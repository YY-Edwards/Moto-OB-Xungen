
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ab00  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000cc00  8000cc00  0000d000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001278  8000ce00  8000ce00  0000d200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a3c  00000004  8000e078  0000e804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00005130  00000a40  8000eab4  0000f240  2**2
                  ALLOC
  7 .comment      00000030  00000000  00000000  0000f240  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00001688  00000000  00000000  0000f270  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00003620  00000000  00000000  000108f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002c40d  00000000  00000000  00013f18  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00007283  00000000  00000000  00040325  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000d41d  00000000  00000000  000475a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003d14  00000000  00000000  000549c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00007f95  00000000  00000000  000586dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0000f391  00000000  00000000  00060671  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 17 .debug_ranges 00001750  00000000  00000000  0006fa08  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c5 08 	sub	pc,pc,-15096

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 98       	ld.ub	r8,r6[0x1]

80002028 <Volume_brdcst_func>:
	//log("Attenuator_Number: %x \n",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("Audio_Parameter: %x \n", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 60       	and	r0,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 03 20 	mov	r10,800
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  800//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3d fc       	mov	r12,-33
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2a a4       	sub	r4,-86
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	ce 00       	breq	80002042 <app_init+0x6>
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 a8       	sub	r8,122
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6a 38       	ld.w	r8,r5[0xc]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 48       	or	r8,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	ce 08       	rjmp	8000225e <ButtonConfig_brdcst_func+0x7a>
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	6d fc       	ld.w	r12,r6[0x7c]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 5c       	eor	r12,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	ce 0c       	rcall	8000228e <ButtonConfig_brdcst_func+0xaa>
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	6d fc       	ld.w	r12,r6[0x7c]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 45       	or	r5,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	ce 18       	rjmp	800022a8 <ButtonConfig_brdcst_func+0xc4>
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	6d fc       	ld.w	r12,r6[0x7c]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	ce 38       	rjmp	800022c0 <ButtonConfig_reply_func>
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	6d fc       	ld.w	r12,r6[0x7c]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	ce 54       	brge	800020d8 <FD_brdcst_func>
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	6d fc       	ld.w	r12,r6[0x7c]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	ce 70       	breq	800020f0 <FD_reply_func+0x4>
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	6d fc       	ld.w	r12,r6[0x7c]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	ce 88       	rjmp	80002352 <ShutDown_brdcst_func+0x12>
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	6d fc       	ld.w	r12,r6[0x7c]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	ce a0       	breq	8000215e <EnOB_reply_func+0x36>
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	ce b4       	brge	80002164 <EnOB_reply_func+0x3c>
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	ce cc       	rcall	8000236a <ShutDown_brdcst_func+0x2a>
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	ce e8       	rjmp	80002372 <DataSession_reply_func+0x2>

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	cf 00       	breq	800021b2 <SingleDetection_brdcst_func+0x1a>
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	6d fc       	ld.w	r12,r6[0x7c]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	cf 14       	brge	800021c0 <SingleDetection_brdcst_func+0x28>
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	cf 24       	brge	800021c6 <SingleDetection_brdcst_func+0x2e>

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	cf 38       	rjmp	80002480 <TransmitControl_reply_func+0x8>
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	6d fc       	ld.w	r12,r6[0x7c]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	cf 58       	rjmp	8000248c <TransmitControl_reply_func+0x14>
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	cf 6c       	rcall	80002492 <TransmitControl_reply_func+0x1a>
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	cf 84       	brge	8000229a <ButtonConfig_brdcst_func+0xb6>
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	cf a4       	brge	800022a2 <ButtonConfig_brdcst_func+0xbe>
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	cf cc       	rcall	800024aa <TransmitControl_reply_func+0x32>
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	cf f4       	brge	800022b4 <ButtonConfig_brdcst_func+0xd0>
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d0 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d0 40       	acall	0x4

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d0 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	6d fc       	ld.w	r12,r6[0x7c]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	cf 58       	rjmp	800024e8 <AudioRoutingControl_reply_func+0x10>
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d0 7c       	*unknown*

80002304 <BatteryLevel_brdcst_func>:
	
}


void BatteryLevel_brdcst_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	BatteryLevel_brdcast_t *ptr = (BatteryLevel_brdcast_t* )(xcmp->u8);
80002308:	f8 c7 ff fe 	sub	r7,r12,-2
	if(ptr->State == Battery_Okay)
8000230c:	0f 89       	ld.ub	r9,r7[0x0]
8000230e:	30 08       	mov	r8,0
80002310:	f0 09 18 00 	cp.b	r9,r8
80002314:	c0 51       	brne	8000231e <BatteryLevel_brdcst_func+0x1a>
		log("\n Battery Okay\n");
80002316:	48 7c       	lddpc	r12,80002330 <BatteryLevel_brdcst_func+0x2c>
80002318:	f0 1f 00 07 	mcall	80002334 <BatteryLevel_brdcst_func+0x30>
8000231c:	c0 48       	rjmp	80002324 <BatteryLevel_brdcst_func+0x20>
	else
		log("\n Battery Low !!!\n");
8000231e:	48 7c       	lddpc	r12,80002338 <BatteryLevel_brdcst_func+0x34>
80002320:	f0 1f 00 05 	mcall	80002334 <BatteryLevel_brdcst_func+0x30>
		
	//log("\n Battery charge: %X \n" , ptr->Charge);
	//log("\n Battery voltage: %X \n" , ptr->Voltage);
	
	Battery_Flag = ptr->State;
80002324:	0f 89       	ld.ub	r9,r7[0x0]
80002326:	48 68       	lddpc	r8,8000233c <BatteryLevel_brdcst_func+0x38>
80002328:	b0 89       	st.b	r8[0x0],r9

}
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	d0 98       	*unknown*
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	6d fc       	ld.w	r12,r6[0x7c]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	d0 a8       	*unknown*
8000233c:	00 00       	add	r0,r0
8000233e:	0a 41       	or	r1,r5

80002340 <ShutDown_brdcst_func>:
		log("ID:  %X \n", xcmp->u8[2]);
	}
	
}
void ShutDown_brdcst_func(xcmp_fragment_t * xcmp)
{
80002340:	d4 01       	pushm	lr
	if (xcmp->u8[0] == Shut_Down_Device)
80002342:	19 a8       	ld.ub	r8,r12[0x2]
80002344:	30 19       	mov	r9,1
80002346:	f2 08 18 00 	cp.b	r8,r9
8000234a:	c0 51       	brne	80002354 <ShutDown_brdcst_func+0x14>
	{
		log("Shut_Down_Device \n");
8000234c:	48 6c       	lddpc	r12,80002364 <ShutDown_brdcst_func+0x24>
8000234e:	f0 1f 00 07 	mcall	80002368 <ShutDown_brdcst_func+0x28>
80002352:	d8 02       	popm	pc
		
	}
	else if(xcmp->u8[0] == Reset_Device)
80002354:	30 29       	mov	r9,2
80002356:	f2 08 18 00 	cp.b	r8,r9
8000235a:	c0 41       	brne	80002362 <ShutDown_brdcst_func+0x22>
	{
		log("Reset_Device \n");
8000235c:	48 4c       	lddpc	r12,8000236c <ShutDown_brdcst_func+0x2c>
8000235e:	f0 1f 00 03 	mcall	80002368 <ShutDown_brdcst_func+0x28>
80002362:	d8 02       	popm	pc
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	d0 bc       	*unknown*
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	6d fc       	ld.w	r12,r6[0x7c]
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	d0 d0       	acall	0xd

80002370 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002370:	eb cd 40 80 	pushm	r7,lr
80002374:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002376:	19 a9       	ld.ub	r9,r12[0x2]
80002378:	30 08       	mov	r8,0
8000237a:	f0 09 18 00 	cp.b	r9,r8
8000237e:	c1 11       	brne	800023a0 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002380:	49 3c       	lddpc	r12,800023cc <DataSession_reply_func+0x5c>
80002382:	f0 1f 00 14 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
80002386:	0f b8       	ld.ub	r8,r7[0x3]
80002388:	1a d8       	st.w	--sp,r8
8000238a:	49 3c       	lddpc	r12,800023d4 <DataSession_reply_func+0x64>
8000238c:	f0 1f 00 11 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002390:	0f c8       	ld.ub	r8,r7[0x4]
80002392:	1a d8       	st.w	--sp,r8
80002394:	49 1c       	lddpc	r12,800023d8 <DataSession_reply_func+0x68>
80002396:	f0 1f 00 0f 	mcall	800023d0 <DataSession_reply_func+0x60>
8000239a:	2f ed       	sub	sp,-8
8000239c:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
800023a0:	48 fc       	lddpc	r12,800023dc <DataSession_reply_func+0x6c>
800023a2:	f0 1f 00 0c 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
800023a6:	0f a8       	ld.ub	r8,r7[0x2]
800023a8:	1a d8       	st.w	--sp,r8
800023aa:	48 ec       	lddpc	r12,800023e0 <DataSession_reply_func+0x70>
800023ac:	f0 1f 00 09 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
800023b0:	0f b8       	ld.ub	r8,r7[0x3]
800023b2:	1a d8       	st.w	--sp,r8
800023b4:	48 cc       	lddpc	r12,800023e4 <DataSession_reply_func+0x74>
800023b6:	f0 1f 00 07 	mcall	800023d0 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
800023ba:	0f c8       	ld.ub	r8,r7[0x4]
800023bc:	1a d8       	st.w	--sp,r8
800023be:	48 bc       	lddpc	r12,800023e8 <DataSession_reply_func+0x78>
800023c0:	f0 1f 00 04 	mcall	800023d0 <DataSession_reply_func+0x60>
800023c4:	2f dd       	sub	sp,-12
800023c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800023ca:	00 00       	add	r0,r0
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	d0 e0       	acall	0xe
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	6d fc       	ld.w	r12,r6[0x7c]
800023d4:	80 00       	ld.sh	r0,r0[0x0]
800023d6:	d0 f0       	acall	0xf
800023d8:	80 00       	ld.sh	r0,r0[0x0]
800023da:	d0 fc       	*unknown*
800023dc:	80 00       	ld.sh	r0,r0[0x0]
800023de:	d1 08       	*unknown*
800023e0:	80 00       	ld.sh	r0,r0[0x0]
800023e2:	d1 18       	*unknown*
800023e4:	80 00       	ld.sh	r0,r0[0x0]
800023e6:	d1 28       	*unknown*
800023e8:	80 00       	ld.sh	r0,r0[0x0]
800023ea:	d1 34       	*unknown*

800023ec <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023ec:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
800023f0:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
800023f4:	0f 98       	ld.ub	r8,r7[0x1]
800023f6:	1a d8       	st.w	--sp,r8
800023f8:	48 bc       	lddpc	r12,80002424 <CallControl_brdcst_func+0x38>
800023fa:	f0 1f 00 0c 	mcall	80002428 <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
800023fe:	2f fd       	sub	sp,-4
80002400:	0f 99       	ld.ub	r9,r7[0x1]
80002402:	30 38       	mov	r8,3
80002404:	f0 09 18 00 	cp.b	r9,r8
80002408:	c0 41       	brne	80002410 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000240a:	30 09       	mov	r9,0
8000240c:	48 88       	lddpc	r8,8000242c <CallControl_brdcst_func+0x40>
8000240e:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002410:	0f 99       	ld.ub	r9,r7[0x1]
80002412:	30 48       	mov	r8,4
80002414:	f0 09 18 00 	cp.b	r9,r8
80002418:	c0 41       	brne	80002420 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000241a:	30 19       	mov	r9,1
8000241c:	48 48       	lddpc	r8,8000242c <CallControl_brdcst_func+0x40>
8000241e:	b0 89       	st.b	r8[0x0],r9
80002420:	e3 cd 80 80 	ldm	sp++,r7,pc
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	d1 40       	acall	0x14
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	6d fc       	ld.w	r12,r6[0x7c]
8000242c:	00 00       	add	r0,r0
8000242e:	0a 47       	or	r7,r5

80002430 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002430:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002434:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
80002438:	0f 99       	ld.ub	r9,r7[0x1]
8000243a:	30 08       	mov	r8,0
8000243c:	f0 09 18 00 	cp.b	r9,r8
80002440:	c0 71       	brne	8000244e <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
80002442:	48 ac       	lddpc	r12,80002468 <TransmitControl_brdcst_func+0x38>
80002444:	f0 1f 00 0a 	mcall	8000246c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
80002448:	30 09       	mov	r9,0
8000244a:	48 a8       	lddpc	r8,80002470 <TransmitControl_brdcst_func+0x40>
8000244c:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
8000244e:	0f 99       	ld.ub	r9,r7[0x1]
80002450:	30 18       	mov	r8,1
80002452:	f0 09 18 00 	cp.b	r9,r8
80002456:	c0 71       	brne	80002464 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
80002458:	48 7c       	lddpc	r12,80002474 <TransmitControl_brdcst_func+0x44>
8000245a:	f0 1f 00 05 	mcall	8000246c <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
8000245e:	30 19       	mov	r9,1
80002460:	48 48       	lddpc	r8,80002470 <TransmitControl_brdcst_func+0x40>
80002462:	b0 89       	st.b	r8[0x0],r9
80002464:	e3 cd 80 80 	ldm	sp++,r7,pc
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d1 58       	*unknown*
8000246c:	80 00       	ld.sh	r0,r0[0x0]
8000246e:	6d fc       	ld.w	r12,r6[0x7c]
80002470:	00 00       	add	r0,r0
80002472:	0a 46       	or	r6,r5
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	d1 70       	acall	0x17

80002478 <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
80002478:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
8000247c:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002480:	0f 89       	ld.ub	r9,r7[0x0]
80002482:	30 08       	mov	r8,0
80002484:	f0 09 18 00 	cp.b	r9,r8
80002488:	c1 61       	brne	800024b4 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000248a:	48 ec       	lddpc	r12,800024c0 <TransmitControl_reply_func+0x48>
8000248c:	f0 1f 00 0e 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002490:	0f 98       	ld.ub	r8,r7[0x1]
80002492:	1a d8       	st.w	--sp,r8
80002494:	48 dc       	lddpc	r12,800024c8 <TransmitControl_reply_func+0x50>
80002496:	f0 1f 00 0c 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000249a:	0f a8       	ld.ub	r8,r7[0x2]
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	48 cc       	lddpc	r12,800024cc <TransmitControl_reply_func+0x54>
800024a0:	f0 1f 00 09 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
800024a4:	0f b8       	ld.ub	r8,r7[0x3]
800024a6:	1a d8       	st.w	--sp,r8
800024a8:	48 ac       	lddpc	r12,800024d0 <TransmitControl_reply_func+0x58>
800024aa:	f0 1f 00 07 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
800024ae:	2f dd       	sub	sp,-12
800024b0:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
800024b4:	48 8c       	lddpc	r12,800024d4 <TransmitControl_reply_func+0x5c>
800024b6:	f0 1f 00 04 	mcall	800024c4 <TransmitControl_reply_func+0x4c>
800024ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800024be:	00 00       	add	r0,r0
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	d1 84       	*unknown*
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	6d fc       	ld.w	r12,r6[0x7c]
800024c8:	80 00       	ld.sh	r0,r0[0x0]
800024ca:	d1 a0       	acall	0x1a
800024cc:	80 00       	ld.sh	r0,r0[0x0]
800024ce:	d1 b4       	*unknown*
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	d1 d0       	acall	0x1d
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	d1 e0       	acall	0x1e

800024d8 <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
800024d8:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800024da:	19 a9       	ld.ub	r9,r12[0x2]
800024dc:	30 08       	mov	r8,0
800024de:	f0 09 18 00 	cp.b	r9,r8
800024e2:	c0 51       	brne	800024ec <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
800024e4:	48 4c       	lddpc	r12,800024f4 <AudioRoutingControl_reply_func+0x1c>
800024e6:	f0 1f 00 05 	mcall	800024f8 <AudioRoutingControl_reply_func+0x20>
800024ea:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
800024ec:	48 4c       	lddpc	r12,800024fc <AudioRoutingControl_reply_func+0x24>
800024ee:	f0 1f 00 03 	mcall	800024f8 <AudioRoutingControl_reply_func+0x20>
800024f2:	d8 02       	popm	pc
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d1 f8       	*unknown*
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	6d fc       	ld.w	r12,r6[0x7c]
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	d2 08       	*unknown*

80002500 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002500:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002504:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
80002508:	0f 89       	ld.ub	r9,r7[0x0]
8000250a:	30 08       	mov	r8,0
8000250c:	f0 09 18 00 	cp.b	r9,r8
80002510:	c1 b1       	brne	80002546 <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002512:	0f b8       	ld.ub	r8,r7[0x3]
80002514:	31 09       	mov	r9,16
80002516:	f2 08 18 00 	cp.b	r8,r9
8000251a:	c0 f1       	brne	80002538 <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
8000251c:	48 dc       	lddpc	r12,80002550 <Volume_reply_func+0x50>
8000251e:	f0 1f 00 0e 	mcall	80002554 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002522:	0f 99       	ld.ub	r9,r7[0x1]
80002524:	0f a8       	ld.ub	r8,r7[0x2]
80002526:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000252a:	1a d8       	st.w	--sp,r8
8000252c:	48 bc       	lddpc	r12,80002558 <Volume_reply_func+0x58>
8000252e:	f0 1f 00 0a 	mcall	80002554 <Volume_reply_func+0x54>
80002532:	2f fd       	sub	sp,-4
80002534:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
80002538:	1a d8       	st.w	--sp,r8
8000253a:	48 9c       	lddpc	r12,8000255c <Volume_reply_func+0x5c>
8000253c:	f0 1f 00 06 	mcall	80002554 <Volume_reply_func+0x54>
80002540:	2f fd       	sub	sp,-4
80002542:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
80002546:	48 7c       	lddpc	r12,80002560 <Volume_reply_func+0x60>
80002548:	f0 1f 00 03 	mcall	80002554 <Volume_reply_func+0x54>
8000254c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002550:	80 00       	ld.sh	r0,r0[0x0]
80002552:	d2 1c       	*unknown*
80002554:	80 00       	ld.sh	r0,r0[0x0]
80002556:	6d fc       	ld.w	r12,r6[0x7c]
80002558:	80 00       	ld.sh	r0,r0[0x0]
8000255a:	d2 30       	acall	0x23
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	d2 4c       	*unknown*
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	d2 64       	*unknown*

80002564 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
80002564:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
80002566:	19 d9       	ld.ub	r9,r12[0x5]
80002568:	30 08       	mov	r8,0
8000256a:	f0 09 18 00 	cp.b	r9,r8
8000256e:	c0 81       	brne	8000257e <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002570:	10 99       	mov	r9,r8
80002572:	48 78       	lddpc	r8,8000258c <spk_brdcst_func+0x28>
80002574:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
80002576:	48 7c       	lddpc	r12,80002590 <spk_brdcst_func+0x2c>
80002578:	f0 1f 00 07 	mcall	80002594 <spk_brdcst_func+0x30>
8000257c:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
8000257e:	30 19       	mov	r9,1
80002580:	48 38       	lddpc	r8,8000258c <spk_brdcst_func+0x28>
80002582:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002584:	48 5c       	lddpc	r12,80002598 <spk_brdcst_func+0x34>
80002586:	f0 1f 00 04 	mcall	80002594 <spk_brdcst_func+0x30>
8000258a:	d8 02       	popm	pc
8000258c:	00 00       	add	r0,r0
8000258e:	0a 40       	or	r0,r5
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	d2 7c       	*unknown*
80002594:	80 00       	ld.sh	r0,r0[0x0]
80002596:	6d fc       	ld.w	r12,r6[0x7c]
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	d2 8c       	*unknown*

8000259c <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
8000259c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000259e:	19 a9       	ld.ub	r9,r12[0x2]
800025a0:	30 08       	mov	r8,0
800025a2:	f0 09 18 00 	cp.b	r9,r8
800025a6:	c0 f1       	brne	800025c4 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
800025a8:	19 e9       	ld.ub	r9,r12[0x6]
800025aa:	f0 09 18 00 	cp.b	r9,r8
800025ae:	c0 40       	breq	800025b6 <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
800025b0:	30 19       	mov	r9,1
800025b2:	48 98       	lddpc	r8,800025d4 <spk_reply_func+0x38>
800025b4:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
800025b6:	19 e8       	ld.ub	r8,r12[0x6]
800025b8:	1a d8       	st.w	--sp,r8
800025ba:	48 8c       	lddpc	r12,800025d8 <spk_reply_func+0x3c>
800025bc:	f0 1f 00 08 	mcall	800025dc <spk_reply_func+0x40>
800025c0:	2f fd       	sub	sp,-4
800025c2:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
800025c4:	30 09       	mov	r9,0
800025c6:	48 48       	lddpc	r8,800025d4 <spk_reply_func+0x38>
800025c8:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
800025ca:	48 6c       	lddpc	r12,800025e0 <spk_reply_func+0x44>
800025cc:	f0 1f 00 04 	mcall	800025dc <spk_reply_func+0x40>
800025d0:	d8 02       	popm	pc
800025d2:	00 00       	add	r0,r0
800025d4:	00 00       	add	r0,r0
800025d6:	0a 40       	or	r0,r5
800025d8:	80 00       	ld.sh	r0,r0[0x0]
800025da:	d2 98       	*unknown*
800025dc:	80 00       	ld.sh	r0,r0[0x0]
800025de:	6d fc       	ld.w	r12,r6[0x7c]
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	d2 a8       	*unknown*

800025e4 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
800025e4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
800025e8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
800025ec:	0f a9       	ld.ub	r9,r7[0x2]
800025ee:	30 08       	mov	r8,0
800025f0:	f0 09 18 00 	cp.b	r9,r8
800025f4:	c0 71       	brne	80002602 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
800025f6:	48 dc       	lddpc	r12,80002628 <mic_brdcst_func+0x44>
800025f8:	f0 1f 00 0d 	mcall	8000262c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
800025fc:	30 09       	mov	r9,0
800025fe:	48 d8       	lddpc	r8,80002630 <mic_brdcst_func+0x4c>
80002600:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002602:	0f a9       	ld.ub	r9,r7[0x2]
80002604:	31 18       	mov	r8,17
80002606:	f0 09 18 00 	cp.b	r9,r8
8000260a:	c0 d1       	brne	80002624 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
8000260c:	48 ac       	lddpc	r12,80002634 <mic_brdcst_func+0x50>
8000260e:	f0 1f 00 08 	mcall	8000262c <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002612:	48 89       	lddpc	r9,80002630 <mic_brdcst_func+0x4c>
80002614:	30 18       	mov	r8,1
80002616:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
80002618:	13 89       	ld.ub	r9,r9[0x0]
8000261a:	f0 09 18 00 	cp.b	r9,r8
8000261e:	c0 31       	brne	80002624 <mic_brdcst_func+0x40>
80002620:	48 68       	lddpc	r8,80002638 <mic_brdcst_func+0x54>
80002622:	11 88       	ld.ub	r8,r8[0x0]
80002624:	e3 cd 80 80 	ldm	sp++,r7,pc
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	d2 b4       	*unknown*
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	6d fc       	ld.w	r12,r6[0x7c]
80002630:	00 00       	add	r0,r0
80002632:	0a 54       	eor	r4,r5
80002634:	80 00       	ld.sh	r0,r0[0x0]
80002636:	d2 c8       	*unknown*
80002638:	00 00       	add	r0,r0
8000263a:	0a 47       	or	r7,r5

8000263c <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
8000263c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
80002640:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
80002644:	49 ac       	lddpc	r12,800026ac <mic_reply_func+0x70>
80002646:	f0 1f 00 1b 	mcall	800026b0 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
8000264a:	0f 89       	ld.ub	r9,r7[0x0]
8000264c:	30 08       	mov	r8,0
8000264e:	f0 09 18 00 	cp.b	r9,r8
80002652:	c2 71       	brne	800026a0 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
80002654:	0f 98       	ld.ub	r8,r7[0x1]
80002656:	30 29       	mov	r9,2
80002658:	f2 08 18 00 	cp.b	r8,r9
8000265c:	c1 b1       	brne	80002692 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
8000265e:	49 6c       	lddpc	r12,800026b4 <mic_reply_func+0x78>
80002660:	f0 1f 00 14 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
80002664:	0f a8       	ld.ub	r8,r7[0x2]
80002666:	1a d8       	st.w	--sp,r8
80002668:	49 4c       	lddpc	r12,800026b8 <mic_reply_func+0x7c>
8000266a:	f0 1f 00 12 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
8000266e:	0f b8       	ld.ub	r8,r7[0x3]
80002670:	1a d8       	st.w	--sp,r8
80002672:	49 3c       	lddpc	r12,800026bc <mic_reply_func+0x80>
80002674:	f0 1f 00 0f 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
80002678:	0f c8       	ld.ub	r8,r7[0x4]
8000267a:	1a d8       	st.w	--sp,r8
8000267c:	49 1c       	lddpc	r12,800026c0 <mic_reply_func+0x84>
8000267e:	f0 1f 00 0d 	mcall	800026b0 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002682:	0f d8       	ld.ub	r8,r7[0x5]
80002684:	1a d8       	st.w	--sp,r8
80002686:	49 0c       	lddpc	r12,800026c4 <mic_reply_func+0x88>
80002688:	f0 1f 00 0a 	mcall	800026b0 <mic_reply_func+0x74>
8000268c:	2f cd       	sub	sp,-16
8000268e:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002692:	1a d8       	st.w	--sp,r8
80002694:	48 dc       	lddpc	r12,800026c8 <mic_reply_func+0x8c>
80002696:	f0 1f 00 07 	mcall	800026b0 <mic_reply_func+0x74>
8000269a:	2f fd       	sub	sp,-4
8000269c:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
800026a0:	48 bc       	lddpc	r12,800026cc <mic_reply_func+0x90>
800026a2:	f0 1f 00 04 	mcall	800026b0 <mic_reply_func+0x74>
800026a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026aa:	00 00       	add	r0,r0
800026ac:	80 00       	ld.sh	r0,r0[0x0]
800026ae:	d2 dc       	*unknown*
800026b0:	80 00       	ld.sh	r0,r0[0x0]
800026b2:	6d fc       	ld.w	r12,r6[0x7c]
800026b4:	80 00       	ld.sh	r0,r0[0x0]
800026b6:	d2 ec       	*unknown*
800026b8:	80 00       	ld.sh	r0,r0[0x0]
800026ba:	d3 00       	acall	0x30
800026bc:	80 00       	ld.sh	r0,r0[0x0]
800026be:	d3 14       	*unknown*
800026c0:	80 00       	ld.sh	r0,r0[0x0]
800026c2:	d3 30       	acall	0x33
800026c4:	80 00       	ld.sh	r0,r0[0x0]
800026c6:	d3 48       	*unknown*
800026c8:	80 00       	ld.sh	r0,r0[0x0]
800026ca:	d3 60       	acall	0x36
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	d3 78       	*unknown*

800026d0 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
800026d0:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
800026d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
800026d8:	48 bc       	lddpc	r12,80002704 <dcm_brdcst_func+0x34>
800026da:	f0 1f 00 0c 	mcall	80002708 <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
800026de:	0f 88       	ld.ub	r8,r7[0x0]
800026e0:	1a d8       	st.w	--sp,r8
800026e2:	48 bc       	lddpc	r12,8000270c <dcm_brdcst_func+0x3c>
800026e4:	f0 1f 00 09 	mcall	80002708 <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
800026e8:	0f a8       	ld.ub	r8,r7[0x2]
800026ea:	1a d8       	st.w	--sp,r8
800026ec:	48 9c       	lddpc	r12,80002710 <dcm_brdcst_func+0x40>
800026ee:	f0 1f 00 07 	mcall	80002708 <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
800026f2:	0f 98       	ld.ub	r8,r7[0x1]
800026f4:	1a d8       	st.w	--sp,r8
800026f6:	48 8c       	lddpc	r12,80002714 <dcm_brdcst_func+0x44>
800026f8:	f0 1f 00 04 	mcall	80002708 <dcm_brdcst_func+0x38>
800026fc:	2f dd       	sub	sp,-12
	
	
}
800026fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002702:	00 00       	add	r0,r0
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d3 88       	*unknown*
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	6d fc       	ld.w	r12,r6[0x7c]
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d3 9c       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d3 b0       	acall	0x3b
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	d3 c8       	*unknown*

80002718 <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
80002718:	eb cd 40 80 	pushm	r7,lr
8000271c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000271e:	19 a9       	ld.ub	r9,r12[0x2]
80002720:	30 08       	mov	r8,0
80002722:	f0 09 18 00 	cp.b	r9,r8
80002726:	c1 b1       	brne	8000275c <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
80002728:	19 b8       	ld.ub	r8,r12[0x3]
8000272a:	30 19       	mov	r9,1
8000272c:	f2 08 18 00 	cp.b	r8,r9
80002730:	c0 51       	brne	8000273a <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002732:	48 ec       	lddpc	r12,80002768 <dcm_reply_func+0x50>
80002734:	f0 1f 00 0e 	mcall	8000276c <dcm_reply_func+0x54>
80002738:	c0 a8       	rjmp	8000274c <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000273a:	58 08       	cp.w	r8,0
8000273c:	c0 51       	brne	80002746 <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
8000273e:	48 dc       	lddpc	r12,80002770 <dcm_reply_func+0x58>
80002740:	f0 1f 00 0b 	mcall	8000276c <dcm_reply_func+0x54>
80002744:	c0 48       	rjmp	8000274c <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
80002746:	48 cc       	lddpc	r12,80002774 <dcm_reply_func+0x5c>
80002748:	f0 1f 00 09 	mcall	8000276c <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
8000274c:	0f d8       	ld.ub	r8,r7[0x5]
8000274e:	1a d8       	st.w	--sp,r8
80002750:	48 ac       	lddpc	r12,80002778 <dcm_reply_func+0x60>
80002752:	f0 1f 00 07 	mcall	8000276c <dcm_reply_func+0x54>
80002756:	2f fd       	sub	sp,-4
80002758:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
8000275c:	48 8c       	lddpc	r12,8000277c <dcm_reply_func+0x64>
8000275e:	f0 1f 00 04 	mcall	8000276c <dcm_reply_func+0x54>
80002762:	e3 cd 80 80 	ldm	sp++,r7,pc
80002766:	00 00       	add	r0,r0
80002768:	80 00       	ld.sh	r0,r0[0x0]
8000276a:	d3 e4       	*unknown*
8000276c:	80 00       	ld.sh	r0,r0[0x0]
8000276e:	6d fc       	ld.w	r12,r6[0x7c]
80002770:	80 00       	ld.sh	r0,r0[0x0]
80002772:	d3 f8       	*unknown*
80002774:	80 00       	ld.sh	r0,r0[0x0]
80002776:	d4 0c       	*unknown*
80002778:	80 00       	ld.sh	r0,r0[0x0]
8000277a:	d4 20       	acall	0x42
8000277c:	80 00       	ld.sh	r0,r0[0x0]
8000277e:	d4 2c       	*unknown*

80002780 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002780:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002782:	19 a9       	ld.ub	r9,r12[0x2]
80002784:	30 08       	mov	r8,0
80002786:	f0 09 18 00 	cp.b	r9,r8
8000278a:	c0 51       	brne	80002794 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
8000278c:	48 4c       	lddpc	r12,8000279c <ToneControl_reply_func+0x1c>
8000278e:	f0 1f 00 05 	mcall	800027a0 <ToneControl_reply_func+0x20>
80002792:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002794:	48 4c       	lddpc	r12,800027a4 <ToneControl_reply_func+0x24>
80002796:	f0 1f 00 03 	mcall	800027a0 <ToneControl_reply_func+0x20>
8000279a:	d8 02       	popm	pc
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	d4 38       	*unknown*
800027a0:	80 00       	ld.sh	r0,r0[0x0]
800027a2:	6d fc       	ld.w	r12,r6[0x7c]
800027a4:	80 00       	ld.sh	r0,r0[0x0]
800027a6:	d4 44       	*unknown*

800027a8 <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
800027a8:	d4 31       	pushm	r0-r7,lr
800027aa:	20 1d       	sub	sp,4
	static  portTickType xLastWakeTime;
	const portTickType xFrequency = 4000;//2s,定时问题已经修正。2s x  2000hz = 4000
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	Message_Protocol_t *m_buff = (Message_Protocol_t *) pvPortMalloc(sizeof(Message_Protocol_t));
800027ac:	31 ac       	mov	r12,26
800027ae:	f0 1f 00 37 	mcall	80002888 <app_cfg+0xe0>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	static xgflash_status_t status = XG_ERROR;
	xLastWakeTime = xTaskGetTickCount();
800027b2:	f0 1f 00 37 	mcall	8000288c <app_cfg+0xe4>
800027b6:	4b 78       	lddpc	r8,80002890 <app_cfg+0xe8>
800027b8:	91 0c       	st.w	r8[0x0],r12
	
	/* 'Give' the semaphore to unblock the task. */
	 if( xBinarySemaphore != NULL ){
800027ba:	4b 78       	lddpc	r8,80002894 <app_cfg+0xec>
800027bc:	70 08       	ld.w	r8,r8[0x0]
800027be:	58 08       	cp.w	r8,0
800027c0:	c0 80       	breq	800027d0 <app_cfg+0x28>
		xSemaphoreGive(xBinarySemaphore);
800027c2:	4b 58       	lddpc	r8,80002894 <app_cfg+0xec>
800027c4:	70 0c       	ld.w	r12,r8[0x0]
800027c6:	30 09       	mov	r9,0
800027c8:	12 9a       	mov	r10,r9
800027ca:	12 9b       	mov	r11,r9
800027cc:	f0 1f 00 33 	mcall	80002898 <app_cfg+0xf0>
	 }
		
	for(;;)
	{
		switch(OB_State)
800027d0:	4b 36       	lddpc	r6,8000289c <app_cfg+0xf4>
			

					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
					
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027d2:	4b 41       	lddpc	r1,800028a0 <app_cfg+0xf8>
800027d4:	30 05       	mov	r5,0
800027d6:	e0 67 0f a0 	mov	r7,4000
							
								log("receive Okay!\n");		
								do 
								{
									log("wait message Ack\n");	
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
800027da:	4a f3       	lddpc	r3,80002894 <app_cfg+0xec>
							if(data_ptr!=NULL){//resend message
							
								log("receive Okay!\n");		
								do 
								{
									log("wait message Ack\n");	
800027dc:	4b 22       	lddpc	r2,800028a4 <app_cfg+0xfc>
		xSemaphoreGive(xBinarySemaphore);
	 }
		
	for(;;)
	{
		switch(OB_State)
800027de:	6c 08       	ld.w	r8,r6[0x0]
800027e0:	58 08       	cp.w	r8,0
800027e2:	c0 40       	breq	800027ea <app_cfg+0x42>
800027e4:	58 38       	cp.w	r8,3
800027e6:	c4 b1       	brne	8000287c <app_cfg+0xd4>
800027e8:	c1 f8       	rjmp	80002826 <app_cfg+0x7e>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
800027ea:	4b 08       	lddpc	r8,800028a8 <app_cfg+0x100>
800027ec:	70 08       	ld.w	r8,r8[0x0]
800027ee:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800027f2:	58 38       	cp.w	r8,3
800027f4:	c1 21       	brne	80002818 <app_cfg+0x70>
800027f6:	4a e8       	lddpc	r8,800028ac <app_cfg+0x104>
800027f8:	11 88       	ld.ub	r8,r8[0x0]
800027fa:	58 08       	cp.w	r8,0
800027fc:	c0 e1       	brne	80002818 <app_cfg+0x70>
				{
					connect_flag=1;
800027fe:	30 19       	mov	r9,1
80002800:	4a b8       	lddpc	r8,800028ac <app_cfg+0x104>
80002802:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
80002804:	30 cb       	mov	r11,12
80002806:	30 1c       	mov	r12,1
80002808:	f0 1f 00 2a 	mcall	800028b0 <app_cfg+0x108>
					OB_State = OB_WAITINGAPPTASK;
8000280c:	30 38       	mov	r8,3
8000280e:	8d 08       	st.w	r6[0x0],r8
					log("connect OB okay!\n");
80002810:	4a 9c       	lddpc	r12,800028b4 <app_cfg+0x10c>
80002812:	f0 1f 00 2a 	mcall	800028b8 <app_cfg+0x110>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002816:	c3 38       	rjmp	8000287c <app_cfg+0xd4>
					OB_State = OB_WAITINGAPPTASK;
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002818:	d7 03       	nop
					nop();
8000281a:	d7 03       	nop
					nop();
8000281c:	d7 03       	nop
					log("connecting...\n");
8000281e:	4a 8c       	lddpc	r12,800028bc <app_cfg+0x114>
80002820:	f0 1f 00 26 	mcall	800028b8 <app_cfg+0x110>
80002824:	c2 c8       	rjmp	8000287c <app_cfg+0xd4>
			

					//if (xSemaphoreTake(xBinarySemaphore, (1000*2) / portTICK_RATE_MS) == pdPASS)
					{
					
						if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002826:	62 0c       	ld.w	r12,r1[0x0]
80002828:	0a 99       	mov	r9,r5
8000282a:	0e 9a       	mov	r10,r7
8000282c:	1a 9b       	mov	r11,sp
8000282e:	f0 1f 00 25 	mcall	800028c0 <app_cfg+0x118>
80002832:	58 1c       	cp.w	r12,1
80002834:	c2 01       	brne	80002874 <app_cfg+0xcc>
						{
							if(data_ptr!=NULL){//resend message
80002836:	40 08       	lddsp	r8,sp[0x0]
80002838:	58 08       	cp.w	r8,0
8000283a:	c1 d0       	breq	80002874 <app_cfg+0xcc>
							
								log("receive Okay!\n");		
8000283c:	4a 2c       	lddpc	r12,800028c4 <app_cfg+0x11c>
8000283e:	f0 1f 00 1f 	mcall	800028b8 <app_cfg+0x110>
								do 
								{
									log("wait message Ack\n");	
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
80002842:	e0 64 27 10 	mov	r4,10000
							if(data_ptr!=NULL){//resend message
							
								log("receive Okay!\n");		
								do 
								{
									log("wait message Ack\n");	
80002846:	04 9c       	mov	r12,r2
80002848:	f0 1f 00 1c 	mcall	800028b8 <app_cfg+0x110>
								} while (xSemaphoreTake(xBinarySemaphore, (5000*2) / portTICK_RATE_MS) == pdFALSE);
8000284c:	66 0c       	ld.w	r12,r3[0x0]
8000284e:	0a 99       	mov	r9,r5
80002850:	08 9a       	mov	r10,r4
80002852:	0a 9b       	mov	r11,r5
80002854:	f0 1f 00 1b 	mcall	800028c0 <app_cfg+0x118>
80002858:	cf 70       	breq	80002846 <app_cfg+0x9e>
												
								xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);								
8000285a:	36 4a       	mov	r10,100
8000285c:	31 ab       	mov	r11,26
8000285e:	40 0c       	lddsp	r12,sp[0x0]
80002860:	f0 1f 00 1a 	mcall	800028c8 <app_cfg+0x120>
								set_message_store(data_ptr);
80002864:	49 a8       	lddpc	r8,800028cc <app_cfg+0x124>
80002866:	70 0c       	ld.w	r12,r8[0x0]
80002868:	40 0b       	lddsp	r11,sp[0x0]
8000286a:	f0 1f 00 1a 	mcall	800028d0 <app_cfg+0x128>
								log("send message\n");
8000286e:	49 ac       	lddpc	r12,800028d4 <app_cfg+0x12c>
80002870:	f0 1f 00 12 	mcall	800028b8 <app_cfg+0x110>
							}
						
						}
					}
										
					nop();
80002874:	d7 03       	nop
					log("app task run!\n");
80002876:	49 9c       	lddpc	r12,800028d8 <app_cfg+0x130>
80002878:	f0 1f 00 10 	mcall	800028b8 <app_cfg+0x110>
			break;
			default:
			break;
				
		} //End of switch on OB_State.
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
8000287c:	0e 9b       	mov	r11,r7
8000287e:	48 5c       	lddpc	r12,80002890 <app_cfg+0xe8>
80002880:	f0 1f 00 17 	mcall	800028dc <app_cfg+0x134>
	}
80002884:	ca db       	rjmp	800027de <app_cfg+0x36>
80002886:	00 00       	add	r0,r0
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	5e c8       	retvs	r8
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	67 28       	ld.w	r8,r3[0x48]
80002890:	00 00       	add	r0,r0
80002892:	0a 58       	eor	r8,r5
80002894:	00 00       	add	r0,r0
80002896:	0b 74       	ld.ub	r4,--r5
80002898:	80 00       	ld.sh	r0,r0[0x0]
8000289a:	62 1c       	ld.w	r12,r1[0x4]
8000289c:	00 00       	add	r0,r0
8000289e:	0a 50       	eor	r0,r5
800028a0:	00 00       	add	r0,r0
800028a2:	0b 6c       	ld.uh	r12,--r5
800028a4:	80 00       	ld.sh	r0,r0[0x0]
800028a6:	d4 84       	*unknown*
800028a8:	00 00       	add	r0,r0
800028aa:	0d 98       	ld.ub	r8,r6[0x1]
800028ac:	00 00       	add	r0,r0
800028ae:	0a 42       	or	r2,r5
800028b0:	80 00       	ld.sh	r0,r0[0x0]
800028b2:	3f 88       	mov	r8,-8
800028b4:	80 00       	ld.sh	r0,r0[0x0]
800028b6:	d4 50       	acall	0x45
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	6d fc       	ld.w	r12,r6[0x7c]
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	d4 64       	*unknown*
800028c0:	80 00       	ld.sh	r0,r0[0x0]
800028c2:	60 10       	ld.w	r0,r0[0x4]
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	d4 74       	*unknown*
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	3e 50       	mov	r0,-27
800028cc:	00 00       	add	r0,r0
800028ce:	0b 70       	ld.ub	r0,--r5
800028d0:	80 00       	ld.sh	r0,r0[0x0]
800028d2:	2b 24       	sub	r4,-78
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	d4 98       	*unknown*
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	d4 a8       	*unknown*
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	68 d8       	ld.w	r8,r4[0x34]

800028e0 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800028e0:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800028e4:	19 c7       	ld.ub	r7,r12[0x4]
800028e6:	19 d8       	ld.ub	r8,r12[0x5]
800028e8:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800028ec:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800028ee:	48 dc       	lddpc	r12,80002920 <Phyuserinput_brdcst_func+0x40>
800028f0:	f0 1f 00 0d 	mcall	80002924 <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800028f4:	36 08       	mov	r8,96
800028f6:	f0 07 19 00 	cp.h	r7,r8
800028fa:	c1 11       	brne	8000291c <Phyuserinput_brdcst_func+0x3c>
800028fc:	48 b8       	lddpc	r8,80002928 <Phyuserinput_brdcst_func+0x48>
800028fe:	11 89       	ld.ub	r9,r8[0x0]
80002900:	30 18       	mov	r8,1
80002902:	f0 09 18 00 	cp.b	r9,r8
80002906:	c0 b1       	brne	8000291c <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
80002908:	31 4b       	mov	r11,20
8000290a:	30 1c       	mov	r12,1
8000290c:	f0 1f 00 08 	mcall	8000292c <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(200*2 / portTICK_RATE_MS);//延迟200ms
80002910:	e0 6c 01 90 	mov	r12,400
80002914:	f0 1f 00 07 	mcall	80002930 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		//rfid_sendID_message();//send message	
		scan_rfid_save_message();//scan and save message	
80002918:	f0 1f 00 07 	mcall	80002934 <Phyuserinput_brdcst_func+0x54>
8000291c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002920:	80 00       	ld.sh	r0,r0[0x0]
80002922:	d4 b8       	*unknown*
80002924:	80 00       	ld.sh	r0,r0[0x0]
80002926:	6d fc       	ld.w	r12,r6[0x7c]
80002928:	00 00       	add	r0,r0
8000292a:	0a 42       	or	r2,r5
8000292c:	80 00       	ld.sh	r0,r0[0x0]
8000292e:	3f 88       	mov	r8,-8
80002930:	80 00       	ld.sh	r0,r0[0x0]
80002932:	68 90       	ld.w	r0,r4[0x24]
80002934:	80 00       	ld.sh	r0,r0[0x0]
80002936:	4f ec       	lddpc	r12,80002b2c <set_idle_store+0x8>

80002938 <DataSession_brdcst_func>:
	Battery_Flag = ptr->State;

}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002938:	d4 21       	pushm	r4-r7,lr
8000293a:	20 8d       	sub	sp,32
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
8000293c:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002940:	0d 88       	ld.ub	r8,r6[0x0]
80002942:	32 49       	mov	r9,36
80002944:	f2 08 18 00 	cp.b	r8,r9
80002948:	c2 91       	brne	8000299a <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
8000294a:	4b 3c       	lddpc	r12,80002a14 <DataSession_brdcst_func+0xdc>
8000294c:	f0 1f 00 33 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002950:	0d a5       	ld.ub	r5,r6[0x2]
80002952:	0d b8       	ld.ub	r8,r6[0x3]
80002954:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002958:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
8000295a:	0d 98       	ld.ub	r8,r6[0x1]
8000295c:	1a d8       	st.w	--sp,r8
8000295e:	4b 0c       	lddpc	r12,80002a1c <DataSession_brdcst_func+0xe4>
80002960:	f0 1f 00 2e 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
		log("\n\r paylaod_length: %d \n\r",data_length );
80002964:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002968:	1a d8       	st.w	--sp,r8
8000296a:	4a ec       	lddpc	r12,80002a20 <DataSession_brdcst_func+0xe8>
8000296c:	f0 1f 00 2b 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
		for(i=0; i<data_length; i++)
80002970:	2f ed       	sub	sp,-8
80002972:	58 05       	cp.w	r5,0
80002974:	c4 e0       	breq	80002a10 <DataSession_brdcst_func+0xd8>
80002976:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002978:	4a b4       	lddpc	r4,80002a24 <DataSession_brdcst_func+0xec>
8000297a:	ec 07 00 08 	add	r8,r6,r7
8000297e:	11 c8       	ld.ub	r8,r8[0x4]
80002980:	1a d8       	st.w	--sp,r8
80002982:	1a d7       	st.w	--sp,r7
80002984:	08 9c       	mov	r12,r4
80002986:	f0 1f 00 25 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
8000298a:	2f f7       	sub	r7,-1
8000298c:	5c 57       	castu.b	r7
8000298e:	2f ed       	sub	sp,-8
80002990:	ee 05 19 00 	cp.h	r5,r7
80002994:	fe 9b ff f3 	brhi	8000297a <DataSession_brdcst_func+0x42>
80002998:	c3 c8       	rjmp	80002a10 <DataSession_brdcst_func+0xd8>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
8000299a:	1a d8       	st.w	--sp,r8
8000299c:	4a 3c       	lddpc	r12,80002a28 <DataSession_brdcst_func+0xf0>
8000299e:	f0 1f 00 1f 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
		if (ptr->State == DATA_SESSION_TX_Suc)
800029a2:	0d 88       	ld.ub	r8,r6[0x0]
800029a4:	2f fd       	sub	sp,-4
800029a6:	30 39       	mov	r9,3
800029a8:	f2 08 18 00 	cp.b	r8,r9
800029ac:	c0 91       	brne	800029be <DataSession_brdcst_func+0x86>
		{
			log("data transmit success\n");
800029ae:	4a 0c       	lddpc	r12,80002a2c <DataSession_brdcst_func+0xf4>
800029b0:	f0 1f 00 1a 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
800029b4:	30 cb       	mov	r11,12
800029b6:	30 1c       	mov	r12,1
800029b8:	f0 1f 00 1e 	mcall	80002a30 <DataSession_brdcst_func+0xf8>
800029bc:	c2 38       	rjmp	80002a02 <DataSession_brdcst_func+0xca>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800029be:	30 49       	mov	r9,4
800029c0:	f2 08 18 00 	cp.b	r8,r9
800029c4:	c1 f1       	brne	80002a02 <DataSession_brdcst_func+0xca>
		{
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
800029c6:	31 aa       	mov	r10,26
800029c8:	ec cb ff fc 	sub	r11,r6,-4
800029cc:	fa cc ff fe 	sub	r12,sp,-2
800029d0:	f0 1f 00 19 	mcall	80002a34 <DataSession_brdcst_func+0xfc>

			Message_Protocol_t * myptr = get_message_store();	
800029d4:	49 98       	lddpc	r8,80002a38 <DataSession_brdcst_func+0x100>
800029d6:	70 0c       	ld.w	r12,r8[0x0]
800029d8:	f0 1f 00 19 	mcall	80002a3c <DataSession_brdcst_func+0x104>
800029dc:	50 7c       	stdsp	sp[0x1c],r12
			if(NULL != myptr)
800029de:	c0 f0       	breq	800029fc <DataSession_brdcst_func+0xc4>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
800029e0:	31 aa       	mov	r10,26
800029e2:	fa cb ff fe 	sub	r11,sp,-2
800029e6:	f0 1f 00 14 	mcall	80002a34 <DataSession_brdcst_func+0xfc>
				xQueueSend(xg_resend_queue, &myptr, 0);
800029ea:	49 68       	lddpc	r8,80002a40 <DataSession_brdcst_func+0x108>
800029ec:	70 0c       	ld.w	r12,r8[0x0]
800029ee:	30 09       	mov	r9,0
800029f0:	12 9a       	mov	r10,r9
800029f2:	fa cb ff e4 	sub	r11,sp,-28
800029f6:	f0 1f 00 14 	mcall	80002a44 <DataSession_brdcst_func+0x10c>
800029fa:	c0 48       	rjmp	80002a02 <DataSession_brdcst_func+0xca>
			}
			else
			{
				log("myptr: err\n\r" );
800029fc:	49 3c       	lddpc	r12,80002a48 <DataSession_brdcst_func+0x110>
800029fe:	f0 1f 00 07 	mcall	80002a18 <DataSession_brdcst_func+0xe0>
			}
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		
		/* 'Give' the semaphore to unblock the task. */
		xSemaphoreGive(xBinarySemaphore);
80002a02:	49 38       	lddpc	r8,80002a4c <DataSession_brdcst_func+0x114>
80002a04:	70 0c       	ld.w	r12,r8[0x0]
80002a06:	30 09       	mov	r9,0
80002a08:	12 9a       	mov	r10,r9
80002a0a:	12 9b       	mov	r11,r9
80002a0c:	f0 1f 00 0e 	mcall	80002a44 <DataSession_brdcst_func+0x10c>
				//
		//}
		
	}
	
}
80002a10:	2f 8d       	sub	sp,-32
80002a12:	d8 22       	popm	r4-r7,pc
80002a14:	80 00       	ld.sh	r0,r0[0x0]
80002a16:	d4 d8       	*unknown*
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	6d fc       	ld.w	r12,r6[0x7c]
80002a1c:	80 00       	ld.sh	r0,r0[0x0]
80002a1e:	d4 ec       	*unknown*
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	d5 04       	*unknown*
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	d5 20       	acall	0x52
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	d5 38       	*unknown*
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	d5 44       	*unknown*
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	3f 88       	mov	r8,-8
80002a34:	80 00       	ld.sh	r0,r0[0x0]
80002a36:	76 78       	ld.w	r8,r11[0x1c]
80002a38:	00 00       	add	r0,r0
80002a3a:	0b 70       	ld.ub	r0,--r5
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	2c d0       	sub	r0,-51
80002a40:	00 00       	add	r0,r0
80002a42:	0b 6c       	ld.uh	r12,--r5
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	62 1c       	ld.w	r12,r1[0x4]
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	d5 5c       	*unknown*
80002a4c:	00 00       	add	r0,r0
80002a4e:	0b 74       	ld.ub	r4,--r5

80002a50 <DeviceInitializationStatus_brdcst_func>:


//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002a50:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002a52:	19 e8       	ld.ub	r8,r12[0x6]
80002a54:	30 19       	mov	r9,1
80002a56:	f2 08 18 00 	cp.b	r8,r9
80002a5a:	c0 61       	brne	80002a66 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
80002a5c:	48 98       	lddpc	r8,80002a80 <DeviceInitializationStatus_brdcst_func+0x30>
80002a5e:	70 09       	ld.w	r9,r8[0x0]
80002a60:	a1 a9       	sbr	r9,0x0
80002a62:	91 09       	st.w	r8[0x0],r9
80002a64:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
80002a66:	30 29       	mov	r9,2
80002a68:	f2 08 18 00 	cp.b	r8,r9
80002a6c:	c0 80       	breq	80002a7c <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
80002a6e:	48 58       	lddpc	r8,80002a80 <DeviceInitializationStatus_brdcst_func+0x30>
80002a70:	70 09       	ld.w	r9,r8[0x0]
80002a72:	e0 19 ff fc 	andl	r9,0xfffc
80002a76:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
80002a78:	f0 1f 00 03 	mcall	80002a84 <DeviceInitializationStatus_brdcst_func+0x34>
80002a7c:	d8 02       	popm	pc
80002a7e:	00 00       	add	r0,r0
80002a80:	00 00       	add	r0,r0
80002a82:	0d 98       	ld.ub	r8,r6[0x1]
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	3e dc       	mov	r12,-19

80002a88 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002a88:	20 1c       	sub	r12,1
80002a8a:	5c 5c       	castu.b	r12
80002a8c:	31 18       	mov	r8,17
80002a8e:	f0 0c 18 00 	cp.b	r12,r8
80002a92:	e0 88 00 03 	brls	80002a98 <CalculateBurst+0x10>
80002a96:	5e fd       	retal	0
80002a98:	48 28       	lddpc	r8,80002aa0 <CalculateBurst+0x18>
80002a9a:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002a9e:	5e fc       	retal	r12
80002aa0:	80 00       	ld.sh	r0,r0[0x0]
80002aa2:	d5 6c       	*unknown*

80002aa4 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002aa4:	48 38       	lddpc	r8,80002ab0 <payload_init+0xc>
80002aa6:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002aa8:	48 38       	lddpc	r8,80002ab4 <payload_init+0x10>
80002aaa:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002aac:	5e fc       	retal	r12
80002aae:	00 00       	add	r0,r0
80002ab0:	00 00       	add	r0,r0
80002ab2:	0a 64       	and	r4,r5
80002ab4:	00 00       	add	r0,r0
80002ab6:	0a 68       	and	r8,r5

80002ab8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002ab8:	d4 01       	pushm	lr
80002aba:	20 2d       	sub	sp,8
80002abc:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002abe:	30 09       	mov	r9,0
80002ac0:	fa ca ff f8 	sub	r10,sp,-8
80002ac4:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002ac6:	1a 9b       	mov	r11,sp
80002ac8:	f0 1f 00 02 	mcall	80002ad0 <set_idle_store_isr+0x18>
}
80002acc:	2f ed       	sub	sp,-8
80002ace:	d8 02       	popm	pc
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	61 cc       	ld.w	r12,r0[0x70]

80002ad4 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002ad4:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002ad6:	48 48       	lddpc	r8,80002ae4 <payload_rx+0x10>
80002ad8:	70 08       	ld.w	r8,r8[0x0]
80002ada:	18 9b       	mov	r11,r12
80002adc:	10 9c       	mov	r12,r8
80002ade:	f0 1f 00 03 	mcall	80002ae8 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002ae2:	d8 02       	popm	pc
80002ae4:	00 00       	add	r0,r0
80002ae6:	0a a0       	st.w	r5++,r0
80002ae8:	80 00       	ld.sh	r0,r0[0x0]
80002aea:	2a b8       	sub	r8,-85

80002aec <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002aec:	d4 01       	pushm	lr
80002aee:	20 2d       	sub	sp,8
80002af0:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002af2:	58 0c       	cp.w	r12,0
80002af4:	c1 10       	breq	80002b16 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002af6:	30 08       	mov	r8,0
80002af8:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002afa:	98 88       	ld.uh	r8,r12[0x0]
80002afc:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b00:	e0 48 40 00 	cp.w	r8,16384
80002b04:	c0 91       	brne	80002b16 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002b06:	48 68       	lddpc	r8,80002b1c <phy_rx+0x30>
80002b08:	70 0c       	ld.w	r12,r8[0x0]
80002b0a:	30 09       	mov	r9,0
80002b0c:	fa ca ff fc 	sub	r10,sp,-4
80002b10:	1a 9b       	mov	r11,sp
80002b12:	f0 1f 00 04 	mcall	80002b20 <phy_rx+0x34>
		}	

    }
		
 
}
80002b16:	2f ed       	sub	sp,-8
80002b18:	d8 02       	popm	pc
80002b1a:	00 00       	add	r0,r0
80002b1c:	00 00       	add	r0,r0
80002b1e:	0a ac       	st.w	r5++,r12
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	61 cc       	ld.w	r12,r0[0x70]

80002b24 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002b24:	eb cd 40 80 	pushm	r7,lr
80002b28:	20 1d       	sub	sp,4
80002b2a:	fa c7 ff fc 	sub	r7,sp,-4
80002b2e:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002b30:	30 09       	mov	r9,0
80002b32:	12 9a       	mov	r10,r9
80002b34:	1a 9b       	mov	r11,sp
80002b36:	f0 1f 00 03 	mcall	80002b40 <set_idle_store+0x1c>
}
80002b3a:	2f fd       	sub	sp,-4
80002b3c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	62 1c       	ld.w	r12,r1[0x4]

80002b44 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002b44:	d4 01       	pushm	lr
80002b46:	20 1d       	sub	sp,4
80002b48:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002b4a:	98 88       	ld.uh	r8,r12[0x0]
80002b4c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002b50:	e0 48 40 00 	cp.w	r8,16384
80002b54:	c0 d1       	brne	80002b6e <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002b56:	49 08       	lddpc	r8,80002b94 <phy_tx+0x50>
80002b58:	70 08       	ld.w	r8,r8[0x0]
80002b5a:	58 08       	cp.w	r8,0
80002b5c:	c1 a0       	breq	80002b90 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002b5e:	48 e8       	lddpc	r8,80002b94 <phy_tx+0x50>
80002b60:	70 0c       	ld.w	r12,r8[0x0]
80002b62:	30 09       	mov	r9,0
80002b64:	12 9a       	mov	r10,r9
80002b66:	1a 9b       	mov	r11,sp
80002b68:	f0 1f 00 0c 	mcall	80002b98 <phy_tx+0x54>
80002b6c:	c1 28       	rjmp	80002b90 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002b6e:	e0 48 10 00 	cp.w	r8,4096
80002b72:	5f 0a       	sreq	r10
80002b74:	e0 48 20 00 	cp.w	r8,8192
80002b78:	5f 09       	sreq	r9
80002b7a:	f5 e9 10 09 	or	r9,r10,r9
80002b7e:	c0 71       	brne	80002b8c <phy_tx+0x48>
80002b80:	e0 48 50 00 	cp.w	r8,20480
80002b84:	c0 40       	breq	80002b8c <phy_tx+0x48>
80002b86:	e0 48 60 00 	cp.w	r8,24576
80002b8a:	c0 31       	brne	80002b90 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002b8c:	48 48       	lddpc	r8,80002b9c <phy_tx+0x58>
80002b8e:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002b90:	2f fd       	sub	sp,-4
80002b92:	d8 02       	popm	pc
80002b94:	00 00       	add	r0,r0
80002b96:	0a cc       	st.b	r5++,r12
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	62 1c       	ld.w	r12,r1[0x4]
80002b9c:	00 00       	add	r0,r0
80002b9e:	0a c0       	st.b	r5++,r0

80002ba0 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002ba0:	d4 01       	pushm	lr
80002ba2:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002ba4:	30 08       	mov	r8,0
80002ba6:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ba8:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002baa:	1a 9a       	mov	r10,sp
80002bac:	fa cb ff fc 	sub	r11,sp,-4
80002bb0:	f0 1f 00 05 	mcall	80002bc4 <get_idle_store_isr+0x24>
80002bb4:	58 1c       	cp.w	r12,1
80002bb6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002bba:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002bbe:	2f ed       	sub	sp,-8
80002bc0:	d8 02       	popm	pc
80002bc2:	00 00       	add	r0,r0
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	5f 20       	srhs	r0

80002bc8 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002bc8:	eb cd 40 c0 	pushm	r6-r7,lr
80002bcc:	20 1d       	sub	sp,4
80002bce:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002bd0:	4b a8       	lddpc	r8,80002cb8 <phy_tx_func+0xf0>
80002bd2:	70 08       	ld.w	r8,r8[0x0]
80002bd4:	58 08       	cp.w	r8,0
80002bd6:	c6 60       	breq	80002ca2 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002bd8:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002bda:	30 08       	mov	r8,0
80002bdc:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002bde:	4b 88       	lddpc	r8,80002cbc <phy_tx_func+0xf4>
80002be0:	70 08       	ld.w	r8,r8[0x0]
80002be2:	58 18       	cp.w	r8,1
80002be4:	c2 60       	breq	80002c30 <phy_tx_func+0x68>
80002be6:	c0 43       	brcs	80002bee <phy_tx_func+0x26>
80002be8:	58 28       	cp.w	r8,2
80002bea:	c5 c1       	brne	80002ca2 <phy_tx_func+0xda>
80002bec:	c5 58       	rjmp	80002c96 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002bee:	4b 38       	lddpc	r8,80002cb8 <phy_tx_func+0xf0>
80002bf0:	70 0c       	ld.w	r12,r8[0x0]
80002bf2:	1a 9a       	mov	r10,sp
80002bf4:	4b 3b       	lddpc	r11,80002cc0 <phy_tx_func+0xf8>
80002bf6:	f0 1f 00 34 	mcall	80002cc4 <phy_tx_func+0xfc>
80002bfa:	58 1c       	cp.w	r12,1
80002bfc:	c1 41       	brne	80002c24 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002bfe:	4b 18       	lddpc	r8,80002cc0 <phy_tx_func+0xf8>
80002c00:	70 08       	ld.w	r8,r8[0x0]
80002c02:	90 08       	ld.sh	r8,r8[0x0]
80002c04:	10 9a       	mov	r10,r8
80002c06:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002c0a:	4b 09       	lddpc	r9,80002cc8 <phy_tx_func+0x100>
80002c0c:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002c0e:	5c 78       	castu.h	r8
80002c10:	ea 18 ab cd 	orh	r8,0xabcd
80002c14:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002c16:	30 19       	mov	r9,1
80002c18:	4a d8       	lddpc	r8,80002ccc <phy_tx_func+0x104>
80002c1a:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002c1c:	30 19       	mov	r9,1
80002c1e:	4a 88       	lddpc	r8,80002cbc <phy_tx_func+0xf4>
80002c20:	91 09       	st.w	r8[0x0],r9
80002c22:	c4 08       	rjmp	80002ca2 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002c24:	e0 68 5a 5a 	mov	r8,23130
80002c28:	ea 18 ab cd 	orh	r8,0xabcd
80002c2c:	8f 18       	st.w	r7[0x4],r8
80002c2e:	c3 a8       	rjmp	80002ca2 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002c30:	4a 7a       	lddpc	r10,80002ccc <phy_tx_func+0x104>
80002c32:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002c34:	4a 39       	lddpc	r9,80002cc0 <phy_tx_func+0xf8>
80002c36:	72 09       	ld.w	r9,r9[0x0]
80002c38:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002c3c:	b1 69       	lsl	r9,0x10
80002c3e:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002c40:	2f f8       	sub	r8,-1
80002c42:	5c 58       	castu.b	r8
80002c44:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002c46:	4a 1b       	lddpc	r11,80002cc8 <phy_tx_func+0x100>
80002c48:	96 0c       	ld.sh	r12,r11[0x0]
80002c4a:	20 2c       	sub	r12,2
80002c4c:	5c 8c       	casts.h	r12
80002c4e:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002c52:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c54:	30 0b       	mov	r11,0
80002c56:	f6 0a 19 00 	cp.h	r10,r11
80002c5a:	e0 89 00 09 	brgt	80002c6c <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002c5e:	e8 19 00 ba 	orl	r9,0xba
80002c62:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002c64:	30 09       	mov	r9,0
80002c66:	49 68       	lddpc	r8,80002cbc <phy_tx_func+0xf4>
80002c68:	91 09       	st.w	r8[0x0],r9
80002c6a:	c1 c8       	rjmp	80002ca2 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002c6c:	49 5a       	lddpc	r10,80002cc0 <phy_tx_func+0xf8>
80002c6e:	74 0a       	ld.w	r10,r10[0x0]
80002c70:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002c74:	14 49       	or	r9,r10
80002c76:	8f 19       	st.w	r7[0x4],r9
80002c78:	2f f8       	sub	r8,-1
80002c7a:	49 59       	lddpc	r9,80002ccc <phy_tx_func+0x104>
80002c7c:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002c7e:	20 2c       	sub	r12,2
80002c80:	49 28       	lddpc	r8,80002cc8 <phy_tx_func+0x100>
80002c82:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002c84:	30 08       	mov	r8,0
80002c86:	f0 0c 19 00 	cp.h	r12,r8
80002c8a:	e0 89 00 0c 	brgt	80002ca2 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002c8e:	30 29       	mov	r9,2
80002c90:	48 b8       	lddpc	r8,80002cbc <phy_tx_func+0xf4>
80002c92:	91 09       	st.w	r8[0x0],r9
80002c94:	c0 78       	rjmp	80002ca2 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002c96:	fc 18 00 ba 	movh	r8,0xba
80002c9a:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002c9c:	30 09       	mov	r9,0
80002c9e:	48 88       	lddpc	r8,80002cbc <phy_tx_func+0xf4>
80002ca0:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002ca2:	e0 68 5a 5a 	mov	r8,23130
80002ca6:	ea 18 ab cd 	orh	r8,0xabcd
80002caa:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002cac:	30 08       	mov	r8,0
80002cae:	8f 38       	st.w	r7[0xc],r8
}
80002cb0:	2f fd       	sub	sp,-4
80002cb2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cb6:	00 00       	add	r0,r0
80002cb8:	00 00       	add	r0,r0
80002cba:	0a cc       	st.b	r5++,r12
80002cbc:	00 00       	add	r0,r0
80002cbe:	0a 8c       	andn	r12,r5
80002cc0:	00 00       	add	r0,r0
80002cc2:	0a 98       	mov	r8,r5
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	5f 20       	srhs	r0
80002cc8:	00 00       	add	r0,r0
80002cca:	0a b4       	st.h	r5++,r4
80002ccc:	00 00       	add	r0,r0
80002cce:	0a 6c       	and	r12,r5

80002cd0 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002cd0:	d4 01       	pushm	lr
80002cd2:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002cd4:	30 0a       	mov	r10,0
80002cd6:	fa cb ff fc 	sub	r11,sp,-4
80002cda:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002cdc:	14 99       	mov	r9,r10
80002cde:	1a 9b       	mov	r11,sp
80002ce0:	f0 1f 00 05 	mcall	80002cf4 <get_idle_store+0x24>
80002ce4:	58 1c       	cp.w	r12,1
80002ce6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002cea:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002cee:	2f fd       	sub	sp,-4
80002cf0:	d8 02       	popm	pc
80002cf2:	00 00       	add	r0,r0
80002cf4:	80 00       	ld.sh	r0,r0[0x0]
80002cf6:	60 10       	ld.w	r0,r0[0x4]

80002cf8 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002cf8:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002cfa:	48 5b       	lddpc	r11,80002d0c <phy_init+0x14>
80002cfc:	48 5c       	lddpc	r12,80002d10 <phy_init+0x18>
80002cfe:	f0 1f 00 06 	mcall	80002d14 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002d02:	f0 1f 00 06 	mcall	80002d18 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002d06:	f0 1f 00 06 	mcall	80002d1c <phy_init+0x24>
	
}
80002d0a:	d8 02       	popm	pc
80002d0c:	80 00       	ld.sh	r0,r0[0x0]
80002d0e:	2b c8       	sub	r8,-68
80002d10:	80 00       	ld.sh	r0,r0[0x0]
80002d12:	2d 20       	sub	r0,-46
80002d14:	80 00       	ld.sh	r0,r0[0x0]
80002d16:	3d 74       	mov	r4,-41
80002d18:	80 00       	ld.sh	r0,r0[0x0]
80002d1a:	3d 88       	mov	r8,-40
80002d1c:	80 00       	ld.sh	r0,r0[0x0]
80002d1e:	47 34       	lddsp	r4,sp[0x1cc]

80002d20 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002d20:	eb cd 40 e0 	pushm	r5-r7,lr
80002d24:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002d26:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002d2a:	70 08       	ld.w	r8,r8[0x0]
80002d2c:	58 08       	cp.w	r8,0
80002d2e:	e0 80 01 08 	breq	80002f3e <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002d32:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002d34:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002d38:	70 09       	ld.w	r9,r8[0x0]
80002d3a:	2f f9       	sub	r9,-1
80002d3c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002d3e:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002d42:	70 08       	ld.w	r8,r8[0x0]
80002d44:	58 18       	cp.w	r8,1
80002d46:	e0 80 00 85 	breq	80002e50 <phy_rx_func+0x130>
80002d4a:	c0 73       	brcs	80002d58 <phy_rx_func+0x38>
80002d4c:	58 28       	cp.w	r8,2
80002d4e:	c5 c0       	breq	80002e06 <phy_rx_func+0xe6>
80002d50:	58 38       	cp.w	r8,3
80002d52:	e0 81 00 f6 	brne	80002f3e <phy_rx_func+0x21e>
80002d56:	cd 58       	rjmp	80002f00 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002d58:	e0 6a 5a 5a 	mov	r10,23130
80002d5c:	ea 1a ab cd 	orh	r10,0xabcd
80002d60:	14 36       	cp.w	r6,r10
80002d62:	e0 80 00 ee 	breq	80002f3e <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002d66:	ec 08 16 10 	lsr	r8,r6,0x10
80002d6a:	e0 48 ab cd 	cp.w	r8,43981
80002d6e:	e0 81 00 e8 	brne	80002f3e <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002d72:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002d76:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002d7a:	20 28       	sub	r8,2
80002d7c:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002d80:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002d82:	30 09       	mov	r9,0
80002d84:	f2 08 19 00 	cp.h	r8,r9
80002d88:	e0 8a 00 db 	brle	80002f3e <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002d8c:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002d90:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002d92:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002d96:	70 0c       	ld.w	r12,r8[0x0]
80002d98:	f0 1f 03 88 	mcall	80003bb8 <phy_rx_func+0xe98>
80002d9c:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002da0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002da2:	58 0c       	cp.w	r12,0
80002da4:	e0 80 00 cd 	breq	80002f3e <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002da8:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002dac:	90 09       	ld.sh	r9,r8[0x0]
80002dae:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002db2:	2f f9       	sub	r9,-1
80002db4:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002db6:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002dba:	74 0a       	ld.w	r10,r10[0x0]
80002dbc:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002dc0:	76 0b       	ld.w	r11,r11[0x0]
80002dc2:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002dc6:	2f f9       	sub	r9,-1
80002dc8:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002dca:	e2 16 0f 00 	andl	r6,0xf00,COH
80002dce:	e0 46 01 00 	cp.w	r6,256
80002dd2:	c0 c0       	breq	80002dea <phy_rx_func+0xca>
80002dd4:	e0 8b 00 05 	brhi	80002dde <phy_rx_func+0xbe>
80002dd8:	58 06       	cp.w	r6,0
80002dda:	c0 80       	breq	80002dea <phy_rx_func+0xca>
80002ddc:	c0 c8       	rjmp	80002df4 <phy_rx_func+0xd4>
80002dde:	e0 46 02 00 	cp.w	r6,512
80002de2:	c0 40       	breq	80002dea <phy_rx_func+0xca>
80002de4:	e0 46 03 00 	cp.w	r6,768
80002de8:	c0 61       	brne	80002df4 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002dea:	30 29       	mov	r9,2
80002dec:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002df0:	91 09       	st.w	r8[0x0],r9
80002df2:	ca 68       	rjmp	80002f3e <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002df4:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002df8:	70 0c       	ld.w	r12,r8[0x0]
80002dfa:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002dfe:	70 0b       	ld.w	r11,r8[0x0]
80002e00:	f0 1f 03 70 	mcall	80003bc0 <phy_rx_func+0xea0>
80002e04:	c9 d8       	rjmp	80002f3e <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002e06:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002e0a:	b1 86       	lsr	r6,0x10
80002e0c:	14 06       	add	r6,r10
80002e0e:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002e12:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002e14:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002e18:	90 09       	ld.sh	r9,r8[0x0]
80002e1a:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002e1e:	76 0b       	ld.w	r11,r11[0x0]
80002e20:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002e24:	2f f9       	sub	r9,-1
80002e26:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002e28:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002e2c:	92 08       	ld.sh	r8,r9[0x0]
80002e2e:	20 28       	sub	r8,2
80002e30:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002e32:	30 09       	mov	r9,0
80002e34:	f2 08 19 00 	cp.h	r8,r9
80002e38:	e0 8a 00 07 	brle	80002e46 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002e3c:	30 19       	mov	r9,1
80002e3e:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002e42:	91 09       	st.w	r8[0x0],r9
80002e44:	c7 d8       	rjmp	80002f3e <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002e46:	30 39       	mov	r9,3
80002e48:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002e4c:	91 09       	st.w	r8[0x0],r9
80002e4e:	c7 88       	rjmp	80002f3e <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002e50:	ec 0a 14 10 	asr	r10,r6,0x10
80002e54:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002e58:	90 09       	ld.sh	r9,r8[0x0]
80002e5a:	14 09       	add	r9,r10
80002e5c:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002e5e:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002e62:	92 08       	ld.sh	r8,r9[0x0]
80002e64:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002e68:	76 0b       	ld.w	r11,r11[0x0]
80002e6a:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002e6e:	2f f8       	sub	r8,-1
80002e70:	5c 88       	casts.h	r8
80002e72:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002e74:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002e78:	94 09       	ld.sh	r9,r10[0x0]
80002e7a:	20 29       	sub	r9,2
80002e7c:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002e7e:	30 0a       	mov	r10,0
80002e80:	f4 09 19 00 	cp.h	r9,r10
80002e84:	e0 89 00 20 	brgt	80002ec4 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002e88:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002e8c:	e0 46 00 ba 	cp.w	r6,186
80002e90:	c0 d1       	brne	80002eaa <phy_rx_func+0x18a>
80002e92:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002e96:	90 09       	ld.sh	r9,r8[0x0]
80002e98:	f4 09 19 00 	cp.h	r9,r10
80002e9c:	c0 71       	brne	80002eaa <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002e9e:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002ea2:	70 0c       	ld.w	r12,r8[0x0]
80002ea4:	f0 1f 03 49 	mcall	80003bc8 <phy_rx_func+0xea8>
80002ea8:	c0 98       	rjmp	80002eba <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002eaa:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002eae:	70 0c       	ld.w	r12,r8[0x0]
80002eb0:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002eb4:	70 0b       	ld.w	r11,r8[0x0]
80002eb6:	f0 1f 03 43 	mcall	80003bc0 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002eba:	30 09       	mov	r9,0
80002ebc:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002ec0:	91 09       	st.w	r8[0x0],r9
80002ec2:	c3 e8       	rjmp	80002f3e <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002ec4:	5c 86       	casts.h	r6
80002ec6:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002eca:	92 0a       	ld.sh	r10,r9[0x0]
80002ecc:	0c 0a       	add	r10,r6
80002ece:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002ed0:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002ed4:	72 09       	ld.w	r9,r9[0x0]
80002ed6:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002eda:	2f f8       	sub	r8,-1
80002edc:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002ee0:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002ee2:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002ee6:	92 08       	ld.sh	r8,r9[0x0]
80002ee8:	20 28       	sub	r8,2
80002eea:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002eec:	30 09       	mov	r9,0
80002eee:	f2 08 19 00 	cp.h	r8,r9
80002ef2:	e0 89 00 26 	brgt	80002f3e <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002ef6:	30 39       	mov	r9,3
80002ef8:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002efc:	91 09       	st.w	r8[0x0],r9
80002efe:	c2 08       	rjmp	80002f3e <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002f00:	e6 16 00 ff 	andh	r6,0xff,COH
80002f04:	fc 19 00 ba 	movh	r9,0xba
80002f08:	12 36       	cp.w	r6,r9
80002f0a:	c0 e1       	brne	80002f26 <phy_rx_func+0x206>
80002f0c:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002f10:	90 09       	ld.sh	r9,r8[0x0]
80002f12:	30 08       	mov	r8,0
80002f14:	f0 09 19 00 	cp.h	r9,r8
80002f18:	c0 71       	brne	80002f26 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002f1a:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002f1e:	70 0c       	ld.w	r12,r8[0x0]
80002f20:	f0 1f 03 2a 	mcall	80003bc8 <phy_rx_func+0xea8>
80002f24:	c0 98       	rjmp	80002f36 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002f26:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002f2a:	70 0c       	ld.w	r12,r8[0x0]
80002f2c:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002f30:	70 0b       	ld.w	r11,r8[0x0]
80002f32:	f0 1f 03 24 	mcall	80003bc0 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002f36:	30 09       	mov	r9,0
80002f38:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002f3c:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002f3e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002f42:	11 89       	ld.ub	r9,r8[0x0]
80002f44:	30 08       	mov	r8,0
80002f46:	f0 09 18 00 	cp.b	r9,r8
80002f4a:	c1 31       	brne	80002f70 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002f4c:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002f50:	6c 0c       	ld.w	r12,r6[0x0]
80002f52:	f0 1f 03 1a 	mcall	80003bb8 <phy_rx_func+0xe98>
80002f56:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002f5a:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002f5c:	6c 0c       	ld.w	r12,r6[0x0]
80002f5e:	f0 1f 03 17 	mcall	80003bb8 <phy_rx_func+0xe98>
80002f62:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002f66:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002f68:	30 19       	mov	r9,1
80002f6a:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002f6e:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002f70:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002f74:	70 08       	ld.w	r8,r8[0x0]
80002f76:	58 28       	cp.w	r8,2
80002f78:	e0 80 01 98 	breq	800032a8 <phy_rx_func+0x588>
80002f7c:	e0 8b 00 06 	brhi	80002f88 <phy_rx_func+0x268>
80002f80:	58 08       	cp.w	r8,0
80002f82:	c0 b0       	breq	80002f98 <phy_rx_func+0x278>
80002f84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002f88:	58 38       	cp.w	r8,3
80002f8a:	e0 80 05 c5 	breq	80003b14 <phy_rx_func+0xdf4>
80002f8e:	58 48       	cp.w	r8,4
80002f90:	e0 81 06 05 	brne	80003b9a <phy_rx_func+0xe7a>
80002f94:	e0 8f 02 4b 	bral	8000342a <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002f98:	6e 28       	ld.w	r8,r7[0x8]
80002f9a:	e0 6a 5a 5a 	mov	r10,23130
80002f9e:	ea 1a ab cd 	orh	r10,0xabcd
80002fa2:	14 38       	cp.w	r8,r10
80002fa4:	c0 71       	brne	80002fb2 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002fa6:	30 09       	mov	r9,0
80002fa8:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002fac:	91 09       	st.w	r8[0x0],r9
80002fae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002fb2:	10 99       	mov	r9,r8
80002fb4:	e0 19 00 00 	andl	r9,0x0
80002fb8:	fc 1a ab cd 	movh	r10,0xabcd
80002fbc:	14 39       	cp.w	r9,r10
80002fbe:	e0 81 05 ee 	brne	80003b9a <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002fc2:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002fc6:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002fca:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002fcc:	6e 29       	ld.w	r9,r7[0x8]
80002fce:	e2 19 f0 00 	andl	r9,0xf000,COH
80002fd2:	e0 49 c0 00 	cp.w	r9,49152
80002fd6:	e0 81 00 ce 	brne	80003172 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002fda:	30 1a       	mov	r10,1
80002fdc:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002fe0:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002fe2:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002fe6:	72 09       	ld.w	r9,r9[0x0]
80002fe8:	58 09       	cp.w	r9,0
80002fea:	c0 71       	brne	80002ff8 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002fec:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002ff0:	f0 1f 03 00 	mcall	80003bf0 <phy_rx_func+0xed0>
80002ff4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002ff8:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002ffc:	fe f9 0b f8 	ld.w	r9,pc[3064]
80003000:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80003002:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003006:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
8000300a:	fe fa 0b ee 	ld.w	r10,pc[3054]
8000300e:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003010:	13 89       	ld.ub	r9,r9[0x0]
80003012:	37 fa       	mov	r10,127
80003014:	f4 09 18 00 	cp.b	r9,r10
80003018:	c6 d0       	breq	800030f2 <phy_rx_func+0x3d2>
8000301a:	e0 8b 00 0c 	brhi	80003032 <phy_rx_func+0x312>
8000301e:	31 2a       	mov	r10,18
80003020:	f4 09 18 00 	cp.b	r9,r10
80003024:	c4 20       	breq	800030a8 <phy_rx_func+0x388>
80003026:	31 3a       	mov	r10,19
80003028:	f4 09 18 00 	cp.b	r9,r10
8000302c:	e0 81 00 83 	brne	80003132 <phy_rx_func+0x412>
80003030:	c5 b8       	rjmp	800030e6 <phy_rx_func+0x3c6>
80003032:	2f 09       	sub	r9,-16
80003034:	30 1a       	mov	r10,1
80003036:	f4 09 18 00 	cp.b	r9,r10
8000303a:	e0 8b 00 7c 	brhi	80003132 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
8000303e:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003042:	e2 18 00 f0 	andl	r8,0xf0,COH
80003046:	59 08       	cp.w	r8,16
80003048:	c0 71       	brne	80003056 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000304a:	30 19       	mov	r9,1
8000304c:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003050:	91 09       	st.w	r8[0x0],r9
80003052:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80003056:	e0 48 00 20 	cp.w	r8,32
8000305a:	c2 11       	brne	8000309c <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
8000305c:	30 a9       	mov	r9,10
8000305e:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003062:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003064:	fe f6 0b 98 	ld.w	r6,pc[2968]
80003068:	6c 08       	ld.w	r8,r6[0x0]
8000306a:	f0 0a 11 ff 	rsub	r10,r8,-1
8000306e:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003072:	2f f8       	sub	r8,-1
80003074:	6e 0c       	ld.w	r12,r7[0x0]
80003076:	f4 ca fe 00 	sub	r10,r10,-512
8000307a:	30 0b       	mov	r11,0
8000307c:	10 0c       	add	r12,r8
8000307e:	f0 1f 02 e1 	mcall	80003c00 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003082:	30 08       	mov	r8,0
80003084:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80003086:	6e 0c       	ld.w	r12,r7[0x0]
80003088:	f0 1f 02 df 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000308c:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003090:	70 0c       	ld.w	r12,r8[0x0]
80003092:	f0 1f 02 ca 	mcall	80003bb8 <phy_rx_func+0xe98>
80003096:	8f 0c       	st.w	r7[0x0],r12
80003098:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
8000309c:	30 09       	mov	r9,0
8000309e:	fe f8 0b 42 	ld.w	r8,pc[2882]
800030a2:	91 09       	st.w	r8[0x0],r9
800030a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800030a8:	20 48       	sub	r8,4
800030aa:	fe f9 0b 3a 	ld.w	r9,pc[2874]
800030ae:	93 08       	st.w	r9[0x0],r8
800030b0:	58 08       	cp.w	r8,0
800030b2:	e0 80 05 74 	breq	80003b9a <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800030b6:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800030ba:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800030be:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800030c2:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800030c4:	8e 69       	ld.sh	r9,r7[0xc]
800030c6:	fe f8 0b 46 	ld.w	r8,pc[2886]
800030ca:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800030cc:	8e 79       	ld.sh	r9,r7[0xe]
800030ce:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800030d0:	f0 1f 02 d0 	mcall	80003c10 <phy_rx_func+0xef0>
800030d4:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800030d8:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800030da:	30 49       	mov	r9,4
800030dc:	fe f8 0b 00 	ld.w	r8,pc[2816]
800030e0:	91 09       	st.w	r8[0x0],r9
800030e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800030e6:	30 09       	mov	r9,0
800030e8:	fe f8 0a f8 	ld.w	r8,pc[2808]
800030ec:	91 09       	st.w	r8[0x0],r9
800030ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800030f2:	20 48       	sub	r8,4
800030f4:	fe f9 0a f0 	ld.w	r9,pc[2800]
800030f8:	93 08       	st.w	r9[0x0],r8
800030fa:	58 08       	cp.w	r8,0
800030fc:	e0 80 05 4f 	breq	80003b9a <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003100:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003104:	70 09       	ld.w	r9,r8[0x0]
80003106:	8e 7b       	ld.sh	r11,r7[0xe]
80003108:	fe fa 0b 10 	ld.w	r10,pc[2832]
8000310c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003110:	2f f9       	sub	r9,-1
80003112:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003114:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003118:	70 09       	ld.w	r9,r8[0x0]
8000311a:	20 29       	sub	r9,2
8000311c:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000311e:	30 29       	mov	r9,2
80003120:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003124:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003126:	30 39       	mov	r9,3
80003128:	fe f8 0a b4 	ld.w	r8,pc[2740]
8000312c:	91 09       	st.w	r8[0x0],r9
8000312e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003132:	30 3a       	mov	r10,3
80003134:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003138:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000313a:	6e 2a       	ld.w	r10,r7[0x8]
8000313c:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003140:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003142:	6e 3a       	ld.w	r10,r7[0xc]
80003144:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003146:	59 48       	cp.w	r8,20
80003148:	c0 61       	brne	80003154 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000314a:	31 89       	mov	r9,24
8000314c:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003150:	91 09       	st.w	r8[0x0],r9
80003152:	c0 a8       	rjmp	80003166 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003154:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003158:	70 08       	ld.w	r8,r8[0x0]
8000315a:	59 08       	cp.w	r8,16
8000315c:	c0 51       	brne	80003166 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000315e:	31 09       	mov	r9,16
80003160:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003164:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
80003166:	30 49       	mov	r9,4
80003168:	fe f8 0a 74 	ld.w	r8,pc[2676]
8000316c:	91 09       	st.w	r8[0x0],r9
8000316e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003172:	e0 49 10 00 	cp.w	r9,4096
80003176:	5f 1a       	srne	r10
80003178:	e0 49 20 00 	cp.w	r9,8192
8000317c:	5f 19       	srne	r9
8000317e:	f5 e9 00 09 	and	r9,r10,r9
80003182:	e0 81 05 0c 	brne	80003b9a <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
80003186:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000318a:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
8000318c:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003190:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003192:	fe fa 0a 62 	ld.w	r10,pc[2658]
80003196:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
80003198:	fe f9 0a 3c 	ld.w	r9,pc[2620]
8000319c:	72 09       	ld.w	r9,r9[0x0]
8000319e:	58 09       	cp.w	r9,0
800031a0:	c0 71       	brne	800031ae <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800031a2:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800031a6:	f0 1f 02 93 	mcall	80003bf0 <phy_rx_func+0xed0>
800031aa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800031ae:	6e 2a       	ld.w	r10,r7[0x8]
800031b0:	e2 1a 0f 00 	andl	r10,0xf00,COH
800031b4:	58 1a       	cp.w	r10,1
800031b6:	e0 8b 00 4d 	brhi	80003250 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800031ba:	20 48       	sub	r8,4
800031bc:	fe f9 0a 28 	ld.w	r9,pc[2600]
800031c0:	93 08       	st.w	r9[0x0],r8
800031c2:	58 08       	cp.w	r8,0
800031c4:	e0 80 04 eb 	breq	80003b9a <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800031c8:	8e 68       	ld.sh	r8,r7[0xc]
800031ca:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800031ce:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800031d2:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800031d4:	30 09       	mov	r9,0
800031d6:	f2 08 19 00 	cp.h	r8,r9
800031da:	c0 70       	breq	800031e8 <phy_rx_func+0x4c8>
800031dc:	30 19       	mov	r9,1
800031de:	f2 08 19 00 	cp.h	r8,r9
800031e2:	e0 81 04 dc 	brne	80003b9a <phy_rx_func+0xe7a>
800031e6:	c2 68       	rjmp	80003232 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800031e8:	fe f8 0a 44 	ld.w	r8,pc[2628]
800031ec:	70 0a       	ld.w	r10,r8[0x0]
800031ee:	fe f9 09 e6 	ld.w	r9,pc[2534]
800031f2:	72 09       	ld.w	r9,r9[0x0]
800031f4:	8e 7b       	ld.sh	r11,r7[0xe]
800031f6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800031fa:	70 09       	ld.w	r9,r8[0x0]
800031fc:	2f f9       	sub	r9,-1
800031fe:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003200:	e0 49 00 ff 	cp.w	r9,255
80003204:	e0 88 00 11 	brls	80003226 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003208:	30 09       	mov	r9,0
8000320a:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
8000320c:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003210:	6e 0c       	ld.w	r12,r7[0x0]
80003212:	f0 1f 02 7d 	mcall	80003c04 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003216:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000321a:	70 0c       	ld.w	r12,r8[0x0]
8000321c:	f0 1f 02 67 	mcall	80003bb8 <phy_rx_func+0xe98>
80003220:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003222:	e0 80 04 bc 	breq	80003b9a <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003226:	30 29       	mov	r9,2
80003228:	fe f8 09 b4 	ld.w	r8,pc[2484]
8000322c:	91 09       	st.w	r8[0x0],r9
8000322e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003232:	8e 79       	ld.sh	r9,r7[0xe]
80003234:	30 38       	mov	r8,3
80003236:	f0 09 19 00 	cp.h	r9,r8
8000323a:	c0 51       	brne	80003244 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
8000323c:	30 19       	mov	r9,1
8000323e:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003242:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003244:	30 29       	mov	r9,2
80003246:	fe f8 09 96 	ld.w	r8,pc[2454]
8000324a:	91 09       	st.w	r8[0x0],r9
8000324c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003250:	58 18       	cp.w	r8,1
80003252:	e0 88 04 a4 	brls	80003b9a <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003256:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000325a:	70 0a       	ld.w	r10,r8[0x0]
8000325c:	6e 3b       	ld.w	r11,r7[0xc]
8000325e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003262:	70 09       	ld.w	r9,r8[0x0]
80003264:	2f f9       	sub	r9,-1
80003266:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003268:	e0 49 00 ff 	cp.w	r9,255
8000326c:	e0 88 00 11 	brls	8000328e <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003270:	30 09       	mov	r9,0
80003272:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003274:	fe f7 09 60 	ld.w	r7,pc[2400]
80003278:	6e 0c       	ld.w	r12,r7[0x0]
8000327a:	f0 1f 02 63 	mcall	80003c04 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000327e:	fe f8 09 52 	ld.w	r8,pc[2386]
80003282:	70 0c       	ld.w	r12,r8[0x0]
80003284:	f0 1f 02 4d 	mcall	80003bb8 <phy_rx_func+0xe98>
80003288:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000328a:	e0 80 04 88 	breq	80003b9a <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
8000328e:	fe f9 09 56 	ld.w	r9,pc[2390]
80003292:	72 08       	ld.w	r8,r9[0x0]
80003294:	20 28       	sub	r8,2
80003296:	93 08       	st.w	r9[0x0],r8
80003298:	e0 80 04 81 	breq	80003b9a <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
8000329c:	30 29       	mov	r9,2
8000329e:	fe f8 09 3e 	ld.w	r8,pc[2366]
800032a2:	91 09       	st.w	r8[0x0],r9
800032a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800032a8:	fe f8 09 84 	ld.w	r8,pc[2436]
800032ac:	70 0a       	ld.w	r10,r8[0x0]
800032ae:	fe f9 09 26 	ld.w	r9,pc[2342]
800032b2:	72 09       	ld.w	r9,r9[0x0]
800032b4:	8e 4b       	ld.sh	r11,r7[0x8]
800032b6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800032ba:	70 09       	ld.w	r9,r8[0x0]
800032bc:	2f f9       	sub	r9,-1
800032be:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032c0:	e0 49 00 ff 	cp.w	r9,255
800032c4:	e0 88 00 16 	brls	800032f0 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800032c8:	30 09       	mov	r9,0
800032ca:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032cc:	fe f6 09 08 	ld.w	r6,pc[2312]
800032d0:	6c 0c       	ld.w	r12,r6[0x0]
800032d2:	f0 1f 02 4d 	mcall	80003c04 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032d6:	fe f8 08 fa 	ld.w	r8,pc[2298]
800032da:	70 0c       	ld.w	r12,r8[0x0]
800032dc:	f0 1f 02 37 	mcall	80003bb8 <phy_rx_func+0xe98>
800032e0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032e2:	c0 71       	brne	800032f0 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800032e4:	30 09       	mov	r9,0
800032e6:	fe f8 08 f6 	ld.w	r8,pc[2294]
800032ea:	91 09       	st.w	r8[0x0],r9
800032ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800032f0:	fe f9 08 f4 	ld.w	r9,pc[2292]
800032f4:	72 08       	ld.w	r8,r9[0x0]
800032f6:	20 28       	sub	r8,2
800032f8:	93 08       	st.w	r9[0x0],r8
800032fa:	c0 71       	brne	80003308 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800032fc:	30 09       	mov	r9,0
800032fe:	fe f8 08 de 	ld.w	r8,pc[2270]
80003302:	91 09       	st.w	r8[0x0],r9
80003304:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003308:	fe f8 09 24 	ld.w	r8,pc[2340]
8000330c:	70 0a       	ld.w	r10,r8[0x0]
8000330e:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003312:	72 09       	ld.w	r9,r9[0x0]
80003314:	8e 5b       	ld.sh	r11,r7[0xa]
80003316:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000331a:	70 09       	ld.w	r9,r8[0x0]
8000331c:	2f f9       	sub	r9,-1
8000331e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003320:	e0 49 00 ff 	cp.w	r9,255
80003324:	e0 88 00 16 	brls	80003350 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003328:	30 09       	mov	r9,0
8000332a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000332c:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003330:	6c 0c       	ld.w	r12,r6[0x0]
80003332:	f0 1f 02 35 	mcall	80003c04 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003336:	fe f8 08 9a 	ld.w	r8,pc[2202]
8000333a:	70 0c       	ld.w	r12,r8[0x0]
8000333c:	f0 1f 02 1f 	mcall	80003bb8 <phy_rx_func+0xe98>
80003340:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003342:	c0 71       	brne	80003350 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003344:	30 09       	mov	r9,0
80003346:	fe f8 08 96 	ld.w	r8,pc[2198]
8000334a:	91 09       	st.w	r8[0x0],r9
8000334c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003350:	fe f9 08 94 	ld.w	r9,pc[2196]
80003354:	72 08       	ld.w	r8,r9[0x0]
80003356:	20 28       	sub	r8,2
80003358:	93 08       	st.w	r9[0x0],r8
8000335a:	c0 71       	brne	80003368 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
8000335c:	30 09       	mov	r9,0
8000335e:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003362:	91 09       	st.w	r8[0x0],r9
80003364:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
80003368:	fe f8 08 c4 	ld.w	r8,pc[2244]
8000336c:	70 0a       	ld.w	r10,r8[0x0]
8000336e:	fe f9 08 66 	ld.w	r9,pc[2150]
80003372:	72 09       	ld.w	r9,r9[0x0]
80003374:	8e 6b       	ld.sh	r11,r7[0xc]
80003376:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000337a:	70 09       	ld.w	r9,r8[0x0]
8000337c:	2f f9       	sub	r9,-1
8000337e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003380:	e0 49 00 ff 	cp.w	r9,255
80003384:	e0 88 00 16 	brls	800033b0 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
80003388:	30 09       	mov	r9,0
8000338a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000338c:	fe f6 08 48 	ld.w	r6,pc[2120]
80003390:	6c 0c       	ld.w	r12,r6[0x0]
80003392:	f0 1f 02 1d 	mcall	80003c04 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003396:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000339a:	70 0c       	ld.w	r12,r8[0x0]
8000339c:	f0 1f 02 07 	mcall	80003bb8 <phy_rx_func+0xe98>
800033a0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800033a2:	c0 71       	brne	800033b0 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800033a4:	30 09       	mov	r9,0
800033a6:	fe f8 08 36 	ld.w	r8,pc[2102]
800033aa:	91 09       	st.w	r8[0x0],r9
800033ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800033b0:	fe f9 08 34 	ld.w	r9,pc[2100]
800033b4:	72 08       	ld.w	r8,r9[0x0]
800033b6:	20 28       	sub	r8,2
800033b8:	93 08       	st.w	r9[0x0],r8
800033ba:	c0 71       	brne	800033c8 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800033bc:	30 09       	mov	r9,0
800033be:	fe f8 08 1e 	ld.w	r8,pc[2078]
800033c2:	91 09       	st.w	r8[0x0],r9
800033c4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800033c8:	fe f8 08 64 	ld.w	r8,pc[2148]
800033cc:	70 0a       	ld.w	r10,r8[0x0]
800033ce:	fe f9 08 06 	ld.w	r9,pc[2054]
800033d2:	72 09       	ld.w	r9,r9[0x0]
800033d4:	8e 7b       	ld.sh	r11,r7[0xe]
800033d6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800033da:	70 09       	ld.w	r9,r8[0x0]
800033dc:	2f f9       	sub	r9,-1
800033de:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800033e0:	e0 49 00 ff 	cp.w	r9,255
800033e4:	e0 88 00 16 	brls	80003410 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800033e8:	30 09       	mov	r9,0
800033ea:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800033ec:	fe f7 07 e8 	ld.w	r7,pc[2024]
800033f0:	6e 0c       	ld.w	r12,r7[0x0]
800033f2:	f0 1f 02 05 	mcall	80003c04 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800033f6:	fe f8 07 da 	ld.w	r8,pc[2010]
800033fa:	70 0c       	ld.w	r12,r8[0x0]
800033fc:	f0 1f 01 ef 	mcall	80003bb8 <phy_rx_func+0xe98>
80003400:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003402:	c0 71       	brne	80003410 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003404:	30 09       	mov	r9,0
80003406:	fe f8 07 d6 	ld.w	r8,pc[2006]
8000340a:	91 09       	st.w	r8[0x0],r9
8000340c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003410:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003414:	72 08       	ld.w	r8,r9[0x0]
80003416:	20 28       	sub	r8,2
80003418:	93 08       	st.w	r9[0x0],r8
8000341a:	e0 81 03 c0 	brne	80003b9a <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000341e:	30 09       	mov	r9,0
80003420:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003424:	91 09       	st.w	r8[0x0],r9
80003426:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000342a:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000342e:	11 89       	ld.ub	r9,r8[0x0]
80003430:	31 28       	mov	r8,18
80003432:	f0 09 18 00 	cp.b	r9,r8
80003436:	e0 81 01 4c 	brne	800036ce <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
8000343a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000343e:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003442:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003444:	11 89       	ld.ub	r9,r8[0x0]
80003446:	3f 28       	mov	r8,-14
80003448:	f0 09 18 00 	cp.b	r9,r8
8000344c:	e0 81 01 3b 	brne	800036c2 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003450:	30 19       	mov	r9,1
80003452:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003456:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003458:	6e 29       	ld.w	r9,r7[0x8]
8000345a:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000345e:	fe f8 07 86 	ld.w	r8,pc[1926]
80003462:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003464:	8e 59       	ld.sh	r9,r7[0xa]
80003466:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000346a:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
8000346c:	8e 69       	ld.sh	r9,r7[0xc]
8000346e:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003470:	8e 79       	ld.sh	r9,r7[0xe]
80003472:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003474:	fe f8 07 88 	ld.w	r8,pc[1928]
80003478:	fe f9 07 60 	ld.w	r9,pc[1888]
8000347c:	72 0a       	ld.w	r10,r9[0x0]
8000347e:	70 09       	ld.w	r9,r8[0x0]
80003480:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003484:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003488:	70 09       	ld.w	r9,r8[0x0]
8000348a:	2f f9       	sub	r9,-1
8000348c:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000348e:	e0 49 01 ff 	cp.w	r9,511
80003492:	e0 88 00 16 	brls	800034be <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
80003496:	30 09       	mov	r9,0
80003498:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000349a:	fe f6 07 3e 	ld.w	r6,pc[1854]
8000349e:	6c 0c       	ld.w	r12,r6[0x0]
800034a0:	f0 1f 01 d9 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034a4:	fe f8 07 2c 	ld.w	r8,pc[1836]
800034a8:	70 0c       	ld.w	r12,r8[0x0]
800034aa:	f0 1f 01 c4 	mcall	80003bb8 <phy_rx_func+0xe98>
800034ae:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034b0:	c0 71       	brne	800034be <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800034b2:	30 09       	mov	r9,0
800034b4:	fe f8 07 28 	ld.w	r8,pc[1832]
800034b8:	91 09       	st.w	r8[0x0],r9
800034ba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034be:	fe f9 07 26 	ld.w	r9,pc[1830]
800034c2:	72 08       	ld.w	r8,r9[0x0]
800034c4:	20 18       	sub	r8,1
800034c6:	93 08       	st.w	r9[0x0],r8
800034c8:	c0 71       	brne	800034d6 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800034ca:	30 09       	mov	r9,0
800034cc:	fe f8 07 10 	ld.w	r8,pc[1808]
800034d0:	91 09       	st.w	r8[0x0],r9
800034d2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800034d6:	fe f8 07 26 	ld.w	r8,pc[1830]
800034da:	fe f9 06 fe 	ld.w	r9,pc[1790]
800034de:	72 0a       	ld.w	r10,r9[0x0]
800034e0:	70 09       	ld.w	r9,r8[0x0]
800034e2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800034e6:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034ea:	70 09       	ld.w	r9,r8[0x0]
800034ec:	2f f9       	sub	r9,-1
800034ee:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034f0:	e0 49 01 ff 	cp.w	r9,511
800034f4:	e0 88 00 16 	brls	80003520 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800034f8:	30 09       	mov	r9,0
800034fa:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800034fc:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003500:	6c 0c       	ld.w	r12,r6[0x0]
80003502:	f0 1f 01 c1 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003506:	fe f8 06 ca 	ld.w	r8,pc[1738]
8000350a:	70 0c       	ld.w	r12,r8[0x0]
8000350c:	f0 1f 01 ab 	mcall	80003bb8 <phy_rx_func+0xe98>
80003510:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003512:	c0 71       	brne	80003520 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003514:	30 09       	mov	r9,0
80003516:	fe f8 06 c6 	ld.w	r8,pc[1734]
8000351a:	91 09       	st.w	r8[0x0],r9
8000351c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003520:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003524:	72 08       	ld.w	r8,r9[0x0]
80003526:	20 18       	sub	r8,1
80003528:	93 08       	st.w	r9[0x0],r8
8000352a:	c0 71       	brne	80003538 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
8000352c:	30 09       	mov	r9,0
8000352e:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003532:	91 09       	st.w	r8[0x0],r9
80003534:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003538:	fe f8 06 c4 	ld.w	r8,pc[1732]
8000353c:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003540:	72 0a       	ld.w	r10,r9[0x0]
80003542:	70 09       	ld.w	r9,r8[0x0]
80003544:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003548:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000354c:	70 09       	ld.w	r9,r8[0x0]
8000354e:	2f f9       	sub	r9,-1
80003550:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003552:	e0 49 01 ff 	cp.w	r9,511
80003556:	e0 88 00 16 	brls	80003582 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000355a:	30 09       	mov	r9,0
8000355c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000355e:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003562:	6c 0c       	ld.w	r12,r6[0x0]
80003564:	f0 1f 01 a8 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003568:	fe f8 06 68 	ld.w	r8,pc[1640]
8000356c:	70 0c       	ld.w	r12,r8[0x0]
8000356e:	f0 1f 01 93 	mcall	80003bb8 <phy_rx_func+0xe98>
80003572:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003574:	c0 71       	brne	80003582 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
80003576:	30 09       	mov	r9,0
80003578:	fe f8 06 64 	ld.w	r8,pc[1636]
8000357c:	91 09       	st.w	r8[0x0],r9
8000357e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003582:	fe f9 06 62 	ld.w	r9,pc[1634]
80003586:	72 08       	ld.w	r8,r9[0x0]
80003588:	20 18       	sub	r8,1
8000358a:	93 08       	st.w	r9[0x0],r8
8000358c:	c0 71       	brne	8000359a <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
8000358e:	30 09       	mov	r9,0
80003590:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003594:	91 09       	st.w	r8[0x0],r9
80003596:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000359a:	fe f8 06 62 	ld.w	r8,pc[1634]
8000359e:	fe f9 06 3a 	ld.w	r9,pc[1594]
800035a2:	72 0a       	ld.w	r10,r9[0x0]
800035a4:	70 09       	ld.w	r9,r8[0x0]
800035a6:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800035aa:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035ae:	70 09       	ld.w	r9,r8[0x0]
800035b0:	2f f9       	sub	r9,-1
800035b2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035b4:	e0 49 01 ff 	cp.w	r9,511
800035b8:	e0 88 00 16 	brls	800035e4 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800035bc:	30 09       	mov	r9,0
800035be:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035c0:	fe f6 06 18 	ld.w	r6,pc[1560]
800035c4:	6c 0c       	ld.w	r12,r6[0x0]
800035c6:	f0 1f 01 90 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ca:	fe f8 06 06 	ld.w	r8,pc[1542]
800035ce:	70 0c       	ld.w	r12,r8[0x0]
800035d0:	f0 1f 01 7a 	mcall	80003bb8 <phy_rx_func+0xe98>
800035d4:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035d6:	c0 71       	brne	800035e4 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800035d8:	30 09       	mov	r9,0
800035da:	fe f8 06 02 	ld.w	r8,pc[1538]
800035de:	91 09       	st.w	r8[0x0],r9
800035e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035e4:	fe f9 06 00 	ld.w	r9,pc[1536]
800035e8:	72 08       	ld.w	r8,r9[0x0]
800035ea:	20 18       	sub	r8,1
800035ec:	93 08       	st.w	r9[0x0],r8
800035ee:	c0 71       	brne	800035fc <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800035f0:	30 09       	mov	r9,0
800035f2:	fe f8 05 ea 	ld.w	r8,pc[1514]
800035f6:	91 09       	st.w	r8[0x0],r9
800035f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800035fc:	fe f8 06 00 	ld.w	r8,pc[1536]
80003600:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003604:	72 0a       	ld.w	r10,r9[0x0]
80003606:	70 09       	ld.w	r9,r8[0x0]
80003608:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000360c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003610:	70 09       	ld.w	r9,r8[0x0]
80003612:	2f f9       	sub	r9,-1
80003614:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003616:	e0 49 01 ff 	cp.w	r9,511
8000361a:	e0 88 00 16 	brls	80003646 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000361e:	30 09       	mov	r9,0
80003620:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003622:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003626:	6c 0c       	ld.w	r12,r6[0x0]
80003628:	f0 1f 01 77 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000362c:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003630:	70 0c       	ld.w	r12,r8[0x0]
80003632:	f0 1f 01 62 	mcall	80003bb8 <phy_rx_func+0xe98>
80003636:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003638:	c0 71       	brne	80003646 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000363a:	30 09       	mov	r9,0
8000363c:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003640:	91 09       	st.w	r8[0x0],r9
80003642:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003646:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000364a:	72 08       	ld.w	r8,r9[0x0]
8000364c:	20 18       	sub	r8,1
8000364e:	93 08       	st.w	r9[0x0],r8
80003650:	c0 71       	brne	8000365e <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003652:	30 09       	mov	r9,0
80003654:	fe f8 05 88 	ld.w	r8,pc[1416]
80003658:	91 09       	st.w	r8[0x0],r9
8000365a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000365e:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003662:	fe f9 05 76 	ld.w	r9,pc[1398]
80003666:	72 0a       	ld.w	r10,r9[0x0]
80003668:	70 09       	ld.w	r9,r8[0x0]
8000366a:	ef 3b 00 0f 	ld.ub	r11,r7[15]
8000366e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003672:	70 09       	ld.w	r9,r8[0x0]
80003674:	2f f9       	sub	r9,-1
80003676:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003678:	e0 49 01 ff 	cp.w	r9,511
8000367c:	e0 88 00 16 	brls	800036a8 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003680:	30 09       	mov	r9,0
80003682:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003684:	fe f7 05 54 	ld.w	r7,pc[1364]
80003688:	6e 0c       	ld.w	r12,r7[0x0]
8000368a:	f0 1f 01 5f 	mcall	80003c04 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000368e:	fe f8 05 42 	ld.w	r8,pc[1346]
80003692:	70 0c       	ld.w	r12,r8[0x0]
80003694:	f0 1f 01 49 	mcall	80003bb8 <phy_rx_func+0xe98>
80003698:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
8000369a:	c0 71       	brne	800036a8 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
8000369c:	30 09       	mov	r9,0
8000369e:	fe f8 05 3e 	ld.w	r8,pc[1342]
800036a2:	91 09       	st.w	r8[0x0],r9
800036a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800036a8:	fe f9 05 3c 	ld.w	r9,pc[1340]
800036ac:	72 08       	ld.w	r8,r9[0x0]
800036ae:	20 18       	sub	r8,1
800036b0:	93 08       	st.w	r9[0x0],r8
800036b2:	e0 81 02 74 	brne	80003b9a <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800036b6:	30 09       	mov	r9,0
800036b8:	fe f8 05 24 	ld.w	r8,pc[1316]
800036bc:	91 09       	st.w	r8[0x0],r9
800036be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
800036c2:	30 09       	mov	r9,0
800036c4:	fe f8 05 18 	ld.w	r8,pc[1304]
800036c8:	91 09       	st.w	r8[0x0],r9
800036ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
800036ce:	fe f8 05 26 	ld.w	r8,pc[1318]
800036d2:	11 89       	ld.ub	r9,r8[0x0]
800036d4:	3f 28       	mov	r8,-14
800036d6:	f0 09 18 00 	cp.b	r9,r8
800036da:	c4 31       	brne	80003760 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
800036dc:	8e 49       	ld.sh	r9,r7[0x8]
800036de:	fe f8 05 56 	ld.w	r8,pc[1366]
800036e2:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
800036e4:	fe f8 05 18 	ld.w	r8,pc[1304]
800036e8:	fe f9 04 f0 	ld.w	r9,pc[1264]
800036ec:	72 0a       	ld.w	r10,r9[0x0]
800036ee:	70 09       	ld.w	r9,r8[0x0]
800036f0:	ef 3b 00 08 	ld.ub	r11,r7[8]
800036f4:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036f8:	70 09       	ld.w	r9,r8[0x0]
800036fa:	2f f9       	sub	r9,-1
800036fc:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036fe:	e0 49 01 ff 	cp.w	r9,511
80003702:	e0 88 00 16 	brls	8000372e <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003706:	30 09       	mov	r9,0
80003708:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000370a:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000370e:	6e 0c       	ld.w	r12,r7[0x0]
80003710:	f0 1f 01 3d 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003714:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003718:	70 0c       	ld.w	r12,r8[0x0]
8000371a:	f0 1f 01 28 	mcall	80003bb8 <phy_rx_func+0xe98>
8000371e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003720:	c0 71       	brne	8000372e <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003722:	30 09       	mov	r9,0
80003724:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003728:	91 09       	st.w	r8[0x0],r9
8000372a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000372e:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003732:	72 08       	ld.w	r8,r9[0x0]
80003734:	20 18       	sub	r8,1
80003736:	93 08       	st.w	r9[0x0],r8
80003738:	c0 71       	brne	80003746 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
8000373a:	30 09       	mov	r9,0
8000373c:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003740:	91 09       	st.w	r8[0x0],r9
80003742:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003746:	20 18       	sub	r8,1
80003748:	fe f9 04 9c 	ld.w	r9,pc[1180]
8000374c:	93 08       	st.w	r9[0x0],r8
8000374e:	58 08       	cp.w	r8,0
80003750:	e0 81 02 25 	brne	80003b9a <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003754:	30 09       	mov	r9,0
80003756:	fe f8 04 86 	ld.w	r8,pc[1158]
8000375a:	91 09       	st.w	r8[0x0],r9
8000375c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003760:	fe f8 04 94 	ld.w	r8,pc[1172]
80003764:	11 89       	ld.ub	r9,r8[0x0]
80003766:	3f 38       	mov	r8,-13
80003768:	f0 09 18 00 	cp.b	r9,r8
8000376c:	e0 81 01 0c 	brne	80003984 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003770:	8e 49       	ld.sh	r9,r7[0x8]
80003772:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003776:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003778:	8e 59       	ld.sh	r9,r7[0xa]
8000377a:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
8000377c:	8e 69       	ld.sh	r9,r7[0xc]
8000377e:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003780:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003784:	fe f9 04 54 	ld.w	r9,pc[1108]
80003788:	72 0a       	ld.w	r10,r9[0x0]
8000378a:	70 09       	ld.w	r9,r8[0x0]
8000378c:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003790:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003794:	70 09       	ld.w	r9,r8[0x0]
80003796:	2f f9       	sub	r9,-1
80003798:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000379a:	e0 49 01 ff 	cp.w	r9,511
8000379e:	e0 88 00 16 	brls	800037ca <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800037a2:	30 09       	mov	r9,0
800037a4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037a6:	fe f6 04 32 	ld.w	r6,pc[1074]
800037aa:	6c 0c       	ld.w	r12,r6[0x0]
800037ac:	f0 1f 01 16 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037b0:	fe f8 04 20 	ld.w	r8,pc[1056]
800037b4:	70 0c       	ld.w	r12,r8[0x0]
800037b6:	f0 1f 01 01 	mcall	80003bb8 <phy_rx_func+0xe98>
800037ba:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037bc:	c0 71       	brne	800037ca <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800037be:	30 09       	mov	r9,0
800037c0:	fe f8 04 1c 	ld.w	r8,pc[1052]
800037c4:	91 09       	st.w	r8[0x0],r9
800037c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037ca:	fe f9 04 1a 	ld.w	r9,pc[1050]
800037ce:	72 08       	ld.w	r8,r9[0x0]
800037d0:	20 18       	sub	r8,1
800037d2:	93 08       	st.w	r9[0x0],r8
800037d4:	c0 71       	brne	800037e2 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
800037d6:	30 09       	mov	r9,0
800037d8:	fe f8 04 04 	ld.w	r8,pc[1028]
800037dc:	91 09       	st.w	r8[0x0],r9
800037de:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
800037e2:	fe f8 04 1a 	ld.w	r8,pc[1050]
800037e6:	fe f9 03 f2 	ld.w	r9,pc[1010]
800037ea:	72 0a       	ld.w	r10,r9[0x0]
800037ec:	70 09       	ld.w	r9,r8[0x0]
800037ee:	ef 3b 00 09 	ld.ub	r11,r7[9]
800037f2:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037f6:	70 09       	ld.w	r9,r8[0x0]
800037f8:	2f f9       	sub	r9,-1
800037fa:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800037fc:	e0 49 01 ff 	cp.w	r9,511
80003800:	e0 88 00 16 	brls	8000382c <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003804:	30 09       	mov	r9,0
80003806:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003808:	fe f6 03 d0 	ld.w	r6,pc[976]
8000380c:	6c 0c       	ld.w	r12,r6[0x0]
8000380e:	f0 1f 00 fe 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003812:	fe f8 03 be 	ld.w	r8,pc[958]
80003816:	70 0c       	ld.w	r12,r8[0x0]
80003818:	f0 1f 00 e8 	mcall	80003bb8 <phy_rx_func+0xe98>
8000381c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000381e:	c0 71       	brne	8000382c <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003820:	30 09       	mov	r9,0
80003822:	fe f8 03 ba 	ld.w	r8,pc[954]
80003826:	91 09       	st.w	r8[0x0],r9
80003828:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000382c:	fe f9 03 b8 	ld.w	r9,pc[952]
80003830:	72 08       	ld.w	r8,r9[0x0]
80003832:	20 18       	sub	r8,1
80003834:	93 08       	st.w	r9[0x0],r8
80003836:	c0 71       	brne	80003844 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003838:	30 09       	mov	r9,0
8000383a:	fe f8 03 a2 	ld.w	r8,pc[930]
8000383e:	91 09       	st.w	r8[0x0],r9
80003840:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003844:	fe f8 03 b8 	ld.w	r8,pc[952]
80003848:	fe f9 03 90 	ld.w	r9,pc[912]
8000384c:	72 0a       	ld.w	r10,r9[0x0]
8000384e:	70 09       	ld.w	r9,r8[0x0]
80003850:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003854:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003858:	70 09       	ld.w	r9,r8[0x0]
8000385a:	2f f9       	sub	r9,-1
8000385c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000385e:	e0 49 01 ff 	cp.w	r9,511
80003862:	e0 88 00 16 	brls	8000388e <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003866:	30 09       	mov	r9,0
80003868:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000386a:	fe f6 03 6e 	ld.w	r6,pc[878]
8000386e:	6c 0c       	ld.w	r12,r6[0x0]
80003870:	f0 1f 00 e5 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003874:	fe f8 03 5c 	ld.w	r8,pc[860]
80003878:	70 0c       	ld.w	r12,r8[0x0]
8000387a:	f0 1f 00 d0 	mcall	80003bb8 <phy_rx_func+0xe98>
8000387e:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003880:	c0 71       	brne	8000388e <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003882:	30 09       	mov	r9,0
80003884:	fe f8 03 58 	ld.w	r8,pc[856]
80003888:	91 09       	st.w	r8[0x0],r9
8000388a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000388e:	fe f9 03 56 	ld.w	r9,pc[854]
80003892:	72 08       	ld.w	r8,r9[0x0]
80003894:	20 18       	sub	r8,1
80003896:	93 08       	st.w	r9[0x0],r8
80003898:	c0 71       	brne	800038a6 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
8000389a:	30 09       	mov	r9,0
8000389c:	fe f8 03 40 	ld.w	r8,pc[832]
800038a0:	91 09       	st.w	r8[0x0],r9
800038a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800038a6:	fe f8 03 56 	ld.w	r8,pc[854]
800038aa:	fe f9 03 2e 	ld.w	r9,pc[814]
800038ae:	72 0a       	ld.w	r10,r9[0x0]
800038b0:	70 09       	ld.w	r9,r8[0x0]
800038b2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800038b6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800038ba:	70 09       	ld.w	r9,r8[0x0]
800038bc:	2f f9       	sub	r9,-1
800038be:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038c0:	e0 49 01 ff 	cp.w	r9,511
800038c4:	e0 88 00 16 	brls	800038f0 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
800038c8:	30 09       	mov	r9,0
800038ca:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800038cc:	fe f6 03 0c 	ld.w	r6,pc[780]
800038d0:	6c 0c       	ld.w	r12,r6[0x0]
800038d2:	f0 1f 00 cd 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800038d6:	fe f8 02 fa 	ld.w	r8,pc[762]
800038da:	70 0c       	ld.w	r12,r8[0x0]
800038dc:	f0 1f 00 b7 	mcall	80003bb8 <phy_rx_func+0xe98>
800038e0:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800038e2:	c0 71       	brne	800038f0 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
800038e4:	30 09       	mov	r9,0
800038e6:	fe f8 02 f6 	ld.w	r8,pc[758]
800038ea:	91 09       	st.w	r8[0x0],r9
800038ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800038f0:	fe f9 02 f4 	ld.w	r9,pc[756]
800038f4:	72 08       	ld.w	r8,r9[0x0]
800038f6:	20 18       	sub	r8,1
800038f8:	93 08       	st.w	r9[0x0],r8
800038fa:	c0 71       	brne	80003908 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
800038fc:	30 09       	mov	r9,0
800038fe:	fe f8 02 de 	ld.w	r8,pc[734]
80003902:	91 09       	st.w	r8[0x0],r9
80003904:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003908:	fe f8 02 f4 	ld.w	r8,pc[756]
8000390c:	fe f9 02 cc 	ld.w	r9,pc[716]
80003910:	72 0a       	ld.w	r10,r9[0x0]
80003912:	70 09       	ld.w	r9,r8[0x0]
80003914:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003918:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000391c:	70 09       	ld.w	r9,r8[0x0]
8000391e:	2f f9       	sub	r9,-1
80003920:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003922:	e0 49 01 ff 	cp.w	r9,511
80003926:	e0 88 00 16 	brls	80003952 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
8000392a:	30 09       	mov	r9,0
8000392c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000392e:	fe f7 02 aa 	ld.w	r7,pc[682]
80003932:	6e 0c       	ld.w	r12,r7[0x0]
80003934:	f0 1f 00 b4 	mcall	80003c04 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003938:	fe f8 02 98 	ld.w	r8,pc[664]
8000393c:	70 0c       	ld.w	r12,r8[0x0]
8000393e:	f0 1f 00 9f 	mcall	80003bb8 <phy_rx_func+0xe98>
80003942:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003944:	c0 71       	brne	80003952 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003946:	30 09       	mov	r9,0
80003948:	fe f8 02 94 	ld.w	r8,pc[660]
8000394c:	91 09       	st.w	r8[0x0],r9
8000394e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003952:	fe f9 02 92 	ld.w	r9,pc[658]
80003956:	72 08       	ld.w	r8,r9[0x0]
80003958:	20 18       	sub	r8,1
8000395a:	93 08       	st.w	r9[0x0],r8
8000395c:	c0 71       	brne	8000396a <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000395e:	30 09       	mov	r9,0
80003960:	fe f8 02 7c 	ld.w	r8,pc[636]
80003964:	91 09       	st.w	r8[0x0],r9
80003966:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
8000396a:	20 18       	sub	r8,1
8000396c:	fe f9 02 78 	ld.w	r9,pc[632]
80003970:	93 08       	st.w	r9[0x0],r8
80003972:	58 08       	cp.w	r8,0
80003974:	e0 81 01 13 	brne	80003b9a <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003978:	30 09       	mov	r9,0
8000397a:	fe f8 02 62 	ld.w	r8,pc[610]
8000397e:	91 09       	st.w	r8[0x0],r9
80003980:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003984:	fe f8 02 70 	ld.w	r8,pc[624]
80003988:	11 89       	ld.ub	r9,r8[0x0]
8000398a:	30 48       	mov	r8,4
8000398c:	f0 09 18 00 	cp.b	r9,r8
80003990:	c0 80       	breq	800039a0 <phy_rx_func+0xc80>
80003992:	fe f8 02 62 	ld.w	r8,pc[610]
80003996:	11 89       	ld.ub	r9,r8[0x0]
80003998:	30 38       	mov	r8,3
8000399a:	f0 09 18 00 	cp.b	r9,r8
8000399e:	c1 41       	brne	800039c6 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800039a0:	6e 29       	ld.w	r9,r7[0x8]
800039a2:	fe f8 02 7a 	ld.w	r8,pc[634]
800039a6:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800039a8:	6e 39       	ld.w	r9,r7[0xc]
800039aa:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800039ac:	fe f9 02 38 	ld.w	r9,pc[568]
800039b0:	72 08       	ld.w	r8,r9[0x0]
800039b2:	20 88       	sub	r8,8
800039b4:	93 08       	st.w	r9[0x0],r8
800039b6:	e0 81 00 f2 	brne	80003b9a <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800039ba:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800039bc:	fe f9 02 20 	ld.w	r9,pc[544]
800039c0:	93 08       	st.w	r9[0x0],r8
800039c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
800039c6:	fe f8 02 2e 	ld.w	r8,pc[558]
800039ca:	11 89       	ld.ub	r9,r8[0x0]
800039cc:	31 38       	mov	r8,19
800039ce:	f0 09 18 00 	cp.b	r9,r8
800039d2:	e0 81 00 9c 	brne	80003b0a <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
800039d6:	fe f8 02 62 	ld.w	r8,pc[610]
800039da:	11 88       	ld.ub	r8,r8[0x0]
800039dc:	30 c9       	mov	r9,12
800039de:	f2 08 18 00 	cp.b	r8,r9
800039e2:	e0 81 00 7b 	brne	80003ad8 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
800039e6:	8e 49       	ld.sh	r9,r7[0x8]
800039e8:	fe f8 02 54 	ld.w	r8,pc[596]
800039ec:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
800039f0:	30 09       	mov	r9,0
800039f2:	fe f8 02 46 	ld.w	r8,pc[582]
800039f6:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800039f8:	ef 39 00 0d 	ld.ub	r9,r7[13]
800039fc:	3f 38       	mov	r8,-13
800039fe:	f0 09 18 00 	cp.b	r9,r8
80003a02:	c6 61       	brne	80003ace <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003a04:	10 99       	mov	r9,r8
80003a06:	4f c8       	lddpc	r8,80003bf4 <phy_rx_func+0xed4>
80003a08:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003a0a:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003a0e:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003a12:	4f 58       	lddpc	r8,80003be4 <phy_rx_func+0xec4>
80003a14:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003a16:	30 19       	mov	r9,1
80003a18:	fe f8 02 0c 	ld.w	r8,pc[524]
80003a1c:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003a1e:	8e 79       	ld.sh	r9,r7[0xe]
80003a20:	fe f8 02 14 	ld.w	r8,pc[532]
80003a24:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003a26:	4f 68       	lddpc	r8,80003bfc <phy_rx_func+0xedc>
80003a28:	4e c9       	lddpc	r9,80003bd8 <phy_rx_func+0xeb8>
80003a2a:	72 0a       	ld.w	r10,r9[0x0]
80003a2c:	70 09       	ld.w	r9,r8[0x0]
80003a2e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003a32:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003a36:	70 09       	ld.w	r9,r8[0x0]
80003a38:	2f f9       	sub	r9,-1
80003a3a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a3c:	e0 49 01 ff 	cp.w	r9,511
80003a40:	e0 88 00 13 	brls	80003a66 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003a44:	30 09       	mov	r9,0
80003a46:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a48:	4e 46       	lddpc	r6,80003bd8 <phy_rx_func+0xeb8>
80003a4a:	6c 0c       	ld.w	r12,r6[0x0]
80003a4c:	f0 1f 00 6e 	mcall	80003c04 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003a50:	4e 08       	lddpc	r8,80003bd0 <phy_rx_func+0xeb0>
80003a52:	70 0c       	ld.w	r12,r8[0x0]
80003a54:	f0 1f 00 59 	mcall	80003bb8 <phy_rx_func+0xe98>
80003a58:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003a5a:	c0 61       	brne	80003a66 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003a5c:	30 09       	mov	r9,0
80003a5e:	4e 08       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003a60:	91 09       	st.w	r8[0x0],r9
80003a62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003a66:	4e 09       	lddpc	r9,80003be4 <phy_rx_func+0xec4>
80003a68:	72 08       	ld.w	r8,r9[0x0]
80003a6a:	20 18       	sub	r8,1
80003a6c:	93 08       	st.w	r9[0x0],r8
80003a6e:	c0 61       	brne	80003a7a <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003a70:	30 09       	mov	r9,0
80003a72:	4d b8       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003a74:	91 09       	st.w	r8[0x0],r9
80003a76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003a7a:	4e 18       	lddpc	r8,80003bfc <phy_rx_func+0xedc>
80003a7c:	4d 79       	lddpc	r9,80003bd8 <phy_rx_func+0xeb8>
80003a7e:	72 0a       	ld.w	r10,r9[0x0]
80003a80:	70 09       	ld.w	r9,r8[0x0]
80003a82:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003a86:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003a8a:	70 09       	ld.w	r9,r8[0x0]
80003a8c:	2f f9       	sub	r9,-1
80003a8e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a90:	e0 49 01 ff 	cp.w	r9,511
80003a94:	e0 88 00 13 	brls	80003aba <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003a98:	30 09       	mov	r9,0
80003a9a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003a9c:	4c f7       	lddpc	r7,80003bd8 <phy_rx_func+0xeb8>
80003a9e:	6e 0c       	ld.w	r12,r7[0x0]
80003aa0:	f0 1f 00 59 	mcall	80003c04 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003aa4:	4c b8       	lddpc	r8,80003bd0 <phy_rx_func+0xeb0>
80003aa6:	70 0c       	ld.w	r12,r8[0x0]
80003aa8:	f0 1f 00 44 	mcall	80003bb8 <phy_rx_func+0xe98>
80003aac:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003aae:	c0 61       	brne	80003aba <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003ab0:	30 09       	mov	r9,0
80003ab2:	4c b8       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003ab4:	91 09       	st.w	r8[0x0],r9
80003ab6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003aba:	4c b9       	lddpc	r9,80003be4 <phy_rx_func+0xec4>
80003abc:	72 08       	ld.w	r8,r9[0x0]
80003abe:	20 18       	sub	r8,1
80003ac0:	93 08       	st.w	r9[0x0],r8
80003ac2:	c6 c1       	brne	80003b9a <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003ac4:	30 09       	mov	r9,0
80003ac6:	4c 68       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003ac8:	91 09       	st.w	r8[0x0],r9
80003aca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003ace:	30 09       	mov	r9,0
80003ad0:	4c 38       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003ad2:	91 09       	st.w	r8[0x0],r9
80003ad4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003ad8:	8e 4a       	ld.sh	r10,r7[0x8]
80003ada:	4d 99       	lddpc	r9,80003c3c <phy_rx_func+0xf1c>
80003adc:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003ae0:	4d 6a       	lddpc	r10,80003c38 <phy_rx_func+0xf18>
80003ae2:	15 88       	ld.ub	r8,r10[0x0]
80003ae4:	f0 cb ff ff 	sub	r11,r8,-1
80003ae8:	8e 5c       	ld.sh	r12,r7[0xa]
80003aea:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003aee:	f0 cb ff fe 	sub	r11,r8,-2
80003af2:	8e 6c       	ld.sh	r12,r7[0xc]
80003af4:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003af8:	f0 cb ff fd 	sub	r11,r8,-3
80003afc:	8e 7c       	ld.sh	r12,r7[0xe]
80003afe:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003b02:	2f c8       	sub	r8,-4
80003b04:	b4 88       	st.b	r10[0x0],r8
80003b06:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003b0a:	30 09       	mov	r9,0
80003b0c:	4b 48       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003b0e:	91 09       	st.w	r8[0x0],r9
80003b10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003b14:	4c 08       	lddpc	r8,80003c14 <phy_rx_func+0xef4>
80003b16:	70 09       	ld.w	r9,r8[0x0]
80003b18:	8e 4b       	ld.sh	r11,r7[0x8]
80003b1a:	4c 0a       	lddpc	r10,80003c18 <phy_rx_func+0xef8>
80003b1c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003b20:	2f f9       	sub	r9,-1
80003b22:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003b24:	4b 58       	lddpc	r8,80003bf8 <phy_rx_func+0xed8>
80003b26:	70 09       	ld.w	r9,r8[0x0]
80003b28:	20 29       	sub	r9,2
80003b2a:	91 09       	st.w	r8[0x0],r9
80003b2c:	70 08       	ld.w	r8,r8[0x0]
80003b2e:	58 08       	cp.w	r8,0
80003b30:	c2 f1       	brne	80003b8e <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003b32:	30 09       	mov	r9,0
80003b34:	4b 88       	lddpc	r8,80003c14 <phy_rx_func+0xef4>
80003b36:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b38:	8e 59       	ld.sh	r9,r7[0xa]
80003b3a:	fe 78 82 12 	mov	r8,-32238
80003b3e:	f0 09 19 00 	cp.h	r9,r8
80003b42:	c2 11       	brne	80003b84 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003b44:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003b48:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003b4c:	4a f8       	lddpc	r8,80003c08 <phy_rx_func+0xee8>
80003b4e:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003b50:	8e 59       	ld.sh	r9,r7[0xa]
80003b52:	4a f8       	lddpc	r8,80003c0c <phy_rx_func+0xeec>
80003b54:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003b56:	8e 69       	ld.sh	r9,r7[0xc]
80003b58:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003b5a:	f0 1f 00 2e 	mcall	80003c10 <phy_rx_func+0xef0>
80003b5e:	4a 18       	lddpc	r8,80003be0 <phy_rx_func+0xec0>
80003b60:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003b62:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003b66:	31 38       	mov	r8,19
80003b68:	f0 09 18 00 	cp.b	r9,r8
80003b6c:	c0 71       	brne	80003b7a <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003b6e:	10 99       	mov	r9,r8
80003b70:	4a 18       	lddpc	r8,80003bf4 <phy_rx_func+0xed4>
80003b72:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003b74:	30 09       	mov	r9,0
80003b76:	49 c8       	lddpc	r8,80003be4 <phy_rx_func+0xec4>
80003b78:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003b7a:	30 49       	mov	r9,4
80003b7c:	49 88       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003b7e:	91 09       	st.w	r8[0x0],r9
80003b80:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003b84:	30 09       	mov	r9,0
80003b86:	49 68       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003b88:	91 09       	st.w	r8[0x0],r9
80003b8a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003b8e:	4a dc       	lddpc	r12,80003c40 <phy_rx_func+0xf20>
80003b90:	f0 1f 00 18 	mcall	80003bf0 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003b94:	30 09       	mov	r9,0
80003b96:	49 28       	lddpc	r8,80003bdc <phy_rx_func+0xebc>
80003b98:	91 09       	st.w	r8[0x0],r9
80003b9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003b9e:	00 00       	add	r0,r0
80003ba0:	00 00       	add	r0,r0
80003ba2:	0a ac       	st.w	r5++,r12
80003ba4:	00 00       	add	r0,r0
80003ba6:	0a c4       	st.b	r5++,r4
80003ba8:	00 00       	add	r0,r0
80003baa:	0a a4       	st.w	r5++,r4
80003bac:	00 00       	add	r0,r0
80003bae:	0a 86       	andn	r6,r5
80003bb0:	00 00       	add	r0,r0
80003bb2:	0a 74       	tst	r4,r5
80003bb4:	00 00       	add	r0,r0
80003bb6:	0a 9c       	mov	r12,r5
80003bb8:	80 00       	ld.sh	r0,r0[0x0]
80003bba:	2b a0       	sub	r0,-70
80003bbc:	00 00       	add	r0,r0
80003bbe:	0a 94       	mov	r4,r5
80003bc0:	80 00       	ld.sh	r0,r0[0x0]
80003bc2:	2a b8       	sub	r8,-85
80003bc4:	00 00       	add	r0,r0
80003bc6:	0a a8       	st.w	r5++,r8
80003bc8:	80 00       	ld.sh	r0,r0[0x0]
80003bca:	2a ec       	sub	r12,-82
80003bcc:	00 00       	add	r0,r0
80003bce:	0a 85       	andn	r5,r5
80003bd0:	00 00       	add	r0,r0
80003bd2:	0a a0       	st.w	r5++,r0
80003bd4:	00 00       	add	r0,r0
80003bd6:	0a b0       	st.h	r5++,r0
80003bd8:	00 00       	add	r0,r0
80003bda:	0a 88       	andn	r8,r5
80003bdc:	00 00       	add	r0,r0
80003bde:	0a d0       	st.w	--r5,r0
80003be0:	00 00       	add	r0,r0
80003be2:	0a b8       	st.h	r5++,r8
80003be4:	00 00       	add	r0,r0
80003be6:	0a 70       	tst	r0,r5
80003be8:	00 00       	add	r0,r0
80003bea:	0a 4c       	or	r12,r5
80003bec:	80 00       	ld.sh	r0,r0[0x0]
80003bee:	d5 b4       	*unknown*
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	6f 88       	ld.w	r8,r7[0x60]
80003bf4:	00 00       	add	r0,r0
80003bf6:	0a 84       	andn	r4,r5
80003bf8:	00 00       	add	r0,r0
80003bfa:	0a dc       	st.w	--r5,r12
80003bfc:	00 00       	add	r0,r0
80003bfe:	0a bc       	st.h	r5++,r12
80003c00:	80 00       	ld.sh	r0,r0[0x0]
80003c02:	77 c0       	ld.w	r0,r11[0x70]
80003c04:	80 00       	ld.sh	r0,r0[0x0]
80003c06:	2a d4       	sub	r4,-83
80003c08:	00 00       	add	r0,r0
80003c0a:	0a 44       	or	r4,r5
80003c0c:	00 00       	add	r0,r0
80003c0e:	1e ac       	st.w	pc++,r12
80003c10:	80 00       	ld.sh	r0,r0[0x0]
80003c12:	2a 88       	sub	r8,-88
80003c14:	00 00       	add	r0,r0
80003c16:	0a 78       	tst	r8,r5
80003c18:	00 00       	add	r0,r0
80003c1a:	1d b0       	ld.ub	r0,lr[0x3]
80003c1c:	00 00       	add	r0,r0
80003c1e:	0a 7c       	tst	r12,r5
80003c20:	00 00       	add	r0,r0
80003c22:	0a 45       	or	r5,r5
80003c24:	00 00       	add	r0,r0
80003c26:	0a 43       	or	r3,r5
80003c28:	00 00       	add	r0,r0
80003c2a:	0a d4       	st.w	--r5,r4
80003c2c:	00 00       	add	r0,r0
80003c2e:	0a 90       	mov	r0,r5
80003c30:	00 00       	add	r0,r0
80003c32:	0a 5d       	eor	sp,r5
80003c34:	00 00       	add	r0,r0
80003c36:	1d a8       	ld.ub	r8,lr[0x2]
80003c38:	00 00       	add	r0,r0
80003c3a:	0a c8       	st.b	r5++,r8
80003c3c:	00 00       	add	r0,r0
80003c3e:	1e b0       	st.h	pc++,r0
80003c40:	80 00       	ld.sh	r0,r0[0x0]
80003c42:	d5 cc       	*unknown*

80003c44 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003c44:	d4 01       	pushm	lr
	//xHigherPriorityTaskWoken = pdFALSE;
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80003c46:	49 a8       	lddpc	r8,80003cac <pdca_int_handler+0x68>
80003c48:	70 09       	ld.w	r9,r8[0x0]
80003c4a:	2f f9       	sub	r9,-1
80003c4c:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003c4e:	49 98       	lddpc	r8,80003cb0 <pdca_int_handler+0x6c>
80003c50:	11 89       	ld.ub	r9,r8[0x0]
80003c52:	ec 19 00 01 	eorl	r9,0x1
80003c56:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003c58:	11 89       	ld.ub	r9,r8[0x0]
80003c5a:	a5 69       	lsl	r9,0x4
80003c5c:	2f c9       	sub	r9,-4
80003c5e:	49 6a       	lddpc	r10,80003cb4 <pdca_int_handler+0x70>
80003c60:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003c62:	fe 7a 00 40 	mov	r10,-65472
80003c66:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c68:	30 39       	mov	r9,3
80003c6a:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003c6c:	11 8a       	ld.ub	r10,r8[0x0]
80003c6e:	a5 6a       	lsl	r10,0x4
80003c70:	2f ca       	sub	r10,-4
80003c72:	49 28       	lddpc	r8,80003cb8 <pdca_int_handler+0x74>
80003c74:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003c76:	fe 78 00 00 	mov	r8,-65536
80003c7a:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c7c:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003c7e:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003c80:	48 f8       	lddpc	r8,80003cbc <pdca_int_handler+0x78>
80003c82:	70 08       	ld.w	r8,r8[0x0]
80003c84:	58 08       	cp.w	r8,0
80003c86:	c0 70       	breq	80003c94 <pdca_int_handler+0x50>
80003c88:	48 a9       	lddpc	r9,80003cb0 <pdca_int_handler+0x6c>
80003c8a:	13 89       	ld.ub	r9,r9[0x0]
80003c8c:	a5 69       	lsl	r9,0x4
80003c8e:	48 bc       	lddpc	r12,80003cb8 <pdca_int_handler+0x74>
80003c90:	12 0c       	add	r12,r9
80003c92:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003c94:	48 b8       	lddpc	r8,80003cc0 <pdca_int_handler+0x7c>
80003c96:	70 08       	ld.w	r8,r8[0x0]
80003c98:	58 08       	cp.w	r8,0
80003c9a:	c0 70       	breq	80003ca8 <pdca_int_handler+0x64>
80003c9c:	48 59       	lddpc	r9,80003cb0 <pdca_int_handler+0x6c>
80003c9e:	13 89       	ld.ub	r9,r9[0x0]
80003ca0:	a5 69       	lsl	r9,0x4
80003ca2:	48 5c       	lddpc	r12,80003cb4 <pdca_int_handler+0x70>
80003ca4:	12 0c       	add	r12,r9
80003ca6:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003ca8:	d4 02       	popm	lr
80003caa:	d6 03       	rete
80003cac:	00 00       	add	r0,r0
80003cae:	0a e4       	st.h	--r5,r4
80003cb0:	00 00       	add	r0,r0
80003cb2:	50 d0       	stdsp	sp[0x34],r0
80003cb4:	00 00       	add	r0,r0
80003cb6:	50 f8       	stdsp	sp[0x3c],r8
80003cb8:	00 00       	add	r0,r0
80003cba:	50 d8       	stdsp	sp[0x34],r8
80003cbc:	00 00       	add	r0,r0
80003cbe:	0a e0       	st.h	--r5,r0
80003cc0:	00 00       	add	r0,r0
80003cc2:	0a e8       	st.h	--r5,r8

80003cc4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003cc4:	fe 78 10 00 	mov	r8,-61440
80003cc8:	e0 69 0d c0 	mov	r9,3520
80003ccc:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003cd0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003cd4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003cd8:	fe 78 34 00 	mov	r8,-52224
80003cdc:	e0 69 80 00 	mov	r9,32768
80003ce0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003ce2:	30 09       	mov	r9,0
80003ce4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003ce6:	e0 69 04 21 	mov	r9,1057
80003cea:	ea 19 3f 20 	orh	r9,0x3f20
80003cee:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003cf0:	e0 69 02 9f 	mov	r9,671
80003cf4:	ea 19 01 00 	orh	r9,0x100
80003cf8:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003cfa:	e0 6a 04 02 	mov	r10,1026
80003cfe:	ea 1a 3f 20 	orh	r10,0x3f20
80003d02:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003d04:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003d06:	5e fc       	retal	r12

80003d08 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003d08:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003d0a:	30 19       	mov	r9,1
80003d0c:	49 78       	lddpc	r8,80003d68 <local_start_PDC+0x60>
80003d0e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003d10:	fe 78 00 00 	mov	r8,-65536
80003d14:	30 7b       	mov	r11,7
80003d16:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003d18:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003d1a:	49 59       	lddpc	r9,80003d6c <local_start_PDC+0x64>
80003d1c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003d20:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003d22:	30 3a       	mov	r10,3
80003d24:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003d26:	30 1c       	mov	r12,1
80003d28:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003d2a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003d2c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003d2e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d30:	30 2c       	mov	r12,2
80003d32:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003d34:	48 f9       	lddpc	r9,80003d70 <local_start_PDC+0x68>
80003d36:	e0 68 5a 5a 	mov	r8,23130
80003d3a:	ea 18 ab cd 	orh	r8,0xabcd
80003d3e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003d40:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003d42:	30 0e       	mov	lr,0
80003d44:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003d46:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003d48:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003d4a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003d4c:	fe 78 00 40 	mov	r8,-65472
80003d50:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003d52:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003d54:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003d58:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003d5a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003d5c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003d5e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003d60:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003d62:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003d64:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003d66:	d8 02       	popm	pc
80003d68:	00 00       	add	r0,r0
80003d6a:	50 d0       	stdsp	sp[0x34],r0
80003d6c:	00 00       	add	r0,r0
80003d6e:	50 d8       	stdsp	sp[0x34],r8
80003d70:	00 00       	add	r0,r0
80003d72:	50 f8       	stdsp	sp[0x3c],r8

80003d74 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003d74:	48 38       	lddpc	r8,80003d80 <register_rx_tx_func+0xc>
80003d76:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003d78:	48 38       	lddpc	r8,80003d84 <register_rx_tx_func+0x10>
80003d7a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003d7c:	5e fc       	retal	r12
80003d7e:	00 00       	add	r0,r0
80003d80:	00 00       	add	r0,r0
80003d82:	0a e0       	st.h	--r5,r0
80003d84:	00 00       	add	r0,r0
80003d86:	0a e8       	st.h	--r5,r8

80003d88 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003d88:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003d8a:	fe 78 10 00 	mov	r8,-61440
80003d8e:	30 29       	mov	r9,2
80003d90:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003d94:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80003d98:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
80003d9a:	30 3a       	mov	r10,3
80003d9c:	36 0b       	mov	r11,96
80003d9e:	49 4c       	lddpc	r12,80003dec <ssc_init+0x64>
80003da0:	f0 1f 00 14 	mcall	80003df0 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
80003da4:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003da6:	fe 79 10 00 	mov	r9,-61440
80003daa:	f2 f8 01 60 	ld.w	r8,r9[352]
80003dae:	e2 18 00 02 	andl	r8,0x2,COH
80003db2:	cf c0       	breq	80003daa <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003db4:	fe 79 10 00 	mov	r9,-61440
80003db8:	f2 f8 01 60 	ld.w	r8,r9[352]
80003dbc:	e2 18 00 02 	andl	r8,0x2,COH
80003dc0:	cf c1       	brne	80003db8 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
80003dc2:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003dc4:	f0 1f 00 0c 	mcall	80003df4 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
80003dc8:	f0 1f 00 0c 	mcall	80003df8 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003dcc:	fe 79 00 00 	mov	r9,-65536
80003dd0:	30 18       	mov	r8,1
80003dd2:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003dd4:	fe 7a 00 40 	mov	r10,-65472
80003dd8:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003dda:	e0 6b 01 01 	mov	r11,257
80003dde:	fe 7a 34 00 	mov	r10,-52224
80003de2:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003de4:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003de6:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003de8:	d8 02       	popm	pc
80003dea:	00 00       	add	r0,r0
80003dec:	80 00       	ld.sh	r0,r0[0x0]
80003dee:	3c 44       	mov	r4,-60
80003df0:	80 00       	ld.sh	r0,r0[0x0]
80003df2:	54 2c       	stdsp	sp[0x108],r12
80003df4:	80 00       	ld.sh	r0,r0[0x0]
80003df6:	3c c4       	mov	r4,-52
80003df8:	80 00       	ld.sh	r0,r0[0x0]
80003dfa:	3d 08       	mov	r8,-48

80003dfc <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003dfc:	48 28       	lddpc	r8,80003e04 <xcmp_register_app_list+0x8>
80003dfe:	91 0c       	st.w	r8[0x0],r12
}
80003e00:	5e fc       	retal	r12
80003e02:	00 00       	add	r0,r0
80003e04:	00 00       	add	r0,r0
80003e06:	51 18       	stdsp	sp[0x44],r8

80003e08 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003e08:	eb cd 40 80 	pushm	r7,lr
80003e0c:	fa cd 01 00 	sub	sp,sp,256
80003e10:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003e12:	16 98       	mov	r8,r11
80003e14:	2f 08       	sub	r8,-16
80003e16:	af a8       	sbr	r8,0xe
80003e18:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003e1a:	3f f8       	mov	r8,-1
80003e1c:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003e1e:	30 b9       	mov	r9,11
80003e20:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003e22:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003e24:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003e26:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003e28:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003e2a:	f6 ca ff fe 	sub	r10,r11,-2
80003e2e:	18 9b       	mov	r11,r12
80003e30:	fa cc ff f0 	sub	r12,sp,-16
80003e34:	f0 1f 00 05 	mcall	80003e48 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003e38:	2f e7       	sub	r7,-2
80003e3a:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003e3c:	1a 9c       	mov	r12,sp
80003e3e:	f0 1f 00 04 	mcall	80003e4c <xcmp_tx+0x44>
}
80003e42:	2c 0d       	sub	sp,-256
80003e44:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e48:	80 00       	ld.sh	r0,r0[0x0]
80003e4a:	76 78       	ld.w	r8,r11[0x1c]
80003e4c:	80 00       	ld.sh	r0,r0[0x0]
80003e4e:	44 14       	lddsp	r4,sp[0x104]

80003e50 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003e50:	d4 21       	pushm	r4-r7,lr
80003e52:	fa cd 00 d0 	sub	sp,sp,208
80003e56:	18 94       	mov	r4,r12
80003e58:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003e5a:	e0 68 01 00 	mov	r8,256
80003e5e:	f0 0b 19 00 	cp.h	r11,r8
80003e62:	e0 8b 00 36 	brhi	80003ece <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003e66:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003e6a:	e0 68 04 1d 	mov	r8,1053
80003e6e:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003e70:	30 18       	mov	r8,1
80003e72:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003e74:	32 08       	mov	r8,32
80003e76:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003e78:	30 28       	mov	r8,2
80003e7a:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003e7c:	30 48       	mov	r8,4
80003e7e:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003e80:	ea 1a 0c 00 	orh	r10,0xc00
80003e84:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003e86:	30 4a       	mov	r10,4
80003e88:	1a 9b       	mov	r11,sp
80003e8a:	fa cc ff f4 	sub	r12,sp,-12
80003e8e:	f0 1f 00 12 	mcall	80003ed4 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003e92:	30 f8       	mov	r8,15
80003e94:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003e98:	3a 78       	mov	r8,-89
80003e9a:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003e9e:	30 08       	mov	r8,0
80003ea0:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003ea4:	0e 9a       	mov	r10,r7
80003ea6:	5c 7a       	castu.h	r10
80003ea8:	f4 08 16 08 	lsr	r8,r10,0x8
80003eac:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003eb0:	0e 96       	mov	r6,r7
80003eb2:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003eb6:	08 9b       	mov	r11,r4
80003eb8:	fa cc ff eb 	sub	r12,sp,-21
80003ebc:	f0 1f 00 06 	mcall	80003ed4 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003ec0:	ee cb ff f3 	sub	r11,r7,-13
80003ec4:	5c 5b       	castu.b	r11
80003ec6:	fa cc ff fa 	sub	r12,sp,-6
80003eca:	f0 1f 00 04 	mcall	80003ed8 <xcmp_data_session_req+0x88>
}
80003ece:	2c cd       	sub	sp,-208
80003ed0:	d8 22       	popm	r4-r7,pc
80003ed2:	00 00       	add	r0,r0
80003ed4:	80 00       	ld.sh	r0,r0[0x0]
80003ed6:	76 78       	ld.w	r8,r11[0x1c]
80003ed8:	80 00       	ld.sh	r0,r0[0x0]
80003eda:	3e 08       	mov	r8,-32

80003edc <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003edc:	d4 01       	pushm	lr
80003ede:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003ee2:	fe 78 b4 00 	mov	r8,-19456
80003ee6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003ee8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003eec:	30 89       	mov	r9,8
80003eee:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003ef0:	30 19       	mov	r9,1
80003ef2:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003ef4:	30 09       	mov	r9,0
80003ef6:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003ef8:	30 5a       	mov	r10,5
80003efa:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003efc:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003efe:	30 7a       	mov	r10,7
80003f00:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003f02:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003f04:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003f06:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003f0a:	30 9b       	mov	r11,9
80003f0c:	fa cc ff fe 	sub	r12,sp,-2
80003f10:	f0 1f 00 02 	mcall	80003f18 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003f14:	2c dd       	sub	sp,-204
80003f16:	d8 02       	popm	pc
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	3e 08       	mov	r8,-32

80003f1c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003f1c:	d4 01       	pushm	lr
80003f1e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003f22:	fe 78 80 00 	mov	r8,-32768
80003f26:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003f28:	30 38       	mov	r8,3
80003f2a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003f2c:	30 1b       	mov	r11,1
80003f2e:	fa cc ff fe 	sub	r12,sp,-2
80003f32:	f0 1f 00 03 	mcall	80003f3c <xcmp_opcode_not_supported+0x20>
}
80003f36:	2c dd       	sub	sp,-204
80003f38:	d8 02       	popm	pc
80003f3a:	00 00       	add	r0,r0
80003f3c:	80 00       	ld.sh	r0,r0[0x0]
80003f3e:	3e 08       	mov	r8,-32

80003f40 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003f40:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003f42:	96 88       	ld.uh	r8,r11[0x0]
80003f44:	e2 18 f0 00 	andl	r8,0xf000,COH
80003f48:	e0 48 80 00 	cp.w	r8,32768
80003f4c:	c0 f0       	breq	80003f6a <xcmp_exec_func+0x2a>
80003f4e:	e0 48 b0 00 	cp.w	r8,45056
80003f52:	c1 20       	breq	80003f76 <xcmp_exec_func+0x36>
80003f54:	58 08       	cp.w	r8,0
80003f56:	c1 51       	brne	80003f80 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003f58:	78 08       	ld.w	r8,r12[0x0]
80003f5a:	58 08       	cp.w	r8,0
80003f5c:	c0 40       	breq	80003f64 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003f5e:	16 9c       	mov	r12,r11
80003f60:	5d 18       	icall	r8
80003f62:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003f64:	f0 1f 00 08 	mcall	80003f84 <xcmp_exec_func+0x44>
80003f68:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003f6a:	78 18       	ld.w	r8,r12[0x4]
80003f6c:	58 08       	cp.w	r8,0
80003f6e:	c0 90       	breq	80003f80 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003f70:	16 9c       	mov	r12,r11
80003f72:	5d 18       	icall	r8
80003f74:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003f76:	78 28       	ld.w	r8,r12[0x8]
80003f78:	58 08       	cp.w	r8,0
80003f7a:	c0 30       	breq	80003f80 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003f7c:	16 9c       	mov	r12,r11
80003f7e:	5d 18       	icall	r8
80003f80:	d8 02       	popm	pc
80003f82:	00 00       	add	r0,r0
80003f84:	80 00       	ld.sh	r0,r0[0x0]
80003f86:	3f 1c       	mov	r12,-15

80003f88 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003f88:	d4 01       	pushm	lr
80003f8a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003f8e:	e0 68 04 09 	mov	r8,1033
80003f92:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003f94:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003f98:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003f9a:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003f9e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003fa0:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003fa2:	30 09       	mov	r9,0
80003fa4:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003fa6:	fb 69 00 08 	st.b	sp[8],r9
80003faa:	fa c8 ff f7 	sub	r8,sp,-9
80003fae:	b0 89       	st.b	r8[0x0],r9
80003fb0:	fa c8 ff f6 	sub	r8,sp,-10
80003fb4:	b0 89       	st.b	r8[0x0],r9
80003fb6:	fa c8 ff f5 	sub	r8,sp,-11
80003fba:	b0 89       	st.b	r8[0x0],r9
80003fbc:	fa c8 ff f4 	sub	r8,sp,-12
80003fc0:	b0 89       	st.b	r8[0x0],r9
80003fc2:	fa c8 ff f3 	sub	r8,sp,-13
80003fc6:	b0 89       	st.b	r8[0x0],r9
80003fc8:	fa c8 ff f2 	sub	r8,sp,-14
80003fcc:	b0 89       	st.b	r8[0x0],r9
80003fce:	fa c8 ff f1 	sub	r8,sp,-15
80003fd2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003fd4:	30 cb       	mov	r11,12
80003fd6:	fa cc ff fe 	sub	r12,sp,-2
80003fda:	f0 1f 00 03 	mcall	80003fe4 <xcmp_IdleTestTone+0x5c>
}
80003fde:	2c dd       	sub	sp,-204
80003fe0:	d8 02       	popm	pc
80003fe2:	00 00       	add	r0,r0
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	3e 08       	mov	r8,-32

80003fe8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003fe8:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003fea:	48 dc       	lddpc	r12,8000401c <xcmp_init+0x34>
80003fec:	f0 1f 00 0d 	mcall	80004020 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003ff0:	30 4b       	mov	r11,4
80003ff2:	31 4c       	mov	r12,20
80003ff4:	f0 1f 00 0c 	mcall	80004024 <xcmp_init+0x3c>
80003ff8:	48 c8       	lddpc	r8,80004028 <xcmp_init+0x40>
80003ffa:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003ffc:	30 09       	mov	r9,0
80003ffe:	1a d9       	st.w	--sp,r9
80004000:	1a d9       	st.w	--sp,r9
80004002:	1a d9       	st.w	--sp,r9
80004004:	30 38       	mov	r8,3
80004006:	e0 6a 04 00 	mov	r10,1024
8000400a:	48 9b       	lddpc	r11,8000402c <xcmp_init+0x44>
8000400c:	48 9c       	lddpc	r12,80004030 <xcmp_init+0x48>
8000400e:	f0 1f 00 0a 	mcall	80004034 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004012:	f0 1f 00 0a 	mcall	80004038 <xcmp_init+0x50>
80004016:	2f dd       	sub	sp,-12
	
}
80004018:	d8 02       	popm	pc
8000401a:	00 00       	add	r0,r0
8000401c:	80 00       	ld.sh	r0,r0[0x0]
8000401e:	41 38       	lddsp	r8,sp[0x4c]
80004020:	80 00       	ld.sh	r0,r0[0x0]
80004022:	41 84       	lddsp	r4,sp[0x60]
80004024:	80 00       	ld.sh	r0,r0[0x0]
80004026:	63 1c       	ld.w	r12,r1[0x44]
80004028:	00 00       	add	r0,r0
8000402a:	0b 04       	ld.w	r4,r5++
8000402c:	80 00       	ld.sh	r0,r0[0x0]
8000402e:	d5 f8       	*unknown*
80004030:	80 00       	ld.sh	r0,r0[0x0]
80004032:	40 3c       	lddsp	r12,sp[0xc]
80004034:	80 00       	ld.sh	r0,r0[0x0]
80004036:	6a 38       	ld.w	r8,r5[0xc]
80004038:	80 00       	ld.sh	r0,r0[0x0]
8000403a:	41 bc       	lddsp	r12,sp[0x6c]

8000403c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000403c:	d4 31       	pushm	r0-r7,lr
8000403e:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004040:	4b 16       	lddpc	r6,80004104 <xcmp_rx_process+0xc8>
80004042:	30 05       	mov	r5,0
80004044:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004046:	4b 13       	lddpc	r3,80004108 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004048:	4b 12       	lddpc	r2,8000410c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000404a:	4b 21       	lddpc	r1,80004110 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000404c:	4b 20       	lddpc	r0,80004114 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000404e:	6c 0c       	ld.w	r12,r6[0x0]
80004050:	0a 99       	mov	r9,r5
80004052:	08 9a       	mov	r10,r4
80004054:	1a 9b       	mov	r11,sp
80004056:	f0 1f 00 31 	mcall	80004118 <xcmp_rx_process+0xdc>
8000405a:	58 1c       	cp.w	r12,1
8000405c:	cf 91       	brne	8000404e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000405e:	40 0b       	lddsp	r11,sp[0x0]
80004060:	58 0b       	cp.w	r11,0
80004062:	cf 60       	breq	8000404e <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004064:	96 0a       	ld.sh	r10,r11[0x0]
80004066:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000406a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000406e:	59 c8       	cp.w	r8,28
80004070:	c1 e0       	breq	800040ac <xcmp_rx_process+0x70>
80004072:	e0 89 00 07 	brgt	80004080 <xcmp_rx_process+0x44>
80004076:	58 e8       	cp.w	r8,14
80004078:	c0 e0       	breq	80004094 <xcmp_rx_process+0x58>
8000407a:	58 f8       	cp.w	r8,15
8000407c:	c2 41       	brne	800040c4 <xcmp_rx_process+0x88>
8000407e:	c0 f8       	rjmp	8000409c <xcmp_rx_process+0x60>
80004080:	e0 48 01 09 	cp.w	r8,265
80004084:	c1 80       	breq	800040b4 <xcmp_rx_process+0x78>
80004086:	e0 48 01 0a 	cp.w	r8,266
8000408a:	c1 90       	breq	800040bc <xcmp_rx_process+0x80>
8000408c:	e0 48 00 2c 	cp.w	r8,44
80004090:	c1 a1       	brne	800040c4 <xcmp_rx_process+0x88>
80004092:	c0 98       	rjmp	800040a4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004094:	4a 2c       	lddpc	r12,8000411c <xcmp_rx_process+0xe0>
80004096:	f0 1f 00 23 	mcall	80004120 <xcmp_rx_process+0xe4>
					break;
8000409a:	c2 f8       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000409c:	4a 2c       	lddpc	r12,80004124 <xcmp_rx_process+0xe8>
8000409e:	f0 1f 00 21 	mcall	80004120 <xcmp_rx_process+0xe4>
					break;
800040a2:	c2 b8       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800040a4:	4a 1c       	lddpc	r12,80004128 <xcmp_rx_process+0xec>
800040a6:	f0 1f 00 1f 	mcall	80004120 <xcmp_rx_process+0xe4>
					break;
800040aa:	c2 78       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800040ac:	04 9c       	mov	r12,r2
800040ae:	f0 1f 00 1d 	mcall	80004120 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800040b2:	c2 38       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800040b4:	02 9c       	mov	r12,r1
800040b6:	f0 1f 00 1b 	mcall	80004120 <xcmp_rx_process+0xe4>
					break;
800040ba:	c1 f8       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800040bc:	00 9c       	mov	r12,r0
800040be:	f0 1f 00 19 	mcall	80004120 <xcmp_rx_process+0xe4>
					break;
800040c2:	c1 b8       	rjmp	800040f8 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800040c4:	12 98       	mov	r8,r9
800040c6:	e2 18 04 00 	andl	r8,0x400,COH
800040ca:	c0 70       	breq	800040d8 <xcmp_rx_process+0x9c>
800040cc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800040d0:	e0 48 00 68 	cp.w	r8,104
800040d4:	e0 8a 00 08 	brle	800040e4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800040d8:	e2 19 f0 00 	andl	r9,0xf000,COH
800040dc:	c0 e1       	brne	800040f8 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800040de:	f0 1f 00 14 	mcall	8000412c <xcmp_rx_process+0xf0>
800040e2:	c0 b8       	rjmp	800040f8 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800040e4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800040e8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800040ec:	49 19       	lddpc	r9,80004130 <xcmp_rx_process+0xf4>
800040ee:	72 08       	ld.w	r8,r9[0x0]
800040f0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800040f4:	f0 1f 00 0b 	mcall	80004120 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800040f8:	66 0c       	ld.w	r12,r3[0x0]
800040fa:	40 0b       	lddsp	r11,sp[0x0]
800040fc:	f0 1f 00 0e 	mcall	80004134 <xcmp_rx_process+0xf8>
80004100:	ca 7b       	rjmp	8000404e <xcmp_rx_process+0x12>
80004102:	00 00       	add	r0,r0
80004104:	00 00       	add	r0,r0
80004106:	0b 04       	ld.w	r4,r5++
80004108:	00 00       	add	r0,r0
8000410a:	0a 9c       	mov	r12,r5
8000410c:	00 00       	add	r0,r0
8000410e:	0b 14       	ld.sh	r4,r5++
80004110:	00 00       	add	r0,r0
80004112:	0b 08       	ld.w	r8,r5++
80004114:	00 00       	add	r0,r0
80004116:	0a f8       	st.b	--r5,r8
80004118:	80 00       	ld.sh	r0,r0[0x0]
8000411a:	60 10       	ld.w	r0,r0[0x4]
8000411c:	00 00       	add	r0,r0
8000411e:	0b 2c       	ld.uh	r12,r5++
80004120:	80 00       	ld.sh	r0,r0[0x0]
80004122:	3f 40       	mov	r0,-12
80004124:	00 00       	add	r0,r0
80004126:	0a ec       	st.h	--r5,r12
80004128:	00 00       	add	r0,r0
8000412a:	0b 20       	ld.uh	r0,r5++
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	3f 1c       	mov	r12,-15
80004130:	00 00       	add	r0,r0
80004132:	51 18       	stdsp	sp[0x44],r8
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	2b 24       	sub	r4,-78

80004138 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004138:	eb cd 40 90 	pushm	r4,r7,lr
8000413c:	20 1d       	sub	sp,4
8000413e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004142:	48 c8       	lddpc	r8,80004170 <xcmp_rx+0x38>
80004144:	70 0c       	ld.w	r12,r8[0x0]
80004146:	f0 1f 00 0c 	mcall	80004174 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000414a:	c1 00       	breq	8000416a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000414c:	fa c7 ff fc 	sub	r7,sp,-4
80004150:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004152:	e0 6a 00 ca 	mov	r10,202
80004156:	08 9b       	mov	r11,r4
80004158:	f0 1f 00 08 	mcall	80004178 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000415c:	48 88       	lddpc	r8,8000417c <xcmp_rx+0x44>
8000415e:	70 0c       	ld.w	r12,r8[0x0]
80004160:	30 09       	mov	r9,0
80004162:	12 9a       	mov	r10,r9
80004164:	1a 9b       	mov	r11,sp
80004166:	f0 1f 00 07 	mcall	80004180 <xcmp_rx+0x48>
	}	
}
8000416a:	2f fd       	sub	sp,-4
8000416c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004170:	00 00       	add	r0,r0
80004172:	0a 9c       	mov	r12,r5
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	2c d0       	sub	r0,-51
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	76 78       	ld.w	r8,r11[0x1c]
8000417c:	00 00       	add	r0,r0
8000417e:	0b 04       	ld.w	r4,r5++
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	62 1c       	ld.w	r12,r1[0x4]

80004184 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004184:	48 28       	lddpc	r8,8000418c <xnl_register_xcmp_func+0x8>
80004186:	91 0c       	st.w	r8[0x0],r12
}
80004188:	5e fc       	retal	r12
8000418a:	00 00       	add	r0,r0
8000418c:	00 00       	add	r0,r0
8000418e:	0b 58       	ld.sh	r8,--r5

80004190 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004190:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004192:	48 88       	lddpc	r8,800041b0 <xnl_get_msg_ack_func+0x20>
80004194:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004196:	98 49       	ld.sh	r9,r12[0x8]
80004198:	f0 09 19 00 	cp.h	r9,r8
8000419c:	c0 81       	brne	800041ac <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000419e:	48 68       	lddpc	r8,800041b4 <xnl_get_msg_ack_func+0x24>
800041a0:	70 0c       	ld.w	r12,r8[0x0]
800041a2:	30 09       	mov	r9,0
800041a4:	12 9a       	mov	r10,r9
800041a6:	12 9b       	mov	r11,r9
800041a8:	f0 1f 00 04 	mcall	800041b8 <xnl_get_msg_ack_func+0x28>
800041ac:	d8 02       	popm	pc
800041ae:	00 00       	add	r0,r0
800041b0:	00 00       	add	r0,r0
800041b2:	0b 3e       	ld.ub	lr,r5++
800041b4:	00 00       	add	r0,r0
800041b6:	0b 38       	ld.ub	r8,r5++
800041b8:	80 00       	ld.sh	r0,r0[0x0]
800041ba:	62 1c       	ld.w	r12,r1[0x4]

800041bc <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800041bc:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800041c0:	30 09       	mov	r9,0
800041c2:	4b 78       	lddpc	r8,8000429c <xnl_init+0xe0>
800041c4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800041c6:	30 0b       	mov	r11,0
800041c8:	30 1c       	mov	r12,1
800041ca:	f0 1f 00 36 	mcall	800042a0 <xnl_init+0xe4>
800041ce:	4b 68       	lddpc	r8,800042a4 <xnl_init+0xe8>
800041d0:	91 0c       	st.w	r8[0x0],r12
800041d2:	70 08       	ld.w	r8,r8[0x0]
800041d4:	58 08       	cp.w	r8,0
800041d6:	c0 80       	breq	800041e6 <xnl_init+0x2a>
800041d8:	4b 38       	lddpc	r8,800042a4 <xnl_init+0xe8>
800041da:	70 0c       	ld.w	r12,r8[0x0]
800041dc:	30 09       	mov	r9,0
800041de:	12 9a       	mov	r10,r9
800041e0:	12 9b       	mov	r11,r9
800041e2:	f0 1f 00 32 	mcall	800042a8 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800041e6:	30 4b       	mov	r11,4
800041e8:	31 4c       	mov	r12,20
800041ea:	f0 1f 00 2e 	mcall	800042a0 <xnl_init+0xe4>
800041ee:	4b 08       	lddpc	r8,800042ac <xnl_init+0xf0>
800041f0:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800041f2:	30 4b       	mov	r11,4
800041f4:	31 ec       	mov	r12,30
800041f6:	f0 1f 00 2b 	mcall	800042a0 <xnl_init+0xe4>
800041fa:	4a e8       	lddpc	r8,800042b0 <xnl_init+0xf4>
800041fc:	91 0c       	st.w	r8[0x0],r12
800041fe:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004200:	10 96       	mov	r6,r8
80004202:	4a d5       	lddpc	r5,800042b4 <xnl_init+0xf8>
80004204:	6c 0c       	ld.w	r12,r6[0x0]
80004206:	ea 07 00 0b 	add	r11,r5,r7
8000420a:	f0 1f 00 2c 	mcall	800042b8 <xnl_init+0xfc>
8000420e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004212:	e0 47 1e 00 	cp.w	r7,7680
80004216:	cf 71       	brne	80004204 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004218:	30 4b       	mov	r11,4
8000421a:	31 4c       	mov	r12,20
8000421c:	f0 1f 00 21 	mcall	800042a0 <xnl_init+0xe4>
80004220:	4a 78       	lddpc	r8,800042bc <xnl_init+0x100>
80004222:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004224:	30 4b       	mov	r11,4
80004226:	30 ac       	mov	r12,10
80004228:	f0 1f 00 1e 	mcall	800042a0 <xnl_init+0xe4>
8000422c:	4a 58       	lddpc	r8,800042c0 <xnl_init+0x104>
8000422e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004230:	30 4b       	mov	r11,4
80004232:	30 ac       	mov	r12,10
80004234:	f0 1f 00 1b 	mcall	800042a0 <xnl_init+0xe4>
80004238:	4a 38       	lddpc	r8,800042c4 <xnl_init+0x108>
8000423a:	91 0c       	st.w	r8[0x0],r12
8000423c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000423e:	10 96       	mov	r6,r8
80004240:	4a 25       	lddpc	r5,800042c8 <xnl_init+0x10c>
80004242:	6c 0c       	ld.w	r12,r6[0x0]
80004244:	ea 07 00 0b 	add	r11,r5,r7
80004248:	f0 1f 00 1c 	mcall	800042b8 <xnl_init+0xfc>
8000424c:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004250:	e0 47 14 00 	cp.w	r7,5120
80004254:	cf 71       	brne	80004242 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004256:	30 4b       	mov	r11,4
80004258:	30 5c       	mov	r12,5
8000425a:	f0 1f 00 12 	mcall	800042a0 <xnl_init+0xe4>
8000425e:	49 c8       	lddpc	r8,800042cc <xnl_init+0x110>
80004260:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004262:	30 07       	mov	r7,0
80004264:	1a d7       	st.w	--sp,r7
80004266:	1a d7       	st.w	--sp,r7
80004268:	1a d7       	st.w	--sp,r7
8000426a:	30 38       	mov	r8,3
8000426c:	0e 99       	mov	r9,r7
8000426e:	e0 6a 00 dc 	mov	r10,220
80004272:	49 8b       	lddpc	r11,800042d0 <xnl_init+0x114>
80004274:	49 8c       	lddpc	r12,800042d4 <xnl_init+0x118>
80004276:	f0 1f 00 19 	mcall	800042d8 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000427a:	1a d7       	st.w	--sp,r7
8000427c:	1a d7       	st.w	--sp,r7
8000427e:	1a d7       	st.w	--sp,r7
80004280:	30 38       	mov	r8,3
80004282:	0e 99       	mov	r9,r7
80004284:	e0 6a 00 82 	mov	r10,130
80004288:	49 5b       	lddpc	r11,800042dc <xnl_init+0x120>
8000428a:	49 6c       	lddpc	r12,800042e0 <xnl_init+0x124>
8000428c:	f0 1f 00 13 	mcall	800042d8 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004290:	f0 1f 00 15 	mcall	800042e4 <xnl_init+0x128>
80004294:	2f ad       	sub	sp,-24
}
80004296:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000429a:	00 00       	add	r0,r0
8000429c:	00 00       	add	r0,r0
8000429e:	0b 3e       	ld.ub	lr,r5++
800042a0:	80 00       	ld.sh	r0,r0[0x0]
800042a2:	63 1c       	ld.w	r12,r1[0x44]
800042a4:	00 00       	add	r0,r0
800042a6:	0b 38       	ld.ub	r8,r5++
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	62 1c       	ld.w	r12,r1[0x4]
800042ac:	00 00       	add	r0,r0
800042ae:	0b 4c       	ld.w	r12,--r5
800042b0:	00 00       	add	r0,r0
800042b2:	0a 9c       	mov	r12,r5
800042b4:	00 00       	add	r0,r0
800042b6:	32 ca       	mov	r10,44
800042b8:	80 00       	ld.sh	r0,r0[0x0]
800042ba:	2b 24       	sub	r4,-78
800042bc:	00 00       	add	r0,r0
800042be:	0a cc       	st.b	r5++,r12
800042c0:	00 00       	add	r0,r0
800042c2:	0a ac       	st.w	r5++,r12
800042c4:	00 00       	add	r0,r0
800042c6:	0a a0       	st.w	r5++,r0
800042c8:	00 00       	add	r0,r0
800042ca:	1e ca       	st.b	pc++,r10
800042cc:	00 00       	add	r0,r0
800042ce:	0a d8       	st.w	--r5,r8
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	d6 00       	acall	0x60
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	42 e8       	lddsp	r8,sp[0xb8]
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	6a 38       	ld.w	r8,r5[0xc]
800042dc:	80 00       	ld.sh	r0,r0[0x0]
800042de:	d6 08       	*unknown*
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	43 48       	lddsp	r8,sp[0xd0]
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	2c f8       	sub	r8,-49

800042e8 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800042e8:	eb cd 40 fe 	pushm	r1-r7,lr
800042ec:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042ee:	49 26       	lddpc	r6,80004334 <xnl_rx_process+0x4c>
800042f0:	30 05       	mov	r5,0
800042f2:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800042f4:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800042f6:	49 11       	lddpc	r1,80004338 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800042f8:	49 12       	lddpc	r2,8000433c <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800042fa:	6c 0c       	ld.w	r12,r6[0x0]
800042fc:	0a 99       	mov	r9,r5
800042fe:	08 9a       	mov	r10,r4
80004300:	1a 9b       	mov	r11,sp
80004302:	f0 1f 00 10 	mcall	80004340 <xnl_rx_process+0x58>
80004306:	58 1c       	cp.w	r12,1
80004308:	cf 91       	brne	800042fa <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000430a:	40 0c       	lddsp	r12,sp[0x0]
8000430c:	58 0c       	cp.w	r12,0
8000430e:	cf 60       	breq	800042fa <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004310:	98 28       	ld.sh	r8,r12[0x4]
80004312:	e6 08 19 00 	cp.h	r8,r3
80004316:	e0 8b 00 0a 	brhi	8000432a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000431a:	5c 78       	castu.h	r8
8000431c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004320:	58 09       	cp.w	r9,0
80004322:	c0 40       	breq	8000432a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004324:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004328:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000432a:	62 0c       	ld.w	r12,r1[0x0]
8000432c:	40 0b       	lddsp	r11,sp[0x0]
8000432e:	f0 1f 00 06 	mcall	80004344 <xnl_rx_process+0x5c>
80004332:	ce 4b       	rjmp	800042fa <xnl_rx_process+0x12>
80004334:	00 00       	add	r0,r0
80004336:	0a ac       	st.w	r5++,r12
80004338:	00 00       	add	r0,r0
8000433a:	0a 9c       	mov	r12,r5
8000433c:	00 00       	add	r0,r0
8000433e:	04 f4       	st.b	--r2,r4
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	60 10       	ld.w	r0,r0[0x4]
80004344:	80 00       	ld.sh	r0,r0[0x0]
80004346:	2b 24       	sub	r4,-78

80004348 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004348:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000434a:	4a a6       	lddpc	r6,800043f0 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000434c:	4a a2       	lddpc	r2,800043f4 <xnl_tx_process+0xac>
8000434e:	4a b4       	lddpc	r4,800043f8 <xnl_tx_process+0xb0>
80004350:	30 07       	mov	r7,0
80004352:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004354:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004356:	4a a5       	lddpc	r5,800043fc <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004358:	4a a3       	lddpc	r3,80004400 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000435a:	6c 08       	ld.w	r8,r6[0x0]
8000435c:	58 08       	cp.w	r8,0
8000435e:	c0 40       	breq	80004366 <xnl_tx_process+0x1e>
80004360:	58 18       	cp.w	r8,1
80004362:	cf d1       	brne	8000435c <xnl_tx_process+0x14>
80004364:	c2 48       	rjmp	800043ac <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004366:	64 0c       	ld.w	r12,r2[0x0]
80004368:	0e 99       	mov	r9,r7
8000436a:	02 9a       	mov	r10,r1
8000436c:	08 9b       	mov	r11,r4
8000436e:	f0 1f 00 26 	mcall	80004404 <xnl_tx_process+0xbc>
80004372:	58 1c       	cp.w	r12,1
80004374:	cf 31       	brne	8000435a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004376:	68 0b       	ld.w	r11,r4[0x0]
80004378:	58 0b       	cp.w	r11,0
8000437a:	cf 00       	breq	8000435a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000437c:	96 28       	ld.sh	r8,r11[0x4]
8000437e:	e0 08 19 00 	cp.h	r8,r0
80004382:	c0 71       	brne	80004390 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004384:	4a 18       	lddpc	r8,80004408 <xnl_tx_process+0xc0>
80004386:	70 08       	ld.w	r8,r8[0x0]
80004388:	10 9c       	mov	r12,r8
8000438a:	f0 1f 00 21 	mcall	8000440c <xnl_tx_process+0xc4>
						break;
8000438e:	ce 6b       	rjmp	8000435a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004390:	16 9c       	mov	r12,r11
80004392:	f0 1f 00 20 	mcall	80004410 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004396:	30 18       	mov	r8,1
80004398:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000439a:	66 0c       	ld.w	r12,r3[0x0]
8000439c:	0e 99       	mov	r9,r7
8000439e:	0e 9a       	mov	r10,r7
800043a0:	0e 9b       	mov	r11,r7
800043a2:	f0 1f 00 19 	mcall	80004404 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800043a6:	30 18       	mov	r8,1
800043a8:	8d 08       	st.w	r6[0x0],r8
800043aa:	cd 8b       	rjmp	8000435a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800043ac:	66 0c       	ld.w	r12,r3[0x0]
800043ae:	0e 99       	mov	r9,r7
800043b0:	36 4a       	mov	r10,100
800043b2:	0e 9b       	mov	r11,r7
800043b4:	f0 1f 00 14 	mcall	80004404 <xnl_tx_process+0xbc>
800043b8:	58 1c       	cp.w	r12,1
800043ba:	c0 81       	brne	800043ca <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800043bc:	49 38       	lddpc	r8,80004408 <xnl_tx_process+0xc0>
800043be:	70 0c       	ld.w	r12,r8[0x0]
800043c0:	68 0b       	ld.w	r11,r4[0x0]
800043c2:	f0 1f 00 13 	mcall	8000440c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800043c6:	8d 07       	st.w	r6[0x0],r7
800043c8:	cc 9b       	rjmp	8000435a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800043ca:	6a 08       	ld.w	r8,r5[0x0]
800043cc:	58 38       	cp.w	r8,3
800043ce:	e0 89 00 09 	brgt	800043e0 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800043d2:	68 0c       	ld.w	r12,r4[0x0]
800043d4:	f0 1f 00 0f 	mcall	80004410 <xnl_tx_process+0xc8>
						xnl_send_times++;
800043d8:	6a 08       	ld.w	r8,r5[0x0]
800043da:	2f f8       	sub	r8,-1
800043dc:	8b 08       	st.w	r5[0x0],r8
800043de:	cb eb       	rjmp	8000435a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800043e0:	48 a8       	lddpc	r8,80004408 <xnl_tx_process+0xc0>
800043e2:	70 0c       	ld.w	r12,r8[0x0]
800043e4:	68 0b       	ld.w	r11,r4[0x0]
800043e6:	f0 1f 00 0a 	mcall	8000440c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800043ea:	8d 07       	st.w	r6[0x0],r7
800043ec:	cb 7b       	rjmp	8000435a <xnl_tx_process+0x12>
800043ee:	00 00       	add	r0,r0
800043f0:	00 00       	add	r0,r0
800043f2:	0b 48       	ld.w	r8,--r5
800043f4:	00 00       	add	r0,r0
800043f6:	0b 4c       	ld.w	r12,--r5
800043f8:	00 00       	add	r0,r0
800043fa:	0b 54       	ld.sh	r4,--r5
800043fc:	00 00       	add	r0,r0
800043fe:	0b 50       	ld.sh	r0,--r5
80004400:	00 00       	add	r0,r0
80004402:	0b 38       	ld.ub	r8,r5++
80004404:	80 00       	ld.sh	r0,r0[0x0]
80004406:	60 10       	ld.w	r0,r0[0x4]
80004408:	00 00       	add	r0,r0
8000440a:	0a 9c       	mov	r12,r5
8000440c:	80 00       	ld.sh	r0,r0[0x0]
8000440e:	2b 24       	sub	r4,-78
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	2b 44       	sub	r4,-76

80004414 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004414:	eb cd 40 c0 	pushm	r6-r7,lr
80004418:	20 1d       	sub	sp,4
8000441a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000441c:	98 39       	ld.sh	r9,r12[0x6]
8000441e:	3f f8       	mov	r8,-1
80004420:	f0 09 19 00 	cp.h	r9,r8
80004424:	c0 a1       	brne	80004438 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004426:	4a e9       	lddpc	r9,800044dc <xnl_tx+0xc8>
80004428:	13 88       	ld.ub	r8,r9[0x0]
8000442a:	2f f8       	sub	r8,-1
8000442c:	5c 58       	castu.b	r8
8000442e:	b2 88       	st.b	r9[0x0],r8
80004430:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004434:	a9 a8       	sbr	r8,0x8
80004436:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004438:	8c 49       	ld.sh	r9,r6[0x8]
8000443a:	3f f8       	mov	r8,-1
8000443c:	f0 09 19 00 	cp.h	r9,r8
80004440:	c0 41       	brne	80004448 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004442:	4a 88       	lddpc	r8,800044e0 <xnl_tx+0xcc>
80004444:	90 18       	ld.sh	r8,r8[0x2]
80004446:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004448:	8c 59       	ld.sh	r9,r6[0xa]
8000444a:	3f f8       	mov	r8,-1
8000444c:	f0 09 19 00 	cp.h	r9,r8
80004450:	c0 41       	brne	80004458 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004452:	4a 48       	lddpc	r8,800044e0 <xnl_tx+0xcc>
80004454:	90 28       	ld.sh	r8,r8[0x4]
80004456:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004458:	8c 69       	ld.sh	r9,r6[0xc]
8000445a:	3f f8       	mov	r8,-1
8000445c:	f0 09 19 00 	cp.h	r9,r8
80004460:	c0 e1       	brne	8000447c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004462:	4a 08       	lddpc	r8,800044e0 <xnl_tx+0xcc>
80004464:	90 49       	ld.sh	r9,r8[0x8]
80004466:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004468:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000446a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000446c:	90 49       	ld.sh	r9,r8[0x8]
8000446e:	e0 19 ff 00 	andl	r9,0xff00
80004472:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004476:	f3 e8 10 08 	or	r8,r9,r8
8000447a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000447c:	0d 98       	ld.ub	r8,r6[0x1]
8000447e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004480:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004484:	10 0c       	add	r12,r8
80004486:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004488:	58 0c       	cp.w	r12,0
8000448a:	e0 89 00 04 	brgt	80004492 <xnl_tx+0x7e>
8000448e:	30 09       	mov	r9,0
80004490:	c0 d8       	rjmp	800044aa <xnl_tx+0x96>
80004492:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004496:	2f ec       	sub	r12,-2
80004498:	30 09       	mov	r9,0
8000449a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000449c:	15 1b       	ld.sh	r11,r10++
8000449e:	f6 09 00 09 	add	r9,r11,r9
800044a2:	5c 89       	casts.h	r9
		indextohWord     += 1;
800044a4:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800044a6:	18 38       	cp.w	r8,r12
800044a8:	cf a1       	brne	8000449c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800044aa:	5c 39       	neg	r9
800044ac:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800044ae:	48 e8       	lddpc	r8,800044e4 <xnl_tx+0xd0>
800044b0:	70 0c       	ld.w	r12,r8[0x0]
800044b2:	f0 1f 00 0e 	mcall	800044e8 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800044b6:	c1 00       	breq	800044d6 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800044b8:	fa c7 ff fc 	sub	r7,sp,-4
800044bc:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800044be:	e0 6a 01 00 	mov	r10,256
800044c2:	0c 9b       	mov	r11,r6
800044c4:	f0 1f 00 0a 	mcall	800044ec <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800044c8:	48 a8       	lddpc	r8,800044f0 <xnl_tx+0xdc>
800044ca:	70 0c       	ld.w	r12,r8[0x0]
800044cc:	30 09       	mov	r9,0
800044ce:	12 9a       	mov	r10,r9
800044d0:	1a 9b       	mov	r11,sp
800044d2:	f0 1f 00 09 	mcall	800044f4 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800044d6:	2f fd       	sub	sp,-4
800044d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800044dc:	00 00       	add	r0,r0
800044de:	0b 3c       	ld.ub	r12,r5++
800044e0:	00 00       	add	r0,r0
800044e2:	0b 3e       	ld.ub	lr,r5++
800044e4:	00 00       	add	r0,r0
800044e6:	0a 9c       	mov	r12,r5
800044e8:	80 00       	ld.sh	r0,r0[0x0]
800044ea:	2c d0       	sub	r0,-51
800044ec:	80 00       	ld.sh	r0,r0[0x0]
800044ee:	76 78       	ld.w	r8,r11[0x1c]
800044f0:	00 00       	add	r0,r0
800044f2:	0b 4c       	ld.w	r12,--r5
800044f4:	80 00       	ld.sh	r0,r0[0x0]
800044f6:	62 1c       	ld.w	r12,r1[0x4]

800044f8 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800044f8:	eb cd 40 80 	pushm	r7,lr
800044fc:	fa cd 01 00 	sub	sp,sp,256
80004500:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004502:	e0 68 40 0e 	mov	r8,16398
80004506:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004508:	3f f8       	mov	r8,-1
8000450a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000450c:	30 c8       	mov	r8,12
8000450e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004510:	98 38       	ld.sh	r8,r12[0x6]
80004512:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004514:	98 58       	ld.sh	r8,r12[0xa]
80004516:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004518:	98 48       	ld.sh	r8,r12[0x8]
8000451a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000451c:	98 68       	ld.sh	r8,r12[0xc]
8000451e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004520:	30 08       	mov	r8,0
80004522:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004524:	1a 9c       	mov	r12,sp
80004526:	f0 1f 00 0a 	mcall	8000454c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000452a:	fa cd 00 cc 	sub	sp,sp,204
8000452e:	e0 6a 00 ca 	mov	r10,202
80004532:	ee cb ff f0 	sub	r11,r7,-16
80004536:	1a 9c       	mov	r12,sp
80004538:	f0 1f 00 06 	mcall	80004550 <xnl_data_msg_func+0x58>
8000453c:	48 68       	lddpc	r8,80004554 <xnl_data_msg_func+0x5c>
8000453e:	70 08       	ld.w	r8,r8[0x0]
80004540:	5d 18       	icall	r8
80004542:	fa cd ff 34 	sub	sp,sp,-204
}
80004546:	2c 0d       	sub	sp,-256
80004548:	e3 cd 80 80 	ldm	sp++,r7,pc
8000454c:	80 00       	ld.sh	r0,r0[0x0]
8000454e:	44 14       	lddsp	r4,sp[0x104]
80004550:	80 00       	ld.sh	r0,r0[0x0]
80004552:	76 78       	ld.w	r8,r11[0x1c]
80004554:	00 00       	add	r0,r0
80004556:	0b 58       	ld.sh	r8,--r5

80004558 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004558:	d4 21       	pushm	r4-r7,lr
8000455a:	fa cd 01 00 	sub	sp,sp,256
8000455e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004560:	4c 28       	lddpc	r8,80004668 <xnl_device_auth_reply_func+0x110>
80004562:	11 88       	ld.ub	r8,r8[0x0]
80004564:	58 08       	cp.w	r8,0
80004566:	e0 81 00 7f 	brne	80004664 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000456a:	4c 18       	lddpc	r8,8000466c <xnl_device_auth_reply_func+0x114>
8000456c:	70 0c       	ld.w	r12,r8[0x0]
8000456e:	30 09       	mov	r9,0
80004570:	12 9a       	mov	r10,r9
80004572:	12 9b       	mov	r11,r9
80004574:	f0 1f 00 3f 	mcall	80004670 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004578:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000457c:	4b b8       	lddpc	r8,80004668 <xnl_device_auth_reply_func+0x110>
8000457e:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004580:	ef 39 00 12 	ld.ub	r9,r7[18]
80004584:	ef 38 00 13 	ld.ub	r8,r7[19]
80004588:	b1 68       	lsl	r8,0x10
8000458a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000458e:	ef 38 00 15 	ld.ub	r8,r7[21]
80004592:	f3 e8 10 08 	or	r8,r9,r8
80004596:	ef 39 00 14 	ld.ub	r9,r7[20]
8000459a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000459e:	ef 3a 00 16 	ld.ub	r10,r7[22]
800045a2:	ef 38 00 17 	ld.ub	r8,r7[23]
800045a6:	b1 68       	lsl	r8,0x10
800045a8:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800045ac:	ef 38 00 19 	ld.ub	r8,r7[25]
800045b0:	f5 e8 10 08 	or	r8,r10,r8
800045b4:	ef 3a 00 18 	ld.ub	r10,r7[24]
800045b8:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800045bc:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045be:	e0 64 79 b9 	mov	r4,31161
800045c2:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045c6:	e0 65 45 07 	mov	r5,17671
800045ca:	ea 15 8a bd 	orh	r5,0x8abd
800045ce:	e0 66 f9 3d 	mov	r6,63805
800045d2:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800045d6:	e0 6e b8 cf 	mov	lr,47311
800045da:	ea 1e 36 83 	orh	lr,0x3683
800045de:	e0 67 aa 1c 	mov	r7,43548
800045e2:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800045e6:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800045e8:	f4 08 00 0c 	add	r12,r10,r8
800045ec:	f0 0b 15 04 	lsl	r11,r8,0x4
800045f0:	0a 0b       	add	r11,r5
800045f2:	f9 eb 20 0b 	eor	r11,r12,r11
800045f6:	f0 0c 16 05 	lsr	r12,r8,0x5
800045fa:	0c 0c       	add	r12,r6
800045fc:	18 5b       	eor	r11,r12
800045fe:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004600:	f2 0c 15 04 	lsl	r12,r9,0x4
80004604:	1c 0c       	add	r12,lr
80004606:	f2 0b 16 05 	lsr	r11,r9,0x5
8000460a:	0e 0b       	add	r11,r7
8000460c:	f9 eb 20 0b 	eor	r11,r12,r11
80004610:	f2 0a 00 0c 	add	r12,r9,r10
80004614:	18 5b       	eor	r11,r12
80004616:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004618:	e0 6b 37 20 	mov	r11,14112
8000461c:	ea 1b c6 ef 	orh	r11,0xc6ef
80004620:	16 3a       	cp.w	r10,r11
80004622:	ce 21       	brne	800045e6 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004624:	e0 6a 40 1a 	mov	r10,16410
80004628:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000462a:	3f fa       	mov	r10,-1
8000462c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000462e:	30 6b       	mov	r11,6
80004630:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004632:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004634:	48 db       	lddpc	r11,80004668 <xnl_device_auth_reply_func+0x110>
80004636:	96 1c       	ld.sh	r12,r11[0x2]
80004638:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000463a:	96 2b       	ld.sh	r11,r11[0x4]
8000463c:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000463e:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004640:	30 ca       	mov	r10,12
80004642:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004644:	30 0a       	mov	r10,0
80004646:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000464a:	30 7a       	mov	r10,7
8000464c:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004650:	30 2a       	mov	r10,2
80004652:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004656:	fa ca ff ec 	sub	r10,sp,-20
8000465a:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000465c:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000465e:	1a 9c       	mov	r12,sp
80004660:	f0 1f 00 05 	mcall	80004674 <xnl_device_auth_reply_func+0x11c>
}
80004664:	2c 0d       	sub	sp,-256
80004666:	d8 22       	popm	r4-r7,pc
80004668:	00 00       	add	r0,r0
8000466a:	0b 3e       	ld.ub	lr,r5++
8000466c:	00 00       	add	r0,r0
8000466e:	0b 38       	ld.ub	r8,r5++
80004670:	80 00       	ld.sh	r0,r0[0x0]
80004672:	62 1c       	ld.w	r12,r1[0x4]
80004674:	80 00       	ld.sh	r0,r0[0x0]
80004676:	44 14       	lddsp	r4,sp[0x104]

80004678 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004678:	eb cd 40 80 	pushm	r7,lr
8000467c:	fa cd 01 00 	sub	sp,sp,256
80004680:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004682:	49 28       	lddpc	r8,800046c8 <xnl_master_status_brdcst_func+0x50>
80004684:	11 88       	ld.ub	r8,r8[0x0]
80004686:	58 08       	cp.w	r8,0
80004688:	c1 c1       	brne	800046c0 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
8000468a:	49 18       	lddpc	r8,800046cc <xnl_master_status_brdcst_func+0x54>
8000468c:	70 0c       	ld.w	r12,r8[0x0]
8000468e:	30 09       	mov	r9,0
80004690:	12 9a       	mov	r10,r9
80004692:	12 9b       	mov	r11,r9
80004694:	f0 1f 00 0f 	mcall	800046d0 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004698:	8e 58       	ld.sh	r8,r7[0xa]
8000469a:	48 c9       	lddpc	r9,800046c8 <xnl_master_status_brdcst_func+0x50>
8000469c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000469e:	e0 68 40 0e 	mov	r8,16398
800046a2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800046a4:	3f f8       	mov	r8,-1
800046a6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800046a8:	30 4a       	mov	r10,4
800046aa:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800046ac:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800046ae:	92 19       	ld.sh	r9,r9[0x2]
800046b0:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800046b2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800046b4:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800046b6:	30 08       	mov	r8,0
800046b8:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800046ba:	1a 9c       	mov	r12,sp
800046bc:	f0 1f 00 06 	mcall	800046d4 <xnl_master_status_brdcst_func+0x5c>
}
800046c0:	2c 0d       	sub	sp,-256
800046c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800046c6:	00 00       	add	r0,r0
800046c8:	00 00       	add	r0,r0
800046ca:	0b 3e       	ld.ub	lr,r5++
800046cc:	00 00       	add	r0,r0
800046ce:	0b 38       	ld.ub	r8,r5++
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	62 1c       	ld.w	r12,r1[0x4]
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	44 14       	lddsp	r4,sp[0x104]

800046d8 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
800046d8:	eb cd 40 80 	pushm	r7,lr
800046dc:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
800046de:	49 28       	lddpc	r8,80004724 <xnl_device_conn_reply_func+0x4c>
800046e0:	70 0c       	ld.w	r12,r8[0x0]
800046e2:	30 09       	mov	r9,0
800046e4:	12 9a       	mov	r10,r9
800046e6:	12 9b       	mov	r11,r9
800046e8:	f0 1f 00 10 	mcall	80004728 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
800046ec:	ef 18 00 10 	ld.uh	r8,r7[16]
800046f0:	10 99       	mov	r9,r8
800046f2:	e2 19 ff 00 	andl	r9,0xff00,COH
800046f6:	e0 49 01 00 	cp.w	r9,256
800046fa:	c0 60       	breq	80004706 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
800046fc:	0e 9c       	mov	r12,r7
800046fe:	f0 1f 00 0c 	mcall	8000472c <xnl_device_conn_reply_func+0x54>
80004702:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004706:	a9 68       	lsl	r8,0x8
80004708:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000470c:	48 98       	lddpc	r8,80004730 <xnl_device_conn_reply_func+0x58>
8000470e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004710:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004714:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004716:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000471a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000471c:	30 19       	mov	r9,1
8000471e:	b0 89       	st.b	r8[0x0],r9
80004720:	e3 cd 80 80 	ldm	sp++,r7,pc
80004724:	00 00       	add	r0,r0
80004726:	0b 38       	ld.ub	r8,r5++
80004728:	80 00       	ld.sh	r0,r0[0x0]
8000472a:	62 1c       	ld.w	r12,r1[0x4]
8000472c:	80 00       	ld.sh	r0,r0[0x0]
8000472e:	46 78       	lddsp	r8,sp[0x19c]
80004730:	00 00       	add	r0,r0
80004732:	0b 3e       	ld.ub	lr,r5++

80004734 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004734:	d4 01       	pushm	lr
80004736:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000473a:	e0 68 40 0e 	mov	r8,16398
8000473e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004740:	3f f8       	mov	r8,-1
80004742:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004744:	30 38       	mov	r8,3
80004746:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004748:	30 08       	mov	r8,0
8000474a:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000474c:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000474e:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004750:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004752:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004754:	1a 9c       	mov	r12,sp
80004756:	f0 1f 00 03 	mcall	80004760 <xnl_send_device_master_query+0x2c>
}
8000475a:	2c 0d       	sub	sp,-256
8000475c:	d8 02       	popm	pc
8000475e:	00 00       	add	r0,r0
80004760:	80 00       	ld.sh	r0,r0[0x0]
80004762:	44 14       	lddsp	r4,sp[0x104]

80004764 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004764:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004766:	48 78       	lddpc	r8,80004780 <RC522_SPI_SetSpeed+0x1c>
80004768:	70 09       	ld.w	r9,r8[0x0]
8000476a:	72 ca       	ld.w	r10,r9[0x30]
8000476c:	5c 7c       	castu.h	r12
8000476e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80004772:	f9 ea 10 0a 	or	r10,r12,r10
80004776:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
80004778:	70 0c       	ld.w	r12,r8[0x0]
8000477a:	f0 1f 00 03 	mcall	80004784 <RC522_SPI_SetSpeed+0x20>
		
	
}
8000477e:	d8 02       	popm	pc
80004780:	00 00       	add	r0,r0
80004782:	1d a4       	ld.ub	r4,lr[0x2]
80004784:	80 00       	ld.sh	r0,r0[0x0]
80004786:	57 0c       	stdsp	sp[0x1c0],r12

80004788 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
80004788:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0A00);//baudDiv=4
8000478a:	e0 6c 0a 00 	mov	r12,2560
8000478e:	f0 1f 00 02 	mcall	80004794 <RC522_SPI_SetSpeedLow+0xc>
	
}
80004792:	d8 02       	popm	pc
80004794:	80 00       	ld.sh	r0,r0[0x0]
80004796:	47 64       	lddsp	r4,sp[0x1d8]

80004798 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004798:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
8000479c:	48 76       	lddpc	r6,800047b8 <RC522_ReadByte+0x20>
8000479e:	e0 6b 00 ff 	mov	r11,255
800047a2:	6c 0c       	ld.w	r12,r6[0x0]
800047a4:	f0 1f 00 06 	mcall	800047bc <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800047a8:	30 07       	mov	r7,0
800047aa:	0e 9b       	mov	r11,r7
800047ac:	6c 0c       	ld.w	r12,r6[0x0]
800047ae:	f0 1f 00 05 	mcall	800047c0 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800047b2:	0f 9c       	ld.ub	r12,r7[0x1]
800047b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800047b8:	00 00       	add	r0,r0
800047ba:	1d a4       	ld.ub	r4,lr[0x2]
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	57 12       	stdsp	sp[0x1c4],r2
800047c0:	80 00       	ld.sh	r0,r0[0x0]
800047c2:	57 2e       	stdsp	sp[0x1c8],lr

800047c4 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800047c4:	eb cd 40 80 	pushm	r7,lr
800047c8:	20 1d       	sub	sp,4
800047ca:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800047cc:	48 77       	lddpc	r7,800047e8 <RC522_WriteByte+0x24>
800047ce:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800047d2:	6e 0c       	ld.w	r12,r7[0x0]
800047d4:	f0 1f 00 06 	mcall	800047ec <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800047d8:	1a 9b       	mov	r11,sp
800047da:	6e 0c       	ld.w	r12,r7[0x0]
800047dc:	f0 1f 00 05 	mcall	800047f0 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800047e0:	5c 5c       	castu.b	r12
800047e2:	2f fd       	sub	sp,-4
800047e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800047e8:	00 00       	add	r0,r0
800047ea:	1d a4       	ld.ub	r4,lr[0x2]
800047ec:	80 00       	ld.sh	r0,r0[0x0]
800047ee:	57 12       	stdsp	sp[0x1c4],r2
800047f0:	80 00       	ld.sh	r0,r0[0x0]
800047f2:	57 2e       	stdsp	sp[0x1c8],lr

800047f4 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800047f4:	eb cd 40 e0 	pushm	r5-r7,lr
800047f8:	18 96       	mov	r6,r12
800047fa:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800047fc:	48 a7       	lddpc	r7,80004824 <WriteRawRC+0x30>
800047fe:	30 0b       	mov	r11,0
80004800:	6e 0c       	ld.w	r12,r7[0x0]
80004802:	f0 1f 00 0a 	mcall	80004828 <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004806:	ec 0c 15 01 	lsl	r12,r6,0x1
8000480a:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000480e:	f0 1f 00 08 	mcall	8000482c <WriteRawRC+0x38>
	RC522_WriteByte(value);
80004812:	0a 9c       	mov	r12,r5
80004814:	f0 1f 00 06 	mcall	8000482c <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004818:	30 0b       	mov	r11,0
8000481a:	6e 0c       	ld.w	r12,r7[0x0]
8000481c:	f0 1f 00 05 	mcall	80004830 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80004820:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004824:	00 00       	add	r0,r0
80004826:	1d a4       	ld.ub	r4,lr[0x2]
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	58 78       	cp.w	r8,7
8000482c:	80 00       	ld.sh	r0,r0[0x0]
8000482e:	47 c4       	lddsp	r4,sp[0x1f0]
80004830:	80 00       	ld.sh	r0,r0[0x0]
80004832:	58 38       	cp.w	r8,3

80004834 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004834:	d4 01       	pushm	lr

	SET_RC522RST;
80004836:	31 9c       	mov	r12,25
80004838:	f0 1f 00 1b 	mcall	800048a4 <PcdReset+0x70>
	delay_ns(10);
8000483c:	30 ac       	mov	r12,10
8000483e:	f0 1f 00 1b 	mcall	800048a8 <PcdReset+0x74>

	CLR_RC522RST;
80004842:	31 9c       	mov	r12,25
80004844:	f0 1f 00 1a 	mcall	800048ac <PcdReset+0x78>
	delay_ns(10);
80004848:	30 ac       	mov	r12,10
8000484a:	f0 1f 00 18 	mcall	800048a8 <PcdReset+0x74>

	SET_RC522RST;
8000484e:	31 9c       	mov	r12,25
80004850:	f0 1f 00 15 	mcall	800048a4 <PcdReset+0x70>
	delay_ns(10);
80004854:	30 ac       	mov	r12,10
80004856:	f0 1f 00 15 	mcall	800048a8 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000485a:	30 fb       	mov	r11,15
8000485c:	30 1c       	mov	r12,1
8000485e:	f0 1f 00 15 	mcall	800048b0 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004862:	30 fb       	mov	r11,15
80004864:	30 1c       	mov	r12,1
80004866:	f0 1f 00 13 	mcall	800048b0 <PcdReset+0x7c>
	delay_ns(10);
8000486a:	30 ac       	mov	r12,10
8000486c:	f0 1f 00 0f 	mcall	800048a8 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004870:	33 db       	mov	r11,61
80004872:	31 1c       	mov	r12,17
80004874:	f0 1f 00 0f 	mcall	800048b0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004878:	31 eb       	mov	r11,30
8000487a:	32 dc       	mov	r12,45
8000487c:	f0 1f 00 0d 	mcall	800048b0 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004880:	30 0b       	mov	r11,0
80004882:	32 cc       	mov	r12,44
80004884:	f0 1f 00 0b 	mcall	800048b0 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004888:	e0 6b 00 8d 	mov	r11,141
8000488c:	32 ac       	mov	r12,42
8000488e:	f0 1f 00 09 	mcall	800048b0 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004892:	33 eb       	mov	r11,62
80004894:	32 bc       	mov	r12,43
80004896:	f0 1f 00 07 	mcall	800048b0 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000489a:	34 0b       	mov	r11,64
8000489c:	31 5c       	mov	r12,21
8000489e:	f0 1f 00 05 	mcall	800048b0 <PcdReset+0x7c>
	
	return MI_OK;
}
800048a2:	d8 0a       	popm	pc,r12=0
800048a4:	80 00       	ld.sh	r0,r0[0x0]
800048a6:	53 f0       	stdsp	sp[0xfc],r0
800048a8:	80 00       	ld.sh	r0,r0[0x0]
800048aa:	51 94       	stdsp	sp[0x64],r4
800048ac:	80 00       	ld.sh	r0,r0[0x0]
800048ae:	54 0c       	stdsp	sp[0x100],r12
800048b0:	80 00       	ld.sh	r0,r0[0x0]
800048b2:	47 f4       	lddsp	r4,sp[0x1fc]

800048b4 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800048b4:	eb cd 40 c0 	pushm	r6-r7,lr
800048b8:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800048ba:	48 c7       	lddpc	r7,800048e8 <ReadRawRC+0x34>
800048bc:	30 0b       	mov	r11,0
800048be:	6e 0c       	ld.w	r12,r7[0x0]
800048c0:	f0 1f 00 0b 	mcall	800048ec <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800048c4:	a1 76       	lsl	r6,0x1
800048c6:	0c 9c       	mov	r12,r6
800048c8:	e2 1c 00 7e 	andl	r12,0x7e,COH
800048cc:	a7 bc       	sbr	r12,0x7
800048ce:	f0 1f 00 09 	mcall	800048f0 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800048d2:	f0 1f 00 09 	mcall	800048f4 <ReadRawRC+0x40>
800048d6:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800048d8:	30 0b       	mov	r11,0
800048da:	6e 0c       	ld.w	r12,r7[0x0]
800048dc:	f0 1f 00 07 	mcall	800048f8 <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800048e0:	0c 9c       	mov	r12,r6
800048e2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048e6:	00 00       	add	r0,r0
800048e8:	00 00       	add	r0,r0
800048ea:	1d a4       	ld.ub	r4,lr[0x2]
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	58 78       	cp.w	r8,7
800048f0:	80 00       	ld.sh	r0,r0[0x0]
800048f2:	47 c4       	lddsp	r4,sp[0x1f0]
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	47 98       	lddsp	r8,sp[0x1e4]
800048f8:	80 00       	ld.sh	r0,r0[0x0]
800048fa:	58 38       	cp.w	r8,3

800048fc <Wait_Wakeup_RC522>:

/////////////////////////////////////////////////////////////////////
//    斤绛寰RC522
/////////////////////////////////////////////////////////////////////
void Wait_Wakeup_RC522(void)
{
800048fc:	d4 01       	pushm	lr
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	do 
	{
		tmp = ReadRawRC(reg);
800048fe:	30 1c       	mov	r12,1
80004900:	f0 1f 00 02 	mcall	80004908 <Wait_Wakeup_RC522+0xc>
			
	//tmp = ReadRawRC(reg);
	//if((tmp & 0x10) == 0)
	//WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
	
}
80004904:	d8 02       	popm	pc
80004906:	00 00       	add	r0,r0
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	48 b4       	lddpc	r4,80004934 <Powerdown_RC522+0x28>

8000490c <Powerdown_RC522>:
/////////////////////////////////////////////////////////////////////
//    斤浣RC522杩ヨ蒋垫ā寮
//
/////////////////////////////////////////////////////////////////////
void Powerdown_RC522(U8 act)
{
8000490c:	eb cd 40 80 	pushm	r7,lr
80004910:	18 97       	mov	r7,r12
	char   tmp = 0x0;
	char   reg = CommandReg;
	
	tmp = ReadRawRC(reg);
80004912:	30 1c       	mov	r12,1
80004914:	f0 1f 00 0d 	mcall	80004948 <Powerdown_RC522+0x3c>
	if(act == ENTER_POWERDOWN)//1
80004918:	30 18       	mov	r8,1
8000491a:	f0 07 18 00 	cp.b	r7,r8
8000491e:	c0 91       	brne	80004930 <Powerdown_RC522+0x24>
		WriteRawRC(reg,tmp | PCD_POWERDOWN);  // set bit powerdown
80004920:	18 9b       	mov	r11,r12
80004922:	a5 ab       	sbr	r11,0x4
80004924:	5c 5b       	castu.b	r11
80004926:	30 1c       	mov	r12,1
80004928:	f0 1f 00 09 	mcall	8000494c <Powerdown_RC522+0x40>
8000492c:	e3 cd 80 80 	ldm	sp++,r7,pc
	else
	{
		WriteRawRC(reg,tmp | PCD_IDLE);  // wake up rc522
80004930:	18 9b       	mov	r11,r12
80004932:	30 1c       	mov	r12,1
80004934:	f0 1f 00 06 	mcall	8000494c <Powerdown_RC522+0x40>
		delay_ns(2);
80004938:	30 2c       	mov	r12,2
8000493a:	f0 1f 00 06 	mcall	80004950 <Powerdown_RC522+0x44>
		Wait_Wakeup_RC522();
8000493e:	f0 1f 00 06 	mcall	80004954 <Powerdown_RC522+0x48>
80004942:	e3 cd 80 80 	ldm	sp++,r7,pc
80004946:	00 00       	add	r0,r0
80004948:	80 00       	ld.sh	r0,r0[0x0]
8000494a:	48 b4       	lddpc	r4,80004974 <SetBitMask+0x1c>
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	47 f4       	lddsp	r4,sp[0x1fc]
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	51 94       	stdsp	sp[0x64],r4
80004954:	80 00       	ld.sh	r0,r0[0x0]
80004956:	48 fc       	lddpc	r12,80004990 <PcdAntennaOn+0x14>

80004958 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004958:	eb cd 40 c0 	pushm	r6-r7,lr
8000495c:	18 97       	mov	r7,r12
8000495e:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004960:	f0 1f 00 05 	mcall	80004974 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004964:	f9 e6 10 0b 	or	r11,r12,r6
80004968:	5c 5b       	castu.b	r11
8000496a:	0e 9c       	mov	r12,r7
8000496c:	f0 1f 00 03 	mcall	80004978 <SetBitMask+0x20>
}
80004970:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004974:	80 00       	ld.sh	r0,r0[0x0]
80004976:	48 b4       	lddpc	r4,800049a0 <ClearBitMask+0x4>
80004978:	80 00       	ld.sh	r0,r0[0x0]
8000497a:	47 f4       	lddsp	r4,sp[0x1fc]

8000497c <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
8000497c:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
8000497e:	31 4c       	mov	r12,20
80004980:	f0 1f 00 05 	mcall	80004994 <PcdAntennaOn+0x18>
	if (!(i & 0x03))
80004984:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004988:	c0 51       	brne	80004992 <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
8000498a:	30 3b       	mov	r11,3
8000498c:	31 4c       	mov	r12,20
8000498e:	f0 1f 00 03 	mcall	80004998 <PcdAntennaOn+0x1c>
80004992:	d8 02       	popm	pc
80004994:	80 00       	ld.sh	r0,r0[0x0]
80004996:	48 b4       	lddpc	r4,800049c0 <ClearBitMask+0x24>
80004998:	80 00       	ld.sh	r0,r0[0x0]
8000499a:	49 58       	lddpc	r8,800049ec <M500PcdConfigISOType+0x18>

8000499c <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
8000499c:	eb cd 40 c0 	pushm	r6-r7,lr
800049a0:	18 97       	mov	r7,r12
800049a2:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
800049a4:	f0 1f 00 06 	mcall	800049bc <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800049a8:	5c d6       	com	r6
800049aa:	f9 e6 00 06 	and	r6,r12,r6
800049ae:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800049b2:	0e 9c       	mov	r12,r7
800049b4:	f0 1f 00 03 	mcall	800049c0 <ClearBitMask+0x24>
	
}
800049b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049bc:	80 00       	ld.sh	r0,r0[0x0]
800049be:	48 b4       	lddpc	r4,800049e8 <M500PcdConfigISOType+0x14>
800049c0:	80 00       	ld.sh	r0,r0[0x0]
800049c2:	47 f4       	lddsp	r4,sp[0x1fc]

800049c4 <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800049c4:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800049c6:	30 3b       	mov	r11,3
800049c8:	31 4c       	mov	r12,20
800049ca:	f0 1f 00 02 	mcall	800049d0 <PcdAntennaOff+0xc>
}
800049ce:	d8 02       	popm	pc
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	49 9c       	lddpc	r12,80004a34 <M500PcdConfigISOType+0x60>

800049d4 <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
800049d4:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
800049d6:	34 18       	mov	r8,65
800049d8:	f0 0c 18 00 	cp.b	r12,r8
800049dc:	c0 20       	breq	800049e0 <M500PcdConfigISOType+0xc>
800049de:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800049e0:	30 8b       	mov	r11,8
800049e2:	16 9c       	mov	r12,r11
800049e4:	f0 1f 00 14 	mcall	80004a34 <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800049e8:	33 db       	mov	r11,61
800049ea:	31 1c       	mov	r12,17
800049ec:	f0 1f 00 13 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800049f0:	e0 6b 00 86 	mov	r11,134
800049f4:	31 7c       	mov	r12,23
800049f6:	f0 1f 00 11 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800049fa:	37 fb       	mov	r11,127
800049fc:	32 6c       	mov	r12,38
800049fe:	f0 1f 00 0f 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
80004a02:	31 eb       	mov	r11,30
80004a04:	32 dc       	mov	r12,45
80004a06:	f0 1f 00 0d 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004a0a:	30 0b       	mov	r11,0
80004a0c:	32 cc       	mov	r12,44
80004a0e:	f0 1f 00 0b 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
80004a12:	e0 6b 00 8d 	mov	r11,141
80004a16:	32 ac       	mov	r12,42
80004a18:	f0 1f 00 08 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004a1c:	33 eb       	mov	r11,62
80004a1e:	32 bc       	mov	r12,43
80004a20:	f0 1f 00 06 	mcall	80004a38 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
80004a24:	e0 6c 03 e8 	mov	r12,1000
80004a28:	f0 1f 00 05 	mcall	80004a3c <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004a2c:	f0 1f 00 05 	mcall	80004a40 <M500PcdConfigISOType+0x6c>
80004a30:	d8 0a       	popm	pc,r12=0
80004a32:	00 00       	add	r0,r0
80004a34:	80 00       	ld.sh	r0,r0[0x0]
80004a36:	49 9c       	lddpc	r12,80004a98 <rc522_init+0x54>
80004a38:	80 00       	ld.sh	r0,r0[0x0]
80004a3a:	47 f4       	lddsp	r4,sp[0x1fc]
80004a3c:	80 00       	ld.sh	r0,r0[0x0]
80004a3e:	51 94       	stdsp	sp[0x64],r4
80004a40:	80 00       	ld.sh	r0,r0[0x0]
80004a42:	49 7c       	lddpc	r12,80004a9c <rc522_init+0x58>

80004a44 <rc522_init>:


//mfrc522 init

void rc522_init()
{
80004a44:	eb cd 40 c0 	pushm	r6-r7,lr
80004a48:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004a4a:	4a 38       	lddpc	r8,80004ad4 <rc522_init+0x90>
80004a4c:	1a 96       	mov	r6,sp
80004a4e:	f0 ea 00 00 	ld.d	r10,r8[0]
80004a52:	fa eb 00 00 	st.d	sp[0],r10
80004a56:	f0 e8 00 08 	ld.d	r8,r8[8]
80004a5a:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004a5e:	30 4b       	mov	r11,4
80004a60:	49 ec       	lddpc	r12,80004ad8 <rc522_init+0x94>
80004a62:	f0 1f 00 1f 	mcall	80004adc <rc522_init+0x98>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
80004a66:	31 9c       	mov	r12,25
80004a68:	f0 1f 00 1e 	mcall	80004ae0 <rc522_init+0x9c>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004a6c:	31 9c       	mov	r12,25
80004a6e:	f0 1f 00 1e 	mcall	80004ae4 <rc522_init+0xa0>

	spi = &AVR32_SPI;
80004a72:	49 e7       	lddpc	r7,80004ae8 <rc522_init+0xa4>
80004a74:	fe 7c 24 00 	mov	r12,-56320
80004a78:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004a7a:	1a 9b       	mov	r11,sp
80004a7c:	f0 1f 00 1c 	mcall	80004aec <rc522_init+0xa8>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004a80:	30 09       	mov	r9,0
80004a82:	12 9a       	mov	r10,r9
80004a84:	12 9b       	mov	r11,r9
80004a86:	6e 0c       	ld.w	r12,r7[0x0]
80004a88:	f0 1f 00 1a 	mcall	80004af0 <rc522_init+0xac>

	// Enable SPI.
	spi_enable(spi);
80004a8c:	6e 0c       	ld.w	r12,r7[0x0]
80004a8e:	f0 1f 00 1a 	mcall	80004af4 <rc522_init+0xb0>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80004a92:	e0 6a 36 00 	mov	r10,13824
80004a96:	ea 1a 01 6e 	orh	r10,0x16e
80004a9a:	1a 9b       	mov	r11,sp
80004a9c:	6e 0c       	ld.w	r12,r7[0x0]
80004a9e:	f0 1f 00 17 	mcall	80004af8 <rc522_init+0xb4>
80004aa2:	c0 50       	breq	80004aac <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
80004aa4:	30 29       	mov	r9,2
80004aa6:	49 68       	lddpc	r8,80004afc <rc522_init+0xb8>
80004aa8:	b0 89       	st.b	r8[0x0],r9
80004aaa:	c0 38       	rjmp	80004ab0 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80004aac:	f0 1f 00 15 	mcall	80004b00 <rc522_init+0xbc>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80004ab0:	f0 1f 00 15 	mcall	80004b04 <rc522_init+0xc0>
	
	PcdAntennaOff();
80004ab4:	f0 1f 00 15 	mcall	80004b08 <rc522_init+0xc4>
	
	delay_ms(2); 
80004ab8:	30 2c       	mov	r12,2
80004aba:	f0 1f 00 15 	mcall	80004b0c <rc522_init+0xc8>
	
	PcdAntennaOn();
80004abe:	f0 1f 00 15 	mcall	80004b10 <rc522_init+0xcc>
	
	M500PcdConfigISOType( 'A' );
80004ac2:	34 1c       	mov	r12,65
80004ac4:	f0 1f 00 14 	mcall	80004b14 <rc522_init+0xd0>
	
	Powerdown_RC522(ENTER_POWERDOWN);
80004ac8:	30 1c       	mov	r12,1
80004aca:	f0 1f 00 14 	mcall	80004b18 <rc522_init+0xd4>
	//Powerdown_RC522(ENTER_POWERDOWN);
	
	//Powerdown_RC522(WAKEUP_RC522);
	

80004ace:	2f cd       	sub	sp,-16
80004ad0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	d6 18       	*unknown*
80004ad8:	80 00       	ld.sh	r0,r0[0x0]
80004ada:	d6 28       	*unknown*
80004adc:	80 00       	ld.sh	r0,r0[0x0]
80004ade:	53 a8       	stdsp	sp[0xe8],r8
80004ae0:	80 00       	ld.sh	r0,r0[0x0]
80004ae2:	53 d8       	stdsp	sp[0xf4],r8
80004ae4:	80 00       	ld.sh	r0,r0[0x0]
80004ae6:	53 f0       	stdsp	sp[0xfc],r0
80004ae8:	00 00       	add	r0,r0
80004aea:	1d a4       	ld.ub	r4,lr[0x2]
80004aec:	80 00       	ld.sh	r0,r0[0x0]
80004aee:	56 a8       	stdsp	sp[0x1a8],r8
80004af0:	80 00       	ld.sh	r0,r0[0x0]
80004af2:	56 e0       	stdsp	sp[0x1b8],r0
80004af4:	80 00       	ld.sh	r0,r0[0x0]
80004af6:	57 0c       	stdsp	sp[0x1c0],r12
80004af8:	80 00       	ld.sh	r0,r0[0x0]
80004afa:	57 50       	stdsp	sp[0x1d4],r0
80004afc:	00 00       	add	r0,r0
80004afe:	0b 5c       	ld.sh	r12,--r5
80004b00:	80 00       	ld.sh	r0,r0[0x0]
80004b02:	47 88       	lddsp	r8,sp[0x1e0]
80004b04:	80 00       	ld.sh	r0,r0[0x0]
80004b06:	48 34       	lddpc	r4,80004b10 <rc522_init+0xcc>
80004b08:	80 00       	ld.sh	r0,r0[0x0]
80004b0a:	49 c4       	lddpc	r4,80004b78 <PcdComMF522+0x5c>
80004b0c:	80 00       	ld.sh	r0,r0[0x0]
80004b0e:	51 d4       	stdsp	sp[0x74],r4
80004b10:	80 00       	ld.sh	r0,r0[0x0]
80004b12:	49 7c       	lddpc	r12,80004b6c <PcdComMF522+0x50>
80004b14:	80 00       	ld.sh	r0,r0[0x0]
80004b16:	49 d4       	lddpc	r4,80004b88 <PcdComMF522+0x6c>
80004b18:	80 00       	ld.sh	r0,r0[0x0]
80004b1a:	49 0c       	lddpc	r12,80004b58 <PcdComMF522+0x3c>

80004b1c <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004b1c:	d4 31       	pushm	r0-r7,lr
80004b1e:	20 1d       	sub	sp,4
80004b20:	18 92       	mov	r2,r12
80004b22:	16 95       	mov	r5,r11
80004b24:	14 96       	mov	r6,r10
80004b26:	50 09       	stdsp	sp[0x0],r9
80004b28:	10 90       	mov	r0,r8
80004b2a:	f8 c8 00 0c 	sub	r8,r12,12
80004b2e:	5c 58       	castu.b	r8
80004b30:	30 29       	mov	r9,2
80004b32:	f2 08 18 00 	cp.b	r8,r9
80004b36:	e0 88 00 05 	brls	80004b40 <PcdComMF522+0x24>
80004b3a:	30 03       	mov	r3,0
80004b3c:	06 91       	mov	r1,r3
80004b3e:	c0 78       	rjmp	80004b4c <PcdComMF522+0x30>
80004b40:	4c f9       	lddpc	r9,80004c7c <PcdComMF522+0x160>
80004b42:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004b46:	4c f9       	lddpc	r9,80004c80 <PcdComMF522+0x164>
80004b48:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004b4c:	02 9b       	mov	r11,r1
80004b4e:	a7 bb       	sbr	r11,0x7
80004b50:	30 2c       	mov	r12,2
80004b52:	f0 1f 00 4d 	mcall	80004c84 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004b56:	e0 6b 00 80 	mov	r11,128
80004b5a:	30 4c       	mov	r12,4
80004b5c:	f0 1f 00 4b 	mcall	80004c88 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b60:	30 0b       	mov	r11,0
80004b62:	30 1c       	mov	r12,1
80004b64:	f0 1f 00 48 	mcall	80004c84 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004b68:	e0 6b 00 80 	mov	r11,128
80004b6c:	30 ac       	mov	r12,10
80004b6e:	f0 1f 00 48 	mcall	80004c8c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004b72:	58 06       	cp.w	r6,0
80004b74:	c0 c0       	breq	80004b8c <PcdComMF522+0x70>
80004b76:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004b78:	30 94       	mov	r4,9
80004b7a:	0f 3b       	ld.ub	r11,r7++
80004b7c:	08 9c       	mov	r12,r4
80004b7e:	f0 1f 00 42 	mcall	80004c84 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004b82:	0e 98       	mov	r8,r7
80004b84:	0a 18       	sub	r8,r5
80004b86:	ec 08 19 00 	cp.h	r8,r6
80004b8a:	cf 83       	brcs	80004b7a <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004b8c:	04 9b       	mov	r11,r2
80004b8e:	30 1c       	mov	r12,1
80004b90:	f0 1f 00 3d 	mcall	80004c84 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004b94:	30 c8       	mov	r8,12
80004b96:	f0 02 18 00 	cp.b	r2,r8
80004b9a:	c0 61       	brne	80004ba6 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004b9c:	e0 6b 00 80 	mov	r11,128
80004ba0:	30 dc       	mov	r12,13
80004ba2:	f0 1f 00 3b 	mcall	80004c8c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004ba6:	30 4c       	mov	r12,4
80004ba8:	f0 1f 00 3a 	mcall	80004c90 <PcdComMF522+0x174>
80004bac:	18 97       	mov	r7,r12
80004bae:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004bb2:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004bb4:	30 44       	mov	r4,4
80004bb6:	c0 88       	rjmp	80004bc6 <PcdComMF522+0xaa>
80004bb8:	08 9c       	mov	r12,r4
80004bba:	f0 1f 00 36 	mcall	80004c90 <PcdComMF522+0x174>
80004bbe:	18 97       	mov	r7,r12
		i--;
80004bc0:	20 16       	sub	r6,1
80004bc2:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004bc4:	c0 a0       	breq	80004bd8 <PcdComMF522+0xbc>
80004bc6:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004bca:	c4 c1       	brne	80004c62 <PcdComMF522+0x146>
80004bcc:	ef e3 00 08 	and	r8,r7,r3
80004bd0:	ea 08 18 00 	cp.b	r8,r5
80004bd4:	cf 20       	breq	80004bb8 <PcdComMF522+0x9c>
80004bd6:	c4 68       	rjmp	80004c62 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004bd8:	e0 6b 00 80 	mov	r11,128
80004bdc:	30 dc       	mov	r12,13
80004bde:	f0 1f 00 2b 	mcall	80004c88 <PcdComMF522+0x16c>
80004be2:	30 27       	mov	r7,2
80004be4:	c3 38       	rjmp	80004c4a <PcdComMF522+0x12e>
80004be6:	02 67       	and	r7,r1
80004be8:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004bec:	30 c8       	mov	r8,12
80004bee:	f0 02 18 00 	cp.b	r2,r8
80004bf2:	c2 c1       	brne	80004c4a <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004bf4:	30 ac       	mov	r12,10
80004bf6:	f0 1f 00 27 	mcall	80004c90 <PcdComMF522+0x174>
80004bfa:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004bfc:	30 cc       	mov	r12,12
80004bfe:	f0 1f 00 25 	mcall	80004c90 <PcdComMF522+0x174>
80004c02:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004c06:	c0 70       	breq	80004c14 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004c08:	08 98       	mov	r8,r4
80004c0a:	20 18       	sub	r8,1
80004c0c:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004c10:	a0 8c       	st.b	r0[0x0],r12
80004c12:	c0 48       	rjmp	80004c1a <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004c14:	e8 08 15 03 	lsl	r8,r4,0x3
80004c18:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004c1a:	58 04       	cp.w	r4,0
80004c1c:	c0 61       	brne	80004c28 <PcdComMF522+0x10c>
80004c1e:	30 14       	mov	r4,1
80004c20:	40 05       	lddsp	r5,sp[0x0]
80004c22:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004c24:	30 93       	mov	r3,9
80004c26:	c0 98       	rjmp	80004c38 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004c28:	31 28       	mov	r8,18
80004c2a:	f0 04 18 00 	cp.b	r4,r8
80004c2e:	f9 b4 0b 12 	movhi	r4,18
80004c32:	58 04       	cp.w	r4,0
80004c34:	cf 61       	brne	80004c20 <PcdComMF522+0x104>
80004c36:	c0 a8       	rjmp	80004c4a <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004c38:	06 9c       	mov	r12,r3
80004c3a:	f0 1f 00 16 	mcall	80004c90 <PcdComMF522+0x174>
80004c3e:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004c40:	ec 05 01 08 	sub	r8,r6,r5
80004c44:	e8 08 19 00 	cp.h	r8,r4
80004c48:	cf 83       	brcs	80004c38 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004c4a:	e0 6b 00 80 	mov	r11,128
80004c4e:	30 cc       	mov	r12,12
80004c50:	f0 1f 00 0f 	mcall	80004c8c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c54:	30 0b       	mov	r11,0
80004c56:	30 1c       	mov	r12,1
80004c58:	f0 1f 00 0b 	mcall	80004c84 <PcdComMF522+0x168>
	return status;
}
80004c5c:	0e 9c       	mov	r12,r7
80004c5e:	2f fd       	sub	sp,-4
80004c60:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004c62:	e0 6b 00 80 	mov	r11,128
80004c66:	30 dc       	mov	r12,13
80004c68:	f0 1f 00 08 	mcall	80004c88 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004c6c:	30 6c       	mov	r12,6
80004c6e:	f0 1f 00 09 	mcall	80004c90 <PcdComMF522+0x174>
80004c72:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004c76:	cb 80       	breq	80004be6 <PcdComMF522+0xca>
80004c78:	30 27       	mov	r7,2
80004c7a:	ce 8b       	rjmp	80004c4a <PcdComMF522+0x12e>
80004c7c:	80 00       	ld.sh	r0,r0[0x0]
80004c7e:	d6 10       	acall	0x61
80004c80:	80 00       	ld.sh	r0,r0[0x0]
80004c82:	d6 14       	*unknown*
80004c84:	80 00       	ld.sh	r0,r0[0x0]
80004c86:	47 f4       	lddsp	r4,sp[0x1fc]
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	49 9c       	lddpc	r12,80004cec <PcdAnticoll+0x58>
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	49 58       	lddpc	r8,80004ce0 <PcdAnticoll+0x4c>
80004c90:	80 00       	ld.sh	r0,r0[0x0]
80004c92:	48 b4       	lddpc	r4,80004cbc <PcdAnticoll+0x28>

80004c94 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004c94:	eb cd 40 c0 	pushm	r6-r7,lr
80004c98:	20 5d       	sub	sp,20
80004c9a:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004c9c:	30 8b       	mov	r11,8
80004c9e:	16 9c       	mov	r12,r11
80004ca0:	f0 1f 00 1a 	mcall	80004d08 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004ca4:	30 0b       	mov	r11,0
80004ca6:	30 dc       	mov	r12,13
80004ca8:	f0 1f 00 19 	mcall	80004d0c <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004cac:	e0 6b 00 80 	mov	r11,128
80004cb0:	30 ec       	mov	r12,14
80004cb2:	f0 1f 00 16 	mcall	80004d08 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004cb6:	39 38       	mov	r8,-109
80004cb8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004cba:	32 08       	mov	r8,32
80004cbc:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004cbe:	1a 9b       	mov	r11,sp
80004cc0:	fa c8 ff ed 	sub	r8,sp,-19
80004cc4:	1a 99       	mov	r9,sp
80004cc6:	30 2a       	mov	r10,2
80004cc8:	30 cc       	mov	r12,12
80004cca:	f0 1f 00 12 	mcall	80004d10 <PcdAnticoll+0x7c>
80004cce:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004cd0:	c1 21       	brne	80004cf4 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004cd2:	1b 89       	ld.ub	r9,sp[0x0]
80004cd4:	ac 89       	st.b	r6[0x0],r9
80004cd6:	1b 98       	ld.ub	r8,sp[0x1]
80004cd8:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004cda:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004cdc:	1b a8       	ld.ub	r8,sp[0x2]
80004cde:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004ce0:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004ce4:	1b b9       	ld.ub	r9,sp[0x3]
80004ce6:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004ce8:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004cea:	1b c9       	ld.ub	r9,sp[0x4]
80004cec:	f0 09 18 00 	cp.b	r9,r8
80004cf0:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004cf4:	e0 6b 00 80 	mov	r11,128
80004cf8:	30 ec       	mov	r12,14
80004cfa:	f0 1f 00 07 	mcall	80004d14 <PcdAnticoll+0x80>
	return status;
}
80004cfe:	0e 9c       	mov	r12,r7
80004d00:	2f bd       	sub	sp,-20
80004d02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d06:	00 00       	add	r0,r0
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	49 9c       	lddpc	r12,80004d6c <PcdRequest+0x54>
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	47 f4       	lddsp	r4,sp[0x1fc]
80004d10:	80 00       	ld.sh	r0,r0[0x0]
80004d12:	4b 1c       	lddpc	r12,80004dd4 <CalulateCRC+0x58>
80004d14:	80 00       	ld.sh	r0,r0[0x0]
80004d16:	49 58       	lddpc	r8,80004d68 <PcdRequest+0x50>

80004d18 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004d18:	eb cd 40 c0 	pushm	r6-r7,lr
80004d1c:	20 5d       	sub	sp,20
80004d1e:	18 97       	mov	r7,r12
80004d20:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004d22:	30 8b       	mov	r11,8
80004d24:	16 9c       	mov	r12,r11
80004d26:	f0 1f 00 12 	mcall	80004d6c <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004d2a:	30 7b       	mov	r11,7
80004d2c:	30 dc       	mov	r12,13
80004d2e:	f0 1f 00 11 	mcall	80004d70 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004d32:	30 3b       	mov	r11,3
80004d34:	31 4c       	mov	r12,20
80004d36:	f0 1f 00 10 	mcall	80004d74 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004d3a:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004d3c:	1a 9b       	mov	r11,sp
80004d3e:	fa c8 ff ed 	sub	r8,sp,-19
80004d42:	1a 99       	mov	r9,sp
80004d44:	30 1a       	mov	r10,1
80004d46:	30 cc       	mov	r12,12
80004d48:	f0 1f 00 0c 	mcall	80004d78 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004d4c:	c0 c1       	brne	80004d64 <PcdRequest+0x4c>
80004d4e:	31 08       	mov	r8,16
80004d50:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d54:	f0 09 18 00 	cp.b	r9,r8
80004d58:	c0 61       	brne	80004d64 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004d5a:	1b 88       	ld.ub	r8,sp[0x0]
80004d5c:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004d5e:	1b 98       	ld.ub	r8,sp[0x1]
80004d60:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004d62:	c0 28       	rjmp	80004d66 <PcdRequest+0x4e>
80004d64:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004d66:	2f bd       	sub	sp,-20
80004d68:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d6c:	80 00       	ld.sh	r0,r0[0x0]
80004d6e:	49 9c       	lddpc	r12,80004dd0 <CalulateCRC+0x54>
80004d70:	80 00       	ld.sh	r0,r0[0x0]
80004d72:	47 f4       	lddsp	r4,sp[0x1fc]
80004d74:	80 00       	ld.sh	r0,r0[0x0]
80004d76:	49 58       	lddpc	r8,80004dc8 <CalulateCRC+0x4c>
80004d78:	80 00       	ld.sh	r0,r0[0x0]
80004d7a:	4b 1c       	lddpc	r12,80004e3c <PcdSelect+0x34>

80004d7c <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004d7c:	eb cd 40 f8 	pushm	r3-r7,lr
80004d80:	18 95       	mov	r5,r12
80004d82:	16 96       	mov	r6,r11
80004d84:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004d86:	30 4b       	mov	r11,4
80004d88:	30 5c       	mov	r12,5
80004d8a:	f0 1f 00 1c 	mcall	80004df8 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d8e:	30 0b       	mov	r11,0
80004d90:	30 1c       	mov	r12,1
80004d92:	f0 1f 00 1b 	mcall	80004dfc <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004d96:	e0 6b 00 80 	mov	r11,128
80004d9a:	30 ac       	mov	r12,10
80004d9c:	f0 1f 00 19 	mcall	80004e00 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004da0:	58 06       	cp.w	r6,0
80004da2:	c0 c0       	breq	80004dba <CalulateCRC+0x3e>
80004da4:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004da6:	30 94       	mov	r4,9
80004da8:	0f 3b       	ld.ub	r11,r7++
80004daa:	08 9c       	mov	r12,r4
80004dac:	f0 1f 00 14 	mcall	80004dfc <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004db0:	0e 98       	mov	r8,r7
80004db2:	0a 18       	sub	r8,r5
80004db4:	ec 08 18 00 	cp.b	r8,r6
80004db8:	cf 83       	brcs	80004da8 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004dba:	30 3b       	mov	r11,3
80004dbc:	30 1c       	mov	r12,1
80004dbe:	f0 1f 00 10 	mcall	80004dfc <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004dc2:	30 5c       	mov	r12,5
80004dc4:	f0 1f 00 10 	mcall	80004e04 <CalulateCRC+0x88>
80004dc8:	e0 67 00 fe 	mov	r7,254
80004dcc:	30 56       	mov	r6,5
80004dce:	c0 78       	rjmp	80004ddc <CalulateCRC+0x60>
80004dd0:	0c 9c       	mov	r12,r6
80004dd2:	f0 1f 00 0d 	mcall	80004e04 <CalulateCRC+0x88>
		i--;
80004dd6:	20 17       	sub	r7,1
80004dd8:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004dda:	c0 40       	breq	80004de2 <CalulateCRC+0x66>
80004ddc:	e2 1c 00 04 	andl	r12,0x4,COH
80004de0:	cf 80       	breq	80004dd0 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004de2:	32 2c       	mov	r12,34
80004de4:	f0 1f 00 08 	mcall	80004e04 <CalulateCRC+0x88>
80004de8:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004dea:	32 1c       	mov	r12,33
80004dec:	f0 1f 00 06 	mcall	80004e04 <CalulateCRC+0x88>
80004df0:	a6 9c       	st.b	r3[0x1],r12
}
80004df2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004df6:	00 00       	add	r0,r0
80004df8:	80 00       	ld.sh	r0,r0[0x0]
80004dfa:	49 9c       	lddpc	r12,80004e5c <PcdSelect+0x54>
80004dfc:	80 00       	ld.sh	r0,r0[0x0]
80004dfe:	47 f4       	lddsp	r4,sp[0x1fc]
80004e00:	80 00       	ld.sh	r0,r0[0x0]
80004e02:	49 58       	lddpc	r8,80004e54 <PcdSelect+0x4c>
80004e04:	80 00       	ld.sh	r0,r0[0x0]
80004e06:	48 b4       	lddpc	r4,80004e30 <PcdSelect+0x28>

80004e08 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004e08:	eb cd 40 80 	pushm	r7,lr
80004e0c:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004e0e:	39 38       	mov	r8,-109
80004e10:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004e12:	37 08       	mov	r8,112
80004e14:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004e16:	30 08       	mov	r8,0
80004e18:	ba e8       	st.b	sp[0x6],r8
80004e1a:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004e1e:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004e22:	19 89       	ld.ub	r9,r12[0x0]
80004e24:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004e26:	19 3a       	ld.ub	r10,r12++
80004e28:	1b e9       	ld.ub	r9,sp[0x6]
80004e2a:	f5 e9 20 09 	eor	r9,r10,r9
80004e2e:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004e30:	16 38       	cp.w	r8,r11
80004e32:	cf 81       	brne	80004e22 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004e34:	1a 97       	mov	r7,sp
80004e36:	fa ca ff f9 	sub	r10,sp,-7
80004e3a:	30 7b       	mov	r11,7
80004e3c:	1a 9c       	mov	r12,sp
80004e3e:	f0 1f 00 0d 	mcall	80004e70 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004e42:	30 8b       	mov	r11,8
80004e44:	16 9c       	mov	r12,r11
80004e46:	f0 1f 00 0c 	mcall	80004e74 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004e4a:	fa c8 ff ed 	sub	r8,sp,-19
80004e4e:	1a 99       	mov	r9,sp
80004e50:	30 9a       	mov	r10,9
80004e52:	1a 9b       	mov	r11,sp
80004e54:	30 cc       	mov	r12,12
80004e56:	f0 1f 00 09 	mcall	80004e78 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004e5a:	c0 71       	brne	80004e68 <PcdSelect+0x60>
80004e5c:	31 88       	mov	r8,24
80004e5e:	fb 39 00 13 	ld.ub	r9,sp[19]
80004e62:	f0 09 18 00 	cp.b	r9,r8
80004e66:	c0 20       	breq	80004e6a <PcdSelect+0x62>
80004e68:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004e6a:	2f bd       	sub	sp,-20
80004e6c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	4d 7c       	lddpc	r12,80004fcc <scan_patrol+0x30>
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	49 9c       	lddpc	r12,80004ed8 <rfid_auto_reader+0x5c>
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	4b 1c       	lddpc	r12,80004f3c <rfid_auto_reader+0xc0>

80004e7c <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004e7c:	eb cd 40 c0 	pushm	r6-r7,lr
80004e80:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004e82:	f0 1f 00 37 	mcall	80004f5c <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004e86:	4b 7b       	lddpc	r11,80004f60 <rfid_auto_reader+0xe4>
80004e88:	35 2c       	mov	r12,82
80004e8a:	f0 1f 00 37 	mcall	80004f64 <rfid_auto_reader+0xe8>
80004e8e:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004e90:	c6 31       	brne	80004f56 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004e92:	4b 48       	lddpc	r8,80004f60 <rfid_auto_reader+0xe4>
80004e94:	11 88       	ld.ub	r8,r8[0x0]
80004e96:	30 49       	mov	r9,4
80004e98:	f2 08 18 00 	cp.b	r8,r9
80004e9c:	c0 b1       	brne	80004eb2 <rfid_auto_reader+0x36>
80004e9e:	4b 19       	lddpc	r9,80004f60 <rfid_auto_reader+0xe4>
80004ea0:	13 9a       	ld.ub	r10,r9[0x1]
80004ea2:	30 09       	mov	r9,0
80004ea4:	f2 0a 18 00 	cp.b	r10,r9
80004ea8:	c0 51       	brne	80004eb2 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004eaa:	4b 0c       	lddpc	r12,80004f68 <rfid_auto_reader+0xec>
80004eac:	f0 1f 00 30 	mcall	80004f6c <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004eb0:	c3 c8       	rjmp	80004f28 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004eb2:	30 29       	mov	r9,2
80004eb4:	f2 08 18 00 	cp.b	r8,r9
80004eb8:	c0 b1       	brne	80004ece <rfid_auto_reader+0x52>
80004eba:	4a a9       	lddpc	r9,80004f60 <rfid_auto_reader+0xe4>
80004ebc:	13 9a       	ld.ub	r10,r9[0x1]
80004ebe:	30 09       	mov	r9,0
80004ec0:	f2 0a 18 00 	cp.b	r10,r9
80004ec4:	c0 51       	brne	80004ece <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004ec6:	4a bc       	lddpc	r12,80004f70 <rfid_auto_reader+0xf4>
80004ec8:	f0 1f 00 29 	mcall	80004f6c <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004ecc:	c2 e8       	rjmp	80004f28 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004ece:	34 49       	mov	r9,68
80004ed0:	f2 08 18 00 	cp.b	r8,r9
80004ed4:	c0 b1       	brne	80004eea <rfid_auto_reader+0x6e>
80004ed6:	4a 39       	lddpc	r9,80004f60 <rfid_auto_reader+0xe4>
80004ed8:	13 9a       	ld.ub	r10,r9[0x1]
80004eda:	30 09       	mov	r9,0
80004edc:	f2 0a 18 00 	cp.b	r10,r9
80004ee0:	c0 51       	brne	80004eea <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004ee2:	4a 5c       	lddpc	r12,80004f74 <rfid_auto_reader+0xf8>
80004ee4:	f0 1f 00 22 	mcall	80004f6c <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004ee8:	c2 08       	rjmp	80004f28 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004eea:	30 89       	mov	r9,8
80004eec:	f2 08 18 00 	cp.b	r8,r9
80004ef0:	c0 b1       	brne	80004f06 <rfid_auto_reader+0x8a>
80004ef2:	49 c9       	lddpc	r9,80004f60 <rfid_auto_reader+0xe4>
80004ef4:	13 9a       	ld.ub	r10,r9[0x1]
80004ef6:	30 09       	mov	r9,0
80004ef8:	f2 0a 18 00 	cp.b	r10,r9
80004efc:	c0 51       	brne	80004f06 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004efe:	49 fc       	lddpc	r12,80004f78 <rfid_auto_reader+0xfc>
80004f00:	f0 1f 00 1b 	mcall	80004f6c <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004f04:	c1 28       	rjmp	80004f28 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004f06:	34 49       	mov	r9,68
80004f08:	f2 08 18 00 	cp.b	r8,r9
80004f0c:	c0 b1       	brne	80004f22 <rfid_auto_reader+0xa6>
80004f0e:	49 58       	lddpc	r8,80004f60 <rfid_auto_reader+0xe4>
80004f10:	11 99       	ld.ub	r9,r8[0x1]
80004f12:	30 38       	mov	r8,3
80004f14:	f0 09 18 00 	cp.b	r9,r8
80004f18:	c0 51       	brne	80004f22 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004f1a:	49 9c       	lddpc	r12,80004f7c <rfid_auto_reader+0x100>
80004f1c:	f0 1f 00 14 	mcall	80004f6c <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004f20:	c0 48       	rjmp	80004f28 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004f22:	49 8c       	lddpc	r12,80004f80 <rfid_auto_reader+0x104>
80004f24:	f0 1f 00 12 	mcall	80004f6c <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004f28:	49 7c       	lddpc	r12,80004f84 <rfid_auto_reader+0x108>
80004f2a:	f0 1f 00 18 	mcall	80004f88 <rfid_auto_reader+0x10c>
80004f2e:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004f30:	c0 60       	breq	80004f3c <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004f32:	37 8b       	mov	r11,120
80004f34:	30 1c       	mov	r12,1
80004f36:	f0 1f 00 16 	mcall	80004f8c <rfid_auto_reader+0x110>
		return status;
80004f3a:	c0 e8       	rjmp	80004f56 <rfid_auto_reader+0xda>
		//continue;
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004f3c:	49 2c       	lddpc	r12,80004f84 <rfid_auto_reader+0x108>
80004f3e:	f0 1f 00 15 	mcall	80004f90 <rfid_auto_reader+0x114>
80004f42:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004f44:	c0 91       	brne	80004f56 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004f46:	30 4a       	mov	r10,4
80004f48:	48 fb       	lddpc	r11,80004f84 <rfid_auto_reader+0x108>
80004f4a:	0c 9c       	mov	r12,r6
80004f4c:	f0 1f 00 12 	mcall	80004f94 <rfid_auto_reader+0x118>
		log("select okay\n");
80004f50:	49 2c       	lddpc	r12,80004f98 <rfid_auto_reader+0x11c>
80004f52:	f0 1f 00 07 	mcall	80004f6c <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004f56:	0e 9c       	mov	r12,r7
80004f58:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	48 34       	lddpc	r4,80004f68 <rfid_auto_reader+0xec>
80004f60:	00 00       	add	r0,r0
80004f62:	51 2c       	stdsp	sp[0x48],r12
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	4d 18       	lddpc	r8,800050a8 <scan_rfid_save_message+0xbc>
80004f68:	80 00       	ld.sh	r0,r0[0x0]
80004f6a:	d6 48       	*unknown*
80004f6c:	80 00       	ld.sh	r0,r0[0x0]
80004f6e:	6d fc       	ld.w	r12,r6[0x7c]
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	d6 54       	*unknown*
80004f74:	80 00       	ld.sh	r0,r0[0x0]
80004f76:	d6 60       	acall	0x66
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	d6 70       	acall	0x67
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	d6 78       	*unknown*
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	d6 84       	*unknown*
80004f84:	00 00       	add	r0,r0
80004f86:	51 30       	stdsp	sp[0x4c],r0
80004f88:	80 00       	ld.sh	r0,r0[0x0]
80004f8a:	4c 94       	lddpc	r4,800050ac <scan_rfid_save_message+0xc0>
80004f8c:	80 00       	ld.sh	r0,r0[0x0]
80004f8e:	3f 88       	mov	r8,-8
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	4e 08       	lddpc	r8,80005110 <scan_rfid_save_message+0x124>
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	76 78       	ld.w	r8,r11[0x1c]
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	d6 90       	acall	0x69

80004f9c <scan_patrol>:
	return return_err;
	
}

U8 scan_patrol(char* SN)
{
80004f9c:	eb cd 40 80 	pushm	r7,lr
80004fa0:	18 97       	mov	r7,r12
	U8 return_err = MI_ERR;
	
	PcdReset();
80004fa2:	f0 1f 00 0d 	mcall	80004fd4 <scan_patrol+0x38>
	Powerdown_RC522(WAKEUP_RC522);
80004fa6:	30 0c       	mov	r12,0
80004fa8:	f0 1f 00 0c 	mcall	80004fd8 <scan_patrol+0x3c>
	return_err = rfid_auto_reader(SN);
80004fac:	0e 9c       	mov	r12,r7
80004fae:	f0 1f 00 0c 	mcall	80004fdc <scan_patrol+0x40>
80004fb2:	18 97       	mov	r7,r12
	Powerdown_RC522(ENTER_POWERDOWN);
80004fb4:	30 1c       	mov	r12,1
80004fb6:	f0 1f 00 09 	mcall	80004fd8 <scan_patrol+0x3c>
	if(return_err == 0)
80004fba:	58 07       	cp.w	r7,0
80004fbc:	c0 51       	brne	80004fc6 <scan_patrol+0x2a>
		log("scan_patrol okay!\n");
80004fbe:	48 9c       	lddpc	r12,80004fe0 <scan_patrol+0x44>
80004fc0:	f0 1f 00 09 	mcall	80004fe4 <scan_patrol+0x48>
80004fc4:	c0 48       	rjmp	80004fcc <scan_patrol+0x30>
	else
		log("scan_patrol err!\n");
80004fc6:	48 9c       	lddpc	r12,80004fe8 <scan_patrol+0x4c>
80004fc8:	f0 1f 00 07 	mcall	80004fe4 <scan_patrol+0x48>
		
	return return_err;

}
80004fcc:	0e 9c       	mov	r12,r7
80004fce:	e3 cd 80 80 	ldm	sp++,r7,pc
80004fd2:	00 00       	add	r0,r0
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	48 34       	lddpc	r4,80004fe0 <scan_patrol+0x44>
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	49 0c       	lddpc	r12,80005018 <scan_rfid_save_message+0x2c>
80004fdc:	80 00       	ld.sh	r0,r0[0x0]
80004fde:	4e 7c       	lddpc	r12,80005178 <scan_rfid_save_message+0x18c>
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	d6 a0       	acall	0x6a
80004fe4:	80 00       	ld.sh	r0,r0[0x0]
80004fe6:	6d fc       	ld.w	r12,r6[0x7c]
80004fe8:	80 00       	ld.sh	r0,r0[0x0]
80004fea:	d6 b4       	*unknown*

80004fec <scan_rfid_save_message>:
U8 scan_rfid_save_message()
{
80004fec:	eb cd 40 e0 	pushm	r5-r7,lr
80004ff0:	fa cd 00 8c 	sub	sp,sp,140
	U8 destination = DEST;
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	memset(SN, 0x00, 10);
80004ff4:	4d 7c       	lddpc	r12,80005150 <scan_rfid_save_message+0x164>
80004ff6:	30 08       	mov	r8,0
80004ff8:	30 09       	mov	r9,0
80004ffa:	f8 e9 00 00 	st.d	r12[0],r8
80004ffe:	30 0a       	mov	r10,0
80005000:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80005002:	fa e9 00 3c 	st.d	sp[60],r8
80005006:	fa e9 00 44 	st.d	sp[68],r8
8000500a:	fa e9 00 4c 	st.d	sp[76],r8
8000500e:	fa e9 00 54 	st.d	sp[84],r8
80005012:	fa e9 00 5c 	st.d	sp[92],r8
80005016:	fa e9 00 64 	st.d	sp[100],r8
8000501a:	fa e9 00 6c 	st.d	sp[108],r8
8000501e:	fa e9 00 74 	st.d	sp[116],r8
80005022:	fa e9 00 7c 	st.d	sp[124],r8
80005026:	fa e9 00 84 	st.d	sp[132],r8
	
	return_err = scan_patrol(SN);
8000502a:	f0 1f 00 4b 	mcall	80005154 <scan_rfid_save_message+0x168>
8000502e:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80005030:	e0 81 00 85 	brne	8000513a <scan_rfid_save_message+0x14e>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80005034:	4c 76       	lddpc	r6,80005150 <scan_rfid_save_message+0x164>
80005036:	0d b8       	ld.ub	r8,r6[0x3]
80005038:	1a d8       	st.w	--sp,r8
8000503a:	0d a8       	ld.ub	r8,r6[0x2]
8000503c:	1a d8       	st.w	--sp,r8
8000503e:	0d 98       	ld.ub	r8,r6[0x1]
80005040:	1a d8       	st.w	--sp,r8
80005042:	0d 88       	ld.ub	r8,r6[0x0]
80005044:	1a d8       	st.w	--sp,r8
80005046:	4c 5c       	lddpc	r12,80005158 <scan_rfid_save_message+0x16c>
80005048:	f0 1f 00 45 	mcall	8000515c <scan_rfid_save_message+0x170>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
8000504c:	37 7b       	mov	r11,119
8000504e:	30 1c       	mov	r12,1
80005050:	f0 1f 00 44 	mcall	80005160 <scan_rfid_save_message+0x174>
80005054:	fa c8 ff ce 	sub	r8,sp,-50
80005058:	fa c9 ff cc 	sub	r9,sp,-52
		log("scan_patrol err!\n");
		
	return return_err;

}
U8 scan_rfid_save_message()
8000505c:	ec c5 ff fc 	sub	r5,r6,-4
80005060:	2f cd       	sub	sp,-16
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005062:	30 9e       	mov	lr,9
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005064:	30 0c       	mov	r12,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
			
			temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80005066:	0d 8a       	ld.ub	r10,r6[0x0]
80005068:	f4 0b 16 04 	lsr	r11,r10,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000506c:	fc 0b 18 00 	cp.b	r11,lr
80005070:	f7 bb 08 d0 	subls	r11,-48
80005074:	f1 fb 8e 00 	st.bls	r8[0x0],r11
			else
			data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005078:	f7 bb 0b a9 	subhi	r11,-87
8000507c:	f1 fb be 00 	st.bhi	r8[0x0],r11
			
			data_buffer.RFID_ID[i*4+1] = 0x00;
80005080:	b0 9c       	st.b	r8[0x1],r12
			
			temp = (SN[i] & 0x0F);//瀛浣浣
80005082:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
			if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80005086:	fc 0a 18 00 	cp.b	r10,lr
8000508a:	f7 ba 08 d0 	subls	r10,-48
8000508e:	f3 fa 8e 00 	st.bls	r9[0x0],r10
			else
			data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80005092:	f7 ba 0b a9 	subhi	r10,-87
80005096:	f3 fa be 00 	st.bhi	r9[0x0],r10

			data_buffer.RFID_ID[i*4+3] = 0x00;
8000509a:	b0 bc       	st.b	r8[0x3],r12
8000509c:	2f f6       	sub	r6,-1
8000509e:	2f c8       	sub	r8,-4
800050a0:	2f c9       	sub	r9,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″
800050a2:	0a 36       	cp.w	r6,r5
800050a4:	ce 11       	brne	80005066 <scan_rfid_save_message+0x7a>
		
		//memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
		
		header.length = (0x0008 + sizeof(Message_Data_t));
		
		if(start_session > 0x9f)start_session = 0x80;
800050a6:	4b 08       	lddpc	r8,80005164 <scan_rfid_save_message+0x178>
800050a8:	11 89       	ld.ub	r9,r8[0x0]
800050aa:	39 f8       	mov	r8,-97
800050ac:	f0 09 18 00 	cp.b	r9,r8
800050b0:	e0 88 00 05 	brls	800050ba <scan_rfid_save_message+0xce>
800050b4:	38 09       	mov	r9,-128
800050b6:	4a c8       	lddpc	r8,80005164 <scan_rfid_save_message+0x178>
800050b8:	b0 89       	st.b	r8[0x0],r9
		
		header.session_id = (++start_session);
800050ba:	4a b8       	lddpc	r8,80005164 <scan_rfid_save_message+0x178>
800050bc:	11 86       	ld.ub	r6,r8[0x0]
800050be:	2f f6       	sub	r6,-1
800050c0:	b0 86       	st.b	r8[0x0],r6
		
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
800050c2:	30 5a       	mov	r10,5
800050c4:	4a 9b       	lddpc	r11,80005168 <scan_rfid_save_message+0x17c>
800050c6:	fa cc ff c9 	sub	r12,sp,-55
800050ca:	f0 1f 00 29 	mcall	8000516c <scan_rfid_save_message+0x180>
		header.type = 0xe000;
		
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
800050ce:	31 88       	mov	r8,24
800050d0:	fb 58 00 32 	st.h	sp[50],r8
800050d4:	fb 66 00 36 	st.b	sp[54],r6
800050d8:	fe 78 e0 00 	mov	r8,-8192
800050dc:	fb 58 00 34 	st.h	sp[52],r8
800050e0:	fa c6 ff c4 	sub	r6,sp,-60
800050e4:	30 aa       	mov	r10,10
800050e6:	fa cb ff ce 	sub	r11,sp,-50
800050ea:	0c 9c       	mov	r12,r6
800050ec:	f0 1f 00 20 	mcall	8000516c <scan_rfid_save_message+0x180>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800050f0:	31 0a       	mov	r10,16
800050f2:	fa cb ff de 	sub	r11,sp,-34
800050f6:	fa cc ff ba 	sub	r12,sp,-70
800050fa:	f0 1f 00 1d 	mcall	8000516c <scan_rfid_save_message+0x180>
		
		//xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
		Message_Protocol_t  xgmessage;
		memcpy(&xgmessage, message, sizeof(Message_Protocol_t));
800050fe:	31 aa       	mov	r10,26
80005100:	0c 9b       	mov	r11,r6
80005102:	fa cc ff fe 	sub	r12,sp,-2
80005106:	f0 1f 00 1a 	mcall	8000516c <scan_rfid_save_message+0x180>

		Message_Protocol_t * myptr = get_message_store();
8000510a:	49 a8       	lddpc	r8,80005170 <scan_rfid_save_message+0x184>
8000510c:	70 0c       	ld.w	r12,r8[0x0]
8000510e:	f0 1f 00 1a 	mcall	80005174 <scan_rfid_save_message+0x188>
80005112:	50 7c       	stdsp	sp[0x1c],r12
		if(NULL != myptr)
80005114:	c0 f0       	breq	80005132 <scan_rfid_save_message+0x146>
		{
			memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));
80005116:	31 aa       	mov	r10,26
80005118:	fa cb ff fe 	sub	r11,sp,-2
8000511c:	f0 1f 00 14 	mcall	8000516c <scan_rfid_save_message+0x180>
			xQueueSend(xg_resend_queue, &myptr, 0);
80005120:	49 68       	lddpc	r8,80005178 <scan_rfid_save_message+0x18c>
80005122:	70 0c       	ld.w	r12,r8[0x0]
80005124:	30 09       	mov	r9,0
80005126:	12 9a       	mov	r10,r9
80005128:	fa cb ff e4 	sub	r11,sp,-28
8000512c:	f0 1f 00 14 	mcall	8000517c <scan_rfid_save_message+0x190>
80005130:	c0 c8       	rjmp	80005148 <scan_rfid_save_message+0x15c>
		}
		else
		{
			log("myptr: err\n\r" );
80005132:	49 4c       	lddpc	r12,80005180 <scan_rfid_save_message+0x194>
80005134:	f0 1f 00 0a 	mcall	8000515c <scan_rfid_save_message+0x170>
80005138:	c0 88       	rjmp	80005148 <scan_rfid_save_message+0x15c>
		}
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
8000513a:	37 8b       	mov	r11,120
8000513c:	30 1c       	mov	r12,1
8000513e:	f0 1f 00 09 	mcall	80005160 <scan_rfid_save_message+0x174>
		log("no card find...\n");
80005142:	49 1c       	lddpc	r12,80005184 <scan_rfid_save_message+0x198>
80005144:	f0 1f 00 06 	mcall	8000515c <scan_rfid_save_message+0x170>
	}
	
	return return_err;
	
}
80005148:	0e 9c       	mov	r12,r7
8000514a:	2d dd       	sub	sp,-140
8000514c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005150:	00 00       	add	r0,r0
80005152:	0b 60       	ld.uh	r0,--r5
80005154:	80 00       	ld.sh	r0,r0[0x0]
80005156:	4f 9c       	lddpc	r12,80005338 <xg_flashc_init+0x7c>
80005158:	80 00       	ld.sh	r0,r0[0x0]
8000515a:	d6 c8       	*unknown*
8000515c:	80 00       	ld.sh	r0,r0[0x0]
8000515e:	6d fc       	ld.w	r12,r6[0x7c]
80005160:	80 00       	ld.sh	r0,r0[0x0]
80005162:	3f 88       	mov	r8,-8
80005164:	00 00       	add	r0,r0
80005166:	05 30       	ld.ub	r0,r2++
80005168:	00 00       	add	r0,r0
8000516a:	05 28       	ld.uh	r8,r2++
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	76 78       	ld.w	r8,r11[0x1c]
80005170:	00 00       	add	r0,r0
80005172:	0b 70       	ld.ub	r0,--r5
80005174:	80 00       	ld.sh	r0,r0[0x0]
80005176:	2c d0       	sub	r0,-51
80005178:	00 00       	add	r0,r0
8000517a:	0b 6c       	ld.uh	r12,--r5
8000517c:	80 00       	ld.sh	r0,r0[0x0]
8000517e:	62 1c       	ld.w	r12,r1[0x4]
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	d5 5c       	*unknown*
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	d6 e4       	*unknown*

80005188 <rfid_init>:
/*the queue is used to receive failure-send message*/
extern volatile xQueueHandle xg_resend_queue ;


void rfid_init()
{
80005188:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
8000518a:	f0 1f 00 02 	mcall	80005190 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		//
}
8000518e:	d8 02       	popm	pc
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	4a 44       	lddpc	r4,80005220 <local_start_timer+0x24>

80005194 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005194:	58 0c       	cp.w	r12,0
80005196:	5e 0c       	reteq	r12
80005198:	30 08       	mov	r8,0
	{
		nop();
8000519a:	d7 03       	nop
		nop();
8000519c:	d7 03       	nop
		nop();
8000519e:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
800051a0:	2f f8       	sub	r8,-1
800051a2:	10 3c       	cp.w	r12,r8
800051a4:	fe 9b ff fb 	brhi	8000519a <delay_ns+0x6>
800051a8:	5e fc       	retal	r12
800051aa:	d7 03       	nop

800051ac <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
800051ac:	eb cd 40 e0 	pushm	r5-r7,lr
800051b0:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
800051b2:	58 0c       	cp.w	r12,0
800051b4:	c0 b0       	breq	800051ca <delay_us+0x1e>
800051b6:	30 07       	mov	r7,0
		delay_ns(1000);
800051b8:	e0 65 03 e8 	mov	r5,1000
800051bc:	0a 9c       	mov	r12,r5
800051be:	f0 1f 00 05 	mcall	800051d0 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
800051c2:	2f f7       	sub	r7,-1
800051c4:	0e 36       	cp.w	r6,r7
800051c6:	fe 9b ff fb 	brhi	800051bc <delay_us+0x10>
800051ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051ce:	00 00       	add	r0,r0
800051d0:	80 00       	ld.sh	r0,r0[0x0]
800051d2:	51 94       	stdsp	sp[0x64],r4

800051d4 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
800051d4:	eb cd 40 e0 	pushm	r5-r7,lr
800051d8:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
800051da:	58 0c       	cp.w	r12,0
800051dc:	c0 b0       	breq	800051f2 <delay_ms+0x1e>
800051de:	30 07       	mov	r7,0
		delay_us(1000);
800051e0:	e0 65 03 e8 	mov	r5,1000
800051e4:	0a 9c       	mov	r12,r5
800051e6:	f0 1f 00 05 	mcall	800051f8 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800051ea:	2f f7       	sub	r7,-1
800051ec:	0e 36       	cp.w	r6,r7
800051ee:	fe 9b ff fb 	brhi	800051e4 <delay_ms+0x10>
800051f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800051f6:	00 00       	add	r0,r0
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	51 ac       	stdsp	sp[0x68],r12

800051fc <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800051fc:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
800051fe:	30 3b       	mov	r11,3
80005200:	48 8c       	lddpc	r12,80005220 <local_start_timer+0x24>
80005202:	f0 1f 00 09 	mcall	80005224 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80005206:	fe 78 38 00 	mov	r8,-51200
8000520a:	e0 69 91 0d 	mov	r9,37133
8000520e:	ea 19 00 52 	orh	r9,0x52
80005212:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80005214:	32 09       	mov	r9,32
80005216:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005218:	30 59       	mov	r9,5
8000521a:	91 09       	st.w	r8[0x0],r9
}
8000521c:	d8 02       	popm	pc
8000521e:	00 00       	add	r0,r0
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	d6 f8       	*unknown*
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	53 a8       	stdsp	sp[0xe8],r8

80005228 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005228:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
8000522a:	30 3a       	mov	r10,3
8000522c:	e0 6b 1b 00 	mov	r11,6912
80005230:	ea 1b 00 b7 	orh	r11,0xb7
80005234:	fe 7c 0c 00 	mov	r12,-62464
80005238:	f0 1f 00 19 	mcall	8000529c <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
8000523c:	31 08       	mov	r8,16
8000523e:	1a d8       	st.w	--sp,r8
80005240:	30 08       	mov	r8,0
80005242:	30 19       	mov	r9,1
80005244:	30 7a       	mov	r10,7
80005246:	10 9b       	mov	r11,r8
80005248:	fe 7c 0c 00 	mov	r12,-62464
8000524c:	f0 1f 00 15 	mcall	800052a0 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005250:	30 08       	mov	r8,0
80005252:	30 19       	mov	r9,1
80005254:	12 9a       	mov	r10,r9
80005256:	10 9b       	mov	r11,r8
80005258:	fe 7c 0c 00 	mov	r12,-62464
8000525c:	f0 1f 00 12 	mcall	800052a4 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005260:	30 0b       	mov	r11,0
80005262:	fe 7c 0c 00 	mov	r12,-62464
80005266:	f0 1f 00 11 	mcall	800052a8 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
8000526a:	fe 7c 0c 00 	mov	r12,-62464
8000526e:	f0 1f 00 10 	mcall	800052ac <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80005272:	30 0a       	mov	r10,0
80005274:	1a da       	st.w	--sp,r10
80005276:	1a da       	st.w	--sp,r10
80005278:	14 98       	mov	r8,r10
8000527a:	14 99       	mov	r9,r10
8000527c:	30 1b       	mov	r11,1
8000527e:	fe 7c 0c 00 	mov	r12,-62464
80005282:	f0 1f 00 0c 	mcall	800052b0 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80005286:	30 1c       	mov	r12,1
80005288:	f0 1f 00 0b 	mcall	800052b4 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
8000528c:	30 2b       	mov	r11,2
8000528e:	fe 7c 0c 00 	mov	r12,-62464
80005292:	f0 1f 00 0a 	mcall	800052b8 <local_start_pll0+0x90>
80005296:	2f dd       	sub	sp,-12
/****/
}
80005298:	d8 02       	popm	pc
8000529a:	00 00       	add	r0,r0
8000529c:	80 00       	ld.sh	r0,r0[0x0]
8000529e:	56 5c       	stdsp	sp[0x194],r12
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	55 fe       	stdsp	sp[0x17c],lr
800052a4:	80 00       	ld.sh	r0,r0[0x0]
800052a6:	56 20       	stdsp	sp[0x188],r0
800052a8:	80 00       	ld.sh	r0,r0[0x0]
800052aa:	56 3a       	stdsp	sp[0x18c],r10
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	56 48       	stdsp	sp[0x190],r8
800052b0:	80 00       	ld.sh	r0,r0[0x0]
800052b2:	55 b8       	stdsp	sp[0x16c],r8
800052b4:	80 00       	ld.sh	r0,r0[0x0]
800052b6:	53 48       	stdsp	sp[0xd0],r8
800052b8:	80 00       	ld.sh	r0,r0[0x0]
800052ba:	56 52       	stdsp	sp[0x194],r2

800052bc <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800052bc:	eb cd 40 e0 	pushm	r5-r7,lr
	//{
		//log("Create the xgflash_mutex semaphore failure\n");
	//}
	//
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
800052c0:	30 0b       	mov	r11,0
800052c2:	30 1c       	mov	r12,1
800052c4:	f0 1f 00 18 	mcall	80005324 <xg_flashc_init+0x68>
800052c8:	49 88       	lddpc	r8,80005328 <xg_flashc_init+0x6c>
800052ca:	91 0c       	st.w	r8[0x0],r12
800052cc:	70 08       	ld.w	r8,r8[0x0]
800052ce:	58 08       	cp.w	r8,0
800052d0:	c0 80       	breq	800052e0 <xg_flashc_init+0x24>
800052d2:	49 68       	lddpc	r8,80005328 <xg_flashc_init+0x6c>
800052d4:	70 0c       	ld.w	r12,r8[0x0]
800052d6:	30 09       	mov	r9,0
800052d8:	12 9a       	mov	r10,r9
800052da:	12 9b       	mov	r11,r9
800052dc:	f0 1f 00 14 	mcall	8000532c <xg_flashc_init+0x70>
	if (xBinarySemaphore == NULL)
800052e0:	49 28       	lddpc	r8,80005328 <xg_flashc_init+0x6c>
800052e2:	70 08       	ld.w	r8,r8[0x0]
800052e4:	58 08       	cp.w	r8,0
800052e6:	c0 41       	brne	800052ee <xg_flashc_init+0x32>
	{
		log("Create the xBinarySemaphore failure\n");
800052e8:	49 2c       	lddpc	r12,80005330 <xg_flashc_init+0x74>
800052ea:	f0 1f 00 13 	mcall	80005334 <xg_flashc_init+0x78>
	//if (SendM_CountingSemaphore == NULL)
	//{
		//log("Create the SendM_Counting semaphore failure\n");
	//}
	//
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
800052ee:	30 4b       	mov	r11,4
800052f0:	36 4c       	mov	r12,100
800052f2:	f0 1f 00 0d 	mcall	80005324 <xg_flashc_init+0x68>
800052f6:	49 18       	lddpc	r8,80005338 <xg_flashc_init+0x7c>
800052f8:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(100, sizeof(U32));
800052fa:	30 4b       	mov	r11,4
800052fc:	36 4c       	mov	r12,100
800052fe:	f0 1f 00 0a 	mcall	80005324 <xg_flashc_init+0x68>
80005302:	48 f8       	lddpc	r8,8000533c <xg_flashc_init+0x80>
80005304:	91 0c       	st.w	r8[0x0],r12
80005306:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005308:	10 96       	mov	r6,r8
8000530a:	48 e5       	lddpc	r5,80005340 <xg_flashc_init+0x84>
8000530c:	6c 0c       	ld.w	r12,r6[0x0]
8000530e:	ea 07 00 0b 	add	r11,r5,r7
80005312:	f0 1f 00 0d 	mcall	80005344 <xg_flashc_init+0x88>
80005316:	2e 67       	sub	r7,-26
	//}
	//
	xg_resend_queue = xQueueCreate(100, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(100, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005318:	e0 47 0a 28 	cp.w	r7,2600
8000531c:	cf 81       	brne	8000530c <xg_flashc_init+0x50>
	//flashc_lock_all_regions(false);
	//xgflash_list_info_init();
	
	
	//create_xg_flash_test_task();
}
8000531e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005322:	00 00       	add	r0,r0
80005324:	80 00       	ld.sh	r0,r0[0x0]
80005326:	63 1c       	ld.w	r12,r1[0x44]
80005328:	00 00       	add	r0,r0
8000532a:	0b 74       	ld.ub	r4,--r5
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	62 1c       	ld.w	r12,r1[0x4]
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	d7 10       	acall	0x71
80005334:	80 00       	ld.sh	r0,r0[0x0]
80005336:	6d fc       	ld.w	r12,r6[0x7c]
80005338:	00 00       	add	r0,r0
8000533a:	0b 6c       	ld.uh	r12,--r5
8000533c:	00 00       	add	r0,r0
8000533e:	0b 70       	ld.ub	r0,--r5
80005340:	00 00       	add	r0,r0
80005342:	51 34       	stdsp	sp[0x4c],r4
80005344:	80 00       	ld.sh	r0,r0[0x0]
80005346:	2b 24       	sub	r4,-78

80005348 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005348:	fe 68 14 00 	mov	r8,-125952
8000534c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000534e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80005352:	91 09       	st.w	r8[0x0],r9
}
80005354:	5e fc       	retal	r12

80005356 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005356:	f8 08 16 05 	lsr	r8,r12,0x5
8000535a:	a9 68       	lsl	r8,0x8
8000535c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
80005360:	58 1b       	cp.w	r11,1
80005362:	c0 d0       	breq	8000537c <gpio_enable_module_pin+0x26>
80005364:	c0 63       	brcs	80005370 <gpio_enable_module_pin+0x1a>
80005366:	58 2b       	cp.w	r11,2
80005368:	c1 00       	breq	80005388 <gpio_enable_module_pin+0x32>
8000536a:	58 3b       	cp.w	r11,3
8000536c:	c1 40       	breq	80005394 <gpio_enable_module_pin+0x3e>
8000536e:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005370:	30 19       	mov	r9,1
80005372:	f2 0c 09 49 	lsl	r9,r9,r12
80005376:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005378:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000537a:	c1 28       	rjmp	8000539e <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000537c:	30 19       	mov	r9,1
8000537e:	f2 0c 09 49 	lsl	r9,r9,r12
80005382:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80005384:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005386:	c0 c8       	rjmp	8000539e <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80005388:	30 19       	mov	r9,1
8000538a:	f2 0c 09 49 	lsl	r9,r9,r12
8000538e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80005390:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80005392:	c0 68       	rjmp	8000539e <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80005394:	30 19       	mov	r9,1
80005396:	f2 0c 09 49 	lsl	r9,r9,r12
8000539a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000539c:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
8000539e:	30 19       	mov	r9,1
800053a0:	f2 0c 09 4c 	lsl	r12,r9,r12
800053a4:	91 2c       	st.w	r8[0x8],r12
800053a6:	5e fd       	retal	0

800053a8 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800053a8:	d4 21       	pushm	r4-r7,lr
800053aa:	18 97       	mov	r7,r12
800053ac:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053ae:	58 0b       	cp.w	r11,0
800053b0:	c0 31       	brne	800053b6 <gpio_enable_module+0xe>
800053b2:	30 05       	mov	r5,0
800053b4:	c0 d8       	rjmp	800053ce <gpio_enable_module+0x26>
800053b6:	30 06       	mov	r6,0
800053b8:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800053ba:	6e 1b       	ld.w	r11,r7[0x4]
800053bc:	6e 0c       	ld.w	r12,r7[0x0]
800053be:	f0 1f 00 06 	mcall	800053d4 <gpio_enable_module+0x2c>
800053c2:	18 45       	or	r5,r12
		gpiomap++;
800053c4:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800053c6:	2f f6       	sub	r6,-1
800053c8:	0c 34       	cp.w	r4,r6
800053ca:	fe 9b ff f8 	brhi	800053ba <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800053ce:	0a 9c       	mov	r12,r5
800053d0:	d8 22       	popm	r4-r7,pc
800053d2:	00 00       	add	r0,r0
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	53 56       	stdsp	sp[0xd4],r6

800053d8 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800053d8:	f8 08 16 05 	lsr	r8,r12,0x5
800053dc:	a9 68       	lsl	r8,0x8
800053de:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
800053e2:	30 19       	mov	r9,1
800053e4:	f2 0c 09 4c 	lsl	r12,r9,r12
800053e8:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
800053ec:	91 1c       	st.w	r8[0x4],r12
}
800053ee:	5e fc       	retal	r12

800053f0 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800053f0:	f8 08 16 05 	lsr	r8,r12,0x5
800053f4:	a9 68       	lsl	r8,0x8
800053f6:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800053fa:	30 19       	mov	r9,1
800053fc:	f2 0c 09 4c 	lsl	r12,r9,r12
80005400:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005404:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005408:	91 1c       	st.w	r8[0x4],r12
}
8000540a:	5e fc       	retal	r12

8000540c <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000540c:	f8 08 16 05 	lsr	r8,r12,0x5
80005410:	a9 68       	lsl	r8,0x8
80005412:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005416:	30 19       	mov	r9,1
80005418:	f2 0c 09 4c 	lsl	r12,r9,r12
8000541c:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005420:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005424:	91 1c       	st.w	r8[0x4],r12
}
80005426:	5e fc       	retal	r12

80005428 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005428:	c0 08       	rjmp	80005428 <_unhandled_interrupt>
8000542a:	d7 03       	nop

8000542c <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000542c:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005430:	49 99       	lddpc	r9,80005494 <INTC_register_interrupt+0x68>
80005432:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005436:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000543a:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
8000543c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005440:	58 0a       	cp.w	r10,0
80005442:	c0 91       	brne	80005454 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005444:	49 59       	lddpc	r9,80005498 <INTC_register_interrupt+0x6c>
80005446:	49 6a       	lddpc	r10,8000549c <INTC_register_interrupt+0x70>
80005448:	12 1a       	sub	r10,r9
8000544a:	fe 79 08 00 	mov	r9,-63488
8000544e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005452:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005454:	58 1a       	cp.w	r10,1
80005456:	c0 a1       	brne	8000546a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80005458:	49 09       	lddpc	r9,80005498 <INTC_register_interrupt+0x6c>
8000545a:	49 2a       	lddpc	r10,800054a0 <INTC_register_interrupt+0x74>
8000545c:	12 1a       	sub	r10,r9
8000545e:	bf aa       	sbr	r10,0x1e
80005460:	fe 79 08 00 	mov	r9,-63488
80005464:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005468:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
8000546a:	58 2a       	cp.w	r10,2
8000546c:	c0 a1       	brne	80005480 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
8000546e:	48 b9       	lddpc	r9,80005498 <INTC_register_interrupt+0x6c>
80005470:	48 da       	lddpc	r10,800054a4 <INTC_register_interrupt+0x78>
80005472:	12 1a       	sub	r10,r9
80005474:	bf ba       	sbr	r10,0x1f
80005476:	fe 79 08 00 	mov	r9,-63488
8000547a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000547e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80005480:	48 69       	lddpc	r9,80005498 <INTC_register_interrupt+0x6c>
80005482:	48 aa       	lddpc	r10,800054a8 <INTC_register_interrupt+0x7c>
80005484:	12 1a       	sub	r10,r9
80005486:	ea 1a c0 00 	orh	r10,0xc000
8000548a:	fe 79 08 00 	mov	r9,-63488
8000548e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005492:	5e fc       	retal	r12
80005494:	80 00       	ld.sh	r0,r0[0x0]
80005496:	d7 48       	*unknown*
80005498:	80 00       	ld.sh	r0,r0[0x0]
8000549a:	cc 00       	breq	8000541a <gpio_clr_gpio_pin+0xe>
8000549c:	80 00       	ld.sh	r0,r0[0x0]
8000549e:	cd 04       	brge	8000543e <INTC_register_interrupt+0x12>
800054a0:	80 00       	ld.sh	r0,r0[0x0]
800054a2:	cd 12       	brcc	80005444 <INTC_register_interrupt+0x18>
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	cd 20       	breq	8000544a <INTC_register_interrupt+0x1e>
800054a8:	80 00       	ld.sh	r0,r0[0x0]
800054aa:	cd 2e       	rcall	8000524e <local_start_pll0+0x26>

800054ac <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800054ac:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054ae:	49 18       	lddpc	r8,800054f0 <INTC_init_interrupts+0x44>
800054b0:	e3 b8 00 01 	mtsr	0x4,r8
800054b4:	49 0e       	lddpc	lr,800054f4 <INTC_init_interrupts+0x48>
800054b6:	30 07       	mov	r7,0
800054b8:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054ba:	49 0c       	lddpc	r12,800054f8 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054bc:	49 05       	lddpc	r5,800054fc <INTC_init_interrupts+0x50>
800054be:	10 15       	sub	r5,r8
800054c0:	fe 76 08 00 	mov	r6,-63488
800054c4:	c1 08       	rjmp	800054e4 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800054c6:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
800054c8:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054ca:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800054cc:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
800054d0:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054d2:	10 3a       	cp.w	r10,r8
800054d4:	fe 9b ff fc 	brhi	800054cc <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800054d8:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
800054dc:	2f f7       	sub	r7,-1
800054de:	2f 8e       	sub	lr,-8
800054e0:	59 37       	cp.w	r7,19
800054e2:	c0 50       	breq	800054ec <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
800054e4:	7c 08       	ld.w	r8,lr[0x0]
800054e6:	58 08       	cp.w	r8,0
800054e8:	ce f1       	brne	800054c6 <INTC_init_interrupts+0x1a>
800054ea:	cf 7b       	rjmp	800054d8 <INTC_init_interrupts+0x2c>
800054ec:	d8 22       	popm	r4-r7,pc
800054ee:	00 00       	add	r0,r0
800054f0:	80 00       	ld.sh	r0,r0[0x0]
800054f2:	cc 00       	breq	80005472 <INTC_register_interrupt+0x46>
800054f4:	80 00       	ld.sh	r0,r0[0x0]
800054f6:	d7 48       	*unknown*
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	54 28       	stdsp	sp[0x108],r8
800054fc:	80 00       	ld.sh	r0,r0[0x0]
800054fe:	cd 04       	brge	8000549e <INTC_register_interrupt+0x72>

80005500 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005500:	fe 78 08 00 	mov	r8,-63488
80005504:	e0 69 00 83 	mov	r9,131
80005508:	f2 0c 01 0c 	sub	r12,r9,r12
8000550c:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005510:	f2 ca ff c0 	sub	r10,r9,-64
80005514:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005518:	58 08       	cp.w	r8,0
8000551a:	c0 21       	brne	8000551e <_get_interrupt_handler+0x1e>
8000551c:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000551e:	f0 08 12 00 	clz	r8,r8
80005522:	48 5a       	lddpc	r10,80005534 <_get_interrupt_handler+0x34>
80005524:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005528:	f0 08 11 1f 	rsub	r8,r8,31
8000552c:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000552e:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005532:	5e fc       	retal	r12
80005534:	80 00       	ld.sh	r0,r0[0x0]
80005536:	d7 48       	*unknown*

80005538 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005538:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000553a:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000553e:	99 a8       	st.w	r12[0x28],r8
}
80005540:	5e fc       	retal	r12
80005542:	d7 03       	nop

80005544 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005544:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005546:	ec 5b bb 9f 	cp.w	r11,899999
8000554a:	e0 8b 00 04 	brhi	80005552 <pm_enable_osc0_crystal+0xe>
8000554e:	30 4b       	mov	r11,4
80005550:	c1 38       	rjmp	80005576 <pm_enable_osc0_crystal+0x32>
80005552:	e0 68 c6 bf 	mov	r8,50879
80005556:	ea 18 00 2d 	orh	r8,0x2d
8000555a:	10 3b       	cp.w	r11,r8
8000555c:	e0 8b 00 04 	brhi	80005564 <pm_enable_osc0_crystal+0x20>
80005560:	30 5b       	mov	r11,5
80005562:	c0 a8       	rjmp	80005576 <pm_enable_osc0_crystal+0x32>
80005564:	e0 68 12 00 	mov	r8,4608
80005568:	ea 18 00 7a 	orh	r8,0x7a
8000556c:	10 3b       	cp.w	r11,r8
8000556e:	f9 bb 03 06 	movlo	r11,6
80005572:	f9 bb 02 07 	movhs	r11,7
80005576:	f0 1f 00 02 	mcall	8000557c <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
8000557a:	d8 02       	popm	pc
8000557c:	80 00       	ld.sh	r0,r0[0x0]
8000557e:	55 38       	stdsp	sp[0x14c],r8

80005580 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005580:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80005582:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80005586:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80005588:	78 08       	ld.w	r8,r12[0x0]
8000558a:	a3 a8       	sbr	r8,0x2
8000558c:	99 08       	st.w	r12[0x0],r8
}
8000558e:	5e fc       	retal	r12

80005590 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005590:	79 58       	ld.w	r8,r12[0x54]
80005592:	e2 18 00 80 	andl	r8,0x80,COH
80005596:	cf d0       	breq	80005590 <pm_wait_for_clk0_ready>
}
80005598:	5e fc       	retal	r12
8000559a:	d7 03       	nop

8000559c <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
8000559c:	eb cd 40 80 	pushm	r7,lr
800055a0:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800055a2:	f0 1f 00 04 	mcall	800055b0 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800055a6:	0e 9c       	mov	r12,r7
800055a8:	f0 1f 00 03 	mcall	800055b4 <pm_enable_clk0+0x18>
}
800055ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800055b0:	80 00       	ld.sh	r0,r0[0x0]
800055b2:	55 80       	stdsp	sp[0x160],r0
800055b4:	80 00       	ld.sh	r0,r0[0x0]
800055b6:	55 90       	stdsp	sp[0x164],r0

800055b8 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
800055b8:	eb cd 40 d0 	pushm	r4,r6-r7,lr
800055bc:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
800055c0:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
800055c2:	09 f7       	ld.ub	r7,r4[0x7]
800055c4:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800055c8:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800055cc:	09 b4       	ld.ub	r4,r4[0x3]
800055ce:	08 96       	mov	r6,r4
800055d0:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800055d4:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800055d8:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800055dc:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800055e0:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800055e4:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800055e8:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800055ec:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800055f0:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800055f2:	79 58       	ld.w	r8,r12[0x54]
800055f4:	e2 18 00 20 	andl	r8,0x20,COH
800055f8:	cf d0       	breq	800055f2 <pm_cksel+0x3a>
}
800055fa:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800055fe <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
800055fe:	eb cd 40 80 	pushm	r7,lr
80005602:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
80005604:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
80005606:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
8000560a:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
8000560e:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
80005612:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
80005616:	2f 8b       	sub	r11,-8
80005618:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
8000561c:	e3 cd 80 80 	ldm	sp++,r7,pc

80005620 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80005620:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
80005622:	2f 8b       	sub	r11,-8
80005624:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80005628:	f5 e9 10 19 	or	r9,r10,r9<<0x1
8000562c:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80005630:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
80005634:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80005638:	d8 02       	popm	pc

8000563a <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
8000563a:	2f 8b       	sub	r11,-8
8000563c:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80005640:	a1 a8       	sbr	r8,0x0
80005642:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80005646:	5e fc       	retal	r12

80005648 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005648:	79 58       	ld.w	r8,r12[0x54]
8000564a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000564e:	cf d0       	breq	80005648 <pm_wait_for_pll0_locked>
}
80005650:	5e fc       	retal	r12

80005652 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80005652:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80005654:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80005658:	99 08       	st.w	r12[0x0],r8
}
8000565a:	5e fc       	retal	r12

8000565c <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
8000565c:	eb cd 40 c0 	pushm	r6-r7,lr
80005660:	18 97       	mov	r7,r12
80005662:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005664:	f0 1f 00 06 	mcall	8000567c <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005668:	0c 9b       	mov	r11,r6
8000566a:	0e 9c       	mov	r12,r7
8000566c:	f0 1f 00 05 	mcall	80005680 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005670:	30 1b       	mov	r11,1
80005672:	0e 9c       	mov	r12,r7
80005674:	f0 1f 00 04 	mcall	80005684 <pm_switch_to_osc0+0x28>
}
80005678:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000567c:	80 00       	ld.sh	r0,r0[0x0]
8000567e:	55 44       	stdsp	sp[0x150],r4
80005680:	80 00       	ld.sh	r0,r0[0x0]
80005682:	55 9c       	stdsp	sp[0x164],r12
80005684:	80 00       	ld.sh	r0,r0[0x0]
80005686:	56 52       	stdsp	sp[0x194],r2

80005688 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005688:	f8 c8 00 01 	sub	r8,r12,1
8000568c:	f0 0b 00 0b 	add	r11,r8,r11
80005690:	f6 0c 0d 0a 	divu	r10,r11,r12
80005694:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005696:	f4 c8 00 01 	sub	r8,r10,1
8000569a:	e0 48 00 fe 	cp.w	r8,254
8000569e:	e0 88 00 03 	brls	800056a4 <getBaudDiv+0x1c>
800056a2:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
800056a4:	5c 8c       	casts.h	r12
}
800056a6:	5e fc       	retal	r12

800056a8 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
800056a8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800056ac:	30 18       	mov	r8,1
800056ae:	f0 09 18 00 	cp.b	r9,r8
800056b2:	e0 88 00 04 	brls	800056ba <spi_initMaster+0x12>
800056b6:	30 2c       	mov	r12,2
800056b8:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800056ba:	e0 68 00 80 	mov	r8,128
800056be:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
800056c0:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
800056c2:	30 19       	mov	r9,1
800056c4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800056c8:	f7 39 00 0d 	ld.ub	r9,r11[13]
800056cc:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
800056d0:	30 09       	mov	r9,0
800056d2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800056d6:	30 fa       	mov	r10,15
800056d8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
800056dc:	99 18       	st.w	r12[0x4],r8
800056de:	5e f9       	retal	r9

800056e0 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800056e0:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
800056e2:	30 18       	mov	r8,1
800056e4:	f0 0b 18 00 	cp.b	r11,r8
800056e8:	5f be       	srhi	lr
800056ea:	f0 0a 18 00 	cp.b	r10,r8
800056ee:	5f b8       	srhi	r8
800056f0:	fd e8 10 08 	or	r8,lr,r8
800056f4:	c0 30       	breq	800056fa <spi_selectionMode+0x1a>
800056f6:	30 2c       	mov	r12,2
800056f8:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800056fa:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800056fc:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005700:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005704:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005708:	99 18       	st.w	r12[0x4],r8
8000570a:	d8 0a       	popm	pc,r12=0

8000570c <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
8000570c:	30 18       	mov	r8,1
8000570e:	99 08       	st.w	r12[0x0],r8
}
80005710:	5e fc       	retal	r12

80005712 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005712:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005716:	c0 58       	rjmp	80005720 <spi_write+0xe>
		if (!timeout--) {
80005718:	58 08       	cp.w	r8,0
8000571a:	c0 21       	brne	8000571e <spi_write+0xc>
8000571c:	5e ff       	retal	1
8000571e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005720:	78 49       	ld.w	r9,r12[0x10]
80005722:	e2 19 00 02 	andl	r9,0x2,COH
80005726:	cf 90       	breq	80005718 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005728:	5c 7b       	castu.h	r11
8000572a:	99 3b       	st.w	r12[0xc],r11
8000572c:	5e fd       	retal	0

8000572e <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
8000572e:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005732:	c0 58       	rjmp	8000573c <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005734:	58 08       	cp.w	r8,0
80005736:	c0 21       	brne	8000573a <spi_read+0xc>
80005738:	5e ff       	retal	1
8000573a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
8000573c:	78 49       	ld.w	r9,r12[0x10]
8000573e:	e2 19 02 01 	andl	r9,0x201,COH
80005742:	e0 49 02 01 	cp.w	r9,513
80005746:	cf 71       	brne	80005734 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005748:	78 28       	ld.w	r8,r12[0x8]
8000574a:	b6 08       	st.h	r11[0x0],r8
8000574c:	5e fd       	retal	0
8000574e:	d7 03       	nop

80005750 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005750:	eb cd 40 f8 	pushm	r3-r7,lr
80005754:	18 95       	mov	r5,r12
80005756:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005758:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000575c:	30 38       	mov	r8,3
8000575e:	f0 06 18 00 	cp.b	r6,r8
80005762:	e0 8b 00 5e 	brhi	8000581e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005766:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000576a:	30 18       	mov	r8,1
8000576c:	f0 04 18 00 	cp.b	r4,r8
80005770:	e0 8b 00 57 	brhi	8000581e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005774:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005778:	30 78       	mov	r8,7
8000577a:	f0 03 18 00 	cp.b	r3,r8
8000577e:	e0 88 00 50 	brls	8000581e <spi_setupChipReg+0xce>
80005782:	31 08       	mov	r8,16
80005784:	f0 03 18 00 	cp.b	r3,r8
80005788:	e0 8b 00 4b 	brhi	8000581e <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
8000578c:	14 9b       	mov	r11,r10
8000578e:	6e 1c       	ld.w	r12,r7[0x4]
80005790:	f0 1f 00 26 	mcall	80005828 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005794:	c4 55       	brlt	8000581e <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005796:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005798:	ec 09 16 01 	lsr	r9,r6,0x1
8000579c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
800057a0:	ec 16 00 01 	eorl	r6,0x1
800057a4:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
800057a8:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
800057ac:	20 83       	sub	r3,8
800057ae:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
800057b2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
800057b6:	ef 39 00 09 	ld.ub	r9,r7[9]
800057ba:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
800057be:	ef 39 00 0a 	ld.ub	r9,r7[10]
800057c2:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
800057c6:	0f 89       	ld.ub	r9,r7[0x0]
800057c8:	30 1a       	mov	r10,1
800057ca:	f4 09 18 00 	cp.b	r9,r10
800057ce:	c0 d0       	breq	800057e8 <spi_setupChipReg+0x98>
800057d0:	c0 a3       	brcs	800057e4 <spi_setupChipReg+0x94>
800057d2:	30 2a       	mov	r10,2
800057d4:	f4 09 18 00 	cp.b	r9,r10
800057d8:	c0 a0       	breq	800057ec <spi_setupChipReg+0x9c>
800057da:	30 3a       	mov	r10,3
800057dc:	f4 09 18 00 	cp.b	r9,r10
800057e0:	c1 f1       	brne	8000581e <spi_setupChipReg+0xce>
800057e2:	c0 78       	rjmp	800057f0 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
800057e4:	8b c8       	st.w	r5[0x30],r8
		break;
800057e6:	c0 68       	rjmp	800057f2 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
800057e8:	8b d8       	st.w	r5[0x34],r8
		break;
800057ea:	c0 48       	rjmp	800057f2 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800057ec:	8b e8       	st.w	r5[0x38],r8
		break;
800057ee:	c0 28       	rjmp	800057f2 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800057f0:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800057f2:	48 f8       	lddpc	r8,8000582c <spi_setupChipReg+0xdc>
800057f4:	70 08       	ld.w	r8,r8[0x0]
800057f6:	58 08       	cp.w	r8,0
800057f8:	c1 61       	brne	80005824 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800057fa:	30 0b       	mov	r11,0
800057fc:	30 1c       	mov	r12,1
800057fe:	f0 1f 00 0d 	mcall	80005830 <spi_setupChipReg+0xe0>
80005802:	48 b8       	lddpc	r8,8000582c <spi_setupChipReg+0xdc>
80005804:	91 0c       	st.w	r8[0x0],r12
80005806:	58 0c       	cp.w	r12,0
80005808:	c0 a0       	breq	8000581c <spi_setupChipReg+0xcc>
8000580a:	30 09       	mov	r9,0
8000580c:	12 9a       	mov	r10,r9
8000580e:	12 9b       	mov	r11,r9
80005810:	f0 1f 00 09 	mcall	80005834 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005814:	48 68       	lddpc	r8,8000582c <spi_setupChipReg+0xdc>
80005816:	70 08       	ld.w	r8,r8[0x0]
80005818:	58 08       	cp.w	r8,0
8000581a:	c0 51       	brne	80005824 <spi_setupChipReg+0xd4>
8000581c:	c0 08       	rjmp	8000581c <spi_setupChipReg+0xcc>
8000581e:	30 2c       	mov	r12,2
80005820:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005824:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005828:	80 00       	ld.sh	r0,r0[0x0]
8000582a:	56 88       	stdsp	sp[0x1a0],r8
8000582c:	00 00       	add	r0,r0
8000582e:	5b 60       	cp.w	r0,-10
80005830:	80 00       	ld.sh	r0,r0[0x0]
80005832:	63 1c       	ld.w	r12,r1[0x44]
80005834:	80 00       	ld.sh	r0,r0[0x0]
80005836:	62 1c       	ld.w	r12,r1[0x4]

80005838 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005838:	d4 01       	pushm	lr
8000583a:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000583e:	c0 58       	rjmp	80005848 <spi_unselectChip+0x10>
		if (!timeout--) {
80005840:	58 08       	cp.w	r8,0
80005842:	c0 21       	brne	80005846 <spi_unselectChip+0xe>
80005844:	da 0a       	popm	pc,r12=1
80005846:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005848:	78 49       	ld.w	r9,r12[0x10]
8000584a:	e2 19 02 00 	andl	r9,0x200,COH
8000584e:	cf 90       	breq	80005840 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005850:	78 18       	ld.w	r8,r12[0x4]
80005852:	ea 18 00 0f 	orh	r8,0xf
80005856:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005858:	fc 18 01 00 	movh	r8,0x100
8000585c:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
8000585e:	30 09       	mov	r9,0
80005860:	12 9a       	mov	r10,r9
80005862:	12 9b       	mov	r11,r9
80005864:	48 38       	lddpc	r8,80005870 <spi_unselectChip+0x38>
80005866:	70 0c       	ld.w	r12,r8[0x0]
80005868:	f0 1f 00 03 	mcall	80005874 <spi_unselectChip+0x3c>
8000586c:	d8 0a       	popm	pc,r12=0
8000586e:	00 00       	add	r0,r0
80005870:	00 00       	add	r0,r0
80005872:	5b 60       	cp.w	r0,-10
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	62 1c       	ld.w	r12,r1[0x4]

80005878 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005878:	eb cd 40 f8 	pushm	r3-r7,lr
8000587c:	18 94       	mov	r4,r12
8000587e:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005880:	49 a6       	lddpc	r6,800058e8 <spi_selectChip+0x70>
80005882:	30 07       	mov	r7,0
80005884:	31 45       	mov	r5,20
80005886:	0e 99       	mov	r9,r7
80005888:	0a 9a       	mov	r10,r5
8000588a:	0e 9b       	mov	r11,r7
8000588c:	6c 0c       	ld.w	r12,r6[0x0]
8000588e:	f0 1f 00 18 	mcall	800058ec <spi_selectChip+0x74>
80005892:	cf a0       	breq	80005886 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005894:	68 18       	ld.w	r8,r4[0x4]
80005896:	ea 18 00 0f 	orh	r8,0xf
8000589a:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
8000589c:	68 18       	ld.w	r8,r4[0x4]
8000589e:	e2 18 00 04 	andl	r8,0x4,COH
800058a2:	c1 10       	breq	800058c4 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
800058a4:	30 e8       	mov	r8,14
800058a6:	f0 03 18 00 	cp.b	r3,r8
800058aa:	e0 8b 00 1c 	brhi	800058e2 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800058ae:	68 19       	ld.w	r9,r4[0x4]
800058b0:	e6 08 15 10 	lsl	r8,r3,0x10
800058b4:	ea 18 ff f0 	orh	r8,0xfff0
800058b8:	e8 18 ff ff 	orl	r8,0xffff
800058bc:	12 68       	and	r8,r9
800058be:	89 18       	st.w	r4[0x4],r8
800058c0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800058c4:	30 38       	mov	r8,3
800058c6:	f0 03 18 00 	cp.b	r3,r8
800058ca:	e0 8b 00 0c 	brhi	800058e2 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800058ce:	68 19       	ld.w	r9,r4[0x4]
800058d0:	2f 03       	sub	r3,-16
800058d2:	30 18       	mov	r8,1
800058d4:	f0 03 09 48 	lsl	r8,r8,r3
800058d8:	5c d8       	com	r8
800058da:	12 68       	and	r8,r9
800058dc:	89 18       	st.w	r4[0x4],r8
800058de:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800058e2:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800058e4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800058e8:	00 00       	add	r0,r0
800058ea:	5b 60       	cp.w	r0,-10
800058ec:	80 00       	ld.sh	r0,r0[0x0]
800058ee:	60 10       	ld.w	r0,r0[0x4]

800058f0 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800058f0:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800058f2:	f6 08 15 04 	lsl	r8,r11,0x4
800058f6:	14 38       	cp.w	r8,r10
800058f8:	f9 b8 08 10 	movls	r8,16
800058fc:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005900:	f0 0b 02 4b 	mul	r11,r8,r11
80005904:	f6 09 16 01 	lsr	r9,r11,0x1
80005908:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000590c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005910:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005914:	f2 cb 00 01 	sub	r11,r9,1
80005918:	e0 4b ff fe 	cp.w	r11,65534
8000591c:	e0 88 00 03 	brls	80005922 <usart_set_async_baudrate+0x32>
80005920:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005922:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005924:	e8 6e 00 00 	mov	lr,524288
80005928:	59 08       	cp.w	r8,16
8000592a:	fc 08 17 10 	movne	r8,lr
8000592e:	f9 b8 00 00 	moveq	r8,0
80005932:	e4 1b ff f7 	andh	r11,0xfff7
80005936:	e0 1b fe cf 	andl	r11,0xfecf
8000593a:	16 48       	or	r8,r11
8000593c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000593e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005942:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005946:	99 89       	st.w	r12[0x20],r9
80005948:	d8 0a       	popm	pc,r12=0

8000594a <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000594a:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
8000594c:	e2 18 00 02 	andl	r8,0x2,COH
80005950:	c0 31       	brne	80005956 <usart_write_char+0xc>
80005952:	30 2c       	mov	r12,2
80005954:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005956:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000595a:	99 7b       	st.w	r12[0x1c],r11
8000595c:	5e fd       	retal	0
8000595e:	d7 03       	nop

80005960 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005960:	eb cd 40 e0 	pushm	r5-r7,lr
80005964:	18 96       	mov	r6,r12
80005966:	16 95       	mov	r5,r11
80005968:	e0 67 27 0f 	mov	r7,9999
8000596c:	c0 68       	rjmp	80005978 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
8000596e:	58 07       	cp.w	r7,0
80005970:	c0 31       	brne	80005976 <usart_putchar+0x16>
80005972:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005976:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005978:	0a 9b       	mov	r11,r5
8000597a:	0c 9c       	mov	r12,r6
8000597c:	f0 1f 00 03 	mcall	80005988 <usart_putchar+0x28>
80005980:	cf 71       	brne	8000596e <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005982:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005986:	00 00       	add	r0,r0
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	59 4a       	cp.w	r10,20

8000598c <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
8000598c:	78 58       	ld.w	r8,r12[0x14]
8000598e:	e2 18 00 e0 	andl	r8,0xe0,COH
80005992:	c0 30       	breq	80005998 <usart_read_char+0xc>
80005994:	30 4c       	mov	r12,4
80005996:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005998:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000599a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000599e:	c0 31       	brne	800059a4 <usart_read_char+0x18>
800059a0:	30 3c       	mov	r12,3
800059a2:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
800059a4:	78 68       	ld.w	r8,r12[0x18]
800059a6:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800059aa:	97 08       	st.w	r11[0x0],r8
800059ac:	5e fd       	retal	0
800059ae:	d7 03       	nop

800059b0 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
800059b0:	eb cd 40 c0 	pushm	r6-r7,lr
800059b4:	20 1d       	sub	sp,4
800059b6:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
800059b8:	1a 97       	mov	r7,sp
800059ba:	1a 9b       	mov	r11,sp
800059bc:	0c 9c       	mov	r12,r6
800059be:	f0 1f 00 07 	mcall	800059d8 <usart_getchar+0x28>
800059c2:	58 3c       	cp.w	r12,3
800059c4:	cf b0       	breq	800059ba <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
800059c6:	58 4c       	cp.w	r12,4
800059c8:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
800059cc:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
800059d0:	2f fd       	sub	sp,-4
800059d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059d6:	00 00       	add	r0,r0
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	59 8c       	cp.w	r12,24

800059dc <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
800059dc:	eb cd 40 c0 	pushm	r6-r7,lr
800059e0:	18 96       	mov	r6,r12
800059e2:	16 97       	mov	r7,r11
  while (*string != '\0')
800059e4:	17 8b       	ld.ub	r11,r11[0x0]
800059e6:	58 0b       	cp.w	r11,0
800059e8:	c0 80       	breq	800059f8 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
800059ea:	2f f7       	sub	r7,-1
800059ec:	0c 9c       	mov	r12,r6
800059ee:	f0 1f 00 04 	mcall	800059fc <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800059f2:	0f 8b       	ld.ub	r11,r7[0x0]
800059f4:	58 0b       	cp.w	r11,0
800059f6:	cf a1       	brne	800059ea <usart_write_line+0xe>
800059f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059fc:	80 00       	ld.sh	r0,r0[0x0]
800059fe:	59 60       	cp.w	r0,22

80005a00 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005a00:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005a04:	e6 18 00 01 	andh	r8,0x1,COH
80005a08:	c0 71       	brne	80005a16 <usart_reset+0x16>
80005a0a:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005a0c:	3f f8       	mov	r8,-1
80005a0e:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005a10:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005a12:	d5 03       	csrf	0x10
80005a14:	c0 48       	rjmp	80005a1c <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005a16:	3f f8       	mov	r8,-1
80005a18:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005a1a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005a1c:	30 08       	mov	r8,0
80005a1e:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005a20:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005a22:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005a24:	ea 68 61 0c 	mov	r8,680204
80005a28:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005a2a:	5e fc       	retal	r12

80005a2c <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005a2c:	eb cd 40 e0 	pushm	r5-r7,lr
80005a30:	18 96       	mov	r6,r12
80005a32:	16 97       	mov	r7,r11
80005a34:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005a36:	f0 1f 00 2f 	mcall	80005af0 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005a3a:	58 07       	cp.w	r7,0
80005a3c:	c5 80       	breq	80005aec <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005a3e:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a40:	30 49       	mov	r9,4
80005a42:	f2 08 18 00 	cp.b	r8,r9
80005a46:	e0 88 00 53 	brls	80005aec <usart_init_rs232+0xc0>
80005a4a:	30 99       	mov	r9,9
80005a4c:	f2 08 18 00 	cp.b	r8,r9
80005a50:	e0 8b 00 4e 	brhi	80005aec <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005a54:	0f d9       	ld.ub	r9,r7[0x5]
80005a56:	30 78       	mov	r8,7
80005a58:	f0 09 18 00 	cp.b	r9,r8
80005a5c:	e0 8b 00 48 	brhi	80005aec <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005a60:	8e 39       	ld.sh	r9,r7[0x6]
80005a62:	e0 68 01 01 	mov	r8,257
80005a66:	f0 09 19 00 	cp.h	r9,r8
80005a6a:	e0 8b 00 41 	brhi	80005aec <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005a6e:	ef 39 00 08 	ld.ub	r9,r7[8]
80005a72:	30 38       	mov	r8,3
80005a74:	f0 09 18 00 	cp.b	r9,r8
80005a78:	e0 8b 00 3a 	brhi	80005aec <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005a7c:	0a 9a       	mov	r10,r5
80005a7e:	6e 0b       	ld.w	r11,r7[0x0]
80005a80:	0c 9c       	mov	r12,r6
80005a82:	f0 1f 00 1d 	mcall	80005af4 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005a86:	58 1c       	cp.w	r12,1
80005a88:	c3 20       	breq	80005aec <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005a8a:	0f c8       	ld.ub	r8,r7[0x4]
80005a8c:	30 99       	mov	r9,9
80005a8e:	f2 08 18 00 	cp.b	r8,r9
80005a92:	c0 51       	brne	80005a9c <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005a94:	6c 18       	ld.w	r8,r6[0x4]
80005a96:	b1 b8       	sbr	r8,0x11
80005a98:	8d 18       	st.w	r6[0x4],r8
80005a9a:	c0 68       	rjmp	80005aa6 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005a9c:	6c 19       	ld.w	r9,r6[0x4]
80005a9e:	20 58       	sub	r8,5
80005aa0:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005aa4:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005aa6:	6c 19       	ld.w	r9,r6[0x4]
80005aa8:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005aac:	0f d8       	ld.ub	r8,r7[0x5]
80005aae:	a9 78       	lsl	r8,0x9
80005ab0:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005ab4:	12 48       	or	r8,r9
80005ab6:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005ab8:	8e 38       	ld.sh	r8,r7[0x6]
80005aba:	30 29       	mov	r9,2
80005abc:	f2 08 19 00 	cp.h	r8,r9
80005ac0:	e0 88 00 09 	brls	80005ad2 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005ac4:	6c 18       	ld.w	r8,r6[0x4]
80005ac6:	ad b8       	sbr	r8,0xd
80005ac8:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005aca:	8e b8       	ld.uh	r8,r7[0x6]
80005acc:	20 28       	sub	r8,2
80005ace:	8d a8       	st.w	r6[0x28],r8
80005ad0:	c0 68       	rjmp	80005adc <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005ad2:	6c 19       	ld.w	r9,r6[0x4]
80005ad4:	5c 78       	castu.h	r8
80005ad6:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005ada:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005adc:	6c 18       	ld.w	r8,r6[0x4]
80005ade:	e0 18 ff f0 	andl	r8,0xfff0
80005ae2:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005ae4:	35 08       	mov	r8,80
80005ae6:	8d 08       	st.w	r6[0x0],r8
80005ae8:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005aec:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005af0:	80 00       	ld.sh	r0,r0[0x0]
80005af2:	5a 00       	cp.w	r0,-32
80005af4:	80 00       	ld.sh	r0,r0[0x0]
80005af6:	58 f0       	cp.w	r0,15

80005af8 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005af8:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005afc:	fe c0 8e fc 	sub	r0,pc,-28932

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005b00:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005b04:	d5 53       	csrf	0x15
  cp      r0, r1
80005b06:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005b08:	e0 61 0a 40 	mov	r1,2624
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005b0c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005b0e:	c0 62       	brcc	80005b1a <idata_load_loop_end>
  cp      r0, r1
80005b10:	48 92       	lddpc	r2,80005b34 <udata_clear_loop_end+0x4>

80005b12 <idata_load_loop>:
  brlo    idata_load_loop
80005b12:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005b14:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005b16:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005b18:	cf d3       	brcs	80005b12 <idata_load_loop>

80005b1a <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005b1a:	e0 60 0a 40 	mov	r0,2624
  mov     r2, 0
  mov     r3, 0
80005b1e:	e0 61 5b 70 	mov	r1,23408
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005b22:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005b24:	c0 62       	brcc	80005b30 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005b26:	30 02       	mov	r2,0
80005b28:	30 03       	mov	r3,0

80005b2a <udata_clear_loop>:
80005b2a:	a1 22       	st.d	r0++,r2
80005b2c:	02 30       	cp.w	r0,r1
80005b2e:	cf e3       	brcs	80005b2a <udata_clear_loop>

80005b30 <udata_clear_loop_end>:
80005b30:	fe cf e9 80 	sub	pc,pc,-5760
80005b34:	80 00       	ld.sh	r0,r0[0x0]
80005b36:	e0 78 f8 c8 	mov	r8,129224

80005b38 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005b38:	f8 c8 ff f8 	sub	r8,r12,-8
80005b3c:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005b3e:	3f f9       	mov	r9,-1
80005b40:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005b42:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005b44:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005b46:	30 08       	mov	r8,0
80005b48:	99 08       	st.w	r12[0x0],r8
}
80005b4a:	5e fc       	retal	r12

80005b4c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005b4c:	30 08       	mov	r8,0
80005b4e:	99 48       	st.w	r12[0x10],r8
}
80005b50:	5e fc       	retal	r12

80005b52 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005b52:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005b54:	70 19       	ld.w	r9,r8[0x4]
80005b56:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005b58:	78 19       	ld.w	r9,r12[0x4]
80005b5a:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b5c:	70 19       	ld.w	r9,r8[0x4]
80005b5e:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b60:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005b62:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b64:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b66:	78 08       	ld.w	r8,r12[0x0]
80005b68:	2f f8       	sub	r8,-1
80005b6a:	99 08       	st.w	r12[0x0],r8
}
80005b6c:	5e fc       	retal	r12

80005b6e <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005b6e:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005b70:	5b fa       	cp.w	r10,-1
80005b72:	c0 31       	brne	80005b78 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005b74:	78 48       	ld.w	r8,r12[0x10]
80005b76:	c0 c8       	rjmp	80005b8e <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005b78:	f8 c8 ff f8 	sub	r8,r12,-8
80005b7c:	70 19       	ld.w	r9,r8[0x4]
80005b7e:	72 09       	ld.w	r9,r9[0x0]
80005b80:	12 3a       	cp.w	r10,r9
80005b82:	c0 63       	brcs	80005b8e <vListInsert+0x20>
80005b84:	70 18       	ld.w	r8,r8[0x4]
80005b86:	70 19       	ld.w	r9,r8[0x4]
80005b88:	72 09       	ld.w	r9,r9[0x0]
80005b8a:	12 3a       	cp.w	r10,r9
80005b8c:	cf c2       	brcc	80005b84 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005b8e:	70 19       	ld.w	r9,r8[0x4]
80005b90:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005b92:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005b94:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005b96:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005b98:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005b9a:	78 08       	ld.w	r8,r12[0x0]
80005b9c:	2f f8       	sub	r8,-1
80005b9e:	99 08       	st.w	r12[0x0],r8
}
80005ba0:	5e fc       	retal	r12

80005ba2 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005ba2:	78 18       	ld.w	r8,r12[0x4]
80005ba4:	78 29       	ld.w	r9,r12[0x8]
80005ba6:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005ba8:	78 28       	ld.w	r8,r12[0x8]
80005baa:	78 19       	ld.w	r9,r12[0x4]
80005bac:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005bae:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005bb0:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005bb2:	18 39       	cp.w	r9,r12
80005bb4:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005bb8:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005bbc:	30 09       	mov	r9,0
80005bbe:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005bc0:	70 09       	ld.w	r9,r8[0x0]
80005bc2:	20 19       	sub	r9,1
80005bc4:	91 09       	st.w	r8[0x0],r9
}
80005bc6:	5e fc       	retal	r12

80005bc8 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005bc8:	e0 68 08 08 	mov	r8,2056
80005bcc:	ea 18 08 08 	orh	r8,0x808
80005bd0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005bd2:	e0 68 09 09 	mov	r8,2313
80005bd6:	ea 18 09 09 	orh	r8,0x909
80005bda:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005bdc:	e0 68 0a 0a 	mov	r8,2570
80005be0:	ea 18 0a 0a 	orh	r8,0xa0a
80005be4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005be6:	e0 68 0b 0b 	mov	r8,2827
80005bea:	ea 18 0b 0b 	orh	r8,0xb0b
80005bee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005bf0:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005bf2:	e0 68 be ef 	mov	r8,48879
80005bf6:	ea 18 de ad 	orh	r8,0xdead
80005bfa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005bfc:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005bfe:	fc 18 00 40 	movh	r8,0x40
80005c02:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005c04:	e0 68 00 ff 	mov	r8,255
80005c08:	ea 18 ff 00 	orh	r8,0xff00
80005c0c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005c0e:	e0 68 01 01 	mov	r8,257
80005c12:	ea 18 01 01 	orh	r8,0x101
80005c16:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005c18:	e0 68 02 02 	mov	r8,514
80005c1c:	ea 18 02 02 	orh	r8,0x202
80005c20:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005c22:	e0 68 03 03 	mov	r8,771
80005c26:	ea 18 03 03 	orh	r8,0x303
80005c2a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005c2c:	e0 68 04 04 	mov	r8,1028
80005c30:	ea 18 04 04 	orh	r8,0x404
80005c34:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005c36:	e0 68 05 05 	mov	r8,1285
80005c3a:	ea 18 05 05 	orh	r8,0x505
80005c3e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005c40:	e0 68 06 06 	mov	r8,1542
80005c44:	ea 18 06 06 	orh	r8,0x606
80005c48:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005c4a:	e0 68 07 07 	mov	r8,1799
80005c4e:	ea 18 07 07 	orh	r8,0x707
80005c52:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005c54:	30 08       	mov	r8,0
80005c56:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005c58:	5e fc       	retal	r12
80005c5a:	d7 03       	nop

80005c5c <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005c5c:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005c5e:	48 38       	lddpc	r8,80005c68 <vPortEnterCritical+0xc>
80005c60:	70 09       	ld.w	r9,r8[0x0]
80005c62:	2f f9       	sub	r9,-1
80005c64:	91 09       	st.w	r8[0x0],r9
}
80005c66:	5e fc       	retal	r12
80005c68:	00 00       	add	r0,r0
80005c6a:	05 34       	ld.ub	r4,r2++

80005c6c <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005c6c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005c6e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005c70:	30 0a       	mov	r10,0
80005c72:	14 9b       	mov	r11,r10
80005c74:	49 2c       	lddpc	r12,80005cbc <xPortStartScheduler+0x50>
80005c76:	f0 1f 00 13 	mcall	80005cc0 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005c7a:	e0 68 5d c0 	mov	r8,24000
80005c7e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005c82:	30 08       	mov	r8,0
80005c84:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005c88:	e0 68 0c f0 	mov	r8,3312
80005c8c:	ea 18 00 00 	orh	r8,0x0
80005c90:	70 00       	ld.w	r0,r8[0x0]
80005c92:	60 0d       	ld.w	sp,r0[0x0]
80005c94:	1b 00       	ld.w	r0,sp++
80005c96:	e0 68 05 34 	mov	r8,1332
80005c9a:	ea 18 00 00 	orh	r8,0x0
80005c9e:	91 00       	st.w	r8[0x0],r0
80005ca0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005ca4:	2f ed       	sub	sp,-8
80005ca6:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005caa:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005cae:	e3 b0 00 00 	mtsr	0x0,r0
80005cb2:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005cb6:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005cba:	d8 0a       	popm	pc,r12=0
80005cbc:	80 00       	ld.sh	r0,r0[0x0]
80005cbe:	5d 88       	*unknown*
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	54 2c       	stdsp	sp[0x108],r12

80005cc4 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005cc4:	20 6d       	sub	sp,24
80005cc6:	eb cd 00 ff 	pushm	r0-r7
80005cca:	fa c7 ff c0 	sub	r7,sp,-64
80005cce:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005cd2:	ef 40 ff e0 	st.w	r7[-32],r0
80005cd6:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005cda:	ef 40 ff e4 	st.w	r7[-28],r0
80005cde:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005ce2:	e0 68 05 34 	mov	r8,1332
80005ce6:	ea 18 00 00 	orh	r8,0x0
80005cea:	70 00       	ld.w	r0,r8[0x0]
80005cec:	1a d0       	st.w	--sp,r0
80005cee:	f0 1f 00 1a 	mcall	80005d54 <LABEL_RET_SCALL_263+0x14>
80005cf2:	e0 68 0c f0 	mov	r8,3312
80005cf6:	ea 18 00 00 	orh	r8,0x0
80005cfa:	70 00       	ld.w	r0,r8[0x0]
80005cfc:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005cfe:	f0 1f 00 17 	mcall	80005d58 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005d02:	e0 68 0c f0 	mov	r8,3312
80005d06:	ea 18 00 00 	orh	r8,0x0
80005d0a:	70 00       	ld.w	r0,r8[0x0]
80005d0c:	60 0d       	ld.w	sp,r0[0x0]
80005d0e:	1b 00       	ld.w	r0,sp++
80005d10:	e0 68 05 34 	mov	r8,1332
80005d14:	ea 18 00 00 	orh	r8,0x0
80005d18:	91 00       	st.w	r8[0x0],r0
80005d1a:	fa c7 ff d8 	sub	r7,sp,-40
80005d1e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005d22:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005d26:	e0 61 05 34 	mov	r1,1332
80005d2a:	ea 11 00 00 	orh	r1,0x0
80005d2e:	62 02       	ld.w	r2,r1[0x0]
80005d30:	58 02       	cp.w	r2,0
80005d32:	c0 70       	breq	80005d40 <LABEL_RET_SCALL_263>
80005d34:	e4 c2 00 01 	sub	r2,r2,1
80005d38:	83 02       	st.w	r1[0x0],r2
80005d3a:	58 02       	cp.w	r2,0
80005d3c:	c0 21       	brne	80005d40 <LABEL_RET_SCALL_263>
80005d3e:	b1 c0       	cbr	r0,0x10

80005d40 <LABEL_RET_SCALL_263>:
80005d40:	ef 40 ff f8 	st.w	r7[-8],r0
80005d44:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005d48:	ef 40 ff fc 	st.w	r7[-4],r0
80005d4c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005d50:	2f ad       	sub	sp,-24
80005d52:	d6 13       	rets
80005d54:	80 00       	ld.sh	r0,r0[0x0]
80005d56:	5c 5c       	castu.b	r12
80005d58:	80 00       	ld.sh	r0,r0[0x0]
80005d5a:	63 a0       	ld.w	r0,r1[0x68]

80005d5c <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005d5c:	e1 b8 00 43 	mfsr	r8,0x10c
80005d60:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005d64:	5e fc       	retal	r12
80005d66:	d7 03       	nop

80005d68 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005d68:	48 78       	lddpc	r8,80005d84 <vPortExitCritical+0x1c>
80005d6a:	70 08       	ld.w	r8,r8[0x0]
80005d6c:	58 08       	cp.w	r8,0
80005d6e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005d70:	48 58       	lddpc	r8,80005d84 <vPortExitCritical+0x1c>
80005d72:	70 09       	ld.w	r9,r8[0x0]
80005d74:	20 19       	sub	r9,1
80005d76:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005d78:	70 08       	ld.w	r8,r8[0x0]
80005d7a:	58 08       	cp.w	r8,0
80005d7c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80005d7e:	d5 03       	csrf	0x10
80005d80:	5e fc       	retal	r12
80005d82:	00 00       	add	r0,r0
80005d84:	00 00       	add	r0,r0
80005d86:	05 34       	ld.ub	r4,r2++

80005d88 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005d88:	eb cd 00 ff 	pushm	r0-r7
80005d8c:	e0 68 05 34 	mov	r8,1332
80005d90:	ea 18 00 00 	orh	r8,0x0
80005d94:	70 00       	ld.w	r0,r8[0x0]
80005d96:	1a d0       	st.w	--sp,r0
80005d98:	7a 90       	ld.w	r0,sp[0x24]
80005d9a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005d9e:	58 10       	cp.w	r0,1
80005da0:	e0 8b 00 08 	brhi	80005db0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80005da4:	e0 68 0c f0 	mov	r8,3312
80005da8:	ea 18 00 00 	orh	r8,0x0
80005dac:	70 00       	ld.w	r0,r8[0x0]
80005dae:	81 0d       	st.w	r0[0x0],sp

80005db0 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005db0:	f0 1f 00 12 	mcall	80005df8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005db4:	f0 1f 00 12 	mcall	80005dfc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80005db8:	f0 1f 00 12 	mcall	80005e00 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80005dbc:	f0 1f 00 12 	mcall	80005e04 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005dc0:	7a 90       	ld.w	r0,sp[0x24]
80005dc2:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005dc6:	58 10       	cp.w	r0,1
80005dc8:	e0 8b 00 0e 	brhi	80005de4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80005dcc:	f0 1f 00 0c 	mcall	80005dfc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80005dd0:	f0 1f 00 0e 	mcall	80005e08 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80005dd4:	f0 1f 00 0c 	mcall	80005e04 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80005dd8:	e0 68 0c f0 	mov	r8,3312
80005ddc:	ea 18 00 00 	orh	r8,0x0
80005de0:	70 00       	ld.w	r0,r8[0x0]
80005de2:	60 0d       	ld.w	sp,r0[0x0]

80005de4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80005de4:	1b 00       	ld.w	r0,sp++
80005de6:	e0 68 05 34 	mov	r8,1332
80005dea:	ea 18 00 00 	orh	r8,0x0
80005dee:	91 00       	st.w	r8[0x0],r0
80005df0:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005df4:	d6 03       	rete
80005df6:	00 00       	add	r0,r0
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	5d 5c       	*unknown*
80005dfc:	80 00       	ld.sh	r0,r0[0x0]
80005dfe:	5c 5c       	castu.b	r12
80005e00:	80 00       	ld.sh	r0,r0[0x0]
80005e02:	65 a4       	ld.w	r4,r2[0x68]
80005e04:	80 00       	ld.sh	r0,r0[0x0]
80005e06:	5d 68       	*unknown*
80005e08:	80 00       	ld.sh	r0,r0[0x0]
80005e0a:	63 a0       	ld.w	r0,r1[0x68]

80005e0c <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80005e0c:	d4 01       	pushm	lr
	vTaskSuspendAll();
80005e0e:	f0 1f 00 02 	mcall	80005e14 <__malloc_lock+0x8>
}
80005e12:	d8 02       	popm	pc
80005e14:	80 00       	ld.sh	r0,r0[0x0]
80005e16:	63 90       	ld.w	r0,r1[0x64]

80005e18 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80005e18:	d4 01       	pushm	lr
	xTaskResumeAll();
80005e1a:	f0 1f 00 02 	mcall	80005e20 <__malloc_unlock+0x8>
}
80005e1e:	d8 02       	popm	pc
80005e20:	80 00       	ld.sh	r0,r0[0x0]
80005e22:	67 4c       	ld.w	r12,r3[0x50]

80005e24 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80005e24:	d4 21       	pushm	r4-r7,lr
80005e26:	16 95       	mov	r5,r11
80005e28:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80005e2a:	58 0c       	cp.w	r12,0
80005e2c:	c0 30       	breq	80005e32 <_read+0xe>
80005e2e:	3f f7       	mov	r7,-1
80005e30:	c1 48       	rjmp	80005e58 <_read+0x34>
    return -1;

  for (; len > 0; --len)
80005e32:	58 0a       	cp.w	r10,0
80005e34:	e0 89 00 04 	brgt	80005e3c <_read+0x18>
80005e38:	30 07       	mov	r7,0
80005e3a:	c0 f8       	rjmp	80005e58 <_read+0x34>
80005e3c:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80005e3e:	48 84       	lddpc	r4,80005e5c <_read+0x38>
80005e40:	68 0c       	ld.w	r12,r4[0x0]
80005e42:	f0 1f 00 08 	mcall	80005e60 <_read+0x3c>
    if (c < 0)
80005e46:	c0 95       	brlt	80005e58 <_read+0x34>
      break;

    *ptr++ = c;
80005e48:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80005e4c:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80005e4e:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80005e52:	58 08       	cp.w	r8,0
80005e54:	fe 99 ff f6 	brgt	80005e40 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80005e58:	0e 9c       	mov	r12,r7
80005e5a:	d8 22       	popm	r4-r7,pc
80005e5c:	00 00       	add	r0,r0
80005e5e:	5b 64       	cp.w	r4,-10
80005e60:	80 00       	ld.sh	r0,r0[0x0]
80005e62:	59 b0       	cp.w	r0,27

80005e64 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80005e64:	d4 21       	pushm	r4-r7,lr
80005e66:	16 95       	mov	r5,r11
80005e68:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80005e6a:	20 1c       	sub	r12,1
80005e6c:	58 2c       	cp.w	r12,2
80005e6e:	e0 8b 00 12 	brhi	80005e92 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e72:	58 0a       	cp.w	r10,0
80005e74:	c0 31       	brne	80005e7a <_write+0x16>
80005e76:	30 07       	mov	r7,0
80005e78:	c0 e8       	rjmp	80005e94 <_write+0x30>
80005e7a:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80005e7c:	48 74       	lddpc	r4,80005e98 <_write+0x34>
80005e7e:	68 0c       	ld.w	r12,r4[0x0]
80005e80:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80005e84:	f0 1f 00 06 	mcall	80005e9c <_write+0x38>
80005e88:	c0 55       	brlt	80005e92 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80005e8a:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80005e8c:	0e 36       	cp.w	r6,r7
80005e8e:	cf 81       	brne	80005e7e <_write+0x1a>
80005e90:	c0 28       	rjmp	80005e94 <_write+0x30>
80005e92:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80005e94:	0e 9c       	mov	r12,r7
80005e96:	d8 22       	popm	r4-r7,pc
80005e98:	00 00       	add	r0,r0
80005e9a:	5b 64       	cp.w	r4,-10
80005e9c:	80 00       	ld.sh	r0,r0[0x0]
80005e9e:	59 60       	cp.w	r0,22

80005ea0 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80005ea0:	eb cd 40 80 	pushm	r7,lr
80005ea4:	18 97       	mov	r7,r12
	if( pv )
80005ea6:	58 0c       	cp.w	r12,0
80005ea8:	c0 80       	breq	80005eb8 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80005eaa:	f0 1f 00 05 	mcall	80005ebc <vPortFree+0x1c>
		{
			free( pv );
80005eae:	0e 9c       	mov	r12,r7
80005eb0:	f0 1f 00 04 	mcall	80005ec0 <vPortFree+0x20>
		}
		xTaskResumeAll();
80005eb4:	f0 1f 00 04 	mcall	80005ec4 <vPortFree+0x24>
80005eb8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ebc:	80 00       	ld.sh	r0,r0[0x0]
80005ebe:	63 90       	ld.w	r0,r1[0x64]
80005ec0:	80 00       	ld.sh	r0,r0[0x0]
80005ec2:	72 20       	ld.w	r0,r9[0x8]
80005ec4:	80 00       	ld.sh	r0,r0[0x0]
80005ec6:	67 4c       	ld.w	r12,r3[0x50]

80005ec8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80005ec8:	eb cd 40 80 	pushm	r7,lr
80005ecc:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80005ece:	f0 1f 00 06 	mcall	80005ee4 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80005ed2:	0e 9c       	mov	r12,r7
80005ed4:	f0 1f 00 05 	mcall	80005ee8 <pvPortMalloc+0x20>
80005ed8:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005eda:	f0 1f 00 05 	mcall	80005eec <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80005ede:	0e 9c       	mov	r12,r7
80005ee0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	63 90       	ld.w	r0,r1[0x64]
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	72 30       	ld.w	r0,r9[0xc]
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	67 4c       	ld.w	r12,r3[0x50]

80005ef0 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80005ef0:	d4 01       	pushm	lr
80005ef2:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005ef4:	78 09       	ld.w	r9,r12[0x0]
80005ef6:	58 09       	cp.w	r9,0
80005ef8:	c1 10       	breq	80005f1a <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005efa:	78 3a       	ld.w	r10,r12[0xc]
80005efc:	79 09       	ld.w	r9,r12[0x40]
80005efe:	f4 09 00 09 	add	r9,r10,r9
80005f02:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005f04:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005f06:	14 39       	cp.w	r9,r10
80005f08:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005f0c:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80005f10:	79 0a       	ld.w	r10,r12[0x40]
80005f12:	78 3b       	ld.w	r11,r12[0xc]
80005f14:	10 9c       	mov	r12,r8
80005f16:	f0 1f 00 02 	mcall	80005f1c <prvCopyDataFromQueue+0x2c>
80005f1a:	d8 02       	popm	pc
80005f1c:	80 00       	ld.sh	r0,r0[0x0]
80005f1e:	76 78       	ld.w	r8,r11[0x1c]

80005f20 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80005f20:	eb cd 40 c0 	pushm	r6-r7,lr
80005f24:	18 97       	mov	r7,r12
80005f26:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005f28:	78 e8       	ld.w	r8,r12[0x38]
80005f2a:	58 08       	cp.w	r8,0
80005f2c:	c0 31       	brne	80005f32 <xQueueReceiveFromISR+0x12>
80005f2e:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80005f32:	f0 1f 00 0e 	mcall	80005f68 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
80005f36:	6e e8       	ld.w	r8,r7[0x38]
80005f38:	20 18       	sub	r8,1
80005f3a:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80005f3c:	6f 18       	ld.w	r8,r7[0x44]
80005f3e:	5b f8       	cp.w	r8,-1
80005f40:	c0 d1       	brne	80005f5a <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005f42:	6e 48       	ld.w	r8,r7[0x10]
80005f44:	58 08       	cp.w	r8,0
80005f46:	c0 f0       	breq	80005f64 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005f48:	ee cc ff f0 	sub	r12,r7,-16
80005f4c:	f0 1f 00 08 	mcall	80005f6c <xQueueReceiveFromISR+0x4c>
80005f50:	c0 a0       	breq	80005f64 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80005f52:	30 1c       	mov	r12,1
80005f54:	8d 0c       	st.w	r6[0x0],r12
80005f56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80005f5a:	2f f8       	sub	r8,-1
80005f5c:	ef 48 00 44 	st.w	r7[68],r8
80005f60:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f64:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	5e f0       	retal	r0
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	65 28       	ld.w	r8,r2[0x48]

80005f70 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80005f70:	eb cd 40 c0 	pushm	r6-r7,lr
80005f74:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005f76:	f0 1f 00 23 	mcall	80006000 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005f7a:	6f 28       	ld.w	r8,r7[0x48]
80005f7c:	58 08       	cp.w	r8,0
80005f7e:	e0 8a 00 18 	brle	80005fae <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f82:	6e 98       	ld.w	r8,r7[0x24]
80005f84:	58 08       	cp.w	r8,0
80005f86:	c1 40       	breq	80005fae <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f88:	ee c6 ff dc 	sub	r6,r7,-36
80005f8c:	c0 48       	rjmp	80005f94 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005f8e:	6e 98       	ld.w	r8,r7[0x24]
80005f90:	58 08       	cp.w	r8,0
80005f92:	c0 e0       	breq	80005fae <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005f94:	0c 9c       	mov	r12,r6
80005f96:	f0 1f 00 1c 	mcall	80006004 <prvUnlockQueue+0x94>
80005f9a:	c0 30       	breq	80005fa0 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005f9c:	f0 1f 00 1b 	mcall	80006008 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80005fa0:	6f 28       	ld.w	r8,r7[0x48]
80005fa2:	20 18       	sub	r8,1
80005fa4:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005fa8:	58 08       	cp.w	r8,0
80005faa:	fe 99 ff f2 	brgt	80005f8e <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80005fae:	3f f8       	mov	r8,-1
80005fb0:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005fb4:	f0 1f 00 16 	mcall	8000600c <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005fb8:	f0 1f 00 12 	mcall	80006000 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005fbc:	6f 18       	ld.w	r8,r7[0x44]
80005fbe:	58 08       	cp.w	r8,0
80005fc0:	e0 8a 00 18 	brle	80005ff0 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005fc4:	6e 48       	ld.w	r8,r7[0x10]
80005fc6:	58 08       	cp.w	r8,0
80005fc8:	c1 40       	breq	80005ff0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005fca:	ee c6 ff f0 	sub	r6,r7,-16
80005fce:	c0 48       	rjmp	80005fd6 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80005fd0:	6e 48       	ld.w	r8,r7[0x10]
80005fd2:	58 08       	cp.w	r8,0
80005fd4:	c0 e0       	breq	80005ff0 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80005fd6:	0c 9c       	mov	r12,r6
80005fd8:	f0 1f 00 0b 	mcall	80006004 <prvUnlockQueue+0x94>
80005fdc:	c0 30       	breq	80005fe2 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80005fde:	f0 1f 00 0b 	mcall	80006008 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80005fe2:	6f 18       	ld.w	r8,r7[0x44]
80005fe4:	20 18       	sub	r8,1
80005fe6:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005fea:	58 08       	cp.w	r8,0
80005fec:	fe 99 ff f2 	brgt	80005fd0 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80005ff0:	3f f8       	mov	r8,-1
80005ff2:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80005ff6:	f0 1f 00 06 	mcall	8000600c <prvUnlockQueue+0x9c>
}
80005ffa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ffe:	00 00       	add	r0,r0
80006000:	80 00       	ld.sh	r0,r0[0x0]
80006002:	5c 5c       	castu.b	r12
80006004:	80 00       	ld.sh	r0,r0[0x0]
80006006:	65 28       	ld.w	r8,r2[0x48]
80006008:	80 00       	ld.sh	r0,r0[0x0]
8000600a:	64 34       	ld.w	r4,r2[0xc]
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	5d 68       	*unknown*

80006010 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006010:	d4 31       	pushm	r0-r7,lr
80006012:	20 5d       	sub	sp,20
80006014:	18 97       	mov	r7,r12
80006016:	50 0b       	stdsp	sp[0x0],r11
80006018:	50 2a       	stdsp	sp[0x8],r10
8000601a:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000601c:	f8 c2 ff dc 	sub	r2,r12,-36
80006020:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006022:	fa c4 ff f4 	sub	r4,sp,-12
80006026:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006028:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000602a:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8000602e:	f0 1f 00 3e 	mcall	80006124 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006032:	6e e8       	ld.w	r8,r7[0x38]
80006034:	58 08       	cp.w	r8,0
80006036:	c2 a0       	breq	8000608a <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80006038:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000603a:	40 0b       	lddsp	r11,sp[0x0]
8000603c:	0e 9c       	mov	r12,r7
8000603e:	f0 1f 00 3b 	mcall	80006128 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006042:	40 18       	lddsp	r8,sp[0x4]
80006044:	58 08       	cp.w	r8,0
80006046:	c1 51       	brne	80006070 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006048:	6e e8       	ld.w	r8,r7[0x38]
8000604a:	20 18       	sub	r8,1
8000604c:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000604e:	6e 08       	ld.w	r8,r7[0x0]
80006050:	58 08       	cp.w	r8,0
80006052:	c0 41       	brne	8000605a <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006054:	f0 1f 00 36 	mcall	8000612c <xQueueGenericReceive+0x11c>
80006058:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000605a:	6e 48       	ld.w	r8,r7[0x10]
8000605c:	58 08       	cp.w	r8,0
8000605e:	c1 20       	breq	80006082 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006060:	ee cc ff f0 	sub	r12,r7,-16
80006064:	f0 1f 00 33 	mcall	80006130 <xQueueGenericReceive+0x120>
80006068:	58 1c       	cp.w	r12,1
8000606a:	c0 c1       	brne	80006082 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
8000606c:	d7 33       	scall
8000606e:	c0 a8       	rjmp	80006082 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006070:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006072:	6e 98       	ld.w	r8,r7[0x24]
80006074:	58 08       	cp.w	r8,0
80006076:	c0 60       	breq	80006082 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006078:	04 9c       	mov	r12,r2
8000607a:	f0 1f 00 2e 	mcall	80006130 <xQueueGenericReceive+0x120>
8000607e:	c0 20       	breq	80006082 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006080:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006082:	f0 1f 00 2d 	mcall	80006134 <xQueueGenericReceive+0x124>
80006086:	30 1c       	mov	r12,1
				return pdPASS;
80006088:	c4 c8       	rjmp	80006120 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000608a:	40 28       	lddsp	r8,sp[0x8]
8000608c:	58 08       	cp.w	r8,0
8000608e:	c0 51       	brne	80006098 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006090:	f0 1f 00 29 	mcall	80006134 <xQueueGenericReceive+0x124>
80006094:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006096:	c4 58       	rjmp	80006120 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006098:	58 05       	cp.w	r5,0
8000609a:	c0 51       	brne	800060a4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000609c:	08 9c       	mov	r12,r4
8000609e:	f0 1f 00 27 	mcall	80006138 <xQueueGenericReceive+0x128>
800060a2:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
800060a4:	f0 1f 00 24 	mcall	80006134 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
800060a8:	f0 1f 00 25 	mcall	8000613c <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800060ac:	f0 1f 00 1e 	mcall	80006124 <xQueueGenericReceive+0x114>
800060b0:	6f 18       	ld.w	r8,r7[0x44]
800060b2:	5b f8       	cp.w	r8,-1
800060b4:	ef f1 0a 11 	st.weq	r7[0x44],r1
800060b8:	6f 28       	ld.w	r8,r7[0x48]
800060ba:	5b f8       	cp.w	r8,-1
800060bc:	ef f1 0a 12 	st.weq	r7[0x48],r1
800060c0:	f0 1f 00 1d 	mcall	80006134 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800060c4:	06 9b       	mov	r11,r3
800060c6:	08 9c       	mov	r12,r4
800060c8:	f0 1f 00 1e 	mcall	80006140 <xQueueGenericReceive+0x130>
800060cc:	c2 41       	brne	80006114 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800060ce:	f0 1f 00 16 	mcall	80006124 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800060d2:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800060d4:	f0 1f 00 18 	mcall	80006134 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800060d8:	58 06       	cp.w	r6,0
800060da:	c1 71       	brne	80006108 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800060dc:	6e 08       	ld.w	r8,r7[0x0]
800060de:	58 08       	cp.w	r8,0
800060e0:	c0 81       	brne	800060f0 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800060e2:	f0 1f 00 11 	mcall	80006124 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800060e6:	6e 1c       	ld.w	r12,r7[0x4]
800060e8:	f0 1f 00 17 	mcall	80006144 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800060ec:	f0 1f 00 12 	mcall	80006134 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800060f0:	40 2b       	lddsp	r11,sp[0x8]
800060f2:	04 9c       	mov	r12,r2
800060f4:	f0 1f 00 15 	mcall	80006148 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800060f8:	0e 9c       	mov	r12,r7
800060fa:	f0 1f 00 15 	mcall	8000614c <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800060fe:	f0 1f 00 15 	mcall	80006150 <xQueueGenericReceive+0x140>
80006102:	c9 61       	brne	8000602e <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80006104:	d7 33       	scall
80006106:	c9 4b       	rjmp	8000602e <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006108:	0e 9c       	mov	r12,r7
8000610a:	f0 1f 00 11 	mcall	8000614c <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
8000610e:	f0 1f 00 11 	mcall	80006150 <xQueueGenericReceive+0x140>
80006112:	c8 eb       	rjmp	8000602e <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006114:	0e 9c       	mov	r12,r7
80006116:	f0 1f 00 0e 	mcall	8000614c <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000611a:	f0 1f 00 0e 	mcall	80006150 <xQueueGenericReceive+0x140>
8000611e:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006120:	2f bd       	sub	sp,-20
80006122:	d8 32       	popm	r0-r7,pc
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	5c 5c       	castu.b	r12
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	5e f0       	retal	r0
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	64 40       	ld.w	r0,r2[0x10]
80006130:	80 00       	ld.sh	r0,r0[0x0]
80006132:	65 28       	ld.w	r8,r2[0x48]
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	5d 68       	*unknown*
80006138:	80 00       	ld.sh	r0,r0[0x0]
8000613a:	64 1c       	ld.w	r12,r2[0x4]
8000613c:	80 00       	ld.sh	r0,r0[0x0]
8000613e:	63 90       	ld.w	r0,r1[0x64]
80006140:	80 00       	ld.sh	r0,r0[0x0]
80006142:	66 b8       	ld.w	r8,r3[0x2c]
80006144:	80 00       	ld.sh	r0,r0[0x0]
80006146:	64 a4       	ld.w	r4,r2[0x28]
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	69 58       	ld.w	r8,r4[0x54]
8000614c:	80 00       	ld.sh	r0,r0[0x0]
8000614e:	5f 70       	srpl	r0
80006150:	80 00       	ld.sh	r0,r0[0x0]
80006152:	67 4c       	ld.w	r12,r3[0x50]

80006154 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006154:	eb cd 40 80 	pushm	r7,lr
80006158:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000615a:	79 08       	ld.w	r8,r12[0x40]
8000615c:	58 08       	cp.w	r8,0
8000615e:	c0 a1       	brne	80006172 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006160:	78 08       	ld.w	r8,r12[0x0]
80006162:	58 08       	cp.w	r8,0
80006164:	c2 b1       	brne	800061ba <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006166:	78 1c       	ld.w	r12,r12[0x4]
80006168:	f0 1f 00 17 	mcall	800061c4 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
8000616c:	30 08       	mov	r8,0
8000616e:	8f 18       	st.w	r7[0x4],r8
80006170:	c2 58       	rjmp	800061ba <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006172:	58 0a       	cp.w	r10,0
80006174:	c1 01       	brne	80006194 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006176:	10 9a       	mov	r10,r8
80006178:	78 2c       	ld.w	r12,r12[0x8]
8000617a:	f0 1f 00 14 	mcall	800061c8 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000617e:	6e 29       	ld.w	r9,r7[0x8]
80006180:	6f 08       	ld.w	r8,r7[0x40]
80006182:	f2 08 00 08 	add	r8,r9,r8
80006186:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006188:	6e 19       	ld.w	r9,r7[0x4]
8000618a:	12 38       	cp.w	r8,r9
8000618c:	c1 73       	brcs	800061ba <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000618e:	6e 08       	ld.w	r8,r7[0x0]
80006190:	8f 28       	st.w	r7[0x8],r8
80006192:	c1 48       	rjmp	800061ba <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006194:	10 9a       	mov	r10,r8
80006196:	78 3c       	ld.w	r12,r12[0xc]
80006198:	f0 1f 00 0c 	mcall	800061c8 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
8000619c:	6f 08       	ld.w	r8,r7[0x40]
8000619e:	6e 39       	ld.w	r9,r7[0xc]
800061a0:	f2 08 01 08 	sub	r8,r9,r8
800061a4:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
800061a6:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
800061a8:	12 38       	cp.w	r8,r9
800061aa:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800061ae:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800061b2:	f3 d8 e3 19 	subcs	r9,r9,r8
800061b6:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800061ba:	6e e8       	ld.w	r8,r7[0x38]
800061bc:	2f f8       	sub	r8,-1
800061be:	8f e8       	st.w	r7[0x38],r8
}
800061c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800061c4:	80 00       	ld.sh	r0,r0[0x0]
800061c6:	64 4c       	ld.w	r12,r2[0x10]
800061c8:	80 00       	ld.sh	r0,r0[0x0]
800061ca:	76 78       	ld.w	r8,r11[0x1c]

800061cc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800061cc:	eb cd 40 c0 	pushm	r6-r7,lr
800061d0:	18 97       	mov	r7,r12
800061d2:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800061d4:	78 ec       	ld.w	r12,r12[0x38]
800061d6:	6e f8       	ld.w	r8,r7[0x3c]
800061d8:	10 3c       	cp.w	r12,r8
800061da:	c0 33       	brcs	800061e0 <xQueueGenericSendFromISR+0x14>
800061dc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800061e0:	12 9a       	mov	r10,r9
800061e2:	0e 9c       	mov	r12,r7
800061e4:	f0 1f 00 0c 	mcall	80006214 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800061e8:	6f 28       	ld.w	r8,r7[0x48]
800061ea:	5b f8       	cp.w	r8,-1
800061ec:	c0 d1       	brne	80006206 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800061ee:	6e 98       	ld.w	r8,r7[0x24]
800061f0:	58 08       	cp.w	r8,0
800061f2:	c0 f0       	breq	80006210 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800061f4:	ee cc ff dc 	sub	r12,r7,-36
800061f8:	f0 1f 00 08 	mcall	80006218 <xQueueGenericSendFromISR+0x4c>
800061fc:	c0 a0       	breq	80006210 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800061fe:	30 1c       	mov	r12,1
80006200:	8d 0c       	st.w	r6[0x0],r12
80006202:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80006206:	2f f8       	sub	r8,-1
80006208:	ef 48 00 48 	st.w	r7[72],r8
8000620c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006210:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	61 54       	ld.w	r4,r0[0x54]
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	65 28       	ld.w	r8,r2[0x48]

8000621c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
8000621c:	d4 31       	pushm	r0-r7,lr
8000621e:	20 5d       	sub	sp,20
80006220:	18 97       	mov	r7,r12
80006222:	50 0b       	stdsp	sp[0x0],r11
80006224:	50 2a       	stdsp	sp[0x8],r10
80006226:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80006228:	f8 c0 ff f0 	sub	r0,r12,-16
8000622c:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000622e:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006232:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006234:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80006238:	f0 1f 00 2f 	mcall	800062f4 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
8000623c:	6e e9       	ld.w	r9,r7[0x38]
8000623e:	6e f8       	ld.w	r8,r7[0x3c]
80006240:	10 39       	cp.w	r9,r8
80006242:	c1 42       	brcc	8000626a <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006244:	40 1a       	lddsp	r10,sp[0x4]
80006246:	40 0b       	lddsp	r11,sp[0x0]
80006248:	0e 9c       	mov	r12,r7
8000624a:	f0 1f 00 2c 	mcall	800062f8 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000624e:	6e 98       	ld.w	r8,r7[0x24]
80006250:	58 08       	cp.w	r8,0
80006252:	c0 80       	breq	80006262 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006254:	ee cc ff dc 	sub	r12,r7,-36
80006258:	f0 1f 00 29 	mcall	800062fc <xQueueGenericSend+0xe0>
8000625c:	58 1c       	cp.w	r12,1
8000625e:	c0 21       	brne	80006262 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006260:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006262:	f0 1f 00 28 	mcall	80006300 <xQueueGenericSend+0xe4>
80006266:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006268:	c4 38       	rjmp	800062ee <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000626a:	40 28       	lddsp	r8,sp[0x8]
8000626c:	58 08       	cp.w	r8,0
8000626e:	c0 51       	brne	80006278 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006270:	f0 1f 00 24 	mcall	80006300 <xQueueGenericSend+0xe4>
80006274:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006276:	c3 c8       	rjmp	800062ee <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006278:	58 04       	cp.w	r4,0
8000627a:	c0 51       	brne	80006284 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8000627c:	06 9c       	mov	r12,r3
8000627e:	f0 1f 00 22 	mcall	80006304 <xQueueGenericSend+0xe8>
80006282:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006284:	f0 1f 00 1f 	mcall	80006300 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006288:	f0 1f 00 20 	mcall	80006308 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
8000628c:	f0 1f 00 1a 	mcall	800062f4 <xQueueGenericSend+0xd8>
80006290:	6f 18       	ld.w	r8,r7[0x44]
80006292:	5b f8       	cp.w	r8,-1
80006294:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006298:	6f 28       	ld.w	r8,r7[0x48]
8000629a:	5b f8       	cp.w	r8,-1
8000629c:	ef f1 0a 12 	st.weq	r7[0x48],r1
800062a0:	f0 1f 00 18 	mcall	80006300 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800062a4:	04 9b       	mov	r11,r2
800062a6:	06 9c       	mov	r12,r3
800062a8:	f0 1f 00 19 	mcall	8000630c <xQueueGenericSend+0xf0>
800062ac:	c1 b1       	brne	800062e2 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800062ae:	f0 1f 00 12 	mcall	800062f4 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800062b2:	6e e5       	ld.w	r5,r7[0x38]
800062b4:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800062b6:	f0 1f 00 13 	mcall	80006300 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800062ba:	0c 35       	cp.w	r5,r6
800062bc:	c0 d1       	brne	800062d6 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800062be:	40 2b       	lddsp	r11,sp[0x8]
800062c0:	00 9c       	mov	r12,r0
800062c2:	f0 1f 00 14 	mcall	80006310 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800062c6:	0e 9c       	mov	r12,r7
800062c8:	f0 1f 00 13 	mcall	80006314 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800062cc:	f0 1f 00 13 	mcall	80006318 <xQueueGenericSend+0xfc>
800062d0:	cb 41       	brne	80006238 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800062d2:	d7 33       	scall
800062d4:	cb 2b       	rjmp	80006238 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800062d6:	0e 9c       	mov	r12,r7
800062d8:	f0 1f 00 0f 	mcall	80006314 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800062dc:	f0 1f 00 0f 	mcall	80006318 <xQueueGenericSend+0xfc>
800062e0:	ca cb       	rjmp	80006238 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800062e2:	0e 9c       	mov	r12,r7
800062e4:	f0 1f 00 0c 	mcall	80006314 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800062e8:	f0 1f 00 0c 	mcall	80006318 <xQueueGenericSend+0xfc>
800062ec:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800062ee:	2f bd       	sub	sp,-20
800062f0:	d8 32       	popm	r0-r7,pc
800062f2:	00 00       	add	r0,r0
800062f4:	80 00       	ld.sh	r0,r0[0x0]
800062f6:	5c 5c       	castu.b	r12
800062f8:	80 00       	ld.sh	r0,r0[0x0]
800062fa:	61 54       	ld.w	r4,r0[0x54]
800062fc:	80 00       	ld.sh	r0,r0[0x0]
800062fe:	65 28       	ld.w	r8,r2[0x48]
80006300:	80 00       	ld.sh	r0,r0[0x0]
80006302:	5d 68       	*unknown*
80006304:	80 00       	ld.sh	r0,r0[0x0]
80006306:	64 1c       	ld.w	r12,r2[0x4]
80006308:	80 00       	ld.sh	r0,r0[0x0]
8000630a:	63 90       	ld.w	r0,r1[0x64]
8000630c:	80 00       	ld.sh	r0,r0[0x0]
8000630e:	66 b8       	ld.w	r8,r3[0x2c]
80006310:	80 00       	ld.sh	r0,r0[0x0]
80006312:	69 58       	ld.w	r8,r4[0x54]
80006314:	80 00       	ld.sh	r0,r0[0x0]
80006316:	5f 70       	srpl	r0
80006318:	80 00       	ld.sh	r0,r0[0x0]
8000631a:	67 4c       	ld.w	r12,r3[0x50]

8000631c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
8000631c:	d4 21       	pushm	r4-r7,lr
8000631e:	18 97       	mov	r7,r12
80006320:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006322:	58 0c       	cp.w	r12,0
80006324:	c2 f0       	breq	80006382 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006326:	34 cc       	mov	r12,76
80006328:	f0 1f 00 17 	mcall	80006384 <xQueueCreate+0x68>
8000632c:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000632e:	c2 a0       	breq	80006382 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006330:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006334:	e8 cc ff ff 	sub	r12,r4,-1
80006338:	f0 1f 00 13 	mcall	80006384 <xQueueCreate+0x68>
8000633c:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000633e:	c1 e0       	breq	8000637a <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006340:	f8 04 00 04 	add	r4,r12,r4
80006344:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006346:	30 08       	mov	r8,0
80006348:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000634a:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
8000634c:	ee c8 00 01 	sub	r8,r7,1
80006350:	ad 38       	mul	r8,r6
80006352:	10 0c       	add	r12,r8
80006354:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
80006356:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
80006358:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
8000635c:	3f f8       	mov	r8,-1
8000635e:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006362:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006366:	ea cc ff f0 	sub	r12,r5,-16
8000636a:	f0 1f 00 08 	mcall	80006388 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000636e:	ea cc ff dc 	sub	r12,r5,-36
80006372:	f0 1f 00 06 	mcall	80006388 <xQueueCreate+0x6c>
80006376:	0a 9c       	mov	r12,r5
80006378:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000637a:	0a 9c       	mov	r12,r5
8000637c:	f0 1f 00 04 	mcall	8000638c <xQueueCreate+0x70>
80006380:	d8 2a       	popm	r4-r7,pc,r12=0
80006382:	d8 2a       	popm	r4-r7,pc,r12=0
80006384:	80 00       	ld.sh	r0,r0[0x0]
80006386:	5e c8       	retvs	r8
80006388:	80 00       	ld.sh	r0,r0[0x0]
8000638a:	5b 38       	cp.w	r8,-13
8000638c:	80 00       	ld.sh	r0,r0[0x0]
8000638e:	5e a0       	retle	r0

80006390 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
80006390:	48 38       	lddpc	r8,8000639c <vTaskSuspendAll+0xc>
80006392:	70 09       	ld.w	r9,r8[0x0]
80006394:	2f f9       	sub	r9,-1
80006396:	91 09       	st.w	r8[0x0],r9
}
80006398:	5e fc       	retal	r12
8000639a:	00 00       	add	r0,r0
8000639c:	00 00       	add	r0,r0
8000639e:	0d 20       	ld.uh	r0,r6++

800063a0 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800063a0:	49 a8       	lddpc	r8,80006408 <vTaskSwitchContext+0x68>
800063a2:	70 08       	ld.w	r8,r8[0x0]
800063a4:	58 08       	cp.w	r8,0
800063a6:	c0 b1       	brne	800063bc <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800063a8:	49 98       	lddpc	r8,8000640c <vTaskSwitchContext+0x6c>
800063aa:	70 08       	ld.w	r8,r8[0x0]
800063ac:	f0 08 00 28 	add	r8,r8,r8<<0x2
800063b0:	49 89       	lddpc	r9,80006410 <vTaskSwitchContext+0x70>
800063b2:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800063b6:	58 08       	cp.w	r8,0
800063b8:	c0 60       	breq	800063c4 <vTaskSwitchContext+0x24>
800063ba:	c1 18       	rjmp	800063dc <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800063bc:	30 19       	mov	r9,1
800063be:	49 68       	lddpc	r8,80006414 <vTaskSwitchContext+0x74>
800063c0:	91 09       	st.w	r8[0x0],r9
800063c2:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800063c4:	49 28       	lddpc	r8,8000640c <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800063c6:	49 3a       	lddpc	r10,80006410 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800063c8:	70 09       	ld.w	r9,r8[0x0]
800063ca:	20 19       	sub	r9,1
800063cc:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800063ce:	70 09       	ld.w	r9,r8[0x0]
800063d0:	f2 09 00 29 	add	r9,r9,r9<<0x2
800063d4:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800063d8:	58 09       	cp.w	r9,0
800063da:	cf 70       	breq	800063c8 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800063dc:	48 c8       	lddpc	r8,8000640c <vTaskSwitchContext+0x6c>
800063de:	70 08       	ld.w	r8,r8[0x0]
800063e0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800063e4:	48 b9       	lddpc	r9,80006410 <vTaskSwitchContext+0x70>
800063e6:	f2 08 00 28 	add	r8,r9,r8<<0x2
800063ea:	70 19       	ld.w	r9,r8[0x4]
800063ec:	72 19       	ld.w	r9,r9[0x4]
800063ee:	91 19       	st.w	r8[0x4],r9
800063f0:	f0 ca ff f8 	sub	r10,r8,-8
800063f4:	14 39       	cp.w	r9,r10
800063f6:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800063fa:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800063fe:	70 18       	ld.w	r8,r8[0x4]
80006400:	70 39       	ld.w	r9,r8[0xc]
80006402:	48 68       	lddpc	r8,80006418 <vTaskSwitchContext+0x78>
80006404:	91 09       	st.w	r8[0x0],r9
80006406:	5e fc       	retal	r12
80006408:	00 00       	add	r0,r0
8000640a:	0d 20       	ld.uh	r0,r6++
8000640c:	00 00       	add	r0,r0
8000640e:	0d 58       	ld.sh	r8,--r6
80006410:	00 00       	add	r0,r0
80006412:	0c 3c       	cp.w	r12,r6
80006414:	00 00       	add	r0,r0
80006416:	0d 40       	ld.w	r0,--r6
80006418:	00 00       	add	r0,r0
8000641a:	0c f0       	st.b	--r6,r0

8000641c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
8000641c:	48 48       	lddpc	r8,8000642c <vTaskSetTimeOutState+0x10>
8000641e:	70 08       	ld.w	r8,r8[0x0]
80006420:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006422:	48 48       	lddpc	r8,80006430 <vTaskSetTimeOutState+0x14>
80006424:	70 08       	ld.w	r8,r8[0x0]
80006426:	99 18       	st.w	r12[0x4],r8
}
80006428:	5e fc       	retal	r12
8000642a:	00 00       	add	r0,r0
8000642c:	00 00       	add	r0,r0
8000642e:	0c 34       	cp.w	r4,r6
80006430:	00 00       	add	r0,r0
80006432:	0d 1c       	ld.sh	r12,r6++

80006434 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006434:	30 19       	mov	r9,1
80006436:	48 28       	lddpc	r8,8000643c <vTaskMissedYield+0x8>
80006438:	91 09       	st.w	r8[0x0],r9
}
8000643a:	5e fc       	retal	r12
8000643c:	00 00       	add	r0,r0
8000643e:	0d 40       	ld.w	r0,--r6

80006440 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006440:	48 28       	lddpc	r8,80006448 <xTaskGetCurrentTaskHandle+0x8>
80006442:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006444:	5e fc       	retal	r12
80006446:	00 00       	add	r0,r0
80006448:	00 00       	add	r0,r0
8000644a:	0c f0       	st.b	--r6,r0

8000644c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
8000644c:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006450:	58 0c       	cp.w	r12,0
80006452:	c1 f0       	breq	80006490 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006454:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
80006456:	78 b9       	ld.w	r9,r12[0x2c]
80006458:	79 18       	ld.w	r8,r12[0x44]
8000645a:	10 39       	cp.w	r9,r8
8000645c:	c1 a0       	breq	80006490 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
8000645e:	f8 c6 ff fc 	sub	r6,r12,-4
80006462:	0c 9c       	mov	r12,r6
80006464:	f0 1f 00 0c 	mcall	80006494 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
80006468:	6f 1c       	ld.w	r12,r7[0x44]
8000646a:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
8000646c:	f8 08 11 08 	rsub	r8,r12,8
80006470:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006472:	48 a8       	lddpc	r8,80006498 <vTaskPriorityDisinherit+0x4c>
80006474:	70 08       	ld.w	r8,r8[0x0]
80006476:	10 3c       	cp.w	r12,r8
80006478:	e0 88 00 04 	brls	80006480 <vTaskPriorityDisinherit+0x34>
8000647c:	48 78       	lddpc	r8,80006498 <vTaskPriorityDisinherit+0x4c>
8000647e:	91 0c       	st.w	r8[0x0],r12
80006480:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006484:	0c 9b       	mov	r11,r6
80006486:	48 68       	lddpc	r8,8000649c <vTaskPriorityDisinherit+0x50>
80006488:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000648c:	f0 1f 00 05 	mcall	800064a0 <vTaskPriorityDisinherit+0x54>
80006490:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006494:	80 00       	ld.sh	r0,r0[0x0]
80006496:	5b a2       	cp.w	r2,-6
80006498:	00 00       	add	r0,r0
8000649a:	0d 58       	ld.sh	r8,--r6
8000649c:	00 00       	add	r0,r0
8000649e:	0c 3c       	cp.w	r12,r6
800064a0:	80 00       	ld.sh	r0,r0[0x0]
800064a2:	5b 52       	cp.w	r2,-11

800064a4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800064a4:	eb cd 40 c0 	pushm	r6-r7,lr
800064a8:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800064aa:	49 b8       	lddpc	r8,80006514 <vTaskPriorityInherit+0x70>
800064ac:	70 08       	ld.w	r8,r8[0x0]
800064ae:	78 b9       	ld.w	r9,r12[0x2c]
800064b0:	70 b8       	ld.w	r8,r8[0x2c]
800064b2:	10 39       	cp.w	r9,r8
800064b4:	c2 d2       	brcc	8000650e <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800064b6:	49 88       	lddpc	r8,80006514 <vTaskPriorityInherit+0x70>
800064b8:	70 08       	ld.w	r8,r8[0x0]
800064ba:	70 b8       	ld.w	r8,r8[0x2c]
800064bc:	f0 08 11 08 	rsub	r8,r8,8
800064c0:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800064c2:	f2 09 00 28 	add	r8,r9,r9<<0x2
800064c6:	49 59       	lddpc	r9,80006518 <vTaskPriorityInherit+0x74>
800064c8:	f2 08 00 28 	add	r8,r9,r8<<0x2
800064cc:	78 59       	ld.w	r9,r12[0x14]
800064ce:	10 39       	cp.w	r9,r8
800064d0:	c1 b1       	brne	80006506 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800064d2:	f8 c6 ff fc 	sub	r6,r12,-4
800064d6:	0c 9c       	mov	r12,r6
800064d8:	f0 1f 00 11 	mcall	8000651c <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800064dc:	48 e8       	lddpc	r8,80006514 <vTaskPriorityInherit+0x70>
800064de:	70 08       	ld.w	r8,r8[0x0]
800064e0:	70 bc       	ld.w	r12,r8[0x2c]
800064e2:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800064e4:	48 f8       	lddpc	r8,80006520 <vTaskPriorityInherit+0x7c>
800064e6:	70 08       	ld.w	r8,r8[0x0]
800064e8:	10 3c       	cp.w	r12,r8
800064ea:	e0 88 00 04 	brls	800064f2 <vTaskPriorityInherit+0x4e>
800064ee:	48 d8       	lddpc	r8,80006520 <vTaskPriorityInherit+0x7c>
800064f0:	91 0c       	st.w	r8[0x0],r12
800064f2:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800064f6:	0c 9b       	mov	r11,r6
800064f8:	48 88       	lddpc	r8,80006518 <vTaskPriorityInherit+0x74>
800064fa:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800064fe:	f0 1f 00 0a 	mcall	80006524 <vTaskPriorityInherit+0x80>
80006502:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006506:	48 48       	lddpc	r8,80006514 <vTaskPriorityInherit+0x70>
80006508:	70 08       	ld.w	r8,r8[0x0]
8000650a:	70 b8       	ld.w	r8,r8[0x2c]
8000650c:	99 b8       	st.w	r12[0x2c],r8
8000650e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006512:	00 00       	add	r0,r0
80006514:	00 00       	add	r0,r0
80006516:	0c f0       	st.b	--r6,r0
80006518:	00 00       	add	r0,r0
8000651a:	0c 3c       	cp.w	r12,r6
8000651c:	80 00       	ld.sh	r0,r0[0x0]
8000651e:	5b a2       	cp.w	r2,-6
80006520:	00 00       	add	r0,r0
80006522:	0d 58       	ld.sh	r8,--r6
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	5b 52       	cp.w	r2,-11

80006528 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80006528:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
8000652c:	78 38       	ld.w	r8,r12[0xc]
8000652e:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006530:	ee c6 ff e8 	sub	r6,r7,-24
80006534:	0c 9c       	mov	r12,r6
80006536:	f0 1f 00 15 	mcall	80006588 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000653a:	49 58       	lddpc	r8,8000658c <xTaskRemoveFromEventList+0x64>
8000653c:	70 08       	ld.w	r8,r8[0x0]
8000653e:	58 08       	cp.w	r8,0
80006540:	c1 71       	brne	8000656e <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006542:	ee c6 ff fc 	sub	r6,r7,-4
80006546:	0c 9c       	mov	r12,r6
80006548:	f0 1f 00 10 	mcall	80006588 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
8000654c:	6e bc       	ld.w	r12,r7[0x2c]
8000654e:	49 18       	lddpc	r8,80006590 <xTaskRemoveFromEventList+0x68>
80006550:	70 08       	ld.w	r8,r8[0x0]
80006552:	10 3c       	cp.w	r12,r8
80006554:	e0 88 00 04 	brls	8000655c <xTaskRemoveFromEventList+0x34>
80006558:	48 e8       	lddpc	r8,80006590 <xTaskRemoveFromEventList+0x68>
8000655a:	91 0c       	st.w	r8[0x0],r12
8000655c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006560:	0c 9b       	mov	r11,r6
80006562:	48 d8       	lddpc	r8,80006594 <xTaskRemoveFromEventList+0x6c>
80006564:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006568:	f0 1f 00 0c 	mcall	80006598 <xTaskRemoveFromEventList+0x70>
8000656c:	c0 58       	rjmp	80006576 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
8000656e:	0c 9b       	mov	r11,r6
80006570:	48 bc       	lddpc	r12,8000659c <xTaskRemoveFromEventList+0x74>
80006572:	f0 1f 00 0a 	mcall	80006598 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006576:	48 b8       	lddpc	r8,800065a0 <xTaskRemoveFromEventList+0x78>
80006578:	70 08       	ld.w	r8,r8[0x0]
8000657a:	6e b9       	ld.w	r9,r7[0x2c]
8000657c:	70 b8       	ld.w	r8,r8[0x2c]
8000657e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006580:	5f 2c       	srhs	r12
80006582:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006586:	00 00       	add	r0,r0
80006588:	80 00       	ld.sh	r0,r0[0x0]
8000658a:	5b a2       	cp.w	r2,-6
8000658c:	00 00       	add	r0,r0
8000658e:	0d 20       	ld.uh	r0,r6++
80006590:	00 00       	add	r0,r0
80006592:	0d 58       	ld.sh	r8,--r6
80006594:	00 00       	add	r0,r0
80006596:	0c 3c       	cp.w	r12,r6
80006598:	80 00       	ld.sh	r0,r0[0x0]
8000659a:	5b 52       	cp.w	r2,-11
8000659c:	00 00       	add	r0,r0
8000659e:	0c f4       	st.b	--r6,r4
800065a0:	00 00       	add	r0,r0
800065a2:	0c f0       	st.b	--r6,r0

800065a4 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800065a4:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800065a8:	4b 98       	lddpc	r8,8000668c <vTaskIncrementTick+0xe8>
800065aa:	70 08       	ld.w	r8,r8[0x0]
800065ac:	58 08       	cp.w	r8,0
800065ae:	c6 91       	brne	80006680 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800065b0:	4b 88       	lddpc	r8,80006690 <vTaskIncrementTick+0xec>
800065b2:	70 09       	ld.w	r9,r8[0x0]
800065b4:	2f f9       	sub	r9,-1
800065b6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800065b8:	70 08       	ld.w	r8,r8[0x0]
800065ba:	58 08       	cp.w	r8,0
800065bc:	c1 a1       	brne	800065f0 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800065be:	4b 68       	lddpc	r8,80006694 <vTaskIncrementTick+0xf0>
800065c0:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800065c2:	4b 69       	lddpc	r9,80006698 <vTaskIncrementTick+0xf4>
800065c4:	72 0b       	ld.w	r11,r9[0x0]
800065c6:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800065c8:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800065ca:	4b 59       	lddpc	r9,8000669c <vTaskIncrementTick+0xf8>
800065cc:	72 0a       	ld.w	r10,r9[0x0]
800065ce:	2f fa       	sub	r10,-1
800065d0:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800065d2:	70 08       	ld.w	r8,r8[0x0]
800065d4:	70 08       	ld.w	r8,r8[0x0]
800065d6:	58 08       	cp.w	r8,0
800065d8:	c0 51       	brne	800065e2 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800065da:	3f f9       	mov	r9,-1
800065dc:	4b 18       	lddpc	r8,800066a0 <vTaskIncrementTick+0xfc>
800065de:	91 09       	st.w	r8[0x0],r9
800065e0:	c0 88       	rjmp	800065f0 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800065e2:	4a d8       	lddpc	r8,80006694 <vTaskIncrementTick+0xf0>
800065e4:	70 08       	ld.w	r8,r8[0x0]
800065e6:	70 38       	ld.w	r8,r8[0xc]
800065e8:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800065ea:	70 19       	ld.w	r9,r8[0x4]
800065ec:	4a d8       	lddpc	r8,800066a0 <vTaskIncrementTick+0xfc>
800065ee:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
800065f0:	4a 88       	lddpc	r8,80006690 <vTaskIncrementTick+0xec>
800065f2:	70 09       	ld.w	r9,r8[0x0]
800065f4:	4a b8       	lddpc	r8,800066a0 <vTaskIncrementTick+0xfc>
800065f6:	70 08       	ld.w	r8,r8[0x0]
800065f8:	10 39       	cp.w	r9,r8
800065fa:	c4 73       	brcs	80006688 <vTaskIncrementTick+0xe4>
800065fc:	4a 68       	lddpc	r8,80006694 <vTaskIncrementTick+0xf0>
800065fe:	70 08       	ld.w	r8,r8[0x0]
80006600:	70 08       	ld.w	r8,r8[0x0]
80006602:	58 08       	cp.w	r8,0
80006604:	c0 c0       	breq	8000661c <vTaskIncrementTick+0x78>
80006606:	4a 48       	lddpc	r8,80006694 <vTaskIncrementTick+0xf0>
80006608:	70 08       	ld.w	r8,r8[0x0]
8000660a:	70 38       	ld.w	r8,r8[0xc]
8000660c:	70 37       	ld.w	r7,r8[0xc]
8000660e:	6e 18       	ld.w	r8,r7[0x4]
80006610:	4a 09       	lddpc	r9,80006690 <vTaskIncrementTick+0xec>
80006612:	72 09       	ld.w	r9,r9[0x0]
80006614:	12 38       	cp.w	r8,r9
80006616:	e0 88 00 14 	brls	8000663e <vTaskIncrementTick+0x9a>
8000661a:	c0 e8       	rjmp	80006636 <vTaskIncrementTick+0x92>
8000661c:	3f f9       	mov	r9,-1
8000661e:	4a 18       	lddpc	r8,800066a0 <vTaskIncrementTick+0xfc>
80006620:	91 09       	st.w	r8[0x0],r9
80006622:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006626:	6a 08       	ld.w	r8,r5[0x0]
80006628:	70 38       	ld.w	r8,r8[0xc]
8000662a:	70 37       	ld.w	r7,r8[0xc]
8000662c:	6e 18       	ld.w	r8,r7[0x4]
8000662e:	64 09       	ld.w	r9,r2[0x0]
80006630:	12 38       	cp.w	r8,r9
80006632:	e0 88 00 0a 	brls	80006646 <vTaskIncrementTick+0xa2>
80006636:	49 b9       	lddpc	r9,800066a0 <vTaskIncrementTick+0xfc>
80006638:	93 08       	st.w	r9[0x0],r8
8000663a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000663e:	49 a4       	lddpc	r4,800066a4 <vTaskIncrementTick+0x100>
80006640:	49 a3       	lddpc	r3,800066a8 <vTaskIncrementTick+0x104>
80006642:	49 55       	lddpc	r5,80006694 <vTaskIncrementTick+0xf0>
80006644:	49 32       	lddpc	r2,80006690 <vTaskIncrementTick+0xec>
80006646:	ee c6 ff fc 	sub	r6,r7,-4
8000664a:	0c 9c       	mov	r12,r6
8000664c:	f0 1f 00 18 	mcall	800066ac <vTaskIncrementTick+0x108>
80006650:	6e a8       	ld.w	r8,r7[0x28]
80006652:	58 08       	cp.w	r8,0
80006654:	c0 50       	breq	8000665e <vTaskIncrementTick+0xba>
80006656:	ee cc ff e8 	sub	r12,r7,-24
8000665a:	f0 1f 00 15 	mcall	800066ac <vTaskIncrementTick+0x108>
8000665e:	6e bc       	ld.w	r12,r7[0x2c]
80006660:	68 08       	ld.w	r8,r4[0x0]
80006662:	10 3c       	cp.w	r12,r8
80006664:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006668:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000666c:	0c 9b       	mov	r11,r6
8000666e:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006672:	f0 1f 00 10 	mcall	800066b0 <vTaskIncrementTick+0x10c>
80006676:	6a 08       	ld.w	r8,r5[0x0]
80006678:	70 08       	ld.w	r8,r8[0x0]
8000667a:	58 08       	cp.w	r8,0
8000667c:	cd 51       	brne	80006626 <vTaskIncrementTick+0x82>
8000667e:	cc fb       	rjmp	8000661c <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006680:	48 d8       	lddpc	r8,800066b4 <vTaskIncrementTick+0x110>
80006682:	70 09       	ld.w	r9,r8[0x0]
80006684:	2f f9       	sub	r9,-1
80006686:	91 09       	st.w	r8[0x0],r9
80006688:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000668c:	00 00       	add	r0,r0
8000668e:	0d 20       	ld.uh	r0,r6++
80006690:	00 00       	add	r0,r0
80006692:	0d 1c       	ld.sh	r12,r6++
80006694:	00 00       	add	r0,r0
80006696:	0c 28       	rsub	r8,r6
80006698:	00 00       	add	r0,r0
8000669a:	0c 38       	cp.w	r8,r6
8000669c:	00 00       	add	r0,r0
8000669e:	0c 34       	cp.w	r4,r6
800066a0:	00 00       	add	r0,r0
800066a2:	05 38       	ld.ub	r8,r2++
800066a4:	00 00       	add	r0,r0
800066a6:	0d 58       	ld.sh	r8,--r6
800066a8:	00 00       	add	r0,r0
800066aa:	0c 3c       	cp.w	r12,r6
800066ac:	80 00       	ld.sh	r0,r0[0x0]
800066ae:	5b a2       	cp.w	r2,-6
800066b0:	80 00       	ld.sh	r0,r0[0x0]
800066b2:	5b 52       	cp.w	r2,-11
800066b4:	00 00       	add	r0,r0
800066b6:	0c 20       	rsub	r0,r6

800066b8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800066b8:	eb cd 40 c0 	pushm	r6-r7,lr
800066bc:	18 97       	mov	r7,r12
800066be:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800066c0:	f0 1f 00 15 	mcall	80006714 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800066c4:	6c 08       	ld.w	r8,r6[0x0]
800066c6:	5b f8       	cp.w	r8,-1
800066c8:	c0 31       	brne	800066ce <xTaskCheckForTimeOut+0x16>
800066ca:	30 07       	mov	r7,0
800066cc:	c1 f8       	rjmp	8000670a <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800066ce:	49 39       	lddpc	r9,80006718 <xTaskCheckForTimeOut+0x60>
800066d0:	72 09       	ld.w	r9,r9[0x0]
800066d2:	6e 0a       	ld.w	r10,r7[0x0]
800066d4:	12 3a       	cp.w	r10,r9
800066d6:	c0 70       	breq	800066e4 <xTaskCheckForTimeOut+0x2c>
800066d8:	49 19       	lddpc	r9,8000671c <xTaskCheckForTimeOut+0x64>
800066da:	72 09       	ld.w	r9,r9[0x0]
800066dc:	6e 1a       	ld.w	r10,r7[0x4]
800066de:	12 3a       	cp.w	r10,r9
800066e0:	e0 88 00 14 	brls	80006708 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800066e4:	48 e9       	lddpc	r9,8000671c <xTaskCheckForTimeOut+0x64>
800066e6:	72 0a       	ld.w	r10,r9[0x0]
800066e8:	6e 19       	ld.w	r9,r7[0x4]
800066ea:	12 1a       	sub	r10,r9
800066ec:	14 38       	cp.w	r8,r10
800066ee:	e0 88 00 0d 	brls	80006708 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
800066f2:	48 ba       	lddpc	r10,8000671c <xTaskCheckForTimeOut+0x64>
800066f4:	74 0a       	ld.w	r10,r10[0x0]
800066f6:	14 19       	sub	r9,r10
800066f8:	f2 08 00 08 	add	r8,r9,r8
800066fc:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
800066fe:	0e 9c       	mov	r12,r7
80006700:	f0 1f 00 08 	mcall	80006720 <xTaskCheckForTimeOut+0x68>
80006704:	30 07       	mov	r7,0
80006706:	c0 28       	rjmp	8000670a <xTaskCheckForTimeOut+0x52>
80006708:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000670a:	f0 1f 00 07 	mcall	80006724 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000670e:	0e 9c       	mov	r12,r7
80006710:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006714:	80 00       	ld.sh	r0,r0[0x0]
80006716:	5c 5c       	castu.b	r12
80006718:	00 00       	add	r0,r0
8000671a:	0c 34       	cp.w	r4,r6
8000671c:	00 00       	add	r0,r0
8000671e:	0d 1c       	ld.sh	r12,r6++
80006720:	80 00       	ld.sh	r0,r0[0x0]
80006722:	64 1c       	ld.w	r12,r2[0x4]
80006724:	80 00       	ld.sh	r0,r0[0x0]
80006726:	5d 68       	*unknown*

80006728 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006728:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
8000672c:	f0 1f 00 05 	mcall	80006740 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006730:	48 58       	lddpc	r8,80006744 <xTaskGetTickCount+0x1c>
80006732:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006734:	f0 1f 00 05 	mcall	80006748 <xTaskGetTickCount+0x20>

	return xTicks;
}
80006738:	0e 9c       	mov	r12,r7
8000673a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000673e:	00 00       	add	r0,r0
80006740:	80 00       	ld.sh	r0,r0[0x0]
80006742:	5c 5c       	castu.b	r12
80006744:	00 00       	add	r0,r0
80006746:	0d 1c       	ld.sh	r12,r6++
80006748:	80 00       	ld.sh	r0,r0[0x0]
8000674a:	5d 68       	*unknown*

8000674c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
8000674c:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006750:	f0 1f 00 2c 	mcall	80006800 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006754:	4a c8       	lddpc	r8,80006804 <xTaskResumeAll+0xb8>
80006756:	70 09       	ld.w	r9,r8[0x0]
80006758:	20 19       	sub	r9,1
8000675a:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000675c:	70 08       	ld.w	r8,r8[0x0]
8000675e:	58 08       	cp.w	r8,0
80006760:	c4 91       	brne	800067f2 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006762:	4a a8       	lddpc	r8,80006808 <xTaskResumeAll+0xbc>
80006764:	70 08       	ld.w	r8,r8[0x0]
80006766:	58 08       	cp.w	r8,0
80006768:	c4 50       	breq	800067f2 <xTaskResumeAll+0xa6>
8000676a:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000676c:	4a 85       	lddpc	r5,8000680c <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
8000676e:	4a 93       	lddpc	r3,80006810 <xTaskResumeAll+0xc4>
80006770:	4a 92       	lddpc	r2,80006814 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006772:	4a a1       	lddpc	r1,80006818 <xTaskResumeAll+0xcc>
80006774:	c1 e8       	rjmp	800067b0 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006776:	6a 38       	ld.w	r8,r5[0xc]
80006778:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
8000677a:	ee cc ff e8 	sub	r12,r7,-24
8000677e:	f0 1f 00 28 	mcall	8000681c <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006782:	ee c6 ff fc 	sub	r6,r7,-4
80006786:	0c 9c       	mov	r12,r6
80006788:	f0 1f 00 25 	mcall	8000681c <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
8000678c:	6e bc       	ld.w	r12,r7[0x2c]
8000678e:	66 08       	ld.w	r8,r3[0x0]
80006790:	10 3c       	cp.w	r12,r8
80006792:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006796:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000679a:	0c 9b       	mov	r11,r6
8000679c:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
800067a0:	f0 1f 00 20 	mcall	80006820 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800067a4:	62 08       	ld.w	r8,r1[0x0]
800067a6:	6e b9       	ld.w	r9,r7[0x2c]
800067a8:	70 b8       	ld.w	r8,r8[0x2c]
800067aa:	10 39       	cp.w	r9,r8
800067ac:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800067b0:	6a 08       	ld.w	r8,r5[0x0]
800067b2:	58 08       	cp.w	r8,0
800067b4:	ce 11       	brne	80006776 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067b6:	49 c8       	lddpc	r8,80006824 <xTaskResumeAll+0xd8>
800067b8:	70 08       	ld.w	r8,r8[0x0]
800067ba:	58 08       	cp.w	r8,0
800067bc:	c0 f0       	breq	800067da <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067be:	49 a8       	lddpc	r8,80006824 <xTaskResumeAll+0xd8>
800067c0:	70 08       	ld.w	r8,r8[0x0]
800067c2:	58 08       	cp.w	r8,0
800067c4:	c1 10       	breq	800067e6 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
800067c6:	49 87       	lddpc	r7,80006824 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
800067c8:	f0 1f 00 18 	mcall	80006828 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
800067cc:	6e 08       	ld.w	r8,r7[0x0]
800067ce:	20 18       	sub	r8,1
800067d0:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
800067d2:	6e 08       	ld.w	r8,r7[0x0]
800067d4:	58 08       	cp.w	r8,0
800067d6:	cf 91       	brne	800067c8 <xTaskResumeAll+0x7c>
800067d8:	c0 78       	rjmp	800067e6 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
800067da:	58 14       	cp.w	r4,1
800067dc:	c0 50       	breq	800067e6 <xTaskResumeAll+0x9a>
800067de:	49 48       	lddpc	r8,8000682c <xTaskResumeAll+0xe0>
800067e0:	70 08       	ld.w	r8,r8[0x0]
800067e2:	58 18       	cp.w	r8,1
800067e4:	c0 71       	brne	800067f2 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
800067e6:	30 09       	mov	r9,0
800067e8:	49 18       	lddpc	r8,8000682c <xTaskResumeAll+0xe0>
800067ea:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
800067ec:	d7 33       	scall
800067ee:	30 17       	mov	r7,1
800067f0:	c0 28       	rjmp	800067f4 <xTaskResumeAll+0xa8>
800067f2:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
800067f4:	f0 1f 00 0f 	mcall	80006830 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
800067f8:	0e 9c       	mov	r12,r7
800067fa:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800067fe:	00 00       	add	r0,r0
80006800:	80 00       	ld.sh	r0,r0[0x0]
80006802:	5c 5c       	castu.b	r12
80006804:	00 00       	add	r0,r0
80006806:	0d 20       	ld.uh	r0,r6++
80006808:	00 00       	add	r0,r0
8000680a:	0d 3c       	ld.ub	r12,r6++
8000680c:	00 00       	add	r0,r0
8000680e:	0c f4       	st.b	--r6,r4
80006810:	00 00       	add	r0,r0
80006812:	0d 58       	ld.sh	r8,--r6
80006814:	00 00       	add	r0,r0
80006816:	0c 3c       	cp.w	r12,r6
80006818:	00 00       	add	r0,r0
8000681a:	0c f0       	st.b	--r6,r0
8000681c:	80 00       	ld.sh	r0,r0[0x0]
8000681e:	5b a2       	cp.w	r2,-6
80006820:	80 00       	ld.sh	r0,r0[0x0]
80006822:	5b 52       	cp.w	r2,-11
80006824:	00 00       	add	r0,r0
80006826:	0c 20       	rsub	r0,r6
80006828:	80 00       	ld.sh	r0,r0[0x0]
8000682a:	65 a4       	ld.w	r4,r2[0x68]
8000682c:	00 00       	add	r0,r0
8000682e:	0d 40       	ld.w	r0,--r6
80006830:	80 00       	ld.sh	r0,r0[0x0]
80006832:	5d 68       	*unknown*

80006834 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006834:	eb cd 40 80 	pushm	r7,lr
80006838:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
8000683a:	49 08       	lddpc	r8,80006878 <prvAddCurrentTaskToDelayedList+0x44>
8000683c:	70 08       	ld.w	r8,r8[0x0]
8000683e:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006840:	48 f8       	lddpc	r8,8000687c <prvAddCurrentTaskToDelayedList+0x48>
80006842:	70 08       	ld.w	r8,r8[0x0]
80006844:	10 3c       	cp.w	r12,r8
80006846:	c0 a2       	brcc	8000685a <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006848:	48 c8       	lddpc	r8,80006878 <prvAddCurrentTaskToDelayedList+0x44>
8000684a:	70 0b       	ld.w	r11,r8[0x0]
8000684c:	48 d8       	lddpc	r8,80006880 <prvAddCurrentTaskToDelayedList+0x4c>
8000684e:	70 0c       	ld.w	r12,r8[0x0]
80006850:	2f cb       	sub	r11,-4
80006852:	f0 1f 00 0d 	mcall	80006884 <prvAddCurrentTaskToDelayedList+0x50>
80006856:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000685a:	48 88       	lddpc	r8,80006878 <prvAddCurrentTaskToDelayedList+0x44>
8000685c:	70 0b       	ld.w	r11,r8[0x0]
8000685e:	48 b8       	lddpc	r8,80006888 <prvAddCurrentTaskToDelayedList+0x54>
80006860:	70 0c       	ld.w	r12,r8[0x0]
80006862:	2f cb       	sub	r11,-4
80006864:	f0 1f 00 08 	mcall	80006884 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006868:	48 98       	lddpc	r8,8000688c <prvAddCurrentTaskToDelayedList+0x58>
8000686a:	70 08       	ld.w	r8,r8[0x0]
8000686c:	10 37       	cp.w	r7,r8
8000686e:	c0 32       	brcc	80006874 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006870:	48 78       	lddpc	r8,8000688c <prvAddCurrentTaskToDelayedList+0x58>
80006872:	91 07       	st.w	r8[0x0],r7
80006874:	e3 cd 80 80 	ldm	sp++,r7,pc
80006878:	00 00       	add	r0,r0
8000687a:	0c f0       	st.b	--r6,r0
8000687c:	00 00       	add	r0,r0
8000687e:	0d 1c       	ld.sh	r12,r6++
80006880:	00 00       	add	r0,r0
80006882:	0c 38       	cp.w	r8,r6
80006884:	80 00       	ld.sh	r0,r0[0x0]
80006886:	5b 6e       	cp.w	lr,-10
80006888:	00 00       	add	r0,r0
8000688a:	0c 28       	rsub	r8,r6
8000688c:	00 00       	add	r0,r0
8000688e:	05 38       	ld.ub	r8,r2++

80006890 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006890:	eb cd 40 c0 	pushm	r6-r7,lr
80006894:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006896:	58 0c       	cp.w	r12,0
80006898:	c1 10       	breq	800068ba <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
8000689a:	f0 1f 00 0a 	mcall	800068c0 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
8000689e:	48 a8       	lddpc	r8,800068c4 <vTaskDelay+0x34>
800068a0:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800068a2:	48 a8       	lddpc	r8,800068c8 <vTaskDelay+0x38>
800068a4:	70 0c       	ld.w	r12,r8[0x0]
800068a6:	2f cc       	sub	r12,-4
800068a8:	f0 1f 00 09 	mcall	800068cc <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
800068ac:	ee 06 00 0c 	add	r12,r7,r6
800068b0:	f0 1f 00 08 	mcall	800068d0 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
800068b4:	f0 1f 00 08 	mcall	800068d4 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
800068b8:	c0 21       	brne	800068bc <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
800068ba:	d7 33       	scall
800068bc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800068c0:	80 00       	ld.sh	r0,r0[0x0]
800068c2:	63 90       	ld.w	r0,r1[0x64]
800068c4:	00 00       	add	r0,r0
800068c6:	0d 1c       	ld.sh	r12,r6++
800068c8:	00 00       	add	r0,r0
800068ca:	0c f0       	st.b	--r6,r0
800068cc:	80 00       	ld.sh	r0,r0[0x0]
800068ce:	5b a2       	cp.w	r2,-6
800068d0:	80 00       	ld.sh	r0,r0[0x0]
800068d2:	68 34       	ld.w	r4,r4[0xc]
800068d4:	80 00       	ld.sh	r0,r0[0x0]
800068d6:	67 4c       	ld.w	r12,r3[0x50]

800068d8 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
800068d8:	eb cd 40 c0 	pushm	r6-r7,lr
800068dc:	18 96       	mov	r6,r12
800068de:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
800068e0:	f0 1f 00 18 	mcall	80006940 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
800068e4:	6c 08       	ld.w	r8,r6[0x0]
800068e6:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
800068e8:	49 79       	lddpc	r9,80006944 <vTaskDelayUntil+0x6c>
800068ea:	72 09       	ld.w	r9,r9[0x0]
800068ec:	12 38       	cp.w	r8,r9
800068ee:	e0 88 00 0c 	brls	80006906 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
800068f2:	0e 38       	cp.w	r8,r7
800068f4:	e0 88 00 22 	brls	80006938 <vTaskDelayUntil+0x60>
800068f8:	49 38       	lddpc	r8,80006944 <vTaskDelayUntil+0x6c>
800068fa:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800068fc:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
800068fe:	10 37       	cp.w	r7,r8
80006900:	e0 88 00 14 	brls	80006928 <vTaskDelayUntil+0x50>
80006904:	c0 a8       	rjmp	80006918 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006906:	0e 38       	cp.w	r8,r7
80006908:	e0 8b 00 16 	brhi	80006934 <vTaskDelayUntil+0x5c>
8000690c:	48 e8       	lddpc	r8,80006944 <vTaskDelayUntil+0x6c>
8000690e:	70 08       	ld.w	r8,r8[0x0]
80006910:	10 37       	cp.w	r7,r8
80006912:	e0 8b 00 11 	brhi	80006934 <vTaskDelayUntil+0x5c>
80006916:	c1 18       	rjmp	80006938 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006918:	48 c8       	lddpc	r8,80006948 <vTaskDelayUntil+0x70>
8000691a:	70 0c       	ld.w	r12,r8[0x0]
8000691c:	2f cc       	sub	r12,-4
8000691e:	f0 1f 00 0c 	mcall	8000694c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006922:	0e 9c       	mov	r12,r7
80006924:	f0 1f 00 0b 	mcall	80006950 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006928:	f0 1f 00 0b 	mcall	80006954 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
8000692c:	c0 81       	brne	8000693c <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000692e:	d7 33       	scall
80006930:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006934:	8d 07       	st.w	r6[0x0],r7
80006936:	cf 1b       	rjmp	80006918 <vTaskDelayUntil+0x40>
80006938:	8d 07       	st.w	r6[0x0],r7
8000693a:	cf 7b       	rjmp	80006928 <vTaskDelayUntil+0x50>
8000693c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006940:	80 00       	ld.sh	r0,r0[0x0]
80006942:	63 90       	ld.w	r0,r1[0x64]
80006944:	00 00       	add	r0,r0
80006946:	0d 1c       	ld.sh	r12,r6++
80006948:	00 00       	add	r0,r0
8000694a:	0c f0       	st.b	--r6,r0
8000694c:	80 00       	ld.sh	r0,r0[0x0]
8000694e:	5b a2       	cp.w	r2,-6
80006950:	80 00       	ld.sh	r0,r0[0x0]
80006952:	68 34       	ld.w	r4,r4[0xc]
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	67 4c       	ld.w	r12,r3[0x50]

80006958 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006958:	eb cd 40 c0 	pushm	r6-r7,lr
8000695c:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
8000695e:	48 e7       	lddpc	r7,80006994 <vTaskPlaceOnEventList+0x3c>
80006960:	6e 0b       	ld.w	r11,r7[0x0]
80006962:	2e 8b       	sub	r11,-24
80006964:	f0 1f 00 0d 	mcall	80006998 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006968:	6e 0c       	ld.w	r12,r7[0x0]
8000696a:	2f cc       	sub	r12,-4
8000696c:	f0 1f 00 0c 	mcall	8000699c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006970:	5b f6       	cp.w	r6,-1
80006972:	c0 81       	brne	80006982 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006974:	6e 0b       	ld.w	r11,r7[0x0]
80006976:	2f cb       	sub	r11,-4
80006978:	48 ac       	lddpc	r12,800069a0 <vTaskPlaceOnEventList+0x48>
8000697a:	f0 1f 00 0b 	mcall	800069a4 <vTaskPlaceOnEventList+0x4c>
8000697e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006982:	48 a8       	lddpc	r8,800069a8 <vTaskPlaceOnEventList+0x50>
80006984:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006986:	ec 0c 00 0c 	add	r12,r6,r12
8000698a:	f0 1f 00 09 	mcall	800069ac <vTaskPlaceOnEventList+0x54>
8000698e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006992:	00 00       	add	r0,r0
80006994:	00 00       	add	r0,r0
80006996:	0c f0       	st.b	--r6,r0
80006998:	80 00       	ld.sh	r0,r0[0x0]
8000699a:	5b 6e       	cp.w	lr,-10
8000699c:	80 00       	ld.sh	r0,r0[0x0]
8000699e:	5b a2       	cp.w	r2,-6
800069a0:	00 00       	add	r0,r0
800069a2:	0d 44       	ld.w	r4,--r6
800069a4:	80 00       	ld.sh	r0,r0[0x0]
800069a6:	5b 52       	cp.w	r2,-11
800069a8:	00 00       	add	r0,r0
800069aa:	0d 1c       	ld.sh	r12,r6++
800069ac:	80 00       	ld.sh	r0,r0[0x0]
800069ae:	68 34       	ld.w	r4,r4[0xc]

800069b0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
800069b0:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800069b4:	49 67       	lddpc	r7,80006a0c <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800069b6:	49 74       	lddpc	r4,80006a10 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
800069b8:	49 73       	lddpc	r3,80006a14 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800069ba:	49 85       	lddpc	r5,80006a18 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
800069bc:	6e 08       	ld.w	r8,r7[0x0]
800069be:	58 08       	cp.w	r8,0
800069c0:	c1 e0       	breq	800069fc <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
800069c2:	f0 1f 00 17 	mcall	80006a1c <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
800069c6:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
800069c8:	f0 1f 00 16 	mcall	80006a20 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
800069cc:	58 06       	cp.w	r6,0
800069ce:	c1 70       	breq	800069fc <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
800069d0:	f0 1f 00 15 	mcall	80006a24 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
800069d4:	68 38       	ld.w	r8,r4[0xc]
800069d6:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
800069d8:	ec cc ff fc 	sub	r12,r6,-4
800069dc:	f0 1f 00 13 	mcall	80006a28 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
800069e0:	66 08       	ld.w	r8,r3[0x0]
800069e2:	20 18       	sub	r8,1
800069e4:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800069e6:	6e 08       	ld.w	r8,r7[0x0]
800069e8:	20 18       	sub	r8,1
800069ea:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
800069ec:	f0 1f 00 10 	mcall	80006a2c <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
800069f0:	6c cc       	ld.w	r12,r6[0x30]
800069f2:	f0 1f 00 10 	mcall	80006a30 <prvIdleTask+0x80>
		vPortFree( pxTCB );
800069f6:	0c 9c       	mov	r12,r6
800069f8:	f0 1f 00 0e 	mcall	80006a30 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800069fc:	6a 08       	ld.w	r8,r5[0x0]
800069fe:	58 18       	cp.w	r8,1
80006a00:	e0 88 00 03 	brls	80006a06 <prvIdleTask+0x56>
			{
				taskYIELD();
80006a04:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006a06:	f0 1f 00 0c 	mcall	80006a34 <prvIdleTask+0x84>
		}
		#endif
	}
80006a0a:	cd 9b       	rjmp	800069bc <prvIdleTask+0xc>
80006a0c:	00 00       	add	r0,r0
80006a0e:	0c 30       	cp.w	r0,r6
80006a10:	00 00       	add	r0,r0
80006a12:	0c dc       	st.w	--r6,r12
80006a14:	00 00       	add	r0,r0
80006a16:	0d 3c       	ld.ub	r12,r6++
80006a18:	00 00       	add	r0,r0
80006a1a:	0c 3c       	cp.w	r12,r6
80006a1c:	80 00       	ld.sh	r0,r0[0x0]
80006a1e:	63 90       	ld.w	r0,r1[0x64]
80006a20:	80 00       	ld.sh	r0,r0[0x0]
80006a22:	67 4c       	ld.w	r12,r3[0x50]
80006a24:	80 00       	ld.sh	r0,r0[0x0]
80006a26:	5c 5c       	castu.b	r12
80006a28:	80 00       	ld.sh	r0,r0[0x0]
80006a2a:	5b a2       	cp.w	r2,-6
80006a2c:	80 00       	ld.sh	r0,r0[0x0]
80006a2e:	5d 68       	*unknown*
80006a30:	80 00       	ld.sh	r0,r0[0x0]
80006a32:	5e a0       	retle	r0
80006a34:	80 00       	ld.sh	r0,r0[0x0]
80006a36:	20 2c       	sub	r12,2

80006a38 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006a38:	d4 31       	pushm	r0-r7,lr
80006a3a:	20 1d       	sub	sp,4
80006a3c:	fa c4 ff d8 	sub	r4,sp,-40
80006a40:	50 0c       	stdsp	sp[0x0],r12
80006a42:	16 91       	mov	r1,r11
80006a44:	14 97       	mov	r7,r10
80006a46:	12 90       	mov	r0,r9
80006a48:	10 93       	mov	r3,r8
80006a4a:	68 02       	ld.w	r2,r4[0x0]
80006a4c:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006a4e:	34 8c       	mov	r12,72
80006a50:	f0 1f 00 5c 	mcall	80006bc0 <xTaskGenericCreate+0x188>
80006a54:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006a56:	c0 31       	brne	80006a5c <xTaskGenericCreate+0x24>
80006a58:	3f fc       	mov	r12,-1
80006a5a:	ca f8       	rjmp	80006bb8 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006a5c:	58 06       	cp.w	r6,0
80006a5e:	e0 81 00 af 	brne	80006bbc <xTaskGenericCreate+0x184>
80006a62:	0e 9c       	mov	r12,r7
80006a64:	5c 7c       	castu.h	r12
80006a66:	a3 6c       	lsl	r12,0x2
80006a68:	f0 1f 00 56 	mcall	80006bc0 <xTaskGenericCreate+0x188>
80006a6c:	18 96       	mov	r6,r12
80006a6e:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006a70:	c0 61       	brne	80006a7c <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006a72:	0a 9c       	mov	r12,r5
80006a74:	f0 1f 00 54 	mcall	80006bc4 <xTaskGenericCreate+0x18c>
80006a78:	3f fc       	mov	r12,-1
80006a7a:	c9 f8       	rjmp	80006bb8 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006a7c:	5c 77       	castu.h	r7
80006a7e:	ee 0a 15 02 	lsl	r10,r7,0x2
80006a82:	e0 6b 00 a5 	mov	r11,165
80006a86:	0c 9c       	mov	r12,r6
80006a88:	f0 1f 00 50 	mcall	80006bc8 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006a8c:	ee c6 00 01 	sub	r6,r7,1
80006a90:	6a c8       	ld.w	r8,r5[0x30]
80006a92:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006a96:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006a9a:	31 0a       	mov	r10,16
80006a9c:	02 9b       	mov	r11,r1
80006a9e:	ea cc ff cc 	sub	r12,r5,-52
80006aa2:	f0 1f 00 4b 	mcall	80006bcc <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006aa6:	30 08       	mov	r8,0
80006aa8:	eb 68 00 43 	st.b	r5[67],r8
80006aac:	58 73       	cp.w	r3,7
80006aae:	e6 07 17 80 	movls	r7,r3
80006ab2:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006ab6:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006ab8:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006abc:	ea c4 ff fc 	sub	r4,r5,-4
80006ac0:	08 9c       	mov	r12,r4
80006ac2:	f0 1f 00 44 	mcall	80006bd0 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006ac6:	ea cc ff e8 	sub	r12,r5,-24
80006aca:	f0 1f 00 42 	mcall	80006bd0 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006ace:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006ad0:	ee 07 11 08 	rsub	r7,r7,8
80006ad4:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006ad6:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006ad8:	00 9a       	mov	r10,r0
80006ada:	40 0b       	lddsp	r11,sp[0x0]
80006adc:	0c 9c       	mov	r12,r6
80006ade:	f0 1f 00 3e 	mcall	80006bd4 <xTaskGenericCreate+0x19c>
80006ae2:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006ae4:	58 02       	cp.w	r2,0
80006ae6:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006aea:	f0 1f 00 3c 	mcall	80006bd8 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006aee:	4b c8       	lddpc	r8,80006bdc <xTaskGenericCreate+0x1a4>
80006af0:	70 09       	ld.w	r9,r8[0x0]
80006af2:	2f f9       	sub	r9,-1
80006af4:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006af6:	4b b8       	lddpc	r8,80006be0 <xTaskGenericCreate+0x1a8>
80006af8:	70 08       	ld.w	r8,r8[0x0]
80006afa:	58 08       	cp.w	r8,0
80006afc:	c2 61       	brne	80006b48 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006afe:	4b 98       	lddpc	r8,80006be0 <xTaskGenericCreate+0x1a8>
80006b00:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006b02:	4b 78       	lddpc	r8,80006bdc <xTaskGenericCreate+0x1a4>
80006b04:	70 08       	ld.w	r8,r8[0x0]
80006b06:	58 18       	cp.w	r8,1
80006b08:	c2 b1       	brne	80006b5e <xTaskGenericCreate+0x126>
80006b0a:	4b 77       	lddpc	r7,80006be4 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006b0c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006b10:	0e 9c       	mov	r12,r7
80006b12:	f0 1f 00 36 	mcall	80006be8 <xTaskGenericCreate+0x1b0>
80006b16:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006b18:	0c 37       	cp.w	r7,r6
80006b1a:	cf b1       	brne	80006b10 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006b1c:	4b 47       	lddpc	r7,80006bec <xTaskGenericCreate+0x1b4>
80006b1e:	0e 9c       	mov	r12,r7
80006b20:	f0 1f 00 32 	mcall	80006be8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006b24:	4b 36       	lddpc	r6,80006bf0 <xTaskGenericCreate+0x1b8>
80006b26:	0c 9c       	mov	r12,r6
80006b28:	f0 1f 00 30 	mcall	80006be8 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006b2c:	4b 2c       	lddpc	r12,80006bf4 <xTaskGenericCreate+0x1bc>
80006b2e:	f0 1f 00 2f 	mcall	80006be8 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006b32:	4b 2c       	lddpc	r12,80006bf8 <xTaskGenericCreate+0x1c0>
80006b34:	f0 1f 00 2d 	mcall	80006be8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006b38:	4b 1c       	lddpc	r12,80006bfc <xTaskGenericCreate+0x1c4>
80006b3a:	f0 1f 00 2c 	mcall	80006be8 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006b3e:	4b 18       	lddpc	r8,80006c00 <xTaskGenericCreate+0x1c8>
80006b40:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006b42:	4b 18       	lddpc	r8,80006c04 <xTaskGenericCreate+0x1cc>
80006b44:	91 06       	st.w	r8[0x0],r6
80006b46:	c0 c8       	rjmp	80006b5e <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006b48:	4b 08       	lddpc	r8,80006c08 <xTaskGenericCreate+0x1d0>
80006b4a:	70 08       	ld.w	r8,r8[0x0]
80006b4c:	58 08       	cp.w	r8,0
80006b4e:	c0 81       	brne	80006b5e <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006b50:	4a 48       	lddpc	r8,80006be0 <xTaskGenericCreate+0x1a8>
80006b52:	70 08       	ld.w	r8,r8[0x0]
80006b54:	70 b8       	ld.w	r8,r8[0x2c]
80006b56:	10 33       	cp.w	r3,r8
80006b58:	c0 33       	brcs	80006b5e <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006b5a:	4a 28       	lddpc	r8,80006be0 <xTaskGenericCreate+0x1a8>
80006b5c:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006b5e:	6a b8       	ld.w	r8,r5[0x2c]
80006b60:	4a b9       	lddpc	r9,80006c0c <xTaskGenericCreate+0x1d4>
80006b62:	72 09       	ld.w	r9,r9[0x0]
80006b64:	12 38       	cp.w	r8,r9
80006b66:	e0 88 00 04 	brls	80006b6e <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006b6a:	4a 99       	lddpc	r9,80006c0c <xTaskGenericCreate+0x1d4>
80006b6c:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006b6e:	4a 98       	lddpc	r8,80006c10 <xTaskGenericCreate+0x1d8>
80006b70:	70 09       	ld.w	r9,r8[0x0]
80006b72:	2f f9       	sub	r9,-1
80006b74:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006b76:	6a b8       	ld.w	r8,r5[0x2c]
80006b78:	4a 79       	lddpc	r9,80006c14 <xTaskGenericCreate+0x1dc>
80006b7a:	72 09       	ld.w	r9,r9[0x0]
80006b7c:	12 38       	cp.w	r8,r9
80006b7e:	e0 88 00 04 	brls	80006b86 <xTaskGenericCreate+0x14e>
80006b82:	4a 59       	lddpc	r9,80006c14 <xTaskGenericCreate+0x1dc>
80006b84:	93 08       	st.w	r9[0x0],r8
80006b86:	6a bc       	ld.w	r12,r5[0x2c]
80006b88:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006b8c:	08 9b       	mov	r11,r4
80006b8e:	49 68       	lddpc	r8,80006be4 <xTaskGenericCreate+0x1ac>
80006b90:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006b94:	f0 1f 00 21 	mcall	80006c18 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006b98:	f0 1f 00 21 	mcall	80006c1c <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006b9c:	49 b8       	lddpc	r8,80006c08 <xTaskGenericCreate+0x1d0>
80006b9e:	70 08       	ld.w	r8,r8[0x0]
80006ba0:	58 08       	cp.w	r8,0
80006ba2:	c0 a0       	breq	80006bb6 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006ba4:	48 f8       	lddpc	r8,80006be0 <xTaskGenericCreate+0x1a8>
80006ba6:	70 08       	ld.w	r8,r8[0x0]
80006ba8:	70 b8       	ld.w	r8,r8[0x2c]
80006baa:	10 33       	cp.w	r3,r8
80006bac:	e0 88 00 05 	brls	80006bb6 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006bb0:	d7 33       	scall
80006bb2:	30 1c       	mov	r12,1
80006bb4:	c0 28       	rjmp	80006bb8 <xTaskGenericCreate+0x180>
80006bb6:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006bb8:	2f fd       	sub	sp,-4
80006bba:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006bbc:	99 c6       	st.w	r12[0x30],r6
80006bbe:	c5 fb       	rjmp	80006a7c <xTaskGenericCreate+0x44>
80006bc0:	80 00       	ld.sh	r0,r0[0x0]
80006bc2:	5e c8       	retvs	r8
80006bc4:	80 00       	ld.sh	r0,r0[0x0]
80006bc6:	5e a0       	retle	r0
80006bc8:	80 00       	ld.sh	r0,r0[0x0]
80006bca:	77 c0       	ld.w	r0,r11[0x70]
80006bcc:	80 00       	ld.sh	r0,r0[0x0]
80006bce:	7a ec       	ld.w	r12,sp[0x38]
80006bd0:	80 00       	ld.sh	r0,r0[0x0]
80006bd2:	5b 4c       	cp.w	r12,-12
80006bd4:	80 00       	ld.sh	r0,r0[0x0]
80006bd6:	5b c8       	cp.w	r8,-4
80006bd8:	80 00       	ld.sh	r0,r0[0x0]
80006bda:	5c 5c       	castu.b	r12
80006bdc:	00 00       	add	r0,r0
80006bde:	0d 3c       	ld.ub	r12,r6++
80006be0:	00 00       	add	r0,r0
80006be2:	0c f0       	st.b	--r6,r0
80006be4:	00 00       	add	r0,r0
80006be6:	0c 3c       	cp.w	r12,r6
80006be8:	80 00       	ld.sh	r0,r0[0x0]
80006bea:	5b 38       	cp.w	r8,-13
80006bec:	00 00       	add	r0,r0
80006bee:	0d 08       	ld.w	r8,r6++
80006bf0:	00 00       	add	r0,r0
80006bf2:	0d 24       	ld.uh	r4,r6++
80006bf4:	00 00       	add	r0,r0
80006bf6:	0c f4       	st.b	--r6,r4
80006bf8:	00 00       	add	r0,r0
80006bfa:	0c dc       	st.w	--r6,r12
80006bfc:	00 00       	add	r0,r0
80006bfe:	0d 44       	ld.w	r4,--r6
80006c00:	00 00       	add	r0,r0
80006c02:	0c 28       	rsub	r8,r6
80006c04:	00 00       	add	r0,r0
80006c06:	0c 38       	cp.w	r8,r6
80006c08:	00 00       	add	r0,r0
80006c0a:	0c 2c       	rsub	r12,r6
80006c0c:	00 00       	add	r0,r0
80006c0e:	0c 24       	rsub	r4,r6
80006c10:	00 00       	add	r0,r0
80006c12:	0d 38       	ld.ub	r8,r6++
80006c14:	00 00       	add	r0,r0
80006c16:	0d 58       	ld.sh	r8,--r6
80006c18:	80 00       	ld.sh	r0,r0[0x0]
80006c1a:	5b 52       	cp.w	r2,-11
80006c1c:	80 00       	ld.sh	r0,r0[0x0]
80006c1e:	5d 68       	*unknown*

80006c20 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006c20:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006c22:	30 09       	mov	r9,0
80006c24:	1a d9       	st.w	--sp,r9
80006c26:	1a d9       	st.w	--sp,r9
80006c28:	1a d9       	st.w	--sp,r9
80006c2a:	12 98       	mov	r8,r9
80006c2c:	e0 6a 01 00 	mov	r10,256
80006c30:	48 9b       	lddpc	r11,80006c54 <vTaskStartScheduler+0x34>
80006c32:	48 ac       	lddpc	r12,80006c58 <vTaskStartScheduler+0x38>
80006c34:	f0 1f 00 0a 	mcall	80006c5c <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006c38:	2f dd       	sub	sp,-12
80006c3a:	58 1c       	cp.w	r12,1
80006c3c:	c0 a1       	brne	80006c50 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006c3e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006c40:	30 19       	mov	r9,1
80006c42:	48 88       	lddpc	r8,80006c60 <vTaskStartScheduler+0x40>
80006c44:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006c46:	30 09       	mov	r9,0
80006c48:	48 78       	lddpc	r8,80006c64 <vTaskStartScheduler+0x44>
80006c4a:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006c4c:	f0 1f 00 07 	mcall	80006c68 <vTaskStartScheduler+0x48>
80006c50:	d8 02       	popm	pc
80006c52:	00 00       	add	r0,r0
80006c54:	80 00       	ld.sh	r0,r0[0x0]
80006c56:	d7 e0       	acall	0x7e
80006c58:	80 00       	ld.sh	r0,r0[0x0]
80006c5a:	69 b0       	ld.w	r0,r4[0x6c]
80006c5c:	80 00       	ld.sh	r0,r0[0x0]
80006c5e:	6a 38       	ld.w	r8,r5[0xc]
80006c60:	00 00       	add	r0,r0
80006c62:	0c 2c       	rsub	r12,r6
80006c64:	00 00       	add	r0,r0
80006c66:	0d 1c       	ld.sh	r12,r6++
80006c68:	80 00       	ld.sh	r0,r0[0x0]
80006c6a:	5c 6c       	casts.b	r12

80006c6c <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006c6c:	16 cc       	st.b	r11++,r12
	return str;
}
80006c6e:	5e fb       	retal	r11

80006c70 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006c70:	eb cd 40 c0 	pushm	r6-r7,lr
80006c74:	20 3d       	sub	sp,12
80006c76:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006c78:	30 06       	mov	r6,0
80006c7a:	30 07       	mov	r7,0
80006c7c:	fa e7 00 00 	st.d	sp[0],r6
80006c80:	30 0c       	mov	r12,0
80006c82:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006c84:	58 08       	cp.w	r8,0
80006c86:	c1 30       	breq	80006cac <PrintHex+0x3c>
80006c88:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006c8a:	1a 9c       	mov	r12,sp
80006c8c:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c90:	58 9e       	cp.w	lr,9
80006c92:	e0 8a 00 04 	brle	80006c9a <PrintHex+0x2a>
80006c96:	2c 9e       	sub	lr,-55
80006c98:	c0 48       	rjmp	80006ca0 <PrintHex+0x30>
80006c9a:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006c9e:	2d 0e       	sub	lr,-48
80006ca0:	f8 09 0b 0e 	st.b	r12[r9],lr
80006ca4:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006ca6:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006ca8:	cf 21       	brne	80006c8c <PrintHex+0x1c>
80006caa:	c0 48       	rjmp	80006cb2 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006cac:	33 08       	mov	r8,48
80006cae:	ba 88       	st.b	sp[0x0],r8
80006cb0:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006cb2:	f6 09 01 08 	sub	r8,r11,r9
80006cb6:	58 08       	cp.w	r8,0
80006cb8:	e0 8a 00 13 	brle	80006cde <PrintHex+0x6e>
	{
		char num = len - cnt;
80006cbc:	12 1b       	sub	r11,r9
80006cbe:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006cc2:	18 9e       	mov	lr,r12
80006cc4:	58 0c       	cp.w	r12,0
80006cc6:	e0 8a 00 0c 	brle	80006cde <PrintHex+0x6e>
80006cca:	1a 9b       	mov	r11,sp
80006ccc:	12 0b       	add	r11,r9
80006cce:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006cd0:	33 07       	mov	r7,48
80006cd2:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006cd4:	2f f8       	sub	r8,-1
80006cd6:	1c 38       	cp.w	r8,lr
80006cd8:	cf d5       	brlt	80006cd2 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006cda:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006cde:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006ce2:	f0 cb ff ff 	sub	r11,r8,-1
80006ce6:	58 0b       	cp.w	r11,0
80006ce8:	e0 8a 00 19 	brle	80006d1a <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006cec:	fa cb ff f4 	sub	r11,sp,-12
80006cf0:	f6 09 00 09 	add	r9,r11,r9
80006cf4:	37 8b       	mov	r11,120
80006cf6:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80006cfa:	fa c9 ff f4 	sub	r9,sp,-12
80006cfe:	10 09       	add	r9,r8
80006d00:	33 0b       	mov	r11,48
80006d02:	f3 6b ff f4 	st.b	r9[-12],r11
80006d06:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006d0a:	fa ce 00 01 	sub	lr,sp,1
80006d0e:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80006d10:	11 8b       	ld.ub	r11,r8[0x0]
80006d12:	12 cb       	st.b	r9++,r11
80006d14:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80006d16:	1c 38       	cp.w	r8,lr
80006d18:	cf c1       	brne	80006d10 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80006d1a:	14 9c       	mov	r12,r10
80006d1c:	2f dd       	sub	sp,-12
80006d1e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80006d22 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80006d22:	d4 21       	pushm	r4-r7,lr
80006d24:	20 3d       	sub	sp,12
80006d26:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80006d28:	30 06       	mov	r6,0
80006d2a:	30 07       	mov	r7,0
80006d2c:	fa e7 00 00 	st.d	sp[0],r6
80006d30:	30 0c       	mov	r12,0
80006d32:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80006d34:	58 08       	cp.w	r8,0
80006d36:	c0 35       	brlt	80006d3c <PrintDec+0x1a>
80006d38:	14 97       	mov	r7,r10
80006d3a:	c0 58       	rjmp	80006d44 <PrintDec+0x22>
	{
		*p++ = '-';
80006d3c:	14 97       	mov	r7,r10
80006d3e:	32 d9       	mov	r9,45
80006d40:	0e c9       	st.b	r7++,r9
		i = -i;
80006d42:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80006d44:	58 08       	cp.w	r8,0
80006d46:	c0 51       	brne	80006d50 <PrintDec+0x2e>
80006d48:	33 08       	mov	r8,48
80006d4a:	ba 88       	st.b	sp[0x0],r8
80006d4c:	30 1e       	mov	lr,1
80006d4e:	c2 f8       	rjmp	80006dac <PrintDec+0x8a>
	
	int ten = i%10;
80006d50:	e0 65 66 67 	mov	r5,26215
80006d54:	ea 15 66 66 	orh	r5,0x6666
80006d58:	f0 05 04 44 	muls.d	r4,r8,r5
80006d5c:	ea 0c 14 02 	asr	r12,r5,0x2
80006d60:	f0 09 14 1f 	asr	r9,r8,0x1f
80006d64:	f8 09 01 09 	sub	r9,r12,r9
80006d68:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006d6c:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80006d70:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80006d72:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80006d74:	e0 66 66 67 	mov	r6,26215
80006d78:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80006d7c:	2d 09       	sub	r9,-48
80006d7e:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80006d82:	2f fe       	sub	lr,-1
		i /= 10;
80006d84:	f0 06 04 44 	muls.d	r4,r8,r6
80006d88:	ea 09 14 02 	asr	r9,r5,0x2
80006d8c:	bf 58       	asr	r8,0x1f
80006d8e:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80006d92:	f0 06 04 44 	muls.d	r4,r8,r6
80006d96:	ea 09 14 02 	asr	r9,r5,0x2
80006d9a:	f0 05 14 1f 	asr	r5,r8,0x1f
80006d9e:	0a 19       	sub	r9,r5
80006da0:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006da4:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80006da8:	58 08       	cp.w	r8,0
80006daa:	ce 91       	brne	80006d7c <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80006dac:	f6 0e 01 08 	sub	r8,r11,lr
80006db0:	58 08       	cp.w	r8,0
80006db2:	e0 89 00 06 	brgt	80006dbe <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006db6:	58 0e       	cp.w	lr,0
80006db8:	e0 89 00 14 	brgt	80006de0 <PrintDec+0xbe>
80006dbc:	c1 d8       	rjmp	80006df6 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80006dbe:	1c 1b       	sub	r11,lr
80006dc0:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80006dc2:	16 9c       	mov	r12,r11
80006dc4:	58 0b       	cp.w	r11,0
80006dc6:	fe 9a ff f8 	brle	80006db6 <PrintDec+0x94>
80006dca:	1a 99       	mov	r9,sp
80006dcc:	1c 09       	add	r9,lr
80006dce:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006dd0:	33 06       	mov	r6,48
80006dd2:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006dd4:	2f f8       	sub	r8,-1
80006dd6:	18 38       	cp.w	r8,r12
80006dd8:	cf d5       	brlt	80006dd2 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80006dda:	f6 0e 00 0e 	add	lr,r11,lr
80006dde:	ce cb       	rjmp	80006db6 <PrintDec+0x94>
80006de0:	fa c8 ff f4 	sub	r8,sp,-12
80006de4:	1c 08       	add	r8,lr
80006de6:	20 d8       	sub	r8,13
80006de8:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80006dec:	11 89       	ld.ub	r9,r8[0x0]
80006dee:	0e c9       	st.b	r7++,r9
80006df0:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80006df2:	16 38       	cp.w	r8,r11
80006df4:	cf c1       	brne	80006dec <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80006df6:	14 9c       	mov	r12,r10
80006df8:	2f dd       	sub	sp,-12
80006dfa:	d8 22       	popm	r4-r7,pc

80006dfc <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80006dfc:	d4 31       	pushm	r0-r7,lr
80006dfe:	fa cd 02 08 	sub	sp,sp,520
80006e02:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80006e04:	e0 6a 01 00 	mov	r10,256
80006e08:	30 0b       	mov	r11,0
80006e0a:	fa cc fe f8 	sub	r12,sp,-264
80006e0e:	f0 1f 00 4e 	mcall	80006f44 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80006e12:	fa c4 fd d4 	sub	r4,sp,-556
80006e16:	30 0a       	mov	r10,0
80006e18:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006e1a:	fa c3 ff fc 	sub	r3,sp,-4
80006e1e:	e0 61 01 00 	mov	r1,256
80006e22:	14 90       	mov	r0,r10
			
					if(*str == '%')
80006e24:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006e26:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006e2a:	02 9a       	mov	r10,r1
80006e2c:	00 9b       	mov	r11,r0
80006e2e:	06 9c       	mov	r12,r3
80006e30:	f0 1f 00 45 	mcall	80006f44 <log+0x148>
			
					if(*str == '%')
80006e34:	0f 88       	ld.ub	r8,r7[0x0]
80006e36:	e4 08 18 00 	cp.b	r8,r2
80006e3a:	c5 71       	brne	80006ee8 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80006e3c:	ee c8 ff ff 	sub	r8,r7,-1
80006e40:	11 89       	ld.ub	r9,r8[0x0]
80006e42:	4c 2a       	lddpc	r10,80006f48 <log+0x14c>
80006e44:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80006e46:	23 09       	sub	r9,48
80006e48:	30 9a       	mov	r10,9
80006e4a:	f4 09 18 00 	cp.b	r9,r10
80006e4e:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80006e52:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006e56:	f7 b9 08 30 	subls	r9,48
80006e5a:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80006e5e:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80006e62:	0f 88       	ld.ub	r8,r7[0x0]
80006e64:	22 58       	sub	r8,37
80006e66:	e0 48 00 53 	cp.w	r8,83
80006e6a:	e0 8b 00 31 	brhi	80006ecc <log+0xd0>
80006e6e:	4b 89       	lddpc	r9,80006f4c <log+0x150>
80006e70:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80006e74:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80006e78:	06 9a       	mov	r10,r3
80006e7a:	40 0b       	lddsp	r11,sp[0x0]
80006e7c:	5c 5b       	castu.b	r11
80006e7e:	68 0c       	ld.w	r12,r4[0x0]
80006e80:	f0 1f 00 34 	mcall	80006f50 <log+0x154>
							break;
80006e84:	c2 98       	rjmp	80006ed6 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80006e86:	4b 4c       	lddpc	r12,80006f54 <log+0x158>
80006e88:	f0 1f 00 34 	mcall	80006f58 <log+0x15c>
80006e8c:	08 95       	mov	r5,r4
80006e8e:	06 9c       	mov	r12,r3
							break;
80006e90:	c2 38       	rjmp	80006ed6 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80006e92:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80006e96:	06 9a       	mov	r10,r3
80006e98:	40 0b       	lddsp	r11,sp[0x0]
80006e9a:	5c 5b       	castu.b	r11
80006e9c:	68 0c       	ld.w	r12,r4[0x0]
80006e9e:	f0 1f 00 30 	mcall	80006f5c <log+0x160>
80006ea2:	06 9c       	mov	r12,r3
							break;
80006ea4:	c1 98       	rjmp	80006ed6 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80006ea6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80006eaa:	06 9b       	mov	r11,r3
80006eac:	09 bc       	ld.ub	r12,r4[0x3]
80006eae:	f0 1f 00 2d 	mcall	80006f60 <log+0x164>
80006eb2:	06 9c       	mov	r12,r3
							break;
80006eb4:	c1 18       	rjmp	80006ed6 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80006eb6:	e8 c5 ff fc 	sub	r5,r4,-4
80006eba:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80006ebc:	c0 d8       	rjmp	80006ed6 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80006ebe:	06 9b       	mov	r11,r3
80006ec0:	32 5c       	mov	r12,37
80006ec2:	f0 1f 00 28 	mcall	80006f60 <log+0x164>
80006ec6:	08 95       	mov	r5,r4
80006ec8:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80006eca:	c0 68       	rjmp	80006ed6 <log+0xda>
							
							default:
							log("I need relax.");
80006ecc:	4a 6c       	lddpc	r12,80006f64 <log+0x168>
80006ece:	f0 1f 00 23 	mcall	80006f58 <log+0x15c>
80006ed2:	08 95       	mov	r5,r4
80006ed4:	06 9c       	mov	r12,r3
						}
						str++;
80006ed6:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80006ed8:	1a dc       	st.w	--sp,r12
80006eda:	1a d6       	st.w	--sp,r6
80006edc:	4a 3b       	lddpc	r11,80006f68 <log+0x16c>
80006ede:	0c 9c       	mov	r12,r6
80006ee0:	f0 1f 00 23 	mcall	80006f6c <log+0x170>
80006ee4:	2f ed       	sub	sp,-8
80006ee6:	c0 a8       	rjmp	80006efa <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006ee8:	2f f7       	sub	r7,-1
80006eea:	1a d8       	st.w	--sp,r8
80006eec:	1a d6       	st.w	--sp,r6
80006eee:	4a 1b       	lddpc	r11,80006f70 <log+0x174>
80006ef0:	0c 9c       	mov	r12,r6
80006ef2:	f0 1f 00 1f 	mcall	80006f6c <log+0x170>
80006ef6:	08 95       	mov	r5,r4
80006ef8:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80006efa:	0f 89       	ld.ub	r9,r7[0x0]
80006efc:	30 08       	mov	r8,0
80006efe:	f0 09 18 00 	cp.b	r9,r8
80006f02:	c0 30       	breq	80006f08 <log+0x10c>
80006f04:	0a 94       	mov	r4,r5
80006f06:	c9 2b       	rjmp	80006e2a <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80006f08:	fa c7 fe f8 	sub	r7,sp,-264
80006f0c:	1a d7       	st.w	--sp,r7
80006f0e:	49 ab       	lddpc	r11,80006f74 <log+0x178>
80006f10:	0e 9c       	mov	r12,r7
80006f12:	f0 1f 00 17 	mcall	80006f6c <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80006f16:	5c 5c       	castu.b	r12
80006f18:	f8 c6 ff ff 	sub	r6,r12,-1
80006f1c:	0c 9c       	mov	r12,r6
80006f1e:	f0 1f 00 17 	mcall	80006f78 <log+0x17c>
80006f22:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80006f24:	0c 9a       	mov	r10,r6
80006f26:	0e 9b       	mov	r11,r7
80006f28:	f0 1f 00 15 	mcall	80006f7c <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80006f2c:	30 09       	mov	r9,0
80006f2e:	30 5a       	mov	r10,5
80006f30:	fa cb fe f8 	sub	r11,sp,-264
80006f34:	49 38       	lddpc	r8,80006f80 <log+0x184>
80006f36:	70 0c       	ld.w	r12,r8[0x0]
80006f38:	f0 1f 00 13 	mcall	80006f84 <log+0x188>
80006f3c:	2f fd       	sub	sp,-4
	
	
}
80006f3e:	fe 3d fd f8 	sub	sp,-520
80006f42:	d8 32       	popm	r0-r7,pc
80006f44:	80 00       	ld.sh	r0,r0[0x0]
80006f46:	77 c0       	ld.w	r0,r11[0x70]
80006f48:	00 00       	add	r0,r0
80006f4a:	0d 5c       	ld.sh	r12,--r6
80006f4c:	80 00       	ld.sh	r0,r0[0x0]
80006f4e:	d7 e8       	*unknown*
80006f50:	80 00       	ld.sh	r0,r0[0x0]
80006f52:	6d 22       	ld.w	r2,r6[0x48]
80006f54:	80 00       	ld.sh	r0,r0[0x0]
80006f56:	da 94       	*unknown*
80006f58:	80 00       	ld.sh	r0,r0[0x0]
80006f5a:	6d fc       	ld.w	r12,r6[0x7c]
80006f5c:	80 00       	ld.sh	r0,r0[0x0]
80006f5e:	6c 70       	ld.w	r0,r6[0x1c]
80006f60:	80 00       	ld.sh	r0,r0[0x0]
80006f62:	6c 6c       	ld.w	r12,r6[0x18]
80006f64:	80 00       	ld.sh	r0,r0[0x0]
80006f66:	da a4       	*unknown*
80006f68:	80 00       	ld.sh	r0,r0[0x0]
80006f6a:	da b4       	*unknown*
80006f6c:	80 00       	ld.sh	r0,r0[0x0]
80006f6e:	7a b0       	ld.w	r0,sp[0x2c]
80006f70:	80 00       	ld.sh	r0,r0[0x0]
80006f72:	da bc       	*unknown*
80006f74:	80 00       	ld.sh	r0,r0[0x0]
80006f76:	da c4       	*unknown*
80006f78:	80 00       	ld.sh	r0,r0[0x0]
80006f7a:	5e c8       	retvs	r8
80006f7c:	80 00       	ld.sh	r0,r0[0x0]
80006f7e:	76 78       	ld.w	r8,r11[0x1c]
80006f80:	00 00       	add	r0,r0
80006f82:	5b 68       	cp.w	r8,-10
80006f84:	80 00       	ld.sh	r0,r0[0x0]
80006f86:	62 1c       	ld.w	r12,r1[0x4]

80006f88 <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
80006f88:	d4 31       	pushm	r0-r7,lr
80006f8a:	fa cd 02 0c 	sub	sp,sp,524
80006f8e:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80006f90:	e0 6a 01 00 	mov	r10,256
80006f94:	30 0b       	mov	r11,0
80006f96:	fa cc fe f4 	sub	r12,sp,-268
80006f9a:	f0 1f 00 4c 	mcall	800070c8 <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80006f9e:	fa c4 fd d0 	sub	r4,sp,-560
80006fa2:	30 0a       	mov	r10,0
80006fa4:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006fa6:	fa c3 ff fc 	sub	r3,sp,-4
80006faa:	e0 61 01 00 	mov	r1,256
80006fae:	14 90       	mov	r0,r10
			
			if(*str == '%')
80006fb0:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80006fb2:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80006fb6:	02 9a       	mov	r10,r1
80006fb8:	00 9b       	mov	r11,r0
80006fba:	06 9c       	mov	r12,r3
80006fbc:	f0 1f 00 43 	mcall	800070c8 <logFromISR+0x140>
			
			if(*str == '%')
80006fc0:	0f 88       	ld.ub	r8,r7[0x0]
80006fc2:	e4 08 18 00 	cp.b	r8,r2
80006fc6:	c5 11       	brne	80007068 <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
80006fc8:	ee c8 ff ff 	sub	r8,r7,-1
80006fcc:	11 89       	ld.ub	r9,r8[0x0]
80006fce:	4c 0a       	lddpc	r10,800070cc <logFromISR+0x144>
80006fd0:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80006fd2:	23 09       	sub	r9,48
80006fd4:	30 9a       	mov	r10,9
80006fd6:	f4 09 18 00 	cp.b	r9,r10
80006fda:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80006fde:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80006fe2:	f7 b9 08 30 	subls	r9,48
80006fe6:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
80006fea:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80006fee:	0f 88       	ld.ub	r8,r7[0x0]
80006ff0:	22 58       	sub	r8,37
80006ff2:	e0 48 00 53 	cp.w	r8,83
80006ff6:	e0 8b 00 2b 	brhi	8000704c <logFromISR+0xc4>
80006ffa:	4b 69       	lddpc	r9,800070d0 <logFromISR+0x148>
80006ffc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007000:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007004:	06 9a       	mov	r10,r3
80007006:	40 0b       	lddsp	r11,sp[0x0]
80007008:	5c 5b       	castu.b	r11
8000700a:	68 0c       	ld.w	r12,r4[0x0]
8000700c:	f0 1f 00 32 	mcall	800070d4 <logFromISR+0x14c>
					break;
80007010:	c2 38       	rjmp	80007056 <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007012:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
80007016:	06 9a       	mov	r10,r3
80007018:	40 0b       	lddsp	r11,sp[0x0]
8000701a:	5c 5b       	castu.b	r11
8000701c:	68 0c       	ld.w	r12,r4[0x0]
8000701e:	f0 1f 00 2f 	mcall	800070d8 <logFromISR+0x150>
80007022:	06 9c       	mov	r12,r3
					break;
80007024:	c1 98       	rjmp	80007056 <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
80007026:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000702a:	06 9b       	mov	r11,r3
8000702c:	09 bc       	ld.ub	r12,r4[0x3]
8000702e:	f0 1f 00 2c 	mcall	800070dc <logFromISR+0x154>
80007032:	06 9c       	mov	r12,r3
					break;
80007034:	c1 18       	rjmp	80007056 <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
80007036:	e8 c5 ff fc 	sub	r5,r4,-4
8000703a:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
8000703c:	c0 d8       	rjmp	80007056 <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
8000703e:	06 9b       	mov	r11,r3
80007040:	32 5c       	mov	r12,37
80007042:	f0 1f 00 27 	mcall	800070dc <logFromISR+0x154>
80007046:	08 95       	mov	r5,r4
80007048:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000704a:	c0 68       	rjmp	80007056 <logFromISR+0xce>
					default:
					log("I need relax.");
8000704c:	4a 5c       	lddpc	r12,800070e0 <logFromISR+0x158>
8000704e:	f0 1f 00 26 	mcall	800070e4 <logFromISR+0x15c>
80007052:	08 95       	mov	r5,r4
80007054:	06 9c       	mov	r12,r3
				}
				str++;
80007056:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80007058:	1a dc       	st.w	--sp,r12
8000705a:	1a d6       	st.w	--sp,r6
8000705c:	4a 3b       	lddpc	r11,800070e8 <logFromISR+0x160>
8000705e:	0c 9c       	mov	r12,r6
80007060:	f0 1f 00 23 	mcall	800070ec <logFromISR+0x164>
80007064:	2f ed       	sub	sp,-8
80007066:	c0 a8       	rjmp	8000707a <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007068:	2f f7       	sub	r7,-1
8000706a:	1a d8       	st.w	--sp,r8
8000706c:	1a d6       	st.w	--sp,r6
8000706e:	4a 1b       	lddpc	r11,800070f0 <logFromISR+0x168>
80007070:	0c 9c       	mov	r12,r6
80007072:	f0 1f 00 1f 	mcall	800070ec <logFromISR+0x164>
80007076:	08 95       	mov	r5,r4
80007078:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000707a:	0f 89       	ld.ub	r9,r7[0x0]
8000707c:	30 08       	mov	r8,0
8000707e:	f0 09 18 00 	cp.b	r9,r8
80007082:	c0 30       	breq	80007088 <logFromISR+0x100>
80007084:	0a 94       	mov	r4,r5
80007086:	c9 8b       	rjmp	80006fb6 <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
80007088:	fa c7 fe f4 	sub	r7,sp,-268
8000708c:	1a d7       	st.w	--sp,r7
8000708e:	49 ab       	lddpc	r11,800070f4 <logFromISR+0x16c>
80007090:	0e 9c       	mov	r12,r7
80007092:	f0 1f 00 17 	mcall	800070ec <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
80007096:	5c 5c       	castu.b	r12
80007098:	f8 c6 ff ff 	sub	r6,r12,-1
8000709c:	0c 9c       	mov	r12,r6
8000709e:	f0 1f 00 17 	mcall	800070f8 <logFromISR+0x170>
800070a2:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800070a4:	0c 9a       	mov	r10,r6
800070a6:	0e 9b       	mov	r11,r7
800070a8:	f0 1f 00 15 	mcall	800070fc <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800070ac:	30 09       	mov	r9,0
800070ae:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800070b0:	fa ca fe f8 	sub	r10,sp,-264
800070b4:	fa cb fe f4 	sub	r11,sp,-268
800070b8:	49 28       	lddpc	r8,80007100 <logFromISR+0x178>
800070ba:	70 0c       	ld.w	r12,r8[0x0]
800070bc:	f0 1f 00 12 	mcall	80007104 <logFromISR+0x17c>
800070c0:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800070c2:	fe 3d fd f4 	sub	sp,-524
800070c6:	d8 32       	popm	r0-r7,pc
800070c8:	80 00       	ld.sh	r0,r0[0x0]
800070ca:	77 c0       	ld.w	r0,r11[0x70]
800070cc:	00 00       	add	r0,r0
800070ce:	0d 5d       	ld.sh	sp,--r6
800070d0:	80 00       	ld.sh	r0,r0[0x0]
800070d2:	d9 38       	*unknown*
800070d4:	80 00       	ld.sh	r0,r0[0x0]
800070d6:	6d 22       	ld.w	r2,r6[0x48]
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	6c 70       	ld.w	r0,r6[0x1c]
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	6c 6c       	ld.w	r12,r6[0x18]
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	da a4       	*unknown*
800070e4:	80 00       	ld.sh	r0,r0[0x0]
800070e6:	6d fc       	ld.w	r12,r6[0x7c]
800070e8:	80 00       	ld.sh	r0,r0[0x0]
800070ea:	da b4       	*unknown*
800070ec:	80 00       	ld.sh	r0,r0[0x0]
800070ee:	7a b0       	ld.w	r0,sp[0x2c]
800070f0:	80 00       	ld.sh	r0,r0[0x0]
800070f2:	da bc       	*unknown*
800070f4:	80 00       	ld.sh	r0,r0[0x0]
800070f6:	da c4       	*unknown*
800070f8:	80 00       	ld.sh	r0,r0[0x0]
800070fa:	5e c8       	retvs	r8
800070fc:	80 00       	ld.sh	r0,r0[0x0]
800070fe:	76 78       	ld.w	r8,r11[0x1c]
80007100:	00 00       	add	r0,r0
80007102:	5b 68       	cp.w	r8,-10
80007104:	80 00       	ld.sh	r0,r0[0x0]
80007106:	61 cc       	ld.w	r12,r0[0x70]

80007108 <log_init>:
		
	return str;
}

void log_init(void)
{
80007108:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000710a:	30 2b       	mov	r11,2
8000710c:	48 fc       	lddpc	r12,80007148 <log_init+0x40>
8000710e:	f0 1f 00 10 	mcall	8000714c <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007112:	e0 6a 36 00 	mov	r10,13824
80007116:	ea 1a 01 6e 	orh	r10,0x16e
8000711a:	48 eb       	lddpc	r11,80007150 <log_init+0x48>
8000711c:	fe 7c 18 00 	mov	r12,-59392
80007120:	f0 1f 00 0d 	mcall	80007154 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007124:	30 4b       	mov	r11,4
80007126:	33 2c       	mov	r12,50
80007128:	f0 1f 00 0c 	mcall	80007158 <log_init+0x50>
8000712c:	48 c8       	lddpc	r8,8000715c <log_init+0x54>
8000712e:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007130:	30 09       	mov	r9,0
80007132:	1a d9       	st.w	--sp,r9
80007134:	1a d9       	st.w	--sp,r9
80007136:	1a d9       	st.w	--sp,r9
80007138:	30 28       	mov	r8,2
8000713a:	36 4a       	mov	r10,100
8000713c:	48 9b       	lddpc	r11,80007160 <log_init+0x58>
8000713e:	48 ac       	lddpc	r12,80007164 <log_init+0x5c>
80007140:	f0 1f 00 0a 	mcall	80007168 <log_init+0x60>
80007144:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80007146:	d8 02       	popm	pc
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	da d0       	acall	0xad
8000714c:	80 00       	ld.sh	r0,r0[0x0]
8000714e:	53 a8       	stdsp	sp[0xe8],r8
80007150:	80 00       	ld.sh	r0,r0[0x0]
80007152:	da 88       	*unknown*
80007154:	80 00       	ld.sh	r0,r0[0x0]
80007156:	5a 2c       	cp.w	r12,-30
80007158:	80 00       	ld.sh	r0,r0[0x0]
8000715a:	63 1c       	ld.w	r12,r1[0x44]
8000715c:	00 00       	add	r0,r0
8000715e:	5b 68       	cp.w	r8,-10
80007160:	80 00       	ld.sh	r0,r0[0x0]
80007162:	da cc       	*unknown*
80007164:	80 00       	ld.sh	r0,r0[0x0]
80007166:	71 6c       	ld.w	r12,r8[0x58]
80007168:	80 00       	ld.sh	r0,r0[0x0]
8000716a:	6a 38       	ld.w	r8,r5[0xc]

8000716c <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
8000716c:	eb cd 40 f8 	pushm	r3-r7,lr
80007170:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007172:	48 c7       	lddpc	r7,800071a0 <task_log+0x34>
80007174:	30 05       	mov	r5,0
80007176:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80007178:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
8000717c:	0a 99       	mov	r9,r5
8000717e:	08 9a       	mov	r10,r4
80007180:	1a 9b       	mov	r11,sp
80007182:	6e 0c       	ld.w	r12,r7[0x0]
80007184:	f0 1f 00 08 	mcall	800071a4 <task_log+0x38>
80007188:	58 1c       	cp.w	r12,1
8000718a:	cf 91       	brne	8000717c <task_log+0x10>
		{
			if( NULL != str)
8000718c:	40 0b       	lddsp	r11,sp[0x0]
8000718e:	58 0b       	cp.w	r11,0
80007190:	cf 60       	breq	8000717c <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007192:	06 9c       	mov	r12,r3
80007194:	f0 1f 00 05 	mcall	800071a8 <task_log+0x3c>
				vPortFree(str);
80007198:	40 0c       	lddsp	r12,sp[0x0]
8000719a:	f0 1f 00 05 	mcall	800071ac <task_log+0x40>
8000719e:	ce fb       	rjmp	8000717c <task_log+0x10>
800071a0:	00 00       	add	r0,r0
800071a2:	5b 68       	cp.w	r8,-10
800071a4:	80 00       	ld.sh	r0,r0[0x0]
800071a6:	60 10       	ld.w	r0,r0[0x4]
800071a8:	80 00       	ld.sh	r0,r0[0x0]
800071aa:	59 dc       	cp.w	r12,29
800071ac:	80 00       	ld.sh	r0,r0[0x0]
800071ae:	5e a0       	retle	r0

800071b0 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800071b0:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800071b2:	fe 78 10 00 	mov	r8,-61440
800071b6:	30 19       	mov	r9,1
800071b8:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800071bc:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800071c0:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800071c4:	d3 03       	ssrf	0x10
	local_start_pll0();
800071c6:	f0 1f 00 0c 	mcall	800071f4 <main+0x44>
		
	INTC_init_interrupts();
800071ca:	f0 1f 00 0c 	mcall	800071f8 <main+0x48>
		
	log_init();
800071ce:	f0 1f 00 0c 	mcall	800071fc <main+0x4c>
	log("----start debug----");
800071d2:	48 cc       	lddpc	r12,80007200 <main+0x50>
800071d4:	f0 1f 00 0c 	mcall	80007204 <main+0x54>
	
	xg_flashc_init();
800071d8:	f0 1f 00 0c 	mcall	80007208 <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
800071dc:	f0 1f 00 0c 	mcall	8000720c <main+0x5c>
		
	app_init();
800071e0:	f0 1f 00 0c 	mcall	80007210 <main+0x60>
	
	//xg_rtc_init();
		
	xcmp_init();
800071e4:	f0 1f 00 0c 	mcall	80007214 <main+0x64>

	local_start_timer();
800071e8:	f0 1f 00 0c 	mcall	80007218 <main+0x68>
		
	vTaskStartScheduler();
800071ec:	f0 1f 00 0c 	mcall	8000721c <main+0x6c>
	return 0;
	
}
800071f0:	d8 0a       	popm	pc,r12=0
800071f2:	00 00       	add	r0,r0
800071f4:	80 00       	ld.sh	r0,r0[0x0]
800071f6:	52 28       	stdsp	sp[0x88],r8
800071f8:	80 00       	ld.sh	r0,r0[0x0]
800071fa:	54 ac       	stdsp	sp[0x128],r12
800071fc:	80 00       	ld.sh	r0,r0[0x0]
800071fe:	71 08       	ld.w	r8,r8[0x40]
80007200:	80 00       	ld.sh	r0,r0[0x0]
80007202:	da e0       	acall	0xae
80007204:	80 00       	ld.sh	r0,r0[0x0]
80007206:	6d fc       	ld.w	r12,r6[0x7c]
80007208:	80 00       	ld.sh	r0,r0[0x0]
8000720a:	52 bc       	stdsp	sp[0xac],r12
8000720c:	80 00       	ld.sh	r0,r0[0x0]
8000720e:	51 88       	stdsp	sp[0x60],r8
80007210:	80 00       	ld.sh	r0,r0[0x0]
80007212:	20 3c       	sub	r12,3
80007214:	80 00       	ld.sh	r0,r0[0x0]
80007216:	3f e8       	mov	r8,-2
80007218:	80 00       	ld.sh	r0,r0[0x0]
8000721a:	51 fc       	stdsp	sp[0x7c],r12
8000721c:	80 00       	ld.sh	r0,r0[0x0]
8000721e:	6c 20       	ld.w	r0,r6[0x8]

80007220 <free>:
80007220:	d4 01       	pushm	lr
80007222:	e0 68 0a 3c 	mov	r8,2620
80007226:	18 9b       	mov	r11,r12
80007228:	70 0c       	ld.w	r12,r8[0x0]
8000722a:	e0 a0 1e 61 	rcall	8000aeec <_free_r>
8000722e:	d8 02       	popm	pc

80007230 <malloc>:
80007230:	d4 01       	pushm	lr
80007232:	e0 68 0a 3c 	mov	r8,2620
80007236:	18 9b       	mov	r11,r12
80007238:	70 0c       	ld.w	r12,r8[0x0]
8000723a:	c0 3c       	rcall	80007240 <_malloc_r>
8000723c:	d8 02       	popm	pc
8000723e:	d7 03       	nop

80007240 <_malloc_r>:
80007240:	d4 31       	pushm	r0-r7,lr
80007242:	f6 c8 ff f5 	sub	r8,r11,-11
80007246:	18 95       	mov	r5,r12
80007248:	10 97       	mov	r7,r8
8000724a:	e0 17 ff f8 	andl	r7,0xfff8
8000724e:	59 68       	cp.w	r8,22
80007250:	f9 b7 08 10 	movls	r7,16
80007254:	16 37       	cp.w	r7,r11
80007256:	5f 38       	srlo	r8
80007258:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000725c:	c0 50       	breq	80007266 <_malloc_r+0x26>
8000725e:	30 c8       	mov	r8,12
80007260:	99 38       	st.w	r12[0xc],r8
80007262:	e0 8f 01 fa 	bral	80007656 <_malloc_r+0x416>
80007266:	fe b0 f5 d3 	rcall	80005e0c <__malloc_lock>
8000726a:	e0 47 01 f7 	cp.w	r7,503
8000726e:	e0 8b 00 1d 	brhi	800072a8 <_malloc_r+0x68>
80007272:	ee 03 16 03 	lsr	r3,r7,0x3
80007276:	e0 68 05 3c 	mov	r8,1340
8000727a:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000727e:	70 36       	ld.w	r6,r8[0xc]
80007280:	10 36       	cp.w	r6,r8
80007282:	c0 61       	brne	8000728e <_malloc_r+0x4e>
80007284:	ec c8 ff f8 	sub	r8,r6,-8
80007288:	70 36       	ld.w	r6,r8[0xc]
8000728a:	10 36       	cp.w	r6,r8
8000728c:	c0 c0       	breq	800072a4 <_malloc_r+0x64>
8000728e:	6c 18       	ld.w	r8,r6[0x4]
80007290:	e0 18 ff fc 	andl	r8,0xfffc
80007294:	6c 3a       	ld.w	r10,r6[0xc]
80007296:	ec 08 00 09 	add	r9,r6,r8
8000729a:	0a 9c       	mov	r12,r5
8000729c:	6c 28       	ld.w	r8,r6[0x8]
8000729e:	95 28       	st.w	r10[0x8],r8
800072a0:	91 3a       	st.w	r8[0xc],r10
800072a2:	c4 78       	rjmp	80007330 <_malloc_r+0xf0>
800072a4:	2f e3       	sub	r3,-2
800072a6:	c4 d8       	rjmp	80007340 <_malloc_r+0x100>
800072a8:	ee 03 16 09 	lsr	r3,r7,0x9
800072ac:	c0 41       	brne	800072b4 <_malloc_r+0x74>
800072ae:	ee 03 16 03 	lsr	r3,r7,0x3
800072b2:	c2 68       	rjmp	800072fe <_malloc_r+0xbe>
800072b4:	58 43       	cp.w	r3,4
800072b6:	e0 8b 00 06 	brhi	800072c2 <_malloc_r+0x82>
800072ba:	ee 03 16 06 	lsr	r3,r7,0x6
800072be:	2c 83       	sub	r3,-56
800072c0:	c1 f8       	rjmp	800072fe <_malloc_r+0xbe>
800072c2:	59 43       	cp.w	r3,20
800072c4:	e0 8b 00 04 	brhi	800072cc <_malloc_r+0x8c>
800072c8:	2a 53       	sub	r3,-91
800072ca:	c1 a8       	rjmp	800072fe <_malloc_r+0xbe>
800072cc:	e0 43 00 54 	cp.w	r3,84
800072d0:	e0 8b 00 06 	brhi	800072dc <_malloc_r+0x9c>
800072d4:	ee 03 16 0c 	lsr	r3,r7,0xc
800072d8:	29 23       	sub	r3,-110
800072da:	c1 28       	rjmp	800072fe <_malloc_r+0xbe>
800072dc:	e0 43 01 54 	cp.w	r3,340
800072e0:	e0 8b 00 06 	brhi	800072ec <_malloc_r+0xac>
800072e4:	ee 03 16 0f 	lsr	r3,r7,0xf
800072e8:	28 93       	sub	r3,-119
800072ea:	c0 a8       	rjmp	800072fe <_malloc_r+0xbe>
800072ec:	e0 43 05 54 	cp.w	r3,1364
800072f0:	e0 88 00 04 	brls	800072f8 <_malloc_r+0xb8>
800072f4:	37 e3       	mov	r3,126
800072f6:	c0 48       	rjmp	800072fe <_malloc_r+0xbe>
800072f8:	ee 03 16 12 	lsr	r3,r7,0x12
800072fc:	28 43       	sub	r3,-124
800072fe:	e0 6a 05 3c 	mov	r10,1340
80007302:	f4 03 00 3a 	add	r10,r10,r3<<0x3
80007306:	74 36       	ld.w	r6,r10[0xc]
80007308:	c1 98       	rjmp	8000733a <_malloc_r+0xfa>
8000730a:	6c 19       	ld.w	r9,r6[0x4]
8000730c:	e0 19 ff fc 	andl	r9,0xfffc
80007310:	f2 07 01 0b 	sub	r11,r9,r7
80007314:	58 fb       	cp.w	r11,15
80007316:	e0 8a 00 04 	brle	8000731e <_malloc_r+0xde>
8000731a:	20 13       	sub	r3,1
8000731c:	c1 18       	rjmp	8000733e <_malloc_r+0xfe>
8000731e:	6c 38       	ld.w	r8,r6[0xc]
80007320:	58 0b       	cp.w	r11,0
80007322:	c0 b5       	brlt	80007338 <_malloc_r+0xf8>
80007324:	6c 2a       	ld.w	r10,r6[0x8]
80007326:	ec 09 00 09 	add	r9,r6,r9
8000732a:	0a 9c       	mov	r12,r5
8000732c:	91 2a       	st.w	r8[0x8],r10
8000732e:	95 38       	st.w	r10[0xc],r8
80007330:	72 18       	ld.w	r8,r9[0x4]
80007332:	a1 a8       	sbr	r8,0x0
80007334:	93 18       	st.w	r9[0x4],r8
80007336:	cb c8       	rjmp	800074ae <_malloc_r+0x26e>
80007338:	10 96       	mov	r6,r8
8000733a:	14 36       	cp.w	r6,r10
8000733c:	ce 71       	brne	8000730a <_malloc_r+0xca>
8000733e:	2f f3       	sub	r3,-1
80007340:	e0 6a 05 3c 	mov	r10,1340
80007344:	f4 cc ff f8 	sub	r12,r10,-8
80007348:	78 26       	ld.w	r6,r12[0x8]
8000734a:	18 36       	cp.w	r6,r12
8000734c:	c6 c0       	breq	80007424 <_malloc_r+0x1e4>
8000734e:	6c 19       	ld.w	r9,r6[0x4]
80007350:	e0 19 ff fc 	andl	r9,0xfffc
80007354:	f2 07 01 08 	sub	r8,r9,r7
80007358:	58 f8       	cp.w	r8,15
8000735a:	e0 89 00 8f 	brgt	80007478 <_malloc_r+0x238>
8000735e:	99 3c       	st.w	r12[0xc],r12
80007360:	99 2c       	st.w	r12[0x8],r12
80007362:	58 08       	cp.w	r8,0
80007364:	c0 55       	brlt	8000736e <_malloc_r+0x12e>
80007366:	ec 09 00 09 	add	r9,r6,r9
8000736a:	0a 9c       	mov	r12,r5
8000736c:	ce 2b       	rjmp	80007330 <_malloc_r+0xf0>
8000736e:	e0 49 01 ff 	cp.w	r9,511
80007372:	e0 8b 00 13 	brhi	80007398 <_malloc_r+0x158>
80007376:	a3 99       	lsr	r9,0x3
80007378:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000737c:	70 2b       	ld.w	r11,r8[0x8]
8000737e:	8d 38       	st.w	r6[0xc],r8
80007380:	8d 2b       	st.w	r6[0x8],r11
80007382:	97 36       	st.w	r11[0xc],r6
80007384:	91 26       	st.w	r8[0x8],r6
80007386:	a3 49       	asr	r9,0x2
80007388:	74 18       	ld.w	r8,r10[0x4]
8000738a:	30 1b       	mov	r11,1
8000738c:	f6 09 09 49 	lsl	r9,r11,r9
80007390:	f1 e9 10 09 	or	r9,r8,r9
80007394:	95 19       	st.w	r10[0x4],r9
80007396:	c4 78       	rjmp	80007424 <_malloc_r+0x1e4>
80007398:	f2 0a 16 09 	lsr	r10,r9,0x9
8000739c:	58 4a       	cp.w	r10,4
8000739e:	e0 8b 00 07 	brhi	800073ac <_malloc_r+0x16c>
800073a2:	f2 0a 16 06 	lsr	r10,r9,0x6
800073a6:	2c 8a       	sub	r10,-56
800073a8:	c2 08       	rjmp	800073e8 <_malloc_r+0x1a8>
800073aa:	d7 03       	nop
800073ac:	59 4a       	cp.w	r10,20
800073ae:	e0 8b 00 04 	brhi	800073b6 <_malloc_r+0x176>
800073b2:	2a 5a       	sub	r10,-91
800073b4:	c1 a8       	rjmp	800073e8 <_malloc_r+0x1a8>
800073b6:	e0 4a 00 54 	cp.w	r10,84
800073ba:	e0 8b 00 06 	brhi	800073c6 <_malloc_r+0x186>
800073be:	f2 0a 16 0c 	lsr	r10,r9,0xc
800073c2:	29 2a       	sub	r10,-110
800073c4:	c1 28       	rjmp	800073e8 <_malloc_r+0x1a8>
800073c6:	e0 4a 01 54 	cp.w	r10,340
800073ca:	e0 8b 00 06 	brhi	800073d6 <_malloc_r+0x196>
800073ce:	f2 0a 16 0f 	lsr	r10,r9,0xf
800073d2:	28 9a       	sub	r10,-119
800073d4:	c0 a8       	rjmp	800073e8 <_malloc_r+0x1a8>
800073d6:	e0 4a 05 54 	cp.w	r10,1364
800073da:	e0 88 00 04 	brls	800073e2 <_malloc_r+0x1a2>
800073de:	37 ea       	mov	r10,126
800073e0:	c0 48       	rjmp	800073e8 <_malloc_r+0x1a8>
800073e2:	f2 0a 16 12 	lsr	r10,r9,0x12
800073e6:	28 4a       	sub	r10,-124
800073e8:	e0 6b 05 3c 	mov	r11,1340
800073ec:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800073f0:	68 28       	ld.w	r8,r4[0x8]
800073f2:	08 38       	cp.w	r8,r4
800073f4:	c0 e1       	brne	80007410 <_malloc_r+0x1d0>
800073f6:	76 19       	ld.w	r9,r11[0x4]
800073f8:	a3 4a       	asr	r10,0x2
800073fa:	30 1e       	mov	lr,1
800073fc:	fc 0a 09 4a 	lsl	r10,lr,r10
80007400:	f3 ea 10 0a 	or	r10,r9,r10
80007404:	10 99       	mov	r9,r8
80007406:	97 1a       	st.w	r11[0x4],r10
80007408:	c0 a8       	rjmp	8000741c <_malloc_r+0x1dc>
8000740a:	70 28       	ld.w	r8,r8[0x8]
8000740c:	08 38       	cp.w	r8,r4
8000740e:	c0 60       	breq	8000741a <_malloc_r+0x1da>
80007410:	70 1a       	ld.w	r10,r8[0x4]
80007412:	e0 1a ff fc 	andl	r10,0xfffc
80007416:	14 39       	cp.w	r9,r10
80007418:	cf 93       	brcs	8000740a <_malloc_r+0x1ca>
8000741a:	70 39       	ld.w	r9,r8[0xc]
8000741c:	8d 39       	st.w	r6[0xc],r9
8000741e:	8d 28       	st.w	r6[0x8],r8
80007420:	91 36       	st.w	r8[0xc],r6
80007422:	93 26       	st.w	r9[0x8],r6
80007424:	e6 08 14 02 	asr	r8,r3,0x2
80007428:	30 1b       	mov	r11,1
8000742a:	e0 64 05 3c 	mov	r4,1340
8000742e:	f6 08 09 4b 	lsl	r11,r11,r8
80007432:	68 18       	ld.w	r8,r4[0x4]
80007434:	10 3b       	cp.w	r11,r8
80007436:	e0 8b 00 6b 	brhi	8000750c <_malloc_r+0x2cc>
8000743a:	f7 e8 00 09 	and	r9,r11,r8
8000743e:	c0 b1       	brne	80007454 <_malloc_r+0x214>
80007440:	e0 13 ff fc 	andl	r3,0xfffc
80007444:	a1 7b       	lsl	r11,0x1
80007446:	2f c3       	sub	r3,-4
80007448:	c0 38       	rjmp	8000744e <_malloc_r+0x20e>
8000744a:	2f c3       	sub	r3,-4
8000744c:	a1 7b       	lsl	r11,0x1
8000744e:	f7 e8 00 09 	and	r9,r11,r8
80007452:	cf c0       	breq	8000744a <_malloc_r+0x20a>
80007454:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80007458:	06 92       	mov	r2,r3
8000745a:	1c 91       	mov	r1,lr
8000745c:	62 36       	ld.w	r6,r1[0xc]
8000745e:	c2 e8       	rjmp	800074ba <_malloc_r+0x27a>
80007460:	6c 1a       	ld.w	r10,r6[0x4]
80007462:	e0 1a ff fc 	andl	r10,0xfffc
80007466:	f4 07 01 08 	sub	r8,r10,r7
8000746a:	58 f8       	cp.w	r8,15
8000746c:	e0 8a 00 15 	brle	80007496 <_malloc_r+0x256>
80007470:	6c 3a       	ld.w	r10,r6[0xc]
80007472:	6c 29       	ld.w	r9,r6[0x8]
80007474:	95 29       	st.w	r10[0x8],r9
80007476:	93 3a       	st.w	r9[0xc],r10
80007478:	0e 99       	mov	r9,r7
8000747a:	ec 07 00 07 	add	r7,r6,r7
8000747e:	a1 a9       	sbr	r9,0x0
80007480:	99 37       	st.w	r12[0xc],r7
80007482:	99 27       	st.w	r12[0x8],r7
80007484:	8d 19       	st.w	r6[0x4],r9
80007486:	ee 08 09 08 	st.w	r7[r8],r8
8000748a:	8f 2c       	st.w	r7[0x8],r12
8000748c:	8f 3c       	st.w	r7[0xc],r12
8000748e:	a1 a8       	sbr	r8,0x0
80007490:	0a 9c       	mov	r12,r5
80007492:	8f 18       	st.w	r7[0x4],r8
80007494:	c0 d8       	rjmp	800074ae <_malloc_r+0x26e>
80007496:	6c 39       	ld.w	r9,r6[0xc]
80007498:	58 08       	cp.w	r8,0
8000749a:	c0 f5       	brlt	800074b8 <_malloc_r+0x278>
8000749c:	ec 0a 00 0a 	add	r10,r6,r10
800074a0:	74 18       	ld.w	r8,r10[0x4]
800074a2:	a1 a8       	sbr	r8,0x0
800074a4:	0a 9c       	mov	r12,r5
800074a6:	95 18       	st.w	r10[0x4],r8
800074a8:	6c 28       	ld.w	r8,r6[0x8]
800074aa:	93 28       	st.w	r9[0x8],r8
800074ac:	91 39       	st.w	r8[0xc],r9
800074ae:	fe b0 f4 b5 	rcall	80005e18 <__malloc_unlock>
800074b2:	ec cc ff f8 	sub	r12,r6,-8
800074b6:	d8 32       	popm	r0-r7,pc
800074b8:	12 96       	mov	r6,r9
800074ba:	02 36       	cp.w	r6,r1
800074bc:	cd 21       	brne	80007460 <_malloc_r+0x220>
800074be:	2f f2       	sub	r2,-1
800074c0:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800074c4:	c0 30       	breq	800074ca <_malloc_r+0x28a>
800074c6:	2f 81       	sub	r1,-8
800074c8:	cc ab       	rjmp	8000745c <_malloc_r+0x21c>
800074ca:	1c 98       	mov	r8,lr
800074cc:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800074d0:	c0 81       	brne	800074e0 <_malloc_r+0x2a0>
800074d2:	68 19       	ld.w	r9,r4[0x4]
800074d4:	f6 08 11 ff 	rsub	r8,r11,-1
800074d8:	f3 e8 00 08 	and	r8,r9,r8
800074dc:	89 18       	st.w	r4[0x4],r8
800074de:	c0 78       	rjmp	800074ec <_malloc_r+0x2ac>
800074e0:	f0 c9 00 08 	sub	r9,r8,8
800074e4:	20 13       	sub	r3,1
800074e6:	70 08       	ld.w	r8,r8[0x0]
800074e8:	12 38       	cp.w	r8,r9
800074ea:	cf 10       	breq	800074cc <_malloc_r+0x28c>
800074ec:	a1 7b       	lsl	r11,0x1
800074ee:	68 18       	ld.w	r8,r4[0x4]
800074f0:	10 3b       	cp.w	r11,r8
800074f2:	e0 8b 00 0d 	brhi	8000750c <_malloc_r+0x2cc>
800074f6:	58 0b       	cp.w	r11,0
800074f8:	c0 a0       	breq	8000750c <_malloc_r+0x2cc>
800074fa:	04 93       	mov	r3,r2
800074fc:	c0 38       	rjmp	80007502 <_malloc_r+0x2c2>
800074fe:	2f c3       	sub	r3,-4
80007500:	a1 7b       	lsl	r11,0x1
80007502:	f7 e8 00 09 	and	r9,r11,r8
80007506:	ca 71       	brne	80007454 <_malloc_r+0x214>
80007508:	cf bb       	rjmp	800074fe <_malloc_r+0x2be>
8000750a:	d7 03       	nop
8000750c:	68 23       	ld.w	r3,r4[0x8]
8000750e:	66 12       	ld.w	r2,r3[0x4]
80007510:	e0 12 ff fc 	andl	r2,0xfffc
80007514:	0e 32       	cp.w	r2,r7
80007516:	5f 39       	srlo	r9
80007518:	e4 07 01 08 	sub	r8,r2,r7
8000751c:	58 f8       	cp.w	r8,15
8000751e:	5f aa       	srle	r10
80007520:	f5 e9 10 09 	or	r9,r10,r9
80007524:	e0 80 00 9a 	breq	80007658 <_malloc_r+0x418>
80007528:	e0 68 0d 68 	mov	r8,3432
8000752c:	70 01       	ld.w	r1,r8[0x0]
8000752e:	e0 68 09 48 	mov	r8,2376
80007532:	2f 01       	sub	r1,-16
80007534:	70 08       	ld.w	r8,r8[0x0]
80007536:	0e 01       	add	r1,r7
80007538:	5b f8       	cp.w	r8,-1
8000753a:	c0 40       	breq	80007542 <_malloc_r+0x302>
8000753c:	28 11       	sub	r1,-127
8000753e:	e0 11 ff 80 	andl	r1,0xff80
80007542:	02 9b       	mov	r11,r1
80007544:	0a 9c       	mov	r12,r5
80007546:	e0 a0 02 a5 	rcall	80007a90 <_sbrk_r>
8000754a:	18 96       	mov	r6,r12
8000754c:	5b fc       	cp.w	r12,-1
8000754e:	c7 50       	breq	80007638 <_malloc_r+0x3f8>
80007550:	e6 02 00 08 	add	r8,r3,r2
80007554:	10 3c       	cp.w	r12,r8
80007556:	c0 32       	brcc	8000755c <_malloc_r+0x31c>
80007558:	08 33       	cp.w	r3,r4
8000755a:	c6 f1       	brne	80007638 <_malloc_r+0x3f8>
8000755c:	e0 6a 0d 6c 	mov	r10,3436
80007560:	74 09       	ld.w	r9,r10[0x0]
80007562:	e2 09 00 09 	add	r9,r1,r9
80007566:	95 09       	st.w	r10[0x0],r9
80007568:	10 36       	cp.w	r6,r8
8000756a:	c0 a1       	brne	8000757e <_malloc_r+0x33e>
8000756c:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007570:	c0 71       	brne	8000757e <_malloc_r+0x33e>
80007572:	e2 02 00 02 	add	r2,r1,r2
80007576:	68 28       	ld.w	r8,r4[0x8]
80007578:	a1 a2       	sbr	r2,0x0
8000757a:	91 12       	st.w	r8[0x4],r2
8000757c:	c4 f8       	rjmp	8000761a <_malloc_r+0x3da>
8000757e:	e0 6a 09 48 	mov	r10,2376
80007582:	74 0b       	ld.w	r11,r10[0x0]
80007584:	5b fb       	cp.w	r11,-1
80007586:	c0 31       	brne	8000758c <_malloc_r+0x34c>
80007588:	95 06       	st.w	r10[0x0],r6
8000758a:	c0 78       	rjmp	80007598 <_malloc_r+0x358>
8000758c:	ec 09 00 09 	add	r9,r6,r9
80007590:	e0 6a 0d 6c 	mov	r10,3436
80007594:	10 19       	sub	r9,r8
80007596:	95 09       	st.w	r10[0x0],r9
80007598:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000759c:	f0 09 11 08 	rsub	r9,r8,8
800075a0:	58 08       	cp.w	r8,0
800075a2:	f2 08 17 10 	movne	r8,r9
800075a6:	ed d8 e1 06 	addne	r6,r6,r8
800075aa:	28 08       	sub	r8,-128
800075ac:	ec 01 00 01 	add	r1,r6,r1
800075b0:	0a 9c       	mov	r12,r5
800075b2:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800075b6:	f0 01 01 01 	sub	r1,r8,r1
800075ba:	02 9b       	mov	r11,r1
800075bc:	e0 a0 02 6a 	rcall	80007a90 <_sbrk_r>
800075c0:	e0 68 0d 6c 	mov	r8,3436
800075c4:	5b fc       	cp.w	r12,-1
800075c6:	ec 0c 17 00 	moveq	r12,r6
800075ca:	f9 b1 00 00 	moveq	r1,0
800075ce:	70 09       	ld.w	r9,r8[0x0]
800075d0:	0c 1c       	sub	r12,r6
800075d2:	89 26       	st.w	r4[0x8],r6
800075d4:	02 0c       	add	r12,r1
800075d6:	12 01       	add	r1,r9
800075d8:	a1 ac       	sbr	r12,0x0
800075da:	91 01       	st.w	r8[0x0],r1
800075dc:	8d 1c       	st.w	r6[0x4],r12
800075de:	08 33       	cp.w	r3,r4
800075e0:	c1 d0       	breq	8000761a <_malloc_r+0x3da>
800075e2:	58 f2       	cp.w	r2,15
800075e4:	e0 8b 00 05 	brhi	800075ee <_malloc_r+0x3ae>
800075e8:	30 18       	mov	r8,1
800075ea:	8d 18       	st.w	r6[0x4],r8
800075ec:	c2 68       	rjmp	80007638 <_malloc_r+0x3f8>
800075ee:	30 59       	mov	r9,5
800075f0:	20 c2       	sub	r2,12
800075f2:	e0 12 ff f8 	andl	r2,0xfff8
800075f6:	e6 02 00 08 	add	r8,r3,r2
800075fa:	91 29       	st.w	r8[0x8],r9
800075fc:	91 19       	st.w	r8[0x4],r9
800075fe:	66 18       	ld.w	r8,r3[0x4]
80007600:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007604:	e5 e8 10 08 	or	r8,r2,r8
80007608:	87 18       	st.w	r3[0x4],r8
8000760a:	58 f2       	cp.w	r2,15
8000760c:	e0 88 00 07 	brls	8000761a <_malloc_r+0x3da>
80007610:	e6 cb ff f8 	sub	r11,r3,-8
80007614:	0a 9c       	mov	r12,r5
80007616:	e0 a0 1c 6b 	rcall	8000aeec <_free_r>
8000761a:	e0 69 0d 64 	mov	r9,3428
8000761e:	72 0a       	ld.w	r10,r9[0x0]
80007620:	e0 68 0d 6c 	mov	r8,3436
80007624:	70 08       	ld.w	r8,r8[0x0]
80007626:	14 38       	cp.w	r8,r10
80007628:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000762c:	e0 69 0d 60 	mov	r9,3424
80007630:	72 0a       	ld.w	r10,r9[0x0]
80007632:	14 38       	cp.w	r8,r10
80007634:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007638:	68 28       	ld.w	r8,r4[0x8]
8000763a:	70 18       	ld.w	r8,r8[0x4]
8000763c:	e0 18 ff fc 	andl	r8,0xfffc
80007640:	0e 38       	cp.w	r8,r7
80007642:	5f 39       	srlo	r9
80007644:	0e 18       	sub	r8,r7
80007646:	58 f8       	cp.w	r8,15
80007648:	5f aa       	srle	r10
8000764a:	f5 e9 10 09 	or	r9,r10,r9
8000764e:	c0 50       	breq	80007658 <_malloc_r+0x418>
80007650:	0a 9c       	mov	r12,r5
80007652:	fe b0 f3 e3 	rcall	80005e18 <__malloc_unlock>
80007656:	d8 3a       	popm	r0-r7,pc,r12=0
80007658:	68 26       	ld.w	r6,r4[0x8]
8000765a:	a1 a8       	sbr	r8,0x0
8000765c:	0e 99       	mov	r9,r7
8000765e:	a1 a9       	sbr	r9,0x0
80007660:	8d 19       	st.w	r6[0x4],r9
80007662:	ec 07 00 07 	add	r7,r6,r7
80007666:	0a 9c       	mov	r12,r5
80007668:	89 27       	st.w	r4[0x8],r7
8000766a:	8f 18       	st.w	r7[0x4],r8
8000766c:	fe b0 f3 d6 	rcall	80005e18 <__malloc_unlock>
80007670:	ec cc ff f8 	sub	r12,r6,-8
80007674:	d8 32       	popm	r0-r7,pc
80007676:	d7 03       	nop

80007678 <memcpy>:
80007678:	58 8a       	cp.w	r10,8
8000767a:	c2 f5       	brlt	800076d8 <memcpy+0x60>
8000767c:	f9 eb 10 09 	or	r9,r12,r11
80007680:	e2 19 00 03 	andl	r9,0x3,COH
80007684:	e0 81 00 97 	brne	800077b2 <memcpy+0x13a>
80007688:	e0 4a 00 20 	cp.w	r10,32
8000768c:	c3 b4       	brge	80007702 <memcpy+0x8a>
8000768e:	f4 08 14 02 	asr	r8,r10,0x2
80007692:	f0 09 11 08 	rsub	r9,r8,8
80007696:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000769a:	76 69       	ld.w	r9,r11[0x18]
8000769c:	99 69       	st.w	r12[0x18],r9
8000769e:	76 59       	ld.w	r9,r11[0x14]
800076a0:	99 59       	st.w	r12[0x14],r9
800076a2:	76 49       	ld.w	r9,r11[0x10]
800076a4:	99 49       	st.w	r12[0x10],r9
800076a6:	76 39       	ld.w	r9,r11[0xc]
800076a8:	99 39       	st.w	r12[0xc],r9
800076aa:	76 29       	ld.w	r9,r11[0x8]
800076ac:	99 29       	st.w	r12[0x8],r9
800076ae:	76 19       	ld.w	r9,r11[0x4]
800076b0:	99 19       	st.w	r12[0x4],r9
800076b2:	76 09       	ld.w	r9,r11[0x0]
800076b4:	99 09       	st.w	r12[0x0],r9
800076b6:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800076ba:	f8 08 00 28 	add	r8,r12,r8<<0x2
800076be:	e0 1a 00 03 	andl	r10,0x3
800076c2:	f4 0a 11 04 	rsub	r10,r10,4
800076c6:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800076ca:	17 a9       	ld.ub	r9,r11[0x2]
800076cc:	b0 a9       	st.b	r8[0x2],r9
800076ce:	17 99       	ld.ub	r9,r11[0x1]
800076d0:	b0 99       	st.b	r8[0x1],r9
800076d2:	17 89       	ld.ub	r9,r11[0x0]
800076d4:	b0 89       	st.b	r8[0x0],r9
800076d6:	5e fc       	retal	r12
800076d8:	f4 0a 11 09 	rsub	r10,r10,9
800076dc:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800076e0:	17 f9       	ld.ub	r9,r11[0x7]
800076e2:	b8 f9       	st.b	r12[0x7],r9
800076e4:	17 e9       	ld.ub	r9,r11[0x6]
800076e6:	b8 e9       	st.b	r12[0x6],r9
800076e8:	17 d9       	ld.ub	r9,r11[0x5]
800076ea:	b8 d9       	st.b	r12[0x5],r9
800076ec:	17 c9       	ld.ub	r9,r11[0x4]
800076ee:	b8 c9       	st.b	r12[0x4],r9
800076f0:	17 b9       	ld.ub	r9,r11[0x3]
800076f2:	b8 b9       	st.b	r12[0x3],r9
800076f4:	17 a9       	ld.ub	r9,r11[0x2]
800076f6:	b8 a9       	st.b	r12[0x2],r9
800076f8:	17 99       	ld.ub	r9,r11[0x1]
800076fa:	b8 99       	st.b	r12[0x1],r9
800076fc:	17 89       	ld.ub	r9,r11[0x0]
800076fe:	b8 89       	st.b	r12[0x0],r9
80007700:	5e fc       	retal	r12
80007702:	eb cd 40 c0 	pushm	r6-r7,lr
80007706:	18 99       	mov	r9,r12
80007708:	22 0a       	sub	r10,32
8000770a:	b7 07       	ld.d	r6,r11++
8000770c:	b3 26       	st.d	r9++,r6
8000770e:	b7 07       	ld.d	r6,r11++
80007710:	b3 26       	st.d	r9++,r6
80007712:	b7 07       	ld.d	r6,r11++
80007714:	b3 26       	st.d	r9++,r6
80007716:	b7 07       	ld.d	r6,r11++
80007718:	b3 26       	st.d	r9++,r6
8000771a:	22 0a       	sub	r10,32
8000771c:	cf 74       	brge	8000770a <memcpy+0x92>
8000771e:	2f 0a       	sub	r10,-16
80007720:	c0 65       	brlt	8000772c <memcpy+0xb4>
80007722:	b7 07       	ld.d	r6,r11++
80007724:	b3 26       	st.d	r9++,r6
80007726:	b7 07       	ld.d	r6,r11++
80007728:	b3 26       	st.d	r9++,r6
8000772a:	21 0a       	sub	r10,16
8000772c:	5c 3a       	neg	r10
8000772e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007732:	d7 03       	nop
80007734:	d7 03       	nop
80007736:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000773a:	f3 66 00 0e 	st.b	r9[14],r6
8000773e:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007742:	f3 66 00 0d 	st.b	r9[13],r6
80007746:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000774a:	f3 66 00 0c 	st.b	r9[12],r6
8000774e:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007752:	f3 66 00 0b 	st.b	r9[11],r6
80007756:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000775a:	f3 66 00 0a 	st.b	r9[10],r6
8000775e:	f7 36 00 09 	ld.ub	r6,r11[9]
80007762:	f3 66 00 09 	st.b	r9[9],r6
80007766:	f7 36 00 08 	ld.ub	r6,r11[8]
8000776a:	f3 66 00 08 	st.b	r9[8],r6
8000776e:	f7 36 00 07 	ld.ub	r6,r11[7]
80007772:	f3 66 00 07 	st.b	r9[7],r6
80007776:	f7 36 00 06 	ld.ub	r6,r11[6]
8000777a:	f3 66 00 06 	st.b	r9[6],r6
8000777e:	f7 36 00 05 	ld.ub	r6,r11[5]
80007782:	f3 66 00 05 	st.b	r9[5],r6
80007786:	f7 36 00 04 	ld.ub	r6,r11[4]
8000778a:	f3 66 00 04 	st.b	r9[4],r6
8000778e:	f7 36 00 03 	ld.ub	r6,r11[3]
80007792:	f3 66 00 03 	st.b	r9[3],r6
80007796:	f7 36 00 02 	ld.ub	r6,r11[2]
8000779a:	f3 66 00 02 	st.b	r9[2],r6
8000779e:	f7 36 00 01 	ld.ub	r6,r11[1]
800077a2:	f3 66 00 01 	st.b	r9[1],r6
800077a6:	f7 36 00 00 	ld.ub	r6,r11[0]
800077aa:	f3 66 00 00 	st.b	r9[0],r6
800077ae:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800077b2:	20 1a       	sub	r10,1
800077b4:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800077b8:	f8 0a 0b 09 	st.b	r12[r10],r9
800077bc:	cf b1       	brne	800077b2 <memcpy+0x13a>
800077be:	5e fc       	retal	r12

800077c0 <memset>:
800077c0:	18 98       	mov	r8,r12
800077c2:	c0 38       	rjmp	800077c8 <memset+0x8>
800077c4:	10 cb       	st.b	r8++,r11
800077c6:	20 1a       	sub	r10,1
800077c8:	58 0a       	cp.w	r10,0
800077ca:	cf d1       	brne	800077c4 <memset+0x4>
800077cc:	5e fc       	retal	r12
800077ce:	d7 03       	nop

800077d0 <_realloc_r>:
800077d0:	d4 31       	pushm	r0-r7,lr
800077d2:	20 1d       	sub	sp,4
800077d4:	16 94       	mov	r4,r11
800077d6:	18 92       	mov	r2,r12
800077d8:	14 9b       	mov	r11,r10
800077da:	58 04       	cp.w	r4,0
800077dc:	c0 51       	brne	800077e6 <_realloc_r+0x16>
800077de:	fe b0 fd 31 	rcall	80007240 <_malloc_r>
800077e2:	18 95       	mov	r5,r12
800077e4:	c5 39       	rjmp	80007a8a <_realloc_r+0x2ba>
800077e6:	50 0a       	stdsp	sp[0x0],r10
800077e8:	fe b0 f3 12 	rcall	80005e0c <__malloc_lock>
800077ec:	40 0b       	lddsp	r11,sp[0x0]
800077ee:	f6 c8 ff f5 	sub	r8,r11,-11
800077f2:	e8 c1 00 08 	sub	r1,r4,8
800077f6:	10 96       	mov	r6,r8
800077f8:	62 1c       	ld.w	r12,r1[0x4]
800077fa:	e0 16 ff f8 	andl	r6,0xfff8
800077fe:	59 68       	cp.w	r8,22
80007800:	f9 b6 08 10 	movls	r6,16
80007804:	16 36       	cp.w	r6,r11
80007806:	5f 38       	srlo	r8
80007808:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000780c:	c0 50       	breq	80007816 <_realloc_r+0x46>
8000780e:	30 c8       	mov	r8,12
80007810:	30 05       	mov	r5,0
80007812:	85 38       	st.w	r2[0xc],r8
80007814:	c3 b9       	rjmp	80007a8a <_realloc_r+0x2ba>
80007816:	18 90       	mov	r0,r12
80007818:	e0 10 ff fc 	andl	r0,0xfffc
8000781c:	0c 30       	cp.w	r0,r6
8000781e:	e0 84 01 0b 	brge	80007a34 <_realloc_r+0x264>
80007822:	e0 68 05 3c 	mov	r8,1340
80007826:	e2 00 00 09 	add	r9,r1,r0
8000782a:	70 25       	ld.w	r5,r8[0x8]
8000782c:	0a 39       	cp.w	r9,r5
8000782e:	c0 90       	breq	80007840 <_realloc_r+0x70>
80007830:	72 1a       	ld.w	r10,r9[0x4]
80007832:	a1 ca       	cbr	r10,0x0
80007834:	f2 0a 00 0a 	add	r10,r9,r10
80007838:	74 1a       	ld.w	r10,r10[0x4]
8000783a:	ed ba 00 00 	bld	r10,0x0
8000783e:	c2 20       	breq	80007882 <_realloc_r+0xb2>
80007840:	72 1a       	ld.w	r10,r9[0x4]
80007842:	e0 1a ff fc 	andl	r10,0xfffc
80007846:	f4 00 00 03 	add	r3,r10,r0
8000784a:	0a 39       	cp.w	r9,r5
8000784c:	c1 31       	brne	80007872 <_realloc_r+0xa2>
8000784e:	ec c7 ff f0 	sub	r7,r6,-16
80007852:	0e 33       	cp.w	r3,r7
80007854:	c1 95       	brlt	80007886 <_realloc_r+0xb6>
80007856:	e2 06 00 09 	add	r9,r1,r6
8000785a:	0c 13       	sub	r3,r6
8000785c:	a1 a3       	sbr	r3,0x0
8000785e:	93 13       	st.w	r9[0x4],r3
80007860:	91 29       	st.w	r8[0x8],r9
80007862:	04 9c       	mov	r12,r2
80007864:	62 18       	ld.w	r8,r1[0x4]
80007866:	08 95       	mov	r5,r4
80007868:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000786c:	10 46       	or	r6,r8
8000786e:	83 16       	st.w	r1[0x4],r6
80007870:	c0 b9       	rjmp	80007a86 <_realloc_r+0x2b6>
80007872:	0c 33       	cp.w	r3,r6
80007874:	c0 95       	brlt	80007886 <_realloc_r+0xb6>
80007876:	72 28       	ld.w	r8,r9[0x8]
80007878:	02 97       	mov	r7,r1
8000787a:	72 39       	ld.w	r9,r9[0xc]
8000787c:	93 28       	st.w	r9[0x8],r8
8000787e:	91 39       	st.w	r8[0xc],r9
80007880:	cd c8       	rjmp	80007a38 <_realloc_r+0x268>
80007882:	30 0a       	mov	r10,0
80007884:	14 99       	mov	r9,r10
80007886:	ed bc 00 00 	bld	r12,0x0
8000788a:	e0 80 00 95 	breq	800079b4 <_realloc_r+0x1e4>
8000788e:	62 07       	ld.w	r7,r1[0x0]
80007890:	e2 07 01 07 	sub	r7,r1,r7
80007894:	6e 1c       	ld.w	r12,r7[0x4]
80007896:	e0 1c ff fc 	andl	r12,0xfffc
8000789a:	58 09       	cp.w	r9,0
8000789c:	c5 60       	breq	80007948 <_realloc_r+0x178>
8000789e:	f8 00 00 03 	add	r3,r12,r0
800078a2:	0a 39       	cp.w	r9,r5
800078a4:	c4 81       	brne	80007934 <_realloc_r+0x164>
800078a6:	14 03       	add	r3,r10
800078a8:	ec c9 ff f0 	sub	r9,r6,-16
800078ac:	12 33       	cp.w	r3,r9
800078ae:	c4 d5       	brlt	80007948 <_realloc_r+0x178>
800078b0:	6e 3a       	ld.w	r10,r7[0xc]
800078b2:	6e 29       	ld.w	r9,r7[0x8]
800078b4:	95 29       	st.w	r10[0x8],r9
800078b6:	93 3a       	st.w	r9[0xc],r10
800078b8:	ee c5 ff f8 	sub	r5,r7,-8
800078bc:	e0 ca 00 04 	sub	r10,r0,4
800078c0:	e0 4a 00 24 	cp.w	r10,36
800078c4:	e0 8b 00 25 	brhi	8000790e <_realloc_r+0x13e>
800078c8:	0a 99       	mov	r9,r5
800078ca:	59 3a       	cp.w	r10,19
800078cc:	e0 88 00 1a 	brls	80007900 <_realloc_r+0x130>
800078d0:	09 09       	ld.w	r9,r4++
800078d2:	8b 09       	st.w	r5[0x0],r9
800078d4:	09 09       	ld.w	r9,r4++
800078d6:	8f 39       	st.w	r7[0xc],r9
800078d8:	ee c9 ff f0 	sub	r9,r7,-16
800078dc:	59 ba       	cp.w	r10,27
800078de:	e0 88 00 11 	brls	80007900 <_realloc_r+0x130>
800078e2:	09 0b       	ld.w	r11,r4++
800078e4:	93 0b       	st.w	r9[0x0],r11
800078e6:	09 09       	ld.w	r9,r4++
800078e8:	8f 59       	st.w	r7[0x14],r9
800078ea:	ee c9 ff e8 	sub	r9,r7,-24
800078ee:	e0 4a 00 24 	cp.w	r10,36
800078f2:	c0 71       	brne	80007900 <_realloc_r+0x130>
800078f4:	09 0a       	ld.w	r10,r4++
800078f6:	93 0a       	st.w	r9[0x0],r10
800078f8:	ee c9 ff e0 	sub	r9,r7,-32
800078fc:	09 0a       	ld.w	r10,r4++
800078fe:	8f 7a       	st.w	r7[0x1c],r10
80007900:	09 0a       	ld.w	r10,r4++
80007902:	12 aa       	st.w	r9++,r10
80007904:	68 0a       	ld.w	r10,r4[0x0]
80007906:	93 0a       	st.w	r9[0x0],r10
80007908:	68 1a       	ld.w	r10,r4[0x4]
8000790a:	93 1a       	st.w	r9[0x4],r10
8000790c:	c0 78       	rjmp	8000791a <_realloc_r+0x14a>
8000790e:	50 08       	stdsp	sp[0x0],r8
80007910:	08 9b       	mov	r11,r4
80007912:	0a 9c       	mov	r12,r5
80007914:	e0 a0 1d 8f 	rcall	8000b432 <memmove>
80007918:	40 08       	lddsp	r8,sp[0x0]
8000791a:	ee 06 00 09 	add	r9,r7,r6
8000791e:	0c 13       	sub	r3,r6
80007920:	a1 a3       	sbr	r3,0x0
80007922:	93 13       	st.w	r9[0x4],r3
80007924:	91 29       	st.w	r8[0x8],r9
80007926:	04 9c       	mov	r12,r2
80007928:	6e 18       	ld.w	r8,r7[0x4]
8000792a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000792e:	10 46       	or	r6,r8
80007930:	8f 16       	st.w	r7[0x4],r6
80007932:	ca a8       	rjmp	80007a86 <_realloc_r+0x2b6>
80007934:	14 03       	add	r3,r10
80007936:	0c 33       	cp.w	r3,r6
80007938:	c0 85       	brlt	80007948 <_realloc_r+0x178>
8000793a:	72 28       	ld.w	r8,r9[0x8]
8000793c:	72 39       	ld.w	r9,r9[0xc]
8000793e:	93 28       	st.w	r9[0x8],r8
80007940:	91 39       	st.w	r8[0xc],r9
80007942:	6e 28       	ld.w	r8,r7[0x8]
80007944:	6e 39       	ld.w	r9,r7[0xc]
80007946:	c0 78       	rjmp	80007954 <_realloc_r+0x184>
80007948:	f8 00 00 03 	add	r3,r12,r0
8000794c:	0c 33       	cp.w	r3,r6
8000794e:	c3 35       	brlt	800079b4 <_realloc_r+0x1e4>
80007950:	6e 39       	ld.w	r9,r7[0xc]
80007952:	6e 28       	ld.w	r8,r7[0x8]
80007954:	93 28       	st.w	r9[0x8],r8
80007956:	91 39       	st.w	r8[0xc],r9
80007958:	e0 ca 00 04 	sub	r10,r0,4
8000795c:	ee cc ff f8 	sub	r12,r7,-8
80007960:	e0 4a 00 24 	cp.w	r10,36
80007964:	e0 8b 00 24 	brhi	800079ac <_realloc_r+0x1dc>
80007968:	59 3a       	cp.w	r10,19
8000796a:	e0 88 00 1a 	brls	8000799e <_realloc_r+0x1ce>
8000796e:	09 08       	ld.w	r8,r4++
80007970:	99 08       	st.w	r12[0x0],r8
80007972:	09 08       	ld.w	r8,r4++
80007974:	8f 38       	st.w	r7[0xc],r8
80007976:	ee cc ff f0 	sub	r12,r7,-16
8000797a:	59 ba       	cp.w	r10,27
8000797c:	e0 88 00 11 	brls	8000799e <_realloc_r+0x1ce>
80007980:	09 08       	ld.w	r8,r4++
80007982:	99 08       	st.w	r12[0x0],r8
80007984:	09 08       	ld.w	r8,r4++
80007986:	8f 58       	st.w	r7[0x14],r8
80007988:	ee cc ff e8 	sub	r12,r7,-24
8000798c:	e0 4a 00 24 	cp.w	r10,36
80007990:	c0 71       	brne	8000799e <_realloc_r+0x1ce>
80007992:	09 08       	ld.w	r8,r4++
80007994:	99 08       	st.w	r12[0x0],r8
80007996:	ee cc ff e0 	sub	r12,r7,-32
8000799a:	09 08       	ld.w	r8,r4++
8000799c:	8f 78       	st.w	r7[0x1c],r8
8000799e:	09 08       	ld.w	r8,r4++
800079a0:	18 a8       	st.w	r12++,r8
800079a2:	68 08       	ld.w	r8,r4[0x0]
800079a4:	99 08       	st.w	r12[0x0],r8
800079a6:	68 18       	ld.w	r8,r4[0x4]
800079a8:	99 18       	st.w	r12[0x4],r8
800079aa:	c4 78       	rjmp	80007a38 <_realloc_r+0x268>
800079ac:	08 9b       	mov	r11,r4
800079ae:	e0 a0 1d 42 	rcall	8000b432 <memmove>
800079b2:	c4 38       	rjmp	80007a38 <_realloc_r+0x268>
800079b4:	04 9c       	mov	r12,r2
800079b6:	fe b0 fc 45 	rcall	80007240 <_malloc_r>
800079ba:	18 95       	mov	r5,r12
800079bc:	c3 a0       	breq	80007a30 <_realloc_r+0x260>
800079be:	62 18       	ld.w	r8,r1[0x4]
800079c0:	f8 c9 00 08 	sub	r9,r12,8
800079c4:	a1 c8       	cbr	r8,0x0
800079c6:	e2 08 00 08 	add	r8,r1,r8
800079ca:	10 39       	cp.w	r9,r8
800079cc:	c0 71       	brne	800079da <_realloc_r+0x20a>
800079ce:	72 13       	ld.w	r3,r9[0x4]
800079d0:	02 97       	mov	r7,r1
800079d2:	e0 13 ff fc 	andl	r3,0xfffc
800079d6:	00 03       	add	r3,r0
800079d8:	c3 08       	rjmp	80007a38 <_realloc_r+0x268>
800079da:	e0 ca 00 04 	sub	r10,r0,4
800079de:	e0 4a 00 24 	cp.w	r10,36
800079e2:	e0 8b 00 20 	brhi	80007a22 <_realloc_r+0x252>
800079e6:	08 99       	mov	r9,r4
800079e8:	18 98       	mov	r8,r12
800079ea:	59 3a       	cp.w	r10,19
800079ec:	e0 88 00 14 	brls	80007a14 <_realloc_r+0x244>
800079f0:	13 0b       	ld.w	r11,r9++
800079f2:	10 ab       	st.w	r8++,r11
800079f4:	13 0b       	ld.w	r11,r9++
800079f6:	10 ab       	st.w	r8++,r11
800079f8:	59 ba       	cp.w	r10,27
800079fa:	e0 88 00 0d 	brls	80007a14 <_realloc_r+0x244>
800079fe:	13 0b       	ld.w	r11,r9++
80007a00:	10 ab       	st.w	r8++,r11
80007a02:	13 0b       	ld.w	r11,r9++
80007a04:	10 ab       	st.w	r8++,r11
80007a06:	e0 4a 00 24 	cp.w	r10,36
80007a0a:	c0 51       	brne	80007a14 <_realloc_r+0x244>
80007a0c:	13 0a       	ld.w	r10,r9++
80007a0e:	10 aa       	st.w	r8++,r10
80007a10:	13 0a       	ld.w	r10,r9++
80007a12:	10 aa       	st.w	r8++,r10
80007a14:	13 0a       	ld.w	r10,r9++
80007a16:	10 aa       	st.w	r8++,r10
80007a18:	72 0a       	ld.w	r10,r9[0x0]
80007a1a:	91 0a       	st.w	r8[0x0],r10
80007a1c:	72 19       	ld.w	r9,r9[0x4]
80007a1e:	91 19       	st.w	r8[0x4],r9
80007a20:	c0 48       	rjmp	80007a28 <_realloc_r+0x258>
80007a22:	08 9b       	mov	r11,r4
80007a24:	e0 a0 1d 07 	rcall	8000b432 <memmove>
80007a28:	08 9b       	mov	r11,r4
80007a2a:	04 9c       	mov	r12,r2
80007a2c:	e0 a0 1a 60 	rcall	8000aeec <_free_r>
80007a30:	04 9c       	mov	r12,r2
80007a32:	c2 a8       	rjmp	80007a86 <_realloc_r+0x2b6>
80007a34:	00 93       	mov	r3,r0
80007a36:	02 97       	mov	r7,r1
80007a38:	e6 06 01 09 	sub	r9,r3,r6
80007a3c:	6e 18       	ld.w	r8,r7[0x4]
80007a3e:	58 f9       	cp.w	r9,15
80007a40:	e0 88 00 16 	brls	80007a6c <_realloc_r+0x29c>
80007a44:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a48:	ed e8 10 08 	or	r8,r6,r8
80007a4c:	8f 18       	st.w	r7[0x4],r8
80007a4e:	12 98       	mov	r8,r9
80007a50:	a1 a8       	sbr	r8,0x0
80007a52:	ee 06 00 0b 	add	r11,r7,r6
80007a56:	f6 09 00 09 	add	r9,r11,r9
80007a5a:	97 18       	st.w	r11[0x4],r8
80007a5c:	72 18       	ld.w	r8,r9[0x4]
80007a5e:	a1 a8       	sbr	r8,0x0
80007a60:	2f 8b       	sub	r11,-8
80007a62:	93 18       	st.w	r9[0x4],r8
80007a64:	04 9c       	mov	r12,r2
80007a66:	e0 a0 1a 43 	rcall	8000aeec <_free_r>
80007a6a:	c0 b8       	rjmp	80007a80 <_realloc_r+0x2b0>
80007a6c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a70:	e7 e8 10 08 	or	r8,r3,r8
80007a74:	8f 18       	st.w	r7[0x4],r8
80007a76:	ee 03 00 03 	add	r3,r7,r3
80007a7a:	66 18       	ld.w	r8,r3[0x4]
80007a7c:	a1 a8       	sbr	r8,0x0
80007a7e:	87 18       	st.w	r3[0x4],r8
80007a80:	04 9c       	mov	r12,r2
80007a82:	ee c5 ff f8 	sub	r5,r7,-8
80007a86:	fe b0 f1 c9 	rcall	80005e18 <__malloc_unlock>
80007a8a:	0a 9c       	mov	r12,r5
80007a8c:	2f fd       	sub	sp,-4
80007a8e:	d8 32       	popm	r0-r7,pc

80007a90 <_sbrk_r>:
80007a90:	d4 21       	pushm	r4-r7,lr
80007a92:	30 08       	mov	r8,0
80007a94:	18 97       	mov	r7,r12
80007a96:	e0 66 5b 6c 	mov	r6,23404
80007a9a:	16 9c       	mov	r12,r11
80007a9c:	8d 08       	st.w	r6[0x0],r8
80007a9e:	c8 5c       	rcall	80007ba8 <_sbrk>
80007aa0:	5b fc       	cp.w	r12,-1
80007aa2:	c0 51       	brne	80007aac <_sbrk_r+0x1c>
80007aa4:	6c 08       	ld.w	r8,r6[0x0]
80007aa6:	58 08       	cp.w	r8,0
80007aa8:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007aac:	d8 22       	popm	r4-r7,pc
80007aae:	d7 03       	nop

80007ab0 <sprintf>:
80007ab0:	d4 01       	pushm	lr
80007ab2:	21 7d       	sub	sp,92
80007ab4:	e0 68 ff ff 	mov	r8,65535
80007ab8:	ea 18 7f ff 	orh	r8,0x7fff
80007abc:	50 58       	stdsp	sp[0x14],r8
80007abe:	50 28       	stdsp	sp[0x8],r8
80007ac0:	e0 68 02 08 	mov	r8,520
80007ac4:	ba 68       	st.h	sp[0xc],r8
80007ac6:	3f f8       	mov	r8,-1
80007ac8:	ba 78       	st.h	sp[0xe],r8
80007aca:	e0 68 0a 3c 	mov	r8,2620
80007ace:	50 4c       	stdsp	sp[0x10],r12
80007ad0:	16 9a       	mov	r10,r11
80007ad2:	50 0c       	stdsp	sp[0x0],r12
80007ad4:	fa c9 ff a0 	sub	r9,sp,-96
80007ad8:	70 0c       	ld.w	r12,r8[0x0]
80007ada:	1a 9b       	mov	r11,sp
80007adc:	e0 a0 02 1a 	rcall	80007f10 <_vfprintf_r>
80007ae0:	30 09       	mov	r9,0
80007ae2:	40 08       	lddsp	r8,sp[0x0]
80007ae4:	b0 89       	st.b	r8[0x0],r9
80007ae6:	2e 9d       	sub	sp,-92
80007ae8:	d8 02       	popm	pc
80007aea:	d7 03       	nop

80007aec <strncpy>:
80007aec:	30 08       	mov	r8,0
80007aee:	10 3a       	cp.w	r10,r8
80007af0:	5e 0c       	reteq	r12
80007af2:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007af6:	f8 08 0b 09 	st.b	r12[r8],r9
80007afa:	2f f8       	sub	r8,-1
80007afc:	58 09       	cp.w	r9,0
80007afe:	cf 81       	brne	80007aee <strncpy+0x2>
80007b00:	10 3a       	cp.w	r10,r8
80007b02:	5e 0c       	reteq	r12
80007b04:	f8 08 0b 09 	st.b	r12[r8],r9
80007b08:	2f f8       	sub	r8,-1
80007b0a:	cf bb       	rjmp	80007b00 <strncpy+0x14>

80007b0c <_close>:
80007b0c:	30 28       	mov	r8,2
80007b0e:	d6 73       	breakpoint
80007b10:	3f fc       	mov	r12,-1
80007b12:	35 8b       	mov	r11,88
80007b14:	58 0c       	cp.w	r12,0
80007b16:	5e 4c       	retge	r12
80007b18:	e0 6a 5b 6c 	mov	r10,23404
80007b1c:	95 0b       	st.w	r10[0x0],r11
80007b1e:	5e fc       	retal	r12

80007b20 <_lseek>:
80007b20:	30 58       	mov	r8,5
80007b22:	d6 73       	breakpoint
80007b24:	3f fc       	mov	r12,-1
80007b26:	35 8b       	mov	r11,88
80007b28:	58 0c       	cp.w	r12,0
80007b2a:	5e 4c       	retge	r12
80007b2c:	e0 6a 5b 6c 	mov	r10,23404
80007b30:	95 0b       	st.w	r10[0x0],r11
80007b32:	5e fc       	retal	r12

80007b34 <isatty>:
80007b34:	30 b8       	mov	r8,11
80007b36:	d6 73       	breakpoint
80007b38:	3f fc       	mov	r12,-1
80007b3a:	35 8b       	mov	r11,88
80007b3c:	58 0c       	cp.w	r12,0
80007b3e:	5e 4c       	retge	r12
80007b40:	e0 6a 5b 6c 	mov	r10,23404
80007b44:	95 0b       	st.w	r10[0x0],r11
80007b46:	5e fc       	retal	r12

80007b48 <_fstat_host>:
80007b48:	30 98       	mov	r8,9
80007b4a:	d6 73       	breakpoint
80007b4c:	3f fc       	mov	r12,-1
80007b4e:	35 8b       	mov	r11,88
80007b50:	58 0c       	cp.w	r12,0
80007b52:	5e 4c       	retge	r12
80007b54:	e0 6a 5b 6c 	mov	r10,23404
80007b58:	95 0b       	st.w	r10[0x0],r11
80007b5a:	5e fc       	retal	r12

80007b5c <_fstat>:
80007b5c:	d4 21       	pushm	r4-r7,lr
80007b5e:	21 0d       	sub	sp,64
80007b60:	16 97       	mov	r7,r11
80007b62:	1a 9b       	mov	r11,sp
80007b64:	cf 2f       	rcall	80007b48 <_fstat_host>
80007b66:	c0 34       	brge	80007b6c <_fstat+0x10>
80007b68:	3f fc       	mov	r12,-1
80007b6a:	c1 c8       	rjmp	80007ba2 <_fstat+0x46>
80007b6c:	40 08       	lddsp	r8,sp[0x0]
80007b6e:	ae 08       	st.h	r7[0x0],r8
80007b70:	40 18       	lddsp	r8,sp[0x4]
80007b72:	ae 18       	st.h	r7[0x2],r8
80007b74:	40 28       	lddsp	r8,sp[0x8]
80007b76:	8f 18       	st.w	r7[0x4],r8
80007b78:	40 38       	lddsp	r8,sp[0xc]
80007b7a:	ae 48       	st.h	r7[0x8],r8
80007b7c:	40 48       	lddsp	r8,sp[0x10]
80007b7e:	ae 58       	st.h	r7[0xa],r8
80007b80:	40 58       	lddsp	r8,sp[0x14]
80007b82:	ae 68       	st.h	r7[0xc],r8
80007b84:	40 68       	lddsp	r8,sp[0x18]
80007b86:	ae 78       	st.h	r7[0xe],r8
80007b88:	40 88       	lddsp	r8,sp[0x20]
80007b8a:	8f 48       	st.w	r7[0x10],r8
80007b8c:	40 a8       	lddsp	r8,sp[0x28]
80007b8e:	8f b8       	st.w	r7[0x2c],r8
80007b90:	40 c8       	lddsp	r8,sp[0x30]
80007b92:	8f c8       	st.w	r7[0x30],r8
80007b94:	40 d8       	lddsp	r8,sp[0x34]
80007b96:	8f 58       	st.w	r7[0x14],r8
80007b98:	40 e8       	lddsp	r8,sp[0x38]
80007b9a:	30 0c       	mov	r12,0
80007b9c:	8f 78       	st.w	r7[0x1c],r8
80007b9e:	40 f8       	lddsp	r8,sp[0x3c]
80007ba0:	8f 98       	st.w	r7[0x24],r8
80007ba2:	2f 0d       	sub	sp,-64
80007ba4:	d8 22       	popm	r4-r7,pc
80007ba6:	d7 03       	nop

80007ba8 <_sbrk>:
80007ba8:	d4 01       	pushm	lr
80007baa:	e0 68 0d 94 	mov	r8,3476
80007bae:	70 09       	ld.w	r9,r8[0x0]
80007bb0:	58 09       	cp.w	r9,0
80007bb2:	c0 41       	brne	80007bba <_sbrk+0x12>
80007bb4:	e0 69 5b 70 	mov	r9,23408
80007bb8:	91 09       	st.w	r8[0x0],r9
80007bba:	e0 69 0d 94 	mov	r9,3476
80007bbe:	e0 7a 70 00 	mov	r10,94208
80007bc2:	72 08       	ld.w	r8,r9[0x0]
80007bc4:	f0 0c 00 0c 	add	r12,r8,r12
80007bc8:	14 3c       	cp.w	r12,r10
80007bca:	e0 8b 00 04 	brhi	80007bd2 <_sbrk+0x2a>
80007bce:	93 0c       	st.w	r9[0x0],r12
80007bd0:	c0 68       	rjmp	80007bdc <_sbrk+0x34>
80007bd2:	e0 a0 18 15 	rcall	8000abfc <__errno>
80007bd6:	30 c8       	mov	r8,12
80007bd8:	99 08       	st.w	r12[0x0],r8
80007bda:	3f f8       	mov	r8,-1
80007bdc:	10 9c       	mov	r12,r8
80007bde:	d8 02       	popm	pc

80007be0 <get_arg>:
80007be0:	d4 31       	pushm	r0-r7,lr
80007be2:	20 8d       	sub	sp,32
80007be4:	fa c4 ff bc 	sub	r4,sp,-68
80007be8:	50 4b       	stdsp	sp[0x10],r11
80007bea:	68 2e       	ld.w	lr,r4[0x8]
80007bec:	50 58       	stdsp	sp[0x14],r8
80007bee:	12 96       	mov	r6,r9
80007bf0:	7c 0b       	ld.w	r11,lr[0x0]
80007bf2:	70 05       	ld.w	r5,r8[0x0]
80007bf4:	50 6e       	stdsp	sp[0x18],lr
80007bf6:	58 0b       	cp.w	r11,0
80007bf8:	f4 0b 17 00 	moveq	r11,r10
80007bfc:	68 03       	ld.w	r3,r4[0x0]
80007bfe:	68 11       	ld.w	r1,r4[0x4]
80007c00:	40 49       	lddsp	r9,sp[0x10]
80007c02:	30 08       	mov	r8,0
80007c04:	c2 89       	rjmp	80007e54 <get_arg+0x274>
80007c06:	2f fb       	sub	r11,-1
80007c08:	32 5c       	mov	r12,37
80007c0a:	17 8a       	ld.ub	r10,r11[0x0]
80007c0c:	f8 0a 18 00 	cp.b	r10,r12
80007c10:	5f 1e       	srne	lr
80007c12:	f0 0a 18 00 	cp.b	r10,r8
80007c16:	5f 1c       	srne	r12
80007c18:	fd ec 00 0c 	and	r12,lr,r12
80007c1c:	f0 0c 18 00 	cp.b	r12,r8
80007c20:	cf 31       	brne	80007c06 <get_arg+0x26>
80007c22:	58 0a       	cp.w	r10,0
80007c24:	e0 80 01 25 	breq	80007e6e <get_arg+0x28e>
80007c28:	30 0c       	mov	r12,0
80007c2a:	3f fa       	mov	r10,-1
80007c2c:	18 90       	mov	r0,r12
80007c2e:	50 3a       	stdsp	sp[0xc],r10
80007c30:	18 94       	mov	r4,r12
80007c32:	18 92       	mov	r2,r12
80007c34:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007c38:	16 97       	mov	r7,r11
80007c3a:	50 7c       	stdsp	sp[0x1c],r12
80007c3c:	fe cc 9e 74 	sub	r12,pc,-24972
80007c40:	0f 3a       	ld.ub	r10,r7++
80007c42:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007c46:	40 7c       	lddsp	r12,sp[0x1c]
80007c48:	1c 0c       	add	r12,lr
80007c4a:	fe ce 9f 4a 	sub	lr,pc,-24758
80007c4e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007c52:	20 1e       	sub	lr,1
80007c54:	50 0e       	stdsp	sp[0x0],lr
80007c56:	fe ce 9f c2 	sub	lr,pc,-24638
80007c5a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007c5e:	50 7c       	stdsp	sp[0x1c],r12
80007c60:	40 0c       	lddsp	r12,sp[0x0]
80007c62:	58 7c       	cp.w	r12,7
80007c64:	e0 8b 00 f1 	brhi	80007e46 <get_arg+0x266>
80007c68:	fe ce a1 74 	sub	lr,pc,-24204
80007c6c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007c70:	36 8b       	mov	r11,104
80007c72:	f6 0a 18 00 	cp.b	r10,r11
80007c76:	e0 80 00 e8 	breq	80007e46 <get_arg+0x266>
80007c7a:	37 1b       	mov	r11,113
80007c7c:	f6 0a 18 00 	cp.b	r10,r11
80007c80:	c0 70       	breq	80007c8e <get_arg+0xae>
80007c82:	34 cb       	mov	r11,76
80007c84:	f6 0a 18 00 	cp.b	r10,r11
80007c88:	c0 51       	brne	80007c92 <get_arg+0xb2>
80007c8a:	a3 b4       	sbr	r4,0x3
80007c8c:	cd d8       	rjmp	80007e46 <get_arg+0x266>
80007c8e:	a5 b4       	sbr	r4,0x5
80007c90:	cd b8       	rjmp	80007e46 <get_arg+0x266>
80007c92:	08 9a       	mov	r10,r4
80007c94:	0e 9b       	mov	r11,r7
80007c96:	a5 aa       	sbr	r10,0x4
80007c98:	17 3c       	ld.ub	r12,r11++
80007c9a:	a5 b4       	sbr	r4,0x5
80007c9c:	36 ce       	mov	lr,108
80007c9e:	fc 0c 18 00 	cp.b	r12,lr
80007ca2:	e0 80 00 d3 	breq	80007e48 <get_arg+0x268>
80007ca6:	14 94       	mov	r4,r10
80007ca8:	cc f8       	rjmp	80007e46 <get_arg+0x266>
80007caa:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007cae:	36 7c       	mov	r12,103
80007cb0:	f8 0a 18 00 	cp.b	r10,r12
80007cb4:	e0 8b 00 27 	brhi	80007d02 <get_arg+0x122>
80007cb8:	36 5b       	mov	r11,101
80007cba:	f6 0a 18 00 	cp.b	r10,r11
80007cbe:	c4 82       	brcc	80007d4e <get_arg+0x16e>
80007cc0:	34 fb       	mov	r11,79
80007cc2:	f6 0a 18 00 	cp.b	r10,r11
80007cc6:	c4 80       	breq	80007d56 <get_arg+0x176>
80007cc8:	e0 8b 00 0c 	brhi	80007ce0 <get_arg+0x100>
80007ccc:	34 5b       	mov	r11,69
80007cce:	f6 0a 18 00 	cp.b	r10,r11
80007cd2:	c3 e0       	breq	80007d4e <get_arg+0x16e>
80007cd4:	34 7b       	mov	r11,71
80007cd6:	f6 0a 18 00 	cp.b	r10,r11
80007cda:	c3 a0       	breq	80007d4e <get_arg+0x16e>
80007cdc:	34 4b       	mov	r11,68
80007cde:	c0 88       	rjmp	80007cee <get_arg+0x10e>
80007ce0:	35 8b       	mov	r11,88
80007ce2:	f6 0a 18 00 	cp.b	r10,r11
80007ce6:	c2 c0       	breq	80007d3e <get_arg+0x15e>
80007ce8:	e0 8b 00 07 	brhi	80007cf6 <get_arg+0x116>
80007cec:	35 5b       	mov	r11,85
80007cee:	f6 0a 18 00 	cp.b	r10,r11
80007cf2:	c3 51       	brne	80007d5c <get_arg+0x17c>
80007cf4:	c3 18       	rjmp	80007d56 <get_arg+0x176>
80007cf6:	36 3b       	mov	r11,99
80007cf8:	f6 0a 18 00 	cp.b	r10,r11
80007cfc:	c2 f0       	breq	80007d5a <get_arg+0x17a>
80007cfe:	36 4b       	mov	r11,100
80007d00:	c0 e8       	rjmp	80007d1c <get_arg+0x13c>
80007d02:	37 0b       	mov	r11,112
80007d04:	f6 0a 18 00 	cp.b	r10,r11
80007d08:	c2 50       	breq	80007d52 <get_arg+0x172>
80007d0a:	e0 8b 00 0d 	brhi	80007d24 <get_arg+0x144>
80007d0e:	36 eb       	mov	r11,110
80007d10:	f6 0a 18 00 	cp.b	r10,r11
80007d14:	c1 f0       	breq	80007d52 <get_arg+0x172>
80007d16:	e0 8b 00 14 	brhi	80007d3e <get_arg+0x15e>
80007d1a:	36 9b       	mov	r11,105
80007d1c:	f6 0a 18 00 	cp.b	r10,r11
80007d20:	c1 e1       	brne	80007d5c <get_arg+0x17c>
80007d22:	c0 e8       	rjmp	80007d3e <get_arg+0x15e>
80007d24:	37 5b       	mov	r11,117
80007d26:	f6 0a 18 00 	cp.b	r10,r11
80007d2a:	c0 a0       	breq	80007d3e <get_arg+0x15e>
80007d2c:	37 8b       	mov	r11,120
80007d2e:	f6 0a 18 00 	cp.b	r10,r11
80007d32:	c0 60       	breq	80007d3e <get_arg+0x15e>
80007d34:	37 3b       	mov	r11,115
80007d36:	f6 0a 18 00 	cp.b	r10,r11
80007d3a:	c1 11       	brne	80007d5c <get_arg+0x17c>
80007d3c:	c0 b8       	rjmp	80007d52 <get_arg+0x172>
80007d3e:	ed b4 00 04 	bld	r4,0x4
80007d42:	c0 a0       	breq	80007d56 <get_arg+0x176>
80007d44:	ed b4 00 05 	bld	r4,0x5
80007d48:	c0 91       	brne	80007d5a <get_arg+0x17a>
80007d4a:	30 20       	mov	r0,2
80007d4c:	c0 88       	rjmp	80007d5c <get_arg+0x17c>
80007d4e:	30 40       	mov	r0,4
80007d50:	c0 68       	rjmp	80007d5c <get_arg+0x17c>
80007d52:	30 30       	mov	r0,3
80007d54:	c0 48       	rjmp	80007d5c <get_arg+0x17c>
80007d56:	30 10       	mov	r0,1
80007d58:	c0 28       	rjmp	80007d5c <get_arg+0x17c>
80007d5a:	30 00       	mov	r0,0
80007d5c:	40 3b       	lddsp	r11,sp[0xc]
80007d5e:	5b fb       	cp.w	r11,-1
80007d60:	c0 40       	breq	80007d68 <get_arg+0x188>
80007d62:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80007d66:	c7 08       	rjmp	80007e46 <get_arg+0x266>
80007d68:	58 60       	cp.w	r0,6
80007d6a:	e0 8b 00 6e 	brhi	80007e46 <get_arg+0x266>
80007d6e:	6c 0a       	ld.w	r10,r6[0x0]
80007d70:	ea cc ff ff 	sub	r12,r5,-1
80007d74:	fe ce a2 60 	sub	lr,pc,-23968
80007d78:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80007d7c:	f4 cb ff f8 	sub	r11,r10,-8
80007d80:	8d 0b       	st.w	r6[0x0],r11
80007d82:	f4 ea 00 00 	ld.d	r10,r10[0]
80007d86:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007d8a:	c0 f8       	rjmp	80007da8 <get_arg+0x1c8>
80007d8c:	f4 cb ff fc 	sub	r11,r10,-4
80007d90:	8d 0b       	st.w	r6[0x0],r11
80007d92:	74 0a       	ld.w	r10,r10[0x0]
80007d94:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007d98:	c0 88       	rjmp	80007da8 <get_arg+0x1c8>
80007d9a:	f4 cb ff f8 	sub	r11,r10,-8
80007d9e:	8d 0b       	st.w	r6[0x0],r11
80007da0:	f4 ea 00 00 	ld.d	r10,r10[0]
80007da4:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80007da8:	0e 9b       	mov	r11,r7
80007daa:	18 95       	mov	r5,r12
80007dac:	c4 e8       	rjmp	80007e48 <get_arg+0x268>
80007dae:	62 0a       	ld.w	r10,r1[0x0]
80007db0:	5b fa       	cp.w	r10,-1
80007db2:	c0 b1       	brne	80007dc8 <get_arg+0x1e8>
80007db4:	50 19       	stdsp	sp[0x4],r9
80007db6:	50 28       	stdsp	sp[0x8],r8
80007db8:	e0 6a 00 80 	mov	r10,128
80007dbc:	30 0b       	mov	r11,0
80007dbe:	02 9c       	mov	r12,r1
80007dc0:	fe b0 fd 00 	rcall	800077c0 <memset>
80007dc4:	40 28       	lddsp	r8,sp[0x8]
80007dc6:	40 19       	lddsp	r9,sp[0x4]
80007dc8:	e4 cc 00 01 	sub	r12,r2,1
80007dcc:	0e 9b       	mov	r11,r7
80007dce:	50 3c       	stdsp	sp[0xc],r12
80007dd0:	f2 0c 0c 49 	max	r9,r9,r12
80007dd4:	c3 a8       	rjmp	80007e48 <get_arg+0x268>
80007dd6:	62 0a       	ld.w	r10,r1[0x0]
80007dd8:	5b fa       	cp.w	r10,-1
80007dda:	c0 b1       	brne	80007df0 <get_arg+0x210>
80007ddc:	50 19       	stdsp	sp[0x4],r9
80007dde:	50 28       	stdsp	sp[0x8],r8
80007de0:	e0 6a 00 80 	mov	r10,128
80007de4:	30 0b       	mov	r11,0
80007de6:	02 9c       	mov	r12,r1
80007de8:	fe b0 fc ec 	rcall	800077c0 <memset>
80007dec:	40 28       	lddsp	r8,sp[0x8]
80007dee:	40 19       	lddsp	r9,sp[0x4]
80007df0:	20 12       	sub	r2,1
80007df2:	30 0a       	mov	r10,0
80007df4:	0e 9b       	mov	r11,r7
80007df6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80007dfa:	f2 02 0c 49 	max	r9,r9,r2
80007dfe:	c2 58       	rjmp	80007e48 <get_arg+0x268>
80007e00:	16 97       	mov	r7,r11
80007e02:	6c 0a       	ld.w	r10,r6[0x0]
80007e04:	f4 cb ff fc 	sub	r11,r10,-4
80007e08:	8d 0b       	st.w	r6[0x0],r11
80007e0a:	74 0a       	ld.w	r10,r10[0x0]
80007e0c:	0e 9b       	mov	r11,r7
80007e0e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80007e12:	2f f5       	sub	r5,-1
80007e14:	c1 a8       	rjmp	80007e48 <get_arg+0x268>
80007e16:	f4 c2 00 30 	sub	r2,r10,48
80007e1a:	c0 68       	rjmp	80007e26 <get_arg+0x246>
80007e1c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80007e20:	2f f7       	sub	r7,-1
80007e22:	f4 02 00 12 	add	r2,r10,r2<<0x1
80007e26:	0f 8a       	ld.ub	r10,r7[0x0]
80007e28:	58 0a       	cp.w	r10,0
80007e2a:	c0 e0       	breq	80007e46 <get_arg+0x266>
80007e2c:	23 0a       	sub	r10,48
80007e2e:	58 9a       	cp.w	r10,9
80007e30:	fe 98 ff f6 	brls	80007e1c <get_arg+0x23c>
80007e34:	c0 98       	rjmp	80007e46 <get_arg+0x266>
80007e36:	2f f7       	sub	r7,-1
80007e38:	0f 8a       	ld.ub	r10,r7[0x0]
80007e3a:	58 0a       	cp.w	r10,0
80007e3c:	c0 50       	breq	80007e46 <get_arg+0x266>
80007e3e:	23 0a       	sub	r10,48
80007e40:	58 9a       	cp.w	r10,9
80007e42:	fe 98 ff fa 	brls	80007e36 <get_arg+0x256>
80007e46:	0e 9b       	mov	r11,r7
80007e48:	40 7c       	lddsp	r12,sp[0x1c]
80007e4a:	30 ba       	mov	r10,11
80007e4c:	f4 0c 18 00 	cp.b	r12,r10
80007e50:	fe 91 fe f2 	brne	80007c34 <get_arg+0x54>
80007e54:	40 42       	lddsp	r2,sp[0x10]
80007e56:	17 8c       	ld.ub	r12,r11[0x0]
80007e58:	0a 32       	cp.w	r2,r5
80007e5a:	5f 4a       	srge	r10
80007e5c:	f0 0c 18 00 	cp.b	r12,r8
80007e60:	5f 1c       	srne	r12
80007e62:	f9 ea 00 0a 	and	r10,r12,r10
80007e66:	f0 0a 18 00 	cp.b	r10,r8
80007e6a:	fe 91 fe cf 	brne	80007c08 <get_arg+0x28>
80007e6e:	30 08       	mov	r8,0
80007e70:	40 4e       	lddsp	lr,sp[0x10]
80007e72:	17 8a       	ld.ub	r10,r11[0x0]
80007e74:	e2 05 00 21 	add	r1,r1,r5<<0x2
80007e78:	f0 0a 18 00 	cp.b	r10,r8
80007e7c:	fc 09 17 10 	movne	r9,lr
80007e80:	e6 05 00 38 	add	r8,r3,r5<<0x3
80007e84:	06 9e       	mov	lr,r3
80007e86:	c2 a8       	rjmp	80007eda <get_arg+0x2fa>
80007e88:	62 0a       	ld.w	r10,r1[0x0]
80007e8a:	58 3a       	cp.w	r10,3
80007e8c:	c1 e0       	breq	80007ec8 <get_arg+0x2e8>
80007e8e:	e0 89 00 07 	brgt	80007e9c <get_arg+0x2bc>
80007e92:	58 1a       	cp.w	r10,1
80007e94:	c1 a0       	breq	80007ec8 <get_arg+0x2e8>
80007e96:	58 2a       	cp.w	r10,2
80007e98:	c1 81       	brne	80007ec8 <get_arg+0x2e8>
80007e9a:	c0 58       	rjmp	80007ea4 <get_arg+0x2c4>
80007e9c:	58 5a       	cp.w	r10,5
80007e9e:	c0 c0       	breq	80007eb6 <get_arg+0x2d6>
80007ea0:	c0 b5       	brlt	80007eb6 <get_arg+0x2d6>
80007ea2:	c1 38       	rjmp	80007ec8 <get_arg+0x2e8>
80007ea4:	6c 0a       	ld.w	r10,r6[0x0]
80007ea6:	f4 cc ff f8 	sub	r12,r10,-8
80007eaa:	8d 0c       	st.w	r6[0x0],r12
80007eac:	f4 e2 00 00 	ld.d	r2,r10[0]
80007eb0:	f0 e3 00 00 	st.d	r8[0],r2
80007eb4:	c1 08       	rjmp	80007ed4 <get_arg+0x2f4>
80007eb6:	6c 0a       	ld.w	r10,r6[0x0]
80007eb8:	f4 cc ff f8 	sub	r12,r10,-8
80007ebc:	8d 0c       	st.w	r6[0x0],r12
80007ebe:	f4 e2 00 00 	ld.d	r2,r10[0]
80007ec2:	f0 e3 00 00 	st.d	r8[0],r2
80007ec6:	c0 78       	rjmp	80007ed4 <get_arg+0x2f4>
80007ec8:	6c 0a       	ld.w	r10,r6[0x0]
80007eca:	f4 cc ff fc 	sub	r12,r10,-4
80007ece:	8d 0c       	st.w	r6[0x0],r12
80007ed0:	74 0a       	ld.w	r10,r10[0x0]
80007ed2:	91 0a       	st.w	r8[0x0],r10
80007ed4:	2f f5       	sub	r5,-1
80007ed6:	2f 88       	sub	r8,-8
80007ed8:	2f c1       	sub	r1,-4
80007eda:	12 35       	cp.w	r5,r9
80007edc:	fe 9a ff d6 	brle	80007e88 <get_arg+0x2a8>
80007ee0:	1c 93       	mov	r3,lr
80007ee2:	40 52       	lddsp	r2,sp[0x14]
80007ee4:	40 6e       	lddsp	lr,sp[0x18]
80007ee6:	85 05       	st.w	r2[0x0],r5
80007ee8:	9d 0b       	st.w	lr[0x0],r11
80007eea:	40 4b       	lddsp	r11,sp[0x10]
80007eec:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80007ef0:	2f 8d       	sub	sp,-32
80007ef2:	d8 32       	popm	r0-r7,pc

80007ef4 <__sprint_r>:
80007ef4:	d4 21       	pushm	r4-r7,lr
80007ef6:	14 97       	mov	r7,r10
80007ef8:	74 28       	ld.w	r8,r10[0x8]
80007efa:	58 08       	cp.w	r8,0
80007efc:	c0 41       	brne	80007f04 <__sprint_r+0x10>
80007efe:	95 18       	st.w	r10[0x4],r8
80007f00:	10 9c       	mov	r12,r8
80007f02:	d8 22       	popm	r4-r7,pc
80007f04:	e0 a0 18 ba 	rcall	8000b078 <__sfvwrite_r>
80007f08:	30 08       	mov	r8,0
80007f0a:	8f 18       	st.w	r7[0x4],r8
80007f0c:	8f 28       	st.w	r7[0x8],r8
80007f0e:	d8 22       	popm	r4-r7,pc

80007f10 <_vfprintf_r>:
80007f10:	d4 31       	pushm	r0-r7,lr
80007f12:	fa cd 06 bc 	sub	sp,sp,1724
80007f16:	51 09       	stdsp	sp[0x40],r9
80007f18:	16 91       	mov	r1,r11
80007f1a:	14 97       	mov	r7,r10
80007f1c:	18 95       	mov	r5,r12
80007f1e:	e0 a0 1a 1d 	rcall	8000b358 <_localeconv_r>
80007f22:	78 0c       	ld.w	r12,r12[0x0]
80007f24:	50 cc       	stdsp	sp[0x30],r12
80007f26:	58 05       	cp.w	r5,0
80007f28:	c0 70       	breq	80007f36 <_vfprintf_r+0x26>
80007f2a:	6a 68       	ld.w	r8,r5[0x18]
80007f2c:	58 08       	cp.w	r8,0
80007f2e:	c0 41       	brne	80007f36 <_vfprintf_r+0x26>
80007f30:	0a 9c       	mov	r12,r5
80007f32:	e0 a0 17 43 	rcall	8000adb8 <__sinit>
80007f36:	fe c8 a0 5e 	sub	r8,pc,-24482
80007f3a:	10 31       	cp.w	r1,r8
80007f3c:	c0 31       	brne	80007f42 <_vfprintf_r+0x32>
80007f3e:	6a 01       	ld.w	r1,r5[0x0]
80007f40:	c0 c8       	rjmp	80007f58 <_vfprintf_r+0x48>
80007f42:	fe c8 a0 4a 	sub	r8,pc,-24502
80007f46:	10 31       	cp.w	r1,r8
80007f48:	c0 31       	brne	80007f4e <_vfprintf_r+0x3e>
80007f4a:	6a 11       	ld.w	r1,r5[0x4]
80007f4c:	c0 68       	rjmp	80007f58 <_vfprintf_r+0x48>
80007f4e:	fe c8 a0 36 	sub	r8,pc,-24522
80007f52:	10 31       	cp.w	r1,r8
80007f54:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80007f58:	82 68       	ld.sh	r8,r1[0xc]
80007f5a:	ed b8 00 03 	bld	r8,0x3
80007f5e:	c0 41       	brne	80007f66 <_vfprintf_r+0x56>
80007f60:	62 48       	ld.w	r8,r1[0x10]
80007f62:	58 08       	cp.w	r8,0
80007f64:	c0 71       	brne	80007f72 <_vfprintf_r+0x62>
80007f66:	02 9b       	mov	r11,r1
80007f68:	0a 9c       	mov	r12,r5
80007f6a:	e0 a0 0f 5d 	rcall	80009e24 <__swsetup_r>
80007f6e:	e0 81 0f 54 	brne	80009e16 <_vfprintf_r+0x1f06>
80007f72:	82 68       	ld.sh	r8,r1[0xc]
80007f74:	10 99       	mov	r9,r8
80007f76:	e2 19 00 1a 	andl	r9,0x1a,COH
80007f7a:	58 a9       	cp.w	r9,10
80007f7c:	c3 c1       	brne	80007ff4 <_vfprintf_r+0xe4>
80007f7e:	82 79       	ld.sh	r9,r1[0xe]
80007f80:	30 0a       	mov	r10,0
80007f82:	f4 09 19 00 	cp.h	r9,r10
80007f86:	c3 75       	brlt	80007ff4 <_vfprintf_r+0xe4>
80007f88:	a1 d8       	cbr	r8,0x1
80007f8a:	fb 58 05 d0 	st.h	sp[1488],r8
80007f8e:	62 88       	ld.w	r8,r1[0x20]
80007f90:	fb 48 05 e4 	st.w	sp[1508],r8
80007f94:	62 a8       	ld.w	r8,r1[0x28]
80007f96:	fb 48 05 ec 	st.w	sp[1516],r8
80007f9a:	fa c8 ff bc 	sub	r8,sp,-68
80007f9e:	fb 48 05 d4 	st.w	sp[1492],r8
80007fa2:	fb 48 05 c4 	st.w	sp[1476],r8
80007fa6:	e0 68 04 00 	mov	r8,1024
80007faa:	fb 48 05 d8 	st.w	sp[1496],r8
80007fae:	fb 48 05 cc 	st.w	sp[1484],r8
80007fb2:	30 08       	mov	r8,0
80007fb4:	fb 59 05 d2 	st.h	sp[1490],r9
80007fb8:	0e 9a       	mov	r10,r7
80007fba:	41 09       	lddsp	r9,sp[0x40]
80007fbc:	fa c7 fa 3c 	sub	r7,sp,-1476
80007fc0:	fb 48 05 dc 	st.w	sp[1500],r8
80007fc4:	0a 9c       	mov	r12,r5
80007fc6:	0e 9b       	mov	r11,r7
80007fc8:	ca 4f       	rcall	80007f10 <_vfprintf_r>
80007fca:	50 bc       	stdsp	sp[0x2c],r12
80007fcc:	c0 95       	brlt	80007fde <_vfprintf_r+0xce>
80007fce:	0e 9b       	mov	r11,r7
80007fd0:	0a 9c       	mov	r12,r5
80007fd2:	e0 a0 16 1b 	rcall	8000ac08 <_fflush_r>
80007fd6:	40 be       	lddsp	lr,sp[0x2c]
80007fd8:	f9 be 01 ff 	movne	lr,-1
80007fdc:	50 be       	stdsp	sp[0x2c],lr
80007fde:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80007fe2:	ed b8 00 06 	bld	r8,0x6
80007fe6:	e0 81 0f 1a 	brne	80009e1a <_vfprintf_r+0x1f0a>
80007fea:	82 68       	ld.sh	r8,r1[0xc]
80007fec:	a7 a8       	sbr	r8,0x6
80007fee:	a2 68       	st.h	r1[0xc],r8
80007ff0:	e0 8f 0f 15 	bral	80009e1a <_vfprintf_r+0x1f0a>
80007ff4:	30 08       	mov	r8,0
80007ff6:	fb 48 06 b4 	st.w	sp[1716],r8
80007ffa:	fb 48 06 90 	st.w	sp[1680],r8
80007ffe:	fb 48 06 8c 	st.w	sp[1676],r8
80008002:	fb 48 06 b0 	st.w	sp[1712],r8
80008006:	30 08       	mov	r8,0
80008008:	30 09       	mov	r9,0
8000800a:	50 a7       	stdsp	sp[0x28],r7
8000800c:	50 78       	stdsp	sp[0x1c],r8
8000800e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008012:	3f f8       	mov	r8,-1
80008014:	50 59       	stdsp	sp[0x14],r9
80008016:	fb 43 06 88 	st.w	sp[1672],r3
8000801a:	fb 48 05 44 	st.w	sp[1348],r8
8000801e:	12 9c       	mov	r12,r9
80008020:	50 69       	stdsp	sp[0x18],r9
80008022:	50 d9       	stdsp	sp[0x34],r9
80008024:	50 e9       	stdsp	sp[0x38],r9
80008026:	50 b9       	stdsp	sp[0x2c],r9
80008028:	12 97       	mov	r7,r9
8000802a:	0a 94       	mov	r4,r5
8000802c:	40 a2       	lddsp	r2,sp[0x28]
8000802e:	32 5a       	mov	r10,37
80008030:	30 08       	mov	r8,0
80008032:	c0 28       	rjmp	80008036 <_vfprintf_r+0x126>
80008034:	2f f2       	sub	r2,-1
80008036:	05 89       	ld.ub	r9,r2[0x0]
80008038:	f0 09 18 00 	cp.b	r9,r8
8000803c:	5f 1b       	srne	r11
8000803e:	f4 09 18 00 	cp.b	r9,r10
80008042:	5f 19       	srne	r9
80008044:	f3 eb 00 0b 	and	r11,r9,r11
80008048:	f0 0b 18 00 	cp.b	r11,r8
8000804c:	cf 41       	brne	80008034 <_vfprintf_r+0x124>
8000804e:	40 ab       	lddsp	r11,sp[0x28]
80008050:	e4 0b 01 06 	sub	r6,r2,r11
80008054:	c1 e0       	breq	80008090 <_vfprintf_r+0x180>
80008056:	fa f8 06 90 	ld.w	r8,sp[1680]
8000805a:	0c 08       	add	r8,r6
8000805c:	87 0b       	st.w	r3[0x0],r11
8000805e:	fb 48 06 90 	st.w	sp[1680],r8
80008062:	87 16       	st.w	r3[0x4],r6
80008064:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008068:	2f f8       	sub	r8,-1
8000806a:	fb 48 06 8c 	st.w	sp[1676],r8
8000806e:	58 78       	cp.w	r8,7
80008070:	e0 89 00 04 	brgt	80008078 <_vfprintf_r+0x168>
80008074:	2f 83       	sub	r3,-8
80008076:	c0 a8       	rjmp	8000808a <_vfprintf_r+0x17a>
80008078:	fa ca f9 78 	sub	r10,sp,-1672
8000807c:	02 9b       	mov	r11,r1
8000807e:	08 9c       	mov	r12,r4
80008080:	c3 af       	rcall	80007ef4 <__sprint_r>
80008082:	e0 81 0e c6 	brne	80009e0e <_vfprintf_r+0x1efe>
80008086:	fa c3 f9 e0 	sub	r3,sp,-1568
8000808a:	40 ba       	lddsp	r10,sp[0x2c]
8000808c:	0c 0a       	add	r10,r6
8000808e:	50 ba       	stdsp	sp[0x2c],r10
80008090:	05 89       	ld.ub	r9,r2[0x0]
80008092:	30 08       	mov	r8,0
80008094:	f0 09 18 00 	cp.b	r9,r8
80008098:	e0 80 0e aa 	breq	80009dec <_vfprintf_r+0x1edc>
8000809c:	30 09       	mov	r9,0
8000809e:	fb 68 06 bb 	st.b	sp[1723],r8
800080a2:	0e 96       	mov	r6,r7
800080a4:	e4 c8 ff ff 	sub	r8,r2,-1
800080a8:	3f fe       	mov	lr,-1
800080aa:	50 93       	stdsp	sp[0x24],r3
800080ac:	50 41       	stdsp	sp[0x10],r1
800080ae:	0e 93       	mov	r3,r7
800080b0:	04 91       	mov	r1,r2
800080b2:	50 89       	stdsp	sp[0x20],r9
800080b4:	50 a8       	stdsp	sp[0x28],r8
800080b6:	50 2e       	stdsp	sp[0x8],lr
800080b8:	50 39       	stdsp	sp[0xc],r9
800080ba:	12 95       	mov	r5,r9
800080bc:	12 90       	mov	r0,r9
800080be:	10 97       	mov	r7,r8
800080c0:	08 92       	mov	r2,r4
800080c2:	c0 78       	rjmp	800080d0 <_vfprintf_r+0x1c0>
800080c4:	3f fc       	mov	r12,-1
800080c6:	08 97       	mov	r7,r4
800080c8:	50 2c       	stdsp	sp[0x8],r12
800080ca:	c0 38       	rjmp	800080d0 <_vfprintf_r+0x1c0>
800080cc:	30 0b       	mov	r11,0
800080ce:	50 3b       	stdsp	sp[0xc],r11
800080d0:	0f 38       	ld.ub	r8,r7++
800080d2:	c0 28       	rjmp	800080d6 <_vfprintf_r+0x1c6>
800080d4:	12 90       	mov	r0,r9
800080d6:	f0 c9 00 20 	sub	r9,r8,32
800080da:	e0 49 00 58 	cp.w	r9,88
800080de:	e0 8b 0a 30 	brhi	8000953e <_vfprintf_r+0x162e>
800080e2:	fe ca a5 b2 	sub	r10,pc,-23118
800080e6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800080ea:	50 a7       	stdsp	sp[0x28],r7
800080ec:	50 80       	stdsp	sp[0x20],r0
800080ee:	0c 97       	mov	r7,r6
800080f0:	04 94       	mov	r4,r2
800080f2:	06 96       	mov	r6,r3
800080f4:	02 92       	mov	r2,r1
800080f6:	fe c9 a3 8a 	sub	r9,pc,-23670
800080fa:	40 93       	lddsp	r3,sp[0x24]
800080fc:	10 90       	mov	r0,r8
800080fe:	40 41       	lddsp	r1,sp[0x10]
80008100:	50 d9       	stdsp	sp[0x34],r9
80008102:	e0 8f 08 8e 	bral	8000921e <_vfprintf_r+0x130e>
80008106:	30 08       	mov	r8,0
80008108:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000810c:	f0 09 18 00 	cp.b	r9,r8
80008110:	ce 01       	brne	800080d0 <_vfprintf_r+0x1c0>
80008112:	32 08       	mov	r8,32
80008114:	c6 e8       	rjmp	800081f0 <_vfprintf_r+0x2e0>
80008116:	a1 a5       	sbr	r5,0x0
80008118:	cd cb       	rjmp	800080d0 <_vfprintf_r+0x1c0>
8000811a:	0f 89       	ld.ub	r9,r7[0x0]
8000811c:	f2 c8 00 30 	sub	r8,r9,48
80008120:	58 98       	cp.w	r8,9
80008122:	e0 8b 00 1d 	brhi	8000815c <_vfprintf_r+0x24c>
80008126:	ee c8 ff ff 	sub	r8,r7,-1
8000812a:	30 0b       	mov	r11,0
8000812c:	23 09       	sub	r9,48
8000812e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008132:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80008136:	11 39       	ld.ub	r9,r8++
80008138:	f2 ca 00 30 	sub	r10,r9,48
8000813c:	58 9a       	cp.w	r10,9
8000813e:	fe 98 ff f7 	brls	8000812c <_vfprintf_r+0x21c>
80008142:	e0 49 00 24 	cp.w	r9,36
80008146:	cc 31       	brne	800080cc <_vfprintf_r+0x1bc>
80008148:	e0 4b 00 20 	cp.w	r11,32
8000814c:	e0 89 0e 60 	brgt	80009e0c <_vfprintf_r+0x1efc>
80008150:	20 1b       	sub	r11,1
80008152:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008156:	12 3b       	cp.w	r11,r9
80008158:	c0 95       	brlt	8000816a <_vfprintf_r+0x25a>
8000815a:	c1 08       	rjmp	8000817a <_vfprintf_r+0x26a>
8000815c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008160:	ec ca ff ff 	sub	r10,r6,-1
80008164:	12 36       	cp.w	r6,r9
80008166:	c1 f5       	brlt	800081a4 <_vfprintf_r+0x294>
80008168:	c2 68       	rjmp	800081b4 <_vfprintf_r+0x2a4>
8000816a:	fa ce f9 44 	sub	lr,sp,-1724
8000816e:	10 97       	mov	r7,r8
80008170:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008174:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008178:	c3 58       	rjmp	800081e2 <_vfprintf_r+0x2d2>
8000817a:	10 97       	mov	r7,r8
8000817c:	fa c8 f9 50 	sub	r8,sp,-1712
80008180:	1a d8       	st.w	--sp,r8
80008182:	fa c8 fa b8 	sub	r8,sp,-1352
80008186:	1a d8       	st.w	--sp,r8
80008188:	fa c8 fb b4 	sub	r8,sp,-1100
8000818c:	02 9a       	mov	r10,r1
8000818e:	1a d8       	st.w	--sp,r8
80008190:	04 9c       	mov	r12,r2
80008192:	fa c8 f9 40 	sub	r8,sp,-1728
80008196:	fa c9 ff b4 	sub	r9,sp,-76
8000819a:	fe b0 fd 23 	rcall	80007be0 <get_arg>
8000819e:	2f dd       	sub	sp,-12
800081a0:	78 00       	ld.w	r0,r12[0x0]
800081a2:	c2 08       	rjmp	800081e2 <_vfprintf_r+0x2d2>
800081a4:	fa cc f9 44 	sub	r12,sp,-1724
800081a8:	14 96       	mov	r6,r10
800081aa:	f8 03 00 38 	add	r8,r12,r3<<0x3
800081ae:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800081b2:	c1 88       	rjmp	800081e2 <_vfprintf_r+0x2d2>
800081b4:	41 08       	lddsp	r8,sp[0x40]
800081b6:	59 f9       	cp.w	r9,31
800081b8:	e0 89 00 11 	brgt	800081da <_vfprintf_r+0x2ca>
800081bc:	f0 cb ff fc 	sub	r11,r8,-4
800081c0:	51 0b       	stdsp	sp[0x40],r11
800081c2:	70 00       	ld.w	r0,r8[0x0]
800081c4:	fa cb f9 44 	sub	r11,sp,-1724
800081c8:	f6 09 00 38 	add	r8,r11,r9<<0x3
800081cc:	f1 40 fd 88 	st.w	r8[-632],r0
800081d0:	2f f9       	sub	r9,-1
800081d2:	14 96       	mov	r6,r10
800081d4:	fb 49 06 b4 	st.w	sp[1716],r9
800081d8:	c0 58       	rjmp	800081e2 <_vfprintf_r+0x2d2>
800081da:	70 00       	ld.w	r0,r8[0x0]
800081dc:	14 96       	mov	r6,r10
800081de:	2f c8       	sub	r8,-4
800081e0:	51 08       	stdsp	sp[0x40],r8
800081e2:	58 00       	cp.w	r0,0
800081e4:	fe 94 ff 76 	brge	800080d0 <_vfprintf_r+0x1c0>
800081e8:	5c 30       	neg	r0
800081ea:	a3 a5       	sbr	r5,0x2
800081ec:	c7 2b       	rjmp	800080d0 <_vfprintf_r+0x1c0>
800081ee:	32 b8       	mov	r8,43
800081f0:	fb 68 06 bb 	st.b	sp[1723],r8
800081f4:	c6 eb       	rjmp	800080d0 <_vfprintf_r+0x1c0>
800081f6:	0f 38       	ld.ub	r8,r7++
800081f8:	e0 48 00 2a 	cp.w	r8,42
800081fc:	c0 30       	breq	80008202 <_vfprintf_r+0x2f2>
800081fe:	30 09       	mov	r9,0
80008200:	c7 98       	rjmp	800082f2 <_vfprintf_r+0x3e2>
80008202:	0f 88       	ld.ub	r8,r7[0x0]
80008204:	f0 c9 00 30 	sub	r9,r8,48
80008208:	58 99       	cp.w	r9,9
8000820a:	e0 8b 00 1f 	brhi	80008248 <_vfprintf_r+0x338>
8000820e:	ee c4 ff ff 	sub	r4,r7,-1
80008212:	30 0b       	mov	r11,0
80008214:	23 08       	sub	r8,48
80008216:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000821a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000821e:	09 38       	ld.ub	r8,r4++
80008220:	f0 c9 00 30 	sub	r9,r8,48
80008224:	58 99       	cp.w	r9,9
80008226:	fe 98 ff f7 	brls	80008214 <_vfprintf_r+0x304>
8000822a:	e0 48 00 24 	cp.w	r8,36
8000822e:	fe 91 ff 4f 	brne	800080cc <_vfprintf_r+0x1bc>
80008232:	e0 4b 00 20 	cp.w	r11,32
80008236:	e0 89 0d eb 	brgt	80009e0c <_vfprintf_r+0x1efc>
8000823a:	20 1b       	sub	r11,1
8000823c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008240:	10 3b       	cp.w	r11,r8
80008242:	c0 a5       	brlt	80008256 <_vfprintf_r+0x346>
80008244:	c1 18       	rjmp	80008266 <_vfprintf_r+0x356>
80008246:	d7 03       	nop
80008248:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000824c:	ec c9 ff ff 	sub	r9,r6,-1
80008250:	14 36       	cp.w	r6,r10
80008252:	c1 f5       	brlt	80008290 <_vfprintf_r+0x380>
80008254:	c2 88       	rjmp	800082a4 <_vfprintf_r+0x394>
80008256:	fa ca f9 44 	sub	r10,sp,-1724
8000825a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000825e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008262:	50 2b       	stdsp	sp[0x8],r11
80008264:	c3 c8       	rjmp	800082dc <_vfprintf_r+0x3cc>
80008266:	fa c8 f9 50 	sub	r8,sp,-1712
8000826a:	1a d8       	st.w	--sp,r8
8000826c:	fa c8 fa b8 	sub	r8,sp,-1352
80008270:	1a d8       	st.w	--sp,r8
80008272:	fa c8 fb b4 	sub	r8,sp,-1100
80008276:	02 9a       	mov	r10,r1
80008278:	1a d8       	st.w	--sp,r8
8000827a:	04 9c       	mov	r12,r2
8000827c:	fa c8 f9 40 	sub	r8,sp,-1728
80008280:	fa c9 ff b4 	sub	r9,sp,-76
80008284:	fe b0 fc ae 	rcall	80007be0 <get_arg>
80008288:	2f dd       	sub	sp,-12
8000828a:	78 0c       	ld.w	r12,r12[0x0]
8000828c:	50 2c       	stdsp	sp[0x8],r12
8000828e:	c2 78       	rjmp	800082dc <_vfprintf_r+0x3cc>
80008290:	12 96       	mov	r6,r9
80008292:	0e 94       	mov	r4,r7
80008294:	fa c9 f9 44 	sub	r9,sp,-1724
80008298:	f2 03 00 38 	add	r8,r9,r3<<0x3
8000829c:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800082a0:	50 28       	stdsp	sp[0x8],r8
800082a2:	c1 d8       	rjmp	800082dc <_vfprintf_r+0x3cc>
800082a4:	41 08       	lddsp	r8,sp[0x40]
800082a6:	59 fa       	cp.w	r10,31
800082a8:	e0 89 00 14 	brgt	800082d0 <_vfprintf_r+0x3c0>
800082ac:	f0 cb ff fc 	sub	r11,r8,-4
800082b0:	70 08       	ld.w	r8,r8[0x0]
800082b2:	51 0b       	stdsp	sp[0x40],r11
800082b4:	50 28       	stdsp	sp[0x8],r8
800082b6:	fa c6 f9 44 	sub	r6,sp,-1724
800082ba:	40 2e       	lddsp	lr,sp[0x8]
800082bc:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800082c0:	f1 4e fd 88 	st.w	r8[-632],lr
800082c4:	2f fa       	sub	r10,-1
800082c6:	0e 94       	mov	r4,r7
800082c8:	fb 4a 06 b4 	st.w	sp[1716],r10
800082cc:	12 96       	mov	r6,r9
800082ce:	c0 78       	rjmp	800082dc <_vfprintf_r+0x3cc>
800082d0:	70 0c       	ld.w	r12,r8[0x0]
800082d2:	0e 94       	mov	r4,r7
800082d4:	2f c8       	sub	r8,-4
800082d6:	50 2c       	stdsp	sp[0x8],r12
800082d8:	12 96       	mov	r6,r9
800082da:	51 08       	stdsp	sp[0x40],r8
800082dc:	40 2b       	lddsp	r11,sp[0x8]
800082de:	58 0b       	cp.w	r11,0
800082e0:	fe 95 fe f2 	brlt	800080c4 <_vfprintf_r+0x1b4>
800082e4:	08 97       	mov	r7,r4
800082e6:	cf 5a       	rjmp	800080d0 <_vfprintf_r+0x1c0>
800082e8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800082ec:	0f 38       	ld.ub	r8,r7++
800082ee:	f4 09 00 19 	add	r9,r10,r9<<0x1
800082f2:	f0 ca 00 30 	sub	r10,r8,48
800082f6:	58 9a       	cp.w	r10,9
800082f8:	fe 98 ff f8 	brls	800082e8 <_vfprintf_r+0x3d8>
800082fc:	3f fa       	mov	r10,-1
800082fe:	f2 0a 0c 49 	max	r9,r9,r10
80008302:	50 29       	stdsp	sp[0x8],r9
80008304:	ce 9a       	rjmp	800080d6 <_vfprintf_r+0x1c6>
80008306:	a7 b5       	sbr	r5,0x7
80008308:	ce 4a       	rjmp	800080d0 <_vfprintf_r+0x1c0>
8000830a:	30 09       	mov	r9,0
8000830c:	23 08       	sub	r8,48
8000830e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008312:	f0 09 00 19 	add	r9,r8,r9<<0x1
80008316:	0f 38       	ld.ub	r8,r7++
80008318:	f0 ca 00 30 	sub	r10,r8,48
8000831c:	58 9a       	cp.w	r10,9
8000831e:	fe 98 ff f7 	brls	8000830c <_vfprintf_r+0x3fc>
80008322:	e0 48 00 24 	cp.w	r8,36
80008326:	fe 91 fe d7 	brne	800080d4 <_vfprintf_r+0x1c4>
8000832a:	e0 49 00 20 	cp.w	r9,32
8000832e:	e0 89 0d 6f 	brgt	80009e0c <_vfprintf_r+0x1efc>
80008332:	f2 c3 00 01 	sub	r3,r9,1
80008336:	30 19       	mov	r9,1
80008338:	50 39       	stdsp	sp[0xc],r9
8000833a:	cc ba       	rjmp	800080d0 <_vfprintf_r+0x1c0>
8000833c:	a3 b5       	sbr	r5,0x3
8000833e:	cc 9a       	rjmp	800080d0 <_vfprintf_r+0x1c0>
80008340:	a7 a5       	sbr	r5,0x6
80008342:	cc 7a       	rjmp	800080d0 <_vfprintf_r+0x1c0>
80008344:	0a 98       	mov	r8,r5
80008346:	a5 b5       	sbr	r5,0x5
80008348:	a5 a8       	sbr	r8,0x4
8000834a:	0f 89       	ld.ub	r9,r7[0x0]
8000834c:	36 ce       	mov	lr,108
8000834e:	fc 09 18 00 	cp.b	r9,lr
80008352:	f7 b7 00 ff 	subeq	r7,-1
80008356:	f0 05 17 10 	movne	r5,r8
8000835a:	cb ba       	rjmp	800080d0 <_vfprintf_r+0x1c0>
8000835c:	a5 b5       	sbr	r5,0x5
8000835e:	cb 9a       	rjmp	800080d0 <_vfprintf_r+0x1c0>
80008360:	50 a7       	stdsp	sp[0x28],r7
80008362:	50 80       	stdsp	sp[0x20],r0
80008364:	0c 97       	mov	r7,r6
80008366:	10 90       	mov	r0,r8
80008368:	06 96       	mov	r6,r3
8000836a:	04 94       	mov	r4,r2
8000836c:	40 93       	lddsp	r3,sp[0x24]
8000836e:	02 92       	mov	r2,r1
80008370:	0e 99       	mov	r9,r7
80008372:	40 41       	lddsp	r1,sp[0x10]
80008374:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008378:	40 3c       	lddsp	r12,sp[0xc]
8000837a:	58 0c       	cp.w	r12,0
8000837c:	c1 d0       	breq	800083b6 <_vfprintf_r+0x4a6>
8000837e:	10 36       	cp.w	r6,r8
80008380:	c0 64       	brge	8000838c <_vfprintf_r+0x47c>
80008382:	fa cb f9 44 	sub	r11,sp,-1724
80008386:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000838a:	c1 d8       	rjmp	800083c4 <_vfprintf_r+0x4b4>
8000838c:	fa c8 f9 50 	sub	r8,sp,-1712
80008390:	1a d8       	st.w	--sp,r8
80008392:	fa c8 fa b8 	sub	r8,sp,-1352
80008396:	1a d8       	st.w	--sp,r8
80008398:	fa c8 fb b4 	sub	r8,sp,-1100
8000839c:	1a d8       	st.w	--sp,r8
8000839e:	fa c8 f9 40 	sub	r8,sp,-1728
800083a2:	fa c9 ff b4 	sub	r9,sp,-76
800083a6:	04 9a       	mov	r10,r2
800083a8:	0c 9b       	mov	r11,r6
800083aa:	08 9c       	mov	r12,r4
800083ac:	fe b0 fc 1a 	rcall	80007be0 <get_arg>
800083b0:	2f dd       	sub	sp,-12
800083b2:	19 b8       	ld.ub	r8,r12[0x3]
800083b4:	c2 28       	rjmp	800083f8 <_vfprintf_r+0x4e8>
800083b6:	2f f7       	sub	r7,-1
800083b8:	10 39       	cp.w	r9,r8
800083ba:	c0 84       	brge	800083ca <_vfprintf_r+0x4ba>
800083bc:	fa ca f9 44 	sub	r10,sp,-1724
800083c0:	f4 06 00 36 	add	r6,r10,r6<<0x3
800083c4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800083c8:	c1 88       	rjmp	800083f8 <_vfprintf_r+0x4e8>
800083ca:	41 09       	lddsp	r9,sp[0x40]
800083cc:	59 f8       	cp.w	r8,31
800083ce:	e0 89 00 12 	brgt	800083f2 <_vfprintf_r+0x4e2>
800083d2:	f2 ca ff fc 	sub	r10,r9,-4
800083d6:	51 0a       	stdsp	sp[0x40],r10
800083d8:	72 09       	ld.w	r9,r9[0x0]
800083da:	fa c6 f9 44 	sub	r6,sp,-1724
800083de:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800083e2:	2f f8       	sub	r8,-1
800083e4:	f5 49 fd 88 	st.w	r10[-632],r9
800083e8:	fb 48 06 b4 	st.w	sp[1716],r8
800083ec:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800083f0:	c0 48       	rjmp	800083f8 <_vfprintf_r+0x4e8>
800083f2:	13 b8       	ld.ub	r8,r9[0x3]
800083f4:	2f c9       	sub	r9,-4
800083f6:	51 09       	stdsp	sp[0x40],r9
800083f8:	fb 68 06 60 	st.b	sp[1632],r8
800083fc:	30 0e       	mov	lr,0
800083fe:	30 08       	mov	r8,0
80008400:	30 12       	mov	r2,1
80008402:	fb 68 06 bb 	st.b	sp[1723],r8
80008406:	50 2e       	stdsp	sp[0x8],lr
80008408:	e0 8f 08 ad 	bral	80009562 <_vfprintf_r+0x1652>
8000840c:	50 a7       	stdsp	sp[0x28],r7
8000840e:	50 80       	stdsp	sp[0x20],r0
80008410:	0c 97       	mov	r7,r6
80008412:	04 94       	mov	r4,r2
80008414:	06 96       	mov	r6,r3
80008416:	02 92       	mov	r2,r1
80008418:	40 93       	lddsp	r3,sp[0x24]
8000841a:	10 90       	mov	r0,r8
8000841c:	40 41       	lddsp	r1,sp[0x10]
8000841e:	a5 a5       	sbr	r5,0x4
80008420:	c0 a8       	rjmp	80008434 <_vfprintf_r+0x524>
80008422:	50 a7       	stdsp	sp[0x28],r7
80008424:	50 80       	stdsp	sp[0x20],r0
80008426:	0c 97       	mov	r7,r6
80008428:	04 94       	mov	r4,r2
8000842a:	06 96       	mov	r6,r3
8000842c:	02 92       	mov	r2,r1
8000842e:	40 93       	lddsp	r3,sp[0x24]
80008430:	10 90       	mov	r0,r8
80008432:	40 41       	lddsp	r1,sp[0x10]
80008434:	ed b5 00 05 	bld	r5,0x5
80008438:	c5 11       	brne	800084da <_vfprintf_r+0x5ca>
8000843a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000843e:	40 3c       	lddsp	r12,sp[0xc]
80008440:	58 0c       	cp.w	r12,0
80008442:	c1 e0       	breq	8000847e <_vfprintf_r+0x56e>
80008444:	10 36       	cp.w	r6,r8
80008446:	c0 64       	brge	80008452 <_vfprintf_r+0x542>
80008448:	fa cb f9 44 	sub	r11,sp,-1724
8000844c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008450:	c2 08       	rjmp	80008490 <_vfprintf_r+0x580>
80008452:	fa c8 f9 50 	sub	r8,sp,-1712
80008456:	1a d8       	st.w	--sp,r8
80008458:	fa c8 fa b8 	sub	r8,sp,-1352
8000845c:	0c 9b       	mov	r11,r6
8000845e:	1a d8       	st.w	--sp,r8
80008460:	fa c8 fb b4 	sub	r8,sp,-1100
80008464:	1a d8       	st.w	--sp,r8
80008466:	fa c9 ff b4 	sub	r9,sp,-76
8000846a:	fa c8 f9 40 	sub	r8,sp,-1728
8000846e:	04 9a       	mov	r10,r2
80008470:	08 9c       	mov	r12,r4
80008472:	fe b0 fb b7 	rcall	80007be0 <get_arg>
80008476:	2f dd       	sub	sp,-12
80008478:	78 1b       	ld.w	r11,r12[0x4]
8000847a:	78 09       	ld.w	r9,r12[0x0]
8000847c:	c2 b8       	rjmp	800084d2 <_vfprintf_r+0x5c2>
8000847e:	ee ca ff ff 	sub	r10,r7,-1
80008482:	10 37       	cp.w	r7,r8
80008484:	c0 b4       	brge	8000849a <_vfprintf_r+0x58a>
80008486:	fa c9 f9 44 	sub	r9,sp,-1724
8000848a:	14 97       	mov	r7,r10
8000848c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008490:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008494:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008498:	c1 d8       	rjmp	800084d2 <_vfprintf_r+0x5c2>
8000849a:	41 09       	lddsp	r9,sp[0x40]
8000849c:	59 f8       	cp.w	r8,31
8000849e:	e0 89 00 14 	brgt	800084c6 <_vfprintf_r+0x5b6>
800084a2:	f2 cb ff f8 	sub	r11,r9,-8
800084a6:	51 0b       	stdsp	sp[0x40],r11
800084a8:	fa c6 f9 44 	sub	r6,sp,-1724
800084ac:	72 1b       	ld.w	r11,r9[0x4]
800084ae:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800084b2:	72 09       	ld.w	r9,r9[0x0]
800084b4:	f9 4b fd 8c 	st.w	r12[-628],r11
800084b8:	f9 49 fd 88 	st.w	r12[-632],r9
800084bc:	2f f8       	sub	r8,-1
800084be:	14 97       	mov	r7,r10
800084c0:	fb 48 06 b4 	st.w	sp[1716],r8
800084c4:	c0 78       	rjmp	800084d2 <_vfprintf_r+0x5c2>
800084c6:	f2 c8 ff f8 	sub	r8,r9,-8
800084ca:	72 1b       	ld.w	r11,r9[0x4]
800084cc:	14 97       	mov	r7,r10
800084ce:	51 08       	stdsp	sp[0x40],r8
800084d0:	72 09       	ld.w	r9,r9[0x0]
800084d2:	16 98       	mov	r8,r11
800084d4:	fa e9 00 00 	st.d	sp[0],r8
800084d8:	ca e8       	rjmp	80008634 <_vfprintf_r+0x724>
800084da:	ed b5 00 04 	bld	r5,0x4
800084de:	c1 71       	brne	8000850c <_vfprintf_r+0x5fc>
800084e0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800084e4:	40 3e       	lddsp	lr,sp[0xc]
800084e6:	58 0e       	cp.w	lr,0
800084e8:	c0 80       	breq	800084f8 <_vfprintf_r+0x5e8>
800084ea:	10 36       	cp.w	r6,r8
800084ec:	c6 94       	brge	800085be <_vfprintf_r+0x6ae>
800084ee:	fa cc f9 44 	sub	r12,sp,-1724
800084f2:	f8 06 00 36 	add	r6,r12,r6<<0x3
800084f6:	c8 28       	rjmp	800085fa <_vfprintf_r+0x6ea>
800084f8:	ee ca ff ff 	sub	r10,r7,-1
800084fc:	10 37       	cp.w	r7,r8
800084fe:	e0 84 00 81 	brge	80008600 <_vfprintf_r+0x6f0>
80008502:	fa cb f9 44 	sub	r11,sp,-1724
80008506:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000850a:	c7 78       	rjmp	800085f8 <_vfprintf_r+0x6e8>
8000850c:	ed b5 00 06 	bld	r5,0x6
80008510:	c4 b1       	brne	800085a6 <_vfprintf_r+0x696>
80008512:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008516:	40 3c       	lddsp	r12,sp[0xc]
80008518:	58 0c       	cp.w	r12,0
8000851a:	c1 d0       	breq	80008554 <_vfprintf_r+0x644>
8000851c:	10 36       	cp.w	r6,r8
8000851e:	c0 64       	brge	8000852a <_vfprintf_r+0x61a>
80008520:	fa cb f9 44 	sub	r11,sp,-1724
80008524:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008528:	c1 f8       	rjmp	80008566 <_vfprintf_r+0x656>
8000852a:	fa c8 f9 50 	sub	r8,sp,-1712
8000852e:	1a d8       	st.w	--sp,r8
80008530:	fa c8 fa b8 	sub	r8,sp,-1352
80008534:	1a d8       	st.w	--sp,r8
80008536:	fa c8 fb b4 	sub	r8,sp,-1100
8000853a:	1a d8       	st.w	--sp,r8
8000853c:	fa c8 f9 40 	sub	r8,sp,-1728
80008540:	fa c9 ff b4 	sub	r9,sp,-76
80008544:	04 9a       	mov	r10,r2
80008546:	0c 9b       	mov	r11,r6
80008548:	08 9c       	mov	r12,r4
8000854a:	fe b0 fb 4b 	rcall	80007be0 <get_arg>
8000854e:	2f dd       	sub	sp,-12
80008550:	98 18       	ld.sh	r8,r12[0x2]
80008552:	c2 68       	rjmp	8000859e <_vfprintf_r+0x68e>
80008554:	ee ca ff ff 	sub	r10,r7,-1
80008558:	10 37       	cp.w	r7,r8
8000855a:	c0 94       	brge	8000856c <_vfprintf_r+0x65c>
8000855c:	fa c9 f9 44 	sub	r9,sp,-1724
80008560:	14 97       	mov	r7,r10
80008562:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008566:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000856a:	c1 a8       	rjmp	8000859e <_vfprintf_r+0x68e>
8000856c:	41 09       	lddsp	r9,sp[0x40]
8000856e:	59 f8       	cp.w	r8,31
80008570:	e0 89 00 13 	brgt	80008596 <_vfprintf_r+0x686>
80008574:	f2 cb ff fc 	sub	r11,r9,-4
80008578:	51 0b       	stdsp	sp[0x40],r11
8000857a:	72 09       	ld.w	r9,r9[0x0]
8000857c:	fa c6 f9 44 	sub	r6,sp,-1724
80008580:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008584:	2f f8       	sub	r8,-1
80008586:	f7 49 fd 88 	st.w	r11[-632],r9
8000858a:	fb 48 06 b4 	st.w	sp[1716],r8
8000858e:	14 97       	mov	r7,r10
80008590:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008594:	c0 58       	rjmp	8000859e <_vfprintf_r+0x68e>
80008596:	92 18       	ld.sh	r8,r9[0x2]
80008598:	14 97       	mov	r7,r10
8000859a:	2f c9       	sub	r9,-4
8000859c:	51 09       	stdsp	sp[0x40],r9
8000859e:	50 18       	stdsp	sp[0x4],r8
800085a0:	bf 58       	asr	r8,0x1f
800085a2:	50 08       	stdsp	sp[0x0],r8
800085a4:	c4 88       	rjmp	80008634 <_vfprintf_r+0x724>
800085a6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800085aa:	40 3c       	lddsp	r12,sp[0xc]
800085ac:	58 0c       	cp.w	r12,0
800085ae:	c1 d0       	breq	800085e8 <_vfprintf_r+0x6d8>
800085b0:	10 36       	cp.w	r6,r8
800085b2:	c0 64       	brge	800085be <_vfprintf_r+0x6ae>
800085b4:	fa cb f9 44 	sub	r11,sp,-1724
800085b8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800085bc:	c1 f8       	rjmp	800085fa <_vfprintf_r+0x6ea>
800085be:	fa c8 f9 50 	sub	r8,sp,-1712
800085c2:	1a d8       	st.w	--sp,r8
800085c4:	fa c8 fa b8 	sub	r8,sp,-1352
800085c8:	0c 9b       	mov	r11,r6
800085ca:	1a d8       	st.w	--sp,r8
800085cc:	fa c8 fb b4 	sub	r8,sp,-1100
800085d0:	04 9a       	mov	r10,r2
800085d2:	1a d8       	st.w	--sp,r8
800085d4:	08 9c       	mov	r12,r4
800085d6:	fa c8 f9 40 	sub	r8,sp,-1728
800085da:	fa c9 ff b4 	sub	r9,sp,-76
800085de:	fe b0 fb 01 	rcall	80007be0 <get_arg>
800085e2:	2f dd       	sub	sp,-12
800085e4:	78 0b       	ld.w	r11,r12[0x0]
800085e6:	c2 48       	rjmp	8000862e <_vfprintf_r+0x71e>
800085e8:	ee ca ff ff 	sub	r10,r7,-1
800085ec:	10 37       	cp.w	r7,r8
800085ee:	c0 94       	brge	80008600 <_vfprintf_r+0x6f0>
800085f0:	fa c9 f9 44 	sub	r9,sp,-1724
800085f4:	f2 06 00 36 	add	r6,r9,r6<<0x3
800085f8:	14 97       	mov	r7,r10
800085fa:	ec fb fd 88 	ld.w	r11,r6[-632]
800085fe:	c1 88       	rjmp	8000862e <_vfprintf_r+0x71e>
80008600:	41 09       	lddsp	r9,sp[0x40]
80008602:	59 f8       	cp.w	r8,31
80008604:	e0 89 00 11 	brgt	80008626 <_vfprintf_r+0x716>
80008608:	f2 cb ff fc 	sub	r11,r9,-4
8000860c:	51 0b       	stdsp	sp[0x40],r11
8000860e:	fa c6 f9 44 	sub	r6,sp,-1724
80008612:	72 0b       	ld.w	r11,r9[0x0]
80008614:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008618:	f3 4b fd 88 	st.w	r9[-632],r11
8000861c:	2f f8       	sub	r8,-1
8000861e:	14 97       	mov	r7,r10
80008620:	fb 48 06 b4 	st.w	sp[1716],r8
80008624:	c0 58       	rjmp	8000862e <_vfprintf_r+0x71e>
80008626:	72 0b       	ld.w	r11,r9[0x0]
80008628:	14 97       	mov	r7,r10
8000862a:	2f c9       	sub	r9,-4
8000862c:	51 09       	stdsp	sp[0x40],r9
8000862e:	50 1b       	stdsp	sp[0x4],r11
80008630:	bf 5b       	asr	r11,0x1f
80008632:	50 0b       	stdsp	sp[0x0],r11
80008634:	fa ea 00 00 	ld.d	r10,sp[0]
80008638:	58 0a       	cp.w	r10,0
8000863a:	5c 2b       	cpc	r11
8000863c:	c0 e4       	brge	80008658 <_vfprintf_r+0x748>
8000863e:	30 08       	mov	r8,0
80008640:	fa ea 00 00 	ld.d	r10,sp[0]
80008644:	30 09       	mov	r9,0
80008646:	f0 0a 01 0a 	sub	r10,r8,r10
8000864a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000864e:	32 d8       	mov	r8,45
80008650:	fa eb 00 00 	st.d	sp[0],r10
80008654:	fb 68 06 bb 	st.b	sp[1723],r8
80008658:	30 18       	mov	r8,1
8000865a:	e0 8f 06 fa 	bral	8000944e <_vfprintf_r+0x153e>
8000865e:	50 a7       	stdsp	sp[0x28],r7
80008660:	50 80       	stdsp	sp[0x20],r0
80008662:	0c 97       	mov	r7,r6
80008664:	04 94       	mov	r4,r2
80008666:	06 96       	mov	r6,r3
80008668:	02 92       	mov	r2,r1
8000866a:	40 93       	lddsp	r3,sp[0x24]
8000866c:	10 90       	mov	r0,r8
8000866e:	40 41       	lddsp	r1,sp[0x10]
80008670:	0e 99       	mov	r9,r7
80008672:	ed b5 00 03 	bld	r5,0x3
80008676:	c4 11       	brne	800086f8 <_vfprintf_r+0x7e8>
80008678:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000867c:	40 3a       	lddsp	r10,sp[0xc]
8000867e:	58 0a       	cp.w	r10,0
80008680:	c1 90       	breq	800086b2 <_vfprintf_r+0x7a2>
80008682:	10 36       	cp.w	r6,r8
80008684:	c6 45       	brlt	8000874c <_vfprintf_r+0x83c>
80008686:	fa c8 f9 50 	sub	r8,sp,-1712
8000868a:	1a d8       	st.w	--sp,r8
8000868c:	fa c8 fa b8 	sub	r8,sp,-1352
80008690:	1a d8       	st.w	--sp,r8
80008692:	fa c8 fb b4 	sub	r8,sp,-1100
80008696:	0c 9b       	mov	r11,r6
80008698:	1a d8       	st.w	--sp,r8
8000869a:	04 9a       	mov	r10,r2
8000869c:	fa c8 f9 40 	sub	r8,sp,-1728
800086a0:	fa c9 ff b4 	sub	r9,sp,-76
800086a4:	08 9c       	mov	r12,r4
800086a6:	fe b0 fa 9d 	rcall	80007be0 <get_arg>
800086aa:	2f dd       	sub	sp,-12
800086ac:	78 16       	ld.w	r6,r12[0x4]
800086ae:	50 76       	stdsp	sp[0x1c],r6
800086b0:	c4 88       	rjmp	80008740 <_vfprintf_r+0x830>
800086b2:	2f f7       	sub	r7,-1
800086b4:	10 39       	cp.w	r9,r8
800086b6:	c0 c4       	brge	800086ce <_vfprintf_r+0x7be>
800086b8:	fa ce f9 44 	sub	lr,sp,-1724
800086bc:	fc 06 00 36 	add	r6,lr,r6<<0x3
800086c0:	ec fc fd 8c 	ld.w	r12,r6[-628]
800086c4:	50 7c       	stdsp	sp[0x1c],r12
800086c6:	ec f6 fd 88 	ld.w	r6,r6[-632]
800086ca:	50 56       	stdsp	sp[0x14],r6
800086cc:	c6 68       	rjmp	80008798 <_vfprintf_r+0x888>
800086ce:	41 09       	lddsp	r9,sp[0x40]
800086d0:	59 f8       	cp.w	r8,31
800086d2:	e0 89 00 10 	brgt	800086f2 <_vfprintf_r+0x7e2>
800086d6:	f2 ca ff f8 	sub	r10,r9,-8
800086da:	72 1b       	ld.w	r11,r9[0x4]
800086dc:	51 0a       	stdsp	sp[0x40],r10
800086de:	72 09       	ld.w	r9,r9[0x0]
800086e0:	fa ca f9 44 	sub	r10,sp,-1724
800086e4:	50 7b       	stdsp	sp[0x1c],r11
800086e6:	50 59       	stdsp	sp[0x14],r9
800086e8:	f4 08 00 39 	add	r9,r10,r8<<0x3
800086ec:	40 5b       	lddsp	r11,sp[0x14]
800086ee:	40 7a       	lddsp	r10,sp[0x1c]
800086f0:	c4 78       	rjmp	8000877e <_vfprintf_r+0x86e>
800086f2:	72 18       	ld.w	r8,r9[0x4]
800086f4:	50 78       	stdsp	sp[0x1c],r8
800086f6:	c4 c8       	rjmp	8000878e <_vfprintf_r+0x87e>
800086f8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086fc:	40 3e       	lddsp	lr,sp[0xc]
800086fe:	58 0e       	cp.w	lr,0
80008700:	c2 30       	breq	80008746 <_vfprintf_r+0x836>
80008702:	10 36       	cp.w	r6,r8
80008704:	c0 94       	brge	80008716 <_vfprintf_r+0x806>
80008706:	fa cc f9 44 	sub	r12,sp,-1724
8000870a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000870e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008712:	50 7b       	stdsp	sp[0x1c],r11
80008714:	cd 9b       	rjmp	800086c6 <_vfprintf_r+0x7b6>
80008716:	fa c8 f9 50 	sub	r8,sp,-1712
8000871a:	1a d8       	st.w	--sp,r8
8000871c:	fa c8 fa b8 	sub	r8,sp,-1352
80008720:	04 9a       	mov	r10,r2
80008722:	1a d8       	st.w	--sp,r8
80008724:	fa c8 fb b4 	sub	r8,sp,-1100
80008728:	0c 9b       	mov	r11,r6
8000872a:	1a d8       	st.w	--sp,r8
8000872c:	08 9c       	mov	r12,r4
8000872e:	fa c8 f9 40 	sub	r8,sp,-1728
80008732:	fa c9 ff b4 	sub	r9,sp,-76
80008736:	fe b0 fa 55 	rcall	80007be0 <get_arg>
8000873a:	2f dd       	sub	sp,-12
8000873c:	78 1a       	ld.w	r10,r12[0x4]
8000873e:	50 7a       	stdsp	sp[0x1c],r10
80008740:	78 0c       	ld.w	r12,r12[0x0]
80008742:	50 5c       	stdsp	sp[0x14],r12
80008744:	c2 a8       	rjmp	80008798 <_vfprintf_r+0x888>
80008746:	2f f7       	sub	r7,-1
80008748:	10 39       	cp.w	r9,r8
8000874a:	c0 94       	brge	8000875c <_vfprintf_r+0x84c>
8000874c:	fa c9 f9 44 	sub	r9,sp,-1724
80008750:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008754:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008758:	50 78       	stdsp	sp[0x1c],r8
8000875a:	cb 6b       	rjmp	800086c6 <_vfprintf_r+0x7b6>
8000875c:	41 09       	lddsp	r9,sp[0x40]
8000875e:	59 f8       	cp.w	r8,31
80008760:	e0 89 00 15 	brgt	8000878a <_vfprintf_r+0x87a>
80008764:	f2 ca ff f8 	sub	r10,r9,-8
80008768:	72 16       	ld.w	r6,r9[0x4]
8000876a:	72 09       	ld.w	r9,r9[0x0]
8000876c:	51 0a       	stdsp	sp[0x40],r10
8000876e:	50 59       	stdsp	sp[0x14],r9
80008770:	fa ce f9 44 	sub	lr,sp,-1724
80008774:	50 76       	stdsp	sp[0x1c],r6
80008776:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000877a:	40 5b       	lddsp	r11,sp[0x14]
8000877c:	0c 9a       	mov	r10,r6
8000877e:	f2 eb fd 88 	st.d	r9[-632],r10
80008782:	2f f8       	sub	r8,-1
80008784:	fb 48 06 b4 	st.w	sp[1716],r8
80008788:	c0 88       	rjmp	80008798 <_vfprintf_r+0x888>
8000878a:	72 1c       	ld.w	r12,r9[0x4]
8000878c:	50 7c       	stdsp	sp[0x1c],r12
8000878e:	f2 c8 ff f8 	sub	r8,r9,-8
80008792:	51 08       	stdsp	sp[0x40],r8
80008794:	72 09       	ld.w	r9,r9[0x0]
80008796:	50 59       	stdsp	sp[0x14],r9
80008798:	40 5b       	lddsp	r11,sp[0x14]
8000879a:	40 7a       	lddsp	r10,sp[0x1c]
8000879c:	e0 a0 19 54 	rcall	8000ba44 <__isinfd>
800087a0:	18 96       	mov	r6,r12
800087a2:	c1 70       	breq	800087d0 <_vfprintf_r+0x8c0>
800087a4:	30 08       	mov	r8,0
800087a6:	30 09       	mov	r9,0
800087a8:	40 5b       	lddsp	r11,sp[0x14]
800087aa:	40 7a       	lddsp	r10,sp[0x1c]
800087ac:	e0 a0 1d b4 	rcall	8000c314 <__avr32_f64_cmp_lt>
800087b0:	c0 40       	breq	800087b8 <_vfprintf_r+0x8a8>
800087b2:	32 d8       	mov	r8,45
800087b4:	fb 68 06 bb 	st.b	sp[1723],r8
800087b8:	fe c8 aa 38 	sub	r8,pc,-21960
800087bc:	fe c6 aa 38 	sub	r6,pc,-21960
800087c0:	a7 d5       	cbr	r5,0x7
800087c2:	e0 40 00 47 	cp.w	r0,71
800087c6:	f0 06 17 a0 	movle	r6,r8
800087ca:	30 32       	mov	r2,3
800087cc:	e0 8f 06 ce 	bral	80009568 <_vfprintf_r+0x1658>
800087d0:	40 5b       	lddsp	r11,sp[0x14]
800087d2:	40 7a       	lddsp	r10,sp[0x1c]
800087d4:	e0 a0 19 4d 	rcall	8000ba6e <__isnand>
800087d8:	c0 e0       	breq	800087f4 <_vfprintf_r+0x8e4>
800087da:	50 26       	stdsp	sp[0x8],r6
800087dc:	fe c8 aa 54 	sub	r8,pc,-21932
800087e0:	fe c6 aa 54 	sub	r6,pc,-21932
800087e4:	a7 d5       	cbr	r5,0x7
800087e6:	e0 40 00 47 	cp.w	r0,71
800087ea:	f0 06 17 a0 	movle	r6,r8
800087ee:	30 32       	mov	r2,3
800087f0:	e0 8f 06 c2 	bral	80009574 <_vfprintf_r+0x1664>
800087f4:	40 2a       	lddsp	r10,sp[0x8]
800087f6:	5b fa       	cp.w	r10,-1
800087f8:	c0 41       	brne	80008800 <_vfprintf_r+0x8f0>
800087fa:	30 69       	mov	r9,6
800087fc:	50 29       	stdsp	sp[0x8],r9
800087fe:	c1 18       	rjmp	80008820 <_vfprintf_r+0x910>
80008800:	e0 40 00 47 	cp.w	r0,71
80008804:	5f 09       	sreq	r9
80008806:	e0 40 00 67 	cp.w	r0,103
8000880a:	5f 08       	sreq	r8
8000880c:	f3 e8 10 08 	or	r8,r9,r8
80008810:	f8 08 18 00 	cp.b	r8,r12
80008814:	c0 60       	breq	80008820 <_vfprintf_r+0x910>
80008816:	40 28       	lddsp	r8,sp[0x8]
80008818:	58 08       	cp.w	r8,0
8000881a:	f9 b8 00 01 	moveq	r8,1
8000881e:	50 28       	stdsp	sp[0x8],r8
80008820:	40 78       	lddsp	r8,sp[0x1c]
80008822:	40 59       	lddsp	r9,sp[0x14]
80008824:	fa e9 06 94 	st.d	sp[1684],r8
80008828:	a9 a5       	sbr	r5,0x8
8000882a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000882e:	58 08       	cp.w	r8,0
80008830:	c0 65       	brlt	8000883c <_vfprintf_r+0x92c>
80008832:	40 5e       	lddsp	lr,sp[0x14]
80008834:	30 0c       	mov	r12,0
80008836:	50 6e       	stdsp	sp[0x18],lr
80008838:	50 9c       	stdsp	sp[0x24],r12
8000883a:	c0 78       	rjmp	80008848 <_vfprintf_r+0x938>
8000883c:	40 5b       	lddsp	r11,sp[0x14]
8000883e:	32 da       	mov	r10,45
80008840:	ee 1b 80 00 	eorh	r11,0x8000
80008844:	50 9a       	stdsp	sp[0x24],r10
80008846:	50 6b       	stdsp	sp[0x18],r11
80008848:	e0 40 00 46 	cp.w	r0,70
8000884c:	5f 09       	sreq	r9
8000884e:	e0 40 00 66 	cp.w	r0,102
80008852:	5f 08       	sreq	r8
80008854:	f3 e8 10 08 	or	r8,r9,r8
80008858:	50 48       	stdsp	sp[0x10],r8
8000885a:	c0 40       	breq	80008862 <_vfprintf_r+0x952>
8000885c:	40 22       	lddsp	r2,sp[0x8]
8000885e:	30 39       	mov	r9,3
80008860:	c1 08       	rjmp	80008880 <_vfprintf_r+0x970>
80008862:	e0 40 00 45 	cp.w	r0,69
80008866:	5f 09       	sreq	r9
80008868:	e0 40 00 65 	cp.w	r0,101
8000886c:	5f 08       	sreq	r8
8000886e:	40 22       	lddsp	r2,sp[0x8]
80008870:	10 49       	or	r9,r8
80008872:	2f f2       	sub	r2,-1
80008874:	40 46       	lddsp	r6,sp[0x10]
80008876:	ec 09 18 00 	cp.b	r9,r6
8000887a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000887e:	30 29       	mov	r9,2
80008880:	fa c8 f9 5c 	sub	r8,sp,-1700
80008884:	1a d8       	st.w	--sp,r8
80008886:	fa c8 f9 54 	sub	r8,sp,-1708
8000888a:	1a d8       	st.w	--sp,r8
8000888c:	fa c8 f9 4c 	sub	r8,sp,-1716
80008890:	08 9c       	mov	r12,r4
80008892:	1a d8       	st.w	--sp,r8
80008894:	04 98       	mov	r8,r2
80008896:	40 9b       	lddsp	r11,sp[0x24]
80008898:	40 aa       	lddsp	r10,sp[0x28]
8000889a:	e0 a0 0b c3 	rcall	8000a020 <_dtoa_r>
8000889e:	e0 40 00 47 	cp.w	r0,71
800088a2:	5f 19       	srne	r9
800088a4:	e0 40 00 67 	cp.w	r0,103
800088a8:	5f 18       	srne	r8
800088aa:	18 96       	mov	r6,r12
800088ac:	2f dd       	sub	sp,-12
800088ae:	f3 e8 00 08 	and	r8,r9,r8
800088b2:	c0 41       	brne	800088ba <_vfprintf_r+0x9aa>
800088b4:	ed b5 00 00 	bld	r5,0x0
800088b8:	c3 01       	brne	80008918 <_vfprintf_r+0xa08>
800088ba:	ec 02 00 0e 	add	lr,r6,r2
800088be:	50 3e       	stdsp	sp[0xc],lr
800088c0:	40 4c       	lddsp	r12,sp[0x10]
800088c2:	58 0c       	cp.w	r12,0
800088c4:	c1 50       	breq	800088ee <_vfprintf_r+0x9de>
800088c6:	0d 89       	ld.ub	r9,r6[0x0]
800088c8:	33 08       	mov	r8,48
800088ca:	f0 09 18 00 	cp.b	r9,r8
800088ce:	c0 b1       	brne	800088e4 <_vfprintf_r+0x9d4>
800088d0:	30 08       	mov	r8,0
800088d2:	30 09       	mov	r9,0
800088d4:	40 6b       	lddsp	r11,sp[0x18]
800088d6:	40 7a       	lddsp	r10,sp[0x1c]
800088d8:	e0 a0 1c d7 	rcall	8000c286 <__avr32_f64_cmp_eq>
800088dc:	fb b2 00 01 	rsubeq	r2,1
800088e0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800088e4:	40 3b       	lddsp	r11,sp[0xc]
800088e6:	fa f8 06 ac 	ld.w	r8,sp[1708]
800088ea:	10 0b       	add	r11,r8
800088ec:	50 3b       	stdsp	sp[0xc],r11
800088ee:	40 6b       	lddsp	r11,sp[0x18]
800088f0:	30 08       	mov	r8,0
800088f2:	30 09       	mov	r9,0
800088f4:	40 7a       	lddsp	r10,sp[0x1c]
800088f6:	e0 a0 1c c8 	rcall	8000c286 <__avr32_f64_cmp_eq>
800088fa:	c0 90       	breq	8000890c <_vfprintf_r+0x9fc>
800088fc:	40 3a       	lddsp	r10,sp[0xc]
800088fe:	fb 4a 06 a4 	st.w	sp[1700],r10
80008902:	c0 58       	rjmp	8000890c <_vfprintf_r+0x9fc>
80008904:	10 c9       	st.b	r8++,r9
80008906:	fb 48 06 a4 	st.w	sp[1700],r8
8000890a:	c0 28       	rjmp	8000890e <_vfprintf_r+0x9fe>
8000890c:	33 09       	mov	r9,48
8000890e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008912:	40 3e       	lddsp	lr,sp[0xc]
80008914:	1c 38       	cp.w	r8,lr
80008916:	cf 73       	brcs	80008904 <_vfprintf_r+0x9f4>
80008918:	e0 40 00 47 	cp.w	r0,71
8000891c:	5f 09       	sreq	r9
8000891e:	e0 40 00 67 	cp.w	r0,103
80008922:	5f 08       	sreq	r8
80008924:	f3 e8 10 08 	or	r8,r9,r8
80008928:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000892c:	0c 19       	sub	r9,r6
8000892e:	50 69       	stdsp	sp[0x18],r9
80008930:	58 08       	cp.w	r8,0
80008932:	c0 b0       	breq	80008948 <_vfprintf_r+0xa38>
80008934:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008938:	5b d8       	cp.w	r8,-3
8000893a:	c0 55       	brlt	80008944 <_vfprintf_r+0xa34>
8000893c:	40 2c       	lddsp	r12,sp[0x8]
8000893e:	18 38       	cp.w	r8,r12
80008940:	e0 8a 00 6a 	brle	80008a14 <_vfprintf_r+0xb04>
80008944:	20 20       	sub	r0,2
80008946:	c0 58       	rjmp	80008950 <_vfprintf_r+0xa40>
80008948:	e0 40 00 65 	cp.w	r0,101
8000894c:	e0 89 00 46 	brgt	800089d8 <_vfprintf_r+0xac8>
80008950:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008954:	fb 60 06 9c 	st.b	sp[1692],r0
80008958:	20 1b       	sub	r11,1
8000895a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000895e:	c0 47       	brpl	80008966 <_vfprintf_r+0xa56>
80008960:	5c 3b       	neg	r11
80008962:	32 d8       	mov	r8,45
80008964:	c0 28       	rjmp	80008968 <_vfprintf_r+0xa58>
80008966:	32 b8       	mov	r8,43
80008968:	fb 68 06 9d 	st.b	sp[1693],r8
8000896c:	58 9b       	cp.w	r11,9
8000896e:	e0 8a 00 1d 	brle	800089a8 <_vfprintf_r+0xa98>
80008972:	fa c9 fa 35 	sub	r9,sp,-1483
80008976:	30 aa       	mov	r10,10
80008978:	12 98       	mov	r8,r9
8000897a:	0e 9c       	mov	r12,r7
8000897c:	0c 92       	mov	r2,r6
8000897e:	f6 0a 0c 06 	divs	r6,r11,r10
80008982:	0e 9b       	mov	r11,r7
80008984:	2d 0b       	sub	r11,-48
80008986:	10 fb       	st.b	--r8,r11
80008988:	0c 9b       	mov	r11,r6
8000898a:	58 96       	cp.w	r6,9
8000898c:	fe 99 ff f9 	brgt	8000897e <_vfprintf_r+0xa6e>
80008990:	2d 0b       	sub	r11,-48
80008992:	18 97       	mov	r7,r12
80008994:	04 96       	mov	r6,r2
80008996:	10 fb       	st.b	--r8,r11
80008998:	fa ca f9 62 	sub	r10,sp,-1694
8000899c:	c0 38       	rjmp	800089a2 <_vfprintf_r+0xa92>
8000899e:	11 3b       	ld.ub	r11,r8++
800089a0:	14 cb       	st.b	r10++,r11
800089a2:	12 38       	cp.w	r8,r9
800089a4:	cf d3       	brcs	8000899e <_vfprintf_r+0xa8e>
800089a6:	c0 98       	rjmp	800089b8 <_vfprintf_r+0xaa8>
800089a8:	2d 0b       	sub	r11,-48
800089aa:	33 08       	mov	r8,48
800089ac:	fb 6b 06 9f 	st.b	sp[1695],r11
800089b0:	fb 68 06 9e 	st.b	sp[1694],r8
800089b4:	fa ca f9 60 	sub	r10,sp,-1696
800089b8:	fa c8 f9 64 	sub	r8,sp,-1692
800089bc:	f4 08 01 08 	sub	r8,r10,r8
800089c0:	50 e8       	stdsp	sp[0x38],r8
800089c2:	10 92       	mov	r2,r8
800089c4:	40 6b       	lddsp	r11,sp[0x18]
800089c6:	16 02       	add	r2,r11
800089c8:	58 1b       	cp.w	r11,1
800089ca:	e0 89 00 05 	brgt	800089d4 <_vfprintf_r+0xac4>
800089ce:	ed b5 00 00 	bld	r5,0x0
800089d2:	c3 51       	brne	80008a3c <_vfprintf_r+0xb2c>
800089d4:	2f f2       	sub	r2,-1
800089d6:	c3 38       	rjmp	80008a3c <_vfprintf_r+0xb2c>
800089d8:	e0 40 00 66 	cp.w	r0,102
800089dc:	c1 c1       	brne	80008a14 <_vfprintf_r+0xb04>
800089de:	fa f2 06 ac 	ld.w	r2,sp[1708]
800089e2:	58 02       	cp.w	r2,0
800089e4:	e0 8a 00 0c 	brle	800089fc <_vfprintf_r+0xaec>
800089e8:	40 2a       	lddsp	r10,sp[0x8]
800089ea:	58 0a       	cp.w	r10,0
800089ec:	c0 41       	brne	800089f4 <_vfprintf_r+0xae4>
800089ee:	ed b5 00 00 	bld	r5,0x0
800089f2:	c2 51       	brne	80008a3c <_vfprintf_r+0xb2c>
800089f4:	2f f2       	sub	r2,-1
800089f6:	40 29       	lddsp	r9,sp[0x8]
800089f8:	12 02       	add	r2,r9
800089fa:	c0 b8       	rjmp	80008a10 <_vfprintf_r+0xb00>
800089fc:	40 28       	lddsp	r8,sp[0x8]
800089fe:	58 08       	cp.w	r8,0
80008a00:	c0 61       	brne	80008a0c <_vfprintf_r+0xafc>
80008a02:	ed b5 00 00 	bld	r5,0x0
80008a06:	c0 30       	breq	80008a0c <_vfprintf_r+0xafc>
80008a08:	30 12       	mov	r2,1
80008a0a:	c1 98       	rjmp	80008a3c <_vfprintf_r+0xb2c>
80008a0c:	40 22       	lddsp	r2,sp[0x8]
80008a0e:	2f e2       	sub	r2,-2
80008a10:	36 60       	mov	r0,102
80008a12:	c1 58       	rjmp	80008a3c <_vfprintf_r+0xb2c>
80008a14:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008a18:	40 6e       	lddsp	lr,sp[0x18]
80008a1a:	1c 32       	cp.w	r2,lr
80008a1c:	c0 65       	brlt	80008a28 <_vfprintf_r+0xb18>
80008a1e:	ed b5 00 00 	bld	r5,0x0
80008a22:	f7 b2 00 ff 	subeq	r2,-1
80008a26:	c0 a8       	rjmp	80008a3a <_vfprintf_r+0xb2a>
80008a28:	e4 08 11 02 	rsub	r8,r2,2
80008a2c:	40 6c       	lddsp	r12,sp[0x18]
80008a2e:	58 02       	cp.w	r2,0
80008a30:	f0 02 17 a0 	movle	r2,r8
80008a34:	f9 b2 09 01 	movgt	r2,1
80008a38:	18 02       	add	r2,r12
80008a3a:	36 70       	mov	r0,103
80008a3c:	40 9b       	lddsp	r11,sp[0x24]
80008a3e:	58 0b       	cp.w	r11,0
80008a40:	e0 80 05 94 	breq	80009568 <_vfprintf_r+0x1658>
80008a44:	32 d8       	mov	r8,45
80008a46:	fb 68 06 bb 	st.b	sp[1723],r8
80008a4a:	e0 8f 05 93 	bral	80009570 <_vfprintf_r+0x1660>
80008a4e:	50 a7       	stdsp	sp[0x28],r7
80008a50:	04 94       	mov	r4,r2
80008a52:	0c 97       	mov	r7,r6
80008a54:	02 92       	mov	r2,r1
80008a56:	06 96       	mov	r6,r3
80008a58:	40 41       	lddsp	r1,sp[0x10]
80008a5a:	40 93       	lddsp	r3,sp[0x24]
80008a5c:	0e 99       	mov	r9,r7
80008a5e:	ed b5 00 05 	bld	r5,0x5
80008a62:	c4 81       	brne	80008af2 <_vfprintf_r+0xbe2>
80008a64:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a68:	40 3e       	lddsp	lr,sp[0xc]
80008a6a:	58 0e       	cp.w	lr,0
80008a6c:	c1 d0       	breq	80008aa6 <_vfprintf_r+0xb96>
80008a6e:	10 36       	cp.w	r6,r8
80008a70:	c0 64       	brge	80008a7c <_vfprintf_r+0xb6c>
80008a72:	fa cc f9 44 	sub	r12,sp,-1724
80008a76:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a7a:	c1 d8       	rjmp	80008ab4 <_vfprintf_r+0xba4>
80008a7c:	fa c8 f9 50 	sub	r8,sp,-1712
80008a80:	1a d8       	st.w	--sp,r8
80008a82:	fa c8 fa b8 	sub	r8,sp,-1352
80008a86:	04 9a       	mov	r10,r2
80008a88:	1a d8       	st.w	--sp,r8
80008a8a:	fa c8 fb b4 	sub	r8,sp,-1100
80008a8e:	0c 9b       	mov	r11,r6
80008a90:	1a d8       	st.w	--sp,r8
80008a92:	08 9c       	mov	r12,r4
80008a94:	fa c8 f9 40 	sub	r8,sp,-1728
80008a98:	fa c9 ff b4 	sub	r9,sp,-76
80008a9c:	fe b0 f8 a2 	rcall	80007be0 <get_arg>
80008aa0:	2f dd       	sub	sp,-12
80008aa2:	78 0a       	ld.w	r10,r12[0x0]
80008aa4:	c2 08       	rjmp	80008ae4 <_vfprintf_r+0xbd4>
80008aa6:	2f f7       	sub	r7,-1
80008aa8:	10 39       	cp.w	r9,r8
80008aaa:	c0 84       	brge	80008aba <_vfprintf_r+0xbaa>
80008aac:	fa cb f9 44 	sub	r11,sp,-1724
80008ab0:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008ab4:	ec fa fd 88 	ld.w	r10,r6[-632]
80008ab8:	c1 68       	rjmp	80008ae4 <_vfprintf_r+0xbd4>
80008aba:	41 09       	lddsp	r9,sp[0x40]
80008abc:	59 f8       	cp.w	r8,31
80008abe:	e0 89 00 10 	brgt	80008ade <_vfprintf_r+0xbce>
80008ac2:	f2 ca ff fc 	sub	r10,r9,-4
80008ac6:	51 0a       	stdsp	sp[0x40],r10
80008ac8:	fa c6 f9 44 	sub	r6,sp,-1724
80008acc:	72 0a       	ld.w	r10,r9[0x0]
80008ace:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ad2:	f3 4a fd 88 	st.w	r9[-632],r10
80008ad6:	2f f8       	sub	r8,-1
80008ad8:	fb 48 06 b4 	st.w	sp[1716],r8
80008adc:	c0 48       	rjmp	80008ae4 <_vfprintf_r+0xbd4>
80008ade:	72 0a       	ld.w	r10,r9[0x0]
80008ae0:	2f c9       	sub	r9,-4
80008ae2:	51 09       	stdsp	sp[0x40],r9
80008ae4:	40 be       	lddsp	lr,sp[0x2c]
80008ae6:	1c 98       	mov	r8,lr
80008ae8:	95 1e       	st.w	r10[0x4],lr
80008aea:	bf 58       	asr	r8,0x1f
80008aec:	95 08       	st.w	r10[0x0],r8
80008aee:	fe 9f fa 9f 	bral	8000802c <_vfprintf_r+0x11c>
80008af2:	ed b5 00 04 	bld	r5,0x4
80008af6:	c4 80       	breq	80008b86 <_vfprintf_r+0xc76>
80008af8:	e2 15 00 40 	andl	r5,0x40,COH
80008afc:	c4 50       	breq	80008b86 <_vfprintf_r+0xc76>
80008afe:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b02:	40 3c       	lddsp	r12,sp[0xc]
80008b04:	58 0c       	cp.w	r12,0
80008b06:	c1 d0       	breq	80008b40 <_vfprintf_r+0xc30>
80008b08:	10 36       	cp.w	r6,r8
80008b0a:	c0 64       	brge	80008b16 <_vfprintf_r+0xc06>
80008b0c:	fa cb f9 44 	sub	r11,sp,-1724
80008b10:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b14:	c1 d8       	rjmp	80008b4e <_vfprintf_r+0xc3e>
80008b16:	fa c8 f9 50 	sub	r8,sp,-1712
80008b1a:	1a d8       	st.w	--sp,r8
80008b1c:	fa c8 fa b8 	sub	r8,sp,-1352
80008b20:	04 9a       	mov	r10,r2
80008b22:	1a d8       	st.w	--sp,r8
80008b24:	fa c8 fb b4 	sub	r8,sp,-1100
80008b28:	0c 9b       	mov	r11,r6
80008b2a:	1a d8       	st.w	--sp,r8
80008b2c:	08 9c       	mov	r12,r4
80008b2e:	fa c8 f9 40 	sub	r8,sp,-1728
80008b32:	fa c9 ff b4 	sub	r9,sp,-76
80008b36:	fe b0 f8 55 	rcall	80007be0 <get_arg>
80008b3a:	2f dd       	sub	sp,-12
80008b3c:	78 0a       	ld.w	r10,r12[0x0]
80008b3e:	c2 08       	rjmp	80008b7e <_vfprintf_r+0xc6e>
80008b40:	2f f7       	sub	r7,-1
80008b42:	10 39       	cp.w	r9,r8
80008b44:	c0 84       	brge	80008b54 <_vfprintf_r+0xc44>
80008b46:	fa ca f9 44 	sub	r10,sp,-1724
80008b4a:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008b4e:	ec fa fd 88 	ld.w	r10,r6[-632]
80008b52:	c1 68       	rjmp	80008b7e <_vfprintf_r+0xc6e>
80008b54:	41 09       	lddsp	r9,sp[0x40]
80008b56:	59 f8       	cp.w	r8,31
80008b58:	e0 89 00 10 	brgt	80008b78 <_vfprintf_r+0xc68>
80008b5c:	f2 ca ff fc 	sub	r10,r9,-4
80008b60:	51 0a       	stdsp	sp[0x40],r10
80008b62:	fa c6 f9 44 	sub	r6,sp,-1724
80008b66:	72 0a       	ld.w	r10,r9[0x0]
80008b68:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008b6c:	f3 4a fd 88 	st.w	r9[-632],r10
80008b70:	2f f8       	sub	r8,-1
80008b72:	fb 48 06 b4 	st.w	sp[1716],r8
80008b76:	c0 48       	rjmp	80008b7e <_vfprintf_r+0xc6e>
80008b78:	72 0a       	ld.w	r10,r9[0x0]
80008b7a:	2f c9       	sub	r9,-4
80008b7c:	51 09       	stdsp	sp[0x40],r9
80008b7e:	40 be       	lddsp	lr,sp[0x2c]
80008b80:	b4 0e       	st.h	r10[0x0],lr
80008b82:	fe 9f fa 55 	bral	8000802c <_vfprintf_r+0x11c>
80008b86:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b8a:	40 3c       	lddsp	r12,sp[0xc]
80008b8c:	58 0c       	cp.w	r12,0
80008b8e:	c1 d0       	breq	80008bc8 <_vfprintf_r+0xcb8>
80008b90:	10 36       	cp.w	r6,r8
80008b92:	c0 64       	brge	80008b9e <_vfprintf_r+0xc8e>
80008b94:	fa cb f9 44 	sub	r11,sp,-1724
80008b98:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008b9c:	c1 d8       	rjmp	80008bd6 <_vfprintf_r+0xcc6>
80008b9e:	fa c8 f9 50 	sub	r8,sp,-1712
80008ba2:	1a d8       	st.w	--sp,r8
80008ba4:	fa c8 fa b8 	sub	r8,sp,-1352
80008ba8:	04 9a       	mov	r10,r2
80008baa:	1a d8       	st.w	--sp,r8
80008bac:	fa c8 fb b4 	sub	r8,sp,-1100
80008bb0:	0c 9b       	mov	r11,r6
80008bb2:	1a d8       	st.w	--sp,r8
80008bb4:	08 9c       	mov	r12,r4
80008bb6:	fa c8 f9 40 	sub	r8,sp,-1728
80008bba:	fa c9 ff b4 	sub	r9,sp,-76
80008bbe:	fe b0 f8 11 	rcall	80007be0 <get_arg>
80008bc2:	2f dd       	sub	sp,-12
80008bc4:	78 0a       	ld.w	r10,r12[0x0]
80008bc6:	c2 08       	rjmp	80008c06 <_vfprintf_r+0xcf6>
80008bc8:	2f f7       	sub	r7,-1
80008bca:	10 39       	cp.w	r9,r8
80008bcc:	c0 84       	brge	80008bdc <_vfprintf_r+0xccc>
80008bce:	fa ca f9 44 	sub	r10,sp,-1724
80008bd2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008bd6:	ec fa fd 88 	ld.w	r10,r6[-632]
80008bda:	c1 68       	rjmp	80008c06 <_vfprintf_r+0xcf6>
80008bdc:	41 09       	lddsp	r9,sp[0x40]
80008bde:	59 f8       	cp.w	r8,31
80008be0:	e0 89 00 10 	brgt	80008c00 <_vfprintf_r+0xcf0>
80008be4:	f2 ca ff fc 	sub	r10,r9,-4
80008be8:	51 0a       	stdsp	sp[0x40],r10
80008bea:	fa c6 f9 44 	sub	r6,sp,-1724
80008bee:	72 0a       	ld.w	r10,r9[0x0]
80008bf0:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008bf4:	f3 4a fd 88 	st.w	r9[-632],r10
80008bf8:	2f f8       	sub	r8,-1
80008bfa:	fb 48 06 b4 	st.w	sp[1716],r8
80008bfe:	c0 48       	rjmp	80008c06 <_vfprintf_r+0xcf6>
80008c00:	72 0a       	ld.w	r10,r9[0x0]
80008c02:	2f c9       	sub	r9,-4
80008c04:	51 09       	stdsp	sp[0x40],r9
80008c06:	40 be       	lddsp	lr,sp[0x2c]
80008c08:	95 0e       	st.w	r10[0x0],lr
80008c0a:	fe 9f fa 11 	bral	8000802c <_vfprintf_r+0x11c>
80008c0e:	50 a7       	stdsp	sp[0x28],r7
80008c10:	50 80       	stdsp	sp[0x20],r0
80008c12:	0c 97       	mov	r7,r6
80008c14:	04 94       	mov	r4,r2
80008c16:	06 96       	mov	r6,r3
80008c18:	02 92       	mov	r2,r1
80008c1a:	40 93       	lddsp	r3,sp[0x24]
80008c1c:	10 90       	mov	r0,r8
80008c1e:	40 41       	lddsp	r1,sp[0x10]
80008c20:	a5 a5       	sbr	r5,0x4
80008c22:	c0 a8       	rjmp	80008c36 <_vfprintf_r+0xd26>
80008c24:	50 a7       	stdsp	sp[0x28],r7
80008c26:	50 80       	stdsp	sp[0x20],r0
80008c28:	0c 97       	mov	r7,r6
80008c2a:	04 94       	mov	r4,r2
80008c2c:	06 96       	mov	r6,r3
80008c2e:	02 92       	mov	r2,r1
80008c30:	40 93       	lddsp	r3,sp[0x24]
80008c32:	10 90       	mov	r0,r8
80008c34:	40 41       	lddsp	r1,sp[0x10]
80008c36:	ed b5 00 05 	bld	r5,0x5
80008c3a:	c5 d1       	brne	80008cf4 <_vfprintf_r+0xde4>
80008c3c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008c40:	40 3c       	lddsp	r12,sp[0xc]
80008c42:	58 0c       	cp.w	r12,0
80008c44:	c2 60       	breq	80008c90 <_vfprintf_r+0xd80>
80008c46:	10 36       	cp.w	r6,r8
80008c48:	c0 a4       	brge	80008c5c <_vfprintf_r+0xd4c>
80008c4a:	fa cb f9 44 	sub	r11,sp,-1724
80008c4e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008c52:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008c56:	fa e9 00 00 	st.d	sp[0],r8
80008c5a:	c1 88       	rjmp	80008c8a <_vfprintf_r+0xd7a>
80008c5c:	fa c8 f9 50 	sub	r8,sp,-1712
80008c60:	1a d8       	st.w	--sp,r8
80008c62:	fa c8 fa b8 	sub	r8,sp,-1352
80008c66:	04 9a       	mov	r10,r2
80008c68:	1a d8       	st.w	--sp,r8
80008c6a:	0c 9b       	mov	r11,r6
80008c6c:	fa c8 fb b4 	sub	r8,sp,-1100
80008c70:	08 9c       	mov	r12,r4
80008c72:	1a d8       	st.w	--sp,r8
80008c74:	fa c8 f9 40 	sub	r8,sp,-1728
80008c78:	fa c9 ff b4 	sub	r9,sp,-76
80008c7c:	fe b0 f7 b2 	rcall	80007be0 <get_arg>
80008c80:	2f dd       	sub	sp,-12
80008c82:	f8 ea 00 00 	ld.d	r10,r12[0]
80008c86:	fa eb 00 00 	st.d	sp[0],r10
80008c8a:	30 08       	mov	r8,0
80008c8c:	e0 8f 03 de 	bral	80009448 <_vfprintf_r+0x1538>
80008c90:	ee ca ff ff 	sub	r10,r7,-1
80008c94:	10 37       	cp.w	r7,r8
80008c96:	c0 b4       	brge	80008cac <_vfprintf_r+0xd9c>
80008c98:	fa c9 f9 44 	sub	r9,sp,-1724
80008c9c:	14 97       	mov	r7,r10
80008c9e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008ca2:	ec ea fd 88 	ld.d	r10,r6[-632]
80008ca6:	fa eb 00 00 	st.d	sp[0],r10
80008caa:	c1 88       	rjmp	80008cda <_vfprintf_r+0xdca>
80008cac:	41 09       	lddsp	r9,sp[0x40]
80008cae:	59 f8       	cp.w	r8,31
80008cb0:	e0 89 00 18 	brgt	80008ce0 <_vfprintf_r+0xdd0>
80008cb4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008cb8:	f2 cb ff f8 	sub	r11,r9,-8
80008cbc:	fa e7 00 00 	st.d	sp[0],r6
80008cc0:	51 0b       	stdsp	sp[0x40],r11
80008cc2:	fa c6 f9 44 	sub	r6,sp,-1724
80008cc6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008cca:	fa e6 00 00 	ld.d	r6,sp[0]
80008cce:	f2 e7 fd 88 	st.d	r9[-632],r6
80008cd2:	2f f8       	sub	r8,-1
80008cd4:	14 97       	mov	r7,r10
80008cd6:	fb 48 06 b4 	st.w	sp[1716],r8
80008cda:	40 38       	lddsp	r8,sp[0xc]
80008cdc:	e0 8f 03 b6 	bral	80009448 <_vfprintf_r+0x1538>
80008ce0:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ce4:	40 38       	lddsp	r8,sp[0xc]
80008ce6:	fa e7 00 00 	st.d	sp[0],r6
80008cea:	2f 89       	sub	r9,-8
80008cec:	14 97       	mov	r7,r10
80008cee:	51 09       	stdsp	sp[0x40],r9
80008cf0:	e0 8f 03 ac 	bral	80009448 <_vfprintf_r+0x1538>
80008cf4:	ed b5 00 04 	bld	r5,0x4
80008cf8:	c1 61       	brne	80008d24 <_vfprintf_r+0xe14>
80008cfa:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008cfe:	40 3e       	lddsp	lr,sp[0xc]
80008d00:	58 0e       	cp.w	lr,0
80008d02:	c0 80       	breq	80008d12 <_vfprintf_r+0xe02>
80008d04:	10 36       	cp.w	r6,r8
80008d06:	c6 74       	brge	80008dd4 <_vfprintf_r+0xec4>
80008d08:	fa cc f9 44 	sub	r12,sp,-1724
80008d0c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008d10:	c8 08       	rjmp	80008e10 <_vfprintf_r+0xf00>
80008d12:	ee ca ff ff 	sub	r10,r7,-1
80008d16:	10 37       	cp.w	r7,r8
80008d18:	c7 f4       	brge	80008e16 <_vfprintf_r+0xf06>
80008d1a:	fa cb f9 44 	sub	r11,sp,-1724
80008d1e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d22:	c7 68       	rjmp	80008e0e <_vfprintf_r+0xefe>
80008d24:	ed b5 00 06 	bld	r5,0x6
80008d28:	c4 a1       	brne	80008dbc <_vfprintf_r+0xeac>
80008d2a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d2e:	40 3c       	lddsp	r12,sp[0xc]
80008d30:	58 0c       	cp.w	r12,0
80008d32:	c1 d0       	breq	80008d6c <_vfprintf_r+0xe5c>
80008d34:	10 36       	cp.w	r6,r8
80008d36:	c0 64       	brge	80008d42 <_vfprintf_r+0xe32>
80008d38:	fa cb f9 44 	sub	r11,sp,-1724
80008d3c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008d40:	c1 f8       	rjmp	80008d7e <_vfprintf_r+0xe6e>
80008d42:	fa c8 f9 50 	sub	r8,sp,-1712
80008d46:	1a d8       	st.w	--sp,r8
80008d48:	fa c8 fa b8 	sub	r8,sp,-1352
80008d4c:	1a d8       	st.w	--sp,r8
80008d4e:	fa c8 fb b4 	sub	r8,sp,-1100
80008d52:	1a d8       	st.w	--sp,r8
80008d54:	fa c8 f9 40 	sub	r8,sp,-1728
80008d58:	fa c9 ff b4 	sub	r9,sp,-76
80008d5c:	04 9a       	mov	r10,r2
80008d5e:	0c 9b       	mov	r11,r6
80008d60:	08 9c       	mov	r12,r4
80008d62:	fe b0 f7 3f 	rcall	80007be0 <get_arg>
80008d66:	2f dd       	sub	sp,-12
80008d68:	98 18       	ld.sh	r8,r12[0x2]
80008d6a:	c2 68       	rjmp	80008db6 <_vfprintf_r+0xea6>
80008d6c:	ee ca ff ff 	sub	r10,r7,-1
80008d70:	10 37       	cp.w	r7,r8
80008d72:	c0 94       	brge	80008d84 <_vfprintf_r+0xe74>
80008d74:	fa c9 f9 44 	sub	r9,sp,-1724
80008d78:	14 97       	mov	r7,r10
80008d7a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008d7e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008d82:	c1 a8       	rjmp	80008db6 <_vfprintf_r+0xea6>
80008d84:	41 09       	lddsp	r9,sp[0x40]
80008d86:	59 f8       	cp.w	r8,31
80008d88:	e0 89 00 13 	brgt	80008dae <_vfprintf_r+0xe9e>
80008d8c:	f2 cb ff fc 	sub	r11,r9,-4
80008d90:	51 0b       	stdsp	sp[0x40],r11
80008d92:	72 09       	ld.w	r9,r9[0x0]
80008d94:	fa c6 f9 44 	sub	r6,sp,-1724
80008d98:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008d9c:	2f f8       	sub	r8,-1
80008d9e:	f7 49 fd 88 	st.w	r11[-632],r9
80008da2:	fb 48 06 b4 	st.w	sp[1716],r8
80008da6:	14 97       	mov	r7,r10
80008da8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008dac:	c0 58       	rjmp	80008db6 <_vfprintf_r+0xea6>
80008dae:	92 18       	ld.sh	r8,r9[0x2]
80008db0:	14 97       	mov	r7,r10
80008db2:	2f c9       	sub	r9,-4
80008db4:	51 09       	stdsp	sp[0x40],r9
80008db6:	5c 78       	castu.h	r8
80008db8:	50 18       	stdsp	sp[0x4],r8
80008dba:	c4 68       	rjmp	80008e46 <_vfprintf_r+0xf36>
80008dbc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008dc0:	40 3c       	lddsp	r12,sp[0xc]
80008dc2:	58 0c       	cp.w	r12,0
80008dc4:	c1 d0       	breq	80008dfe <_vfprintf_r+0xeee>
80008dc6:	10 36       	cp.w	r6,r8
80008dc8:	c0 64       	brge	80008dd4 <_vfprintf_r+0xec4>
80008dca:	fa cb f9 44 	sub	r11,sp,-1724
80008dce:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dd2:	c1 f8       	rjmp	80008e10 <_vfprintf_r+0xf00>
80008dd4:	fa c8 f9 50 	sub	r8,sp,-1712
80008dd8:	1a d8       	st.w	--sp,r8
80008dda:	fa c8 fa b8 	sub	r8,sp,-1352
80008dde:	0c 9b       	mov	r11,r6
80008de0:	1a d8       	st.w	--sp,r8
80008de2:	fa c8 fb b4 	sub	r8,sp,-1100
80008de6:	04 9a       	mov	r10,r2
80008de8:	1a d8       	st.w	--sp,r8
80008dea:	08 9c       	mov	r12,r4
80008dec:	fa c8 f9 40 	sub	r8,sp,-1728
80008df0:	fa c9 ff b4 	sub	r9,sp,-76
80008df4:	fe b0 f6 f6 	rcall	80007be0 <get_arg>
80008df8:	2f dd       	sub	sp,-12
80008dfa:	78 0b       	ld.w	r11,r12[0x0]
80008dfc:	c2 48       	rjmp	80008e44 <_vfprintf_r+0xf34>
80008dfe:	ee ca ff ff 	sub	r10,r7,-1
80008e02:	10 37       	cp.w	r7,r8
80008e04:	c0 94       	brge	80008e16 <_vfprintf_r+0xf06>
80008e06:	fa c9 f9 44 	sub	r9,sp,-1724
80008e0a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008e0e:	14 97       	mov	r7,r10
80008e10:	ec fb fd 88 	ld.w	r11,r6[-632]
80008e14:	c1 88       	rjmp	80008e44 <_vfprintf_r+0xf34>
80008e16:	41 09       	lddsp	r9,sp[0x40]
80008e18:	59 f8       	cp.w	r8,31
80008e1a:	e0 89 00 11 	brgt	80008e3c <_vfprintf_r+0xf2c>
80008e1e:	f2 cb ff fc 	sub	r11,r9,-4
80008e22:	51 0b       	stdsp	sp[0x40],r11
80008e24:	fa c6 f9 44 	sub	r6,sp,-1724
80008e28:	72 0b       	ld.w	r11,r9[0x0]
80008e2a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e2e:	f3 4b fd 88 	st.w	r9[-632],r11
80008e32:	2f f8       	sub	r8,-1
80008e34:	14 97       	mov	r7,r10
80008e36:	fb 48 06 b4 	st.w	sp[1716],r8
80008e3a:	c0 58       	rjmp	80008e44 <_vfprintf_r+0xf34>
80008e3c:	72 0b       	ld.w	r11,r9[0x0]
80008e3e:	14 97       	mov	r7,r10
80008e40:	2f c9       	sub	r9,-4
80008e42:	51 09       	stdsp	sp[0x40],r9
80008e44:	50 1b       	stdsp	sp[0x4],r11
80008e46:	30 0e       	mov	lr,0
80008e48:	50 0e       	stdsp	sp[0x0],lr
80008e4a:	1c 98       	mov	r8,lr
80008e4c:	e0 8f 02 fe 	bral	80009448 <_vfprintf_r+0x1538>
80008e50:	50 a7       	stdsp	sp[0x28],r7
80008e52:	50 80       	stdsp	sp[0x20],r0
80008e54:	0c 97       	mov	r7,r6
80008e56:	04 94       	mov	r4,r2
80008e58:	06 96       	mov	r6,r3
80008e5a:	02 92       	mov	r2,r1
80008e5c:	40 93       	lddsp	r3,sp[0x24]
80008e5e:	40 41       	lddsp	r1,sp[0x10]
80008e60:	0e 99       	mov	r9,r7
80008e62:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e66:	40 3c       	lddsp	r12,sp[0xc]
80008e68:	58 0c       	cp.w	r12,0
80008e6a:	c1 d0       	breq	80008ea4 <_vfprintf_r+0xf94>
80008e6c:	10 36       	cp.w	r6,r8
80008e6e:	c0 64       	brge	80008e7a <_vfprintf_r+0xf6a>
80008e70:	fa cb f9 44 	sub	r11,sp,-1724
80008e74:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e78:	c1 d8       	rjmp	80008eb2 <_vfprintf_r+0xfa2>
80008e7a:	fa c8 f9 50 	sub	r8,sp,-1712
80008e7e:	1a d8       	st.w	--sp,r8
80008e80:	fa c8 fa b8 	sub	r8,sp,-1352
80008e84:	1a d8       	st.w	--sp,r8
80008e86:	fa c8 fb b4 	sub	r8,sp,-1100
80008e8a:	1a d8       	st.w	--sp,r8
80008e8c:	fa c9 ff b4 	sub	r9,sp,-76
80008e90:	fa c8 f9 40 	sub	r8,sp,-1728
80008e94:	04 9a       	mov	r10,r2
80008e96:	0c 9b       	mov	r11,r6
80008e98:	08 9c       	mov	r12,r4
80008e9a:	fe b0 f6 a3 	rcall	80007be0 <get_arg>
80008e9e:	2f dd       	sub	sp,-12
80008ea0:	78 09       	ld.w	r9,r12[0x0]
80008ea2:	c2 18       	rjmp	80008ee4 <_vfprintf_r+0xfd4>
80008ea4:	2f f7       	sub	r7,-1
80008ea6:	10 39       	cp.w	r9,r8
80008ea8:	c0 84       	brge	80008eb8 <_vfprintf_r+0xfa8>
80008eaa:	fa ca f9 44 	sub	r10,sp,-1724
80008eae:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008eb2:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008eb6:	c1 78       	rjmp	80008ee4 <_vfprintf_r+0xfd4>
80008eb8:	41 09       	lddsp	r9,sp[0x40]
80008eba:	59 f8       	cp.w	r8,31
80008ebc:	e0 89 00 10 	brgt	80008edc <_vfprintf_r+0xfcc>
80008ec0:	f2 ca ff fc 	sub	r10,r9,-4
80008ec4:	51 0a       	stdsp	sp[0x40],r10
80008ec6:	fa c6 f9 44 	sub	r6,sp,-1724
80008eca:	72 09       	ld.w	r9,r9[0x0]
80008ecc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80008ed0:	f5 49 fd 88 	st.w	r10[-632],r9
80008ed4:	2f f8       	sub	r8,-1
80008ed6:	fb 48 06 b4 	st.w	sp[1716],r8
80008eda:	c0 58       	rjmp	80008ee4 <_vfprintf_r+0xfd4>
80008edc:	f2 c8 ff fc 	sub	r8,r9,-4
80008ee0:	51 08       	stdsp	sp[0x40],r8
80008ee2:	72 09       	ld.w	r9,r9[0x0]
80008ee4:	33 08       	mov	r8,48
80008ee6:	fb 68 06 b8 	st.b	sp[1720],r8
80008eea:	37 88       	mov	r8,120
80008eec:	30 0e       	mov	lr,0
80008eee:	fb 68 06 b9 	st.b	sp[1721],r8
80008ef2:	fe cc b1 62 	sub	r12,pc,-20126
80008ef6:	50 19       	stdsp	sp[0x4],r9
80008ef8:	a1 b5       	sbr	r5,0x1
80008efa:	50 0e       	stdsp	sp[0x0],lr
80008efc:	50 dc       	stdsp	sp[0x34],r12
80008efe:	30 28       	mov	r8,2
80008f00:	37 80       	mov	r0,120
80008f02:	e0 8f 02 a3 	bral	80009448 <_vfprintf_r+0x1538>
80008f06:	50 a7       	stdsp	sp[0x28],r7
80008f08:	50 80       	stdsp	sp[0x20],r0
80008f0a:	10 90       	mov	r0,r8
80008f0c:	30 08       	mov	r8,0
80008f0e:	fb 68 06 bb 	st.b	sp[1723],r8
80008f12:	0c 97       	mov	r7,r6
80008f14:	04 94       	mov	r4,r2
80008f16:	06 96       	mov	r6,r3
80008f18:	02 92       	mov	r2,r1
80008f1a:	40 93       	lddsp	r3,sp[0x24]
80008f1c:	40 41       	lddsp	r1,sp[0x10]
80008f1e:	0e 99       	mov	r9,r7
80008f20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f24:	40 3b       	lddsp	r11,sp[0xc]
80008f26:	58 0b       	cp.w	r11,0
80008f28:	c1 d0       	breq	80008f62 <_vfprintf_r+0x1052>
80008f2a:	10 36       	cp.w	r6,r8
80008f2c:	c0 64       	brge	80008f38 <_vfprintf_r+0x1028>
80008f2e:	fa ca f9 44 	sub	r10,sp,-1724
80008f32:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008f36:	c1 d8       	rjmp	80008f70 <_vfprintf_r+0x1060>
80008f38:	fa c8 f9 50 	sub	r8,sp,-1712
80008f3c:	1a d8       	st.w	--sp,r8
80008f3e:	fa c8 fa b8 	sub	r8,sp,-1352
80008f42:	1a d8       	st.w	--sp,r8
80008f44:	fa c8 fb b4 	sub	r8,sp,-1100
80008f48:	0c 9b       	mov	r11,r6
80008f4a:	1a d8       	st.w	--sp,r8
80008f4c:	04 9a       	mov	r10,r2
80008f4e:	fa c8 f9 40 	sub	r8,sp,-1728
80008f52:	fa c9 ff b4 	sub	r9,sp,-76
80008f56:	08 9c       	mov	r12,r4
80008f58:	fe b0 f6 44 	rcall	80007be0 <get_arg>
80008f5c:	2f dd       	sub	sp,-12
80008f5e:	78 06       	ld.w	r6,r12[0x0]
80008f60:	c2 08       	rjmp	80008fa0 <_vfprintf_r+0x1090>
80008f62:	2f f7       	sub	r7,-1
80008f64:	10 39       	cp.w	r9,r8
80008f66:	c0 84       	brge	80008f76 <_vfprintf_r+0x1066>
80008f68:	fa c9 f9 44 	sub	r9,sp,-1724
80008f6c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008f70:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008f74:	c1 68       	rjmp	80008fa0 <_vfprintf_r+0x1090>
80008f76:	41 09       	lddsp	r9,sp[0x40]
80008f78:	59 f8       	cp.w	r8,31
80008f7a:	e0 89 00 10 	brgt	80008f9a <_vfprintf_r+0x108a>
80008f7e:	f2 ca ff fc 	sub	r10,r9,-4
80008f82:	51 0a       	stdsp	sp[0x40],r10
80008f84:	72 06       	ld.w	r6,r9[0x0]
80008f86:	fa ce f9 44 	sub	lr,sp,-1724
80008f8a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008f8e:	f3 46 fd 88 	st.w	r9[-632],r6
80008f92:	2f f8       	sub	r8,-1
80008f94:	fb 48 06 b4 	st.w	sp[1716],r8
80008f98:	c0 48       	rjmp	80008fa0 <_vfprintf_r+0x1090>
80008f9a:	72 06       	ld.w	r6,r9[0x0]
80008f9c:	2f c9       	sub	r9,-4
80008f9e:	51 09       	stdsp	sp[0x40],r9
80008fa0:	40 2c       	lddsp	r12,sp[0x8]
80008fa2:	58 0c       	cp.w	r12,0
80008fa4:	c1 05       	brlt	80008fc4 <_vfprintf_r+0x10b4>
80008fa6:	18 9a       	mov	r10,r12
80008fa8:	30 0b       	mov	r11,0
80008faa:	0c 9c       	mov	r12,r6
80008fac:	e0 a0 12 38 	rcall	8000b41c <memchr>
80008fb0:	e0 80 02 df 	breq	8000956e <_vfprintf_r+0x165e>
80008fb4:	f8 06 01 02 	sub	r2,r12,r6
80008fb8:	40 2b       	lddsp	r11,sp[0x8]
80008fba:	16 32       	cp.w	r2,r11
80008fbc:	e0 89 02 d9 	brgt	8000956e <_vfprintf_r+0x165e>
80008fc0:	e0 8f 02 d4 	bral	80009568 <_vfprintf_r+0x1658>
80008fc4:	30 0a       	mov	r10,0
80008fc6:	0c 9c       	mov	r12,r6
80008fc8:	50 2a       	stdsp	sp[0x8],r10
80008fca:	e0 a0 15 99 	rcall	8000bafc <strlen>
80008fce:	18 92       	mov	r2,r12
80008fd0:	e0 8f 02 d2 	bral	80009574 <_vfprintf_r+0x1664>
80008fd4:	50 a7       	stdsp	sp[0x28],r7
80008fd6:	50 80       	stdsp	sp[0x20],r0
80008fd8:	0c 97       	mov	r7,r6
80008fda:	04 94       	mov	r4,r2
80008fdc:	06 96       	mov	r6,r3
80008fde:	02 92       	mov	r2,r1
80008fe0:	40 93       	lddsp	r3,sp[0x24]
80008fe2:	10 90       	mov	r0,r8
80008fe4:	40 41       	lddsp	r1,sp[0x10]
80008fe6:	a5 a5       	sbr	r5,0x4
80008fe8:	c0 a8       	rjmp	80008ffc <_vfprintf_r+0x10ec>
80008fea:	50 a7       	stdsp	sp[0x28],r7
80008fec:	50 80       	stdsp	sp[0x20],r0
80008fee:	0c 97       	mov	r7,r6
80008ff0:	04 94       	mov	r4,r2
80008ff2:	06 96       	mov	r6,r3
80008ff4:	02 92       	mov	r2,r1
80008ff6:	40 93       	lddsp	r3,sp[0x24]
80008ff8:	10 90       	mov	r0,r8
80008ffa:	40 41       	lddsp	r1,sp[0x10]
80008ffc:	ed b5 00 05 	bld	r5,0x5
80009000:	c5 61       	brne	800090ac <_vfprintf_r+0x119c>
80009002:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009006:	40 39       	lddsp	r9,sp[0xc]
80009008:	58 09       	cp.w	r9,0
8000900a:	c2 10       	breq	8000904c <_vfprintf_r+0x113c>
8000900c:	10 36       	cp.w	r6,r8
8000900e:	c0 74       	brge	8000901c <_vfprintf_r+0x110c>
80009010:	fa c8 f9 44 	sub	r8,sp,-1724
80009014:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009018:	c2 38       	rjmp	8000905e <_vfprintf_r+0x114e>
8000901a:	d7 03       	nop
8000901c:	fa c8 f9 50 	sub	r8,sp,-1712
80009020:	1a d8       	st.w	--sp,r8
80009022:	fa c8 fa b8 	sub	r8,sp,-1352
80009026:	1a d8       	st.w	--sp,r8
80009028:	fa c8 fb b4 	sub	r8,sp,-1100
8000902c:	1a d8       	st.w	--sp,r8
8000902e:	fa c8 f9 40 	sub	r8,sp,-1728
80009032:	fa c9 ff b4 	sub	r9,sp,-76
80009036:	04 9a       	mov	r10,r2
80009038:	0c 9b       	mov	r11,r6
8000903a:	08 9c       	mov	r12,r4
8000903c:	fe b0 f5 d2 	rcall	80007be0 <get_arg>
80009040:	2f dd       	sub	sp,-12
80009042:	f8 e8 00 00 	ld.d	r8,r12[0]
80009046:	fa e9 00 00 	st.d	sp[0],r8
8000904a:	c2 e8       	rjmp	800090a6 <_vfprintf_r+0x1196>
8000904c:	ee ca ff ff 	sub	r10,r7,-1
80009050:	10 37       	cp.w	r7,r8
80009052:	c0 b4       	brge	80009068 <_vfprintf_r+0x1158>
80009054:	fa c8 f9 44 	sub	r8,sp,-1724
80009058:	14 97       	mov	r7,r10
8000905a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000905e:	ec ea fd 88 	ld.d	r10,r6[-632]
80009062:	fa eb 00 00 	st.d	sp[0],r10
80009066:	c2 08       	rjmp	800090a6 <_vfprintf_r+0x1196>
80009068:	41 09       	lddsp	r9,sp[0x40]
8000906a:	59 f8       	cp.w	r8,31
8000906c:	e0 89 00 16 	brgt	80009098 <_vfprintf_r+0x1188>
80009070:	f2 e6 00 00 	ld.d	r6,r9[0]
80009074:	f2 cb ff f8 	sub	r11,r9,-8
80009078:	fa e7 00 00 	st.d	sp[0],r6
8000907c:	51 0b       	stdsp	sp[0x40],r11
8000907e:	fa c6 f9 44 	sub	r6,sp,-1724
80009082:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009086:	fa e6 00 00 	ld.d	r6,sp[0]
8000908a:	f2 e7 fd 88 	st.d	r9[-632],r6
8000908e:	2f f8       	sub	r8,-1
80009090:	14 97       	mov	r7,r10
80009092:	fb 48 06 b4 	st.w	sp[1716],r8
80009096:	c0 88       	rjmp	800090a6 <_vfprintf_r+0x1196>
80009098:	f2 e6 00 00 	ld.d	r6,r9[0]
8000909c:	2f 89       	sub	r9,-8
8000909e:	fa e7 00 00 	st.d	sp[0],r6
800090a2:	51 09       	stdsp	sp[0x40],r9
800090a4:	14 97       	mov	r7,r10
800090a6:	30 18       	mov	r8,1
800090a8:	e0 8f 01 d0 	bral	80009448 <_vfprintf_r+0x1538>
800090ac:	ed b5 00 04 	bld	r5,0x4
800090b0:	c1 61       	brne	800090dc <_vfprintf_r+0x11cc>
800090b2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090b6:	40 3e       	lddsp	lr,sp[0xc]
800090b8:	58 0e       	cp.w	lr,0
800090ba:	c0 80       	breq	800090ca <_vfprintf_r+0x11ba>
800090bc:	10 36       	cp.w	r6,r8
800090be:	c6 74       	brge	8000918c <_vfprintf_r+0x127c>
800090c0:	fa cc f9 44 	sub	r12,sp,-1724
800090c4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800090c8:	c8 08       	rjmp	800091c8 <_vfprintf_r+0x12b8>
800090ca:	ee ca ff ff 	sub	r10,r7,-1
800090ce:	10 37       	cp.w	r7,r8
800090d0:	c7 f4       	brge	800091ce <_vfprintf_r+0x12be>
800090d2:	fa cb f9 44 	sub	r11,sp,-1724
800090d6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090da:	c7 68       	rjmp	800091c6 <_vfprintf_r+0x12b6>
800090dc:	ed b5 00 06 	bld	r5,0x6
800090e0:	c4 a1       	brne	80009174 <_vfprintf_r+0x1264>
800090e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090e6:	40 3c       	lddsp	r12,sp[0xc]
800090e8:	58 0c       	cp.w	r12,0
800090ea:	c1 d0       	breq	80009124 <_vfprintf_r+0x1214>
800090ec:	10 36       	cp.w	r6,r8
800090ee:	c0 64       	brge	800090fa <_vfprintf_r+0x11ea>
800090f0:	fa cb f9 44 	sub	r11,sp,-1724
800090f4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090f8:	c1 f8       	rjmp	80009136 <_vfprintf_r+0x1226>
800090fa:	fa c8 f9 50 	sub	r8,sp,-1712
800090fe:	1a d8       	st.w	--sp,r8
80009100:	fa c8 fa b8 	sub	r8,sp,-1352
80009104:	1a d8       	st.w	--sp,r8
80009106:	fa c8 fb b4 	sub	r8,sp,-1100
8000910a:	1a d8       	st.w	--sp,r8
8000910c:	fa c8 f9 40 	sub	r8,sp,-1728
80009110:	fa c9 ff b4 	sub	r9,sp,-76
80009114:	04 9a       	mov	r10,r2
80009116:	0c 9b       	mov	r11,r6
80009118:	08 9c       	mov	r12,r4
8000911a:	fe b0 f5 63 	rcall	80007be0 <get_arg>
8000911e:	2f dd       	sub	sp,-12
80009120:	98 18       	ld.sh	r8,r12[0x2]
80009122:	c2 68       	rjmp	8000916e <_vfprintf_r+0x125e>
80009124:	ee ca ff ff 	sub	r10,r7,-1
80009128:	10 37       	cp.w	r7,r8
8000912a:	c0 94       	brge	8000913c <_vfprintf_r+0x122c>
8000912c:	fa c9 f9 44 	sub	r9,sp,-1724
80009130:	14 97       	mov	r7,r10
80009132:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009136:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000913a:	c1 a8       	rjmp	8000916e <_vfprintf_r+0x125e>
8000913c:	41 09       	lddsp	r9,sp[0x40]
8000913e:	59 f8       	cp.w	r8,31
80009140:	e0 89 00 13 	brgt	80009166 <_vfprintf_r+0x1256>
80009144:	f2 cb ff fc 	sub	r11,r9,-4
80009148:	51 0b       	stdsp	sp[0x40],r11
8000914a:	72 09       	ld.w	r9,r9[0x0]
8000914c:	fa c6 f9 44 	sub	r6,sp,-1724
80009150:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009154:	2f f8       	sub	r8,-1
80009156:	f7 49 fd 88 	st.w	r11[-632],r9
8000915a:	fb 48 06 b4 	st.w	sp[1716],r8
8000915e:	14 97       	mov	r7,r10
80009160:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009164:	c0 58       	rjmp	8000916e <_vfprintf_r+0x125e>
80009166:	92 18       	ld.sh	r8,r9[0x2]
80009168:	14 97       	mov	r7,r10
8000916a:	2f c9       	sub	r9,-4
8000916c:	51 09       	stdsp	sp[0x40],r9
8000916e:	5c 78       	castu.h	r8
80009170:	50 18       	stdsp	sp[0x4],r8
80009172:	c4 68       	rjmp	800091fe <_vfprintf_r+0x12ee>
80009174:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009178:	40 3c       	lddsp	r12,sp[0xc]
8000917a:	58 0c       	cp.w	r12,0
8000917c:	c1 d0       	breq	800091b6 <_vfprintf_r+0x12a6>
8000917e:	10 36       	cp.w	r6,r8
80009180:	c0 64       	brge	8000918c <_vfprintf_r+0x127c>
80009182:	fa cb f9 44 	sub	r11,sp,-1724
80009186:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000918a:	c1 f8       	rjmp	800091c8 <_vfprintf_r+0x12b8>
8000918c:	fa c8 f9 50 	sub	r8,sp,-1712
80009190:	1a d8       	st.w	--sp,r8
80009192:	fa c8 fa b8 	sub	r8,sp,-1352
80009196:	0c 9b       	mov	r11,r6
80009198:	1a d8       	st.w	--sp,r8
8000919a:	fa c8 fb b4 	sub	r8,sp,-1100
8000919e:	04 9a       	mov	r10,r2
800091a0:	1a d8       	st.w	--sp,r8
800091a2:	08 9c       	mov	r12,r4
800091a4:	fa c8 f9 40 	sub	r8,sp,-1728
800091a8:	fa c9 ff b4 	sub	r9,sp,-76
800091ac:	fe b0 f5 1a 	rcall	80007be0 <get_arg>
800091b0:	2f dd       	sub	sp,-12
800091b2:	78 0b       	ld.w	r11,r12[0x0]
800091b4:	c2 48       	rjmp	800091fc <_vfprintf_r+0x12ec>
800091b6:	ee ca ff ff 	sub	r10,r7,-1
800091ba:	10 37       	cp.w	r7,r8
800091bc:	c0 94       	brge	800091ce <_vfprintf_r+0x12be>
800091be:	fa c9 f9 44 	sub	r9,sp,-1724
800091c2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800091c6:	14 97       	mov	r7,r10
800091c8:	ec fb fd 88 	ld.w	r11,r6[-632]
800091cc:	c1 88       	rjmp	800091fc <_vfprintf_r+0x12ec>
800091ce:	41 09       	lddsp	r9,sp[0x40]
800091d0:	59 f8       	cp.w	r8,31
800091d2:	e0 89 00 11 	brgt	800091f4 <_vfprintf_r+0x12e4>
800091d6:	f2 cb ff fc 	sub	r11,r9,-4
800091da:	51 0b       	stdsp	sp[0x40],r11
800091dc:	fa c6 f9 44 	sub	r6,sp,-1724
800091e0:	72 0b       	ld.w	r11,r9[0x0]
800091e2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800091e6:	f3 4b fd 88 	st.w	r9[-632],r11
800091ea:	2f f8       	sub	r8,-1
800091ec:	14 97       	mov	r7,r10
800091ee:	fb 48 06 b4 	st.w	sp[1716],r8
800091f2:	c0 58       	rjmp	800091fc <_vfprintf_r+0x12ec>
800091f4:	72 0b       	ld.w	r11,r9[0x0]
800091f6:	14 97       	mov	r7,r10
800091f8:	2f c9       	sub	r9,-4
800091fa:	51 09       	stdsp	sp[0x40],r9
800091fc:	50 1b       	stdsp	sp[0x4],r11
800091fe:	30 0e       	mov	lr,0
80009200:	30 18       	mov	r8,1
80009202:	50 0e       	stdsp	sp[0x0],lr
80009204:	c2 29       	rjmp	80009448 <_vfprintf_r+0x1538>
80009206:	50 a7       	stdsp	sp[0x28],r7
80009208:	50 80       	stdsp	sp[0x20],r0
8000920a:	0c 97       	mov	r7,r6
8000920c:	04 94       	mov	r4,r2
8000920e:	06 96       	mov	r6,r3
80009210:	02 92       	mov	r2,r1
80009212:	fe cc b4 82 	sub	r12,pc,-19326
80009216:	40 93       	lddsp	r3,sp[0x24]
80009218:	10 90       	mov	r0,r8
8000921a:	40 41       	lddsp	r1,sp[0x10]
8000921c:	50 dc       	stdsp	sp[0x34],r12
8000921e:	ed b5 00 05 	bld	r5,0x5
80009222:	c5 51       	brne	800092cc <_vfprintf_r+0x13bc>
80009224:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009228:	40 3b       	lddsp	r11,sp[0xc]
8000922a:	58 0b       	cp.w	r11,0
8000922c:	c2 20       	breq	80009270 <_vfprintf_r+0x1360>
8000922e:	10 36       	cp.w	r6,r8
80009230:	c0 a4       	brge	80009244 <_vfprintf_r+0x1334>
80009232:	fa ca f9 44 	sub	r10,sp,-1724
80009236:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000923a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000923e:	fa e9 00 00 	st.d	sp[0],r8
80009242:	cf 28       	rjmp	80009426 <_vfprintf_r+0x1516>
80009244:	fa c8 f9 50 	sub	r8,sp,-1712
80009248:	1a d8       	st.w	--sp,r8
8000924a:	fa c8 fa b8 	sub	r8,sp,-1352
8000924e:	04 9a       	mov	r10,r2
80009250:	1a d8       	st.w	--sp,r8
80009252:	0c 9b       	mov	r11,r6
80009254:	fa c8 fb b4 	sub	r8,sp,-1100
80009258:	08 9c       	mov	r12,r4
8000925a:	1a d8       	st.w	--sp,r8
8000925c:	fa c8 f9 40 	sub	r8,sp,-1728
80009260:	fa c9 ff b4 	sub	r9,sp,-76
80009264:	fe b0 f4 be 	rcall	80007be0 <get_arg>
80009268:	2f dd       	sub	sp,-12
8000926a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000926e:	c0 c8       	rjmp	80009286 <_vfprintf_r+0x1376>
80009270:	ee ca ff ff 	sub	r10,r7,-1
80009274:	10 37       	cp.w	r7,r8
80009276:	c0 b4       	brge	8000928c <_vfprintf_r+0x137c>
80009278:	fa c9 f9 44 	sub	r9,sp,-1724
8000927c:	14 97       	mov	r7,r10
8000927e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009282:	ec ea fd 88 	ld.d	r10,r6[-632]
80009286:	fa eb 00 00 	st.d	sp[0],r10
8000928a:	cc e8       	rjmp	80009426 <_vfprintf_r+0x1516>
8000928c:	41 09       	lddsp	r9,sp[0x40]
8000928e:	59 f8       	cp.w	r8,31
80009290:	e0 89 00 16 	brgt	800092bc <_vfprintf_r+0x13ac>
80009294:	f2 e6 00 00 	ld.d	r6,r9[0]
80009298:	f2 cb ff f8 	sub	r11,r9,-8
8000929c:	fa e7 00 00 	st.d	sp[0],r6
800092a0:	51 0b       	stdsp	sp[0x40],r11
800092a2:	fa c6 f9 44 	sub	r6,sp,-1724
800092a6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800092aa:	fa e6 00 00 	ld.d	r6,sp[0]
800092ae:	f2 e7 fd 88 	st.d	r9[-632],r6
800092b2:	2f f8       	sub	r8,-1
800092b4:	14 97       	mov	r7,r10
800092b6:	fb 48 06 b4 	st.w	sp[1716],r8
800092ba:	cb 68       	rjmp	80009426 <_vfprintf_r+0x1516>
800092bc:	f2 e6 00 00 	ld.d	r6,r9[0]
800092c0:	2f 89       	sub	r9,-8
800092c2:	fa e7 00 00 	st.d	sp[0],r6
800092c6:	51 09       	stdsp	sp[0x40],r9
800092c8:	14 97       	mov	r7,r10
800092ca:	ca e8       	rjmp	80009426 <_vfprintf_r+0x1516>
800092cc:	ed b5 00 04 	bld	r5,0x4
800092d0:	c1 71       	brne	800092fe <_vfprintf_r+0x13ee>
800092d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800092d6:	40 3e       	lddsp	lr,sp[0xc]
800092d8:	58 0e       	cp.w	lr,0
800092da:	c0 80       	breq	800092ea <_vfprintf_r+0x13da>
800092dc:	10 36       	cp.w	r6,r8
800092de:	c6 94       	brge	800093b0 <_vfprintf_r+0x14a0>
800092e0:	fa cc f9 44 	sub	r12,sp,-1724
800092e4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800092e8:	c8 28       	rjmp	800093ec <_vfprintf_r+0x14dc>
800092ea:	ee ca ff ff 	sub	r10,r7,-1
800092ee:	10 37       	cp.w	r7,r8
800092f0:	e0 84 00 81 	brge	800093f2 <_vfprintf_r+0x14e2>
800092f4:	fa cb f9 44 	sub	r11,sp,-1724
800092f8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800092fc:	c7 78       	rjmp	800093ea <_vfprintf_r+0x14da>
800092fe:	ed b5 00 06 	bld	r5,0x6
80009302:	c4 b1       	brne	80009398 <_vfprintf_r+0x1488>
80009304:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009308:	40 3c       	lddsp	r12,sp[0xc]
8000930a:	58 0c       	cp.w	r12,0
8000930c:	c1 d0       	breq	80009346 <_vfprintf_r+0x1436>
8000930e:	10 36       	cp.w	r6,r8
80009310:	c0 64       	brge	8000931c <_vfprintf_r+0x140c>
80009312:	fa cb f9 44 	sub	r11,sp,-1724
80009316:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000931a:	c1 f8       	rjmp	80009358 <_vfprintf_r+0x1448>
8000931c:	fa c8 f9 50 	sub	r8,sp,-1712
80009320:	1a d8       	st.w	--sp,r8
80009322:	fa c8 fa b8 	sub	r8,sp,-1352
80009326:	1a d8       	st.w	--sp,r8
80009328:	fa c8 fb b4 	sub	r8,sp,-1100
8000932c:	1a d8       	st.w	--sp,r8
8000932e:	fa c8 f9 40 	sub	r8,sp,-1728
80009332:	fa c9 ff b4 	sub	r9,sp,-76
80009336:	04 9a       	mov	r10,r2
80009338:	0c 9b       	mov	r11,r6
8000933a:	08 9c       	mov	r12,r4
8000933c:	fe b0 f4 52 	rcall	80007be0 <get_arg>
80009340:	2f dd       	sub	sp,-12
80009342:	98 18       	ld.sh	r8,r12[0x2]
80009344:	c2 78       	rjmp	80009392 <_vfprintf_r+0x1482>
80009346:	ee ca ff ff 	sub	r10,r7,-1
8000934a:	10 37       	cp.w	r7,r8
8000934c:	c0 a4       	brge	80009360 <_vfprintf_r+0x1450>
8000934e:	fa c9 f9 44 	sub	r9,sp,-1724
80009352:	14 97       	mov	r7,r10
80009354:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009358:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000935c:	c1 b8       	rjmp	80009392 <_vfprintf_r+0x1482>
8000935e:	d7 03       	nop
80009360:	41 09       	lddsp	r9,sp[0x40]
80009362:	59 f8       	cp.w	r8,31
80009364:	e0 89 00 13 	brgt	8000938a <_vfprintf_r+0x147a>
80009368:	f2 cb ff fc 	sub	r11,r9,-4
8000936c:	51 0b       	stdsp	sp[0x40],r11
8000936e:	72 09       	ld.w	r9,r9[0x0]
80009370:	fa c6 f9 44 	sub	r6,sp,-1724
80009374:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009378:	2f f8       	sub	r8,-1
8000937a:	f7 49 fd 88 	st.w	r11[-632],r9
8000937e:	fb 48 06 b4 	st.w	sp[1716],r8
80009382:	14 97       	mov	r7,r10
80009384:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009388:	c0 58       	rjmp	80009392 <_vfprintf_r+0x1482>
8000938a:	92 18       	ld.sh	r8,r9[0x2]
8000938c:	14 97       	mov	r7,r10
8000938e:	2f c9       	sub	r9,-4
80009390:	51 09       	stdsp	sp[0x40],r9
80009392:	5c 78       	castu.h	r8
80009394:	50 18       	stdsp	sp[0x4],r8
80009396:	c4 68       	rjmp	80009422 <_vfprintf_r+0x1512>
80009398:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000939c:	40 3c       	lddsp	r12,sp[0xc]
8000939e:	58 0c       	cp.w	r12,0
800093a0:	c1 d0       	breq	800093da <_vfprintf_r+0x14ca>
800093a2:	10 36       	cp.w	r6,r8
800093a4:	c0 64       	brge	800093b0 <_vfprintf_r+0x14a0>
800093a6:	fa cb f9 44 	sub	r11,sp,-1724
800093aa:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093ae:	c1 f8       	rjmp	800093ec <_vfprintf_r+0x14dc>
800093b0:	fa c8 f9 50 	sub	r8,sp,-1712
800093b4:	1a d8       	st.w	--sp,r8
800093b6:	fa c8 fa b8 	sub	r8,sp,-1352
800093ba:	0c 9b       	mov	r11,r6
800093bc:	1a d8       	st.w	--sp,r8
800093be:	fa c8 fb b4 	sub	r8,sp,-1100
800093c2:	04 9a       	mov	r10,r2
800093c4:	1a d8       	st.w	--sp,r8
800093c6:	08 9c       	mov	r12,r4
800093c8:	fa c8 f9 40 	sub	r8,sp,-1728
800093cc:	fa c9 ff b4 	sub	r9,sp,-76
800093d0:	fe b0 f4 08 	rcall	80007be0 <get_arg>
800093d4:	2f dd       	sub	sp,-12
800093d6:	78 0b       	ld.w	r11,r12[0x0]
800093d8:	c2 48       	rjmp	80009420 <_vfprintf_r+0x1510>
800093da:	ee ca ff ff 	sub	r10,r7,-1
800093de:	10 37       	cp.w	r7,r8
800093e0:	c0 94       	brge	800093f2 <_vfprintf_r+0x14e2>
800093e2:	fa c9 f9 44 	sub	r9,sp,-1724
800093e6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800093ea:	14 97       	mov	r7,r10
800093ec:	ec fb fd 88 	ld.w	r11,r6[-632]
800093f0:	c1 88       	rjmp	80009420 <_vfprintf_r+0x1510>
800093f2:	41 09       	lddsp	r9,sp[0x40]
800093f4:	59 f8       	cp.w	r8,31
800093f6:	e0 89 00 11 	brgt	80009418 <_vfprintf_r+0x1508>
800093fa:	f2 cb ff fc 	sub	r11,r9,-4
800093fe:	51 0b       	stdsp	sp[0x40],r11
80009400:	fa c6 f9 44 	sub	r6,sp,-1724
80009404:	72 0b       	ld.w	r11,r9[0x0]
80009406:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000940a:	f3 4b fd 88 	st.w	r9[-632],r11
8000940e:	2f f8       	sub	r8,-1
80009410:	14 97       	mov	r7,r10
80009412:	fb 48 06 b4 	st.w	sp[1716],r8
80009416:	c0 58       	rjmp	80009420 <_vfprintf_r+0x1510>
80009418:	72 0b       	ld.w	r11,r9[0x0]
8000941a:	14 97       	mov	r7,r10
8000941c:	2f c9       	sub	r9,-4
8000941e:	51 09       	stdsp	sp[0x40],r9
80009420:	50 1b       	stdsp	sp[0x4],r11
80009422:	30 0e       	mov	lr,0
80009424:	50 0e       	stdsp	sp[0x0],lr
80009426:	40 08       	lddsp	r8,sp[0x0]
80009428:	40 1c       	lddsp	r12,sp[0x4]
8000942a:	18 48       	or	r8,r12
8000942c:	5f 19       	srne	r9
8000942e:	0a 98       	mov	r8,r5
80009430:	eb e9 00 09 	and	r9,r5,r9
80009434:	a1 b8       	sbr	r8,0x1
80009436:	58 09       	cp.w	r9,0
80009438:	c0 70       	breq	80009446 <_vfprintf_r+0x1536>
8000943a:	10 95       	mov	r5,r8
8000943c:	fb 60 06 b9 	st.b	sp[1721],r0
80009440:	33 08       	mov	r8,48
80009442:	fb 68 06 b8 	st.b	sp[1720],r8
80009446:	30 28       	mov	r8,2
80009448:	30 09       	mov	r9,0
8000944a:	fb 69 06 bb 	st.b	sp[1723],r9
8000944e:	0a 99       	mov	r9,r5
80009450:	a7 d9       	cbr	r9,0x7
80009452:	40 2b       	lddsp	r11,sp[0x8]
80009454:	40 16       	lddsp	r6,sp[0x4]
80009456:	58 0b       	cp.w	r11,0
80009458:	5f 1a       	srne	r10
8000945a:	f2 05 17 40 	movge	r5,r9
8000945e:	fa c2 f9 78 	sub	r2,sp,-1672
80009462:	40 09       	lddsp	r9,sp[0x0]
80009464:	0c 49       	or	r9,r6
80009466:	5f 19       	srne	r9
80009468:	f5 e9 10 09 	or	r9,r10,r9
8000946c:	c5 c0       	breq	80009524 <_vfprintf_r+0x1614>
8000946e:	30 19       	mov	r9,1
80009470:	f2 08 18 00 	cp.b	r8,r9
80009474:	c0 60       	breq	80009480 <_vfprintf_r+0x1570>
80009476:	30 29       	mov	r9,2
80009478:	f2 08 18 00 	cp.b	r8,r9
8000947c:	c0 41       	brne	80009484 <_vfprintf_r+0x1574>
8000947e:	c3 c8       	rjmp	800094f6 <_vfprintf_r+0x15e6>
80009480:	04 96       	mov	r6,r2
80009482:	c3 08       	rjmp	800094e2 <_vfprintf_r+0x15d2>
80009484:	04 96       	mov	r6,r2
80009486:	fa e8 00 00 	ld.d	r8,sp[0]
8000948a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000948e:	2d 0a       	sub	r10,-48
80009490:	0c fa       	st.b	--r6,r10
80009492:	f0 0b 16 03 	lsr	r11,r8,0x3
80009496:	f2 0c 16 03 	lsr	r12,r9,0x3
8000949a:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000949e:	18 99       	mov	r9,r12
800094a0:	16 98       	mov	r8,r11
800094a2:	58 08       	cp.w	r8,0
800094a4:	5c 29       	cpc	r9
800094a6:	cf 21       	brne	8000948a <_vfprintf_r+0x157a>
800094a8:	fa e9 00 00 	st.d	sp[0],r8
800094ac:	ed b5 00 00 	bld	r5,0x0
800094b0:	c4 51       	brne	8000953a <_vfprintf_r+0x162a>
800094b2:	33 09       	mov	r9,48
800094b4:	f2 0a 18 00 	cp.b	r10,r9
800094b8:	c4 10       	breq	8000953a <_vfprintf_r+0x162a>
800094ba:	0c f9       	st.b	--r6,r9
800094bc:	c3 f8       	rjmp	8000953a <_vfprintf_r+0x162a>
800094be:	fa ea 00 00 	ld.d	r10,sp[0]
800094c2:	30 a8       	mov	r8,10
800094c4:	30 09       	mov	r9,0
800094c6:	e0 a0 1a 19 	rcall	8000c8f8 <__avr32_umod64>
800094ca:	30 a8       	mov	r8,10
800094cc:	2d 0a       	sub	r10,-48
800094ce:	30 09       	mov	r9,0
800094d0:	ac 8a       	st.b	r6[0x0],r10
800094d2:	fa ea 00 00 	ld.d	r10,sp[0]
800094d6:	e0 a0 18 df 	rcall	8000c694 <__avr32_udiv64>
800094da:	16 99       	mov	r9,r11
800094dc:	14 98       	mov	r8,r10
800094de:	fa e9 00 00 	st.d	sp[0],r8
800094e2:	20 16       	sub	r6,1
800094e4:	fa ea 00 00 	ld.d	r10,sp[0]
800094e8:	58 9a       	cp.w	r10,9
800094ea:	5c 2b       	cpc	r11
800094ec:	fe 9b ff e9 	brhi	800094be <_vfprintf_r+0x15ae>
800094f0:	1b f8       	ld.ub	r8,sp[0x7]
800094f2:	2d 08       	sub	r8,-48
800094f4:	c2 08       	rjmp	80009534 <_vfprintf_r+0x1624>
800094f6:	04 96       	mov	r6,r2
800094f8:	fa e8 00 00 	ld.d	r8,sp[0]
800094fc:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009500:	40 de       	lddsp	lr,sp[0x34]
80009502:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80009506:	0c fa       	st.b	--r6,r10
80009508:	f2 0b 16 04 	lsr	r11,r9,0x4
8000950c:	f0 0a 16 04 	lsr	r10,r8,0x4
80009510:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009514:	16 99       	mov	r9,r11
80009516:	14 98       	mov	r8,r10
80009518:	58 08       	cp.w	r8,0
8000951a:	5c 29       	cpc	r9
8000951c:	cf 01       	brne	800094fc <_vfprintf_r+0x15ec>
8000951e:	fa e9 00 00 	st.d	sp[0],r8
80009522:	c0 c8       	rjmp	8000953a <_vfprintf_r+0x162a>
80009524:	58 08       	cp.w	r8,0
80009526:	c0 91       	brne	80009538 <_vfprintf_r+0x1628>
80009528:	ed b5 00 00 	bld	r5,0x0
8000952c:	c0 61       	brne	80009538 <_vfprintf_r+0x1628>
8000952e:	fa c6 f9 79 	sub	r6,sp,-1671
80009532:	33 08       	mov	r8,48
80009534:	ac 88       	st.b	r6[0x0],r8
80009536:	c0 28       	rjmp	8000953a <_vfprintf_r+0x162a>
80009538:	04 96       	mov	r6,r2
8000953a:	0c 12       	sub	r2,r6
8000953c:	c1 c8       	rjmp	80009574 <_vfprintf_r+0x1664>
8000953e:	50 a7       	stdsp	sp[0x28],r7
80009540:	50 80       	stdsp	sp[0x20],r0
80009542:	40 93       	lddsp	r3,sp[0x24]
80009544:	0c 97       	mov	r7,r6
80009546:	10 90       	mov	r0,r8
80009548:	04 94       	mov	r4,r2
8000954a:	40 41       	lddsp	r1,sp[0x10]
8000954c:	58 08       	cp.w	r8,0
8000954e:	e0 80 04 4f 	breq	80009dec <_vfprintf_r+0x1edc>
80009552:	fb 68 06 60 	st.b	sp[1632],r8
80009556:	30 0c       	mov	r12,0
80009558:	30 08       	mov	r8,0
8000955a:	30 12       	mov	r2,1
8000955c:	fb 68 06 bb 	st.b	sp[1723],r8
80009560:	50 2c       	stdsp	sp[0x8],r12
80009562:	fa c6 f9 a0 	sub	r6,sp,-1632
80009566:	c0 78       	rjmp	80009574 <_vfprintf_r+0x1664>
80009568:	30 0b       	mov	r11,0
8000956a:	50 2b       	stdsp	sp[0x8],r11
8000956c:	c0 48       	rjmp	80009574 <_vfprintf_r+0x1664>
8000956e:	40 22       	lddsp	r2,sp[0x8]
80009570:	30 0a       	mov	r10,0
80009572:	50 2a       	stdsp	sp[0x8],r10
80009574:	40 29       	lddsp	r9,sp[0x8]
80009576:	e4 09 0c 49 	max	r9,r2,r9
8000957a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000957e:	50 39       	stdsp	sp[0xc],r9
80009580:	0a 9e       	mov	lr,r5
80009582:	30 09       	mov	r9,0
80009584:	e2 1e 00 02 	andl	lr,0x2,COH
80009588:	f2 08 18 00 	cp.b	r8,r9
8000958c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009590:	f7 b8 01 ff 	subne	r8,-1
80009594:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009598:	0a 9b       	mov	r11,r5
8000959a:	58 0e       	cp.w	lr,0
8000959c:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800095a0:	f7 bc 01 fe 	subne	r12,-2
800095a4:	fb fc 1a 03 	st.wne	sp[0xc],r12
800095a8:	e2 1b 00 84 	andl	r11,0x84,COH
800095ac:	50 fe       	stdsp	sp[0x3c],lr
800095ae:	50 9b       	stdsp	sp[0x24],r11
800095b0:	c4 71       	brne	8000963e <_vfprintf_r+0x172e>
800095b2:	40 8a       	lddsp	r10,sp[0x20]
800095b4:	40 39       	lddsp	r9,sp[0xc]
800095b6:	12 1a       	sub	r10,r9
800095b8:	50 4a       	stdsp	sp[0x10],r10
800095ba:	58 0a       	cp.w	r10,0
800095bc:	e0 89 00 20 	brgt	800095fc <_vfprintf_r+0x16ec>
800095c0:	c3 f8       	rjmp	8000963e <_vfprintf_r+0x172e>
800095c2:	2f 09       	sub	r9,-16
800095c4:	2f f8       	sub	r8,-1
800095c6:	fe ce b8 1e 	sub	lr,pc,-18402
800095ca:	31 0c       	mov	r12,16
800095cc:	fb 49 06 90 	st.w	sp[1680],r9
800095d0:	87 0e       	st.w	r3[0x0],lr
800095d2:	87 1c       	st.w	r3[0x4],r12
800095d4:	fb 48 06 8c 	st.w	sp[1676],r8
800095d8:	58 78       	cp.w	r8,7
800095da:	e0 89 00 04 	brgt	800095e2 <_vfprintf_r+0x16d2>
800095de:	2f 83       	sub	r3,-8
800095e0:	c0 b8       	rjmp	800095f6 <_vfprintf_r+0x16e6>
800095e2:	fa ca f9 78 	sub	r10,sp,-1672
800095e6:	02 9b       	mov	r11,r1
800095e8:	08 9c       	mov	r12,r4
800095ea:	fe b0 f4 85 	rcall	80007ef4 <__sprint_r>
800095ee:	e0 81 04 10 	brne	80009e0e <_vfprintf_r+0x1efe>
800095f2:	fa c3 f9 e0 	sub	r3,sp,-1568
800095f6:	40 4b       	lddsp	r11,sp[0x10]
800095f8:	21 0b       	sub	r11,16
800095fa:	50 4b       	stdsp	sp[0x10],r11
800095fc:	fa f9 06 90 	ld.w	r9,sp[1680]
80009600:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009604:	fe ca b8 5c 	sub	r10,pc,-18340
80009608:	40 4e       	lddsp	lr,sp[0x10]
8000960a:	59 0e       	cp.w	lr,16
8000960c:	fe 99 ff db 	brgt	800095c2 <_vfprintf_r+0x16b2>
80009610:	1c 09       	add	r9,lr
80009612:	2f f8       	sub	r8,-1
80009614:	87 0a       	st.w	r3[0x0],r10
80009616:	fb 49 06 90 	st.w	sp[1680],r9
8000961a:	87 1e       	st.w	r3[0x4],lr
8000961c:	fb 48 06 8c 	st.w	sp[1676],r8
80009620:	58 78       	cp.w	r8,7
80009622:	e0 89 00 04 	brgt	8000962a <_vfprintf_r+0x171a>
80009626:	2f 83       	sub	r3,-8
80009628:	c0 b8       	rjmp	8000963e <_vfprintf_r+0x172e>
8000962a:	fa ca f9 78 	sub	r10,sp,-1672
8000962e:	02 9b       	mov	r11,r1
80009630:	08 9c       	mov	r12,r4
80009632:	fe b0 f4 61 	rcall	80007ef4 <__sprint_r>
80009636:	e0 81 03 ec 	brne	80009e0e <_vfprintf_r+0x1efe>
8000963a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000963e:	30 09       	mov	r9,0
80009640:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009644:	f2 08 18 00 	cp.b	r8,r9
80009648:	c1 f0       	breq	80009686 <_vfprintf_r+0x1776>
8000964a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000964e:	fa c9 f9 45 	sub	r9,sp,-1723
80009652:	2f f8       	sub	r8,-1
80009654:	87 09       	st.w	r3[0x0],r9
80009656:	fb 48 06 90 	st.w	sp[1680],r8
8000965a:	30 19       	mov	r9,1
8000965c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009660:	87 19       	st.w	r3[0x4],r9
80009662:	2f f8       	sub	r8,-1
80009664:	fb 48 06 8c 	st.w	sp[1676],r8
80009668:	58 78       	cp.w	r8,7
8000966a:	e0 89 00 04 	brgt	80009672 <_vfprintf_r+0x1762>
8000966e:	2f 83       	sub	r3,-8
80009670:	c0 b8       	rjmp	80009686 <_vfprintf_r+0x1776>
80009672:	fa ca f9 78 	sub	r10,sp,-1672
80009676:	02 9b       	mov	r11,r1
80009678:	08 9c       	mov	r12,r4
8000967a:	fe b0 f4 3d 	rcall	80007ef4 <__sprint_r>
8000967e:	e0 81 03 c8 	brne	80009e0e <_vfprintf_r+0x1efe>
80009682:	fa c3 f9 e0 	sub	r3,sp,-1568
80009686:	40 fc       	lddsp	r12,sp[0x3c]
80009688:	58 0c       	cp.w	r12,0
8000968a:	c1 f0       	breq	800096c8 <_vfprintf_r+0x17b8>
8000968c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009690:	fa c9 f9 48 	sub	r9,sp,-1720
80009694:	2f e8       	sub	r8,-2
80009696:	87 09       	st.w	r3[0x0],r9
80009698:	fb 48 06 90 	st.w	sp[1680],r8
8000969c:	30 29       	mov	r9,2
8000969e:	fa f8 06 8c 	ld.w	r8,sp[1676]
800096a2:	87 19       	st.w	r3[0x4],r9
800096a4:	2f f8       	sub	r8,-1
800096a6:	fb 48 06 8c 	st.w	sp[1676],r8
800096aa:	58 78       	cp.w	r8,7
800096ac:	e0 89 00 04 	brgt	800096b4 <_vfprintf_r+0x17a4>
800096b0:	2f 83       	sub	r3,-8
800096b2:	c0 b8       	rjmp	800096c8 <_vfprintf_r+0x17b8>
800096b4:	fa ca f9 78 	sub	r10,sp,-1672
800096b8:	02 9b       	mov	r11,r1
800096ba:	08 9c       	mov	r12,r4
800096bc:	fe b0 f4 1c 	rcall	80007ef4 <__sprint_r>
800096c0:	e0 81 03 a7 	brne	80009e0e <_vfprintf_r+0x1efe>
800096c4:	fa c3 f9 e0 	sub	r3,sp,-1568
800096c8:	40 9b       	lddsp	r11,sp[0x24]
800096ca:	e0 4b 00 80 	cp.w	r11,128
800096ce:	c4 71       	brne	8000975c <_vfprintf_r+0x184c>
800096d0:	40 8a       	lddsp	r10,sp[0x20]
800096d2:	40 39       	lddsp	r9,sp[0xc]
800096d4:	12 1a       	sub	r10,r9
800096d6:	50 4a       	stdsp	sp[0x10],r10
800096d8:	58 0a       	cp.w	r10,0
800096da:	e0 89 00 20 	brgt	8000971a <_vfprintf_r+0x180a>
800096de:	c3 f8       	rjmp	8000975c <_vfprintf_r+0x184c>
800096e0:	2f 09       	sub	r9,-16
800096e2:	2f f8       	sub	r8,-1
800096e4:	fe ce b9 2c 	sub	lr,pc,-18132
800096e8:	31 0c       	mov	r12,16
800096ea:	fb 49 06 90 	st.w	sp[1680],r9
800096ee:	87 0e       	st.w	r3[0x0],lr
800096f0:	87 1c       	st.w	r3[0x4],r12
800096f2:	fb 48 06 8c 	st.w	sp[1676],r8
800096f6:	58 78       	cp.w	r8,7
800096f8:	e0 89 00 04 	brgt	80009700 <_vfprintf_r+0x17f0>
800096fc:	2f 83       	sub	r3,-8
800096fe:	c0 b8       	rjmp	80009714 <_vfprintf_r+0x1804>
80009700:	fa ca f9 78 	sub	r10,sp,-1672
80009704:	02 9b       	mov	r11,r1
80009706:	08 9c       	mov	r12,r4
80009708:	fe b0 f3 f6 	rcall	80007ef4 <__sprint_r>
8000970c:	e0 81 03 81 	brne	80009e0e <_vfprintf_r+0x1efe>
80009710:	fa c3 f9 e0 	sub	r3,sp,-1568
80009714:	40 4b       	lddsp	r11,sp[0x10]
80009716:	21 0b       	sub	r11,16
80009718:	50 4b       	stdsp	sp[0x10],r11
8000971a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000971e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009722:	fe ca b9 6a 	sub	r10,pc,-18070
80009726:	40 4e       	lddsp	lr,sp[0x10]
80009728:	59 0e       	cp.w	lr,16
8000972a:	fe 99 ff db 	brgt	800096e0 <_vfprintf_r+0x17d0>
8000972e:	1c 09       	add	r9,lr
80009730:	2f f8       	sub	r8,-1
80009732:	87 0a       	st.w	r3[0x0],r10
80009734:	fb 49 06 90 	st.w	sp[1680],r9
80009738:	87 1e       	st.w	r3[0x4],lr
8000973a:	fb 48 06 8c 	st.w	sp[1676],r8
8000973e:	58 78       	cp.w	r8,7
80009740:	e0 89 00 04 	brgt	80009748 <_vfprintf_r+0x1838>
80009744:	2f 83       	sub	r3,-8
80009746:	c0 b8       	rjmp	8000975c <_vfprintf_r+0x184c>
80009748:	fa ca f9 78 	sub	r10,sp,-1672
8000974c:	02 9b       	mov	r11,r1
8000974e:	08 9c       	mov	r12,r4
80009750:	fe b0 f3 d2 	rcall	80007ef4 <__sprint_r>
80009754:	e0 81 03 5d 	brne	80009e0e <_vfprintf_r+0x1efe>
80009758:	fa c3 f9 e0 	sub	r3,sp,-1568
8000975c:	40 2c       	lddsp	r12,sp[0x8]
8000975e:	04 1c       	sub	r12,r2
80009760:	50 2c       	stdsp	sp[0x8],r12
80009762:	58 0c       	cp.w	r12,0
80009764:	e0 89 00 20 	brgt	800097a4 <_vfprintf_r+0x1894>
80009768:	c3 f8       	rjmp	800097e6 <_vfprintf_r+0x18d6>
8000976a:	2f 09       	sub	r9,-16
8000976c:	2f f8       	sub	r8,-1
8000976e:	fe cb b9 b6 	sub	r11,pc,-17994
80009772:	31 0a       	mov	r10,16
80009774:	fb 49 06 90 	st.w	sp[1680],r9
80009778:	87 0b       	st.w	r3[0x0],r11
8000977a:	87 1a       	st.w	r3[0x4],r10
8000977c:	fb 48 06 8c 	st.w	sp[1676],r8
80009780:	58 78       	cp.w	r8,7
80009782:	e0 89 00 04 	brgt	8000978a <_vfprintf_r+0x187a>
80009786:	2f 83       	sub	r3,-8
80009788:	c0 b8       	rjmp	8000979e <_vfprintf_r+0x188e>
8000978a:	fa ca f9 78 	sub	r10,sp,-1672
8000978e:	02 9b       	mov	r11,r1
80009790:	08 9c       	mov	r12,r4
80009792:	fe b0 f3 b1 	rcall	80007ef4 <__sprint_r>
80009796:	e0 81 03 3c 	brne	80009e0e <_vfprintf_r+0x1efe>
8000979a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000979e:	40 29       	lddsp	r9,sp[0x8]
800097a0:	21 09       	sub	r9,16
800097a2:	50 29       	stdsp	sp[0x8],r9
800097a4:	fa f9 06 90 	ld.w	r9,sp[1680]
800097a8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800097ac:	fe ca b9 f4 	sub	r10,pc,-17932
800097b0:	40 2e       	lddsp	lr,sp[0x8]
800097b2:	59 0e       	cp.w	lr,16
800097b4:	fe 99 ff db 	brgt	8000976a <_vfprintf_r+0x185a>
800097b8:	1c 09       	add	r9,lr
800097ba:	2f f8       	sub	r8,-1
800097bc:	87 0a       	st.w	r3[0x0],r10
800097be:	fb 49 06 90 	st.w	sp[1680],r9
800097c2:	87 1e       	st.w	r3[0x4],lr
800097c4:	fb 48 06 8c 	st.w	sp[1676],r8
800097c8:	58 78       	cp.w	r8,7
800097ca:	e0 89 00 04 	brgt	800097d2 <_vfprintf_r+0x18c2>
800097ce:	2f 83       	sub	r3,-8
800097d0:	c0 b8       	rjmp	800097e6 <_vfprintf_r+0x18d6>
800097d2:	fa ca f9 78 	sub	r10,sp,-1672
800097d6:	02 9b       	mov	r11,r1
800097d8:	08 9c       	mov	r12,r4
800097da:	fe b0 f3 8d 	rcall	80007ef4 <__sprint_r>
800097de:	e0 81 03 18 	brne	80009e0e <_vfprintf_r+0x1efe>
800097e2:	fa c3 f9 e0 	sub	r3,sp,-1568
800097e6:	ed b5 00 08 	bld	r5,0x8
800097ea:	c0 b0       	breq	80009800 <_vfprintf_r+0x18f0>
800097ec:	fa f8 06 90 	ld.w	r8,sp[1680]
800097f0:	87 12       	st.w	r3[0x4],r2
800097f2:	87 06       	st.w	r3[0x0],r6
800097f4:	f0 02 00 02 	add	r2,r8,r2
800097f8:	fb 42 06 90 	st.w	sp[1680],r2
800097fc:	e0 8f 01 d4 	bral	80009ba4 <_vfprintf_r+0x1c94>
80009800:	e0 40 00 65 	cp.w	r0,101
80009804:	e0 8a 01 d6 	brle	80009bb0 <_vfprintf_r+0x1ca0>
80009808:	30 08       	mov	r8,0
8000980a:	30 09       	mov	r9,0
8000980c:	40 5b       	lddsp	r11,sp[0x14]
8000980e:	40 7a       	lddsp	r10,sp[0x1c]
80009810:	e0 a0 15 3b 	rcall	8000c286 <__avr32_f64_cmp_eq>
80009814:	c7 90       	breq	80009906 <_vfprintf_r+0x19f6>
80009816:	fa f8 06 90 	ld.w	r8,sp[1680]
8000981a:	fe c9 ba 76 	sub	r9,pc,-17802
8000981e:	2f f8       	sub	r8,-1
80009820:	87 09       	st.w	r3[0x0],r9
80009822:	fb 48 06 90 	st.w	sp[1680],r8
80009826:	30 19       	mov	r9,1
80009828:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000982c:	87 19       	st.w	r3[0x4],r9
8000982e:	2f f8       	sub	r8,-1
80009830:	fb 48 06 8c 	st.w	sp[1676],r8
80009834:	58 78       	cp.w	r8,7
80009836:	e0 89 00 05 	brgt	80009840 <_vfprintf_r+0x1930>
8000983a:	2f 83       	sub	r3,-8
8000983c:	c0 c8       	rjmp	80009854 <_vfprintf_r+0x1944>
8000983e:	d7 03       	nop
80009840:	fa ca f9 78 	sub	r10,sp,-1672
80009844:	02 9b       	mov	r11,r1
80009846:	08 9c       	mov	r12,r4
80009848:	fe b0 f3 56 	rcall	80007ef4 <__sprint_r>
8000984c:	e0 81 02 e1 	brne	80009e0e <_vfprintf_r+0x1efe>
80009850:	fa c3 f9 e0 	sub	r3,sp,-1568
80009854:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009858:	40 6c       	lddsp	r12,sp[0x18]
8000985a:	18 38       	cp.w	r8,r12
8000985c:	c0 55       	brlt	80009866 <_vfprintf_r+0x1956>
8000985e:	ed b5 00 00 	bld	r5,0x0
80009862:	e0 81 02 6b 	brne	80009d38 <_vfprintf_r+0x1e28>
80009866:	fa f8 06 90 	ld.w	r8,sp[1680]
8000986a:	2f f8       	sub	r8,-1
8000986c:	40 cb       	lddsp	r11,sp[0x30]
8000986e:	fb 48 06 90 	st.w	sp[1680],r8
80009872:	30 19       	mov	r9,1
80009874:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009878:	87 0b       	st.w	r3[0x0],r11
8000987a:	2f f8       	sub	r8,-1
8000987c:	87 19       	st.w	r3[0x4],r9
8000987e:	fb 48 06 8c 	st.w	sp[1676],r8
80009882:	58 78       	cp.w	r8,7
80009884:	e0 89 00 04 	brgt	8000988c <_vfprintf_r+0x197c>
80009888:	2f 83       	sub	r3,-8
8000988a:	c0 b8       	rjmp	800098a0 <_vfprintf_r+0x1990>
8000988c:	fa ca f9 78 	sub	r10,sp,-1672
80009890:	02 9b       	mov	r11,r1
80009892:	08 9c       	mov	r12,r4
80009894:	fe b0 f3 30 	rcall	80007ef4 <__sprint_r>
80009898:	e0 81 02 bb 	brne	80009e0e <_vfprintf_r+0x1efe>
8000989c:	fa c3 f9 e0 	sub	r3,sp,-1568
800098a0:	40 66       	lddsp	r6,sp[0x18]
800098a2:	20 16       	sub	r6,1
800098a4:	58 06       	cp.w	r6,0
800098a6:	e0 89 00 1d 	brgt	800098e0 <_vfprintf_r+0x19d0>
800098aa:	e0 8f 02 47 	bral	80009d38 <_vfprintf_r+0x1e28>
800098ae:	2f 09       	sub	r9,-16
800098b0:	2f f8       	sub	r8,-1
800098b2:	fb 49 06 90 	st.w	sp[1680],r9
800098b6:	87 02       	st.w	r3[0x0],r2
800098b8:	87 10       	st.w	r3[0x4],r0
800098ba:	fb 48 06 8c 	st.w	sp[1676],r8
800098be:	58 78       	cp.w	r8,7
800098c0:	e0 89 00 04 	brgt	800098c8 <_vfprintf_r+0x19b8>
800098c4:	2f 83       	sub	r3,-8
800098c6:	c0 b8       	rjmp	800098dc <_vfprintf_r+0x19cc>
800098c8:	fa ca f9 78 	sub	r10,sp,-1672
800098cc:	02 9b       	mov	r11,r1
800098ce:	08 9c       	mov	r12,r4
800098d0:	fe b0 f3 12 	rcall	80007ef4 <__sprint_r>
800098d4:	e0 81 02 9d 	brne	80009e0e <_vfprintf_r+0x1efe>
800098d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800098dc:	21 06       	sub	r6,16
800098de:	c0 48       	rjmp	800098e6 <_vfprintf_r+0x19d6>
800098e0:	fe c2 bb 28 	sub	r2,pc,-17624
800098e4:	31 00       	mov	r0,16
800098e6:	fa f9 06 90 	ld.w	r9,sp[1680]
800098ea:	fa f8 06 8c 	ld.w	r8,sp[1676]
800098ee:	fe ca bb 36 	sub	r10,pc,-17610
800098f2:	59 06       	cp.w	r6,16
800098f4:	fe 99 ff dd 	brgt	800098ae <_vfprintf_r+0x199e>
800098f8:	0c 09       	add	r9,r6
800098fa:	87 0a       	st.w	r3[0x0],r10
800098fc:	fb 49 06 90 	st.w	sp[1680],r9
80009900:	2f f8       	sub	r8,-1
80009902:	87 16       	st.w	r3[0x4],r6
80009904:	c5 39       	rjmp	80009baa <_vfprintf_r+0x1c9a>
80009906:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000990a:	58 0a       	cp.w	r10,0
8000990c:	e0 89 00 92 	brgt	80009a30 <_vfprintf_r+0x1b20>
80009910:	fa f8 06 90 	ld.w	r8,sp[1680]
80009914:	fe c9 bb 70 	sub	r9,pc,-17552
80009918:	2f f8       	sub	r8,-1
8000991a:	87 09       	st.w	r3[0x0],r9
8000991c:	fb 48 06 90 	st.w	sp[1680],r8
80009920:	30 19       	mov	r9,1
80009922:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009926:	87 19       	st.w	r3[0x4],r9
80009928:	2f f8       	sub	r8,-1
8000992a:	fb 48 06 8c 	st.w	sp[1676],r8
8000992e:	58 78       	cp.w	r8,7
80009930:	e0 89 00 04 	brgt	80009938 <_vfprintf_r+0x1a28>
80009934:	2f 83       	sub	r3,-8
80009936:	c0 b8       	rjmp	8000994c <_vfprintf_r+0x1a3c>
80009938:	fa ca f9 78 	sub	r10,sp,-1672
8000993c:	02 9b       	mov	r11,r1
8000993e:	08 9c       	mov	r12,r4
80009940:	fe b0 f2 da 	rcall	80007ef4 <__sprint_r>
80009944:	e0 81 02 65 	brne	80009e0e <_vfprintf_r+0x1efe>
80009948:	fa c3 f9 e0 	sub	r3,sp,-1568
8000994c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009950:	58 08       	cp.w	r8,0
80009952:	c0 81       	brne	80009962 <_vfprintf_r+0x1a52>
80009954:	40 6a       	lddsp	r10,sp[0x18]
80009956:	58 0a       	cp.w	r10,0
80009958:	c0 51       	brne	80009962 <_vfprintf_r+0x1a52>
8000995a:	ed b5 00 00 	bld	r5,0x0
8000995e:	e0 81 01 ed 	brne	80009d38 <_vfprintf_r+0x1e28>
80009962:	40 c9       	lddsp	r9,sp[0x30]
80009964:	fa f8 06 90 	ld.w	r8,sp[1680]
80009968:	2f f8       	sub	r8,-1
8000996a:	87 09       	st.w	r3[0x0],r9
8000996c:	fb 48 06 90 	st.w	sp[1680],r8
80009970:	30 19       	mov	r9,1
80009972:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009976:	87 19       	st.w	r3[0x4],r9
80009978:	2f f8       	sub	r8,-1
8000997a:	fb 48 06 8c 	st.w	sp[1676],r8
8000997e:	58 78       	cp.w	r8,7
80009980:	e0 89 00 04 	brgt	80009988 <_vfprintf_r+0x1a78>
80009984:	2f 83       	sub	r3,-8
80009986:	c0 b8       	rjmp	8000999c <_vfprintf_r+0x1a8c>
80009988:	fa ca f9 78 	sub	r10,sp,-1672
8000998c:	02 9b       	mov	r11,r1
8000998e:	08 9c       	mov	r12,r4
80009990:	fe b0 f2 b2 	rcall	80007ef4 <__sprint_r>
80009994:	e0 81 02 3d 	brne	80009e0e <_vfprintf_r+0x1efe>
80009998:	fa c3 f9 e0 	sub	r3,sp,-1568
8000999c:	fa f2 06 ac 	ld.w	r2,sp[1708]
800099a0:	5c 32       	neg	r2
800099a2:	58 02       	cp.w	r2,0
800099a4:	e0 89 00 1d 	brgt	800099de <_vfprintf_r+0x1ace>
800099a8:	c3 d8       	rjmp	80009a22 <_vfprintf_r+0x1b12>
800099aa:	2f 09       	sub	r9,-16
800099ac:	2f f8       	sub	r8,-1
800099ae:	31 0e       	mov	lr,16
800099b0:	fb 49 06 90 	st.w	sp[1680],r9
800099b4:	87 00       	st.w	r3[0x0],r0
800099b6:	87 1e       	st.w	r3[0x4],lr
800099b8:	fb 48 06 8c 	st.w	sp[1676],r8
800099bc:	58 78       	cp.w	r8,7
800099be:	e0 89 00 04 	brgt	800099c6 <_vfprintf_r+0x1ab6>
800099c2:	2f 83       	sub	r3,-8
800099c4:	c0 b8       	rjmp	800099da <_vfprintf_r+0x1aca>
800099c6:	fa ca f9 78 	sub	r10,sp,-1672
800099ca:	02 9b       	mov	r11,r1
800099cc:	08 9c       	mov	r12,r4
800099ce:	fe b0 f2 93 	rcall	80007ef4 <__sprint_r>
800099d2:	e0 81 02 1e 	brne	80009e0e <_vfprintf_r+0x1efe>
800099d6:	fa c3 f9 e0 	sub	r3,sp,-1568
800099da:	21 02       	sub	r2,16
800099dc:	c0 38       	rjmp	800099e2 <_vfprintf_r+0x1ad2>
800099de:	fe c0 bc 26 	sub	r0,pc,-17370
800099e2:	fa f9 06 90 	ld.w	r9,sp[1680]
800099e6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099ea:	fe ca bc 32 	sub	r10,pc,-17358
800099ee:	59 02       	cp.w	r2,16
800099f0:	fe 99 ff dd 	brgt	800099aa <_vfprintf_r+0x1a9a>
800099f4:	04 09       	add	r9,r2
800099f6:	2f f8       	sub	r8,-1
800099f8:	87 0a       	st.w	r3[0x0],r10
800099fa:	fb 49 06 90 	st.w	sp[1680],r9
800099fe:	87 12       	st.w	r3[0x4],r2
80009a00:	fb 48 06 8c 	st.w	sp[1676],r8
80009a04:	58 78       	cp.w	r8,7
80009a06:	e0 89 00 04 	brgt	80009a0e <_vfprintf_r+0x1afe>
80009a0a:	2f 83       	sub	r3,-8
80009a0c:	c0 b8       	rjmp	80009a22 <_vfprintf_r+0x1b12>
80009a0e:	fa ca f9 78 	sub	r10,sp,-1672
80009a12:	02 9b       	mov	r11,r1
80009a14:	08 9c       	mov	r12,r4
80009a16:	fe b0 f2 6f 	rcall	80007ef4 <__sprint_r>
80009a1a:	e0 81 01 fa 	brne	80009e0e <_vfprintf_r+0x1efe>
80009a1e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a22:	40 6c       	lddsp	r12,sp[0x18]
80009a24:	fa f8 06 90 	ld.w	r8,sp[1680]
80009a28:	87 06       	st.w	r3[0x0],r6
80009a2a:	87 1c       	st.w	r3[0x4],r12
80009a2c:	18 08       	add	r8,r12
80009a2e:	cb 98       	rjmp	80009ba0 <_vfprintf_r+0x1c90>
80009a30:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a34:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a38:	40 6b       	lddsp	r11,sp[0x18]
80009a3a:	16 3a       	cp.w	r10,r11
80009a3c:	c6 f5       	brlt	80009b1a <_vfprintf_r+0x1c0a>
80009a3e:	16 09       	add	r9,r11
80009a40:	2f f8       	sub	r8,-1
80009a42:	87 06       	st.w	r3[0x0],r6
80009a44:	fb 49 06 90 	st.w	sp[1680],r9
80009a48:	87 1b       	st.w	r3[0x4],r11
80009a4a:	fb 48 06 8c 	st.w	sp[1676],r8
80009a4e:	58 78       	cp.w	r8,7
80009a50:	e0 89 00 04 	brgt	80009a58 <_vfprintf_r+0x1b48>
80009a54:	2f 83       	sub	r3,-8
80009a56:	c0 b8       	rjmp	80009a6c <_vfprintf_r+0x1b5c>
80009a58:	fa ca f9 78 	sub	r10,sp,-1672
80009a5c:	02 9b       	mov	r11,r1
80009a5e:	08 9c       	mov	r12,r4
80009a60:	fe b0 f2 4a 	rcall	80007ef4 <__sprint_r>
80009a64:	e0 81 01 d5 	brne	80009e0e <_vfprintf_r+0x1efe>
80009a68:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a6c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009a70:	40 6a       	lddsp	r10,sp[0x18]
80009a72:	14 16       	sub	r6,r10
80009a74:	58 06       	cp.w	r6,0
80009a76:	e0 89 00 1c 	brgt	80009aae <_vfprintf_r+0x1b9e>
80009a7a:	c3 d8       	rjmp	80009af4 <_vfprintf_r+0x1be4>
80009a7c:	2f 09       	sub	r9,-16
80009a7e:	2f f8       	sub	r8,-1
80009a80:	fb 49 06 90 	st.w	sp[1680],r9
80009a84:	87 02       	st.w	r3[0x0],r2
80009a86:	87 10       	st.w	r3[0x4],r0
80009a88:	fb 48 06 8c 	st.w	sp[1676],r8
80009a8c:	58 78       	cp.w	r8,7
80009a8e:	e0 89 00 04 	brgt	80009a96 <_vfprintf_r+0x1b86>
80009a92:	2f 83       	sub	r3,-8
80009a94:	c0 b8       	rjmp	80009aaa <_vfprintf_r+0x1b9a>
80009a96:	fa ca f9 78 	sub	r10,sp,-1672
80009a9a:	02 9b       	mov	r11,r1
80009a9c:	08 9c       	mov	r12,r4
80009a9e:	fe b0 f2 2b 	rcall	80007ef4 <__sprint_r>
80009aa2:	e0 81 01 b6 	brne	80009e0e <_vfprintf_r+0x1efe>
80009aa6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009aaa:	21 06       	sub	r6,16
80009aac:	c0 48       	rjmp	80009ab4 <_vfprintf_r+0x1ba4>
80009aae:	fe c2 bc f6 	sub	r2,pc,-17162
80009ab2:	31 00       	mov	r0,16
80009ab4:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ab8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009abc:	fe ca bd 04 	sub	r10,pc,-17148
80009ac0:	59 06       	cp.w	r6,16
80009ac2:	fe 99 ff dd 	brgt	80009a7c <_vfprintf_r+0x1b6c>
80009ac6:	0c 09       	add	r9,r6
80009ac8:	2f f8       	sub	r8,-1
80009aca:	87 0a       	st.w	r3[0x0],r10
80009acc:	fb 49 06 90 	st.w	sp[1680],r9
80009ad0:	87 16       	st.w	r3[0x4],r6
80009ad2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ad6:	58 78       	cp.w	r8,7
80009ad8:	e0 89 00 04 	brgt	80009ae0 <_vfprintf_r+0x1bd0>
80009adc:	2f 83       	sub	r3,-8
80009ade:	c0 b8       	rjmp	80009af4 <_vfprintf_r+0x1be4>
80009ae0:	fa ca f9 78 	sub	r10,sp,-1672
80009ae4:	02 9b       	mov	r11,r1
80009ae6:	08 9c       	mov	r12,r4
80009ae8:	fe b0 f2 06 	rcall	80007ef4 <__sprint_r>
80009aec:	e0 81 01 91 	brne	80009e0e <_vfprintf_r+0x1efe>
80009af0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009af4:	ed b5 00 00 	bld	r5,0x0
80009af8:	e0 81 01 20 	brne	80009d38 <_vfprintf_r+0x1e28>
80009afc:	40 c9       	lddsp	r9,sp[0x30]
80009afe:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b02:	2f f8       	sub	r8,-1
80009b04:	87 09       	st.w	r3[0x0],r9
80009b06:	fb 48 06 90 	st.w	sp[1680],r8
80009b0a:	30 19       	mov	r9,1
80009b0c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b10:	87 19       	st.w	r3[0x4],r9
80009b12:	2f f8       	sub	r8,-1
80009b14:	fb 48 06 8c 	st.w	sp[1676],r8
80009b18:	c0 29       	rjmp	80009d1c <_vfprintf_r+0x1e0c>
80009b1a:	14 09       	add	r9,r10
80009b1c:	2f f8       	sub	r8,-1
80009b1e:	fb 49 06 90 	st.w	sp[1680],r9
80009b22:	87 06       	st.w	r3[0x0],r6
80009b24:	87 1a       	st.w	r3[0x4],r10
80009b26:	fb 48 06 8c 	st.w	sp[1676],r8
80009b2a:	58 78       	cp.w	r8,7
80009b2c:	e0 89 00 04 	brgt	80009b34 <_vfprintf_r+0x1c24>
80009b30:	2f 83       	sub	r3,-8
80009b32:	c0 b8       	rjmp	80009b48 <_vfprintf_r+0x1c38>
80009b34:	fa ca f9 78 	sub	r10,sp,-1672
80009b38:	02 9b       	mov	r11,r1
80009b3a:	08 9c       	mov	r12,r4
80009b3c:	fe b0 f1 dc 	rcall	80007ef4 <__sprint_r>
80009b40:	e0 81 01 67 	brne	80009e0e <_vfprintf_r+0x1efe>
80009b44:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b48:	40 c8       	lddsp	r8,sp[0x30]
80009b4a:	87 08       	st.w	r3[0x0],r8
80009b4c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b50:	2f f8       	sub	r8,-1
80009b52:	30 19       	mov	r9,1
80009b54:	fb 48 06 90 	st.w	sp[1680],r8
80009b58:	87 19       	st.w	r3[0x4],r9
80009b5a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b5e:	2f f8       	sub	r8,-1
80009b60:	fb 48 06 8c 	st.w	sp[1676],r8
80009b64:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009b68:	58 78       	cp.w	r8,7
80009b6a:	e0 89 00 04 	brgt	80009b72 <_vfprintf_r+0x1c62>
80009b6e:	2f 83       	sub	r3,-8
80009b70:	c0 b8       	rjmp	80009b86 <_vfprintf_r+0x1c76>
80009b72:	fa ca f9 78 	sub	r10,sp,-1672
80009b76:	02 9b       	mov	r11,r1
80009b78:	08 9c       	mov	r12,r4
80009b7a:	fe b0 f1 bd 	rcall	80007ef4 <__sprint_r>
80009b7e:	e0 81 01 48 	brne	80009e0e <_vfprintf_r+0x1efe>
80009b82:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b86:	04 06       	add	r6,r2
80009b88:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b8c:	87 06       	st.w	r3[0x0],r6
80009b8e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009b92:	40 66       	lddsp	r6,sp[0x18]
80009b94:	40 6e       	lddsp	lr,sp[0x18]
80009b96:	10 16       	sub	r6,r8
80009b98:	f2 08 01 08 	sub	r8,r9,r8
80009b9c:	87 16       	st.w	r3[0x4],r6
80009b9e:	1c 08       	add	r8,lr
80009ba0:	fb 48 06 90 	st.w	sp[1680],r8
80009ba4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ba8:	2f f8       	sub	r8,-1
80009baa:	fb 48 06 8c 	st.w	sp[1676],r8
80009bae:	cb 78       	rjmp	80009d1c <_vfprintf_r+0x1e0c>
80009bb0:	40 6c       	lddsp	r12,sp[0x18]
80009bb2:	58 1c       	cp.w	r12,1
80009bb4:	e0 89 00 06 	brgt	80009bc0 <_vfprintf_r+0x1cb0>
80009bb8:	ed b5 00 00 	bld	r5,0x0
80009bbc:	e0 81 00 85 	brne	80009cc6 <_vfprintf_r+0x1db6>
80009bc0:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bc4:	2f f8       	sub	r8,-1
80009bc6:	30 19       	mov	r9,1
80009bc8:	fb 48 06 90 	st.w	sp[1680],r8
80009bcc:	87 06       	st.w	r3[0x0],r6
80009bce:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bd2:	87 19       	st.w	r3[0x4],r9
80009bd4:	2f f8       	sub	r8,-1
80009bd6:	fb 48 06 8c 	st.w	sp[1676],r8
80009bda:	58 78       	cp.w	r8,7
80009bdc:	e0 89 00 04 	brgt	80009be4 <_vfprintf_r+0x1cd4>
80009be0:	2f 83       	sub	r3,-8
80009be2:	c0 b8       	rjmp	80009bf8 <_vfprintf_r+0x1ce8>
80009be4:	fa ca f9 78 	sub	r10,sp,-1672
80009be8:	02 9b       	mov	r11,r1
80009bea:	08 9c       	mov	r12,r4
80009bec:	fe b0 f1 84 	rcall	80007ef4 <__sprint_r>
80009bf0:	e0 81 01 0f 	brne	80009e0e <_vfprintf_r+0x1efe>
80009bf4:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bf8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009bfc:	2f f8       	sub	r8,-1
80009bfe:	40 cb       	lddsp	r11,sp[0x30]
80009c00:	fb 48 06 90 	st.w	sp[1680],r8
80009c04:	30 19       	mov	r9,1
80009c06:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c0a:	87 0b       	st.w	r3[0x0],r11
80009c0c:	2f f8       	sub	r8,-1
80009c0e:	87 19       	st.w	r3[0x4],r9
80009c10:	fb 48 06 8c 	st.w	sp[1676],r8
80009c14:	58 78       	cp.w	r8,7
80009c16:	e0 89 00 05 	brgt	80009c20 <_vfprintf_r+0x1d10>
80009c1a:	2f 83       	sub	r3,-8
80009c1c:	c0 c8       	rjmp	80009c34 <_vfprintf_r+0x1d24>
80009c1e:	d7 03       	nop
80009c20:	fa ca f9 78 	sub	r10,sp,-1672
80009c24:	02 9b       	mov	r11,r1
80009c26:	08 9c       	mov	r12,r4
80009c28:	fe b0 f1 66 	rcall	80007ef4 <__sprint_r>
80009c2c:	e0 81 00 f1 	brne	80009e0e <_vfprintf_r+0x1efe>
80009c30:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c34:	30 08       	mov	r8,0
80009c36:	30 09       	mov	r9,0
80009c38:	40 5b       	lddsp	r11,sp[0x14]
80009c3a:	40 7a       	lddsp	r10,sp[0x1c]
80009c3c:	e0 a0 13 25 	rcall	8000c286 <__avr32_f64_cmp_eq>
80009c40:	40 68       	lddsp	r8,sp[0x18]
80009c42:	20 18       	sub	r8,1
80009c44:	58 0c       	cp.w	r12,0
80009c46:	c0 d1       	brne	80009c60 <_vfprintf_r+0x1d50>
80009c48:	2f f6       	sub	r6,-1
80009c4a:	87 18       	st.w	r3[0x4],r8
80009c4c:	87 06       	st.w	r3[0x0],r6
80009c4e:	fa f6 06 90 	ld.w	r6,sp[1680]
80009c52:	10 06       	add	r6,r8
80009c54:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c58:	fb 46 06 90 	st.w	sp[1680],r6
80009c5c:	2f f8       	sub	r8,-1
80009c5e:	c3 18       	rjmp	80009cc0 <_vfprintf_r+0x1db0>
80009c60:	10 96       	mov	r6,r8
80009c62:	58 08       	cp.w	r8,0
80009c64:	e0 89 00 1c 	brgt	80009c9c <_vfprintf_r+0x1d8c>
80009c68:	c4 b8       	rjmp	80009cfe <_vfprintf_r+0x1dee>
80009c6a:	2f 09       	sub	r9,-16
80009c6c:	2f f8       	sub	r8,-1
80009c6e:	fb 49 06 90 	st.w	sp[1680],r9
80009c72:	87 02       	st.w	r3[0x0],r2
80009c74:	87 10       	st.w	r3[0x4],r0
80009c76:	fb 48 06 8c 	st.w	sp[1676],r8
80009c7a:	58 78       	cp.w	r8,7
80009c7c:	e0 89 00 04 	brgt	80009c84 <_vfprintf_r+0x1d74>
80009c80:	2f 83       	sub	r3,-8
80009c82:	c0 b8       	rjmp	80009c98 <_vfprintf_r+0x1d88>
80009c84:	fa ca f9 78 	sub	r10,sp,-1672
80009c88:	02 9b       	mov	r11,r1
80009c8a:	08 9c       	mov	r12,r4
80009c8c:	fe b0 f1 34 	rcall	80007ef4 <__sprint_r>
80009c90:	e0 81 00 bf 	brne	80009e0e <_vfprintf_r+0x1efe>
80009c94:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c98:	21 06       	sub	r6,16
80009c9a:	c0 48       	rjmp	80009ca2 <_vfprintf_r+0x1d92>
80009c9c:	fe c2 be e4 	sub	r2,pc,-16668
80009ca0:	31 00       	mov	r0,16
80009ca2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ca6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009caa:	fe ca be f2 	sub	r10,pc,-16654
80009cae:	59 06       	cp.w	r6,16
80009cb0:	fe 99 ff dd 	brgt	80009c6a <_vfprintf_r+0x1d5a>
80009cb4:	0c 09       	add	r9,r6
80009cb6:	87 0a       	st.w	r3[0x0],r10
80009cb8:	fb 49 06 90 	st.w	sp[1680],r9
80009cbc:	2f f8       	sub	r8,-1
80009cbe:	87 16       	st.w	r3[0x4],r6
80009cc0:	fb 48 06 8c 	st.w	sp[1676],r8
80009cc4:	c0 e8       	rjmp	80009ce0 <_vfprintf_r+0x1dd0>
80009cc6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cca:	2f f8       	sub	r8,-1
80009ccc:	30 19       	mov	r9,1
80009cce:	fb 48 06 90 	st.w	sp[1680],r8
80009cd2:	87 06       	st.w	r3[0x0],r6
80009cd4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cd8:	87 19       	st.w	r3[0x4],r9
80009cda:	2f f8       	sub	r8,-1
80009cdc:	fb 48 06 8c 	st.w	sp[1676],r8
80009ce0:	58 78       	cp.w	r8,7
80009ce2:	e0 89 00 04 	brgt	80009cea <_vfprintf_r+0x1dda>
80009ce6:	2f 83       	sub	r3,-8
80009ce8:	c0 b8       	rjmp	80009cfe <_vfprintf_r+0x1dee>
80009cea:	fa ca f9 78 	sub	r10,sp,-1672
80009cee:	02 9b       	mov	r11,r1
80009cf0:	08 9c       	mov	r12,r4
80009cf2:	fe b0 f1 01 	rcall	80007ef4 <__sprint_r>
80009cf6:	e0 81 00 8c 	brne	80009e0e <_vfprintf_r+0x1efe>
80009cfa:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cfe:	40 ea       	lddsp	r10,sp[0x38]
80009d00:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d04:	14 08       	add	r8,r10
80009d06:	fa c9 f9 64 	sub	r9,sp,-1692
80009d0a:	fb 48 06 90 	st.w	sp[1680],r8
80009d0e:	87 1a       	st.w	r3[0x4],r10
80009d10:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d14:	87 09       	st.w	r3[0x0],r9
80009d16:	2f f8       	sub	r8,-1
80009d18:	fb 48 06 8c 	st.w	sp[1676],r8
80009d1c:	58 78       	cp.w	r8,7
80009d1e:	e0 89 00 04 	brgt	80009d26 <_vfprintf_r+0x1e16>
80009d22:	2f 83       	sub	r3,-8
80009d24:	c0 a8       	rjmp	80009d38 <_vfprintf_r+0x1e28>
80009d26:	fa ca f9 78 	sub	r10,sp,-1672
80009d2a:	02 9b       	mov	r11,r1
80009d2c:	08 9c       	mov	r12,r4
80009d2e:	fe b0 f0 e3 	rcall	80007ef4 <__sprint_r>
80009d32:	c6 e1       	brne	80009e0e <_vfprintf_r+0x1efe>
80009d34:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d38:	e2 15 00 04 	andl	r5,0x4,COH
80009d3c:	c3 f0       	breq	80009dba <_vfprintf_r+0x1eaa>
80009d3e:	40 86       	lddsp	r6,sp[0x20]
80009d40:	40 39       	lddsp	r9,sp[0xc]
80009d42:	12 16       	sub	r6,r9
80009d44:	58 06       	cp.w	r6,0
80009d46:	e0 89 00 1a 	brgt	80009d7a <_vfprintf_r+0x1e6a>
80009d4a:	c3 88       	rjmp	80009dba <_vfprintf_r+0x1eaa>
80009d4c:	2f 09       	sub	r9,-16
80009d4e:	2f f8       	sub	r8,-1
80009d50:	fb 49 06 90 	st.w	sp[1680],r9
80009d54:	87 05       	st.w	r3[0x0],r5
80009d56:	87 12       	st.w	r3[0x4],r2
80009d58:	fb 48 06 8c 	st.w	sp[1676],r8
80009d5c:	58 78       	cp.w	r8,7
80009d5e:	e0 89 00 04 	brgt	80009d66 <_vfprintf_r+0x1e56>
80009d62:	2f 83       	sub	r3,-8
80009d64:	c0 98       	rjmp	80009d76 <_vfprintf_r+0x1e66>
80009d66:	00 9a       	mov	r10,r0
80009d68:	02 9b       	mov	r11,r1
80009d6a:	08 9c       	mov	r12,r4
80009d6c:	fe b0 f0 c4 	rcall	80007ef4 <__sprint_r>
80009d70:	c4 f1       	brne	80009e0e <_vfprintf_r+0x1efe>
80009d72:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d76:	21 06       	sub	r6,16
80009d78:	c0 68       	rjmp	80009d84 <_vfprintf_r+0x1e74>
80009d7a:	fe c5 bf d2 	sub	r5,pc,-16430
80009d7e:	31 02       	mov	r2,16
80009d80:	fa c0 f9 78 	sub	r0,sp,-1672
80009d84:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d8c:	fe ca bf e4 	sub	r10,pc,-16412
80009d90:	59 06       	cp.w	r6,16
80009d92:	fe 99 ff dd 	brgt	80009d4c <_vfprintf_r+0x1e3c>
80009d96:	0c 09       	add	r9,r6
80009d98:	2f f8       	sub	r8,-1
80009d9a:	87 0a       	st.w	r3[0x0],r10
80009d9c:	87 16       	st.w	r3[0x4],r6
80009d9e:	fb 49 06 90 	st.w	sp[1680],r9
80009da2:	fb 48 06 8c 	st.w	sp[1676],r8
80009da6:	58 78       	cp.w	r8,7
80009da8:	e0 8a 00 09 	brle	80009dba <_vfprintf_r+0x1eaa>
80009dac:	fa ca f9 78 	sub	r10,sp,-1672
80009db0:	02 9b       	mov	r11,r1
80009db2:	08 9c       	mov	r12,r4
80009db4:	fe b0 f0 a0 	rcall	80007ef4 <__sprint_r>
80009db8:	c2 b1       	brne	80009e0e <_vfprintf_r+0x1efe>
80009dba:	40 bc       	lddsp	r12,sp[0x2c]
80009dbc:	40 36       	lddsp	r6,sp[0xc]
80009dbe:	40 8e       	lddsp	lr,sp[0x20]
80009dc0:	ec 0e 0c 48 	max	r8,r6,lr
80009dc4:	10 0c       	add	r12,r8
80009dc6:	50 bc       	stdsp	sp[0x2c],r12
80009dc8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009dcc:	58 08       	cp.w	r8,0
80009dce:	c0 80       	breq	80009dde <_vfprintf_r+0x1ece>
80009dd0:	fa ca f9 78 	sub	r10,sp,-1672
80009dd4:	02 9b       	mov	r11,r1
80009dd6:	08 9c       	mov	r12,r4
80009dd8:	fe b0 f0 8e 	rcall	80007ef4 <__sprint_r>
80009ddc:	c1 91       	brne	80009e0e <_vfprintf_r+0x1efe>
80009dde:	30 0b       	mov	r11,0
80009de0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009de4:	fb 4b 06 8c 	st.w	sp[1676],r11
80009de8:	fe 9f f1 22 	bral	8000802c <_vfprintf_r+0x11c>
80009dec:	08 95       	mov	r5,r4
80009dee:	fa f8 06 90 	ld.w	r8,sp[1680]
80009df2:	58 08       	cp.w	r8,0
80009df4:	c0 80       	breq	80009e04 <_vfprintf_r+0x1ef4>
80009df6:	08 9c       	mov	r12,r4
80009df8:	fa ca f9 78 	sub	r10,sp,-1672
80009dfc:	02 9b       	mov	r11,r1
80009dfe:	fe b0 f0 7b 	rcall	80007ef4 <__sprint_r>
80009e02:	c0 61       	brne	80009e0e <_vfprintf_r+0x1efe>
80009e04:	30 08       	mov	r8,0
80009e06:	fb 48 06 8c 	st.w	sp[1676],r8
80009e0a:	c0 28       	rjmp	80009e0e <_vfprintf_r+0x1efe>
80009e0c:	40 41       	lddsp	r1,sp[0x10]
80009e0e:	82 68       	ld.sh	r8,r1[0xc]
80009e10:	ed b8 00 06 	bld	r8,0x6
80009e14:	c0 31       	brne	80009e1a <_vfprintf_r+0x1f0a>
80009e16:	3f fa       	mov	r10,-1
80009e18:	50 ba       	stdsp	sp[0x2c],r10
80009e1a:	40 bc       	lddsp	r12,sp[0x2c]
80009e1c:	fe 3d f9 44 	sub	sp,-1724
80009e20:	d8 32       	popm	r0-r7,pc
80009e22:	d7 03       	nop

80009e24 <__swsetup_r>:
80009e24:	d4 21       	pushm	r4-r7,lr
80009e26:	e0 68 0a 3c 	mov	r8,2620
80009e2a:	18 96       	mov	r6,r12
80009e2c:	16 97       	mov	r7,r11
80009e2e:	70 0c       	ld.w	r12,r8[0x0]
80009e30:	58 0c       	cp.w	r12,0
80009e32:	c0 60       	breq	80009e3e <__swsetup_r+0x1a>
80009e34:	78 68       	ld.w	r8,r12[0x18]
80009e36:	58 08       	cp.w	r8,0
80009e38:	c0 31       	brne	80009e3e <__swsetup_r+0x1a>
80009e3a:	e0 a0 07 bf 	rcall	8000adb8 <__sinit>
80009e3e:	fe c8 bf 66 	sub	r8,pc,-16538
80009e42:	10 37       	cp.w	r7,r8
80009e44:	c0 61       	brne	80009e50 <__swsetup_r+0x2c>
80009e46:	e0 68 0a 3c 	mov	r8,2620
80009e4a:	70 08       	ld.w	r8,r8[0x0]
80009e4c:	70 07       	ld.w	r7,r8[0x0]
80009e4e:	c1 28       	rjmp	80009e72 <__swsetup_r+0x4e>
80009e50:	fe c8 bf 58 	sub	r8,pc,-16552
80009e54:	10 37       	cp.w	r7,r8
80009e56:	c0 61       	brne	80009e62 <__swsetup_r+0x3e>
80009e58:	e0 68 0a 3c 	mov	r8,2620
80009e5c:	70 08       	ld.w	r8,r8[0x0]
80009e5e:	70 17       	ld.w	r7,r8[0x4]
80009e60:	c0 98       	rjmp	80009e72 <__swsetup_r+0x4e>
80009e62:	fe c8 bf 4a 	sub	r8,pc,-16566
80009e66:	10 37       	cp.w	r7,r8
80009e68:	c0 51       	brne	80009e72 <__swsetup_r+0x4e>
80009e6a:	e0 68 0a 3c 	mov	r8,2620
80009e6e:	70 08       	ld.w	r8,r8[0x0]
80009e70:	70 27       	ld.w	r7,r8[0x8]
80009e72:	8e 68       	ld.sh	r8,r7[0xc]
80009e74:	ed b8 00 03 	bld	r8,0x3
80009e78:	c1 e0       	breq	80009eb4 <__swsetup_r+0x90>
80009e7a:	ed b8 00 04 	bld	r8,0x4
80009e7e:	c3 e1       	brne	80009efa <__swsetup_r+0xd6>
80009e80:	ed b8 00 02 	bld	r8,0x2
80009e84:	c1 51       	brne	80009eae <__swsetup_r+0x8a>
80009e86:	6e db       	ld.w	r11,r7[0x34]
80009e88:	58 0b       	cp.w	r11,0
80009e8a:	c0 a0       	breq	80009e9e <__swsetup_r+0x7a>
80009e8c:	ee c8 ff bc 	sub	r8,r7,-68
80009e90:	10 3b       	cp.w	r11,r8
80009e92:	c0 40       	breq	80009e9a <__swsetup_r+0x76>
80009e94:	0c 9c       	mov	r12,r6
80009e96:	e0 a0 08 2b 	rcall	8000aeec <_free_r>
80009e9a:	30 08       	mov	r8,0
80009e9c:	8f d8       	st.w	r7[0x34],r8
80009e9e:	8e 68       	ld.sh	r8,r7[0xc]
80009ea0:	e0 18 ff db 	andl	r8,0xffdb
80009ea4:	ae 68       	st.h	r7[0xc],r8
80009ea6:	30 08       	mov	r8,0
80009ea8:	8f 18       	st.w	r7[0x4],r8
80009eaa:	6e 48       	ld.w	r8,r7[0x10]
80009eac:	8f 08       	st.w	r7[0x0],r8
80009eae:	8e 68       	ld.sh	r8,r7[0xc]
80009eb0:	a3 b8       	sbr	r8,0x3
80009eb2:	ae 68       	st.h	r7[0xc],r8
80009eb4:	6e 48       	ld.w	r8,r7[0x10]
80009eb6:	58 08       	cp.w	r8,0
80009eb8:	c0 b1       	brne	80009ece <__swsetup_r+0xaa>
80009eba:	8e 68       	ld.sh	r8,r7[0xc]
80009ebc:	e2 18 02 80 	andl	r8,0x280,COH
80009ec0:	e0 48 02 00 	cp.w	r8,512
80009ec4:	c0 50       	breq	80009ece <__swsetup_r+0xaa>
80009ec6:	0c 9c       	mov	r12,r6
80009ec8:	0e 9b       	mov	r11,r7
80009eca:	e0 a0 0a 4b 	rcall	8000b360 <__smakebuf_r>
80009ece:	8e 69       	ld.sh	r9,r7[0xc]
80009ed0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80009ed4:	c0 70       	breq	80009ee2 <__swsetup_r+0xbe>
80009ed6:	30 08       	mov	r8,0
80009ed8:	8f 28       	st.w	r7[0x8],r8
80009eda:	6e 58       	ld.w	r8,r7[0x14]
80009edc:	5c 38       	neg	r8
80009ede:	8f 68       	st.w	r7[0x18],r8
80009ee0:	c0 68       	rjmp	80009eec <__swsetup_r+0xc8>
80009ee2:	ed b9 00 01 	bld	r9,0x1
80009ee6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80009eea:	8f 28       	st.w	r7[0x8],r8
80009eec:	6e 48       	ld.w	r8,r7[0x10]
80009eee:	58 08       	cp.w	r8,0
80009ef0:	c0 61       	brne	80009efc <__swsetup_r+0xd8>
80009ef2:	8e 68       	ld.sh	r8,r7[0xc]
80009ef4:	ed b8 00 07 	bld	r8,0x7
80009ef8:	c0 21       	brne	80009efc <__swsetup_r+0xd8>
80009efa:	dc 2a       	popm	r4-r7,pc,r12=-1
80009efc:	d8 2a       	popm	r4-r7,pc,r12=0
80009efe:	d7 03       	nop

80009f00 <quorem>:
80009f00:	d4 31       	pushm	r0-r7,lr
80009f02:	20 2d       	sub	sp,8
80009f04:	18 97       	mov	r7,r12
80009f06:	78 48       	ld.w	r8,r12[0x10]
80009f08:	76 46       	ld.w	r6,r11[0x10]
80009f0a:	0c 38       	cp.w	r8,r6
80009f0c:	c0 34       	brge	80009f12 <quorem+0x12>
80009f0e:	30 0c       	mov	r12,0
80009f10:	c8 58       	rjmp	8000a01a <quorem+0x11a>
80009f12:	ec c2 ff fc 	sub	r2,r6,-4
80009f16:	f6 c3 ff ec 	sub	r3,r11,-20
80009f1a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80009f1e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80009f22:	2f f9       	sub	r9,-1
80009f24:	20 16       	sub	r6,1
80009f26:	f8 09 0d 08 	divu	r8,r12,r9
80009f2a:	f6 02 00 22 	add	r2,r11,r2<<0x2
80009f2e:	ee c4 ff ec 	sub	r4,r7,-20
80009f32:	10 95       	mov	r5,r8
80009f34:	58 08       	cp.w	r8,0
80009f36:	c4 10       	breq	80009fb8 <quorem+0xb8>
80009f38:	30 09       	mov	r9,0
80009f3a:	06 9a       	mov	r10,r3
80009f3c:	08 98       	mov	r8,r4
80009f3e:	12 91       	mov	r1,r9
80009f40:	50 0b       	stdsp	sp[0x0],r11
80009f42:	70 0e       	ld.w	lr,r8[0x0]
80009f44:	b1 8e       	lsr	lr,0x10
80009f46:	50 1e       	stdsp	sp[0x4],lr
80009f48:	15 0e       	ld.w	lr,r10++
80009f4a:	fc 00 16 10 	lsr	r0,lr,0x10
80009f4e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80009f52:	ea 0e 03 41 	mac	r1,r5,lr
80009f56:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80009f5a:	b1 81       	lsr	r1,0x10
80009f5c:	40 1b       	lddsp	r11,sp[0x4]
80009f5e:	ea 00 02 40 	mul	r0,r5,r0
80009f62:	e2 00 00 00 	add	r0,r1,r0
80009f66:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80009f6a:	02 1b       	sub	r11,r1
80009f6c:	50 1b       	stdsp	sp[0x4],r11
80009f6e:	70 0b       	ld.w	r11,r8[0x0]
80009f70:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80009f74:	02 09       	add	r9,r1
80009f76:	f2 0e 01 0e 	sub	lr,r9,lr
80009f7a:	b0 1e       	st.h	r8[0x2],lr
80009f7c:	fc 09 14 10 	asr	r9,lr,0x10
80009f80:	40 1e       	lddsp	lr,sp[0x4]
80009f82:	fc 09 00 09 	add	r9,lr,r9
80009f86:	b0 09       	st.h	r8[0x0],r9
80009f88:	e0 01 16 10 	lsr	r1,r0,0x10
80009f8c:	2f c8       	sub	r8,-4
80009f8e:	b1 49       	asr	r9,0x10
80009f90:	04 3a       	cp.w	r10,r2
80009f92:	fe 98 ff d8 	brls	80009f42 <quorem+0x42>
80009f96:	40 0b       	lddsp	r11,sp[0x0]
80009f98:	58 0c       	cp.w	r12,0
80009f9a:	c0 f1       	brne	80009fb8 <quorem+0xb8>
80009f9c:	ec c8 ff fb 	sub	r8,r6,-5
80009fa0:	ee 08 00 28 	add	r8,r7,r8<<0x2
80009fa4:	c0 28       	rjmp	80009fa8 <quorem+0xa8>
80009fa6:	20 16       	sub	r6,1
80009fa8:	20 48       	sub	r8,4
80009faa:	08 38       	cp.w	r8,r4
80009fac:	e0 88 00 05 	brls	80009fb6 <quorem+0xb6>
80009fb0:	70 09       	ld.w	r9,r8[0x0]
80009fb2:	58 09       	cp.w	r9,0
80009fb4:	cf 90       	breq	80009fa6 <quorem+0xa6>
80009fb6:	8f 46       	st.w	r7[0x10],r6
80009fb8:	0e 9c       	mov	r12,r7
80009fba:	e0 a0 0a d2 	rcall	8000b55e <__mcmp>
80009fbe:	c2 d5       	brlt	8000a018 <quorem+0x118>
80009fc0:	2f f5       	sub	r5,-1
80009fc2:	08 98       	mov	r8,r4
80009fc4:	30 09       	mov	r9,0
80009fc6:	07 0b       	ld.w	r11,r3++
80009fc8:	f6 0a 16 10 	lsr	r10,r11,0x10
80009fcc:	70 0c       	ld.w	r12,r8[0x0]
80009fce:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80009fd2:	f8 0e 16 10 	lsr	lr,r12,0x10
80009fd6:	14 1e       	sub	lr,r10
80009fd8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80009fdc:	16 1a       	sub	r10,r11
80009fde:	12 0a       	add	r10,r9
80009fe0:	b0 1a       	st.h	r8[0x2],r10
80009fe2:	b1 4a       	asr	r10,0x10
80009fe4:	fc 0a 00 09 	add	r9,lr,r10
80009fe8:	b0 09       	st.h	r8[0x0],r9
80009fea:	2f c8       	sub	r8,-4
80009fec:	b1 49       	asr	r9,0x10
80009fee:	04 33       	cp.w	r3,r2
80009ff0:	fe 98 ff eb 	brls	80009fc6 <quorem+0xc6>
80009ff4:	ec c8 ff fb 	sub	r8,r6,-5
80009ff8:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80009ffc:	58 09       	cp.w	r9,0
80009ffe:	c0 d1       	brne	8000a018 <quorem+0x118>
8000a000:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a004:	c0 28       	rjmp	8000a008 <quorem+0x108>
8000a006:	20 16       	sub	r6,1
8000a008:	20 48       	sub	r8,4
8000a00a:	08 38       	cp.w	r8,r4
8000a00c:	e0 88 00 05 	brls	8000a016 <quorem+0x116>
8000a010:	70 09       	ld.w	r9,r8[0x0]
8000a012:	58 09       	cp.w	r9,0
8000a014:	cf 90       	breq	8000a006 <quorem+0x106>
8000a016:	8f 46       	st.w	r7[0x10],r6
8000a018:	0a 9c       	mov	r12,r5
8000a01a:	2f ed       	sub	sp,-8
8000a01c:	d8 32       	popm	r0-r7,pc
8000a01e:	d7 03       	nop

8000a020 <_dtoa_r>:
8000a020:	d4 31       	pushm	r0-r7,lr
8000a022:	21 ad       	sub	sp,104
8000a024:	fa c4 ff 74 	sub	r4,sp,-140
8000a028:	18 97       	mov	r7,r12
8000a02a:	16 95       	mov	r5,r11
8000a02c:	68 2c       	ld.w	r12,r4[0x8]
8000a02e:	50 c9       	stdsp	sp[0x30],r9
8000a030:	68 16       	ld.w	r6,r4[0x4]
8000a032:	68 09       	ld.w	r9,r4[0x0]
8000a034:	50 e8       	stdsp	sp[0x38],r8
8000a036:	14 94       	mov	r4,r10
8000a038:	51 2c       	stdsp	sp[0x48],r12
8000a03a:	fa e5 00 08 	st.d	sp[8],r4
8000a03e:	51 59       	stdsp	sp[0x54],r9
8000a040:	6e 95       	ld.w	r5,r7[0x24]
8000a042:	58 05       	cp.w	r5,0
8000a044:	c0 91       	brne	8000a056 <_dtoa_r+0x36>
8000a046:	31 0c       	mov	r12,16
8000a048:	fe b0 e8 f4 	rcall	80007230 <malloc>
8000a04c:	99 35       	st.w	r12[0xc],r5
8000a04e:	8f 9c       	st.w	r7[0x24],r12
8000a050:	99 15       	st.w	r12[0x4],r5
8000a052:	99 25       	st.w	r12[0x8],r5
8000a054:	99 05       	st.w	r12[0x0],r5
8000a056:	6e 99       	ld.w	r9,r7[0x24]
8000a058:	72 08       	ld.w	r8,r9[0x0]
8000a05a:	58 08       	cp.w	r8,0
8000a05c:	c0 f0       	breq	8000a07a <_dtoa_r+0x5a>
8000a05e:	72 1a       	ld.w	r10,r9[0x4]
8000a060:	91 1a       	st.w	r8[0x4],r10
8000a062:	30 1a       	mov	r10,1
8000a064:	72 19       	ld.w	r9,r9[0x4]
8000a066:	f4 09 09 49 	lsl	r9,r10,r9
8000a06a:	10 9b       	mov	r11,r8
8000a06c:	91 29       	st.w	r8[0x8],r9
8000a06e:	0e 9c       	mov	r12,r7
8000a070:	e0 a0 0a 90 	rcall	8000b590 <_Bfree>
8000a074:	6e 98       	ld.w	r8,r7[0x24]
8000a076:	30 09       	mov	r9,0
8000a078:	91 09       	st.w	r8[0x0],r9
8000a07a:	40 28       	lddsp	r8,sp[0x8]
8000a07c:	10 94       	mov	r4,r8
8000a07e:	58 08       	cp.w	r8,0
8000a080:	c0 64       	brge	8000a08c <_dtoa_r+0x6c>
8000a082:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a086:	50 28       	stdsp	sp[0x8],r8
8000a088:	30 18       	mov	r8,1
8000a08a:	c0 28       	rjmp	8000a08e <_dtoa_r+0x6e>
8000a08c:	30 08       	mov	r8,0
8000a08e:	8d 08       	st.w	r6[0x0],r8
8000a090:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a094:	40 26       	lddsp	r6,sp[0x8]
8000a096:	0c 98       	mov	r8,r6
8000a098:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a09c:	18 38       	cp.w	r8,r12
8000a09e:	c2 01       	brne	8000a0de <_dtoa_r+0xbe>
8000a0a0:	e0 68 27 0f 	mov	r8,9999
8000a0a4:	41 5b       	lddsp	r11,sp[0x54]
8000a0a6:	97 08       	st.w	r11[0x0],r8
8000a0a8:	40 3a       	lddsp	r10,sp[0xc]
8000a0aa:	58 0a       	cp.w	r10,0
8000a0ac:	c0 71       	brne	8000a0ba <_dtoa_r+0x9a>
8000a0ae:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a0b2:	c0 41       	brne	8000a0ba <_dtoa_r+0x9a>
8000a0b4:	fe cc c1 ec 	sub	r12,pc,-15892
8000a0b8:	c0 38       	rjmp	8000a0be <_dtoa_r+0x9e>
8000a0ba:	fe cc c1 e6 	sub	r12,pc,-15898
8000a0be:	41 29       	lddsp	r9,sp[0x48]
8000a0c0:	58 09       	cp.w	r9,0
8000a0c2:	e0 80 05 9a 	breq	8000abf6 <_dtoa_r+0xbd6>
8000a0c6:	f8 c8 ff fd 	sub	r8,r12,-3
8000a0ca:	f8 c9 ff f8 	sub	r9,r12,-8
8000a0ce:	11 8b       	ld.ub	r11,r8[0x0]
8000a0d0:	30 0a       	mov	r10,0
8000a0d2:	41 25       	lddsp	r5,sp[0x48]
8000a0d4:	f4 0b 18 00 	cp.b	r11,r10
8000a0d8:	f2 08 17 10 	movne	r8,r9
8000a0dc:	c1 68       	rjmp	8000a108 <_dtoa_r+0xe8>
8000a0de:	fa ea 00 08 	ld.d	r10,sp[8]
8000a0e2:	30 08       	mov	r8,0
8000a0e4:	fa eb 00 3c 	st.d	sp[60],r10
8000a0e8:	30 09       	mov	r9,0
8000a0ea:	e0 a0 10 ce 	rcall	8000c286 <__avr32_f64_cmp_eq>
8000a0ee:	c1 00       	breq	8000a10e <_dtoa_r+0xee>
8000a0f0:	30 18       	mov	r8,1
8000a0f2:	41 5a       	lddsp	r10,sp[0x54]
8000a0f4:	95 08       	st.w	r10[0x0],r8
8000a0f6:	fe cc c3 52 	sub	r12,pc,-15534
8000a0fa:	41 29       	lddsp	r9,sp[0x48]
8000a0fc:	f8 08 00 08 	add	r8,r12,r8
8000a100:	58 09       	cp.w	r9,0
8000a102:	e0 80 05 7a 	breq	8000abf6 <_dtoa_r+0xbd6>
8000a106:	12 95       	mov	r5,r9
8000a108:	8b 08       	st.w	r5[0x0],r8
8000a10a:	e0 8f 05 76 	bral	8000abf6 <_dtoa_r+0xbd6>
8000a10e:	fa c8 ff 9c 	sub	r8,sp,-100
8000a112:	fa c9 ff a0 	sub	r9,sp,-96
8000a116:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a11a:	0e 9c       	mov	r12,r7
8000a11c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a120:	e0 a0 0a 8a 	rcall	8000b634 <__d2b>
8000a124:	18 93       	mov	r3,r12
8000a126:	58 05       	cp.w	r5,0
8000a128:	c0 d0       	breq	8000a142 <_dtoa_r+0x122>
8000a12a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a12e:	30 04       	mov	r4,0
8000a130:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a134:	ea c5 03 ff 	sub	r5,r5,1023
8000a138:	10 9b       	mov	r11,r8
8000a13a:	51 74       	stdsp	sp[0x5c],r4
8000a13c:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a140:	c2 58       	rjmp	8000a18a <_dtoa_r+0x16a>
8000a142:	41 88       	lddsp	r8,sp[0x60]
8000a144:	41 9c       	lddsp	r12,sp[0x64]
8000a146:	10 0c       	add	r12,r8
8000a148:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a14c:	e0 45 00 20 	cp.w	r5,32
8000a150:	e0 8a 00 0e 	brle	8000a16c <_dtoa_r+0x14c>
8000a154:	f8 cc fb ee 	sub	r12,r12,-1042
8000a158:	40 3b       	lddsp	r11,sp[0xc]
8000a15a:	ea 08 11 40 	rsub	r8,r5,64
8000a15e:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a162:	ec 08 09 46 	lsl	r6,r6,r8
8000a166:	0c 4c       	or	r12,r6
8000a168:	c0 78       	rjmp	8000a176 <_dtoa_r+0x156>
8000a16a:	d7 03       	nop
8000a16c:	ea 0c 11 20 	rsub	r12,r5,32
8000a170:	40 3a       	lddsp	r10,sp[0xc]
8000a172:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a176:	e0 a0 10 14 	rcall	8000c19e <__avr32_u32_to_f64>
8000a17a:	fc 18 fe 10 	movh	r8,0xfe10
8000a17e:	30 19       	mov	r9,1
8000a180:	ea c5 04 33 	sub	r5,r5,1075
8000a184:	f0 0b 00 0b 	add	r11,r8,r11
8000a188:	51 79       	stdsp	sp[0x5c],r9
8000a18a:	30 08       	mov	r8,0
8000a18c:	fc 19 3f f8 	movh	r9,0x3ff8
8000a190:	e0 a0 0e 9c 	rcall	8000bec8 <__avr32_f64_sub>
8000a194:	e0 68 43 61 	mov	r8,17249
8000a198:	ea 18 63 6f 	orh	r8,0x636f
8000a19c:	e0 69 87 a7 	mov	r9,34727
8000a1a0:	ea 19 3f d2 	orh	r9,0x3fd2
8000a1a4:	e0 a0 0d a6 	rcall	8000bcf0 <__avr32_f64_mul>
8000a1a8:	e0 68 c8 b3 	mov	r8,51379
8000a1ac:	ea 18 8b 60 	orh	r8,0x8b60
8000a1b0:	e0 69 8a 28 	mov	r9,35368
8000a1b4:	ea 19 3f c6 	orh	r9,0x3fc6
8000a1b8:	e0 a0 0f 56 	rcall	8000c064 <__avr32_f64_add>
8000a1bc:	0a 9c       	mov	r12,r5
8000a1be:	14 90       	mov	r0,r10
8000a1c0:	16 91       	mov	r1,r11
8000a1c2:	e0 a0 0f f2 	rcall	8000c1a6 <__avr32_s32_to_f64>
8000a1c6:	e0 68 79 fb 	mov	r8,31227
8000a1ca:	ea 18 50 9f 	orh	r8,0x509f
8000a1ce:	e0 69 44 13 	mov	r9,17427
8000a1d2:	ea 19 3f d3 	orh	r9,0x3fd3
8000a1d6:	e0 a0 0d 8d 	rcall	8000bcf0 <__avr32_f64_mul>
8000a1da:	14 98       	mov	r8,r10
8000a1dc:	16 99       	mov	r9,r11
8000a1de:	00 9a       	mov	r10,r0
8000a1e0:	02 9b       	mov	r11,r1
8000a1e2:	e0 a0 0f 41 	rcall	8000c064 <__avr32_f64_add>
8000a1e6:	14 90       	mov	r0,r10
8000a1e8:	16 91       	mov	r1,r11
8000a1ea:	e0 a0 0f c7 	rcall	8000c178 <__avr32_f64_to_s32>
8000a1ee:	30 08       	mov	r8,0
8000a1f0:	18 96       	mov	r6,r12
8000a1f2:	30 09       	mov	r9,0
8000a1f4:	00 9a       	mov	r10,r0
8000a1f6:	02 9b       	mov	r11,r1
8000a1f8:	e0 a0 10 8e 	rcall	8000c314 <__avr32_f64_cmp_lt>
8000a1fc:	c0 c0       	breq	8000a214 <_dtoa_r+0x1f4>
8000a1fe:	0c 9c       	mov	r12,r6
8000a200:	e0 a0 0f d3 	rcall	8000c1a6 <__avr32_s32_to_f64>
8000a204:	14 98       	mov	r8,r10
8000a206:	16 99       	mov	r9,r11
8000a208:	00 9a       	mov	r10,r0
8000a20a:	02 9b       	mov	r11,r1
8000a20c:	e0 a0 10 3d 	rcall	8000c286 <__avr32_f64_cmp_eq>
8000a210:	f7 b6 00 01 	subeq	r6,1
8000a214:	59 66       	cp.w	r6,22
8000a216:	e0 88 00 05 	brls	8000a220 <_dtoa_r+0x200>
8000a21a:	30 18       	mov	r8,1
8000a21c:	51 48       	stdsp	sp[0x50],r8
8000a21e:	c1 38       	rjmp	8000a244 <_dtoa_r+0x224>
8000a220:	fe c8 c2 98 	sub	r8,pc,-15720
8000a224:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a228:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a22c:	e0 a0 10 74 	rcall	8000c314 <__avr32_f64_cmp_lt>
8000a230:	f9 b4 00 00 	moveq	r4,0
8000a234:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a238:	f7 b6 01 01 	subne	r6,1
8000a23c:	f9 bc 01 00 	movne	r12,0
8000a240:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a244:	41 90       	lddsp	r0,sp[0x64]
8000a246:	20 10       	sub	r0,1
8000a248:	0a 10       	sub	r0,r5
8000a24a:	c0 46       	brmi	8000a252 <_dtoa_r+0x232>
8000a24c:	50 40       	stdsp	sp[0x10],r0
8000a24e:	30 00       	mov	r0,0
8000a250:	c0 48       	rjmp	8000a258 <_dtoa_r+0x238>
8000a252:	30 0b       	mov	r11,0
8000a254:	5c 30       	neg	r0
8000a256:	50 4b       	stdsp	sp[0x10],r11
8000a258:	ec 02 11 00 	rsub	r2,r6,0
8000a25c:	58 06       	cp.w	r6,0
8000a25e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a262:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a266:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a26a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a26e:	f9 b2 04 00 	movge	r2,0
8000a272:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a276:	f9 b9 05 00 	movlt	r9,0
8000a27a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a27e:	40 c8       	lddsp	r8,sp[0x30]
8000a280:	58 98       	cp.w	r8,9
8000a282:	e0 8b 00 20 	brhi	8000a2c2 <_dtoa_r+0x2a2>
8000a286:	58 58       	cp.w	r8,5
8000a288:	f9 b4 0a 01 	movle	r4,1
8000a28c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a290:	f7 b5 09 04 	subgt	r5,4
8000a294:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a298:	f9 b4 09 00 	movgt	r4,0
8000a29c:	40 cc       	lddsp	r12,sp[0x30]
8000a29e:	58 3c       	cp.w	r12,3
8000a2a0:	c2 d0       	breq	8000a2fa <_dtoa_r+0x2da>
8000a2a2:	e0 89 00 05 	brgt	8000a2ac <_dtoa_r+0x28c>
8000a2a6:	58 2c       	cp.w	r12,2
8000a2a8:	c1 01       	brne	8000a2c8 <_dtoa_r+0x2a8>
8000a2aa:	c1 88       	rjmp	8000a2da <_dtoa_r+0x2ba>
8000a2ac:	40 cb       	lddsp	r11,sp[0x30]
8000a2ae:	58 4b       	cp.w	r11,4
8000a2b0:	c0 60       	breq	8000a2bc <_dtoa_r+0x29c>
8000a2b2:	58 5b       	cp.w	r11,5
8000a2b4:	c0 a1       	brne	8000a2c8 <_dtoa_r+0x2a8>
8000a2b6:	30 1a       	mov	r10,1
8000a2b8:	50 da       	stdsp	sp[0x34],r10
8000a2ba:	c2 28       	rjmp	8000a2fe <_dtoa_r+0x2de>
8000a2bc:	30 19       	mov	r9,1
8000a2be:	50 d9       	stdsp	sp[0x34],r9
8000a2c0:	c0 f8       	rjmp	8000a2de <_dtoa_r+0x2be>
8000a2c2:	30 08       	mov	r8,0
8000a2c4:	30 14       	mov	r4,1
8000a2c6:	50 c8       	stdsp	sp[0x30],r8
8000a2c8:	3f f5       	mov	r5,-1
8000a2ca:	30 1c       	mov	r12,1
8000a2cc:	30 0b       	mov	r11,0
8000a2ce:	50 95       	stdsp	sp[0x24],r5
8000a2d0:	50 dc       	stdsp	sp[0x34],r12
8000a2d2:	0a 91       	mov	r1,r5
8000a2d4:	31 28       	mov	r8,18
8000a2d6:	50 eb       	stdsp	sp[0x38],r11
8000a2d8:	c2 08       	rjmp	8000a318 <_dtoa_r+0x2f8>
8000a2da:	30 0a       	mov	r10,0
8000a2dc:	50 da       	stdsp	sp[0x34],r10
8000a2de:	40 e9       	lddsp	r9,sp[0x38]
8000a2e0:	58 09       	cp.w	r9,0
8000a2e2:	e0 89 00 07 	brgt	8000a2f0 <_dtoa_r+0x2d0>
8000a2e6:	30 18       	mov	r8,1
8000a2e8:	50 98       	stdsp	sp[0x24],r8
8000a2ea:	10 91       	mov	r1,r8
8000a2ec:	50 e8       	stdsp	sp[0x38],r8
8000a2ee:	c1 58       	rjmp	8000a318 <_dtoa_r+0x2f8>
8000a2f0:	40 e5       	lddsp	r5,sp[0x38]
8000a2f2:	50 95       	stdsp	sp[0x24],r5
8000a2f4:	0a 91       	mov	r1,r5
8000a2f6:	0a 98       	mov	r8,r5
8000a2f8:	c1 08       	rjmp	8000a318 <_dtoa_r+0x2f8>
8000a2fa:	30 0c       	mov	r12,0
8000a2fc:	50 dc       	stdsp	sp[0x34],r12
8000a2fe:	40 eb       	lddsp	r11,sp[0x38]
8000a300:	ec 0b 00 0b 	add	r11,r6,r11
8000a304:	50 9b       	stdsp	sp[0x24],r11
8000a306:	16 98       	mov	r8,r11
8000a308:	2f f8       	sub	r8,-1
8000a30a:	58 08       	cp.w	r8,0
8000a30c:	e0 89 00 05 	brgt	8000a316 <_dtoa_r+0x2f6>
8000a310:	10 91       	mov	r1,r8
8000a312:	30 18       	mov	r8,1
8000a314:	c0 28       	rjmp	8000a318 <_dtoa_r+0x2f8>
8000a316:	10 91       	mov	r1,r8
8000a318:	30 09       	mov	r9,0
8000a31a:	6e 9a       	ld.w	r10,r7[0x24]
8000a31c:	95 19       	st.w	r10[0x4],r9
8000a31e:	30 49       	mov	r9,4
8000a320:	c0 68       	rjmp	8000a32c <_dtoa_r+0x30c>
8000a322:	d7 03       	nop
8000a324:	6a 1a       	ld.w	r10,r5[0x4]
8000a326:	a1 79       	lsl	r9,0x1
8000a328:	2f fa       	sub	r10,-1
8000a32a:	8b 1a       	st.w	r5[0x4],r10
8000a32c:	6e 95       	ld.w	r5,r7[0x24]
8000a32e:	f2 ca ff ec 	sub	r10,r9,-20
8000a332:	10 3a       	cp.w	r10,r8
8000a334:	fe 98 ff f8 	brls	8000a324 <_dtoa_r+0x304>
8000a338:	6a 1b       	ld.w	r11,r5[0x4]
8000a33a:	0e 9c       	mov	r12,r7
8000a33c:	e0 a0 09 44 	rcall	8000b5c4 <_Balloc>
8000a340:	58 e1       	cp.w	r1,14
8000a342:	5f 88       	srls	r8
8000a344:	8b 0c       	st.w	r5[0x0],r12
8000a346:	f1 e4 00 04 	and	r4,r8,r4
8000a34a:	6e 98       	ld.w	r8,r7[0x24]
8000a34c:	70 08       	ld.w	r8,r8[0x0]
8000a34e:	50 88       	stdsp	sp[0x20],r8
8000a350:	e0 80 01 82 	breq	8000a654 <_dtoa_r+0x634>
8000a354:	58 06       	cp.w	r6,0
8000a356:	e0 8a 00 43 	brle	8000a3dc <_dtoa_r+0x3bc>
8000a35a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a35e:	fe c8 c3 d6 	sub	r8,pc,-15402
8000a362:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a366:	fa e5 00 18 	st.d	sp[24],r4
8000a36a:	ec 04 14 04 	asr	r4,r6,0x4
8000a36e:	ed b4 00 04 	bld	r4,0x4
8000a372:	c0 30       	breq	8000a378 <_dtoa_r+0x358>
8000a374:	30 25       	mov	r5,2
8000a376:	c1 08       	rjmp	8000a396 <_dtoa_r+0x376>
8000a378:	fe c8 c3 28 	sub	r8,pc,-15576
8000a37c:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a380:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a384:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a388:	e0 a0 0f fa 	rcall	8000c37c <__avr32_f64_div>
8000a38c:	30 35       	mov	r5,3
8000a38e:	14 98       	mov	r8,r10
8000a390:	16 99       	mov	r9,r11
8000a392:	fa e9 00 08 	st.d	sp[8],r8
8000a396:	fe cc c3 46 	sub	r12,pc,-15546
8000a39a:	50 a3       	stdsp	sp[0x28],r3
8000a39c:	0c 93       	mov	r3,r6
8000a39e:	18 96       	mov	r6,r12
8000a3a0:	c0 f8       	rjmp	8000a3be <_dtoa_r+0x39e>
8000a3a2:	fa ea 00 18 	ld.d	r10,sp[24]
8000a3a6:	ed b4 00 00 	bld	r4,0x0
8000a3aa:	c0 81       	brne	8000a3ba <_dtoa_r+0x39a>
8000a3ac:	ec e8 00 00 	ld.d	r8,r6[0]
8000a3b0:	2f f5       	sub	r5,-1
8000a3b2:	e0 a0 0c 9f 	rcall	8000bcf0 <__avr32_f64_mul>
8000a3b6:	fa eb 00 18 	st.d	sp[24],r10
8000a3ba:	a1 54       	asr	r4,0x1
8000a3bc:	2f 86       	sub	r6,-8
8000a3be:	58 04       	cp.w	r4,0
8000a3c0:	cf 11       	brne	8000a3a2 <_dtoa_r+0x382>
8000a3c2:	fa e8 00 18 	ld.d	r8,sp[24]
8000a3c6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3ca:	06 96       	mov	r6,r3
8000a3cc:	e0 a0 0f d8 	rcall	8000c37c <__avr32_f64_div>
8000a3d0:	40 a3       	lddsp	r3,sp[0x28]
8000a3d2:	14 98       	mov	r8,r10
8000a3d4:	16 99       	mov	r9,r11
8000a3d6:	fa e9 00 08 	st.d	sp[8],r8
8000a3da:	c2 f8       	rjmp	8000a438 <_dtoa_r+0x418>
8000a3dc:	ec 08 11 00 	rsub	r8,r6,0
8000a3e0:	c0 31       	brne	8000a3e6 <_dtoa_r+0x3c6>
8000a3e2:	30 25       	mov	r5,2
8000a3e4:	c2 a8       	rjmp	8000a438 <_dtoa_r+0x418>
8000a3e6:	fe cc c3 96 	sub	r12,pc,-15466
8000a3ea:	f0 04 14 04 	asr	r4,r8,0x4
8000a3ee:	50 1c       	stdsp	sp[0x4],r12
8000a3f0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a3f4:	fe c9 c4 6c 	sub	r9,pc,-15252
8000a3f8:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a3fc:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a400:	e0 a0 0c 78 	rcall	8000bcf0 <__avr32_f64_mul>
8000a404:	40 1c       	lddsp	r12,sp[0x4]
8000a406:	50 63       	stdsp	sp[0x18],r3
8000a408:	30 25       	mov	r5,2
8000a40a:	0c 93       	mov	r3,r6
8000a40c:	fa eb 00 08 	st.d	sp[8],r10
8000a410:	18 96       	mov	r6,r12
8000a412:	c0 f8       	rjmp	8000a430 <_dtoa_r+0x410>
8000a414:	fa ea 00 08 	ld.d	r10,sp[8]
8000a418:	ed b4 00 00 	bld	r4,0x0
8000a41c:	c0 81       	brne	8000a42c <_dtoa_r+0x40c>
8000a41e:	ec e8 00 00 	ld.d	r8,r6[0]
8000a422:	2f f5       	sub	r5,-1
8000a424:	e0 a0 0c 66 	rcall	8000bcf0 <__avr32_f64_mul>
8000a428:	fa eb 00 08 	st.d	sp[8],r10
8000a42c:	a1 54       	asr	r4,0x1
8000a42e:	2f 86       	sub	r6,-8
8000a430:	58 04       	cp.w	r4,0
8000a432:	cf 11       	brne	8000a414 <_dtoa_r+0x3f4>
8000a434:	06 96       	mov	r6,r3
8000a436:	40 63       	lddsp	r3,sp[0x18]
8000a438:	41 4a       	lddsp	r10,sp[0x50]
8000a43a:	58 0a       	cp.w	r10,0
8000a43c:	c2 a0       	breq	8000a490 <_dtoa_r+0x470>
8000a43e:	fa e8 00 08 	ld.d	r8,sp[8]
8000a442:	58 01       	cp.w	r1,0
8000a444:	5f 94       	srgt	r4
8000a446:	fa e9 00 18 	st.d	sp[24],r8
8000a44a:	30 08       	mov	r8,0
8000a44c:	fc 19 3f f0 	movh	r9,0x3ff0
8000a450:	fa ea 00 18 	ld.d	r10,sp[24]
8000a454:	e0 a0 0f 60 	rcall	8000c314 <__avr32_f64_cmp_lt>
8000a458:	f9 bc 00 00 	moveq	r12,0
8000a45c:	f9 bc 01 01 	movne	r12,1
8000a460:	e9 ec 00 0c 	and	r12,r4,r12
8000a464:	c1 60       	breq	8000a490 <_dtoa_r+0x470>
8000a466:	40 98       	lddsp	r8,sp[0x24]
8000a468:	58 08       	cp.w	r8,0
8000a46a:	e0 8a 00 f1 	brle	8000a64c <_dtoa_r+0x62c>
8000a46e:	30 08       	mov	r8,0
8000a470:	fc 19 40 24 	movh	r9,0x4024
8000a474:	ec c4 00 01 	sub	r4,r6,1
8000a478:	fa ea 00 18 	ld.d	r10,sp[24]
8000a47c:	2f f5       	sub	r5,-1
8000a47e:	50 64       	stdsp	sp[0x18],r4
8000a480:	e0 a0 0c 38 	rcall	8000bcf0 <__avr32_f64_mul>
8000a484:	40 94       	lddsp	r4,sp[0x24]
8000a486:	14 98       	mov	r8,r10
8000a488:	16 99       	mov	r9,r11
8000a48a:	fa e9 00 08 	st.d	sp[8],r8
8000a48e:	c0 38       	rjmp	8000a494 <_dtoa_r+0x474>
8000a490:	50 66       	stdsp	sp[0x18],r6
8000a492:	02 94       	mov	r4,r1
8000a494:	0a 9c       	mov	r12,r5
8000a496:	e0 a0 0e 88 	rcall	8000c1a6 <__avr32_s32_to_f64>
8000a49a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a49e:	e0 a0 0c 29 	rcall	8000bcf0 <__avr32_f64_mul>
8000a4a2:	30 08       	mov	r8,0
8000a4a4:	fc 19 40 1c 	movh	r9,0x401c
8000a4a8:	e0 a0 0d de 	rcall	8000c064 <__avr32_f64_add>
8000a4ac:	14 98       	mov	r8,r10
8000a4ae:	16 99       	mov	r9,r11
8000a4b0:	fa e9 00 28 	st.d	sp[40],r8
8000a4b4:	fc 18 fc c0 	movh	r8,0xfcc0
8000a4b8:	40 a5       	lddsp	r5,sp[0x28]
8000a4ba:	10 05       	add	r5,r8
8000a4bc:	50 a5       	stdsp	sp[0x28],r5
8000a4be:	58 04       	cp.w	r4,0
8000a4c0:	c2 11       	brne	8000a502 <_dtoa_r+0x4e2>
8000a4c2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4c6:	30 08       	mov	r8,0
8000a4c8:	fc 19 40 14 	movh	r9,0x4014
8000a4cc:	e0 a0 0c fe 	rcall	8000bec8 <__avr32_f64_sub>
8000a4d0:	40 bc       	lddsp	r12,sp[0x2c]
8000a4d2:	fa eb 00 08 	st.d	sp[8],r10
8000a4d6:	14 98       	mov	r8,r10
8000a4d8:	16 99       	mov	r9,r11
8000a4da:	18 9a       	mov	r10,r12
8000a4dc:	0a 9b       	mov	r11,r5
8000a4de:	e0 a0 0f 1b 	rcall	8000c314 <__avr32_f64_cmp_lt>
8000a4e2:	e0 81 02 54 	brne	8000a98a <_dtoa_r+0x96a>
8000a4e6:	0a 98       	mov	r8,r5
8000a4e8:	40 b9       	lddsp	r9,sp[0x2c]
8000a4ea:	ee 18 80 00 	eorh	r8,0x8000
8000a4ee:	fa ea 00 08 	ld.d	r10,sp[8]
8000a4f2:	10 95       	mov	r5,r8
8000a4f4:	12 98       	mov	r8,r9
8000a4f6:	0a 99       	mov	r9,r5
8000a4f8:	e0 a0 0f 0e 	rcall	8000c314 <__avr32_f64_cmp_lt>
8000a4fc:	e0 81 02 3e 	brne	8000a978 <_dtoa_r+0x958>
8000a500:	ca 68       	rjmp	8000a64c <_dtoa_r+0x62c>
8000a502:	fe c9 c5 7a 	sub	r9,pc,-14982
8000a506:	e8 c8 00 01 	sub	r8,r4,1
8000a50a:	40 d5       	lddsp	r5,sp[0x34]
8000a50c:	58 05       	cp.w	r5,0
8000a50e:	c4 f0       	breq	8000a5ac <_dtoa_r+0x58c>
8000a510:	30 0c       	mov	r12,0
8000a512:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a516:	51 3c       	stdsp	sp[0x4c],r12
8000a518:	30 0a       	mov	r10,0
8000a51a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a51e:	e0 a0 0f 2f 	rcall	8000c37c <__avr32_f64_div>
8000a522:	fa e8 00 28 	ld.d	r8,sp[40]
8000a526:	40 85       	lddsp	r5,sp[0x20]
8000a528:	e0 a0 0c d0 	rcall	8000bec8 <__avr32_f64_sub>
8000a52c:	fa eb 00 28 	st.d	sp[40],r10
8000a530:	fa ea 00 08 	ld.d	r10,sp[8]
8000a534:	e0 a0 0e 22 	rcall	8000c178 <__avr32_f64_to_s32>
8000a538:	51 6c       	stdsp	sp[0x58],r12
8000a53a:	e0 a0 0e 36 	rcall	8000c1a6 <__avr32_s32_to_f64>
8000a53e:	14 98       	mov	r8,r10
8000a540:	16 99       	mov	r9,r11
8000a542:	fa ea 00 08 	ld.d	r10,sp[8]
8000a546:	e0 a0 0c c1 	rcall	8000bec8 <__avr32_f64_sub>
8000a54a:	fa eb 00 08 	st.d	sp[8],r10
8000a54e:	41 68       	lddsp	r8,sp[0x58]
8000a550:	2d 08       	sub	r8,-48
8000a552:	0a c8       	st.b	r5++,r8
8000a554:	41 39       	lddsp	r9,sp[0x4c]
8000a556:	2f f9       	sub	r9,-1
8000a558:	51 39       	stdsp	sp[0x4c],r9
8000a55a:	fa e8 00 28 	ld.d	r8,sp[40]
8000a55e:	e0 a0 0e db 	rcall	8000c314 <__avr32_f64_cmp_lt>
8000a562:	e0 81 03 39 	brne	8000abd4 <_dtoa_r+0xbb4>
8000a566:	fa e8 00 08 	ld.d	r8,sp[8]
8000a56a:	30 0a       	mov	r10,0
8000a56c:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a570:	e0 a0 0c ac 	rcall	8000bec8 <__avr32_f64_sub>
8000a574:	fa e8 00 28 	ld.d	r8,sp[40]
8000a578:	e0 a0 0e ce 	rcall	8000c314 <__avr32_f64_cmp_lt>
8000a57c:	fa ea 00 28 	ld.d	r10,sp[40]
8000a580:	30 08       	mov	r8,0
8000a582:	fc 19 40 24 	movh	r9,0x4024
8000a586:	e0 81 00 da 	brne	8000a73a <_dtoa_r+0x71a>
8000a58a:	41 3c       	lddsp	r12,sp[0x4c]
8000a58c:	08 3c       	cp.w	r12,r4
8000a58e:	c5 f4       	brge	8000a64c <_dtoa_r+0x62c>
8000a590:	e0 a0 0b b0 	rcall	8000bcf0 <__avr32_f64_mul>
8000a594:	30 08       	mov	r8,0
8000a596:	fa eb 00 28 	st.d	sp[40],r10
8000a59a:	fc 19 40 24 	movh	r9,0x4024
8000a59e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5a2:	e0 a0 0b a7 	rcall	8000bcf0 <__avr32_f64_mul>
8000a5a6:	fa eb 00 08 	st.d	sp[8],r10
8000a5aa:	cc 3b       	rjmp	8000a530 <_dtoa_r+0x510>
8000a5ac:	40 85       	lddsp	r5,sp[0x20]
8000a5ae:	08 05       	add	r5,r4
8000a5b0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a5b4:	51 35       	stdsp	sp[0x4c],r5
8000a5b6:	fa e8 00 28 	ld.d	r8,sp[40]
8000a5ba:	40 85       	lddsp	r5,sp[0x20]
8000a5bc:	e0 a0 0b 9a 	rcall	8000bcf0 <__avr32_f64_mul>
8000a5c0:	fa eb 00 28 	st.d	sp[40],r10
8000a5c4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5c8:	e0 a0 0d d8 	rcall	8000c178 <__avr32_f64_to_s32>
8000a5cc:	51 6c       	stdsp	sp[0x58],r12
8000a5ce:	e0 a0 0d ec 	rcall	8000c1a6 <__avr32_s32_to_f64>
8000a5d2:	14 98       	mov	r8,r10
8000a5d4:	16 99       	mov	r9,r11
8000a5d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a5da:	e0 a0 0c 77 	rcall	8000bec8 <__avr32_f64_sub>
8000a5de:	fa eb 00 08 	st.d	sp[8],r10
8000a5e2:	41 68       	lddsp	r8,sp[0x58]
8000a5e4:	2d 08       	sub	r8,-48
8000a5e6:	0a c8       	st.b	r5++,r8
8000a5e8:	41 3c       	lddsp	r12,sp[0x4c]
8000a5ea:	18 35       	cp.w	r5,r12
8000a5ec:	c2 81       	brne	8000a63c <_dtoa_r+0x61c>
8000a5ee:	30 08       	mov	r8,0
8000a5f0:	fc 19 3f e0 	movh	r9,0x3fe0
8000a5f4:	fa ea 00 28 	ld.d	r10,sp[40]
8000a5f8:	e0 a0 0d 36 	rcall	8000c064 <__avr32_f64_add>
8000a5fc:	40 85       	lddsp	r5,sp[0x20]
8000a5fe:	fa e8 00 08 	ld.d	r8,sp[8]
8000a602:	08 05       	add	r5,r4
8000a604:	e0 a0 0e 88 	rcall	8000c314 <__avr32_f64_cmp_lt>
8000a608:	e0 81 00 99 	brne	8000a73a <_dtoa_r+0x71a>
8000a60c:	fa e8 00 28 	ld.d	r8,sp[40]
8000a610:	30 0a       	mov	r10,0
8000a612:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a616:	e0 a0 0c 59 	rcall	8000bec8 <__avr32_f64_sub>
8000a61a:	14 98       	mov	r8,r10
8000a61c:	16 99       	mov	r9,r11
8000a61e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a622:	e0 a0 0e 79 	rcall	8000c314 <__avr32_f64_cmp_lt>
8000a626:	c1 30       	breq	8000a64c <_dtoa_r+0x62c>
8000a628:	33 09       	mov	r9,48
8000a62a:	0a 98       	mov	r8,r5
8000a62c:	11 7a       	ld.ub	r10,--r8
8000a62e:	f2 0a 18 00 	cp.b	r10,r9
8000a632:	e0 81 02 d1 	brne	8000abd4 <_dtoa_r+0xbb4>
8000a636:	10 95       	mov	r5,r8
8000a638:	cf 9b       	rjmp	8000a62a <_dtoa_r+0x60a>
8000a63a:	d7 03       	nop
8000a63c:	30 08       	mov	r8,0
8000a63e:	fc 19 40 24 	movh	r9,0x4024
8000a642:	e0 a0 0b 57 	rcall	8000bcf0 <__avr32_f64_mul>
8000a646:	fa eb 00 08 	st.d	sp[8],r10
8000a64a:	cb db       	rjmp	8000a5c4 <_dtoa_r+0x5a4>
8000a64c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a650:	fa eb 00 08 	st.d	sp[8],r10
8000a654:	58 e6       	cp.w	r6,14
8000a656:	5f ab       	srle	r11
8000a658:	41 8a       	lddsp	r10,sp[0x60]
8000a65a:	30 08       	mov	r8,0
8000a65c:	f4 09 11 ff 	rsub	r9,r10,-1
8000a660:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a664:	f0 09 18 00 	cp.b	r9,r8
8000a668:	e0 80 00 82 	breq	8000a76c <_dtoa_r+0x74c>
8000a66c:	40 ea       	lddsp	r10,sp[0x38]
8000a66e:	58 01       	cp.w	r1,0
8000a670:	5f a9       	srle	r9
8000a672:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a676:	fe ca c6 ee 	sub	r10,pc,-14610
8000a67a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a67e:	fa e5 00 10 	st.d	sp[16],r4
8000a682:	f0 09 18 00 	cp.b	r9,r8
8000a686:	c1 40       	breq	8000a6ae <_dtoa_r+0x68e>
8000a688:	58 01       	cp.w	r1,0
8000a68a:	e0 81 01 77 	brne	8000a978 <_dtoa_r+0x958>
8000a68e:	30 08       	mov	r8,0
8000a690:	fc 19 40 14 	movh	r9,0x4014
8000a694:	08 9a       	mov	r10,r4
8000a696:	0a 9b       	mov	r11,r5
8000a698:	e0 a0 0b 2c 	rcall	8000bcf0 <__avr32_f64_mul>
8000a69c:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6a0:	e0 a0 0e 06 	rcall	8000c2ac <__avr32_f64_cmp_ge>
8000a6a4:	e0 81 01 6a 	brne	8000a978 <_dtoa_r+0x958>
8000a6a8:	02 92       	mov	r2,r1
8000a6aa:	e0 8f 01 72 	bral	8000a98e <_dtoa_r+0x96e>
8000a6ae:	40 85       	lddsp	r5,sp[0x20]
8000a6b0:	30 14       	mov	r4,1
8000a6b2:	fa e8 00 10 	ld.d	r8,sp[16]
8000a6b6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6ba:	e0 a0 0e 61 	rcall	8000c37c <__avr32_f64_div>
8000a6be:	e0 a0 0d 5d 	rcall	8000c178 <__avr32_f64_to_s32>
8000a6c2:	18 92       	mov	r2,r12
8000a6c4:	e0 a0 0d 71 	rcall	8000c1a6 <__avr32_s32_to_f64>
8000a6c8:	fa e8 00 10 	ld.d	r8,sp[16]
8000a6cc:	e0 a0 0b 12 	rcall	8000bcf0 <__avr32_f64_mul>
8000a6d0:	14 98       	mov	r8,r10
8000a6d2:	16 99       	mov	r9,r11
8000a6d4:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6d8:	e0 a0 0b f8 	rcall	8000bec8 <__avr32_f64_sub>
8000a6dc:	fa eb 00 08 	st.d	sp[8],r10
8000a6e0:	e4 c8 ff d0 	sub	r8,r2,-48
8000a6e4:	0a c8       	st.b	r5++,r8
8000a6e6:	fc 19 40 24 	movh	r9,0x4024
8000a6ea:	30 08       	mov	r8,0
8000a6ec:	02 34       	cp.w	r4,r1
8000a6ee:	c3 31       	brne	8000a754 <_dtoa_r+0x734>
8000a6f0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a6f4:	e0 a0 0c b8 	rcall	8000c064 <__avr32_f64_add>
8000a6f8:	16 91       	mov	r1,r11
8000a6fa:	14 90       	mov	r0,r10
8000a6fc:	14 98       	mov	r8,r10
8000a6fe:	02 99       	mov	r9,r1
8000a700:	fa ea 00 10 	ld.d	r10,sp[16]
8000a704:	e0 a0 0e 08 	rcall	8000c314 <__avr32_f64_cmp_lt>
8000a708:	c1 a1       	brne	8000a73c <_dtoa_r+0x71c>
8000a70a:	fa e8 00 10 	ld.d	r8,sp[16]
8000a70e:	00 9a       	mov	r10,r0
8000a710:	02 9b       	mov	r11,r1
8000a712:	e0 a0 0d ba 	rcall	8000c286 <__avr32_f64_cmp_eq>
8000a716:	e0 80 02 5e 	breq	8000abd2 <_dtoa_r+0xbb2>
8000a71a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000a71e:	c0 f1       	brne	8000a73c <_dtoa_r+0x71c>
8000a720:	e0 8f 02 59 	bral	8000abd2 <_dtoa_r+0xbb2>
8000a724:	40 8a       	lddsp	r10,sp[0x20]
8000a726:	14 38       	cp.w	r8,r10
8000a728:	c0 30       	breq	8000a72e <_dtoa_r+0x70e>
8000a72a:	10 95       	mov	r5,r8
8000a72c:	c0 98       	rjmp	8000a73e <_dtoa_r+0x71e>
8000a72e:	33 08       	mov	r8,48
8000a730:	40 89       	lddsp	r9,sp[0x20]
8000a732:	2f f6       	sub	r6,-1
8000a734:	b2 88       	st.b	r9[0x0],r8
8000a736:	40 88       	lddsp	r8,sp[0x20]
8000a738:	c0 88       	rjmp	8000a748 <_dtoa_r+0x728>
8000a73a:	40 66       	lddsp	r6,sp[0x18]
8000a73c:	33 99       	mov	r9,57
8000a73e:	0a 98       	mov	r8,r5
8000a740:	11 7a       	ld.ub	r10,--r8
8000a742:	f2 0a 18 00 	cp.b	r10,r9
8000a746:	ce f0       	breq	8000a724 <_dtoa_r+0x704>
8000a748:	50 66       	stdsp	sp[0x18],r6
8000a74a:	11 89       	ld.ub	r9,r8[0x0]
8000a74c:	2f f9       	sub	r9,-1
8000a74e:	b0 89       	st.b	r8[0x0],r9
8000a750:	e0 8f 02 42 	bral	8000abd4 <_dtoa_r+0xbb4>
8000a754:	e0 a0 0a ce 	rcall	8000bcf0 <__avr32_f64_mul>
8000a758:	2f f4       	sub	r4,-1
8000a75a:	fa eb 00 08 	st.d	sp[8],r10
8000a75e:	30 08       	mov	r8,0
8000a760:	30 09       	mov	r9,0
8000a762:	e0 a0 0d 92 	rcall	8000c286 <__avr32_f64_cmp_eq>
8000a766:	ca 60       	breq	8000a6b2 <_dtoa_r+0x692>
8000a768:	e0 8f 02 35 	bral	8000abd2 <_dtoa_r+0xbb2>
8000a76c:	40 d8       	lddsp	r8,sp[0x34]
8000a76e:	58 08       	cp.w	r8,0
8000a770:	c0 51       	brne	8000a77a <_dtoa_r+0x75a>
8000a772:	04 98       	mov	r8,r2
8000a774:	00 95       	mov	r5,r0
8000a776:	40 d4       	lddsp	r4,sp[0x34]
8000a778:	c3 78       	rjmp	8000a7e6 <_dtoa_r+0x7c6>
8000a77a:	40 c5       	lddsp	r5,sp[0x30]
8000a77c:	58 15       	cp.w	r5,1
8000a77e:	e0 89 00 0f 	brgt	8000a79c <_dtoa_r+0x77c>
8000a782:	41 74       	lddsp	r4,sp[0x5c]
8000a784:	58 04       	cp.w	r4,0
8000a786:	c0 40       	breq	8000a78e <_dtoa_r+0x76e>
8000a788:	f4 c9 fb cd 	sub	r9,r10,-1075
8000a78c:	c0 48       	rjmp	8000a794 <_dtoa_r+0x774>
8000a78e:	41 99       	lddsp	r9,sp[0x64]
8000a790:	f2 09 11 36 	rsub	r9,r9,54
8000a794:	04 98       	mov	r8,r2
8000a796:	00 95       	mov	r5,r0
8000a798:	c1 c8       	rjmp	8000a7d0 <_dtoa_r+0x7b0>
8000a79a:	d7 03       	nop
8000a79c:	e2 c8 00 01 	sub	r8,r1,1
8000a7a0:	58 01       	cp.w	r1,0
8000a7a2:	e0 05 17 40 	movge	r5,r0
8000a7a6:	e2 09 17 40 	movge	r9,r1
8000a7aa:	e1 d1 e5 15 	sublt	r5,r0,r1
8000a7ae:	f9 b9 05 00 	movlt	r9,0
8000a7b2:	10 32       	cp.w	r2,r8
8000a7b4:	e5 d8 e4 18 	subge	r8,r2,r8
8000a7b8:	f1 d2 e5 18 	sublt	r8,r8,r2
8000a7bc:	e5 d8 e5 02 	addlt	r2,r2,r8
8000a7c0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000a7c4:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000a7c8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000a7cc:	f9 b8 05 00 	movlt	r8,0
8000a7d0:	40 4b       	lddsp	r11,sp[0x10]
8000a7d2:	12 0b       	add	r11,r9
8000a7d4:	50 08       	stdsp	sp[0x0],r8
8000a7d6:	50 4b       	stdsp	sp[0x10],r11
8000a7d8:	12 00       	add	r0,r9
8000a7da:	30 1b       	mov	r11,1
8000a7dc:	0e 9c       	mov	r12,r7
8000a7de:	e0 a0 08 a7 	rcall	8000b92c <__i2b>
8000a7e2:	40 08       	lddsp	r8,sp[0x0]
8000a7e4:	18 94       	mov	r4,r12
8000a7e6:	40 4a       	lddsp	r10,sp[0x10]
8000a7e8:	58 05       	cp.w	r5,0
8000a7ea:	5f 99       	srgt	r9
8000a7ec:	58 0a       	cp.w	r10,0
8000a7ee:	5f 9a       	srgt	r10
8000a7f0:	f5 e9 00 09 	and	r9,r10,r9
8000a7f4:	c0 80       	breq	8000a804 <_dtoa_r+0x7e4>
8000a7f6:	40 4c       	lddsp	r12,sp[0x10]
8000a7f8:	f8 05 0d 49 	min	r9,r12,r5
8000a7fc:	12 1c       	sub	r12,r9
8000a7fe:	12 10       	sub	r0,r9
8000a800:	50 4c       	stdsp	sp[0x10],r12
8000a802:	12 15       	sub	r5,r9
8000a804:	58 02       	cp.w	r2,0
8000a806:	e0 8a 00 27 	brle	8000a854 <_dtoa_r+0x834>
8000a80a:	40 db       	lddsp	r11,sp[0x34]
8000a80c:	58 0b       	cp.w	r11,0
8000a80e:	c1 d0       	breq	8000a848 <_dtoa_r+0x828>
8000a810:	58 08       	cp.w	r8,0
8000a812:	e0 8a 00 17 	brle	8000a840 <_dtoa_r+0x820>
8000a816:	10 9a       	mov	r10,r8
8000a818:	50 08       	stdsp	sp[0x0],r8
8000a81a:	08 9b       	mov	r11,r4
8000a81c:	0e 9c       	mov	r12,r7
8000a81e:	e0 a0 08 cd 	rcall	8000b9b8 <__pow5mult>
8000a822:	06 9a       	mov	r10,r3
8000a824:	18 9b       	mov	r11,r12
8000a826:	18 94       	mov	r4,r12
8000a828:	0e 9c       	mov	r12,r7
8000a82a:	e0 a0 08 01 	rcall	8000b82c <__multiply>
8000a82e:	18 99       	mov	r9,r12
8000a830:	06 9b       	mov	r11,r3
8000a832:	50 19       	stdsp	sp[0x4],r9
8000a834:	0e 9c       	mov	r12,r7
8000a836:	e0 a0 06 ad 	rcall	8000b590 <_Bfree>
8000a83a:	40 19       	lddsp	r9,sp[0x4]
8000a83c:	40 08       	lddsp	r8,sp[0x0]
8000a83e:	12 93       	mov	r3,r9
8000a840:	e4 08 01 0a 	sub	r10,r2,r8
8000a844:	c0 80       	breq	8000a854 <_dtoa_r+0x834>
8000a846:	c0 28       	rjmp	8000a84a <_dtoa_r+0x82a>
8000a848:	04 9a       	mov	r10,r2
8000a84a:	06 9b       	mov	r11,r3
8000a84c:	0e 9c       	mov	r12,r7
8000a84e:	e0 a0 08 b5 	rcall	8000b9b8 <__pow5mult>
8000a852:	18 93       	mov	r3,r12
8000a854:	30 1b       	mov	r11,1
8000a856:	0e 9c       	mov	r12,r7
8000a858:	e0 a0 08 6a 	rcall	8000b92c <__i2b>
8000a85c:	41 1a       	lddsp	r10,sp[0x44]
8000a85e:	18 92       	mov	r2,r12
8000a860:	58 0a       	cp.w	r10,0
8000a862:	e0 8a 00 07 	brle	8000a870 <_dtoa_r+0x850>
8000a866:	18 9b       	mov	r11,r12
8000a868:	0e 9c       	mov	r12,r7
8000a86a:	e0 a0 08 a7 	rcall	8000b9b8 <__pow5mult>
8000a86e:	18 92       	mov	r2,r12
8000a870:	40 c9       	lddsp	r9,sp[0x30]
8000a872:	58 19       	cp.w	r9,1
8000a874:	e0 89 00 14 	brgt	8000a89c <_dtoa_r+0x87c>
8000a878:	40 38       	lddsp	r8,sp[0xc]
8000a87a:	58 08       	cp.w	r8,0
8000a87c:	c1 01       	brne	8000a89c <_dtoa_r+0x87c>
8000a87e:	40 29       	lddsp	r9,sp[0x8]
8000a880:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000a884:	c0 c1       	brne	8000a89c <_dtoa_r+0x87c>
8000a886:	12 98       	mov	r8,r9
8000a888:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a88c:	c0 80       	breq	8000a89c <_dtoa_r+0x87c>
8000a88e:	40 4c       	lddsp	r12,sp[0x10]
8000a890:	30 1b       	mov	r11,1
8000a892:	2f fc       	sub	r12,-1
8000a894:	2f f0       	sub	r0,-1
8000a896:	50 4c       	stdsp	sp[0x10],r12
8000a898:	50 6b       	stdsp	sp[0x18],r11
8000a89a:	c0 38       	rjmp	8000a8a0 <_dtoa_r+0x880>
8000a89c:	30 0a       	mov	r10,0
8000a89e:	50 6a       	stdsp	sp[0x18],r10
8000a8a0:	41 19       	lddsp	r9,sp[0x44]
8000a8a2:	58 09       	cp.w	r9,0
8000a8a4:	c0 31       	brne	8000a8aa <_dtoa_r+0x88a>
8000a8a6:	30 1c       	mov	r12,1
8000a8a8:	c0 98       	rjmp	8000a8ba <_dtoa_r+0x89a>
8000a8aa:	64 48       	ld.w	r8,r2[0x10]
8000a8ac:	2f c8       	sub	r8,-4
8000a8ae:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000a8b2:	e0 a0 05 df 	rcall	8000b470 <__hi0bits>
8000a8b6:	f8 0c 11 20 	rsub	r12,r12,32
8000a8ba:	40 4b       	lddsp	r11,sp[0x10]
8000a8bc:	f8 0b 00 08 	add	r8,r12,r11
8000a8c0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000a8c4:	c0 c0       	breq	8000a8dc <_dtoa_r+0x8bc>
8000a8c6:	f0 08 11 20 	rsub	r8,r8,32
8000a8ca:	58 48       	cp.w	r8,4
8000a8cc:	e0 8a 00 06 	brle	8000a8d8 <_dtoa_r+0x8b8>
8000a8d0:	20 48       	sub	r8,4
8000a8d2:	10 0b       	add	r11,r8
8000a8d4:	50 4b       	stdsp	sp[0x10],r11
8000a8d6:	c0 78       	rjmp	8000a8e4 <_dtoa_r+0x8c4>
8000a8d8:	58 48       	cp.w	r8,4
8000a8da:	c0 70       	breq	8000a8e8 <_dtoa_r+0x8c8>
8000a8dc:	40 4a       	lddsp	r10,sp[0x10]
8000a8de:	2e 48       	sub	r8,-28
8000a8e0:	10 0a       	add	r10,r8
8000a8e2:	50 4a       	stdsp	sp[0x10],r10
8000a8e4:	10 00       	add	r0,r8
8000a8e6:	10 05       	add	r5,r8
8000a8e8:	58 00       	cp.w	r0,0
8000a8ea:	e0 8a 00 08 	brle	8000a8fa <_dtoa_r+0x8da>
8000a8ee:	06 9b       	mov	r11,r3
8000a8f0:	00 9a       	mov	r10,r0
8000a8f2:	0e 9c       	mov	r12,r7
8000a8f4:	e0 a0 07 58 	rcall	8000b7a4 <__lshift>
8000a8f8:	18 93       	mov	r3,r12
8000a8fa:	40 49       	lddsp	r9,sp[0x10]
8000a8fc:	58 09       	cp.w	r9,0
8000a8fe:	e0 8a 00 08 	brle	8000a90e <_dtoa_r+0x8ee>
8000a902:	04 9b       	mov	r11,r2
8000a904:	12 9a       	mov	r10,r9
8000a906:	0e 9c       	mov	r12,r7
8000a908:	e0 a0 07 4e 	rcall	8000b7a4 <__lshift>
8000a90c:	18 92       	mov	r2,r12
8000a90e:	41 48       	lddsp	r8,sp[0x50]
8000a910:	58 08       	cp.w	r8,0
8000a912:	c1 b0       	breq	8000a948 <_dtoa_r+0x928>
8000a914:	04 9b       	mov	r11,r2
8000a916:	06 9c       	mov	r12,r3
8000a918:	e0 a0 06 23 	rcall	8000b55e <__mcmp>
8000a91c:	c1 64       	brge	8000a948 <_dtoa_r+0x928>
8000a91e:	06 9b       	mov	r11,r3
8000a920:	30 09       	mov	r9,0
8000a922:	30 aa       	mov	r10,10
8000a924:	0e 9c       	mov	r12,r7
8000a926:	e0 a0 08 0b 	rcall	8000b93c <__multadd>
8000a92a:	20 16       	sub	r6,1
8000a92c:	18 93       	mov	r3,r12
8000a92e:	40 dc       	lddsp	r12,sp[0x34]
8000a930:	58 0c       	cp.w	r12,0
8000a932:	c0 31       	brne	8000a938 <_dtoa_r+0x918>
8000a934:	40 91       	lddsp	r1,sp[0x24]
8000a936:	c0 98       	rjmp	8000a948 <_dtoa_r+0x928>
8000a938:	08 9b       	mov	r11,r4
8000a93a:	40 91       	lddsp	r1,sp[0x24]
8000a93c:	30 09       	mov	r9,0
8000a93e:	30 aa       	mov	r10,10
8000a940:	0e 9c       	mov	r12,r7
8000a942:	e0 a0 07 fd 	rcall	8000b93c <__multadd>
8000a946:	18 94       	mov	r4,r12
8000a948:	58 01       	cp.w	r1,0
8000a94a:	5f a9       	srle	r9
8000a94c:	40 cb       	lddsp	r11,sp[0x30]
8000a94e:	58 2b       	cp.w	r11,2
8000a950:	5f 98       	srgt	r8
8000a952:	f3 e8 00 08 	and	r8,r9,r8
8000a956:	c2 50       	breq	8000a9a0 <_dtoa_r+0x980>
8000a958:	58 01       	cp.w	r1,0
8000a95a:	c1 11       	brne	8000a97c <_dtoa_r+0x95c>
8000a95c:	04 9b       	mov	r11,r2
8000a95e:	02 99       	mov	r9,r1
8000a960:	30 5a       	mov	r10,5
8000a962:	0e 9c       	mov	r12,r7
8000a964:	e0 a0 07 ec 	rcall	8000b93c <__multadd>
8000a968:	18 92       	mov	r2,r12
8000a96a:	18 9b       	mov	r11,r12
8000a96c:	06 9c       	mov	r12,r3
8000a96e:	e0 a0 05 f8 	rcall	8000b55e <__mcmp>
8000a972:	e0 89 00 0f 	brgt	8000a990 <_dtoa_r+0x970>
8000a976:	c0 38       	rjmp	8000a97c <_dtoa_r+0x95c>
8000a978:	30 02       	mov	r2,0
8000a97a:	04 94       	mov	r4,r2
8000a97c:	40 ea       	lddsp	r10,sp[0x38]
8000a97e:	30 09       	mov	r9,0
8000a980:	5c da       	com	r10
8000a982:	40 85       	lddsp	r5,sp[0x20]
8000a984:	50 6a       	stdsp	sp[0x18],r10
8000a986:	50 49       	stdsp	sp[0x10],r9
8000a988:	c0 f9       	rjmp	8000aba6 <_dtoa_r+0xb86>
8000a98a:	08 92       	mov	r2,r4
8000a98c:	40 66       	lddsp	r6,sp[0x18]
8000a98e:	04 94       	mov	r4,r2
8000a990:	2f f6       	sub	r6,-1
8000a992:	50 66       	stdsp	sp[0x18],r6
8000a994:	33 18       	mov	r8,49
8000a996:	40 85       	lddsp	r5,sp[0x20]
8000a998:	0a c8       	st.b	r5++,r8
8000a99a:	30 08       	mov	r8,0
8000a99c:	50 48       	stdsp	sp[0x10],r8
8000a99e:	c0 49       	rjmp	8000aba6 <_dtoa_r+0xb86>
8000a9a0:	40 dc       	lddsp	r12,sp[0x34]
8000a9a2:	58 0c       	cp.w	r12,0
8000a9a4:	e0 80 00 b5 	breq	8000ab0e <_dtoa_r+0xaee>
8000a9a8:	58 05       	cp.w	r5,0
8000a9aa:	e0 8a 00 08 	brle	8000a9ba <_dtoa_r+0x99a>
8000a9ae:	08 9b       	mov	r11,r4
8000a9b0:	0a 9a       	mov	r10,r5
8000a9b2:	0e 9c       	mov	r12,r7
8000a9b4:	e0 a0 06 f8 	rcall	8000b7a4 <__lshift>
8000a9b8:	18 94       	mov	r4,r12
8000a9ba:	40 6b       	lddsp	r11,sp[0x18]
8000a9bc:	58 0b       	cp.w	r11,0
8000a9be:	c0 31       	brne	8000a9c4 <_dtoa_r+0x9a4>
8000a9c0:	08 9c       	mov	r12,r4
8000a9c2:	c1 38       	rjmp	8000a9e8 <_dtoa_r+0x9c8>
8000a9c4:	68 1b       	ld.w	r11,r4[0x4]
8000a9c6:	0e 9c       	mov	r12,r7
8000a9c8:	e0 a0 05 fe 	rcall	8000b5c4 <_Balloc>
8000a9cc:	68 4a       	ld.w	r10,r4[0x10]
8000a9ce:	18 95       	mov	r5,r12
8000a9d0:	e8 cb ff f4 	sub	r11,r4,-12
8000a9d4:	2f ea       	sub	r10,-2
8000a9d6:	2f 4c       	sub	r12,-12
8000a9d8:	a3 6a       	lsl	r10,0x2
8000a9da:	fe b0 e6 4f 	rcall	80007678 <memcpy>
8000a9de:	0a 9b       	mov	r11,r5
8000a9e0:	30 1a       	mov	r10,1
8000a9e2:	0e 9c       	mov	r12,r7
8000a9e4:	e0 a0 06 e0 	rcall	8000b7a4 <__lshift>
8000a9e8:	50 44       	stdsp	sp[0x10],r4
8000a9ea:	40 3a       	lddsp	r10,sp[0xc]
8000a9ec:	30 19       	mov	r9,1
8000a9ee:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000a9f2:	18 94       	mov	r4,r12
8000a9f4:	50 da       	stdsp	sp[0x34],r10
8000a9f6:	40 85       	lddsp	r5,sp[0x20]
8000a9f8:	50 99       	stdsp	sp[0x24],r9
8000a9fa:	50 26       	stdsp	sp[0x8],r6
8000a9fc:	50 e1       	stdsp	sp[0x38],r1
8000a9fe:	04 9b       	mov	r11,r2
8000aa00:	06 9c       	mov	r12,r3
8000aa02:	fe b0 fa 7f 	rcall	80009f00 <quorem>
8000aa06:	40 4b       	lddsp	r11,sp[0x10]
8000aa08:	f8 c0 ff d0 	sub	r0,r12,-48
8000aa0c:	06 9c       	mov	r12,r3
8000aa0e:	e0 a0 05 a8 	rcall	8000b55e <__mcmp>
8000aa12:	08 9a       	mov	r10,r4
8000aa14:	50 6c       	stdsp	sp[0x18],r12
8000aa16:	04 9b       	mov	r11,r2
8000aa18:	0e 9c       	mov	r12,r7
8000aa1a:	e0 a0 06 5d 	rcall	8000b6d4 <__mdiff>
8000aa1e:	18 91       	mov	r1,r12
8000aa20:	78 38       	ld.w	r8,r12[0xc]
8000aa22:	58 08       	cp.w	r8,0
8000aa24:	c0 30       	breq	8000aa2a <_dtoa_r+0xa0a>
8000aa26:	30 16       	mov	r6,1
8000aa28:	c0 68       	rjmp	8000aa34 <_dtoa_r+0xa14>
8000aa2a:	18 9b       	mov	r11,r12
8000aa2c:	06 9c       	mov	r12,r3
8000aa2e:	e0 a0 05 98 	rcall	8000b55e <__mcmp>
8000aa32:	18 96       	mov	r6,r12
8000aa34:	0e 9c       	mov	r12,r7
8000aa36:	02 9b       	mov	r11,r1
8000aa38:	e0 a0 05 ac 	rcall	8000b590 <_Bfree>
8000aa3c:	40 cc       	lddsp	r12,sp[0x30]
8000aa3e:	ed ec 10 08 	or	r8,r6,r12
8000aa42:	c0 d1       	brne	8000aa5c <_dtoa_r+0xa3c>
8000aa44:	40 db       	lddsp	r11,sp[0x34]
8000aa46:	58 0b       	cp.w	r11,0
8000aa48:	c0 a1       	brne	8000aa5c <_dtoa_r+0xa3c>
8000aa4a:	40 26       	lddsp	r6,sp[0x8]
8000aa4c:	e0 40 00 39 	cp.w	r0,57
8000aa50:	c3 00       	breq	8000aab0 <_dtoa_r+0xa90>
8000aa52:	40 6a       	lddsp	r10,sp[0x18]
8000aa54:	58 0a       	cp.w	r10,0
8000aa56:	e0 89 00 24 	brgt	8000aa9e <_dtoa_r+0xa7e>
8000aa5a:	c2 f8       	rjmp	8000aab8 <_dtoa_r+0xa98>
8000aa5c:	40 69       	lddsp	r9,sp[0x18]
8000aa5e:	58 09       	cp.w	r9,0
8000aa60:	c0 85       	brlt	8000aa70 <_dtoa_r+0xa50>
8000aa62:	12 98       	mov	r8,r9
8000aa64:	40 cc       	lddsp	r12,sp[0x30]
8000aa66:	18 48       	or	r8,r12
8000aa68:	c1 d1       	brne	8000aaa2 <_dtoa_r+0xa82>
8000aa6a:	40 db       	lddsp	r11,sp[0x34]
8000aa6c:	58 0b       	cp.w	r11,0
8000aa6e:	c1 a1       	brne	8000aaa2 <_dtoa_r+0xa82>
8000aa70:	0c 99       	mov	r9,r6
8000aa72:	40 26       	lddsp	r6,sp[0x8]
8000aa74:	58 09       	cp.w	r9,0
8000aa76:	e0 8a 00 21 	brle	8000aab8 <_dtoa_r+0xa98>
8000aa7a:	06 9b       	mov	r11,r3
8000aa7c:	30 1a       	mov	r10,1
8000aa7e:	0e 9c       	mov	r12,r7
8000aa80:	e0 a0 06 92 	rcall	8000b7a4 <__lshift>
8000aa84:	04 9b       	mov	r11,r2
8000aa86:	18 93       	mov	r3,r12
8000aa88:	e0 a0 05 6b 	rcall	8000b55e <__mcmp>
8000aa8c:	e0 89 00 06 	brgt	8000aa98 <_dtoa_r+0xa78>
8000aa90:	c1 41       	brne	8000aab8 <_dtoa_r+0xa98>
8000aa92:	ed b0 00 00 	bld	r0,0x0
8000aa96:	c1 11       	brne	8000aab8 <_dtoa_r+0xa98>
8000aa98:	e0 40 00 39 	cp.w	r0,57
8000aa9c:	c0 a0       	breq	8000aab0 <_dtoa_r+0xa90>
8000aa9e:	2f f0       	sub	r0,-1
8000aaa0:	c0 c8       	rjmp	8000aab8 <_dtoa_r+0xa98>
8000aaa2:	58 06       	cp.w	r6,0
8000aaa4:	e0 8a 00 0c 	brle	8000aabc <_dtoa_r+0xa9c>
8000aaa8:	40 26       	lddsp	r6,sp[0x8]
8000aaaa:	e0 40 00 39 	cp.w	r0,57
8000aaae:	c0 41       	brne	8000aab6 <_dtoa_r+0xa96>
8000aab0:	33 98       	mov	r8,57
8000aab2:	0a c8       	st.b	r5++,r8
8000aab4:	c6 78       	rjmp	8000ab82 <_dtoa_r+0xb62>
8000aab6:	2f f0       	sub	r0,-1
8000aab8:	0a c0       	st.b	r5++,r0
8000aaba:	c7 58       	rjmp	8000aba4 <_dtoa_r+0xb84>
8000aabc:	0a c0       	st.b	r5++,r0
8000aabe:	40 9a       	lddsp	r10,sp[0x24]
8000aac0:	40 e9       	lddsp	r9,sp[0x38]
8000aac2:	12 3a       	cp.w	r10,r9
8000aac4:	c4 30       	breq	8000ab4a <_dtoa_r+0xb2a>
8000aac6:	06 9b       	mov	r11,r3
8000aac8:	30 09       	mov	r9,0
8000aaca:	30 aa       	mov	r10,10
8000aacc:	0e 9c       	mov	r12,r7
8000aace:	e0 a0 07 37 	rcall	8000b93c <__multadd>
8000aad2:	40 48       	lddsp	r8,sp[0x10]
8000aad4:	18 93       	mov	r3,r12
8000aad6:	08 38       	cp.w	r8,r4
8000aad8:	c0 91       	brne	8000aaea <_dtoa_r+0xaca>
8000aada:	10 9b       	mov	r11,r8
8000aadc:	30 09       	mov	r9,0
8000aade:	30 aa       	mov	r10,10
8000aae0:	0e 9c       	mov	r12,r7
8000aae2:	e0 a0 07 2d 	rcall	8000b93c <__multadd>
8000aae6:	50 4c       	stdsp	sp[0x10],r12
8000aae8:	c0 e8       	rjmp	8000ab04 <_dtoa_r+0xae4>
8000aaea:	40 4b       	lddsp	r11,sp[0x10]
8000aaec:	30 09       	mov	r9,0
8000aaee:	30 aa       	mov	r10,10
8000aaf0:	0e 9c       	mov	r12,r7
8000aaf2:	e0 a0 07 25 	rcall	8000b93c <__multadd>
8000aaf6:	08 9b       	mov	r11,r4
8000aaf8:	50 4c       	stdsp	sp[0x10],r12
8000aafa:	30 09       	mov	r9,0
8000aafc:	30 aa       	mov	r10,10
8000aafe:	0e 9c       	mov	r12,r7
8000ab00:	e0 a0 07 1e 	rcall	8000b93c <__multadd>
8000ab04:	18 94       	mov	r4,r12
8000ab06:	40 9c       	lddsp	r12,sp[0x24]
8000ab08:	2f fc       	sub	r12,-1
8000ab0a:	50 9c       	stdsp	sp[0x24],r12
8000ab0c:	c7 9b       	rjmp	8000a9fe <_dtoa_r+0x9de>
8000ab0e:	30 18       	mov	r8,1
8000ab10:	06 90       	mov	r0,r3
8000ab12:	40 85       	lddsp	r5,sp[0x20]
8000ab14:	08 93       	mov	r3,r4
8000ab16:	0c 94       	mov	r4,r6
8000ab18:	10 96       	mov	r6,r8
8000ab1a:	04 9b       	mov	r11,r2
8000ab1c:	00 9c       	mov	r12,r0
8000ab1e:	fe b0 f9 f1 	rcall	80009f00 <quorem>
8000ab22:	2d 0c       	sub	r12,-48
8000ab24:	0a cc       	st.b	r5++,r12
8000ab26:	02 36       	cp.w	r6,r1
8000ab28:	c0 a4       	brge	8000ab3c <_dtoa_r+0xb1c>
8000ab2a:	00 9b       	mov	r11,r0
8000ab2c:	30 09       	mov	r9,0
8000ab2e:	30 aa       	mov	r10,10
8000ab30:	0e 9c       	mov	r12,r7
8000ab32:	2f f6       	sub	r6,-1
8000ab34:	e0 a0 07 04 	rcall	8000b93c <__multadd>
8000ab38:	18 90       	mov	r0,r12
8000ab3a:	cf 0b       	rjmp	8000ab1a <_dtoa_r+0xafa>
8000ab3c:	08 96       	mov	r6,r4
8000ab3e:	30 0b       	mov	r11,0
8000ab40:	06 94       	mov	r4,r3
8000ab42:	50 4b       	stdsp	sp[0x10],r11
8000ab44:	00 93       	mov	r3,r0
8000ab46:	18 90       	mov	r0,r12
8000ab48:	c0 28       	rjmp	8000ab4c <_dtoa_r+0xb2c>
8000ab4a:	40 26       	lddsp	r6,sp[0x8]
8000ab4c:	06 9b       	mov	r11,r3
8000ab4e:	30 1a       	mov	r10,1
8000ab50:	0e 9c       	mov	r12,r7
8000ab52:	e0 a0 06 29 	rcall	8000b7a4 <__lshift>
8000ab56:	04 9b       	mov	r11,r2
8000ab58:	18 93       	mov	r3,r12
8000ab5a:	e0 a0 05 02 	rcall	8000b55e <__mcmp>
8000ab5e:	e0 89 00 12 	brgt	8000ab82 <_dtoa_r+0xb62>
8000ab62:	c1 b1       	brne	8000ab98 <_dtoa_r+0xb78>
8000ab64:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ab68:	c0 d1       	brne	8000ab82 <_dtoa_r+0xb62>
8000ab6a:	c1 78       	rjmp	8000ab98 <_dtoa_r+0xb78>
8000ab6c:	40 89       	lddsp	r9,sp[0x20]
8000ab6e:	12 38       	cp.w	r8,r9
8000ab70:	c0 30       	breq	8000ab76 <_dtoa_r+0xb56>
8000ab72:	10 95       	mov	r5,r8
8000ab74:	c0 88       	rjmp	8000ab84 <_dtoa_r+0xb64>
8000ab76:	2f f6       	sub	r6,-1
8000ab78:	50 66       	stdsp	sp[0x18],r6
8000ab7a:	33 18       	mov	r8,49
8000ab7c:	40 8c       	lddsp	r12,sp[0x20]
8000ab7e:	b8 88       	st.b	r12[0x0],r8
8000ab80:	c1 38       	rjmp	8000aba6 <_dtoa_r+0xb86>
8000ab82:	33 9a       	mov	r10,57
8000ab84:	0a 98       	mov	r8,r5
8000ab86:	11 79       	ld.ub	r9,--r8
8000ab88:	f4 09 18 00 	cp.b	r9,r10
8000ab8c:	cf 00       	breq	8000ab6c <_dtoa_r+0xb4c>
8000ab8e:	2f f9       	sub	r9,-1
8000ab90:	b0 89       	st.b	r8[0x0],r9
8000ab92:	c0 98       	rjmp	8000aba4 <_dtoa_r+0xb84>
8000ab94:	10 95       	mov	r5,r8
8000ab96:	c0 28       	rjmp	8000ab9a <_dtoa_r+0xb7a>
8000ab98:	33 09       	mov	r9,48
8000ab9a:	0a 98       	mov	r8,r5
8000ab9c:	11 7a       	ld.ub	r10,--r8
8000ab9e:	f2 0a 18 00 	cp.b	r10,r9
8000aba2:	cf 90       	breq	8000ab94 <_dtoa_r+0xb74>
8000aba4:	50 66       	stdsp	sp[0x18],r6
8000aba6:	04 9b       	mov	r11,r2
8000aba8:	0e 9c       	mov	r12,r7
8000abaa:	e0 a0 04 f3 	rcall	8000b590 <_Bfree>
8000abae:	58 04       	cp.w	r4,0
8000abb0:	c1 20       	breq	8000abd4 <_dtoa_r+0xbb4>
8000abb2:	40 4b       	lddsp	r11,sp[0x10]
8000abb4:	08 3b       	cp.w	r11,r4
8000abb6:	5f 19       	srne	r9
8000abb8:	58 0b       	cp.w	r11,0
8000abba:	5f 18       	srne	r8
8000abbc:	f3 e8 00 08 	and	r8,r9,r8
8000abc0:	c0 40       	breq	8000abc8 <_dtoa_r+0xba8>
8000abc2:	0e 9c       	mov	r12,r7
8000abc4:	e0 a0 04 e6 	rcall	8000b590 <_Bfree>
8000abc8:	08 9b       	mov	r11,r4
8000abca:	0e 9c       	mov	r12,r7
8000abcc:	e0 a0 04 e2 	rcall	8000b590 <_Bfree>
8000abd0:	c0 28       	rjmp	8000abd4 <_dtoa_r+0xbb4>
8000abd2:	50 66       	stdsp	sp[0x18],r6
8000abd4:	0e 9c       	mov	r12,r7
8000abd6:	06 9b       	mov	r11,r3
8000abd8:	e0 a0 04 dc 	rcall	8000b590 <_Bfree>
8000abdc:	30 08       	mov	r8,0
8000abde:	aa 88       	st.b	r5[0x0],r8
8000abe0:	40 68       	lddsp	r8,sp[0x18]
8000abe2:	41 5a       	lddsp	r10,sp[0x54]
8000abe4:	2f f8       	sub	r8,-1
8000abe6:	41 29       	lddsp	r9,sp[0x48]
8000abe8:	95 08       	st.w	r10[0x0],r8
8000abea:	40 8c       	lddsp	r12,sp[0x20]
8000abec:	58 09       	cp.w	r9,0
8000abee:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000abf2:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000abf6:	2e 6d       	sub	sp,-104
8000abf8:	d8 32       	popm	r0-r7,pc
8000abfa:	d7 03       	nop

8000abfc <__errno>:
8000abfc:	e0 68 0a 3c 	mov	r8,2620
8000ac00:	70 0c       	ld.w	r12,r8[0x0]
8000ac02:	2f 4c       	sub	r12,-12
8000ac04:	5e fc       	retal	r12
8000ac06:	d7 03       	nop

8000ac08 <_fflush_r>:
8000ac08:	d4 21       	pushm	r4-r7,lr
8000ac0a:	16 97       	mov	r7,r11
8000ac0c:	18 96       	mov	r6,r12
8000ac0e:	76 48       	ld.w	r8,r11[0x10]
8000ac10:	58 08       	cp.w	r8,0
8000ac12:	c7 f0       	breq	8000ad10 <_fflush_r+0x108>
8000ac14:	58 0c       	cp.w	r12,0
8000ac16:	c0 50       	breq	8000ac20 <_fflush_r+0x18>
8000ac18:	78 68       	ld.w	r8,r12[0x18]
8000ac1a:	58 08       	cp.w	r8,0
8000ac1c:	c0 21       	brne	8000ac20 <_fflush_r+0x18>
8000ac1e:	cc dc       	rcall	8000adb8 <__sinit>
8000ac20:	fe c8 cd 48 	sub	r8,pc,-12984
8000ac24:	10 37       	cp.w	r7,r8
8000ac26:	c0 31       	brne	8000ac2c <_fflush_r+0x24>
8000ac28:	6c 07       	ld.w	r7,r6[0x0]
8000ac2a:	c0 c8       	rjmp	8000ac42 <_fflush_r+0x3a>
8000ac2c:	fe c8 cd 34 	sub	r8,pc,-13004
8000ac30:	10 37       	cp.w	r7,r8
8000ac32:	c0 31       	brne	8000ac38 <_fflush_r+0x30>
8000ac34:	6c 17       	ld.w	r7,r6[0x4]
8000ac36:	c0 68       	rjmp	8000ac42 <_fflush_r+0x3a>
8000ac38:	fe c8 cd 20 	sub	r8,pc,-13024
8000ac3c:	10 37       	cp.w	r7,r8
8000ac3e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000ac42:	8e 6a       	ld.sh	r10,r7[0xc]
8000ac44:	14 98       	mov	r8,r10
8000ac46:	ed ba 00 03 	bld	r10,0x3
8000ac4a:	c4 20       	breq	8000acce <_fflush_r+0xc6>
8000ac4c:	ab ba       	sbr	r10,0xb
8000ac4e:	ae 6a       	st.h	r7[0xc],r10
8000ac50:	6e 18       	ld.w	r8,r7[0x4]
8000ac52:	58 08       	cp.w	r8,0
8000ac54:	e0 89 00 06 	brgt	8000ac60 <_fflush_r+0x58>
8000ac58:	6f 08       	ld.w	r8,r7[0x40]
8000ac5a:	58 08       	cp.w	r8,0
8000ac5c:	e0 8a 00 5a 	brle	8000ad10 <_fflush_r+0x108>
8000ac60:	6e b8       	ld.w	r8,r7[0x2c]
8000ac62:	58 08       	cp.w	r8,0
8000ac64:	c5 60       	breq	8000ad10 <_fflush_r+0x108>
8000ac66:	e2 1a 10 00 	andl	r10,0x1000,COH
8000ac6a:	c0 30       	breq	8000ac70 <_fflush_r+0x68>
8000ac6c:	6f 55       	ld.w	r5,r7[0x54]
8000ac6e:	c0 f8       	rjmp	8000ac8c <_fflush_r+0x84>
8000ac70:	30 19       	mov	r9,1
8000ac72:	6e 8b       	ld.w	r11,r7[0x20]
8000ac74:	0c 9c       	mov	r12,r6
8000ac76:	5d 18       	icall	r8
8000ac78:	18 95       	mov	r5,r12
8000ac7a:	5b fc       	cp.w	r12,-1
8000ac7c:	c0 81       	brne	8000ac8c <_fflush_r+0x84>
8000ac7e:	6c 38       	ld.w	r8,r6[0xc]
8000ac80:	59 d8       	cp.w	r8,29
8000ac82:	c4 70       	breq	8000ad10 <_fflush_r+0x108>
8000ac84:	8e 68       	ld.sh	r8,r7[0xc]
8000ac86:	a7 a8       	sbr	r8,0x6
8000ac88:	ae 68       	st.h	r7[0xc],r8
8000ac8a:	d8 22       	popm	r4-r7,pc
8000ac8c:	8e 68       	ld.sh	r8,r7[0xc]
8000ac8e:	ed b8 00 02 	bld	r8,0x2
8000ac92:	c0 91       	brne	8000aca4 <_fflush_r+0x9c>
8000ac94:	6e 18       	ld.w	r8,r7[0x4]
8000ac96:	10 15       	sub	r5,r8
8000ac98:	6e d8       	ld.w	r8,r7[0x34]
8000ac9a:	58 08       	cp.w	r8,0
8000ac9c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000aca0:	eb d8 e1 15 	subne	r5,r5,r8
8000aca4:	6e b8       	ld.w	r8,r7[0x2c]
8000aca6:	0c 9c       	mov	r12,r6
8000aca8:	30 09       	mov	r9,0
8000acaa:	0a 9a       	mov	r10,r5
8000acac:	6e 8b       	ld.w	r11,r7[0x20]
8000acae:	5d 18       	icall	r8
8000acb0:	8e 68       	ld.sh	r8,r7[0xc]
8000acb2:	0a 3c       	cp.w	r12,r5
8000acb4:	c2 61       	brne	8000ad00 <_fflush_r+0xf8>
8000acb6:	ab d8       	cbr	r8,0xb
8000acb8:	30 0c       	mov	r12,0
8000acba:	6e 49       	ld.w	r9,r7[0x10]
8000acbc:	ae 68       	st.h	r7[0xc],r8
8000acbe:	8f 1c       	st.w	r7[0x4],r12
8000acc0:	8f 09       	st.w	r7[0x0],r9
8000acc2:	ed b8 00 0c 	bld	r8,0xc
8000acc6:	c2 51       	brne	8000ad10 <_fflush_r+0x108>
8000acc8:	ef 45 00 54 	st.w	r7[84],r5
8000accc:	d8 22       	popm	r4-r7,pc
8000acce:	6e 45       	ld.w	r5,r7[0x10]
8000acd0:	58 05       	cp.w	r5,0
8000acd2:	c1 f0       	breq	8000ad10 <_fflush_r+0x108>
8000acd4:	6e 04       	ld.w	r4,r7[0x0]
8000acd6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000acda:	8f 05       	st.w	r7[0x0],r5
8000acdc:	f9 b8 01 00 	movne	r8,0
8000ace0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000ace4:	0a 14       	sub	r4,r5
8000ace6:	8f 28       	st.w	r7[0x8],r8
8000ace8:	c1 18       	rjmp	8000ad0a <_fflush_r+0x102>
8000acea:	08 99       	mov	r9,r4
8000acec:	0a 9a       	mov	r10,r5
8000acee:	6e a8       	ld.w	r8,r7[0x28]
8000acf0:	6e 8b       	ld.w	r11,r7[0x20]
8000acf2:	0c 9c       	mov	r12,r6
8000acf4:	5d 18       	icall	r8
8000acf6:	18 14       	sub	r4,r12
8000acf8:	58 0c       	cp.w	r12,0
8000acfa:	e0 89 00 07 	brgt	8000ad08 <_fflush_r+0x100>
8000acfe:	8e 68       	ld.sh	r8,r7[0xc]
8000ad00:	a7 a8       	sbr	r8,0x6
8000ad02:	3f fc       	mov	r12,-1
8000ad04:	ae 68       	st.h	r7[0xc],r8
8000ad06:	d8 22       	popm	r4-r7,pc
8000ad08:	18 05       	add	r5,r12
8000ad0a:	58 04       	cp.w	r4,0
8000ad0c:	fe 99 ff ef 	brgt	8000acea <_fflush_r+0xe2>
8000ad10:	d8 2a       	popm	r4-r7,pc,r12=0
8000ad12:	d7 03       	nop

8000ad14 <__sfp_lock_acquire>:
8000ad14:	5e fc       	retal	r12

8000ad16 <__sfp_lock_release>:
8000ad16:	5e fc       	retal	r12

8000ad18 <_cleanup_r>:
8000ad18:	d4 01       	pushm	lr
8000ad1a:	fe cb f0 ae 	sub	r11,pc,-3922
8000ad1e:	e0 a0 02 f7 	rcall	8000b30c <_fwalk>
8000ad22:	d8 02       	popm	pc

8000ad24 <__sfmoreglue>:
8000ad24:	d4 21       	pushm	r4-r7,lr
8000ad26:	16 95       	mov	r5,r11
8000ad28:	f6 06 10 5c 	mul	r6,r11,92
8000ad2c:	ec cb ff f4 	sub	r11,r6,-12
8000ad30:	fe b0 e2 88 	rcall	80007240 <_malloc_r>
8000ad34:	18 97       	mov	r7,r12
8000ad36:	c0 90       	breq	8000ad48 <__sfmoreglue+0x24>
8000ad38:	99 15       	st.w	r12[0x4],r5
8000ad3a:	30 0b       	mov	r11,0
8000ad3c:	2f 4c       	sub	r12,-12
8000ad3e:	0c 9a       	mov	r10,r6
8000ad40:	8f 2c       	st.w	r7[0x8],r12
8000ad42:	8f 0b       	st.w	r7[0x0],r11
8000ad44:	fe b0 e5 3e 	rcall	800077c0 <memset>
8000ad48:	0e 9c       	mov	r12,r7
8000ad4a:	d8 22       	popm	r4-r7,pc

8000ad4c <__sfp>:
8000ad4c:	d4 21       	pushm	r4-r7,lr
8000ad4e:	fe c8 ce 12 	sub	r8,pc,-12782
8000ad52:	18 96       	mov	r6,r12
8000ad54:	70 07       	ld.w	r7,r8[0x0]
8000ad56:	6e 68       	ld.w	r8,r7[0x18]
8000ad58:	58 08       	cp.w	r8,0
8000ad5a:	c0 31       	brne	8000ad60 <__sfp+0x14>
8000ad5c:	0e 9c       	mov	r12,r7
8000ad5e:	c2 dc       	rcall	8000adb8 <__sinit>
8000ad60:	ee c7 ff 28 	sub	r7,r7,-216
8000ad64:	30 05       	mov	r5,0
8000ad66:	6e 2c       	ld.w	r12,r7[0x8]
8000ad68:	6e 18       	ld.w	r8,r7[0x4]
8000ad6a:	c0 68       	rjmp	8000ad76 <__sfp+0x2a>
8000ad6c:	98 69       	ld.sh	r9,r12[0xc]
8000ad6e:	ea 09 19 00 	cp.h	r9,r5
8000ad72:	c1 10       	breq	8000ad94 <__sfp+0x48>
8000ad74:	2a 4c       	sub	r12,-92
8000ad76:	20 18       	sub	r8,1
8000ad78:	cf a7       	brpl	8000ad6c <__sfp+0x20>
8000ad7a:	6e 08       	ld.w	r8,r7[0x0]
8000ad7c:	58 08       	cp.w	r8,0
8000ad7e:	c0 61       	brne	8000ad8a <__sfp+0x3e>
8000ad80:	30 4b       	mov	r11,4
8000ad82:	0c 9c       	mov	r12,r6
8000ad84:	cd 0f       	rcall	8000ad24 <__sfmoreglue>
8000ad86:	8f 0c       	st.w	r7[0x0],r12
8000ad88:	c0 30       	breq	8000ad8e <__sfp+0x42>
8000ad8a:	6e 07       	ld.w	r7,r7[0x0]
8000ad8c:	ce db       	rjmp	8000ad66 <__sfp+0x1a>
8000ad8e:	30 c8       	mov	r8,12
8000ad90:	8d 38       	st.w	r6[0xc],r8
8000ad92:	d8 22       	popm	r4-r7,pc
8000ad94:	30 08       	mov	r8,0
8000ad96:	f9 48 00 4c 	st.w	r12[76],r8
8000ad9a:	99 08       	st.w	r12[0x0],r8
8000ad9c:	99 28       	st.w	r12[0x8],r8
8000ad9e:	99 18       	st.w	r12[0x4],r8
8000ada0:	99 48       	st.w	r12[0x10],r8
8000ada2:	99 58       	st.w	r12[0x14],r8
8000ada4:	99 68       	st.w	r12[0x18],r8
8000ada6:	99 d8       	st.w	r12[0x34],r8
8000ada8:	99 e8       	st.w	r12[0x38],r8
8000adaa:	f9 48 00 48 	st.w	r12[72],r8
8000adae:	3f f8       	mov	r8,-1
8000adb0:	b8 78       	st.h	r12[0xe],r8
8000adb2:	30 18       	mov	r8,1
8000adb4:	b8 68       	st.h	r12[0xc],r8
8000adb6:	d8 22       	popm	r4-r7,pc

8000adb8 <__sinit>:
8000adb8:	d4 21       	pushm	r4-r7,lr
8000adba:	18 96       	mov	r6,r12
8000adbc:	78 67       	ld.w	r7,r12[0x18]
8000adbe:	58 07       	cp.w	r7,0
8000adc0:	c4 91       	brne	8000ae52 <__sinit+0x9a>
8000adc2:	fe c8 00 aa 	sub	r8,pc,170
8000adc6:	30 15       	mov	r5,1
8000adc8:	99 a8       	st.w	r12[0x28],r8
8000adca:	f9 47 00 d8 	st.w	r12[216],r7
8000adce:	f9 47 00 dc 	st.w	r12[220],r7
8000add2:	f9 47 00 e0 	st.w	r12[224],r7
8000add6:	99 65       	st.w	r12[0x18],r5
8000add8:	cb af       	rcall	8000ad4c <__sfp>
8000adda:	8d 0c       	st.w	r6[0x0],r12
8000addc:	0c 9c       	mov	r12,r6
8000adde:	cb 7f       	rcall	8000ad4c <__sfp>
8000ade0:	8d 1c       	st.w	r6[0x4],r12
8000ade2:	0c 9c       	mov	r12,r6
8000ade4:	cb 4f       	rcall	8000ad4c <__sfp>
8000ade6:	6c 09       	ld.w	r9,r6[0x0]
8000ade8:	30 48       	mov	r8,4
8000adea:	93 07       	st.w	r9[0x0],r7
8000adec:	b2 68       	st.h	r9[0xc],r8
8000adee:	93 17       	st.w	r9[0x4],r7
8000adf0:	93 27       	st.w	r9[0x8],r7
8000adf2:	6c 18       	ld.w	r8,r6[0x4]
8000adf4:	b2 77       	st.h	r9[0xe],r7
8000adf6:	93 47       	st.w	r9[0x10],r7
8000adf8:	93 57       	st.w	r9[0x14],r7
8000adfa:	93 67       	st.w	r9[0x18],r7
8000adfc:	93 89       	st.w	r9[0x20],r9
8000adfe:	91 07       	st.w	r8[0x0],r7
8000ae00:	91 17       	st.w	r8[0x4],r7
8000ae02:	91 27       	st.w	r8[0x8],r7
8000ae04:	fe ce f3 24 	sub	lr,pc,-3292
8000ae08:	fe cb f3 54 	sub	r11,pc,-3244
8000ae0c:	93 9e       	st.w	r9[0x24],lr
8000ae0e:	93 ab       	st.w	r9[0x28],r11
8000ae10:	fe ca f3 7c 	sub	r10,pc,-3204
8000ae14:	fe c4 f3 88 	sub	r4,pc,-3192
8000ae18:	93 ba       	st.w	r9[0x2c],r10
8000ae1a:	93 c4       	st.w	r9[0x30],r4
8000ae1c:	30 99       	mov	r9,9
8000ae1e:	b0 69       	st.h	r8[0xc],r9
8000ae20:	b0 75       	st.h	r8[0xe],r5
8000ae22:	91 c4       	st.w	r8[0x30],r4
8000ae24:	91 47       	st.w	r8[0x10],r7
8000ae26:	91 57       	st.w	r8[0x14],r7
8000ae28:	91 67       	st.w	r8[0x18],r7
8000ae2a:	91 88       	st.w	r8[0x20],r8
8000ae2c:	91 9e       	st.w	r8[0x24],lr
8000ae2e:	91 ab       	st.w	r8[0x28],r11
8000ae30:	91 ba       	st.w	r8[0x2c],r10
8000ae32:	8d 2c       	st.w	r6[0x8],r12
8000ae34:	31 28       	mov	r8,18
8000ae36:	99 07       	st.w	r12[0x0],r7
8000ae38:	b8 68       	st.h	r12[0xc],r8
8000ae3a:	99 17       	st.w	r12[0x4],r7
8000ae3c:	99 27       	st.w	r12[0x8],r7
8000ae3e:	30 28       	mov	r8,2
8000ae40:	b8 78       	st.h	r12[0xe],r8
8000ae42:	99 c4       	st.w	r12[0x30],r4
8000ae44:	99 67       	st.w	r12[0x18],r7
8000ae46:	99 9e       	st.w	r12[0x24],lr
8000ae48:	99 ab       	st.w	r12[0x28],r11
8000ae4a:	99 ba       	st.w	r12[0x2c],r10
8000ae4c:	99 47       	st.w	r12[0x10],r7
8000ae4e:	99 57       	st.w	r12[0x14],r7
8000ae50:	99 8c       	st.w	r12[0x20],r12
8000ae52:	d8 22       	popm	r4-r7,pc

8000ae54 <_malloc_trim_r>:
8000ae54:	d4 21       	pushm	r4-r7,lr
8000ae56:	16 95       	mov	r5,r11
8000ae58:	18 97       	mov	r7,r12
8000ae5a:	fe b0 d7 d9 	rcall	80005e0c <__malloc_lock>
8000ae5e:	e0 64 05 3c 	mov	r4,1340
8000ae62:	68 28       	ld.w	r8,r4[0x8]
8000ae64:	70 16       	ld.w	r6,r8[0x4]
8000ae66:	e0 16 ff fc 	andl	r6,0xfffc
8000ae6a:	ec c8 ff 91 	sub	r8,r6,-111
8000ae6e:	f0 05 01 05 	sub	r5,r8,r5
8000ae72:	e0 15 ff 80 	andl	r5,0xff80
8000ae76:	ea c5 00 80 	sub	r5,r5,128
8000ae7a:	e0 45 00 7f 	cp.w	r5,127
8000ae7e:	e0 8a 00 25 	brle	8000aec8 <_malloc_trim_r+0x74>
8000ae82:	30 0b       	mov	r11,0
8000ae84:	0e 9c       	mov	r12,r7
8000ae86:	fe b0 e6 05 	rcall	80007a90 <_sbrk_r>
8000ae8a:	68 28       	ld.w	r8,r4[0x8]
8000ae8c:	0c 08       	add	r8,r6
8000ae8e:	10 3c       	cp.w	r12,r8
8000ae90:	c1 c1       	brne	8000aec8 <_malloc_trim_r+0x74>
8000ae92:	ea 0b 11 00 	rsub	r11,r5,0
8000ae96:	0e 9c       	mov	r12,r7
8000ae98:	fe b0 e5 fc 	rcall	80007a90 <_sbrk_r>
8000ae9c:	5b fc       	cp.w	r12,-1
8000ae9e:	c1 91       	brne	8000aed0 <_malloc_trim_r+0x7c>
8000aea0:	30 0b       	mov	r11,0
8000aea2:	0e 9c       	mov	r12,r7
8000aea4:	fe b0 e5 f6 	rcall	80007a90 <_sbrk_r>
8000aea8:	68 28       	ld.w	r8,r4[0x8]
8000aeaa:	f8 08 01 09 	sub	r9,r12,r8
8000aeae:	58 f9       	cp.w	r9,15
8000aeb0:	e0 8a 00 0c 	brle	8000aec8 <_malloc_trim_r+0x74>
8000aeb4:	a1 a9       	sbr	r9,0x0
8000aeb6:	91 19       	st.w	r8[0x4],r9
8000aeb8:	e0 68 09 48 	mov	r8,2376
8000aebc:	70 09       	ld.w	r9,r8[0x0]
8000aebe:	e0 68 0d 6c 	mov	r8,3436
8000aec2:	f8 09 01 09 	sub	r9,r12,r9
8000aec6:	91 09       	st.w	r8[0x0],r9
8000aec8:	0e 9c       	mov	r12,r7
8000aeca:	fe b0 d7 a7 	rcall	80005e18 <__malloc_unlock>
8000aece:	d8 2a       	popm	r4-r7,pc,r12=0
8000aed0:	68 28       	ld.w	r8,r4[0x8]
8000aed2:	0a 16       	sub	r6,r5
8000aed4:	a1 a6       	sbr	r6,0x0
8000aed6:	91 16       	st.w	r8[0x4],r6
8000aed8:	e0 68 0d 6c 	mov	r8,3436
8000aedc:	70 09       	ld.w	r9,r8[0x0]
8000aede:	0a 19       	sub	r9,r5
8000aee0:	0e 9c       	mov	r12,r7
8000aee2:	91 09       	st.w	r8[0x0],r9
8000aee4:	fe b0 d7 9a 	rcall	80005e18 <__malloc_unlock>
8000aee8:	da 2a       	popm	r4-r7,pc,r12=1
8000aeea:	d7 03       	nop

8000aeec <_free_r>:
8000aeec:	d4 21       	pushm	r4-r7,lr
8000aeee:	16 96       	mov	r6,r11
8000aef0:	18 97       	mov	r7,r12
8000aef2:	58 0b       	cp.w	r11,0
8000aef4:	e0 80 00 c0 	breq	8000b074 <_free_r+0x188>
8000aef8:	fe b0 d7 8a 	rcall	80005e0c <__malloc_lock>
8000aefc:	20 86       	sub	r6,8
8000aefe:	e0 6a 05 3c 	mov	r10,1340
8000af02:	6c 18       	ld.w	r8,r6[0x4]
8000af04:	74 2e       	ld.w	lr,r10[0x8]
8000af06:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000af0a:	a1 c8       	cbr	r8,0x0
8000af0c:	ec 08 00 09 	add	r9,r6,r8
8000af10:	72 1b       	ld.w	r11,r9[0x4]
8000af12:	e0 1b ff fc 	andl	r11,0xfffc
8000af16:	1c 39       	cp.w	r9,lr
8000af18:	c1 e1       	brne	8000af54 <_free_r+0x68>
8000af1a:	f6 08 00 08 	add	r8,r11,r8
8000af1e:	58 0c       	cp.w	r12,0
8000af20:	c0 81       	brne	8000af30 <_free_r+0x44>
8000af22:	6c 09       	ld.w	r9,r6[0x0]
8000af24:	12 16       	sub	r6,r9
8000af26:	12 08       	add	r8,r9
8000af28:	6c 3b       	ld.w	r11,r6[0xc]
8000af2a:	6c 29       	ld.w	r9,r6[0x8]
8000af2c:	97 29       	st.w	r11[0x8],r9
8000af2e:	93 3b       	st.w	r9[0xc],r11
8000af30:	10 99       	mov	r9,r8
8000af32:	95 26       	st.w	r10[0x8],r6
8000af34:	a1 a9       	sbr	r9,0x0
8000af36:	8d 19       	st.w	r6[0x4],r9
8000af38:	e0 69 09 44 	mov	r9,2372
8000af3c:	72 09       	ld.w	r9,r9[0x0]
8000af3e:	12 38       	cp.w	r8,r9
8000af40:	c0 63       	brcs	8000af4c <_free_r+0x60>
8000af42:	e0 68 0d 68 	mov	r8,3432
8000af46:	0e 9c       	mov	r12,r7
8000af48:	70 0b       	ld.w	r11,r8[0x0]
8000af4a:	c8 5f       	rcall	8000ae54 <_malloc_trim_r>
8000af4c:	0e 9c       	mov	r12,r7
8000af4e:	fe b0 d7 65 	rcall	80005e18 <__malloc_unlock>
8000af52:	d8 22       	popm	r4-r7,pc
8000af54:	93 1b       	st.w	r9[0x4],r11
8000af56:	58 0c       	cp.w	r12,0
8000af58:	c0 30       	breq	8000af5e <_free_r+0x72>
8000af5a:	30 0c       	mov	r12,0
8000af5c:	c1 08       	rjmp	8000af7c <_free_r+0x90>
8000af5e:	6c 0e       	ld.w	lr,r6[0x0]
8000af60:	f4 c5 ff f8 	sub	r5,r10,-8
8000af64:	1c 16       	sub	r6,lr
8000af66:	1c 08       	add	r8,lr
8000af68:	6c 2e       	ld.w	lr,r6[0x8]
8000af6a:	0a 3e       	cp.w	lr,r5
8000af6c:	f9 bc 00 01 	moveq	r12,1
8000af70:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000af74:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000af78:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000af7c:	f2 0b 00 0e 	add	lr,r9,r11
8000af80:	7c 1e       	ld.w	lr,lr[0x4]
8000af82:	ed be 00 00 	bld	lr,0x0
8000af86:	c1 40       	breq	8000afae <_free_r+0xc2>
8000af88:	16 08       	add	r8,r11
8000af8a:	58 0c       	cp.w	r12,0
8000af8c:	c0 d1       	brne	8000afa6 <_free_r+0xba>
8000af8e:	e0 6e 05 3c 	mov	lr,1340
8000af92:	72 2b       	ld.w	r11,r9[0x8]
8000af94:	2f 8e       	sub	lr,-8
8000af96:	1c 3b       	cp.w	r11,lr
8000af98:	c0 71       	brne	8000afa6 <_free_r+0xba>
8000af9a:	97 36       	st.w	r11[0xc],r6
8000af9c:	97 26       	st.w	r11[0x8],r6
8000af9e:	8d 2b       	st.w	r6[0x8],r11
8000afa0:	8d 3b       	st.w	r6[0xc],r11
8000afa2:	30 1c       	mov	r12,1
8000afa4:	c0 58       	rjmp	8000afae <_free_r+0xc2>
8000afa6:	72 2b       	ld.w	r11,r9[0x8]
8000afa8:	72 39       	ld.w	r9,r9[0xc]
8000afaa:	93 2b       	st.w	r9[0x8],r11
8000afac:	97 39       	st.w	r11[0xc],r9
8000afae:	10 99       	mov	r9,r8
8000afb0:	ec 08 09 08 	st.w	r6[r8],r8
8000afb4:	a1 a9       	sbr	r9,0x0
8000afb6:	8d 19       	st.w	r6[0x4],r9
8000afb8:	58 0c       	cp.w	r12,0
8000afba:	c5 a1       	brne	8000b06e <_free_r+0x182>
8000afbc:	e0 48 01 ff 	cp.w	r8,511
8000afc0:	e0 8b 00 13 	brhi	8000afe6 <_free_r+0xfa>
8000afc4:	a3 98       	lsr	r8,0x3
8000afc6:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000afca:	72 2b       	ld.w	r11,r9[0x8]
8000afcc:	8d 39       	st.w	r6[0xc],r9
8000afce:	8d 2b       	st.w	r6[0x8],r11
8000afd0:	97 36       	st.w	r11[0xc],r6
8000afd2:	93 26       	st.w	r9[0x8],r6
8000afd4:	a3 48       	asr	r8,0x2
8000afd6:	74 19       	ld.w	r9,r10[0x4]
8000afd8:	30 1b       	mov	r11,1
8000afda:	f6 08 09 48 	lsl	r8,r11,r8
8000afde:	f3 e8 10 08 	or	r8,r9,r8
8000afe2:	95 18       	st.w	r10[0x4],r8
8000afe4:	c4 58       	rjmp	8000b06e <_free_r+0x182>
8000afe6:	f0 0b 16 09 	lsr	r11,r8,0x9
8000afea:	58 4b       	cp.w	r11,4
8000afec:	e0 8b 00 06 	brhi	8000aff8 <_free_r+0x10c>
8000aff0:	f0 0b 16 06 	lsr	r11,r8,0x6
8000aff4:	2c 8b       	sub	r11,-56
8000aff6:	c2 08       	rjmp	8000b036 <_free_r+0x14a>
8000aff8:	59 4b       	cp.w	r11,20
8000affa:	e0 8b 00 04 	brhi	8000b002 <_free_r+0x116>
8000affe:	2a 5b       	sub	r11,-91
8000b000:	c1 b8       	rjmp	8000b036 <_free_r+0x14a>
8000b002:	e0 4b 00 54 	cp.w	r11,84
8000b006:	e0 8b 00 06 	brhi	8000b012 <_free_r+0x126>
8000b00a:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b00e:	29 2b       	sub	r11,-110
8000b010:	c1 38       	rjmp	8000b036 <_free_r+0x14a>
8000b012:	e0 4b 01 54 	cp.w	r11,340
8000b016:	e0 8b 00 06 	brhi	8000b022 <_free_r+0x136>
8000b01a:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b01e:	28 9b       	sub	r11,-119
8000b020:	c0 b8       	rjmp	8000b036 <_free_r+0x14a>
8000b022:	e0 4b 05 54 	cp.w	r11,1364
8000b026:	e0 88 00 05 	brls	8000b030 <_free_r+0x144>
8000b02a:	37 eb       	mov	r11,126
8000b02c:	c0 58       	rjmp	8000b036 <_free_r+0x14a>
8000b02e:	d7 03       	nop
8000b030:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b034:	28 4b       	sub	r11,-124
8000b036:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b03a:	78 29       	ld.w	r9,r12[0x8]
8000b03c:	18 39       	cp.w	r9,r12
8000b03e:	c0 e1       	brne	8000b05a <_free_r+0x16e>
8000b040:	74 18       	ld.w	r8,r10[0x4]
8000b042:	a3 4b       	asr	r11,0x2
8000b044:	30 1c       	mov	r12,1
8000b046:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b04a:	f1 eb 10 0b 	or	r11,r8,r11
8000b04e:	12 98       	mov	r8,r9
8000b050:	95 1b       	st.w	r10[0x4],r11
8000b052:	c0 a8       	rjmp	8000b066 <_free_r+0x17a>
8000b054:	72 29       	ld.w	r9,r9[0x8]
8000b056:	18 39       	cp.w	r9,r12
8000b058:	c0 60       	breq	8000b064 <_free_r+0x178>
8000b05a:	72 1a       	ld.w	r10,r9[0x4]
8000b05c:	e0 1a ff fc 	andl	r10,0xfffc
8000b060:	14 38       	cp.w	r8,r10
8000b062:	cf 93       	brcs	8000b054 <_free_r+0x168>
8000b064:	72 38       	ld.w	r8,r9[0xc]
8000b066:	8d 38       	st.w	r6[0xc],r8
8000b068:	8d 29       	st.w	r6[0x8],r9
8000b06a:	93 36       	st.w	r9[0xc],r6
8000b06c:	91 26       	st.w	r8[0x8],r6
8000b06e:	0e 9c       	mov	r12,r7
8000b070:	fe b0 d6 d4 	rcall	80005e18 <__malloc_unlock>
8000b074:	d8 22       	popm	r4-r7,pc
8000b076:	d7 03       	nop

8000b078 <__sfvwrite_r>:
8000b078:	d4 31       	pushm	r0-r7,lr
8000b07a:	20 3d       	sub	sp,12
8000b07c:	14 94       	mov	r4,r10
8000b07e:	18 95       	mov	r5,r12
8000b080:	16 97       	mov	r7,r11
8000b082:	74 28       	ld.w	r8,r10[0x8]
8000b084:	58 08       	cp.w	r8,0
8000b086:	e0 80 01 40 	breq	8000b306 <__sfvwrite_r+0x28e>
8000b08a:	96 68       	ld.sh	r8,r11[0xc]
8000b08c:	ed b8 00 03 	bld	r8,0x3
8000b090:	c0 41       	brne	8000b098 <__sfvwrite_r+0x20>
8000b092:	76 48       	ld.w	r8,r11[0x10]
8000b094:	58 08       	cp.w	r8,0
8000b096:	c0 c1       	brne	8000b0ae <__sfvwrite_r+0x36>
8000b098:	0e 9b       	mov	r11,r7
8000b09a:	0a 9c       	mov	r12,r5
8000b09c:	fe b0 f6 c4 	rcall	80009e24 <__swsetup_r>
8000b0a0:	c0 70       	breq	8000b0ae <__sfvwrite_r+0x36>
8000b0a2:	8e 68       	ld.sh	r8,r7[0xc]
8000b0a4:	a7 a8       	sbr	r8,0x6
8000b0a6:	ae 68       	st.h	r7[0xc],r8
8000b0a8:	30 98       	mov	r8,9
8000b0aa:	8b 38       	st.w	r5[0xc],r8
8000b0ac:	c2 b9       	rjmp	8000b302 <__sfvwrite_r+0x28a>
8000b0ae:	8e 63       	ld.sh	r3,r7[0xc]
8000b0b0:	68 00       	ld.w	r0,r4[0x0]
8000b0b2:	06 96       	mov	r6,r3
8000b0b4:	e2 16 00 02 	andl	r6,0x2,COH
8000b0b8:	c2 10       	breq	8000b0fa <__sfvwrite_r+0x82>
8000b0ba:	30 03       	mov	r3,0
8000b0bc:	e0 62 04 00 	mov	r2,1024
8000b0c0:	06 96       	mov	r6,r3
8000b0c2:	c0 48       	rjmp	8000b0ca <__sfvwrite_r+0x52>
8000b0c4:	60 03       	ld.w	r3,r0[0x0]
8000b0c6:	60 16       	ld.w	r6,r0[0x4]
8000b0c8:	2f 80       	sub	r0,-8
8000b0ca:	58 06       	cp.w	r6,0
8000b0cc:	cf c0       	breq	8000b0c4 <__sfvwrite_r+0x4c>
8000b0ce:	e0 46 04 00 	cp.w	r6,1024
8000b0d2:	ec 09 17 80 	movls	r9,r6
8000b0d6:	e4 09 17 b0 	movhi	r9,r2
8000b0da:	06 9a       	mov	r10,r3
8000b0dc:	6e a8       	ld.w	r8,r7[0x28]
8000b0de:	6e 8b       	ld.w	r11,r7[0x20]
8000b0e0:	0a 9c       	mov	r12,r5
8000b0e2:	5d 18       	icall	r8
8000b0e4:	18 16       	sub	r6,r12
8000b0e6:	58 0c       	cp.w	r12,0
8000b0e8:	e0 8a 01 0a 	brle	8000b2fc <__sfvwrite_r+0x284>
8000b0ec:	68 28       	ld.w	r8,r4[0x8]
8000b0ee:	18 18       	sub	r8,r12
8000b0f0:	89 28       	st.w	r4[0x8],r8
8000b0f2:	e0 80 01 0a 	breq	8000b306 <__sfvwrite_r+0x28e>
8000b0f6:	18 03       	add	r3,r12
8000b0f8:	ce 9b       	rjmp	8000b0ca <__sfvwrite_r+0x52>
8000b0fa:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b0fe:	c0 70       	breq	8000b10c <__sfvwrite_r+0x94>
8000b100:	50 06       	stdsp	sp[0x0],r6
8000b102:	0c 93       	mov	r3,r6
8000b104:	0c 91       	mov	r1,r6
8000b106:	50 15       	stdsp	sp[0x4],r5
8000b108:	08 92       	mov	r2,r4
8000b10a:	c9 c8       	rjmp	8000b242 <__sfvwrite_r+0x1ca>
8000b10c:	06 96       	mov	r6,r3
8000b10e:	08 91       	mov	r1,r4
8000b110:	c0 48       	rjmp	8000b118 <__sfvwrite_r+0xa0>
8000b112:	60 03       	ld.w	r3,r0[0x0]
8000b114:	60 16       	ld.w	r6,r0[0x4]
8000b116:	2f 80       	sub	r0,-8
8000b118:	58 06       	cp.w	r6,0
8000b11a:	cf c0       	breq	8000b112 <__sfvwrite_r+0x9a>
8000b11c:	8e 68       	ld.sh	r8,r7[0xc]
8000b11e:	6e 24       	ld.w	r4,r7[0x8]
8000b120:	10 99       	mov	r9,r8
8000b122:	e2 19 02 00 	andl	r9,0x200,COH
8000b126:	c5 50       	breq	8000b1d0 <__sfvwrite_r+0x158>
8000b128:	08 36       	cp.w	r6,r4
8000b12a:	c4 43       	brcs	8000b1b2 <__sfvwrite_r+0x13a>
8000b12c:	10 99       	mov	r9,r8
8000b12e:	e2 19 04 80 	andl	r9,0x480,COH
8000b132:	c4 00       	breq	8000b1b2 <__sfvwrite_r+0x13a>
8000b134:	6e 4b       	ld.w	r11,r7[0x10]
8000b136:	6e 09       	ld.w	r9,r7[0x0]
8000b138:	16 19       	sub	r9,r11
8000b13a:	50 09       	stdsp	sp[0x0],r9
8000b13c:	6e 59       	ld.w	r9,r7[0x14]
8000b13e:	10 9c       	mov	r12,r8
8000b140:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b144:	30 28       	mov	r8,2
8000b146:	f4 08 0c 08 	divs	r8,r10,r8
8000b14a:	fa e9 00 04 	st.d	sp[4],r8
8000b14e:	10 94       	mov	r4,r8
8000b150:	40 09       	lddsp	r9,sp[0x0]
8000b152:	e2 1c 04 00 	andl	r12,0x400,COH
8000b156:	2f f9       	sub	r9,-1
8000b158:	0c 09       	add	r9,r6
8000b15a:	12 38       	cp.w	r8,r9
8000b15c:	f2 04 17 30 	movlo	r4,r9
8000b160:	58 0c       	cp.w	r12,0
8000b162:	c1 10       	breq	8000b184 <__sfvwrite_r+0x10c>
8000b164:	08 9b       	mov	r11,r4
8000b166:	0a 9c       	mov	r12,r5
8000b168:	fe b0 e0 6c 	rcall	80007240 <_malloc_r>
8000b16c:	18 92       	mov	r2,r12
8000b16e:	c1 40       	breq	8000b196 <__sfvwrite_r+0x11e>
8000b170:	40 0a       	lddsp	r10,sp[0x0]
8000b172:	6e 4b       	ld.w	r11,r7[0x10]
8000b174:	fe b0 e2 82 	rcall	80007678 <memcpy>
8000b178:	8e 68       	ld.sh	r8,r7[0xc]
8000b17a:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b17e:	a7 b8       	sbr	r8,0x7
8000b180:	ae 68       	st.h	r7[0xc],r8
8000b182:	c0 d8       	rjmp	8000b19c <__sfvwrite_r+0x124>
8000b184:	08 9a       	mov	r10,r4
8000b186:	0a 9c       	mov	r12,r5
8000b188:	fe b0 e3 24 	rcall	800077d0 <_realloc_r>
8000b18c:	18 92       	mov	r2,r12
8000b18e:	c0 71       	brne	8000b19c <__sfvwrite_r+0x124>
8000b190:	6e 4b       	ld.w	r11,r7[0x10]
8000b192:	0a 9c       	mov	r12,r5
8000b194:	ca ce       	rcall	8000aeec <_free_r>
8000b196:	30 c8       	mov	r8,12
8000b198:	8b 38       	st.w	r5[0xc],r8
8000b19a:	cb 18       	rjmp	8000b2fc <__sfvwrite_r+0x284>
8000b19c:	40 0a       	lddsp	r10,sp[0x0]
8000b19e:	40 09       	lddsp	r9,sp[0x0]
8000b1a0:	e8 0a 01 0a 	sub	r10,r4,r10
8000b1a4:	e4 09 00 08 	add	r8,r2,r9
8000b1a8:	8f 54       	st.w	r7[0x14],r4
8000b1aa:	8f 2a       	st.w	r7[0x8],r10
8000b1ac:	8f 08       	st.w	r7[0x0],r8
8000b1ae:	8f 42       	st.w	r7[0x10],r2
8000b1b0:	0c 94       	mov	r4,r6
8000b1b2:	08 36       	cp.w	r6,r4
8000b1b4:	ec 04 17 30 	movlo	r4,r6
8000b1b8:	06 9b       	mov	r11,r3
8000b1ba:	08 9a       	mov	r10,r4
8000b1bc:	6e 0c       	ld.w	r12,r7[0x0]
8000b1be:	c3 ad       	rcall	8000b432 <memmove>
8000b1c0:	6e 08       	ld.w	r8,r7[0x0]
8000b1c2:	08 08       	add	r8,r4
8000b1c4:	8f 08       	st.w	r7[0x0],r8
8000b1c6:	6e 28       	ld.w	r8,r7[0x8]
8000b1c8:	08 18       	sub	r8,r4
8000b1ca:	0c 94       	mov	r4,r6
8000b1cc:	8f 28       	st.w	r7[0x8],r8
8000b1ce:	c2 e8       	rjmp	8000b22a <__sfvwrite_r+0x1b2>
8000b1d0:	08 36       	cp.w	r6,r4
8000b1d2:	5f ba       	srhi	r10
8000b1d4:	6e 0c       	ld.w	r12,r7[0x0]
8000b1d6:	6e 48       	ld.w	r8,r7[0x10]
8000b1d8:	10 3c       	cp.w	r12,r8
8000b1da:	5f b8       	srhi	r8
8000b1dc:	f5 e8 00 08 	and	r8,r10,r8
8000b1e0:	f2 08 18 00 	cp.b	r8,r9
8000b1e4:	c0 d0       	breq	8000b1fe <__sfvwrite_r+0x186>
8000b1e6:	06 9b       	mov	r11,r3
8000b1e8:	08 9a       	mov	r10,r4
8000b1ea:	c2 4d       	rcall	8000b432 <memmove>
8000b1ec:	6e 08       	ld.w	r8,r7[0x0]
8000b1ee:	08 08       	add	r8,r4
8000b1f0:	0e 9b       	mov	r11,r7
8000b1f2:	8f 08       	st.w	r7[0x0],r8
8000b1f4:	0a 9c       	mov	r12,r5
8000b1f6:	fe b0 fd 09 	rcall	8000ac08 <_fflush_r>
8000b1fa:	c1 80       	breq	8000b22a <__sfvwrite_r+0x1b2>
8000b1fc:	c8 08       	rjmp	8000b2fc <__sfvwrite_r+0x284>
8000b1fe:	6e 59       	ld.w	r9,r7[0x14]
8000b200:	12 36       	cp.w	r6,r9
8000b202:	c0 a3       	brcs	8000b216 <__sfvwrite_r+0x19e>
8000b204:	6e a8       	ld.w	r8,r7[0x28]
8000b206:	06 9a       	mov	r10,r3
8000b208:	6e 8b       	ld.w	r11,r7[0x20]
8000b20a:	0a 9c       	mov	r12,r5
8000b20c:	5d 18       	icall	r8
8000b20e:	18 94       	mov	r4,r12
8000b210:	e0 89 00 0d 	brgt	8000b22a <__sfvwrite_r+0x1b2>
8000b214:	c7 48       	rjmp	8000b2fc <__sfvwrite_r+0x284>
8000b216:	0c 9a       	mov	r10,r6
8000b218:	06 9b       	mov	r11,r3
8000b21a:	c0 cd       	rcall	8000b432 <memmove>
8000b21c:	6e 08       	ld.w	r8,r7[0x0]
8000b21e:	0c 08       	add	r8,r6
8000b220:	0c 94       	mov	r4,r6
8000b222:	8f 08       	st.w	r7[0x0],r8
8000b224:	6e 28       	ld.w	r8,r7[0x8]
8000b226:	0c 18       	sub	r8,r6
8000b228:	8f 28       	st.w	r7[0x8],r8
8000b22a:	62 28       	ld.w	r8,r1[0x8]
8000b22c:	08 18       	sub	r8,r4
8000b22e:	83 28       	st.w	r1[0x8],r8
8000b230:	c6 b0       	breq	8000b306 <__sfvwrite_r+0x28e>
8000b232:	08 16       	sub	r6,r4
8000b234:	08 03       	add	r3,r4
8000b236:	c7 1b       	rjmp	8000b118 <__sfvwrite_r+0xa0>
8000b238:	60 03       	ld.w	r3,r0[0x0]
8000b23a:	60 11       	ld.w	r1,r0[0x4]
8000b23c:	30 08       	mov	r8,0
8000b23e:	2f 80       	sub	r0,-8
8000b240:	50 08       	stdsp	sp[0x0],r8
8000b242:	58 01       	cp.w	r1,0
8000b244:	cf a0       	breq	8000b238 <__sfvwrite_r+0x1c0>
8000b246:	40 0a       	lddsp	r10,sp[0x0]
8000b248:	58 0a       	cp.w	r10,0
8000b24a:	c1 41       	brne	8000b272 <__sfvwrite_r+0x1fa>
8000b24c:	e2 c6 ff ff 	sub	r6,r1,-1
8000b250:	02 9a       	mov	r10,r1
8000b252:	30 ab       	mov	r11,10
8000b254:	06 9c       	mov	r12,r3
8000b256:	ce 3c       	rcall	8000b41c <memchr>
8000b258:	f8 c8 ff ff 	sub	r8,r12,-1
8000b25c:	58 0c       	cp.w	r12,0
8000b25e:	f1 d3 e1 16 	subne	r6,r8,r3
8000b262:	f9 b9 01 01 	movne	r9,1
8000b266:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b26a:	f9 b8 00 01 	moveq	r8,1
8000b26e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b272:	02 36       	cp.w	r6,r1
8000b274:	ec 04 17 80 	movls	r4,r6
8000b278:	e2 04 17 b0 	movhi	r4,r1
8000b27c:	6e 59       	ld.w	r9,r7[0x14]
8000b27e:	6e 25       	ld.w	r5,r7[0x8]
8000b280:	f2 05 00 05 	add	r5,r9,r5
8000b284:	0a 34       	cp.w	r4,r5
8000b286:	5f 9a       	srgt	r10
8000b288:	6e 0c       	ld.w	r12,r7[0x0]
8000b28a:	6e 48       	ld.w	r8,r7[0x10]
8000b28c:	10 3c       	cp.w	r12,r8
8000b28e:	5f b8       	srhi	r8
8000b290:	f5 e8 00 08 	and	r8,r10,r8
8000b294:	30 0a       	mov	r10,0
8000b296:	f4 08 18 00 	cp.b	r8,r10
8000b29a:	c0 d0       	breq	8000b2b4 <__sfvwrite_r+0x23c>
8000b29c:	06 9b       	mov	r11,r3
8000b29e:	0a 9a       	mov	r10,r5
8000b2a0:	cc 9c       	rcall	8000b432 <memmove>
8000b2a2:	6e 08       	ld.w	r8,r7[0x0]
8000b2a4:	0a 08       	add	r8,r5
8000b2a6:	0e 9b       	mov	r11,r7
8000b2a8:	8f 08       	st.w	r7[0x0],r8
8000b2aa:	40 1c       	lddsp	r12,sp[0x4]
8000b2ac:	fe b0 fc ae 	rcall	8000ac08 <_fflush_r>
8000b2b0:	c1 70       	breq	8000b2de <__sfvwrite_r+0x266>
8000b2b2:	c2 58       	rjmp	8000b2fc <__sfvwrite_r+0x284>
8000b2b4:	12 34       	cp.w	r4,r9
8000b2b6:	c0 a5       	brlt	8000b2ca <__sfvwrite_r+0x252>
8000b2b8:	6e a8       	ld.w	r8,r7[0x28]
8000b2ba:	06 9a       	mov	r10,r3
8000b2bc:	6e 8b       	ld.w	r11,r7[0x20]
8000b2be:	40 1c       	lddsp	r12,sp[0x4]
8000b2c0:	5d 18       	icall	r8
8000b2c2:	18 95       	mov	r5,r12
8000b2c4:	e0 89 00 0d 	brgt	8000b2de <__sfvwrite_r+0x266>
8000b2c8:	c1 a8       	rjmp	8000b2fc <__sfvwrite_r+0x284>
8000b2ca:	08 9a       	mov	r10,r4
8000b2cc:	06 9b       	mov	r11,r3
8000b2ce:	cb 2c       	rcall	8000b432 <memmove>
8000b2d0:	6e 08       	ld.w	r8,r7[0x0]
8000b2d2:	08 08       	add	r8,r4
8000b2d4:	08 95       	mov	r5,r4
8000b2d6:	8f 08       	st.w	r7[0x0],r8
8000b2d8:	6e 28       	ld.w	r8,r7[0x8]
8000b2da:	08 18       	sub	r8,r4
8000b2dc:	8f 28       	st.w	r7[0x8],r8
8000b2de:	0a 16       	sub	r6,r5
8000b2e0:	c0 71       	brne	8000b2ee <__sfvwrite_r+0x276>
8000b2e2:	0e 9b       	mov	r11,r7
8000b2e4:	40 1c       	lddsp	r12,sp[0x4]
8000b2e6:	fe b0 fc 91 	rcall	8000ac08 <_fflush_r>
8000b2ea:	c0 91       	brne	8000b2fc <__sfvwrite_r+0x284>
8000b2ec:	50 06       	stdsp	sp[0x0],r6
8000b2ee:	64 28       	ld.w	r8,r2[0x8]
8000b2f0:	0a 18       	sub	r8,r5
8000b2f2:	85 28       	st.w	r2[0x8],r8
8000b2f4:	c0 90       	breq	8000b306 <__sfvwrite_r+0x28e>
8000b2f6:	0a 11       	sub	r1,r5
8000b2f8:	0a 03       	add	r3,r5
8000b2fa:	ca 4b       	rjmp	8000b242 <__sfvwrite_r+0x1ca>
8000b2fc:	8e 68       	ld.sh	r8,r7[0xc]
8000b2fe:	a7 a8       	sbr	r8,0x6
8000b300:	ae 68       	st.h	r7[0xc],r8
8000b302:	3f fc       	mov	r12,-1
8000b304:	c0 28       	rjmp	8000b308 <__sfvwrite_r+0x290>
8000b306:	30 0c       	mov	r12,0
8000b308:	2f dd       	sub	sp,-12
8000b30a:	d8 32       	popm	r0-r7,pc

8000b30c <_fwalk>:
8000b30c:	d4 31       	pushm	r0-r7,lr
8000b30e:	30 05       	mov	r5,0
8000b310:	16 91       	mov	r1,r11
8000b312:	f8 c7 ff 28 	sub	r7,r12,-216
8000b316:	0a 92       	mov	r2,r5
8000b318:	fe b0 fc fe 	rcall	8000ad14 <__sfp_lock_acquire>
8000b31c:	3f f3       	mov	r3,-1
8000b31e:	c1 68       	rjmp	8000b34a <_fwalk+0x3e>
8000b320:	6e 26       	ld.w	r6,r7[0x8]
8000b322:	6e 14       	ld.w	r4,r7[0x4]
8000b324:	2f 46       	sub	r6,-12
8000b326:	c0 c8       	rjmp	8000b33e <_fwalk+0x32>
8000b328:	8c 08       	ld.sh	r8,r6[0x0]
8000b32a:	e4 08 19 00 	cp.h	r8,r2
8000b32e:	c0 70       	breq	8000b33c <_fwalk+0x30>
8000b330:	8c 18       	ld.sh	r8,r6[0x2]
8000b332:	e6 08 19 00 	cp.h	r8,r3
8000b336:	c0 30       	breq	8000b33c <_fwalk+0x30>
8000b338:	5d 11       	icall	r1
8000b33a:	18 45       	or	r5,r12
8000b33c:	2a 46       	sub	r6,-92
8000b33e:	20 14       	sub	r4,1
8000b340:	ec cc 00 0c 	sub	r12,r6,12
8000b344:	58 04       	cp.w	r4,0
8000b346:	cf 14       	brge	8000b328 <_fwalk+0x1c>
8000b348:	6e 07       	ld.w	r7,r7[0x0]
8000b34a:	58 07       	cp.w	r7,0
8000b34c:	ce a1       	brne	8000b320 <_fwalk+0x14>
8000b34e:	fe b0 fc e4 	rcall	8000ad16 <__sfp_lock_release>
8000b352:	0a 9c       	mov	r12,r5
8000b354:	d8 32       	popm	r0-r7,pc
8000b356:	d7 03       	nop

8000b358 <_localeconv_r>:
8000b358:	fe cc d4 18 	sub	r12,pc,-11240
8000b35c:	5e fc       	retal	r12
8000b35e:	d7 03       	nop

8000b360 <__smakebuf_r>:
8000b360:	d4 21       	pushm	r4-r7,lr
8000b362:	20 fd       	sub	sp,60
8000b364:	96 68       	ld.sh	r8,r11[0xc]
8000b366:	16 97       	mov	r7,r11
8000b368:	18 96       	mov	r6,r12
8000b36a:	e2 18 00 02 	andl	r8,0x2,COH
8000b36e:	c3 d1       	brne	8000b3e8 <__smakebuf_r+0x88>
8000b370:	96 7b       	ld.sh	r11,r11[0xe]
8000b372:	f0 0b 19 00 	cp.h	r11,r8
8000b376:	c0 55       	brlt	8000b380 <__smakebuf_r+0x20>
8000b378:	1a 9a       	mov	r10,sp
8000b37a:	e0 a0 04 81 	rcall	8000bc7c <_fstat_r>
8000b37e:	c0 f4       	brge	8000b39c <__smakebuf_r+0x3c>
8000b380:	8e 65       	ld.sh	r5,r7[0xc]
8000b382:	0a 98       	mov	r8,r5
8000b384:	ab b8       	sbr	r8,0xb
8000b386:	e2 15 00 80 	andl	r5,0x80,COH
8000b38a:	ae 68       	st.h	r7[0xc],r8
8000b38c:	30 04       	mov	r4,0
8000b38e:	e0 68 04 00 	mov	r8,1024
8000b392:	f9 b5 01 40 	movne	r5,64
8000b396:	f0 05 17 00 	moveq	r5,r8
8000b39a:	c1 c8       	rjmp	8000b3d2 <__smakebuf_r+0x72>
8000b39c:	40 18       	lddsp	r8,sp[0x4]
8000b39e:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b3a2:	e0 48 20 00 	cp.w	r8,8192
8000b3a6:	5f 04       	sreq	r4
8000b3a8:	e0 48 80 00 	cp.w	r8,32768
8000b3ac:	c0 e1       	brne	8000b3c8 <__smakebuf_r+0x68>
8000b3ae:	6e b9       	ld.w	r9,r7[0x2c]
8000b3b0:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b3b4:	10 39       	cp.w	r9,r8
8000b3b6:	c0 91       	brne	8000b3c8 <__smakebuf_r+0x68>
8000b3b8:	8e 68       	ld.sh	r8,r7[0xc]
8000b3ba:	e0 65 04 00 	mov	r5,1024
8000b3be:	ab a8       	sbr	r8,0xa
8000b3c0:	ef 45 00 50 	st.w	r7[80],r5
8000b3c4:	ae 68       	st.h	r7[0xc],r8
8000b3c6:	c0 68       	rjmp	8000b3d2 <__smakebuf_r+0x72>
8000b3c8:	8e 68       	ld.sh	r8,r7[0xc]
8000b3ca:	e0 65 04 00 	mov	r5,1024
8000b3ce:	ab b8       	sbr	r8,0xb
8000b3d0:	ae 68       	st.h	r7[0xc],r8
8000b3d2:	0a 9b       	mov	r11,r5
8000b3d4:	0c 9c       	mov	r12,r6
8000b3d6:	fe b0 df 35 	rcall	80007240 <_malloc_r>
8000b3da:	8e 68       	ld.sh	r8,r7[0xc]
8000b3dc:	c0 d1       	brne	8000b3f6 <__smakebuf_r+0x96>
8000b3de:	ed b8 00 09 	bld	r8,0x9
8000b3e2:	c1 b0       	breq	8000b418 <__smakebuf_r+0xb8>
8000b3e4:	a1 b8       	sbr	r8,0x1
8000b3e6:	ae 68       	st.h	r7[0xc],r8
8000b3e8:	ee c8 ff b9 	sub	r8,r7,-71
8000b3ec:	8f 48       	st.w	r7[0x10],r8
8000b3ee:	8f 08       	st.w	r7[0x0],r8
8000b3f0:	30 18       	mov	r8,1
8000b3f2:	8f 58       	st.w	r7[0x14],r8
8000b3f4:	c1 28       	rjmp	8000b418 <__smakebuf_r+0xb8>
8000b3f6:	a7 b8       	sbr	r8,0x7
8000b3f8:	8f 4c       	st.w	r7[0x10],r12
8000b3fa:	ae 68       	st.h	r7[0xc],r8
8000b3fc:	8f 55       	st.w	r7[0x14],r5
8000b3fe:	fe c8 06 e6 	sub	r8,pc,1766
8000b402:	8f 0c       	st.w	r7[0x0],r12
8000b404:	8d a8       	st.w	r6[0x28],r8
8000b406:	58 04       	cp.w	r4,0
8000b408:	c0 80       	breq	8000b418 <__smakebuf_r+0xb8>
8000b40a:	8e 7c       	ld.sh	r12,r7[0xe]
8000b40c:	fe b0 e3 94 	rcall	80007b34 <isatty>
8000b410:	c0 40       	breq	8000b418 <__smakebuf_r+0xb8>
8000b412:	8e 68       	ld.sh	r8,r7[0xc]
8000b414:	a1 a8       	sbr	r8,0x0
8000b416:	ae 68       	st.h	r7[0xc],r8
8000b418:	2f 1d       	sub	sp,-60
8000b41a:	d8 22       	popm	r4-r7,pc

8000b41c <memchr>:
8000b41c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b420:	c0 68       	rjmp	8000b42c <memchr+0x10>
8000b422:	20 1a       	sub	r10,1
8000b424:	19 88       	ld.ub	r8,r12[0x0]
8000b426:	16 38       	cp.w	r8,r11
8000b428:	5e 0c       	reteq	r12
8000b42a:	2f fc       	sub	r12,-1
8000b42c:	58 0a       	cp.w	r10,0
8000b42e:	cf a1       	brne	8000b422 <memchr+0x6>
8000b430:	5e fa       	retal	r10

8000b432 <memmove>:
8000b432:	d4 01       	pushm	lr
8000b434:	18 3b       	cp.w	r11,r12
8000b436:	c1 92       	brcc	8000b468 <memmove+0x36>
8000b438:	f6 0a 00 09 	add	r9,r11,r10
8000b43c:	12 3c       	cp.w	r12,r9
8000b43e:	c1 52       	brcc	8000b468 <memmove+0x36>
8000b440:	f8 0a 00 0b 	add	r11,r12,r10
8000b444:	30 08       	mov	r8,0
8000b446:	c0 68       	rjmp	8000b452 <memmove+0x20>
8000b448:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b44c:	20 1a       	sub	r10,1
8000b44e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b452:	20 18       	sub	r8,1
8000b454:	58 0a       	cp.w	r10,0
8000b456:	cf 91       	brne	8000b448 <memmove+0x16>
8000b458:	d8 02       	popm	pc
8000b45a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b45e:	20 1a       	sub	r10,1
8000b460:	f8 08 0b 09 	st.b	r12[r8],r9
8000b464:	2f f8       	sub	r8,-1
8000b466:	c0 28       	rjmp	8000b46a <memmove+0x38>
8000b468:	30 08       	mov	r8,0
8000b46a:	58 0a       	cp.w	r10,0
8000b46c:	cf 71       	brne	8000b45a <memmove+0x28>
8000b46e:	d8 02       	popm	pc

8000b470 <__hi0bits>:
8000b470:	18 98       	mov	r8,r12
8000b472:	e0 1c 00 00 	andl	r12,0x0
8000b476:	f0 09 15 10 	lsl	r9,r8,0x10
8000b47a:	58 0c       	cp.w	r12,0
8000b47c:	f2 08 17 00 	moveq	r8,r9
8000b480:	f9 bc 00 10 	moveq	r12,16
8000b484:	f9 bc 01 00 	movne	r12,0
8000b488:	10 9a       	mov	r10,r8
8000b48a:	f0 09 15 08 	lsl	r9,r8,0x8
8000b48e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b492:	f7 bc 00 f8 	subeq	r12,-8
8000b496:	f2 08 17 00 	moveq	r8,r9
8000b49a:	10 9a       	mov	r10,r8
8000b49c:	f0 09 15 04 	lsl	r9,r8,0x4
8000b4a0:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b4a4:	f7 bc 00 fc 	subeq	r12,-4
8000b4a8:	f2 08 17 00 	moveq	r8,r9
8000b4ac:	10 9a       	mov	r10,r8
8000b4ae:	f0 09 15 02 	lsl	r9,r8,0x2
8000b4b2:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b4b6:	f7 bc 00 fe 	subeq	r12,-2
8000b4ba:	f2 08 17 00 	moveq	r8,r9
8000b4be:	58 08       	cp.w	r8,0
8000b4c0:	5e 5c       	retlt	r12
8000b4c2:	ed b8 00 1e 	bld	r8,0x1e
8000b4c6:	f9 bc 01 20 	movne	r12,32
8000b4ca:	f7 bc 00 ff 	subeq	r12,-1
8000b4ce:	5e fc       	retal	r12

8000b4d0 <__lo0bits>:
8000b4d0:	18 99       	mov	r9,r12
8000b4d2:	78 08       	ld.w	r8,r12[0x0]
8000b4d4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b4d8:	c1 50       	breq	8000b502 <__lo0bits+0x32>
8000b4da:	ed b8 00 00 	bld	r8,0x0
8000b4de:	c0 21       	brne	8000b4e2 <__lo0bits+0x12>
8000b4e0:	5e fd       	retal	0
8000b4e2:	10 9b       	mov	r11,r8
8000b4e4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b4e8:	e2 1b 00 02 	andl	r11,0x2,COH
8000b4ec:	a3 88       	lsr	r8,0x2
8000b4ee:	58 0b       	cp.w	r11,0
8000b4f0:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b4f4:	f9 bc 01 01 	movne	r12,1
8000b4f8:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b4fc:	f9 bc 00 02 	moveq	r12,2
8000b500:	5e fc       	retal	r12
8000b502:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b506:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b50a:	58 0a       	cp.w	r10,0
8000b50c:	f6 08 17 00 	moveq	r8,r11
8000b510:	f9 bc 00 10 	moveq	r12,16
8000b514:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b518:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b51c:	58 0b       	cp.w	r11,0
8000b51e:	f7 bc 00 f8 	subeq	r12,-8
8000b522:	f4 08 17 00 	moveq	r8,r10
8000b526:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b52a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b52e:	58 0b       	cp.w	r11,0
8000b530:	f7 bc 00 fc 	subeq	r12,-4
8000b534:	f4 08 17 00 	moveq	r8,r10
8000b538:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b53c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b540:	58 0b       	cp.w	r11,0
8000b542:	f7 bc 00 fe 	subeq	r12,-2
8000b546:	f4 08 17 00 	moveq	r8,r10
8000b54a:	ed b8 00 00 	bld	r8,0x0
8000b54e:	c0 60       	breq	8000b55a <__lo0bits+0x8a>
8000b550:	a1 98       	lsr	r8,0x1
8000b552:	c0 31       	brne	8000b558 <__lo0bits+0x88>
8000b554:	32 0c       	mov	r12,32
8000b556:	5e fc       	retal	r12
8000b558:	2f fc       	sub	r12,-1
8000b55a:	93 08       	st.w	r9[0x0],r8
8000b55c:	5e fc       	retal	r12

8000b55e <__mcmp>:
8000b55e:	d4 01       	pushm	lr
8000b560:	18 98       	mov	r8,r12
8000b562:	76 49       	ld.w	r9,r11[0x10]
8000b564:	78 4c       	ld.w	r12,r12[0x10]
8000b566:	12 1c       	sub	r12,r9
8000b568:	c1 31       	brne	8000b58e <__mcmp+0x30>
8000b56a:	2f b9       	sub	r9,-5
8000b56c:	a3 69       	lsl	r9,0x2
8000b56e:	12 0b       	add	r11,r9
8000b570:	f0 09 00 09 	add	r9,r8,r9
8000b574:	2e c8       	sub	r8,-20
8000b576:	13 4e       	ld.w	lr,--r9
8000b578:	17 4a       	ld.w	r10,--r11
8000b57a:	14 3e       	cp.w	lr,r10
8000b57c:	c0 60       	breq	8000b588 <__mcmp+0x2a>
8000b57e:	f9 bc 03 ff 	movlo	r12,-1
8000b582:	f9 bc 02 01 	movhs	r12,1
8000b586:	d8 02       	popm	pc
8000b588:	10 39       	cp.w	r9,r8
8000b58a:	fe 9b ff f6 	brhi	8000b576 <__mcmp+0x18>
8000b58e:	d8 02       	popm	pc

8000b590 <_Bfree>:
8000b590:	d4 21       	pushm	r4-r7,lr
8000b592:	18 97       	mov	r7,r12
8000b594:	16 95       	mov	r5,r11
8000b596:	78 96       	ld.w	r6,r12[0x24]
8000b598:	58 06       	cp.w	r6,0
8000b59a:	c0 91       	brne	8000b5ac <_Bfree+0x1c>
8000b59c:	31 0c       	mov	r12,16
8000b59e:	fe b0 de 49 	rcall	80007230 <malloc>
8000b5a2:	99 36       	st.w	r12[0xc],r6
8000b5a4:	8f 9c       	st.w	r7[0x24],r12
8000b5a6:	99 16       	st.w	r12[0x4],r6
8000b5a8:	99 26       	st.w	r12[0x8],r6
8000b5aa:	99 06       	st.w	r12[0x0],r6
8000b5ac:	58 05       	cp.w	r5,0
8000b5ae:	c0 90       	breq	8000b5c0 <_Bfree+0x30>
8000b5b0:	6a 19       	ld.w	r9,r5[0x4]
8000b5b2:	6e 98       	ld.w	r8,r7[0x24]
8000b5b4:	70 38       	ld.w	r8,r8[0xc]
8000b5b6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b5ba:	8b 0a       	st.w	r5[0x0],r10
8000b5bc:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b5c0:	d8 22       	popm	r4-r7,pc
8000b5c2:	d7 03       	nop

8000b5c4 <_Balloc>:
8000b5c4:	d4 21       	pushm	r4-r7,lr
8000b5c6:	18 97       	mov	r7,r12
8000b5c8:	16 96       	mov	r6,r11
8000b5ca:	78 95       	ld.w	r5,r12[0x24]
8000b5cc:	58 05       	cp.w	r5,0
8000b5ce:	c0 91       	brne	8000b5e0 <_Balloc+0x1c>
8000b5d0:	31 0c       	mov	r12,16
8000b5d2:	fe b0 de 2f 	rcall	80007230 <malloc>
8000b5d6:	99 35       	st.w	r12[0xc],r5
8000b5d8:	8f 9c       	st.w	r7[0x24],r12
8000b5da:	99 15       	st.w	r12[0x4],r5
8000b5dc:	99 25       	st.w	r12[0x8],r5
8000b5de:	99 05       	st.w	r12[0x0],r5
8000b5e0:	6e 95       	ld.w	r5,r7[0x24]
8000b5e2:	6a 38       	ld.w	r8,r5[0xc]
8000b5e4:	58 08       	cp.w	r8,0
8000b5e6:	c0 b1       	brne	8000b5fc <_Balloc+0x38>
8000b5e8:	31 0a       	mov	r10,16
8000b5ea:	30 4b       	mov	r11,4
8000b5ec:	0e 9c       	mov	r12,r7
8000b5ee:	e0 a0 02 a7 	rcall	8000bb3c <_calloc_r>
8000b5f2:	8b 3c       	st.w	r5[0xc],r12
8000b5f4:	6e 98       	ld.w	r8,r7[0x24]
8000b5f6:	70 3c       	ld.w	r12,r8[0xc]
8000b5f8:	58 0c       	cp.w	r12,0
8000b5fa:	c1 b0       	breq	8000b630 <_Balloc+0x6c>
8000b5fc:	6e 98       	ld.w	r8,r7[0x24]
8000b5fe:	70 38       	ld.w	r8,r8[0xc]
8000b600:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b604:	70 0c       	ld.w	r12,r8[0x0]
8000b606:	58 0c       	cp.w	r12,0
8000b608:	c0 40       	breq	8000b610 <_Balloc+0x4c>
8000b60a:	78 09       	ld.w	r9,r12[0x0]
8000b60c:	91 09       	st.w	r8[0x0],r9
8000b60e:	c0 e8       	rjmp	8000b62a <_Balloc+0x66>
8000b610:	0e 9c       	mov	r12,r7
8000b612:	30 17       	mov	r7,1
8000b614:	0e 9b       	mov	r11,r7
8000b616:	ee 06 09 47 	lsl	r7,r7,r6
8000b61a:	ee ca ff fb 	sub	r10,r7,-5
8000b61e:	a3 6a       	lsl	r10,0x2
8000b620:	e0 a0 02 8e 	rcall	8000bb3c <_calloc_r>
8000b624:	c0 60       	breq	8000b630 <_Balloc+0x6c>
8000b626:	99 16       	st.w	r12[0x4],r6
8000b628:	99 27       	st.w	r12[0x8],r7
8000b62a:	30 08       	mov	r8,0
8000b62c:	99 38       	st.w	r12[0xc],r8
8000b62e:	99 48       	st.w	r12[0x10],r8
8000b630:	d8 22       	popm	r4-r7,pc
8000b632:	d7 03       	nop

8000b634 <__d2b>:
8000b634:	d4 31       	pushm	r0-r7,lr
8000b636:	20 2d       	sub	sp,8
8000b638:	16 93       	mov	r3,r11
8000b63a:	12 96       	mov	r6,r9
8000b63c:	10 95       	mov	r5,r8
8000b63e:	14 92       	mov	r2,r10
8000b640:	30 1b       	mov	r11,1
8000b642:	cc 1f       	rcall	8000b5c4 <_Balloc>
8000b644:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b648:	50 09       	stdsp	sp[0x0],r9
8000b64a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b64e:	b5 a9       	sbr	r9,0x14
8000b650:	f0 01 16 14 	lsr	r1,r8,0x14
8000b654:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b658:	18 94       	mov	r4,r12
8000b65a:	58 02       	cp.w	r2,0
8000b65c:	c1 d0       	breq	8000b696 <__d2b+0x62>
8000b65e:	fa cc ff f8 	sub	r12,sp,-8
8000b662:	18 d2       	st.w	--r12,r2
8000b664:	c3 6f       	rcall	8000b4d0 <__lo0bits>
8000b666:	40 18       	lddsp	r8,sp[0x4]
8000b668:	c0 d0       	breq	8000b682 <__d2b+0x4e>
8000b66a:	40 09       	lddsp	r9,sp[0x0]
8000b66c:	f8 0a 11 20 	rsub	r10,r12,32
8000b670:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b674:	f5 e8 10 08 	or	r8,r10,r8
8000b678:	89 58       	st.w	r4[0x14],r8
8000b67a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b67e:	50 09       	stdsp	sp[0x0],r9
8000b680:	c0 28       	rjmp	8000b684 <__d2b+0x50>
8000b682:	89 58       	st.w	r4[0x14],r8
8000b684:	40 08       	lddsp	r8,sp[0x0]
8000b686:	58 08       	cp.w	r8,0
8000b688:	f9 b3 01 02 	movne	r3,2
8000b68c:	f9 b3 00 01 	moveq	r3,1
8000b690:	89 68       	st.w	r4[0x18],r8
8000b692:	89 43       	st.w	r4[0x10],r3
8000b694:	c0 88       	rjmp	8000b6a4 <__d2b+0x70>
8000b696:	1a 9c       	mov	r12,sp
8000b698:	c1 cf       	rcall	8000b4d0 <__lo0bits>
8000b69a:	30 13       	mov	r3,1
8000b69c:	40 08       	lddsp	r8,sp[0x0]
8000b69e:	2e 0c       	sub	r12,-32
8000b6a0:	89 43       	st.w	r4[0x10],r3
8000b6a2:	89 58       	st.w	r4[0x14],r8
8000b6a4:	58 01       	cp.w	r1,0
8000b6a6:	c0 90       	breq	8000b6b8 <__d2b+0x84>
8000b6a8:	e2 c1 04 33 	sub	r1,r1,1075
8000b6ac:	18 01       	add	r1,r12
8000b6ae:	8d 01       	st.w	r6[0x0],r1
8000b6b0:	f8 0c 11 35 	rsub	r12,r12,53
8000b6b4:	8b 0c       	st.w	r5[0x0],r12
8000b6b6:	c0 c8       	rjmp	8000b6ce <__d2b+0x9a>
8000b6b8:	e6 c8 ff fc 	sub	r8,r3,-4
8000b6bc:	f8 cc 04 32 	sub	r12,r12,1074
8000b6c0:	a5 73       	lsl	r3,0x5
8000b6c2:	8d 0c       	st.w	r6[0x0],r12
8000b6c4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b6c8:	cd 4e       	rcall	8000b470 <__hi0bits>
8000b6ca:	18 13       	sub	r3,r12
8000b6cc:	8b 03       	st.w	r5[0x0],r3
8000b6ce:	08 9c       	mov	r12,r4
8000b6d0:	2f ed       	sub	sp,-8
8000b6d2:	d8 32       	popm	r0-r7,pc

8000b6d4 <__mdiff>:
8000b6d4:	d4 31       	pushm	r0-r7,lr
8000b6d6:	74 48       	ld.w	r8,r10[0x10]
8000b6d8:	76 45       	ld.w	r5,r11[0x10]
8000b6da:	16 97       	mov	r7,r11
8000b6dc:	14 96       	mov	r6,r10
8000b6de:	10 15       	sub	r5,r8
8000b6e0:	c1 31       	brne	8000b706 <__mdiff+0x32>
8000b6e2:	2f b8       	sub	r8,-5
8000b6e4:	ee ce ff ec 	sub	lr,r7,-20
8000b6e8:	a3 68       	lsl	r8,0x2
8000b6ea:	f4 08 00 0b 	add	r11,r10,r8
8000b6ee:	ee 08 00 08 	add	r8,r7,r8
8000b6f2:	11 4a       	ld.w	r10,--r8
8000b6f4:	17 49       	ld.w	r9,--r11
8000b6f6:	12 3a       	cp.w	r10,r9
8000b6f8:	c0 30       	breq	8000b6fe <__mdiff+0x2a>
8000b6fa:	c0 e2       	brcc	8000b716 <__mdiff+0x42>
8000b6fc:	c0 78       	rjmp	8000b70a <__mdiff+0x36>
8000b6fe:	1c 38       	cp.w	r8,lr
8000b700:	fe 9b ff f9 	brhi	8000b6f2 <__mdiff+0x1e>
8000b704:	c4 98       	rjmp	8000b796 <__mdiff+0xc2>
8000b706:	58 05       	cp.w	r5,0
8000b708:	c0 64       	brge	8000b714 <__mdiff+0x40>
8000b70a:	0e 98       	mov	r8,r7
8000b70c:	30 15       	mov	r5,1
8000b70e:	0c 97       	mov	r7,r6
8000b710:	10 96       	mov	r6,r8
8000b712:	c0 28       	rjmp	8000b716 <__mdiff+0x42>
8000b714:	30 05       	mov	r5,0
8000b716:	6e 1b       	ld.w	r11,r7[0x4]
8000b718:	c5 6f       	rcall	8000b5c4 <_Balloc>
8000b71a:	6e 49       	ld.w	r9,r7[0x10]
8000b71c:	6c 44       	ld.w	r4,r6[0x10]
8000b71e:	99 35       	st.w	r12[0xc],r5
8000b720:	2f b4       	sub	r4,-5
8000b722:	f2 c5 ff fb 	sub	r5,r9,-5
8000b726:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000b72a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000b72e:	2e c6       	sub	r6,-20
8000b730:	2e c7       	sub	r7,-20
8000b732:	f8 c8 ff ec 	sub	r8,r12,-20
8000b736:	30 0a       	mov	r10,0
8000b738:	0f 0e       	ld.w	lr,r7++
8000b73a:	0d 0b       	ld.w	r11,r6++
8000b73c:	fc 02 16 10 	lsr	r2,lr,0x10
8000b740:	f6 03 16 10 	lsr	r3,r11,0x10
8000b744:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b748:	e4 03 01 03 	sub	r3,r2,r3
8000b74c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b750:	fc 0b 01 0b 	sub	r11,lr,r11
8000b754:	f6 0a 00 0a 	add	r10,r11,r10
8000b758:	b0 1a       	st.h	r8[0x2],r10
8000b75a:	b1 4a       	asr	r10,0x10
8000b75c:	e6 0a 00 0a 	add	r10,r3,r10
8000b760:	b0 0a       	st.h	r8[0x0],r10
8000b762:	2f c8       	sub	r8,-4
8000b764:	b1 4a       	asr	r10,0x10
8000b766:	08 36       	cp.w	r6,r4
8000b768:	ce 83       	brcs	8000b738 <__mdiff+0x64>
8000b76a:	c0 d8       	rjmp	8000b784 <__mdiff+0xb0>
8000b76c:	0f 0b       	ld.w	r11,r7++
8000b76e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000b772:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b776:	16 0a       	add	r10,r11
8000b778:	b0 1a       	st.h	r8[0x2],r10
8000b77a:	b1 4a       	asr	r10,0x10
8000b77c:	1c 0a       	add	r10,lr
8000b77e:	b0 0a       	st.h	r8[0x0],r10
8000b780:	2f c8       	sub	r8,-4
8000b782:	b1 4a       	asr	r10,0x10
8000b784:	0a 37       	cp.w	r7,r5
8000b786:	cf 33       	brcs	8000b76c <__mdiff+0x98>
8000b788:	c0 28       	rjmp	8000b78c <__mdiff+0xb8>
8000b78a:	20 19       	sub	r9,1
8000b78c:	11 4a       	ld.w	r10,--r8
8000b78e:	58 0a       	cp.w	r10,0
8000b790:	cf d0       	breq	8000b78a <__mdiff+0xb6>
8000b792:	99 49       	st.w	r12[0x10],r9
8000b794:	d8 32       	popm	r0-r7,pc
8000b796:	30 0b       	mov	r11,0
8000b798:	c1 6f       	rcall	8000b5c4 <_Balloc>
8000b79a:	30 18       	mov	r8,1
8000b79c:	99 48       	st.w	r12[0x10],r8
8000b79e:	30 08       	mov	r8,0
8000b7a0:	99 58       	st.w	r12[0x14],r8
8000b7a2:	d8 32       	popm	r0-r7,pc

8000b7a4 <__lshift>:
8000b7a4:	d4 31       	pushm	r0-r7,lr
8000b7a6:	16 97       	mov	r7,r11
8000b7a8:	76 46       	ld.w	r6,r11[0x10]
8000b7aa:	f4 02 14 05 	asr	r2,r10,0x5
8000b7ae:	2f f6       	sub	r6,-1
8000b7b0:	14 93       	mov	r3,r10
8000b7b2:	18 94       	mov	r4,r12
8000b7b4:	04 06       	add	r6,r2
8000b7b6:	76 1b       	ld.w	r11,r11[0x4]
8000b7b8:	6e 28       	ld.w	r8,r7[0x8]
8000b7ba:	c0 38       	rjmp	8000b7c0 <__lshift+0x1c>
8000b7bc:	2f fb       	sub	r11,-1
8000b7be:	a1 78       	lsl	r8,0x1
8000b7c0:	10 36       	cp.w	r6,r8
8000b7c2:	fe 99 ff fd 	brgt	8000b7bc <__lshift+0x18>
8000b7c6:	08 9c       	mov	r12,r4
8000b7c8:	cf ee       	rcall	8000b5c4 <_Balloc>
8000b7ca:	30 09       	mov	r9,0
8000b7cc:	18 95       	mov	r5,r12
8000b7ce:	f8 c8 ff ec 	sub	r8,r12,-20
8000b7d2:	12 9a       	mov	r10,r9
8000b7d4:	c0 38       	rjmp	8000b7da <__lshift+0x36>
8000b7d6:	10 aa       	st.w	r8++,r10
8000b7d8:	2f f9       	sub	r9,-1
8000b7da:	04 39       	cp.w	r9,r2
8000b7dc:	cf d5       	brlt	8000b7d6 <__lshift+0x32>
8000b7de:	6e 4b       	ld.w	r11,r7[0x10]
8000b7e0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000b7e4:	2f bb       	sub	r11,-5
8000b7e6:	ee c9 ff ec 	sub	r9,r7,-20
8000b7ea:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000b7ee:	58 03       	cp.w	r3,0
8000b7f0:	c1 30       	breq	8000b816 <__lshift+0x72>
8000b7f2:	e6 0c 11 20 	rsub	r12,r3,32
8000b7f6:	30 0a       	mov	r10,0
8000b7f8:	72 02       	ld.w	r2,r9[0x0]
8000b7fa:	e4 03 09 42 	lsl	r2,r2,r3
8000b7fe:	04 4a       	or	r10,r2
8000b800:	10 aa       	st.w	r8++,r10
8000b802:	13 0a       	ld.w	r10,r9++
8000b804:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000b808:	16 39       	cp.w	r9,r11
8000b80a:	cf 73       	brcs	8000b7f8 <__lshift+0x54>
8000b80c:	91 0a       	st.w	r8[0x0],r10
8000b80e:	58 0a       	cp.w	r10,0
8000b810:	c0 70       	breq	8000b81e <__lshift+0x7a>
8000b812:	2f f6       	sub	r6,-1
8000b814:	c0 58       	rjmp	8000b81e <__lshift+0x7a>
8000b816:	13 0a       	ld.w	r10,r9++
8000b818:	10 aa       	st.w	r8++,r10
8000b81a:	16 39       	cp.w	r9,r11
8000b81c:	cf d3       	brcs	8000b816 <__lshift+0x72>
8000b81e:	08 9c       	mov	r12,r4
8000b820:	20 16       	sub	r6,1
8000b822:	0e 9b       	mov	r11,r7
8000b824:	8b 46       	st.w	r5[0x10],r6
8000b826:	cb 5e       	rcall	8000b590 <_Bfree>
8000b828:	0a 9c       	mov	r12,r5
8000b82a:	d8 32       	popm	r0-r7,pc

8000b82c <__multiply>:
8000b82c:	d4 31       	pushm	r0-r7,lr
8000b82e:	20 2d       	sub	sp,8
8000b830:	76 49       	ld.w	r9,r11[0x10]
8000b832:	74 48       	ld.w	r8,r10[0x10]
8000b834:	16 96       	mov	r6,r11
8000b836:	14 95       	mov	r5,r10
8000b838:	10 39       	cp.w	r9,r8
8000b83a:	ec 08 17 50 	movlt	r8,r6
8000b83e:	ea 06 17 50 	movlt	r6,r5
8000b842:	f0 05 17 50 	movlt	r5,r8
8000b846:	6c 28       	ld.w	r8,r6[0x8]
8000b848:	76 43       	ld.w	r3,r11[0x10]
8000b84a:	74 42       	ld.w	r2,r10[0x10]
8000b84c:	76 1b       	ld.w	r11,r11[0x4]
8000b84e:	e4 03 00 07 	add	r7,r2,r3
8000b852:	10 37       	cp.w	r7,r8
8000b854:	f7 bb 09 ff 	subgt	r11,-1
8000b858:	cb 6e       	rcall	8000b5c4 <_Balloc>
8000b85a:	ee c4 ff fb 	sub	r4,r7,-5
8000b85e:	f8 c9 ff ec 	sub	r9,r12,-20
8000b862:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000b866:	30 0a       	mov	r10,0
8000b868:	12 98       	mov	r8,r9
8000b86a:	c0 28       	rjmp	8000b86e <__multiply+0x42>
8000b86c:	10 aa       	st.w	r8++,r10
8000b86e:	08 38       	cp.w	r8,r4
8000b870:	cf e3       	brcs	8000b86c <__multiply+0x40>
8000b872:	2f b3       	sub	r3,-5
8000b874:	2f b2       	sub	r2,-5
8000b876:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000b87a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000b87e:	ec cb ff ec 	sub	r11,r6,-20
8000b882:	50 12       	stdsp	sp[0x4],r2
8000b884:	ea ca ff ec 	sub	r10,r5,-20
8000b888:	c4 48       	rjmp	8000b910 <__multiply+0xe4>
8000b88a:	94 95       	ld.uh	r5,r10[0x2]
8000b88c:	58 05       	cp.w	r5,0
8000b88e:	c2 00       	breq	8000b8ce <__multiply+0xa2>
8000b890:	12 98       	mov	r8,r9
8000b892:	16 96       	mov	r6,r11
8000b894:	30 0e       	mov	lr,0
8000b896:	50 09       	stdsp	sp[0x0],r9
8000b898:	0d 02       	ld.w	r2,r6++
8000b89a:	e4 00 16 10 	lsr	r0,r2,0x10
8000b89e:	70 01       	ld.w	r1,r8[0x0]
8000b8a0:	70 09       	ld.w	r9,r8[0x0]
8000b8a2:	b1 81       	lsr	r1,0x10
8000b8a4:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000b8a8:	e0 05 03 41 	mac	r1,r0,r5
8000b8ac:	ab 32       	mul	r2,r5
8000b8ae:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000b8b2:	00 02       	add	r2,r0
8000b8b4:	e4 0e 00 0e 	add	lr,r2,lr
8000b8b8:	b0 1e       	st.h	r8[0x2],lr
8000b8ba:	b1 8e       	lsr	lr,0x10
8000b8bc:	1c 01       	add	r1,lr
8000b8be:	b0 01       	st.h	r8[0x0],r1
8000b8c0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000b8c4:	2f c8       	sub	r8,-4
8000b8c6:	06 36       	cp.w	r6,r3
8000b8c8:	ce 83       	brcs	8000b898 <__multiply+0x6c>
8000b8ca:	40 09       	lddsp	r9,sp[0x0]
8000b8cc:	91 0e       	st.w	r8[0x0],lr
8000b8ce:	94 86       	ld.uh	r6,r10[0x0]
8000b8d0:	58 06       	cp.w	r6,0
8000b8d2:	c1 d0       	breq	8000b90c <__multiply+0xe0>
8000b8d4:	72 02       	ld.w	r2,r9[0x0]
8000b8d6:	12 98       	mov	r8,r9
8000b8d8:	16 9e       	mov	lr,r11
8000b8da:	30 05       	mov	r5,0
8000b8dc:	b0 12       	st.h	r8[0x2],r2
8000b8de:	1d 01       	ld.w	r1,lr++
8000b8e0:	90 82       	ld.uh	r2,r8[0x0]
8000b8e2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000b8e6:	ad 30       	mul	r0,r6
8000b8e8:	e0 02 00 02 	add	r2,r0,r2
8000b8ec:	e4 05 00 05 	add	r5,r2,r5
8000b8f0:	b0 05       	st.h	r8[0x0],r5
8000b8f2:	b1 85       	lsr	r5,0x10
8000b8f4:	b1 81       	lsr	r1,0x10
8000b8f6:	2f c8       	sub	r8,-4
8000b8f8:	ad 31       	mul	r1,r6
8000b8fa:	90 92       	ld.uh	r2,r8[0x2]
8000b8fc:	e2 02 00 02 	add	r2,r1,r2
8000b900:	0a 02       	add	r2,r5
8000b902:	e4 05 16 10 	lsr	r5,r2,0x10
8000b906:	06 3e       	cp.w	lr,r3
8000b908:	ce a3       	brcs	8000b8dc <__multiply+0xb0>
8000b90a:	91 02       	st.w	r8[0x0],r2
8000b90c:	2f ca       	sub	r10,-4
8000b90e:	2f c9       	sub	r9,-4
8000b910:	40 18       	lddsp	r8,sp[0x4]
8000b912:	10 3a       	cp.w	r10,r8
8000b914:	cb b3       	brcs	8000b88a <__multiply+0x5e>
8000b916:	c0 28       	rjmp	8000b91a <__multiply+0xee>
8000b918:	20 17       	sub	r7,1
8000b91a:	58 07       	cp.w	r7,0
8000b91c:	e0 8a 00 05 	brle	8000b926 <__multiply+0xfa>
8000b920:	09 48       	ld.w	r8,--r4
8000b922:	58 08       	cp.w	r8,0
8000b924:	cf a0       	breq	8000b918 <__multiply+0xec>
8000b926:	99 47       	st.w	r12[0x10],r7
8000b928:	2f ed       	sub	sp,-8
8000b92a:	d8 32       	popm	r0-r7,pc

8000b92c <__i2b>:
8000b92c:	d4 21       	pushm	r4-r7,lr
8000b92e:	16 97       	mov	r7,r11
8000b930:	30 1b       	mov	r11,1
8000b932:	c4 9e       	rcall	8000b5c4 <_Balloc>
8000b934:	30 19       	mov	r9,1
8000b936:	99 57       	st.w	r12[0x14],r7
8000b938:	99 49       	st.w	r12[0x10],r9
8000b93a:	d8 22       	popm	r4-r7,pc

8000b93c <__multadd>:
8000b93c:	d4 31       	pushm	r0-r7,lr
8000b93e:	30 08       	mov	r8,0
8000b940:	12 95       	mov	r5,r9
8000b942:	16 97       	mov	r7,r11
8000b944:	18 96       	mov	r6,r12
8000b946:	76 44       	ld.w	r4,r11[0x10]
8000b948:	f6 c9 ff ec 	sub	r9,r11,-20
8000b94c:	72 0b       	ld.w	r11,r9[0x0]
8000b94e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000b952:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000b956:	f4 0c 02 4c 	mul	r12,r10,r12
8000b95a:	f4 0b 03 45 	mac	r5,r10,r11
8000b95e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000b962:	b1 85       	lsr	r5,0x10
8000b964:	18 05       	add	r5,r12
8000b966:	ea 0c 15 10 	lsl	r12,r5,0x10
8000b96a:	f8 0b 00 0b 	add	r11,r12,r11
8000b96e:	12 ab       	st.w	r9++,r11
8000b970:	2f f8       	sub	r8,-1
8000b972:	b1 85       	lsr	r5,0x10
8000b974:	08 38       	cp.w	r8,r4
8000b976:	ce b5       	brlt	8000b94c <__multadd+0x10>
8000b978:	58 05       	cp.w	r5,0
8000b97a:	c1 c0       	breq	8000b9b2 <__multadd+0x76>
8000b97c:	6e 28       	ld.w	r8,r7[0x8]
8000b97e:	10 34       	cp.w	r4,r8
8000b980:	c1 35       	brlt	8000b9a6 <__multadd+0x6a>
8000b982:	6e 1b       	ld.w	r11,r7[0x4]
8000b984:	0c 9c       	mov	r12,r6
8000b986:	2f fb       	sub	r11,-1
8000b988:	c1 ee       	rcall	8000b5c4 <_Balloc>
8000b98a:	6e 4a       	ld.w	r10,r7[0x10]
8000b98c:	ee cb ff f4 	sub	r11,r7,-12
8000b990:	18 93       	mov	r3,r12
8000b992:	2f ea       	sub	r10,-2
8000b994:	2f 4c       	sub	r12,-12
8000b996:	a3 6a       	lsl	r10,0x2
8000b998:	fe b0 de 70 	rcall	80007678 <memcpy>
8000b99c:	0e 9b       	mov	r11,r7
8000b99e:	0c 9c       	mov	r12,r6
8000b9a0:	fe b0 fd f8 	rcall	8000b590 <_Bfree>
8000b9a4:	06 97       	mov	r7,r3
8000b9a6:	e8 c8 ff ff 	sub	r8,r4,-1
8000b9aa:	2f b4       	sub	r4,-5
8000b9ac:	8f 48       	st.w	r7[0x10],r8
8000b9ae:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000b9b2:	0e 9c       	mov	r12,r7
8000b9b4:	d8 32       	popm	r0-r7,pc
8000b9b6:	d7 03       	nop

8000b9b8 <__pow5mult>:
8000b9b8:	d4 31       	pushm	r0-r7,lr
8000b9ba:	14 96       	mov	r6,r10
8000b9bc:	18 97       	mov	r7,r12
8000b9be:	16 94       	mov	r4,r11
8000b9c0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000b9c4:	c0 90       	breq	8000b9d6 <__pow5mult+0x1e>
8000b9c6:	20 18       	sub	r8,1
8000b9c8:	fe c9 da 4c 	sub	r9,pc,-9652
8000b9cc:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000b9d0:	30 09       	mov	r9,0
8000b9d2:	cb 5f       	rcall	8000b93c <__multadd>
8000b9d4:	18 94       	mov	r4,r12
8000b9d6:	a3 46       	asr	r6,0x2
8000b9d8:	c3 40       	breq	8000ba40 <__pow5mult+0x88>
8000b9da:	6e 95       	ld.w	r5,r7[0x24]
8000b9dc:	58 05       	cp.w	r5,0
8000b9de:	c0 91       	brne	8000b9f0 <__pow5mult+0x38>
8000b9e0:	31 0c       	mov	r12,16
8000b9e2:	fe b0 dc 27 	rcall	80007230 <malloc>
8000b9e6:	99 35       	st.w	r12[0xc],r5
8000b9e8:	8f 9c       	st.w	r7[0x24],r12
8000b9ea:	99 15       	st.w	r12[0x4],r5
8000b9ec:	99 25       	st.w	r12[0x8],r5
8000b9ee:	99 05       	st.w	r12[0x0],r5
8000b9f0:	6e 93       	ld.w	r3,r7[0x24]
8000b9f2:	66 25       	ld.w	r5,r3[0x8]
8000b9f4:	58 05       	cp.w	r5,0
8000b9f6:	c0 c1       	brne	8000ba0e <__pow5mult+0x56>
8000b9f8:	e0 6b 02 71 	mov	r11,625
8000b9fc:	0e 9c       	mov	r12,r7
8000b9fe:	c9 7f       	rcall	8000b92c <__i2b>
8000ba00:	87 2c       	st.w	r3[0x8],r12
8000ba02:	30 08       	mov	r8,0
8000ba04:	18 95       	mov	r5,r12
8000ba06:	99 08       	st.w	r12[0x0],r8
8000ba08:	c0 38       	rjmp	8000ba0e <__pow5mult+0x56>
8000ba0a:	06 9c       	mov	r12,r3
8000ba0c:	18 95       	mov	r5,r12
8000ba0e:	ed b6 00 00 	bld	r6,0x0
8000ba12:	c0 b1       	brne	8000ba28 <__pow5mult+0x70>
8000ba14:	08 9b       	mov	r11,r4
8000ba16:	0a 9a       	mov	r10,r5
8000ba18:	0e 9c       	mov	r12,r7
8000ba1a:	c0 9f       	rcall	8000b82c <__multiply>
8000ba1c:	08 9b       	mov	r11,r4
8000ba1e:	18 93       	mov	r3,r12
8000ba20:	0e 9c       	mov	r12,r7
8000ba22:	06 94       	mov	r4,r3
8000ba24:	fe b0 fd b6 	rcall	8000b590 <_Bfree>
8000ba28:	a1 56       	asr	r6,0x1
8000ba2a:	c0 b0       	breq	8000ba40 <__pow5mult+0x88>
8000ba2c:	6a 03       	ld.w	r3,r5[0x0]
8000ba2e:	58 03       	cp.w	r3,0
8000ba30:	ce d1       	brne	8000ba0a <__pow5mult+0x52>
8000ba32:	0a 9a       	mov	r10,r5
8000ba34:	0a 9b       	mov	r11,r5
8000ba36:	0e 9c       	mov	r12,r7
8000ba38:	cf ae       	rcall	8000b82c <__multiply>
8000ba3a:	8b 0c       	st.w	r5[0x0],r12
8000ba3c:	99 03       	st.w	r12[0x0],r3
8000ba3e:	ce 7b       	rjmp	8000ba0c <__pow5mult+0x54>
8000ba40:	08 9c       	mov	r12,r4
8000ba42:	d8 32       	popm	r0-r7,pc

8000ba44 <__isinfd>:
8000ba44:	14 98       	mov	r8,r10
8000ba46:	fc 19 7f f0 	movh	r9,0x7ff0
8000ba4a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ba4e:	f0 0b 11 00 	rsub	r11,r8,0
8000ba52:	f7 e8 10 08 	or	r8,r11,r8
8000ba56:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000ba5a:	f2 08 01 08 	sub	r8,r9,r8
8000ba5e:	f0 0c 11 00 	rsub	r12,r8,0
8000ba62:	f9 e8 10 08 	or	r8,r12,r8
8000ba66:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000ba6a:	2f fc       	sub	r12,-1
8000ba6c:	5e fc       	retal	r12

8000ba6e <__isnand>:
8000ba6e:	14 98       	mov	r8,r10
8000ba70:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000ba74:	f0 0c 11 00 	rsub	r12,r8,0
8000ba78:	10 4c       	or	r12,r8
8000ba7a:	fc 18 7f f0 	movh	r8,0x7ff0
8000ba7e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000ba82:	f0 0c 01 0c 	sub	r12,r8,r12
8000ba86:	bf 9c       	lsr	r12,0x1f
8000ba88:	5e fc       	retal	r12
8000ba8a:	d7 03       	nop

8000ba8c <__sclose>:
8000ba8c:	d4 01       	pushm	lr
8000ba8e:	96 7b       	ld.sh	r11,r11[0xe]
8000ba90:	c8 2c       	rcall	8000bb94 <_close_r>
8000ba92:	d8 02       	popm	pc

8000ba94 <__sseek>:
8000ba94:	d4 21       	pushm	r4-r7,lr
8000ba96:	16 97       	mov	r7,r11
8000ba98:	96 7b       	ld.sh	r11,r11[0xe]
8000ba9a:	c0 3d       	rcall	8000bca0 <_lseek_r>
8000ba9c:	8e 68       	ld.sh	r8,r7[0xc]
8000ba9e:	10 99       	mov	r9,r8
8000baa0:	ad c8       	cbr	r8,0xc
8000baa2:	ad a9       	sbr	r9,0xc
8000baa4:	5b fc       	cp.w	r12,-1
8000baa6:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000baaa:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000baae:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bab2:	d8 22       	popm	r4-r7,pc

8000bab4 <__swrite>:
8000bab4:	d4 21       	pushm	r4-r7,lr
8000bab6:	96 68       	ld.sh	r8,r11[0xc]
8000bab8:	16 97       	mov	r7,r11
8000baba:	14 95       	mov	r5,r10
8000babc:	12 94       	mov	r4,r9
8000babe:	e2 18 01 00 	andl	r8,0x100,COH
8000bac2:	18 96       	mov	r6,r12
8000bac4:	c0 50       	breq	8000bace <__swrite+0x1a>
8000bac6:	30 29       	mov	r9,2
8000bac8:	30 0a       	mov	r10,0
8000baca:	96 7b       	ld.sh	r11,r11[0xe]
8000bacc:	ce ac       	rcall	8000bca0 <_lseek_r>
8000bace:	8e 68       	ld.sh	r8,r7[0xc]
8000bad0:	ad c8       	cbr	r8,0xc
8000bad2:	08 99       	mov	r9,r4
8000bad4:	0a 9a       	mov	r10,r5
8000bad6:	8e 7b       	ld.sh	r11,r7[0xe]
8000bad8:	0c 9c       	mov	r12,r6
8000bada:	ae 68       	st.h	r7[0xc],r8
8000badc:	c1 cc       	rcall	8000bb14 <_write_r>
8000bade:	d8 22       	popm	r4-r7,pc

8000bae0 <__sread>:
8000bae0:	d4 21       	pushm	r4-r7,lr
8000bae2:	16 97       	mov	r7,r11
8000bae4:	96 7b       	ld.sh	r11,r11[0xe]
8000bae6:	cf 1c       	rcall	8000bcc8 <_read_r>
8000bae8:	c0 65       	brlt	8000baf4 <__sread+0x14>
8000baea:	6f 58       	ld.w	r8,r7[0x54]
8000baec:	18 08       	add	r8,r12
8000baee:	ef 48 00 54 	st.w	r7[84],r8
8000baf2:	d8 22       	popm	r4-r7,pc
8000baf4:	8e 68       	ld.sh	r8,r7[0xc]
8000baf6:	ad c8       	cbr	r8,0xc
8000baf8:	ae 68       	st.h	r7[0xc],r8
8000bafa:	d8 22       	popm	r4-r7,pc

8000bafc <strlen>:
8000bafc:	30 09       	mov	r9,0
8000bafe:	18 98       	mov	r8,r12
8000bb00:	c0 28       	rjmp	8000bb04 <strlen+0x8>
8000bb02:	2f f8       	sub	r8,-1
8000bb04:	11 8a       	ld.ub	r10,r8[0x0]
8000bb06:	f2 0a 18 00 	cp.b	r10,r9
8000bb0a:	cf c1       	brne	8000bb02 <strlen+0x6>
8000bb0c:	f0 0c 01 0c 	sub	r12,r8,r12
8000bb10:	5e fc       	retal	r12
8000bb12:	d7 03       	nop

8000bb14 <_write_r>:
8000bb14:	d4 21       	pushm	r4-r7,lr
8000bb16:	16 98       	mov	r8,r11
8000bb18:	18 97       	mov	r7,r12
8000bb1a:	10 9c       	mov	r12,r8
8000bb1c:	30 08       	mov	r8,0
8000bb1e:	14 9b       	mov	r11,r10
8000bb20:	e0 66 5b 6c 	mov	r6,23404
8000bb24:	12 9a       	mov	r10,r9
8000bb26:	8d 08       	st.w	r6[0x0],r8
8000bb28:	fe b0 d1 9e 	rcall	80005e64 <_write>
8000bb2c:	5b fc       	cp.w	r12,-1
8000bb2e:	c0 51       	brne	8000bb38 <_write_r+0x24>
8000bb30:	6c 08       	ld.w	r8,r6[0x0]
8000bb32:	58 08       	cp.w	r8,0
8000bb34:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bb38:	d8 22       	popm	r4-r7,pc
8000bb3a:	d7 03       	nop

8000bb3c <_calloc_r>:
8000bb3c:	d4 21       	pushm	r4-r7,lr
8000bb3e:	f4 0b 02 4b 	mul	r11,r10,r11
8000bb42:	fe b0 db 7f 	rcall	80007240 <_malloc_r>
8000bb46:	18 97       	mov	r7,r12
8000bb48:	c2 30       	breq	8000bb8e <_calloc_r+0x52>
8000bb4a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bb4e:	e0 1a ff fc 	andl	r10,0xfffc
8000bb52:	20 4a       	sub	r10,4
8000bb54:	e0 4a 00 24 	cp.w	r10,36
8000bb58:	e0 8b 00 18 	brhi	8000bb88 <_calloc_r+0x4c>
8000bb5c:	18 98       	mov	r8,r12
8000bb5e:	59 3a       	cp.w	r10,19
8000bb60:	e0 88 00 0f 	brls	8000bb7e <_calloc_r+0x42>
8000bb64:	30 09       	mov	r9,0
8000bb66:	10 a9       	st.w	r8++,r9
8000bb68:	10 a9       	st.w	r8++,r9
8000bb6a:	59 ba       	cp.w	r10,27
8000bb6c:	e0 88 00 09 	brls	8000bb7e <_calloc_r+0x42>
8000bb70:	10 a9       	st.w	r8++,r9
8000bb72:	10 a9       	st.w	r8++,r9
8000bb74:	e0 4a 00 24 	cp.w	r10,36
8000bb78:	c0 31       	brne	8000bb7e <_calloc_r+0x42>
8000bb7a:	10 a9       	st.w	r8++,r9
8000bb7c:	10 a9       	st.w	r8++,r9
8000bb7e:	30 09       	mov	r9,0
8000bb80:	10 a9       	st.w	r8++,r9
8000bb82:	91 19       	st.w	r8[0x4],r9
8000bb84:	91 09       	st.w	r8[0x0],r9
8000bb86:	c0 48       	rjmp	8000bb8e <_calloc_r+0x52>
8000bb88:	30 0b       	mov	r11,0
8000bb8a:	fe b0 de 1b 	rcall	800077c0 <memset>
8000bb8e:	0e 9c       	mov	r12,r7
8000bb90:	d8 22       	popm	r4-r7,pc
8000bb92:	d7 03       	nop

8000bb94 <_close_r>:
8000bb94:	d4 21       	pushm	r4-r7,lr
8000bb96:	30 08       	mov	r8,0
8000bb98:	18 97       	mov	r7,r12
8000bb9a:	e0 66 5b 6c 	mov	r6,23404
8000bb9e:	16 9c       	mov	r12,r11
8000bba0:	8d 08       	st.w	r6[0x0],r8
8000bba2:	fe b0 df b5 	rcall	80007b0c <_close>
8000bba6:	5b fc       	cp.w	r12,-1
8000bba8:	c0 51       	brne	8000bbb2 <_close_r+0x1e>
8000bbaa:	6c 08       	ld.w	r8,r6[0x0]
8000bbac:	58 08       	cp.w	r8,0
8000bbae:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bbb2:	d8 22       	popm	r4-r7,pc

8000bbb4 <_fclose_r>:
8000bbb4:	d4 21       	pushm	r4-r7,lr
8000bbb6:	18 96       	mov	r6,r12
8000bbb8:	16 97       	mov	r7,r11
8000bbba:	58 0b       	cp.w	r11,0
8000bbbc:	c0 31       	brne	8000bbc2 <_fclose_r+0xe>
8000bbbe:	16 95       	mov	r5,r11
8000bbc0:	c5 38       	rjmp	8000bc66 <_fclose_r+0xb2>
8000bbc2:	fe b0 f8 a9 	rcall	8000ad14 <__sfp_lock_acquire>
8000bbc6:	58 06       	cp.w	r6,0
8000bbc8:	c0 70       	breq	8000bbd6 <_fclose_r+0x22>
8000bbca:	6c 68       	ld.w	r8,r6[0x18]
8000bbcc:	58 08       	cp.w	r8,0
8000bbce:	c0 41       	brne	8000bbd6 <_fclose_r+0x22>
8000bbd0:	0c 9c       	mov	r12,r6
8000bbd2:	fe b0 f8 f3 	rcall	8000adb8 <__sinit>
8000bbd6:	fe c8 dc fe 	sub	r8,pc,-8962
8000bbda:	10 37       	cp.w	r7,r8
8000bbdc:	c0 31       	brne	8000bbe2 <_fclose_r+0x2e>
8000bbde:	6c 07       	ld.w	r7,r6[0x0]
8000bbe0:	c0 c8       	rjmp	8000bbf8 <_fclose_r+0x44>
8000bbe2:	fe c8 dc ea 	sub	r8,pc,-8982
8000bbe6:	10 37       	cp.w	r7,r8
8000bbe8:	c0 31       	brne	8000bbee <_fclose_r+0x3a>
8000bbea:	6c 17       	ld.w	r7,r6[0x4]
8000bbec:	c0 68       	rjmp	8000bbf8 <_fclose_r+0x44>
8000bbee:	fe c8 dc d6 	sub	r8,pc,-9002
8000bbf2:	10 37       	cp.w	r7,r8
8000bbf4:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bbf8:	8e 69       	ld.sh	r9,r7[0xc]
8000bbfa:	30 08       	mov	r8,0
8000bbfc:	f0 09 19 00 	cp.h	r9,r8
8000bc00:	c0 51       	brne	8000bc0a <_fclose_r+0x56>
8000bc02:	fe b0 f8 8a 	rcall	8000ad16 <__sfp_lock_release>
8000bc06:	30 05       	mov	r5,0
8000bc08:	c2 f8       	rjmp	8000bc66 <_fclose_r+0xb2>
8000bc0a:	0e 9b       	mov	r11,r7
8000bc0c:	0c 9c       	mov	r12,r6
8000bc0e:	fe b0 f7 fd 	rcall	8000ac08 <_fflush_r>
8000bc12:	6e c8       	ld.w	r8,r7[0x30]
8000bc14:	18 95       	mov	r5,r12
8000bc16:	58 08       	cp.w	r8,0
8000bc18:	c0 60       	breq	8000bc24 <_fclose_r+0x70>
8000bc1a:	6e 8b       	ld.w	r11,r7[0x20]
8000bc1c:	0c 9c       	mov	r12,r6
8000bc1e:	5d 18       	icall	r8
8000bc20:	f9 b5 05 ff 	movlt	r5,-1
8000bc24:	8e 68       	ld.sh	r8,r7[0xc]
8000bc26:	ed b8 00 07 	bld	r8,0x7
8000bc2a:	c0 51       	brne	8000bc34 <_fclose_r+0x80>
8000bc2c:	6e 4b       	ld.w	r11,r7[0x10]
8000bc2e:	0c 9c       	mov	r12,r6
8000bc30:	fe b0 f9 5e 	rcall	8000aeec <_free_r>
8000bc34:	6e db       	ld.w	r11,r7[0x34]
8000bc36:	58 0b       	cp.w	r11,0
8000bc38:	c0 a0       	breq	8000bc4c <_fclose_r+0x98>
8000bc3a:	ee c8 ff bc 	sub	r8,r7,-68
8000bc3e:	10 3b       	cp.w	r11,r8
8000bc40:	c0 40       	breq	8000bc48 <_fclose_r+0x94>
8000bc42:	0c 9c       	mov	r12,r6
8000bc44:	fe b0 f9 54 	rcall	8000aeec <_free_r>
8000bc48:	30 08       	mov	r8,0
8000bc4a:	8f d8       	st.w	r7[0x34],r8
8000bc4c:	6f 2b       	ld.w	r11,r7[0x48]
8000bc4e:	58 0b       	cp.w	r11,0
8000bc50:	c0 70       	breq	8000bc5e <_fclose_r+0xaa>
8000bc52:	0c 9c       	mov	r12,r6
8000bc54:	fe b0 f9 4c 	rcall	8000aeec <_free_r>
8000bc58:	30 08       	mov	r8,0
8000bc5a:	ef 48 00 48 	st.w	r7[72],r8
8000bc5e:	30 08       	mov	r8,0
8000bc60:	ae 68       	st.h	r7[0xc],r8
8000bc62:	fe b0 f8 5a 	rcall	8000ad16 <__sfp_lock_release>
8000bc66:	0a 9c       	mov	r12,r5
8000bc68:	d8 22       	popm	r4-r7,pc
8000bc6a:	d7 03       	nop

8000bc6c <fclose>:
8000bc6c:	d4 01       	pushm	lr
8000bc6e:	e0 68 0a 3c 	mov	r8,2620
8000bc72:	18 9b       	mov	r11,r12
8000bc74:	70 0c       	ld.w	r12,r8[0x0]
8000bc76:	c9 ff       	rcall	8000bbb4 <_fclose_r>
8000bc78:	d8 02       	popm	pc
8000bc7a:	d7 03       	nop

8000bc7c <_fstat_r>:
8000bc7c:	d4 21       	pushm	r4-r7,lr
8000bc7e:	16 98       	mov	r8,r11
8000bc80:	18 97       	mov	r7,r12
8000bc82:	10 9c       	mov	r12,r8
8000bc84:	30 08       	mov	r8,0
8000bc86:	e0 66 5b 6c 	mov	r6,23404
8000bc8a:	14 9b       	mov	r11,r10
8000bc8c:	8d 08       	st.w	r6[0x0],r8
8000bc8e:	fe b0 df 67 	rcall	80007b5c <_fstat>
8000bc92:	5b fc       	cp.w	r12,-1
8000bc94:	c0 51       	brne	8000bc9e <_fstat_r+0x22>
8000bc96:	6c 08       	ld.w	r8,r6[0x0]
8000bc98:	58 08       	cp.w	r8,0
8000bc9a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bc9e:	d8 22       	popm	r4-r7,pc

8000bca0 <_lseek_r>:
8000bca0:	d4 21       	pushm	r4-r7,lr
8000bca2:	16 98       	mov	r8,r11
8000bca4:	18 97       	mov	r7,r12
8000bca6:	10 9c       	mov	r12,r8
8000bca8:	30 08       	mov	r8,0
8000bcaa:	14 9b       	mov	r11,r10
8000bcac:	e0 66 5b 6c 	mov	r6,23404
8000bcb0:	12 9a       	mov	r10,r9
8000bcb2:	8d 08       	st.w	r6[0x0],r8
8000bcb4:	fe b0 df 36 	rcall	80007b20 <_lseek>
8000bcb8:	5b fc       	cp.w	r12,-1
8000bcba:	c0 51       	brne	8000bcc4 <_lseek_r+0x24>
8000bcbc:	6c 08       	ld.w	r8,r6[0x0]
8000bcbe:	58 08       	cp.w	r8,0
8000bcc0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bcc4:	d8 22       	popm	r4-r7,pc
8000bcc6:	d7 03       	nop

8000bcc8 <_read_r>:
8000bcc8:	d4 21       	pushm	r4-r7,lr
8000bcca:	16 98       	mov	r8,r11
8000bccc:	18 97       	mov	r7,r12
8000bcce:	10 9c       	mov	r12,r8
8000bcd0:	30 08       	mov	r8,0
8000bcd2:	14 9b       	mov	r11,r10
8000bcd4:	e0 66 5b 6c 	mov	r6,23404
8000bcd8:	12 9a       	mov	r10,r9
8000bcda:	8d 08       	st.w	r6[0x0],r8
8000bcdc:	fe b0 d0 a4 	rcall	80005e24 <_read>
8000bce0:	5b fc       	cp.w	r12,-1
8000bce2:	c0 51       	brne	8000bcec <_read_r+0x24>
8000bce4:	6c 08       	ld.w	r8,r6[0x0]
8000bce6:	58 08       	cp.w	r8,0
8000bce8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bcec:	d8 22       	popm	r4-r7,pc
8000bcee:	d7 03       	nop

8000bcf0 <__avr32_f64_mul>:
8000bcf0:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000bcf4:	e0 80 00 dc 	breq	8000beac <__avr32_f64_mul_op1_zero>
8000bcf8:	d4 21       	pushm	r4-r7,lr
8000bcfa:	f7 e9 20 0e 	eor	lr,r11,r9
8000bcfe:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000bd02:	30 15       	mov	r5,1
8000bd04:	c4 30       	breq	8000bd8a <__avr32_f64_mul_op1_subnormal>
8000bd06:	ab 6b       	lsl	r11,0xa
8000bd08:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000bd0c:	ab 6a       	lsl	r10,0xa
8000bd0e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000bd12:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000bd16:	c5 c0       	breq	8000bdce <__avr32_f64_mul_op2_subnormal>
8000bd18:	a1 78       	lsl	r8,0x1
8000bd1a:	5c f9       	rol	r9
8000bd1c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000bd20:	e0 47 07 ff 	cp.w	r7,2047
8000bd24:	c7 70       	breq	8000be12 <__avr32_f64_mul_op_nan_or_inf>
8000bd26:	e0 46 07 ff 	cp.w	r6,2047
8000bd2a:	c7 40       	breq	8000be12 <__avr32_f64_mul_op_nan_or_inf>
8000bd2c:	ee 06 00 0c 	add	r12,r7,r6
8000bd30:	e0 2c 03 fe 	sub	r12,1022
8000bd34:	f6 08 06 44 	mulu.d	r4,r11,r8
8000bd38:	f4 09 07 44 	macu.d	r4,r10,r9
8000bd3c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000bd40:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000bd44:	08 07       	add	r7,r4
8000bd46:	f4 05 00 4a 	adc	r10,r10,r5
8000bd4a:	5c 0b       	acr	r11
8000bd4c:	ed bb 00 14 	bld	r11,0x14
8000bd50:	c0 50       	breq	8000bd5a <__avr32_f64_mul+0x6a>
8000bd52:	a1 77       	lsl	r7,0x1
8000bd54:	5c fa       	rol	r10
8000bd56:	5c fb       	rol	r11
8000bd58:	20 1c       	sub	r12,1
8000bd5a:	58 0c       	cp.w	r12,0
8000bd5c:	e0 8a 00 6f 	brle	8000be3a <__avr32_f64_mul_res_subnormal>
8000bd60:	e0 4c 07 ff 	cp.w	r12,2047
8000bd64:	e0 84 00 9c 	brge	8000be9c <__avr32_f64_mul_res_inf>
8000bd68:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000bd6c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000bd70:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000bd74:	ee 17 80 00 	eorh	r7,0x8000
8000bd78:	f1 b7 04 20 	satu	r7,0x1
8000bd7c:	0e 0a       	add	r10,r7
8000bd7e:	5c 0b       	acr	r11
8000bd80:	ed be 00 1f 	bld	lr,0x1f
8000bd84:	ef bb 00 1f 	bst	r11,0x1f
8000bd88:	d8 22       	popm	r4-r7,pc

8000bd8a <__avr32_f64_mul_op1_subnormal>:
8000bd8a:	e4 1b 00 0f 	andh	r11,0xf
8000bd8e:	f4 0c 12 00 	clz	r12,r10
8000bd92:	f6 06 12 00 	clz	r6,r11
8000bd96:	f7 bc 03 e1 	sublo	r12,-31
8000bd9a:	f8 06 17 30 	movlo	r6,r12
8000bd9e:	f7 b6 02 01 	subhs	r6,1
8000bda2:	e0 46 00 20 	cp.w	r6,32
8000bda6:	c0 d4       	brge	8000bdc0 <__avr32_f64_mul_op1_subnormal+0x36>
8000bda8:	ec 0c 11 20 	rsub	r12,r6,32
8000bdac:	f6 06 09 4b 	lsl	r11,r11,r6
8000bdb0:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000bdb4:	18 4b       	or	r11,r12
8000bdb6:	f4 06 09 4a 	lsl	r10,r10,r6
8000bdba:	20 b6       	sub	r6,11
8000bdbc:	0c 17       	sub	r7,r6
8000bdbe:	ca ab       	rjmp	8000bd12 <__avr32_f64_mul+0x22>
8000bdc0:	f4 06 09 4b 	lsl	r11,r10,r6
8000bdc4:	c6 40       	breq	8000be8c <__avr32_f64_mul_res_zero>
8000bdc6:	30 0a       	mov	r10,0
8000bdc8:	20 b6       	sub	r6,11
8000bdca:	0c 17       	sub	r7,r6
8000bdcc:	ca 3b       	rjmp	8000bd12 <__avr32_f64_mul+0x22>

8000bdce <__avr32_f64_mul_op2_subnormal>:
8000bdce:	e4 19 00 0f 	andh	r9,0xf
8000bdd2:	f0 0c 12 00 	clz	r12,r8
8000bdd6:	f2 05 12 00 	clz	r5,r9
8000bdda:	f7 bc 03 ea 	sublo	r12,-22
8000bdde:	f8 05 17 30 	movlo	r5,r12
8000bde2:	f7 b5 02 0a 	subhs	r5,10
8000bde6:	e0 45 00 20 	cp.w	r5,32
8000bdea:	c0 d4       	brge	8000be04 <__avr32_f64_mul_op2_subnormal+0x36>
8000bdec:	ea 0c 11 20 	rsub	r12,r5,32
8000bdf0:	f2 05 09 49 	lsl	r9,r9,r5
8000bdf4:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000bdf8:	18 49       	or	r9,r12
8000bdfa:	f0 05 09 48 	lsl	r8,r8,r5
8000bdfe:	20 25       	sub	r5,2
8000be00:	0a 16       	sub	r6,r5
8000be02:	c8 fb       	rjmp	8000bd20 <__avr32_f64_mul+0x30>
8000be04:	f0 05 09 49 	lsl	r9,r8,r5
8000be08:	c4 20       	breq	8000be8c <__avr32_f64_mul_res_zero>
8000be0a:	30 08       	mov	r8,0
8000be0c:	20 25       	sub	r5,2
8000be0e:	0a 16       	sub	r6,r5
8000be10:	c8 8b       	rjmp	8000bd20 <__avr32_f64_mul+0x30>

8000be12 <__avr32_f64_mul_op_nan_or_inf>:
8000be12:	e4 19 00 0f 	andh	r9,0xf
8000be16:	e4 1b 00 0f 	andh	r11,0xf
8000be1a:	14 4b       	or	r11,r10
8000be1c:	10 49       	or	r9,r8
8000be1e:	e0 47 07 ff 	cp.w	r7,2047
8000be22:	c0 91       	brne	8000be34 <__avr32_f64_mul_op1_not_naninf>
8000be24:	58 0b       	cp.w	r11,0
8000be26:	c3 81       	brne	8000be96 <__avr32_f64_mul_res_nan>
8000be28:	e0 46 07 ff 	cp.w	r6,2047
8000be2c:	c3 81       	brne	8000be9c <__avr32_f64_mul_res_inf>
8000be2e:	58 09       	cp.w	r9,0
8000be30:	c3 60       	breq	8000be9c <__avr32_f64_mul_res_inf>
8000be32:	c3 28       	rjmp	8000be96 <__avr32_f64_mul_res_nan>

8000be34 <__avr32_f64_mul_op1_not_naninf>:
8000be34:	58 09       	cp.w	r9,0
8000be36:	c3 30       	breq	8000be9c <__avr32_f64_mul_res_inf>
8000be38:	c2 f8       	rjmp	8000be96 <__avr32_f64_mul_res_nan>

8000be3a <__avr32_f64_mul_res_subnormal>:
8000be3a:	5c 3c       	neg	r12
8000be3c:	2f fc       	sub	r12,-1
8000be3e:	f1 bc 04 c0 	satu	r12,0x6
8000be42:	e0 4c 00 20 	cp.w	r12,32
8000be46:	c1 14       	brge	8000be68 <__avr32_f64_mul_res_subnormal+0x2e>
8000be48:	f8 08 11 20 	rsub	r8,r12,32
8000be4c:	0e 46       	or	r6,r7
8000be4e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000be52:	f4 08 09 49 	lsl	r9,r10,r8
8000be56:	12 47       	or	r7,r9
8000be58:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000be5c:	f6 08 09 49 	lsl	r9,r11,r8
8000be60:	12 4a       	or	r10,r9
8000be62:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000be66:	c8 3b       	rjmp	8000bd6c <__avr32_f64_mul+0x7c>
8000be68:	f8 08 11 20 	rsub	r8,r12,32
8000be6c:	f9 b9 00 00 	moveq	r9,0
8000be70:	c0 30       	breq	8000be76 <__avr32_f64_mul_res_subnormal+0x3c>
8000be72:	f6 08 09 49 	lsl	r9,r11,r8
8000be76:	0e 46       	or	r6,r7
8000be78:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000be7c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000be80:	f3 ea 10 07 	or	r7,r9,r10
8000be84:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000be88:	30 0b       	mov	r11,0
8000be8a:	c7 1b       	rjmp	8000bd6c <__avr32_f64_mul+0x7c>

8000be8c <__avr32_f64_mul_res_zero>:
8000be8c:	1c 9b       	mov	r11,lr
8000be8e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000be92:	30 0a       	mov	r10,0
8000be94:	d8 22       	popm	r4-r7,pc

8000be96 <__avr32_f64_mul_res_nan>:
8000be96:	3f fb       	mov	r11,-1
8000be98:	3f fa       	mov	r10,-1
8000be9a:	d8 22       	popm	r4-r7,pc

8000be9c <__avr32_f64_mul_res_inf>:
8000be9c:	f0 6b 00 00 	mov	r11,-1048576
8000bea0:	ed be 00 1f 	bld	lr,0x1f
8000bea4:	ef bb 00 1f 	bst	r11,0x1f
8000bea8:	30 0a       	mov	r10,0
8000beaa:	d8 22       	popm	r4-r7,pc

8000beac <__avr32_f64_mul_op1_zero>:
8000beac:	f7 e9 20 0b 	eor	r11,r11,r9
8000beb0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000beb4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000beb8:	e0 4c 07 ff 	cp.w	r12,2047
8000bebc:	5e 1c       	retne	r12
8000bebe:	3f fa       	mov	r10,-1
8000bec0:	3f fb       	mov	r11,-1
8000bec2:	5e fc       	retal	r12

8000bec4 <__avr32_f64_sub_from_add>:
8000bec4:	ee 19 80 00 	eorh	r9,0x8000

8000bec8 <__avr32_f64_sub>:
8000bec8:	f7 e9 20 0c 	eor	r12,r11,r9
8000becc:	e0 86 00 ca 	brmi	8000c060 <__avr32_f64_add_from_sub>
8000bed0:	eb cd 40 e0 	pushm	r5-r7,lr
8000bed4:	16 9c       	mov	r12,r11
8000bed6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000beda:	bf db       	cbr	r11,0x1f
8000bedc:	bf d9       	cbr	r9,0x1f
8000bede:	10 3a       	cp.w	r10,r8
8000bee0:	f2 0b 13 00 	cpc	r11,r9
8000bee4:	c0 92       	brcc	8000bef6 <__avr32_f64_sub+0x2e>
8000bee6:	16 97       	mov	r7,r11
8000bee8:	12 9b       	mov	r11,r9
8000beea:	0e 99       	mov	r9,r7
8000beec:	14 97       	mov	r7,r10
8000beee:	10 9a       	mov	r10,r8
8000bef0:	0e 98       	mov	r8,r7
8000bef2:	ee 1c 80 00 	eorh	r12,0x8000
8000bef6:	f6 07 16 14 	lsr	r7,r11,0x14
8000befa:	ab 7b       	lsl	r11,0xb
8000befc:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000bf00:	ab 7a       	lsl	r10,0xb
8000bf02:	bf bb       	sbr	r11,0x1f
8000bf04:	f2 06 16 14 	lsr	r6,r9,0x14
8000bf08:	c4 40       	breq	8000bf90 <__avr32_f64_sub_opL_subnormal>
8000bf0a:	ab 79       	lsl	r9,0xb
8000bf0c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bf10:	ab 78       	lsl	r8,0xb
8000bf12:	bf b9       	sbr	r9,0x1f

8000bf14 <__avr32_f64_sub_opL_subnormal_done>:
8000bf14:	e0 47 07 ff 	cp.w	r7,2047
8000bf18:	c4 f0       	breq	8000bfb6 <__avr32_f64_sub_opH_nan_or_inf>
8000bf1a:	0e 26       	rsub	r6,r7
8000bf1c:	c1 20       	breq	8000bf40 <__avr32_f64_sub_shift_done>
8000bf1e:	ec 05 11 20 	rsub	r5,r6,32
8000bf22:	e0 46 00 20 	cp.w	r6,32
8000bf26:	c7 c2       	brcc	8000c01e <__avr32_f64_sub_longshift>
8000bf28:	f0 05 09 4e 	lsl	lr,r8,r5
8000bf2c:	f2 05 09 45 	lsl	r5,r9,r5
8000bf30:	f0 06 0a 48 	lsr	r8,r8,r6
8000bf34:	f2 06 0a 49 	lsr	r9,r9,r6
8000bf38:	0a 48       	or	r8,r5
8000bf3a:	58 0e       	cp.w	lr,0
8000bf3c:	5f 1e       	srne	lr
8000bf3e:	1c 48       	or	r8,lr

8000bf40 <__avr32_f64_sub_shift_done>:
8000bf40:	10 1a       	sub	r10,r8
8000bf42:	f6 09 01 4b 	sbc	r11,r11,r9
8000bf46:	f6 06 12 00 	clz	r6,r11
8000bf4a:	c0 e0       	breq	8000bf66 <__avr32_f64_sub_longnormalize_done>
8000bf4c:	c7 83       	brcs	8000c03c <__avr32_f64_sub_longnormalize>
8000bf4e:	ec 0e 11 20 	rsub	lr,r6,32
8000bf52:	f6 06 09 4b 	lsl	r11,r11,r6
8000bf56:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000bf5a:	1c 4b       	or	r11,lr
8000bf5c:	f4 06 09 4a 	lsl	r10,r10,r6
8000bf60:	0c 17       	sub	r7,r6
8000bf62:	e0 8a 00 39 	brle	8000bfd4 <__avr32_f64_sub_subnormal_result>

8000bf66 <__avr32_f64_sub_longnormalize_done>:
8000bf66:	f4 09 15 15 	lsl	r9,r10,0x15
8000bf6a:	ab 9a       	lsr	r10,0xb
8000bf6c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000bf70:	ab 9b       	lsr	r11,0xb
8000bf72:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000bf76:	18 4b       	or	r11,r12

8000bf78 <__avr32_f64_sub_round>:
8000bf78:	fc 17 80 00 	movh	r7,0x8000
8000bf7c:	ed ba 00 00 	bld	r10,0x0
8000bf80:	f7 b7 01 ff 	subne	r7,-1
8000bf84:	0e 39       	cp.w	r9,r7
8000bf86:	5f 29       	srhs	r9
8000bf88:	12 0a       	add	r10,r9
8000bf8a:	5c 0b       	acr	r11
8000bf8c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bf90 <__avr32_f64_sub_opL_subnormal>:
8000bf90:	ab 79       	lsl	r9,0xb
8000bf92:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000bf96:	ab 78       	lsl	r8,0xb
8000bf98:	f3 e8 10 0e 	or	lr,r9,r8
8000bf9c:	f9 b6 01 01 	movne	r6,1
8000bfa0:	ee 0e 11 00 	rsub	lr,r7,0
8000bfa4:	f9 b7 00 01 	moveq	r7,1
8000bfa8:	ef bb 00 1f 	bst	r11,0x1f
8000bfac:	f7 ea 10 0e 	or	lr,r11,r10
8000bfb0:	f9 b7 00 00 	moveq	r7,0
8000bfb4:	cb 0b       	rjmp	8000bf14 <__avr32_f64_sub_opL_subnormal_done>

8000bfb6 <__avr32_f64_sub_opH_nan_or_inf>:
8000bfb6:	bf db       	cbr	r11,0x1f
8000bfb8:	f7 ea 10 0e 	or	lr,r11,r10
8000bfbc:	c0 81       	brne	8000bfcc <__avr32_f64_sub_return_nan>
8000bfbe:	e0 46 07 ff 	cp.w	r6,2047
8000bfc2:	c0 50       	breq	8000bfcc <__avr32_f64_sub_return_nan>
8000bfc4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000bfc8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bfcc <__avr32_f64_sub_return_nan>:
8000bfcc:	3f fa       	mov	r10,-1
8000bfce:	3f fb       	mov	r11,-1
8000bfd0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000bfd4 <__avr32_f64_sub_subnormal_result>:
8000bfd4:	5c 37       	neg	r7
8000bfd6:	2f f7       	sub	r7,-1
8000bfd8:	f1 b7 04 c0 	satu	r7,0x6
8000bfdc:	e0 47 00 20 	cp.w	r7,32
8000bfe0:	c1 14       	brge	8000c002 <__avr32_f64_sub_subnormal_result+0x2e>
8000bfe2:	ee 08 11 20 	rsub	r8,r7,32
8000bfe6:	f4 08 09 49 	lsl	r9,r10,r8
8000bfea:	5f 16       	srne	r6
8000bfec:	f4 07 0a 4a 	lsr	r10,r10,r7
8000bff0:	0c 4a       	or	r10,r6
8000bff2:	f6 08 09 49 	lsl	r9,r11,r8
8000bff6:	f5 e9 10 0a 	or	r10,r10,r9
8000bffa:	f4 07 0a 4b 	lsr	r11,r10,r7
8000bffe:	30 07       	mov	r7,0
8000c000:	cb 3b       	rjmp	8000bf66 <__avr32_f64_sub_longnormalize_done>
8000c002:	ee 08 11 40 	rsub	r8,r7,64
8000c006:	f6 08 09 49 	lsl	r9,r11,r8
8000c00a:	14 49       	or	r9,r10
8000c00c:	5f 16       	srne	r6
8000c00e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c012:	0c 4a       	or	r10,r6
8000c014:	30 0b       	mov	r11,0
8000c016:	30 07       	mov	r7,0
8000c018:	ca 7b       	rjmp	8000bf66 <__avr32_f64_sub_longnormalize_done>
8000c01a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c01e <__avr32_f64_sub_longshift>:
8000c01e:	f1 b6 04 c0 	satu	r6,0x6
8000c022:	f0 0e 17 00 	moveq	lr,r8
8000c026:	c0 40       	breq	8000c02e <__avr32_f64_sub_longshift+0x10>
8000c028:	f2 05 09 4e 	lsl	lr,r9,r5
8000c02c:	10 4e       	or	lr,r8
8000c02e:	f2 06 0a 48 	lsr	r8,r9,r6
8000c032:	30 09       	mov	r9,0
8000c034:	58 0e       	cp.w	lr,0
8000c036:	5f 1e       	srne	lr
8000c038:	1c 48       	or	r8,lr
8000c03a:	c8 3b       	rjmp	8000bf40 <__avr32_f64_sub_shift_done>

8000c03c <__avr32_f64_sub_longnormalize>:
8000c03c:	f4 06 12 00 	clz	r6,r10
8000c040:	f9 b7 03 00 	movlo	r7,0
8000c044:	f9 b6 03 00 	movlo	r6,0
8000c048:	f9 bc 03 00 	movlo	r12,0
8000c04c:	f7 b6 02 e0 	subhs	r6,-32
8000c050:	f4 06 09 4b 	lsl	r11,r10,r6
8000c054:	30 0a       	mov	r10,0
8000c056:	0c 17       	sub	r7,r6
8000c058:	fe 9a ff be 	brle	8000bfd4 <__avr32_f64_sub_subnormal_result>
8000c05c:	c8 5b       	rjmp	8000bf66 <__avr32_f64_sub_longnormalize_done>
8000c05e:	d7 03       	nop

8000c060 <__avr32_f64_add_from_sub>:
8000c060:	ee 19 80 00 	eorh	r9,0x8000

8000c064 <__avr32_f64_add>:
8000c064:	f7 e9 20 0c 	eor	r12,r11,r9
8000c068:	fe 96 ff 2e 	brmi	8000bec4 <__avr32_f64_sub_from_add>
8000c06c:	eb cd 40 e0 	pushm	r5-r7,lr
8000c070:	16 9c       	mov	r12,r11
8000c072:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c076:	bf db       	cbr	r11,0x1f
8000c078:	bf d9       	cbr	r9,0x1f
8000c07a:	12 3b       	cp.w	r11,r9
8000c07c:	c0 72       	brcc	8000c08a <__avr32_f64_add+0x26>
8000c07e:	16 97       	mov	r7,r11
8000c080:	12 9b       	mov	r11,r9
8000c082:	0e 99       	mov	r9,r7
8000c084:	14 97       	mov	r7,r10
8000c086:	10 9a       	mov	r10,r8
8000c088:	0e 98       	mov	r8,r7
8000c08a:	30 0e       	mov	lr,0
8000c08c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c090:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c094:	b5 ab       	sbr	r11,0x14
8000c096:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c09a:	c6 20       	breq	8000c15e <__avr32_f64_add_op2_subnormal>
8000c09c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c0a0:	b5 a9       	sbr	r9,0x14
8000c0a2:	e0 47 07 ff 	cp.w	r7,2047
8000c0a6:	c2 80       	breq	8000c0f6 <__avr32_f64_add_opH_nan_or_inf>
8000c0a8:	0e 26       	rsub	r6,r7
8000c0aa:	c1 20       	breq	8000c0ce <__avr32_f64_add_shift_done>
8000c0ac:	e0 46 00 36 	cp.w	r6,54
8000c0b0:	c1 52       	brcc	8000c0da <__avr32_f64_add_res_of_done>
8000c0b2:	ec 05 11 20 	rsub	r5,r6,32
8000c0b6:	e0 46 00 20 	cp.w	r6,32
8000c0ba:	c3 52       	brcc	8000c124 <__avr32_f64_add_longshift>
8000c0bc:	f0 05 09 4e 	lsl	lr,r8,r5
8000c0c0:	f2 05 09 45 	lsl	r5,r9,r5
8000c0c4:	f0 06 0a 48 	lsr	r8,r8,r6
8000c0c8:	f2 06 0a 49 	lsr	r9,r9,r6
8000c0cc:	0a 48       	or	r8,r5

8000c0ce <__avr32_f64_add_shift_done>:
8000c0ce:	10 0a       	add	r10,r8
8000c0d0:	f6 09 00 4b 	adc	r11,r11,r9
8000c0d4:	ed bb 00 15 	bld	r11,0x15
8000c0d8:	c3 40       	breq	8000c140 <__avr32_f64_add_res_of>

8000c0da <__avr32_f64_add_res_of_done>:
8000c0da:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c0de:	18 4b       	or	r11,r12

8000c0e0 <__avr32_f64_add_round>:
8000c0e0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c0e4:	18 4e       	or	lr,r12
8000c0e6:	ee 1e 80 00 	eorh	lr,0x8000
8000c0ea:	f1 be 04 20 	satu	lr,0x1
8000c0ee:	1c 0a       	add	r10,lr
8000c0f0:	5c 0b       	acr	r11
8000c0f2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c0f6 <__avr32_f64_add_opH_nan_or_inf>:
8000c0f6:	b5 cb       	cbr	r11,0x14
8000c0f8:	f7 ea 10 0e 	or	lr,r11,r10
8000c0fc:	c1 01       	brne	8000c11c <__avr32_f64_add_return_nan>
8000c0fe:	e0 46 07 ff 	cp.w	r6,2047
8000c102:	c0 30       	breq	8000c108 <__avr32_f64_add_opL_nan_or_inf>
8000c104:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c108 <__avr32_f64_add_opL_nan_or_inf>:
8000c108:	b5 c9       	cbr	r9,0x14
8000c10a:	f3 e8 10 0e 	or	lr,r9,r8
8000c10e:	c0 71       	brne	8000c11c <__avr32_f64_add_return_nan>
8000c110:	30 0a       	mov	r10,0
8000c112:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c116:	18 4b       	or	r11,r12
8000c118:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c11c <__avr32_f64_add_return_nan>:
8000c11c:	3f fa       	mov	r10,-1
8000c11e:	3f fb       	mov	r11,-1
8000c120:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c124 <__avr32_f64_add_longshift>:
8000c124:	f1 b6 04 c0 	satu	r6,0x6
8000c128:	f0 0e 17 00 	moveq	lr,r8
8000c12c:	c0 60       	breq	8000c138 <__avr32_f64_add_longshift+0x14>
8000c12e:	f2 05 09 4e 	lsl	lr,r9,r5
8000c132:	58 08       	cp.w	r8,0
8000c134:	5f 18       	srne	r8
8000c136:	10 4e       	or	lr,r8
8000c138:	f2 06 0a 48 	lsr	r8,r9,r6
8000c13c:	30 09       	mov	r9,0
8000c13e:	cc 8b       	rjmp	8000c0ce <__avr32_f64_add_shift_done>

8000c140 <__avr32_f64_add_res_of>:
8000c140:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c144:	a1 9b       	lsr	r11,0x1
8000c146:	5d 0a       	ror	r10
8000c148:	5d 0e       	ror	lr
8000c14a:	2f f7       	sub	r7,-1
8000c14c:	e0 47 07 ff 	cp.w	r7,2047
8000c150:	f9 ba 00 00 	moveq	r10,0
8000c154:	f9 bb 00 00 	moveq	r11,0
8000c158:	f9 be 00 00 	moveq	lr,0
8000c15c:	cb fb       	rjmp	8000c0da <__avr32_f64_add_res_of_done>

8000c15e <__avr32_f64_add_op2_subnormal>:
8000c15e:	30 16       	mov	r6,1
8000c160:	58 07       	cp.w	r7,0
8000c162:	ca 01       	brne	8000c0a2 <__avr32_f64_add+0x3e>
8000c164:	b5 cb       	cbr	r11,0x14
8000c166:	10 0a       	add	r10,r8
8000c168:	f6 09 00 4b 	adc	r11,r11,r9
8000c16c:	18 4b       	or	r11,r12
8000c16e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c172:	d7 03       	nop

8000c174 <__avr32_f64_to_u32>:
8000c174:	58 0b       	cp.w	r11,0
8000c176:	5e 6d       	retmi	0

8000c178 <__avr32_f64_to_s32>:
8000c178:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c17c:	b5 9c       	lsr	r12,0x15
8000c17e:	e0 2c 03 ff 	sub	r12,1023
8000c182:	5e 3d       	retlo	0
8000c184:	f8 0c 11 1f 	rsub	r12,r12,31
8000c188:	16 99       	mov	r9,r11
8000c18a:	ab 7b       	lsl	r11,0xb
8000c18c:	bf bb       	sbr	r11,0x1f
8000c18e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c192:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c196:	a1 79       	lsl	r9,0x1
8000c198:	5e 2b       	reths	r11
8000c19a:	5c 3b       	neg	r11
8000c19c:	5e fb       	retal	r11

8000c19e <__avr32_u32_to_f64>:
8000c19e:	f8 cb 00 00 	sub	r11,r12,0
8000c1a2:	30 0c       	mov	r12,0
8000c1a4:	c0 38       	rjmp	8000c1aa <__avr32_s32_to_f64+0x4>

8000c1a6 <__avr32_s32_to_f64>:
8000c1a6:	18 9b       	mov	r11,r12
8000c1a8:	5c 4b       	abs	r11
8000c1aa:	30 0a       	mov	r10,0
8000c1ac:	5e 0b       	reteq	r11
8000c1ae:	d4 01       	pushm	lr
8000c1b0:	e0 69 04 1e 	mov	r9,1054
8000c1b4:	f6 08 12 00 	clz	r8,r11
8000c1b8:	c1 70       	breq	8000c1e6 <__avr32_s32_to_f64+0x40>
8000c1ba:	c0 c3       	brcs	8000c1d2 <__avr32_s32_to_f64+0x2c>
8000c1bc:	f0 0e 11 20 	rsub	lr,r8,32
8000c1c0:	f6 08 09 4b 	lsl	r11,r11,r8
8000c1c4:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c1c8:	1c 4b       	or	r11,lr
8000c1ca:	f4 08 09 4a 	lsl	r10,r10,r8
8000c1ce:	10 19       	sub	r9,r8
8000c1d0:	c0 b8       	rjmp	8000c1e6 <__avr32_s32_to_f64+0x40>
8000c1d2:	f4 08 12 00 	clz	r8,r10
8000c1d6:	f9 b8 03 00 	movlo	r8,0
8000c1da:	f7 b8 02 e0 	subhs	r8,-32
8000c1de:	f4 08 09 4b 	lsl	r11,r10,r8
8000c1e2:	30 0a       	mov	r10,0
8000c1e4:	10 19       	sub	r9,r8
8000c1e6:	58 09       	cp.w	r9,0
8000c1e8:	e0 89 00 30 	brgt	8000c248 <__avr32_s32_to_f64+0xa2>
8000c1ec:	5c 39       	neg	r9
8000c1ee:	2f f9       	sub	r9,-1
8000c1f0:	e0 49 00 36 	cp.w	r9,54
8000c1f4:	c0 43       	brcs	8000c1fc <__avr32_s32_to_f64+0x56>
8000c1f6:	30 0b       	mov	r11,0
8000c1f8:	30 0a       	mov	r10,0
8000c1fa:	c2 68       	rjmp	8000c246 <__avr32_s32_to_f64+0xa0>
8000c1fc:	2f 69       	sub	r9,-10
8000c1fe:	f2 08 11 20 	rsub	r8,r9,32
8000c202:	e0 49 00 20 	cp.w	r9,32
8000c206:	c0 b2       	brcc	8000c21c <__avr32_s32_to_f64+0x76>
8000c208:	f4 08 09 4e 	lsl	lr,r10,r8
8000c20c:	f6 08 09 48 	lsl	r8,r11,r8
8000c210:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c214:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c218:	10 4b       	or	r11,r8
8000c21a:	c0 88       	rjmp	8000c22a <__avr32_s32_to_f64+0x84>
8000c21c:	f6 08 09 4e 	lsl	lr,r11,r8
8000c220:	14 4e       	or	lr,r10
8000c222:	16 9a       	mov	r10,r11
8000c224:	30 0b       	mov	r11,0
8000c226:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c22a:	ed ba 00 00 	bld	r10,0x0
8000c22e:	c0 92       	brcc	8000c240 <__avr32_s32_to_f64+0x9a>
8000c230:	1c 7e       	tst	lr,lr
8000c232:	c0 41       	brne	8000c23a <__avr32_s32_to_f64+0x94>
8000c234:	ed ba 00 01 	bld	r10,0x1
8000c238:	c0 42       	brcc	8000c240 <__avr32_s32_to_f64+0x9a>
8000c23a:	2f fa       	sub	r10,-1
8000c23c:	f7 bb 02 ff 	subhs	r11,-1
8000c240:	5c fc       	rol	r12
8000c242:	5d 0b       	ror	r11
8000c244:	5d 0a       	ror	r10
8000c246:	d8 02       	popm	pc
8000c248:	e0 68 03 ff 	mov	r8,1023
8000c24c:	ed ba 00 0b 	bld	r10,0xb
8000c250:	f7 b8 00 ff 	subeq	r8,-1
8000c254:	10 0a       	add	r10,r8
8000c256:	5c 0b       	acr	r11
8000c258:	f7 b9 03 fe 	sublo	r9,-2
8000c25c:	e0 49 07 ff 	cp.w	r9,2047
8000c260:	c0 55       	brlt	8000c26a <__avr32_s32_to_f64+0xc4>
8000c262:	30 0a       	mov	r10,0
8000c264:	fc 1b ff e0 	movh	r11,0xffe0
8000c268:	c0 c8       	rjmp	8000c280 <__floatsidf_return_op1>
8000c26a:	ed bb 00 1f 	bld	r11,0x1f
8000c26e:	f7 b9 01 01 	subne	r9,1
8000c272:	ab 9a       	lsr	r10,0xb
8000c274:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c278:	a1 7b       	lsl	r11,0x1
8000c27a:	ab 9b       	lsr	r11,0xb
8000c27c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c280 <__floatsidf_return_op1>:
8000c280:	a1 7c       	lsl	r12,0x1
8000c282:	5d 0b       	ror	r11
8000c284:	d8 02       	popm	pc

8000c286 <__avr32_f64_cmp_eq>:
8000c286:	10 3a       	cp.w	r10,r8
8000c288:	f2 0b 13 00 	cpc	r11,r9
8000c28c:	c0 80       	breq	8000c29c <__avr32_f64_cmp_eq+0x16>
8000c28e:	a1 7b       	lsl	r11,0x1
8000c290:	a1 79       	lsl	r9,0x1
8000c292:	14 4b       	or	r11,r10
8000c294:	12 4b       	or	r11,r9
8000c296:	10 4b       	or	r11,r8
8000c298:	5e 0f       	reteq	1
8000c29a:	5e fd       	retal	0
8000c29c:	a1 7b       	lsl	r11,0x1
8000c29e:	fc 1c ff e0 	movh	r12,0xffe0
8000c2a2:	58 0a       	cp.w	r10,0
8000c2a4:	f8 0b 13 00 	cpc	r11,r12
8000c2a8:	5e 8f       	retls	1
8000c2aa:	5e fd       	retal	0

8000c2ac <__avr32_f64_cmp_ge>:
8000c2ac:	1a de       	st.w	--sp,lr
8000c2ae:	1a d7       	st.w	--sp,r7
8000c2b0:	a1 7b       	lsl	r11,0x1
8000c2b2:	5f 3c       	srlo	r12
8000c2b4:	a1 79       	lsl	r9,0x1
8000c2b6:	5f 37       	srlo	r7
8000c2b8:	5c fc       	rol	r12
8000c2ba:	fc 1e ff e0 	movh	lr,0xffe0
8000c2be:	58 0a       	cp.w	r10,0
8000c2c0:	fc 0b 13 00 	cpc	r11,lr
8000c2c4:	e0 8b 00 1d 	brhi	8000c2fe <__avr32_f64_cmp_ge+0x52>
8000c2c8:	58 08       	cp.w	r8,0
8000c2ca:	fc 09 13 00 	cpc	r9,lr
8000c2ce:	e0 8b 00 18 	brhi	8000c2fe <__avr32_f64_cmp_ge+0x52>
8000c2d2:	58 0b       	cp.w	r11,0
8000c2d4:	f5 ba 00 00 	subfeq	r10,0
8000c2d8:	c1 50       	breq	8000c302 <__avr32_f64_cmp_ge+0x56>
8000c2da:	1b 07       	ld.w	r7,sp++
8000c2dc:	1b 0e       	ld.w	lr,sp++
8000c2de:	58 3c       	cp.w	r12,3
8000c2e0:	c0 a0       	breq	8000c2f4 <__avr32_f64_cmp_ge+0x48>
8000c2e2:	58 1c       	cp.w	r12,1
8000c2e4:	c0 33       	brcs	8000c2ea <__avr32_f64_cmp_ge+0x3e>
8000c2e6:	5e 0f       	reteq	1
8000c2e8:	5e 1d       	retne	0
8000c2ea:	10 3a       	cp.w	r10,r8
8000c2ec:	f2 0b 13 00 	cpc	r11,r9
8000c2f0:	5e 2f       	reths	1
8000c2f2:	5e 3d       	retlo	0
8000c2f4:	14 38       	cp.w	r8,r10
8000c2f6:	f6 09 13 00 	cpc	r9,r11
8000c2fa:	5e 2f       	reths	1
8000c2fc:	5e 3d       	retlo	0
8000c2fe:	1b 07       	ld.w	r7,sp++
8000c300:	d8 0a       	popm	pc,r12=0
8000c302:	58 17       	cp.w	r7,1
8000c304:	5f 0c       	sreq	r12
8000c306:	58 09       	cp.w	r9,0
8000c308:	f5 b8 00 00 	subfeq	r8,0
8000c30c:	1b 07       	ld.w	r7,sp++
8000c30e:	1b 0e       	ld.w	lr,sp++
8000c310:	5e 0f       	reteq	1
8000c312:	5e fc       	retal	r12

8000c314 <__avr32_f64_cmp_lt>:
8000c314:	1a de       	st.w	--sp,lr
8000c316:	1a d7       	st.w	--sp,r7
8000c318:	a1 7b       	lsl	r11,0x1
8000c31a:	5f 3c       	srlo	r12
8000c31c:	a1 79       	lsl	r9,0x1
8000c31e:	5f 37       	srlo	r7
8000c320:	5c fc       	rol	r12
8000c322:	fc 1e ff e0 	movh	lr,0xffe0
8000c326:	58 0a       	cp.w	r10,0
8000c328:	fc 0b 13 00 	cpc	r11,lr
8000c32c:	e0 8b 00 1d 	brhi	8000c366 <__avr32_f64_cmp_lt+0x52>
8000c330:	58 08       	cp.w	r8,0
8000c332:	fc 09 13 00 	cpc	r9,lr
8000c336:	e0 8b 00 18 	brhi	8000c366 <__avr32_f64_cmp_lt+0x52>
8000c33a:	58 0b       	cp.w	r11,0
8000c33c:	f5 ba 00 00 	subfeq	r10,0
8000c340:	c1 50       	breq	8000c36a <__avr32_f64_cmp_lt+0x56>
8000c342:	1b 07       	ld.w	r7,sp++
8000c344:	1b 0e       	ld.w	lr,sp++
8000c346:	58 3c       	cp.w	r12,3
8000c348:	c0 a0       	breq	8000c35c <__avr32_f64_cmp_lt+0x48>
8000c34a:	58 1c       	cp.w	r12,1
8000c34c:	c0 33       	brcs	8000c352 <__avr32_f64_cmp_lt+0x3e>
8000c34e:	5e 0d       	reteq	0
8000c350:	5e 1f       	retne	1
8000c352:	10 3a       	cp.w	r10,r8
8000c354:	f2 0b 13 00 	cpc	r11,r9
8000c358:	5e 2d       	reths	0
8000c35a:	5e 3f       	retlo	1
8000c35c:	14 38       	cp.w	r8,r10
8000c35e:	f6 09 13 00 	cpc	r9,r11
8000c362:	5e 2d       	reths	0
8000c364:	5e 3f       	retlo	1
8000c366:	1b 07       	ld.w	r7,sp++
8000c368:	d8 0a       	popm	pc,r12=0
8000c36a:	58 17       	cp.w	r7,1
8000c36c:	5f 1c       	srne	r12
8000c36e:	58 09       	cp.w	r9,0
8000c370:	f5 b8 00 00 	subfeq	r8,0
8000c374:	1b 07       	ld.w	r7,sp++
8000c376:	1b 0e       	ld.w	lr,sp++
8000c378:	5e 0d       	reteq	0
8000c37a:	5e fc       	retal	r12

8000c37c <__avr32_f64_div>:
8000c37c:	eb cd 40 ff 	pushm	r0-r7,lr
8000c380:	f7 e9 20 0e 	eor	lr,r11,r9
8000c384:	f6 07 16 14 	lsr	r7,r11,0x14
8000c388:	a9 7b       	lsl	r11,0x9
8000c38a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c38e:	a9 7a       	lsl	r10,0x9
8000c390:	bd bb       	sbr	r11,0x1d
8000c392:	e4 1b 3f ff 	andh	r11,0x3fff
8000c396:	ab d7       	cbr	r7,0xb
8000c398:	e0 80 00 cc 	breq	8000c530 <__avr32_f64_div_round_subnormal+0x54>
8000c39c:	e0 47 07 ff 	cp.w	r7,2047
8000c3a0:	e0 84 00 b5 	brge	8000c50a <__avr32_f64_div_round_subnormal+0x2e>
8000c3a4:	f2 06 16 14 	lsr	r6,r9,0x14
8000c3a8:	a9 79       	lsl	r9,0x9
8000c3aa:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c3ae:	a9 78       	lsl	r8,0x9
8000c3b0:	bd b9       	sbr	r9,0x1d
8000c3b2:	e4 19 3f ff 	andh	r9,0x3fff
8000c3b6:	ab d6       	cbr	r6,0xb
8000c3b8:	e0 80 00 e2 	breq	8000c57c <__avr32_f64_div_round_subnormal+0xa0>
8000c3bc:	e0 46 07 ff 	cp.w	r6,2047
8000c3c0:	e0 84 00 b2 	brge	8000c524 <__avr32_f64_div_round_subnormal+0x48>
8000c3c4:	0c 17       	sub	r7,r6
8000c3c6:	fe 37 fc 01 	sub	r7,-1023
8000c3ca:	fc 1c 80 00 	movh	r12,0x8000
8000c3ce:	f8 03 16 01 	lsr	r3,r12,0x1
8000c3d2:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c3d6:	5c d4       	com	r4
8000c3d8:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c3dc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3e0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c3e4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3e8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3ec:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c3f0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c3f4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c3f8:	ea 03 15 02 	lsl	r3,r5,0x2
8000c3fc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c400:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c404:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c408:	ea 03 15 02 	lsl	r3,r5,0x2
8000c40c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c410:	e4 09 07 40 	macu.d	r0,r2,r9
8000c414:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c418:	02 04       	add	r4,r1
8000c41a:	5c 05       	acr	r5
8000c41c:	a3 65       	lsl	r5,0x2
8000c41e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c422:	a3 64       	lsl	r4,0x2
8000c424:	5c 34       	neg	r4
8000c426:	f8 05 01 45 	sbc	r5,r12,r5
8000c42a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c42e:	e4 05 07 40 	macu.d	r0,r2,r5
8000c432:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c436:	02 04       	add	r4,r1
8000c438:	5c 05       	acr	r5
8000c43a:	ea 03 15 02 	lsl	r3,r5,0x2
8000c43e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c442:	e8 02 15 02 	lsl	r2,r4,0x2
8000c446:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c44a:	e4 09 07 40 	macu.d	r0,r2,r9
8000c44e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c452:	02 04       	add	r4,r1
8000c454:	5c 05       	acr	r5
8000c456:	a3 65       	lsl	r5,0x2
8000c458:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c45c:	a3 64       	lsl	r4,0x2
8000c45e:	5c 34       	neg	r4
8000c460:	f8 05 01 45 	sbc	r5,r12,r5
8000c464:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c468:	e4 05 07 40 	macu.d	r0,r2,r5
8000c46c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c470:	02 04       	add	r4,r1
8000c472:	5c 05       	acr	r5
8000c474:	ea 03 15 02 	lsl	r3,r5,0x2
8000c478:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c47c:	e8 02 15 02 	lsl	r2,r4,0x2
8000c480:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c484:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c488:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c48c:	02 02       	add	r2,r1
8000c48e:	5c 03       	acr	r3
8000c490:	ed b3 00 1c 	bld	r3,0x1c
8000c494:	c0 90       	breq	8000c4a6 <__avr32_f64_div+0x12a>
8000c496:	a1 72       	lsl	r2,0x1
8000c498:	5c f3       	rol	r3
8000c49a:	20 17       	sub	r7,1
8000c49c:	a3 9a       	lsr	r10,0x3
8000c49e:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c4a2:	a3 9b       	lsr	r11,0x3
8000c4a4:	c0 58       	rjmp	8000c4ae <__avr32_f64_div+0x132>
8000c4a6:	a5 8a       	lsr	r10,0x4
8000c4a8:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c4ac:	a5 8b       	lsr	r11,0x4
8000c4ae:	58 07       	cp.w	r7,0
8000c4b0:	e0 8a 00 8b 	brle	8000c5c6 <__avr32_f64_div_res_subnormal>
8000c4b4:	e0 12 ff 00 	andl	r2,0xff00
8000c4b8:	e8 12 00 80 	orl	r2,0x80
8000c4bc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c4c0:	e4 09 07 40 	macu.d	r0,r2,r9
8000c4c4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c4c8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c4cc:	00 05       	add	r5,r0
8000c4ce:	f0 01 00 48 	adc	r8,r8,r1
8000c4d2:	5c 09       	acr	r9
8000c4d4:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c4d8:	58 04       	cp.w	r4,0
8000c4da:	5c 25       	cpc	r5

8000c4dc <__avr32_f64_div_round_subnormal>:
8000c4dc:	f4 08 13 00 	cpc	r8,r10
8000c4e0:	f6 09 13 00 	cpc	r9,r11
8000c4e4:	5f 36       	srlo	r6
8000c4e6:	f8 06 17 00 	moveq	r6,r12
8000c4ea:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c4ee:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c4f2:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c4f6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c4fa:	ed be 00 1f 	bld	lr,0x1f
8000c4fe:	ef bb 00 1f 	bst	r11,0x1f
8000c502:	0c 0a       	add	r10,r6
8000c504:	5c 0b       	acr	r11
8000c506:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c50a:	e4 1b 00 0f 	andh	r11,0xf
8000c50e:	14 4b       	or	r11,r10
8000c510:	e0 81 00 a7 	brne	8000c65e <__avr32_f64_div_res_subnormal+0x98>
8000c514:	f2 06 16 14 	lsr	r6,r9,0x14
8000c518:	ab d6       	cbr	r6,0xb
8000c51a:	e0 46 07 ff 	cp.w	r6,2047
8000c51e:	e0 81 00 a4 	brne	8000c666 <__avr32_f64_div_res_subnormal+0xa0>
8000c522:	c9 e8       	rjmp	8000c65e <__avr32_f64_div_res_subnormal+0x98>
8000c524:	e4 19 00 0f 	andh	r9,0xf
8000c528:	10 49       	or	r9,r8
8000c52a:	e0 81 00 9a 	brne	8000c65e <__avr32_f64_div_res_subnormal+0x98>
8000c52e:	c9 28       	rjmp	8000c652 <__avr32_f64_div_res_subnormal+0x8c>
8000c530:	a3 7b       	lsl	r11,0x3
8000c532:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c536:	a3 7a       	lsl	r10,0x3
8000c538:	f5 eb 10 04 	or	r4,r10,r11
8000c53c:	e0 80 00 a0 	breq	8000c67c <__avr32_f64_div_op1_zero>
8000c540:	f6 04 12 00 	clz	r4,r11
8000c544:	c1 70       	breq	8000c572 <__avr32_f64_div_round_subnormal+0x96>
8000c546:	c0 c3       	brcs	8000c55e <__avr32_f64_div_round_subnormal+0x82>
8000c548:	e8 05 11 20 	rsub	r5,r4,32
8000c54c:	f6 04 09 4b 	lsl	r11,r11,r4
8000c550:	f4 05 0a 45 	lsr	r5,r10,r5
8000c554:	0a 4b       	or	r11,r5
8000c556:	f4 04 09 4a 	lsl	r10,r10,r4
8000c55a:	08 17       	sub	r7,r4
8000c55c:	c0 b8       	rjmp	8000c572 <__avr32_f64_div_round_subnormal+0x96>
8000c55e:	f4 04 12 00 	clz	r4,r10
8000c562:	f9 b4 03 00 	movlo	r4,0
8000c566:	f7 b4 02 e0 	subhs	r4,-32
8000c56a:	f4 04 09 4b 	lsl	r11,r10,r4
8000c56e:	30 0a       	mov	r10,0
8000c570:	08 17       	sub	r7,r4
8000c572:	a3 8a       	lsr	r10,0x2
8000c574:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c578:	a3 8b       	lsr	r11,0x2
8000c57a:	c1 1b       	rjmp	8000c39c <__avr32_f64_div+0x20>
8000c57c:	a3 79       	lsl	r9,0x3
8000c57e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c582:	a3 78       	lsl	r8,0x3
8000c584:	f3 e8 10 04 	or	r4,r9,r8
8000c588:	c6 f0       	breq	8000c666 <__avr32_f64_div_res_subnormal+0xa0>
8000c58a:	f2 04 12 00 	clz	r4,r9
8000c58e:	c1 70       	breq	8000c5bc <__avr32_f64_div_round_subnormal+0xe0>
8000c590:	c0 c3       	brcs	8000c5a8 <__avr32_f64_div_round_subnormal+0xcc>
8000c592:	e8 05 11 20 	rsub	r5,r4,32
8000c596:	f2 04 09 49 	lsl	r9,r9,r4
8000c59a:	f0 05 0a 45 	lsr	r5,r8,r5
8000c59e:	0a 49       	or	r9,r5
8000c5a0:	f0 04 09 48 	lsl	r8,r8,r4
8000c5a4:	08 16       	sub	r6,r4
8000c5a6:	c0 b8       	rjmp	8000c5bc <__avr32_f64_div_round_subnormal+0xe0>
8000c5a8:	f0 04 12 00 	clz	r4,r8
8000c5ac:	f9 b4 03 00 	movlo	r4,0
8000c5b0:	f7 b4 02 e0 	subhs	r4,-32
8000c5b4:	f0 04 09 49 	lsl	r9,r8,r4
8000c5b8:	30 08       	mov	r8,0
8000c5ba:	08 16       	sub	r6,r4
8000c5bc:	a3 88       	lsr	r8,0x2
8000c5be:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c5c2:	a3 89       	lsr	r9,0x2
8000c5c4:	cf ca       	rjmp	8000c3bc <__avr32_f64_div+0x40>

8000c5c6 <__avr32_f64_div_res_subnormal>:
8000c5c6:	5c 37       	neg	r7
8000c5c8:	2f f7       	sub	r7,-1
8000c5ca:	f1 b7 04 c0 	satu	r7,0x6
8000c5ce:	e0 47 00 20 	cp.w	r7,32
8000c5d2:	c1 54       	brge	8000c5fc <__avr32_f64_div_res_subnormal+0x36>
8000c5d4:	ee 06 11 20 	rsub	r6,r7,32
8000c5d8:	e4 07 0a 42 	lsr	r2,r2,r7
8000c5dc:	e6 06 09 4c 	lsl	r12,r3,r6
8000c5e0:	18 42       	or	r2,r12
8000c5e2:	e6 07 0a 43 	lsr	r3,r3,r7
8000c5e6:	f4 06 09 41 	lsl	r1,r10,r6
8000c5ea:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c5ee:	f6 06 09 4c 	lsl	r12,r11,r6
8000c5f2:	18 4a       	or	r10,r12
8000c5f4:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c5f8:	30 00       	mov	r0,0
8000c5fa:	c1 58       	rjmp	8000c624 <__avr32_f64_div_res_subnormal+0x5e>
8000c5fc:	ee 06 11 20 	rsub	r6,r7,32
8000c600:	f9 b0 00 00 	moveq	r0,0
8000c604:	f9 bc 00 00 	moveq	r12,0
8000c608:	c0 50       	breq	8000c612 <__avr32_f64_div_res_subnormal+0x4c>
8000c60a:	f4 06 09 40 	lsl	r0,r10,r6
8000c60e:	f6 06 09 4c 	lsl	r12,r11,r6
8000c612:	e6 07 0a 42 	lsr	r2,r3,r7
8000c616:	30 03       	mov	r3,0
8000c618:	f4 07 0a 41 	lsr	r1,r10,r7
8000c61c:	18 41       	or	r1,r12
8000c61e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c622:	30 0b       	mov	r11,0
8000c624:	e0 12 ff 00 	andl	r2,0xff00
8000c628:	e8 12 00 80 	orl	r2,0x80
8000c62c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c630:	e4 09 07 46 	macu.d	r6,r2,r9
8000c634:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c638:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c63c:	0c 05       	add	r5,r6
8000c63e:	f0 07 00 48 	adc	r8,r8,r7
8000c642:	5c 09       	acr	r9
8000c644:	30 07       	mov	r7,0
8000c646:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c64a:	00 34       	cp.w	r4,r0
8000c64c:	e2 05 13 00 	cpc	r5,r1
8000c650:	c4 6b       	rjmp	8000c4dc <__avr32_f64_div_round_subnormal>
8000c652:	1c 9b       	mov	r11,lr
8000c654:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c658:	30 0a       	mov	r10,0
8000c65a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c65e:	3f fb       	mov	r11,-1
8000c660:	30 0a       	mov	r10,0
8000c662:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c666:	f5 eb 10 04 	or	r4,r10,r11
8000c66a:	c0 90       	breq	8000c67c <__avr32_f64_div_op1_zero>
8000c66c:	1c 9b       	mov	r11,lr
8000c66e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c672:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c676:	30 0a       	mov	r10,0
8000c678:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c67c <__avr32_f64_div_op1_zero>:
8000c67c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c680:	ce f0       	breq	8000c65e <__avr32_f64_div_res_subnormal+0x98>
8000c682:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c686:	e0 44 07 ff 	cp.w	r4,2047
8000c68a:	ce 41       	brne	8000c652 <__avr32_f64_div_res_subnormal+0x8c>
8000c68c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c690:	ce 10       	breq	8000c652 <__avr32_f64_div_res_subnormal+0x8c>
8000c692:	ce 6b       	rjmp	8000c65e <__avr32_f64_div_res_subnormal+0x98>

8000c694 <__avr32_udiv64>:
8000c694:	d4 31       	pushm	r0-r7,lr
8000c696:	1a 97       	mov	r7,sp
8000c698:	20 3d       	sub	sp,12
8000c69a:	10 9c       	mov	r12,r8
8000c69c:	12 9e       	mov	lr,r9
8000c69e:	14 93       	mov	r3,r10
8000c6a0:	58 09       	cp.w	r9,0
8000c6a2:	e0 81 00 bd 	brne	8000c81c <__avr32_udiv64+0x188>
8000c6a6:	16 38       	cp.w	r8,r11
8000c6a8:	e0 88 00 40 	brls	8000c728 <__avr32_udiv64+0x94>
8000c6ac:	f0 08 12 00 	clz	r8,r8
8000c6b0:	c0 d0       	breq	8000c6ca <__avr32_udiv64+0x36>
8000c6b2:	f6 08 09 4b 	lsl	r11,r11,r8
8000c6b6:	f0 09 11 20 	rsub	r9,r8,32
8000c6ba:	f8 08 09 4c 	lsl	r12,r12,r8
8000c6be:	f4 09 0a 49 	lsr	r9,r10,r9
8000c6c2:	f4 08 09 43 	lsl	r3,r10,r8
8000c6c6:	f3 eb 10 0b 	or	r11,r9,r11
8000c6ca:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c6ce:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c6d2:	f6 0e 0d 00 	divu	r0,r11,lr
8000c6d6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c6da:	00 99       	mov	r9,r0
8000c6dc:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c6e0:	e0 0a 02 48 	mul	r8,r0,r10
8000c6e4:	10 3b       	cp.w	r11,r8
8000c6e6:	c0 a2       	brcc	8000c6fa <__avr32_udiv64+0x66>
8000c6e8:	20 19       	sub	r9,1
8000c6ea:	18 0b       	add	r11,r12
8000c6ec:	18 3b       	cp.w	r11,r12
8000c6ee:	c0 63       	brcs	8000c6fa <__avr32_udiv64+0x66>
8000c6f0:	10 3b       	cp.w	r11,r8
8000c6f2:	f7 b9 03 01 	sublo	r9,1
8000c6f6:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c6fa:	f6 08 01 01 	sub	r1,r11,r8
8000c6fe:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c702:	e2 0e 0d 00 	divu	r0,r1,lr
8000c706:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c70a:	00 98       	mov	r8,r0
8000c70c:	e0 0a 02 4a 	mul	r10,r0,r10
8000c710:	14 33       	cp.w	r3,r10
8000c712:	c0 82       	brcc	8000c722 <__avr32_udiv64+0x8e>
8000c714:	20 18       	sub	r8,1
8000c716:	18 03       	add	r3,r12
8000c718:	18 33       	cp.w	r3,r12
8000c71a:	c0 43       	brcs	8000c722 <__avr32_udiv64+0x8e>
8000c71c:	14 33       	cp.w	r3,r10
8000c71e:	f7 b8 03 01 	sublo	r8,1
8000c722:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000c726:	cd f8       	rjmp	8000c8e4 <__avr32_udiv64+0x250>
8000c728:	58 08       	cp.w	r8,0
8000c72a:	c0 51       	brne	8000c734 <__avr32_udiv64+0xa0>
8000c72c:	30 19       	mov	r9,1
8000c72e:	f2 08 0d 08 	divu	r8,r9,r8
8000c732:	10 9c       	mov	r12,r8
8000c734:	f8 06 12 00 	clz	r6,r12
8000c738:	c0 41       	brne	8000c740 <__avr32_udiv64+0xac>
8000c73a:	18 1b       	sub	r11,r12
8000c73c:	30 19       	mov	r9,1
8000c73e:	c4 08       	rjmp	8000c7be <__avr32_udiv64+0x12a>
8000c740:	ec 01 11 20 	rsub	r1,r6,32
8000c744:	f4 01 0a 49 	lsr	r9,r10,r1
8000c748:	f8 06 09 4c 	lsl	r12,r12,r6
8000c74c:	f6 06 09 48 	lsl	r8,r11,r6
8000c750:	f6 01 0a 41 	lsr	r1,r11,r1
8000c754:	f3 e8 10 08 	or	r8,r9,r8
8000c758:	f8 03 16 10 	lsr	r3,r12,0x10
8000c75c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c760:	e2 03 0d 00 	divu	r0,r1,r3
8000c764:	f0 0b 16 10 	lsr	r11,r8,0x10
8000c768:	00 9e       	mov	lr,r0
8000c76a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c76e:	e0 05 02 49 	mul	r9,r0,r5
8000c772:	12 3b       	cp.w	r11,r9
8000c774:	c0 a2       	brcc	8000c788 <__avr32_udiv64+0xf4>
8000c776:	20 1e       	sub	lr,1
8000c778:	18 0b       	add	r11,r12
8000c77a:	18 3b       	cp.w	r11,r12
8000c77c:	c0 63       	brcs	8000c788 <__avr32_udiv64+0xf4>
8000c77e:	12 3b       	cp.w	r11,r9
8000c780:	f7 be 03 01 	sublo	lr,1
8000c784:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c788:	12 1b       	sub	r11,r9
8000c78a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000c78e:	f6 03 0d 02 	divu	r2,r11,r3
8000c792:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000c796:	04 99       	mov	r9,r2
8000c798:	e4 05 02 4b 	mul	r11,r2,r5
8000c79c:	16 38       	cp.w	r8,r11
8000c79e:	c0 a2       	brcc	8000c7b2 <__avr32_udiv64+0x11e>
8000c7a0:	20 19       	sub	r9,1
8000c7a2:	18 08       	add	r8,r12
8000c7a4:	18 38       	cp.w	r8,r12
8000c7a6:	c0 63       	brcs	8000c7b2 <__avr32_udiv64+0x11e>
8000c7a8:	16 38       	cp.w	r8,r11
8000c7aa:	f7 b9 03 01 	sublo	r9,1
8000c7ae:	f1 dc e3 08 	addcs	r8,r8,r12
8000c7b2:	f4 06 09 43 	lsl	r3,r10,r6
8000c7b6:	f0 0b 01 0b 	sub	r11,r8,r11
8000c7ba:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000c7be:	f8 06 16 10 	lsr	r6,r12,0x10
8000c7c2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000c7c6:	f6 06 0d 00 	divu	r0,r11,r6
8000c7ca:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c7ce:	00 9a       	mov	r10,r0
8000c7d0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c7d4:	e0 0e 02 48 	mul	r8,r0,lr
8000c7d8:	10 3b       	cp.w	r11,r8
8000c7da:	c0 a2       	brcc	8000c7ee <__avr32_udiv64+0x15a>
8000c7dc:	20 1a       	sub	r10,1
8000c7de:	18 0b       	add	r11,r12
8000c7e0:	18 3b       	cp.w	r11,r12
8000c7e2:	c0 63       	brcs	8000c7ee <__avr32_udiv64+0x15a>
8000c7e4:	10 3b       	cp.w	r11,r8
8000c7e6:	f7 ba 03 01 	sublo	r10,1
8000c7ea:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c7ee:	f6 08 01 01 	sub	r1,r11,r8
8000c7f2:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000c7f6:	e2 06 0d 00 	divu	r0,r1,r6
8000c7fa:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000c7fe:	00 98       	mov	r8,r0
8000c800:	e0 0e 02 4b 	mul	r11,r0,lr
8000c804:	16 33       	cp.w	r3,r11
8000c806:	c0 82       	brcc	8000c816 <__avr32_udiv64+0x182>
8000c808:	20 18       	sub	r8,1
8000c80a:	18 03       	add	r3,r12
8000c80c:	18 33       	cp.w	r3,r12
8000c80e:	c0 43       	brcs	8000c816 <__avr32_udiv64+0x182>
8000c810:	16 33       	cp.w	r3,r11
8000c812:	f7 b8 03 01 	sublo	r8,1
8000c816:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000c81a:	c6 98       	rjmp	8000c8ec <__avr32_udiv64+0x258>
8000c81c:	16 39       	cp.w	r9,r11
8000c81e:	e0 8b 00 65 	brhi	8000c8e8 <__avr32_udiv64+0x254>
8000c822:	f2 09 12 00 	clz	r9,r9
8000c826:	c0 b1       	brne	8000c83c <__avr32_udiv64+0x1a8>
8000c828:	10 3a       	cp.w	r10,r8
8000c82a:	5f 2a       	srhs	r10
8000c82c:	1c 3b       	cp.w	r11,lr
8000c82e:	5f b8       	srhi	r8
8000c830:	10 4a       	or	r10,r8
8000c832:	f2 0a 18 00 	cp.b	r10,r9
8000c836:	c5 90       	breq	8000c8e8 <__avr32_udiv64+0x254>
8000c838:	30 18       	mov	r8,1
8000c83a:	c5 98       	rjmp	8000c8ec <__avr32_udiv64+0x258>
8000c83c:	f0 09 09 46 	lsl	r6,r8,r9
8000c840:	f2 03 11 20 	rsub	r3,r9,32
8000c844:	fc 09 09 4e 	lsl	lr,lr,r9
8000c848:	f0 03 0a 48 	lsr	r8,r8,r3
8000c84c:	f6 09 09 4c 	lsl	r12,r11,r9
8000c850:	f4 03 0a 42 	lsr	r2,r10,r3
8000c854:	ef 46 ff f4 	st.w	r7[-12],r6
8000c858:	f6 03 0a 43 	lsr	r3,r11,r3
8000c85c:	18 42       	or	r2,r12
8000c85e:	f1 ee 10 0c 	or	r12,r8,lr
8000c862:	f8 01 16 10 	lsr	r1,r12,0x10
8000c866:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c86a:	e6 01 0d 04 	divu	r4,r3,r1
8000c86e:	e4 03 16 10 	lsr	r3,r2,0x10
8000c872:	08 9e       	mov	lr,r4
8000c874:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000c878:	e8 06 02 48 	mul	r8,r4,r6
8000c87c:	10 33       	cp.w	r3,r8
8000c87e:	c0 a2       	brcc	8000c892 <__avr32_udiv64+0x1fe>
8000c880:	20 1e       	sub	lr,1
8000c882:	18 03       	add	r3,r12
8000c884:	18 33       	cp.w	r3,r12
8000c886:	c0 63       	brcs	8000c892 <__avr32_udiv64+0x1fe>
8000c888:	10 33       	cp.w	r3,r8
8000c88a:	f7 be 03 01 	sublo	lr,1
8000c88e:	e7 dc e3 03 	addcs	r3,r3,r12
8000c892:	10 13       	sub	r3,r8
8000c894:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000c898:	e6 01 0d 00 	divu	r0,r3,r1
8000c89c:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c8a0:	00 98       	mov	r8,r0
8000c8a2:	e0 06 02 46 	mul	r6,r0,r6
8000c8a6:	0c 3b       	cp.w	r11,r6
8000c8a8:	c0 a2       	brcc	8000c8bc <__avr32_udiv64+0x228>
8000c8aa:	20 18       	sub	r8,1
8000c8ac:	18 0b       	add	r11,r12
8000c8ae:	18 3b       	cp.w	r11,r12
8000c8b0:	c0 63       	brcs	8000c8bc <__avr32_udiv64+0x228>
8000c8b2:	0c 3b       	cp.w	r11,r6
8000c8b4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000c8b8:	f7 b8 03 01 	sublo	r8,1
8000c8bc:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000c8c0:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000c8c4:	0c 1b       	sub	r11,r6
8000c8c6:	f0 04 06 42 	mulu.d	r2,r8,r4
8000c8ca:	06 95       	mov	r5,r3
8000c8cc:	16 35       	cp.w	r5,r11
8000c8ce:	e0 8b 00 0a 	brhi	8000c8e2 <__avr32_udiv64+0x24e>
8000c8d2:	5f 0b       	sreq	r11
8000c8d4:	f4 09 09 49 	lsl	r9,r10,r9
8000c8d8:	12 32       	cp.w	r2,r9
8000c8da:	5f b9       	srhi	r9
8000c8dc:	f7 e9 00 09 	and	r9,r11,r9
8000c8e0:	c0 60       	breq	8000c8ec <__avr32_udiv64+0x258>
8000c8e2:	20 18       	sub	r8,1
8000c8e4:	30 09       	mov	r9,0
8000c8e6:	c0 38       	rjmp	8000c8ec <__avr32_udiv64+0x258>
8000c8e8:	30 09       	mov	r9,0
8000c8ea:	12 98       	mov	r8,r9
8000c8ec:	10 9a       	mov	r10,r8
8000c8ee:	12 93       	mov	r3,r9
8000c8f0:	10 92       	mov	r2,r8
8000c8f2:	12 9b       	mov	r11,r9
8000c8f4:	2f dd       	sub	sp,-12
8000c8f6:	d8 32       	popm	r0-r7,pc

8000c8f8 <__avr32_umod64>:
8000c8f8:	d4 31       	pushm	r0-r7,lr
8000c8fa:	1a 97       	mov	r7,sp
8000c8fc:	20 3d       	sub	sp,12
8000c8fe:	10 9c       	mov	r12,r8
8000c900:	12 95       	mov	r5,r9
8000c902:	14 9e       	mov	lr,r10
8000c904:	16 91       	mov	r1,r11
8000c906:	16 96       	mov	r6,r11
8000c908:	58 09       	cp.w	r9,0
8000c90a:	e0 81 00 81 	brne	8000ca0c <__avr32_umod64+0x114>
8000c90e:	16 38       	cp.w	r8,r11
8000c910:	e0 88 00 12 	brls	8000c934 <__avr32_umod64+0x3c>
8000c914:	f0 08 12 00 	clz	r8,r8
8000c918:	c4 e0       	breq	8000c9b4 <__avr32_umod64+0xbc>
8000c91a:	f6 08 09 46 	lsl	r6,r11,r8
8000c91e:	f8 08 09 4c 	lsl	r12,r12,r8
8000c922:	f0 0b 11 20 	rsub	r11,r8,32
8000c926:	f4 08 09 4e 	lsl	lr,r10,r8
8000c92a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000c92e:	f7 e6 10 06 	or	r6,r11,r6
8000c932:	c4 18       	rjmp	8000c9b4 <__avr32_umod64+0xbc>
8000c934:	58 08       	cp.w	r8,0
8000c936:	c0 51       	brne	8000c940 <__avr32_umod64+0x48>
8000c938:	30 19       	mov	r9,1
8000c93a:	f2 08 0d 08 	divu	r8,r9,r8
8000c93e:	10 9c       	mov	r12,r8
8000c940:	f8 08 12 00 	clz	r8,r12
8000c944:	c0 31       	brne	8000c94a <__avr32_umod64+0x52>
8000c946:	18 16       	sub	r6,r12
8000c948:	c3 68       	rjmp	8000c9b4 <__avr32_umod64+0xbc>
8000c94a:	f0 03 11 20 	rsub	r3,r8,32
8000c94e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000c952:	f8 08 09 4c 	lsl	r12,r12,r8
8000c956:	ec 08 09 49 	lsl	r9,r6,r8
8000c95a:	ec 03 0a 43 	lsr	r3,r6,r3
8000c95e:	f7 e9 10 09 	or	r9,r11,r9
8000c962:	f8 05 16 10 	lsr	r5,r12,0x10
8000c966:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000c96a:	e6 05 0d 02 	divu	r2,r3,r5
8000c96e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000c972:	ec 02 02 4b 	mul	r11,r6,r2
8000c976:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000c97a:	16 3e       	cp.w	lr,r11
8000c97c:	c0 72       	brcc	8000c98a <__avr32_umod64+0x92>
8000c97e:	18 0e       	add	lr,r12
8000c980:	18 3e       	cp.w	lr,r12
8000c982:	c0 43       	brcs	8000c98a <__avr32_umod64+0x92>
8000c984:	16 3e       	cp.w	lr,r11
8000c986:	fd dc e3 0e 	addcs	lr,lr,r12
8000c98a:	fc 0b 01 03 	sub	r3,lr,r11
8000c98e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000c992:	e6 05 0d 02 	divu	r2,r3,r5
8000c996:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c99a:	a5 36       	mul	r6,r2
8000c99c:	0c 39       	cp.w	r9,r6
8000c99e:	c0 72       	brcc	8000c9ac <__avr32_umod64+0xb4>
8000c9a0:	18 09       	add	r9,r12
8000c9a2:	18 39       	cp.w	r9,r12
8000c9a4:	c0 43       	brcs	8000c9ac <__avr32_umod64+0xb4>
8000c9a6:	0c 39       	cp.w	r9,r6
8000c9a8:	f3 dc e3 09 	addcs	r9,r9,r12
8000c9ac:	f2 06 01 06 	sub	r6,r9,r6
8000c9b0:	f4 08 09 4e 	lsl	lr,r10,r8
8000c9b4:	f8 0a 16 10 	lsr	r10,r12,0x10
8000c9b8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000c9bc:	ec 0a 0d 02 	divu	r2,r6,r10
8000c9c0:	fc 09 16 10 	lsr	r9,lr,0x10
8000c9c4:	ea 02 02 4b 	mul	r11,r5,r2
8000c9c8:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000c9cc:	16 39       	cp.w	r9,r11
8000c9ce:	c0 72       	brcc	8000c9dc <__avr32_umod64+0xe4>
8000c9d0:	18 09       	add	r9,r12
8000c9d2:	18 39       	cp.w	r9,r12
8000c9d4:	c0 43       	brcs	8000c9dc <__avr32_umod64+0xe4>
8000c9d6:	16 39       	cp.w	r9,r11
8000c9d8:	f3 dc e3 09 	addcs	r9,r9,r12
8000c9dc:	f2 0b 01 0b 	sub	r11,r9,r11
8000c9e0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000c9e4:	f6 0a 0d 0a 	divu	r10,r11,r10
8000c9e8:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000c9ec:	ea 0a 02 4a 	mul	r10,r5,r10
8000c9f0:	14 3e       	cp.w	lr,r10
8000c9f2:	c0 72       	brcc	8000ca00 <__avr32_umod64+0x108>
8000c9f4:	18 0e       	add	lr,r12
8000c9f6:	18 3e       	cp.w	lr,r12
8000c9f8:	c0 43       	brcs	8000ca00 <__avr32_umod64+0x108>
8000c9fa:	14 3e       	cp.w	lr,r10
8000c9fc:	fd dc e3 0e 	addcs	lr,lr,r12
8000ca00:	fc 0a 01 0a 	sub	r10,lr,r10
8000ca04:	30 0b       	mov	r11,0
8000ca06:	f4 08 0a 4a 	lsr	r10,r10,r8
8000ca0a:	c7 b8       	rjmp	8000cb00 <__avr32_umod64+0x208>
8000ca0c:	16 39       	cp.w	r9,r11
8000ca0e:	e0 8b 00 79 	brhi	8000cb00 <__avr32_umod64+0x208>
8000ca12:	f2 09 12 00 	clz	r9,r9
8000ca16:	c1 21       	brne	8000ca3a <__avr32_umod64+0x142>
8000ca18:	10 3a       	cp.w	r10,r8
8000ca1a:	5f 2b       	srhs	r11
8000ca1c:	0a 31       	cp.w	r1,r5
8000ca1e:	5f ba       	srhi	r10
8000ca20:	f7 ea 10 0a 	or	r10,r11,r10
8000ca24:	f2 0a 18 00 	cp.b	r10,r9
8000ca28:	c0 60       	breq	8000ca34 <__avr32_umod64+0x13c>
8000ca2a:	fc 08 01 0c 	sub	r12,lr,r8
8000ca2e:	e2 05 01 46 	sbc	r6,r1,r5
8000ca32:	18 9e       	mov	lr,r12
8000ca34:	0c 9b       	mov	r11,r6
8000ca36:	1c 9a       	mov	r10,lr
8000ca38:	c6 48       	rjmp	8000cb00 <__avr32_umod64+0x208>
8000ca3a:	ea 09 09 4c 	lsl	r12,r5,r9
8000ca3e:	f2 06 11 20 	rsub	r6,r9,32
8000ca42:	f6 09 09 4b 	lsl	r11,r11,r9
8000ca46:	f0 09 09 42 	lsl	r2,r8,r9
8000ca4a:	ef 46 ff f4 	st.w	r7[-12],r6
8000ca4e:	f0 06 0a 48 	lsr	r8,r8,r6
8000ca52:	18 48       	or	r8,r12
8000ca54:	e2 06 0a 4c 	lsr	r12,r1,r6
8000ca58:	f4 09 09 43 	lsl	r3,r10,r9
8000ca5c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000ca60:	f4 06 0a 4a 	lsr	r10,r10,r6
8000ca64:	16 4a       	or	r10,r11
8000ca66:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ca6a:	f8 0b 0d 04 	divu	r4,r12,r11
8000ca6e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000ca72:	08 91       	mov	r1,r4
8000ca74:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000ca78:	e8 0e 02 46 	mul	r6,r4,lr
8000ca7c:	0c 3c       	cp.w	r12,r6
8000ca7e:	c0 a2       	brcc	8000ca92 <__avr32_umod64+0x19a>
8000ca80:	20 11       	sub	r1,1
8000ca82:	10 0c       	add	r12,r8
8000ca84:	10 3c       	cp.w	r12,r8
8000ca86:	c0 63       	brcs	8000ca92 <__avr32_umod64+0x19a>
8000ca88:	0c 3c       	cp.w	r12,r6
8000ca8a:	f7 b1 03 01 	sublo	r1,1
8000ca8e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000ca92:	0c 1c       	sub	r12,r6
8000ca94:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000ca98:	f8 0b 0d 04 	divu	r4,r12,r11
8000ca9c:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000caa0:	08 96       	mov	r6,r4
8000caa2:	e8 0e 02 4e 	mul	lr,r4,lr
8000caa6:	1c 3b       	cp.w	r11,lr
8000caa8:	c0 a2       	brcc	8000cabc <__avr32_umod64+0x1c4>
8000caaa:	20 16       	sub	r6,1
8000caac:	10 0b       	add	r11,r8
8000caae:	10 3b       	cp.w	r11,r8
8000cab0:	c0 63       	brcs	8000cabc <__avr32_umod64+0x1c4>
8000cab2:	1c 3b       	cp.w	r11,lr
8000cab4:	f7 b6 03 01 	sublo	r6,1
8000cab8:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cabc:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cac0:	1c 1b       	sub	r11,lr
8000cac2:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cac6:	00 9e       	mov	lr,r0
8000cac8:	02 9c       	mov	r12,r1
8000caca:	16 3c       	cp.w	r12,r11
8000cacc:	e0 8b 00 08 	brhi	8000cadc <__avr32_umod64+0x1e4>
8000cad0:	5f 06       	sreq	r6
8000cad2:	06 30       	cp.w	r0,r3
8000cad4:	5f ba       	srhi	r10
8000cad6:	ed ea 00 0a 	and	r10,r6,r10
8000cada:	c0 60       	breq	8000cae6 <__avr32_umod64+0x1ee>
8000cadc:	fc 02 01 04 	sub	r4,lr,r2
8000cae0:	f8 08 01 4c 	sbc	r12,r12,r8
8000cae4:	08 9e       	mov	lr,r4
8000cae6:	e6 0e 01 0a 	sub	r10,r3,lr
8000caea:	f6 0c 01 4c 	sbc	r12,r11,r12
8000caee:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000caf2:	f8 09 0a 4b 	lsr	r11,r12,r9
8000caf6:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cafa:	f8 01 09 4c 	lsl	r12,r12,r1
8000cafe:	18 4a       	or	r10,r12
8000cb00:	2f dd       	sub	sp,-12
8000cb02:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000cc00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000cc00:	c0 08       	rjmp	8000cc00 <_evba>
	...

8000cc04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000cc04:	c0 08       	rjmp	8000cc04 <_handle_TLB_Multiple_Hit>
	...

8000cc08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000cc08:	c0 08       	rjmp	8000cc08 <_handle_Bus_Error_Data_Fetch>
	...

8000cc0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000cc0c:	c0 08       	rjmp	8000cc0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000cc10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000cc10:	c0 08       	rjmp	8000cc10 <_handle_NMI>
	...

8000cc14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000cc14:	c0 08       	rjmp	8000cc14 <_handle_Instruction_Address>
	...

8000cc18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000cc18:	c0 08       	rjmp	8000cc18 <_handle_ITLB_Protection>
	...

8000cc1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000cc1c:	c0 08       	rjmp	8000cc1c <_handle_Breakpoint>
	...

8000cc20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000cc20:	c0 08       	rjmp	8000cc20 <_handle_Illegal_Opcode>
	...

8000cc24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000cc24:	c0 08       	rjmp	8000cc24 <_handle_Unimplemented_Instruction>
	...

8000cc28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000cc28:	c0 08       	rjmp	8000cc28 <_handle_Privilege_Violation>
	...

8000cc2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000cc2c:	c0 08       	rjmp	8000cc2c <_handle_Floating_Point>
	...

8000cc30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000cc30:	c0 08       	rjmp	8000cc30 <_handle_Coprocessor_Absent>
	...

8000cc34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000cc34:	c0 08       	rjmp	8000cc34 <_handle_Data_Address_Read>
	...

8000cc38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000cc38:	c0 08       	rjmp	8000cc38 <_handle_Data_Address_Write>
	...

8000cc3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000cc3c:	c0 08       	rjmp	8000cc3c <_handle_DTLB_Protection_Read>
	...

8000cc40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000cc40:	c0 08       	rjmp	8000cc40 <_handle_DTLB_Protection_Write>
	...

8000cc44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000cc44:	c0 08       	rjmp	8000cc44 <_handle_DTLB_Modified>
	...

8000cc50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000cc50:	c0 08       	rjmp	8000cc50 <_handle_ITLB_Miss>
	...

8000cc60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000cc60:	c0 08       	rjmp	8000cc60 <_handle_DTLB_Miss_Read>
	...

8000cc70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000cc70:	c0 08       	rjmp	8000cc70 <_handle_DTLB_Miss_Write>
	...

8000cd00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000cd00:	fe cf 70 3c 	sub	pc,pc,28732

8000cd04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000cd04:	30 0c       	mov	r12,0
8000cd06:	fe b0 c3 fd 	rcall	80005500 <_get_interrupt_handler>
8000cd0a:	58 0c       	cp.w	r12,0
8000cd0c:	f8 0f 17 10 	movne	pc,r12
8000cd10:	d6 03       	rete

8000cd12 <_int1>:
8000cd12:	30 1c       	mov	r12,1
8000cd14:	fe b0 c3 f6 	rcall	80005500 <_get_interrupt_handler>
8000cd18:	58 0c       	cp.w	r12,0
8000cd1a:	f8 0f 17 10 	movne	pc,r12
8000cd1e:	d6 03       	rete

8000cd20 <_int2>:
8000cd20:	30 2c       	mov	r12,2
8000cd22:	fe b0 c3 ef 	rcall	80005500 <_get_interrupt_handler>
8000cd26:	58 0c       	cp.w	r12,0
8000cd28:	f8 0f 17 10 	movne	pc,r12
8000cd2c:	d6 03       	rete

8000cd2e <_int3>:
8000cd2e:	30 3c       	mov	r12,3
8000cd30:	fe b0 c3 e8 	rcall	80005500 <_get_interrupt_handler>
8000cd34:	58 0c       	cp.w	r12,0
8000cd36:	f8 0f 17 10 	movne	pc,r12
8000cd3a:	d6 03       	rete

8000cd3c <ipr_val>:
8000cd3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000cd4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cd9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cddc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000cdfc:	d7 03 d7 03                                         ....
