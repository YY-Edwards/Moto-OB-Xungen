
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000ae14  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000d000  8000d000  0000d400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000012e0  8000d200  8000d200  0000d600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a40  00000004  8000e4e0  0000ec04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a44  8000ef20  0000f644  2**0
                  ALLOC
  7 .bss          00004988  00000a48  8000ef20  0000f648  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000f644  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001738  00000000  00000000  0000f678  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000376c  00000000  00000000  00010db0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002dcc2  00000000  00000000  0001451c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000076b1  00000000  00000000  000421de  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d92b  00000000  00000000  0004988f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003edc  00000000  00000000  000571bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000080f6  00000000  00000000  0005b098  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f6cf  00000000  00000000  0006318e  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 000017f0  00000000  00000000  00072860  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c2 4c 	sub	pc,pc,-15796

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d 98       	ld.ub	r8,r6[0x1]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 68       	and	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	41 fc       	lddsp	r12,sp[0x7c]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	2e 98       	sub	r8,-23
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d2 00       	acall	0x20
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 3c       	sub	r12,115
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6d 4c       	ld.w	r12,r6[0x50]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 60       	and	r0,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d2 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	71 10       	ld.w	r0,r8[0x44]

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 54       	eor	r4,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d2 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	71 10       	ld.w	r0,r8[0x44]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 4b       	or	r11,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d2 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	71 10       	ld.w	r0,r8[0x44]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d2 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	71 10       	ld.w	r0,r8[0x44]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d2 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	71 10       	ld.w	r0,r8[0x44]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d2 70       	acall	0x27
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	71 10       	ld.w	r0,r8[0x44]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d2 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	71 10       	ld.w	r0,r8[0x44]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d2 a0       	acall	0x2a
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d2 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d2 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d2 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	d3 00       	acall	0x30
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	71 10       	ld.w	r0,r8[0x44]
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	d3 14       	*unknown*
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	d3 24       	*unknown*

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	d3 38       	*unknown*
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	71 10       	ld.w	r0,r8[0x44]
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	d3 58       	*unknown*
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	d3 6c       	*unknown*
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	d3 84       	*unknown*
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	d3 a4       	*unknown*
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	d3 cc       	*unknown*
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	d3 f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	d4 18       	*unknown*
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	d4 40       	acall	0x44

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	d4 64       	*unknown*
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	71 10       	ld.w	r0,r8[0x44]
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	d3 58       	*unknown*
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	d4 7c       	*unknown*

80002304 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
80002308:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000230a:	19 a9       	ld.ub	r9,r12[0x2]
8000230c:	30 08       	mov	r8,0
8000230e:	f0 09 18 00 	cp.b	r9,r8
80002312:	c1 11       	brne	80002334 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002314:	49 3c       	lddpc	r12,80002360 <DataSession_reply_func+0x5c>
80002316:	f0 1f 00 14 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000231a:	0f b8       	ld.ub	r8,r7[0x3]
8000231c:	1a d8       	st.w	--sp,r8
8000231e:	49 3c       	lddpc	r12,80002368 <DataSession_reply_func+0x64>
80002320:	f0 1f 00 11 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002324:	0f c8       	ld.ub	r8,r7[0x4]
80002326:	1a d8       	st.w	--sp,r8
80002328:	49 1c       	lddpc	r12,8000236c <DataSession_reply_func+0x68>
8000232a:	f0 1f 00 0f 	mcall	80002364 <DataSession_reply_func+0x60>
8000232e:	2f ed       	sub	sp,-8
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002334:	48 fc       	lddpc	r12,80002370 <DataSession_reply_func+0x6c>
80002336:	f0 1f 00 0c 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000233a:	0f a8       	ld.ub	r8,r7[0x2]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ec       	lddpc	r12,80002374 <DataSession_reply_func+0x70>
80002340:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002344:	0f b8       	ld.ub	r8,r7[0x3]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 cc       	lddpc	r12,80002378 <DataSession_reply_func+0x74>
8000234a:	f0 1f 00 07 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000234e:	0f c8       	ld.ub	r8,r7[0x4]
80002350:	1a d8       	st.w	--sp,r8
80002352:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x78>
80002354:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x60>
80002358:	2f dd       	sub	sp,-12
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	d4 98       	*unknown*
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	71 10       	ld.w	r0,r8[0x44]
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	d4 a8       	*unknown*
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	d4 b4       	*unknown*
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	d4 c0       	acall	0x4c
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	d4 d0       	acall	0x4d
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	d4 e0       	acall	0x4e
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	d4 ec       	*unknown*

80002380 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002384:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 bc       	lddpc	r12,800023b8 <CallControl_brdcst_func+0x38>
8000238e:	f0 1f 00 0c 	mcall	800023bc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002392:	2f fd       	sub	sp,-4
80002394:	0f 99       	ld.ub	r9,r7[0x1]
80002396:	30 38       	mov	r8,3
80002398:	f0 09 18 00 	cp.b	r9,r8
8000239c:	c0 41       	brne	800023a4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000239e:	30 09       	mov	r9,0
800023a0:	48 88       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023a2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023a4:	0f 99       	ld.ub	r9,r7[0x1]
800023a6:	30 48       	mov	r8,4
800023a8:	f0 09 18 00 	cp.b	r9,r8
800023ac:	c0 41       	brne	800023b4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023ae:	30 19       	mov	r9,1
800023b0:	48 48       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023b2:	b0 89       	st.b	r8[0x0],r9
800023b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	d4 f8       	*unknown*
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	71 10       	ld.w	r0,r8[0x44]
800023c0:	00 00       	add	r0,r0
800023c2:	0a 4d       	or	sp,r5

800023c4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023cc:	0f 99       	ld.ub	r9,r7[0x1]
800023ce:	30 08       	mov	r8,0
800023d0:	f0 09 18 00 	cp.b	r9,r8
800023d4:	c0 71       	brne	800023e2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023d6:	48 ac       	lddpc	r12,800023fc <TransmitControl_brdcst_func+0x38>
800023d8:	f0 1f 00 0a 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023dc:	30 09       	mov	r9,0
800023de:	48 a8       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023e0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023e2:	0f 99       	ld.ub	r9,r7[0x1]
800023e4:	30 18       	mov	r8,1
800023e6:	f0 09 18 00 	cp.b	r9,r8
800023ea:	c0 71       	brne	800023f8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023ec:	48 7c       	lddpc	r12,80002408 <TransmitControl_brdcst_func+0x44>
800023ee:	f0 1f 00 05 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023f2:	30 19       	mov	r9,1
800023f4:	48 48       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023f6:	b0 89       	st.b	r8[0x0],r9
800023f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	d5 10       	acall	0x51
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	71 10       	ld.w	r0,r8[0x44]
80002404:	00 00       	add	r0,r0
80002406:	0a 4c       	or	r12,r5
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	d5 28       	*unknown*

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c1 61       	brne	80002448 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	48 ec       	lddpc	r12,80002454 <TransmitControl_reply_func+0x48>
80002420:	f0 1f 00 0e 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 dc       	lddpc	r12,8000245c <TransmitControl_reply_func+0x50>
8000242a:	f0 1f 00 0c 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	48 cc       	lddpc	r12,80002460 <TransmitControl_reply_func+0x54>
80002434:	f0 1f 00 09 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 ac       	lddpc	r12,80002464 <TransmitControl_reply_func+0x58>
8000243e:	f0 1f 00 07 	mcall	80002458 <TransmitControl_reply_func+0x4c>
80002442:	2f dd       	sub	sp,-12
80002444:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002448:	48 8c       	lddpc	r12,80002468 <TransmitControl_reply_func+0x5c>
8000244a:	f0 1f 00 04 	mcall	80002458 <TransmitControl_reply_func+0x4c>
8000244e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002452:	00 00       	add	r0,r0
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	d5 3c       	*unknown*
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	71 10       	ld.w	r0,r8[0x44]
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	d5 58       	*unknown*
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d5 6c       	*unknown*
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	d5 88       	*unknown*
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	d5 98       	*unknown*

8000246c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000246c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246e:	19 a9       	ld.ub	r9,r12[0x2]
80002470:	30 08       	mov	r8,0
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 51       	brne	80002480 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x1c>
8000247a:	f0 1f 00 05 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x24>
80002482:	f0 1f 00 03 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	d5 b0       	acall	0x5b
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	71 10       	ld.w	r0,r8[0x44]
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	d5 c0       	acall	0x5c

80002494 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 b1       	brne	800024da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024a6:	0f b8       	ld.ub	r8,r7[0x3]
800024a8:	31 09       	mov	r9,16
800024aa:	f2 08 18 00 	cp.b	r8,r9
800024ae:	c0 f1       	brne	800024cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b0:	48 dc       	lddpc	r12,800024e4 <Volume_reply_func+0x50>
800024b2:	f0 1f 00 0e 	mcall	800024e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024b6:	0f 99       	ld.ub	r9,r7[0x1]
800024b8:	0f a8       	ld.ub	r8,r7[0x2]
800024ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024be:	1a d8       	st.w	--sp,r8
800024c0:	48 bc       	lddpc	r12,800024ec <Volume_reply_func+0x58>
800024c2:	f0 1f 00 0a 	mcall	800024e8 <Volume_reply_func+0x54>
800024c6:	2f fd       	sub	sp,-4
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 9c       	lddpc	r12,800024f0 <Volume_reply_func+0x5c>
800024d0:	f0 1f 00 06 	mcall	800024e8 <Volume_reply_func+0x54>
800024d4:	2f fd       	sub	sp,-4
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024da:	48 7c       	lddpc	r12,800024f4 <Volume_reply_func+0x60>
800024dc:	f0 1f 00 03 	mcall	800024e8 <Volume_reply_func+0x54>
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	d5 d4       	*unknown*
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	71 10       	ld.w	r0,r8[0x44]
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	d5 e8       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	d6 04       	*unknown*
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d6 1c       	*unknown*

800024f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024fa:	19 d9       	ld.ub	r9,r12[0x5]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 81       	brne	80002512 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002504:	10 99       	mov	r9,r8
80002506:	48 78       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002508:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000250a:	48 7c       	lddpc	r12,80002524 <spk_brdcst_func+0x2c>
8000250c:	f0 1f 00 07 	mcall	80002528 <spk_brdcst_func+0x30>
80002510:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002512:	30 19       	mov	r9,1
80002514:	48 38       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002516:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002518:	48 5c       	lddpc	r12,8000252c <spk_brdcst_func+0x34>
8000251a:	f0 1f 00 04 	mcall	80002528 <spk_brdcst_func+0x30>
8000251e:	d8 02       	popm	pc
80002520:	00 00       	add	r0,r0
80002522:	0a 48       	or	r8,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	d6 34       	*unknown*
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	71 10       	ld.w	r0,r8[0x44]
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	d6 44       	*unknown*

80002530 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002532:	19 a9       	ld.ub	r9,r12[0x2]
80002534:	30 08       	mov	r8,0
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 f1       	brne	80002558 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000253c:	19 e9       	ld.ub	r9,r12[0x6]
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 40       	breq	8000254a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002544:	30 19       	mov	r9,1
80002546:	48 98       	lddpc	r8,80002568 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254a:	19 e8       	ld.ub	r8,r12[0x6]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 8c       	lddpc	r12,8000256c <spk_reply_func+0x3c>
80002550:	f0 1f 00 08 	mcall	80002570 <spk_reply_func+0x40>
80002554:	2f fd       	sub	sp,-4
80002556:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002558:	30 09       	mov	r9,0
8000255a:	48 48       	lddpc	r8,80002568 <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000255e:	48 6c       	lddpc	r12,80002574 <spk_reply_func+0x44>
80002560:	f0 1f 00 04 	mcall	80002570 <spk_reply_func+0x40>
80002564:	d8 02       	popm	pc
80002566:	00 00       	add	r0,r0
80002568:	00 00       	add	r0,r0
8000256a:	0a 48       	or	r8,r5
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	d6 50       	acall	0x65
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	71 10       	ld.w	r0,r8[0x44]
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	d6 60       	acall	0x66

80002578 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000257c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002580:	0f a9       	ld.ub	r9,r7[0x2]
80002582:	30 08       	mov	r8,0
80002584:	f0 09 18 00 	cp.b	r9,r8
80002588:	c0 71       	brne	80002596 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000258a:	48 dc       	lddpc	r12,800025bc <mic_brdcst_func+0x44>
8000258c:	f0 1f 00 0d 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002590:	30 09       	mov	r9,0
80002592:	48 d8       	lddpc	r8,800025c4 <mic_brdcst_func+0x4c>
80002594:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002596:	0f a9       	ld.ub	r9,r7[0x2]
80002598:	31 18       	mov	r8,17
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 d1       	brne	800025b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a0:	48 ac       	lddpc	r12,800025c8 <mic_brdcst_func+0x50>
800025a2:	f0 1f 00 08 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025a6:	48 89       	lddpc	r9,800025c4 <mic_brdcst_func+0x4c>
800025a8:	30 18       	mov	r8,1
800025aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025ac:	13 89       	ld.ub	r9,r9[0x0]
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 31       	brne	800025b8 <mic_brdcst_func+0x40>
800025b4:	48 68       	lddpc	r8,800025cc <mic_brdcst_func+0x54>
800025b6:	11 88       	ld.ub	r8,r8[0x0]
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	d6 6c       	*unknown*
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	71 10       	ld.w	r0,r8[0x44]
800025c4:	00 00       	add	r0,r0
800025c6:	0a 5c       	eor	r12,r5
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	d6 80       	acall	0x68
800025cc:	00 00       	add	r0,r0
800025ce:	0a 4d       	or	sp,r5

800025d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d8:	49 ac       	lddpc	r12,80002640 <mic_reply_func+0x70>
800025da:	f0 1f 00 1b 	mcall	80002644 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025de:	0f 89       	ld.ub	r9,r7[0x0]
800025e0:	30 08       	mov	r8,0
800025e2:	f0 09 18 00 	cp.b	r9,r8
800025e6:	c2 71       	brne	80002634 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	30 29       	mov	r9,2
800025ec:	f2 08 18 00 	cp.b	r8,r9
800025f0:	c1 b1       	brne	80002626 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025f2:	49 6c       	lddpc	r12,80002648 <mic_reply_func+0x78>
800025f4:	f0 1f 00 14 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f8:	0f a8       	ld.ub	r8,r7[0x2]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 4c       	lddpc	r12,8000264c <mic_reply_func+0x7c>
800025fe:	f0 1f 00 12 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002602:	0f b8       	ld.ub	r8,r7[0x3]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 3c       	lddpc	r12,80002650 <mic_reply_func+0x80>
80002608:	f0 1f 00 0f 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000260c:	0f c8       	ld.ub	r8,r7[0x4]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 1c       	lddpc	r12,80002654 <mic_reply_func+0x84>
80002612:	f0 1f 00 0d 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002616:	0f d8       	ld.ub	r8,r7[0x5]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 0c       	lddpc	r12,80002658 <mic_reply_func+0x88>
8000261c:	f0 1f 00 0a 	mcall	80002644 <mic_reply_func+0x74>
80002620:	2f cd       	sub	sp,-16
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002626:	1a d8       	st.w	--sp,r8
80002628:	48 dc       	lddpc	r12,8000265c <mic_reply_func+0x8c>
8000262a:	f0 1f 00 07 	mcall	80002644 <mic_reply_func+0x74>
8000262e:	2f fd       	sub	sp,-4
80002630:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002634:	48 bc       	lddpc	r12,80002660 <mic_reply_func+0x90>
80002636:	f0 1f 00 04 	mcall	80002644 <mic_reply_func+0x74>
8000263a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263e:	00 00       	add	r0,r0
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	d6 94       	*unknown*
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	71 10       	ld.w	r0,r8[0x44]
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	d6 a4       	*unknown*
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	d6 b8       	*unknown*
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	d6 cc       	*unknown*
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	d6 e8       	*unknown*
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	d7 00       	acall	0x70
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	d7 18       	*unknown*
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	d7 30       	acall	0x73

80002664 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000266c:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x34>
8000266e:	f0 1f 00 0c 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002672:	0f 88       	ld.ub	r8,r7[0x0]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x3c>
80002678:	f0 1f 00 09 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 9c       	lddpc	r12,800026a4 <dcm_brdcst_func+0x40>
80002682:	f0 1f 00 07 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002686:	0f 98       	ld.ub	r8,r7[0x1]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 8c       	lddpc	r12,800026a8 <dcm_brdcst_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <dcm_brdcst_func+0x38>
80002690:	2f dd       	sub	sp,-12
	
	
}
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	d7 40       	acall	0x74
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	71 10       	ld.w	r0,r8[0x44]
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	d7 54       	*unknown*
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	d7 68       	*unknown*
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	d7 80       	acall	0x78

800026ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
800026b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026b2:	19 a9       	ld.ub	r9,r12[0x2]
800026b4:	30 08       	mov	r8,0
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c1 b1       	brne	800026f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026bc:	19 b8       	ld.ub	r8,r12[0x3]
800026be:	30 19       	mov	r9,1
800026c0:	f2 08 18 00 	cp.b	r8,r9
800026c4:	c0 51       	brne	800026ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026c6:	48 ec       	lddpc	r12,800026fc <dcm_reply_func+0x50>
800026c8:	f0 1f 00 0e 	mcall	80002700 <dcm_reply_func+0x54>
800026cc:	c0 a8       	rjmp	800026e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ce:	58 08       	cp.w	r8,0
800026d0:	c0 51       	brne	800026da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026d2:	48 dc       	lddpc	r12,80002704 <dcm_reply_func+0x58>
800026d4:	f0 1f 00 0b 	mcall	80002700 <dcm_reply_func+0x54>
800026d8:	c0 48       	rjmp	800026e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026da:	48 cc       	lddpc	r12,80002708 <dcm_reply_func+0x5c>
800026dc:	f0 1f 00 09 	mcall	80002700 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e0:	0f d8       	ld.ub	r8,r7[0x5]
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 ac       	lddpc	r12,8000270c <dcm_reply_func+0x60>
800026e6:	f0 1f 00 07 	mcall	80002700 <dcm_reply_func+0x54>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f0:	48 8c       	lddpc	r12,80002710 <dcm_reply_func+0x64>
800026f2:	f0 1f 00 04 	mcall	80002700 <dcm_reply_func+0x54>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	d7 9c       	*unknown*
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	71 10       	ld.w	r0,r8[0x44]
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	d7 b0       	acall	0x7b
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d7 c4       	*unknown*
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	d7 d8       	*unknown*
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	d7 e4       	*unknown*

80002714 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002716:	19 a9       	ld.ub	r9,r12[0x2]
80002718:	30 08       	mov	r8,0
8000271a:	f0 09 18 00 	cp.b	r9,r8
8000271e:	c0 51       	brne	80002728 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x1c>
80002722:	f0 1f 00 05 	mcall	80002734 <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x24>
8000272a:	f0 1f 00 03 	mcall	80002734 <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	d7 f0       	acall	0x7f
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	71 10       	ld.w	r0,r8[0x44]
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	d7 fc       	*unknown*

8000273c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000273c:	d4 31       	pushm	r0-r7,lr
8000273e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	//static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
80002740:	f0 1f 00 39 	mcall	80002824 <app_cfg+0xe8>
80002744:	4b 98       	lddpc	r8,80002828 <app_cfg+0xec>
80002746:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
80002748:	4b 97       	lddpc	r7,8000282c <app_cfg+0xf0>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000274a:	4b a5       	lddpc	r5,80002830 <app_cfg+0xf4>
							OB_State = OB_WAITINGAPPTASK;
							log("get time okay!\n");
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000274c:	30 92       	mov	r2,9
8000274e:	32 01       	mov	r1,32
80002750:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
80002752:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002754:	4b 84       	lddpc	r4,80002834 <app_cfg+0xf8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
80002756:	6e 08       	ld.w	r8,r7[0x0]
80002758:	58 28       	cp.w	r8,2
8000275a:	c3 40       	breq	800027c2 <app_cfg+0x86>
8000275c:	58 38       	cp.w	r8,3
8000275e:	c4 00       	breq	800027de <app_cfg+0xa2>
80002760:	58 08       	cp.w	r8,0
80002762:	c5 a1       	brne	80002816 <app_cfg+0xda>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002764:	4b 58       	lddpc	r8,80002838 <app_cfg+0xfc>
80002766:	70 08       	ld.w	r8,r8[0x0]
80002768:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000276c:	58 38       	cp.w	r8,3
8000276e:	c1 21       	brne	80002792 <app_cfg+0x56>
80002770:	4b 38       	lddpc	r8,8000283c <app_cfg+0x100>
80002772:	11 88       	ld.ub	r8,r8[0x0]
80002774:	58 08       	cp.w	r8,0
80002776:	c0 e1       	brne	80002792 <app_cfg+0x56>
				{
					connect_flag=1;
80002778:	30 19       	mov	r9,1
8000277a:	4b 18       	lddpc	r8,8000283c <app_cfg+0x100>
8000277c:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000277e:	30 cb       	mov	r11,12
80002780:	30 1c       	mov	r12,1
80002782:	f0 1f 00 30 	mcall	80002840 <app_cfg+0x104>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002786:	30 28       	mov	r8,2
80002788:	8f 08       	st.w	r7[0x0],r8
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
8000278a:	4a fc       	lddpc	r12,80002844 <app_cfg+0x108>
8000278c:	f0 1f 00 2f 	mcall	80002848 <app_cfg+0x10c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002790:	c4 38       	rjmp	80002816 <app_cfg+0xda>
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002792:	d7 03       	nop
					nop();
80002794:	d7 03       	nop
					nop();
80002796:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002798:	4a dc       	lddpc	r12,8000284c <app_cfg+0x110>
8000279a:	f0 1f 00 2c 	mcall	80002848 <app_cfg+0x10c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
8000279e:	4a d8       	lddpc	r8,80002850 <app_cfg+0x114>
800027a0:	11 de       	ld.ub	lr,r8[0x5]
800027a2:	11 cc       	ld.ub	r12,r8[0x4]
800027a4:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800027a6:	11 aa       	ld.ub	r10,r8[0x2]
800027a8:	11 99       	ld.ub	r9,r8[0x1]
800027aa:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800027ac:	1a de       	st.w	--sp,lr
800027ae:	1a dc       	st.w	--sp,r12
800027b0:	1a db       	st.w	--sp,r11
800027b2:	1a da       	st.w	--sp,r10
800027b4:	1a d9       	st.w	--sp,r9
800027b6:	1a d8       	st.w	--sp,r8
800027b8:	4a 7c       	lddpc	r12,80002854 <app_cfg+0x118>
800027ba:	f0 1f 00 24 	mcall	80002848 <app_cfg+0x10c>
800027be:	2f ad       	sub	sp,-24
800027c0:	c2 b8       	rjmp	80002816 <app_cfg+0xda>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027c2:	0b 88       	ld.ub	r8,r5[0x0]
800027c4:	58 08       	cp.w	r8,0
800027c6:	c0 60       	breq	800027d2 <app_cfg+0x96>
							
							OB_State = OB_WAITINGAPPTASK;
800027c8:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
800027ca:	4a 4c       	lddpc	r12,80002858 <app_cfg+0x11c>
800027cc:	f0 1f 00 1f 	mcall	80002848 <app_cfg+0x10c>
800027d0:	c2 38       	rjmp	80002816 <app_cfg+0xda>
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027d2:	04 9a       	mov	r10,r2
800027d4:	02 9b       	mov	r11,r1
800027d6:	0c 9c       	mov	r12,r6
800027d8:	f0 1f 00 21 	mcall	8000285c <app_cfg+0x120>
800027dc:	c1 d8       	rjmp	80002816 <app_cfg+0xda>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027de:	68 0c       	ld.w	r12,r4[0x0]
800027e0:	0c 99       	mov	r9,r6
800027e2:	e0 6a 0f a0 	mov	r10,4000
800027e6:	1a 9b       	mov	r11,sp
800027e8:	f0 1f 00 1e 	mcall	80002860 <app_cfg+0x124>
800027ec:	58 1c       	cp.w	r12,1
800027ee:	c1 01       	brne	8000280e <app_cfg+0xd2>
					{
						if(data_ptr!=NULL){//Resend message
800027f0:	40 0c       	lddsp	r12,sp[0x0]
800027f2:	58 0c       	cp.w	r12,0
800027f4:	c0 d0       	breq	8000280e <app_cfg+0xd2>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
							//log("receive data : %d", ptr->data.XG_Time.Second);
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
800027f6:	04 9a       	mov	r10,r2
800027f8:	02 9b       	mov	r11,r1
800027fa:	f0 1f 00 19 	mcall	8000285c <app_cfg+0x120>
							
							//flashc_memset8((void*)0x80038000, 0x02, 5, TRUE);
							
							set_message_store(data_ptr);
800027fe:	49 a8       	lddpc	r8,80002864 <app_cfg+0x128>
80002800:	70 0c       	ld.w	r12,r8[0x0]
80002802:	40 0b       	lddsp	r11,sp[0x0]
80002804:	f0 1f 00 19 	mcall	80002868 <app_cfg+0x12c>
							log("receive okay!\n");
80002808:	49 9c       	lddpc	r12,8000286c <app_cfg+0x130>
8000280a:	f0 1f 00 10 	mcall	80002848 <app_cfg+0x10c>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
8000280e:	d7 03       	nop
					//log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					//Current_time.Year, Current_time.Month, Current_time.Day,
					//Current_time.Hour, Current_time.Minute, Current_time.Second);
					log("app task run!\n");
80002810:	49 8c       	lddpc	r12,80002870 <app_cfg+0x134>
80002812:	f0 1f 00 0e 	mcall	80002848 <app_cfg+0x10c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002816:	e0 6b 0f a0 	mov	r11,4000
8000281a:	48 4c       	lddpc	r12,80002828 <app_cfg+0xec>
8000281c:	f0 1f 00 16 	mcall	80002874 <app_cfg+0x138>
	}
80002820:	c9 bb       	rjmp	80002756 <app_cfg+0x1a>
80002822:	00 00       	add	r0,r0
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	6a 3c       	ld.w	r12,r5[0xc]
80002828:	00 00       	add	r0,r0
8000282a:	0a 58       	eor	r8,r5
8000282c:	00 00       	add	r0,r0
8000282e:	0a 50       	eor	r0,r5
80002830:	00 00       	add	r0,r0
80002832:	00 04       	add	r4,r0
80002834:	00 00       	add	r0,r0
80002836:	0b 6c       	ld.uh	r12,--r5
80002838:	00 00       	add	r0,r0
8000283a:	0d 98       	ld.ub	r8,r6[0x1]
8000283c:	00 00       	add	r0,r0
8000283e:	0a 56       	eor	r6,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	43 88       	lddsp	r8,sp[0xe0]
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	d8 08       	*unknown*
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	71 10       	ld.w	r0,r8[0x44]
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	d8 1c       	*unknown*
80002850:	00 00       	add	r0,r0
80002852:	0d 9c       	ld.ub	r12,r6[0x1]
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	d8 2c       	*unknown*
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	d8 58       	*unknown*
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	42 50       	lddsp	r0,sp[0x94]
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	62 cc       	ld.w	r12,r1[0x30]
80002864:	00 00       	add	r0,r0
80002866:	0b 74       	ld.ub	r4,--r5
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	2f 18       	sub	r8,-15
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	d8 68       	*unknown*
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	d8 78       	*unknown*
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	6b ec       	ld.w	r12,r5[0x78]

80002878 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002878:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000287c:	19 c7       	ld.ub	r7,r12[0x4]
8000287e:	19 d8       	ld.ub	r8,r12[0x5]
80002880:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002884:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002886:	48 dc       	lddpc	r12,800028b8 <Phyuserinput_brdcst_func+0x40>
80002888:	f0 1f 00 0d 	mcall	800028bc <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
8000288c:	36 08       	mov	r8,96
8000288e:	f0 07 19 00 	cp.h	r7,r8
80002892:	c1 11       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
80002894:	48 b8       	lddpc	r8,800028c0 <Phyuserinput_brdcst_func+0x48>
80002896:	11 89       	ld.ub	r9,r8[0x0]
80002898:	30 18       	mov	r8,1
8000289a:	f0 09 18 00 	cp.b	r9,r8
8000289e:	c0 b1       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028a0:	31 4b       	mov	r11,20
800028a2:	30 1c       	mov	r12,1
800028a4:	f0 1f 00 08 	mcall	800028c4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800028a8:	e0 6c 03 20 	mov	r12,800
800028ac:	f0 1f 00 07 	mcall	800028c8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028b0:	f0 1f 00 07 	mcall	800028cc <Phyuserinput_brdcst_func+0x54>
800028b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	d8 88       	*unknown*
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	71 10       	ld.w	r0,r8[0x44]
800028c0:	00 00       	add	r0,r0
800028c2:	0a 56       	eor	r6,r5
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	43 88       	lddsp	r8,sp[0xe0]
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	6b a4       	ld.w	r4,r5[0x68]
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	51 ac       	stdsp	sp[0x68],r12

800028d0 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028d0:	d4 21       	pushm	r4-r7,lr
800028d2:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028d4:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028d8:	0d 88       	ld.ub	r8,r6[0x0]
800028da:	32 49       	mov	r9,36
800028dc:	f2 08 18 00 	cp.b	r8,r9
800028e0:	c2 91       	brne	80002932 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800028e2:	4a dc       	lddpc	r12,80002994 <DataSession_brdcst_func+0xc4>
800028e4:	f0 1f 00 2d 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800028e8:	0d a5       	ld.ub	r5,r6[0x2]
800028ea:	0d b8       	ld.ub	r8,r6[0x3]
800028ec:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800028f0:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800028f2:	0d 98       	ld.ub	r8,r6[0x1]
800028f4:	1a d8       	st.w	--sp,r8
800028f6:	4a ac       	lddpc	r12,8000299c <DataSession_brdcst_func+0xcc>
800028f8:	f0 1f 00 28 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800028fc:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002900:	1a d8       	st.w	--sp,r8
80002902:	4a 8c       	lddpc	r12,800029a0 <DataSession_brdcst_func+0xd0>
80002904:	f0 1f 00 25 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002908:	2f ed       	sub	sp,-8
8000290a:	58 05       	cp.w	r5,0
8000290c:	c4 10       	breq	8000298e <DataSession_brdcst_func+0xbe>
8000290e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002910:	4a 54       	lddpc	r4,800029a4 <DataSession_brdcst_func+0xd4>
80002912:	ec 07 00 08 	add	r8,r6,r7
80002916:	11 c8       	ld.ub	r8,r8[0x4]
80002918:	1a d8       	st.w	--sp,r8
8000291a:	1a d7       	st.w	--sp,r7
8000291c:	08 9c       	mov	r12,r4
8000291e:	f0 1f 00 1f 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002922:	2f f7       	sub	r7,-1
80002924:	5c 57       	castu.b	r7
80002926:	2f ed       	sub	sp,-8
80002928:	ee 05 19 00 	cp.h	r5,r7
8000292c:	fe 9b ff f3 	brhi	80002912 <DataSession_brdcst_func+0x42>
80002930:	c2 f8       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002932:	1a d8       	st.w	--sp,r8
80002934:	49 dc       	lddpc	r12,800029a8 <DataSession_brdcst_func+0xd8>
80002936:	f0 1f 00 19 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000293a:	0d 88       	ld.ub	r8,r6[0x0]
8000293c:	2f fd       	sub	sp,-4
8000293e:	30 39       	mov	r9,3
80002940:	f2 08 18 00 	cp.b	r8,r9
80002944:	c0 51       	brne	8000294e <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002946:	49 ac       	lddpc	r12,800029ac <DataSession_brdcst_func+0xdc>
80002948:	f0 1f 00 14 	mcall	80002998 <DataSession_brdcst_func+0xc8>
8000294c:	c2 18       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000294e:	30 49       	mov	r9,4
80002950:	f2 08 18 00 	cp.b	r8,r9
80002954:	c1 d1       	brne	8000298e <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002956:	32 0a       	mov	r10,32
80002958:	ec cb ff fc 	sub	r11,r6,-4
8000295c:	1a 9c       	mov	r12,sp
8000295e:	f0 1f 00 15 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002962:	49 58       	lddpc	r8,800029b4 <DataSession_brdcst_func+0xe4>
80002964:	70 0c       	ld.w	r12,r8[0x0]
80002966:	f0 1f 00 15 	mcall	800029b8 <DataSession_brdcst_func+0xe8>
8000296a:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
8000296c:	c0 e0       	breq	80002988 <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
8000296e:	32 0a       	mov	r10,32
80002970:	1a 9b       	mov	r11,sp
80002972:	f0 1f 00 10 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002976:	49 28       	lddpc	r8,800029bc <DataSession_brdcst_func+0xec>
80002978:	70 0c       	ld.w	r12,r8[0x0]
8000297a:	30 09       	mov	r9,0
8000297c:	12 9a       	mov	r10,r9
8000297e:	fa cb ff e0 	sub	r11,sp,-32
80002982:	f0 1f 00 10 	mcall	800029c0 <DataSession_brdcst_func+0xf0>
80002986:	c0 48       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002988:	48 fc       	lddpc	r12,800029c4 <DataSession_brdcst_func+0xf4>
8000298a:	f0 1f 00 04 	mcall	80002998 <DataSession_brdcst_func+0xc8>
				//
		//}
		
	}
	
}
8000298e:	2f 7d       	sub	sp,-36
80002990:	d8 22       	popm	r4-r7,pc
80002992:	00 00       	add	r0,r0
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	d8 a8       	*unknown*
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	71 10       	ld.w	r0,r8[0x44]
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	d8 bc       	*unknown*
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	d8 d4       	*unknown*
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	d8 f0       	acall	0x8f
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	d9 08       	*unknown*
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	d9 14       	*unknown*
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	79 8c       	ld.w	r12,r12[0x60]
800029b4:	00 00       	add	r0,r0
800029b6:	0b 74       	ld.ub	r4,--r5
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	30 c4       	mov	r4,12
800029bc:	00 00       	add	r0,r0
800029be:	0b 6c       	ld.uh	r12,--r5
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	64 d8       	ld.w	r8,r2[0x34]
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	d9 2c       	*unknown*

800029c8 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029c8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800029ca:	19 e8       	ld.ub	r8,r12[0x6]
800029cc:	30 19       	mov	r9,1
800029ce:	f2 08 18 00 	cp.b	r8,r9
800029d2:	c0 61       	brne	800029de <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029d4:	48 98       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029d6:	70 09       	ld.w	r9,r8[0x0]
800029d8:	a1 a9       	sbr	r9,0x0
800029da:	91 09       	st.w	r8[0x0],r9
800029dc:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029de:	30 29       	mov	r9,2
800029e0:	f2 08 18 00 	cp.b	r8,r9
800029e4:	c0 80       	breq	800029f4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029e6:	48 58       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029e8:	70 09       	ld.w	r9,r8[0x0]
800029ea:	e0 19 ff fc 	andl	r9,0xfffc
800029ee:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029f0:	f0 1f 00 03 	mcall	800029fc <DeviceInitializationStatus_brdcst_func+0x34>
800029f4:	d8 02       	popm	pc
800029f6:	00 00       	add	r0,r0
800029f8:	00 00       	add	r0,r0
800029fa:	0d 98       	ld.ub	r8,r6[0x1]
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	42 dc       	lddsp	r12,sp[0xb4]

80002a00 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002a00:	eb cd 40 fc 	pushm	r2-r7,lr
80002a04:	20 1d       	sub	sp,4
80002a06:	18 97       	mov	r7,r12
80002a08:	14 95       	mov	r5,r10
80002a0a:	12 96       	mov	r6,r9
	U16 status = 1;
80002a0c:	30 18       	mov	r8,1
80002a0e:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002a10:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002a14:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002a18:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002a1c:	30 1b       	mov	r11,1
80002a1e:	4e 08       	lddpc	r8,80002b9c <send_flash_command+0x19c>
80002a20:	70 0c       	ld.w	r12,r8[0x0]
80002a22:	f0 1f 00 60 	mcall	80002ba0 <send_flash_command+0x1a0>

    switch (command)
80002a26:	30 58       	mov	r8,5
80002a28:	f0 07 19 00 	cp.h	r7,r8
80002a2c:	c3 40       	breq	80002a94 <send_flash_command+0x94>
80002a2e:	e0 8b 00 18 	brhi	80002a5e <send_flash_command+0x5e>
80002a32:	30 28       	mov	r8,2
80002a34:	f0 07 19 00 	cp.h	r7,r8
80002a38:	c5 e0       	breq	80002af4 <send_flash_command+0xf4>
80002a3a:	e0 8b 00 08 	brhi	80002a4a <send_flash_command+0x4a>
80002a3e:	30 18       	mov	r8,1
80002a40:	f0 07 19 00 	cp.h	r7,r8
80002a44:	e0 81 00 a3 	brne	80002b8a <send_flash_command+0x18a>
80002a48:	c9 88       	rjmp	80002b78 <send_flash_command+0x178>
80002a4a:	30 38       	mov	r8,3
80002a4c:	f0 07 19 00 	cp.h	r7,r8
80002a50:	c7 20       	breq	80002b34 <send_flash_command+0x134>
80002a52:	30 48       	mov	r8,4
80002a54:	f0 07 19 00 	cp.h	r7,r8
80002a58:	e0 81 00 99 	brne	80002b8a <send_flash_command+0x18a>
80002a5c:	c2 c8       	rjmp	80002ab4 <send_flash_command+0xb4>
80002a5e:	35 28       	mov	r8,82
80002a60:	f0 07 19 00 	cp.h	r7,r8
80002a64:	c2 f0       	breq	80002ac2 <send_flash_command+0xc2>
80002a66:	e0 8b 00 0c 	brhi	80002a7e <send_flash_command+0x7e>
80002a6a:	30 68       	mov	r8,6
80002a6c:	f0 07 19 00 	cp.h	r7,r8
80002a70:	c2 20       	breq	80002ab4 <send_flash_command+0xb4>
80002a72:	32 08       	mov	r8,32
80002a74:	f0 07 19 00 	cp.h	r7,r8
80002a78:	e0 81 00 89 	brne	80002b8a <send_flash_command+0x18a>
80002a7c:	c2 38       	rjmp	80002ac2 <send_flash_command+0xc2>
80002a7e:	36 08       	mov	r8,96
80002a80:	f0 07 19 00 	cp.h	r7,r8
80002a84:	c3 20       	breq	80002ae8 <send_flash_command+0xe8>
80002a86:	e0 68 00 d8 	mov	r8,216
80002a8a:	f0 07 19 00 	cp.h	r7,r8
80002a8e:	e0 81 00 7e 	brne	80002b8a <send_flash_command+0x18a>
80002a92:	c1 88       	rjmp	80002ac2 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002a94:	4c 27       	lddpc	r7,80002b9c <send_flash_command+0x19c>
80002a96:	30 5b       	mov	r11,5
80002a98:	6e 0c       	ld.w	r12,r7[0x0]
80002a9a:	f0 1f 00 43 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_dummy();
80002a9e:	e0 6b 00 ff 	mov	r11,255
80002aa2:	6e 0c       	ld.w	r12,r7[0x0]
80002aa4:	f0 1f 00 40 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_read_byte(&status);
80002aa8:	fa cb ff fe 	sub	r11,sp,-2
80002aac:	6e 0c       	ld.w	r12,r7[0x0]
80002aae:	f0 1f 00 3f 	mcall	80002ba8 <send_flash_command+0x1a8>
			break;
80002ab2:	c6 c8       	rjmp	80002b8a <send_flash_command+0x18a>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002ab4:	0e 9b       	mov	r11,r7
80002ab6:	5c 7b       	castu.h	r11
80002ab8:	4b 98       	lddpc	r8,80002b9c <send_flash_command+0x19c>
80002aba:	70 0c       	ld.w	r12,r8[0x0]
80002abc:	f0 1f 00 3a 	mcall	80002ba4 <send_flash_command+0x1a4>
			break;
80002ac0:	c6 58       	rjmp	80002b8a <send_flash_command+0x18a>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002ac2:	4b 76       	lddpc	r6,80002b9c <send_flash_command+0x19c>
80002ac4:	0e 9b       	mov	r11,r7
80002ac6:	5c 7b       	castu.h	r11
80002ac8:	6c 0c       	ld.w	r12,r6[0x0]
80002aca:	f0 1f 00 37 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_byte(addr[2]);
80002ace:	08 9b       	mov	r11,r4
80002ad0:	6c 0c       	ld.w	r12,r6[0x0]
80002ad2:	f0 1f 00 35 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_byte(addr[1]);
80002ad6:	06 9b       	mov	r11,r3
80002ad8:	6c 0c       	ld.w	r12,r6[0x0]
80002ada:	f0 1f 00 33 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_byte(addr[0]);
80002ade:	04 9b       	mov	r11,r2
80002ae0:	6c 0c       	ld.w	r12,r6[0x0]
80002ae2:	f0 1f 00 31 	mcall	80002ba4 <send_flash_command+0x1a4>
			break;
80002ae6:	c5 28       	rjmp	80002b8a <send_flash_command+0x18a>
		case CHIP_ERASE:
			spi_write_byte(command);
80002ae8:	36 0b       	mov	r11,96
80002aea:	4a d8       	lddpc	r8,80002b9c <send_flash_command+0x19c>
80002aec:	70 0c       	ld.w	r12,r8[0x0]
80002aee:	f0 1f 00 2e 	mcall	80002ba4 <send_flash_command+0x1a4>
			break;
80002af2:	c4 c8       	rjmp	80002b8a <send_flash_command+0x18a>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002af4:	4a a7       	lddpc	r7,80002b9c <send_flash_command+0x19c>
80002af6:	30 2b       	mov	r11,2
80002af8:	6e 0c       	ld.w	r12,r7[0x0]
80002afa:	f0 1f 00 2b 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_byte(addr[2]);
80002afe:	08 9b       	mov	r11,r4
80002b00:	6e 0c       	ld.w	r12,r7[0x0]
80002b02:	f0 1f 00 29 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_byte(addr[1]);
80002b06:	06 9b       	mov	r11,r3
80002b08:	6e 0c       	ld.w	r12,r7[0x0]
80002b0a:	f0 1f 00 27 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_byte(addr[0]);
80002b0e:	04 9b       	mov	r11,r2
80002b10:	6e 0c       	ld.w	r12,r7[0x0]
80002b12:	f0 1f 00 25 	mcall	80002ba4 <send_flash_command+0x1a4>
			for (i = 0; i < length; i++)
80002b16:	58 06       	cp.w	r6,0
80002b18:	c3 90       	breq	80002b8a <send_flash_command+0x18a>
80002b1a:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002b1c:	4a 04       	lddpc	r4,80002b9c <send_flash_command+0x19c>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002b1e:	0f 3b       	ld.ub	r11,r7++
80002b20:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002b22:	68 0c       	ld.w	r12,r4[0x0]
80002b24:	f0 1f 00 20 	mcall	80002ba4 <send_flash_command+0x1a4>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002b28:	0e 98       	mov	r8,r7
80002b2a:	0a 18       	sub	r8,r5
80002b2c:	ec 08 19 00 	cp.h	r8,r6
80002b30:	cf 73       	brcs	80002b1e <send_flash_command+0x11e>
80002b32:	c2 c8       	rjmp	80002b8a <send_flash_command+0x18a>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002b34:	49 a7       	lddpc	r7,80002b9c <send_flash_command+0x19c>
80002b36:	30 3b       	mov	r11,3
80002b38:	6e 0c       	ld.w	r12,r7[0x0]
80002b3a:	f0 1f 00 1b 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_byte(addr[2]);
80002b3e:	08 9b       	mov	r11,r4
80002b40:	6e 0c       	ld.w	r12,r7[0x0]
80002b42:	f0 1f 00 19 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_byte(addr[1]);
80002b46:	06 9b       	mov	r11,r3
80002b48:	6e 0c       	ld.w	r12,r7[0x0]
80002b4a:	f0 1f 00 17 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_byte(addr[0]);
80002b4e:	04 9b       	mov	r11,r2
80002b50:	6e 0c       	ld.w	r12,r7[0x0]
80002b52:	f0 1f 00 15 	mcall	80002ba4 <send_flash_command+0x1a4>
			for (i = 0; i < length; i++)
80002b56:	58 06       	cp.w	r6,0
80002b58:	c1 90       	breq	80002b8a <send_flash_command+0x18a>
80002b5a:	0a 97       	mov	r7,r5
			{
				//spi_write_dummy();
				spi_read_byte(&data_u16);
80002b5c:	1a 94       	mov	r4,sp
80002b5e:	49 03       	lddpc	r3,80002b9c <send_flash_command+0x19c>
80002b60:	1a 9b       	mov	r11,sp
80002b62:	66 0c       	ld.w	r12,r3[0x0]
80002b64:	f0 1f 00 11 	mcall	80002ba8 <send_flash_command+0x1a8>
				*data_ptr = (U8)data_u16;
80002b68:	9a 08       	ld.sh	r8,sp[0x0]
80002b6a:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002b6c:	0e 98       	mov	r8,r7
80002b6e:	0a 18       	sub	r8,r5
80002b70:	ec 08 19 00 	cp.h	r8,r6
80002b74:	cf 63       	brcs	80002b60 <send_flash_command+0x160>
80002b76:	c0 a8       	rjmp	80002b8a <send_flash_command+0x18a>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002b78:	48 97       	lddpc	r7,80002b9c <send_flash_command+0x19c>
80002b7a:	30 1b       	mov	r11,1
80002b7c:	6e 0c       	ld.w	r12,r7[0x0]
80002b7e:	f0 1f 00 0a 	mcall	80002ba4 <send_flash_command+0x1a4>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002b82:	30 0b       	mov	r11,0
80002b84:	6e 0c       	ld.w	r12,r7[0x0]
80002b86:	f0 1f 00 08 	mcall	80002ba4 <send_flash_command+0x1a4>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002b8a:	30 1b       	mov	r11,1
80002b8c:	48 48       	lddpc	r8,80002b9c <send_flash_command+0x19c>
80002b8e:	70 0c       	ld.w	r12,r8[0x0]
80002b90:	f0 1f 00 07 	mcall	80002bac <send_flash_command+0x1ac>

	return status;
}
80002b94:	9a 1c       	ld.sh	r12,sp[0x2]
80002b96:	2f fd       	sub	sp,-4
80002b98:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002b9c:	00 00       	add	r0,r0
80002b9e:	20 24       	sub	r4,2
80002ba0:	80 00       	ld.sh	r0,r0[0x0]
80002ba2:	5b 34       	cp.w	r4,-13
80002ba4:	80 00       	ld.sh	r0,r0[0x0]
80002ba6:	59 ce       	cp.w	lr,28
80002ba8:	80 00       	ld.sh	r0,r0[0x0]
80002baa:	59 ea       	cp.w	r10,30
80002bac:	80 00       	ld.sh	r0,r0[0x0]
80002bae:	5a f4       	cp.w	r4,-17

80002bb0 <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002bb0:	eb cd 40 c0 	pushm	r6-r7,lr
80002bb4:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 0,//1,
		.spi_mode     = 0,//0,
		.modfdis      = 1
	};
80002bb6:	4c 38       	lddpc	r8,80002cc0 <data_flash_init+0x110>
80002bb8:	fa c6 ff fc 	sub	r6,sp,-4
80002bbc:	f0 ea 00 00 	ld.d	r10,r8[0]
80002bc0:	ec eb 00 00 	st.d	r6[0],r10
80002bc4:	f0 e8 00 08 	ld.d	r8,r8[8]
80002bc8:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002bcc:	30 4b       	mov	r11,4
80002bce:	4b ec       	lddpc	r12,80002cc4 <data_flash_init+0x114>
80002bd0:	f0 1f 00 3e 	mcall	80002cc8 <data_flash_init+0x118>

	gpio_enable_gpio_pin(AVR32_PIN_PA23);
80002bd4:	31 7c       	mov	r12,23
80002bd6:	f0 1f 00 3e 	mcall	80002ccc <data_flash_init+0x11c>

	spi = &AVR32_SPI;
80002bda:	4b e7       	lddpc	r7,80002cd0 <data_flash_init+0x120>
80002bdc:	fe 7c 24 00 	mov	r12,-56320
80002be0:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002be2:	0c 9b       	mov	r11,r6
80002be4:	f0 1f 00 3c 	mcall	80002cd4 <data_flash_init+0x124>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002be8:	30 09       	mov	r9,0
80002bea:	12 9a       	mov	r10,r9
80002bec:	12 9b       	mov	r11,r9
80002bee:	6e 0c       	ld.w	r12,r7[0x0]
80002bf0:	f0 1f 00 3a 	mcall	80002cd8 <data_flash_init+0x128>

	// Enable SPI.
	spi_enable(spi);
80002bf4:	6e 0c       	ld.w	r12,r7[0x0]
80002bf6:	f0 1f 00 3a 	mcall	80002cdc <data_flash_init+0x12c>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002bfa:	e0 6a 36 00 	mov	r10,13824
80002bfe:	ea 1a 01 6e 	orh	r10,0x16e
80002c02:	0c 9b       	mov	r11,r6
80002c04:	6e 0c       	ld.w	r12,r7[0x0]
80002c06:	f0 1f 00 37 	mcall	80002ce0 <data_flash_init+0x130>
80002c0a:	c0 50       	breq	80002c14 <data_flash_init+0x64>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002c0c:	30 29       	mov	r9,2
80002c0e:	4b 68       	lddpc	r8,80002ce4 <data_flash_init+0x134>
80002c10:	b0 89       	st.b	r8[0x0],r9
		return;
80002c12:	c5 38       	rjmp	80002cb8 <data_flash_init+0x108>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002c14:	1a 96       	mov	r6,sp
80002c16:	30 4a       	mov	r10,4
80002c18:	4b 4b       	lddpc	r11,80002ce8 <data_flash_init+0x138>
80002c1a:	1a 9c       	mov	r12,sp
80002c1c:	f0 1f 00 34 	mcall	80002cec <data_flash_init+0x13c>

	/* DF memory check. */
	/* Select the DF memory to check. */
	//spi_selectChip(spi, DF_SPI_PCS_0);
	CLR_SPI_CS_1;
80002c20:	31 7c       	mov	r12,23
80002c22:	f0 1f 00 34 	mcall	80002cf0 <data_flash_init+0x140>
	
	spi_selectChip(spi, DF_SPI_PCS_1);
80002c26:	4a b7       	lddpc	r7,80002cd0 <data_flash_init+0x120>
80002c28:	30 1b       	mov	r11,1
80002c2a:	6e 0c       	ld.w	r12,r7[0x0]
80002c2c:	f0 1f 00 32 	mcall	80002cf4 <data_flash_init+0x144>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);
80002c30:	e0 6b 00 90 	mov	r11,144
80002c34:	6e 0c       	ld.w	r12,r7[0x0]
80002c36:	f0 1f 00 31 	mcall	80002cf8 <data_flash_init+0x148>

	/* Send 2 dummy byte and 1 zero byte to read the status register. */
	spi_write_dummy();
80002c3a:	e0 6b 00 ff 	mov	r11,255
80002c3e:	6e 0c       	ld.w	r12,r7[0x0]
80002c40:	f0 1f 00 2e 	mcall	80002cf8 <data_flash_init+0x148>
	spi_write_dummy();
80002c44:	e0 6b 00 ff 	mov	r11,255
80002c48:	6e 0c       	ld.w	r12,r7[0x0]
80002c4a:	f0 1f 00 2c 	mcall	80002cf8 <data_flash_init+0x148>
	//spi_write_zero();
	//spi_write_zero();
	spi_write_zero();
80002c4e:	30 0b       	mov	r11,0
80002c50:	6e 0c       	ld.w	r12,r7[0x0]
80002c52:	f0 1f 00 2a 	mcall	80002cf8 <data_flash_init+0x148>
	
	spi_read(spi, &manufacturer_device_id[0]);
80002c56:	1a 9b       	mov	r11,sp
80002c58:	6e 0c       	ld.w	r12,r7[0x0]
80002c5a:	f0 1f 00 29 	mcall	80002cfc <data_flash_init+0x14c>
	
	spi_read(spi, &manufacturer_device_id[1]);
80002c5e:	fa cb ff fe 	sub	r11,sp,-2
80002c62:	6e 0c       	ld.w	r12,r7[0x0]
80002c64:	f0 1f 00 26 	mcall	80002cfc <data_flash_init+0x14c>

	/* Unselect the checked DF memory. */
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	spi_unselectChip(spi, DF_SPI_PCS_1);
80002c68:	30 1b       	mov	r11,1
80002c6a:	6e 0c       	ld.w	r12,r7[0x0]
80002c6c:	f0 1f 00 25 	mcall	80002d00 <data_flash_init+0x150>
	
	SET_SPI_CS_1;
80002c70:	31 7c       	mov	r12,23
80002c72:	f0 1f 00 25 	mcall	80002d04 <data_flash_init+0x154>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
80002c76:	e0 68 00 ef 	mov	r8,239
80002c7a:	9a 09       	ld.sh	r9,sp[0x0]
80002c7c:	f0 09 19 00 	cp.h	r9,r8
80002c80:	c0 61       	brne	80002c8c <data_flash_init+0xdc>
80002c82:	31 68       	mov	r8,22
80002c84:	9a 19       	ld.sh	r9,sp[0x2]
80002c86:	f0 09 19 00 	cp.h	r9,r8
80002c8a:	c0 50       	breq	80002c94 <data_flash_init+0xe4>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002c8c:	30 39       	mov	r9,3
80002c8e:	49 68       	lddpc	r8,80002ce4 <data_flash_init+0x134>
80002c90:	b0 89       	st.b	r8[0x0],r9
		return;
80002c92:	c1 38       	rjmp	80002cb8 <data_flash_init+0x108>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c94:	30 09       	mov	r9,0
80002c96:	12 9a       	mov	r10,r9
80002c98:	12 9b       	mov	r11,r9
80002c9a:	30 6c       	mov	r12,6
80002c9c:	f0 1f 00 1b 	mcall	80002d08 <data_flash_init+0x158>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002ca0:	30 09       	mov	r9,0
80002ca2:	12 9a       	mov	r10,r9
80002ca4:	12 9b       	mov	r11,r9
80002ca6:	30 1c       	mov	r12,1
80002ca8:	f0 1f 00 18 	mcall	80002d08 <data_flash_init+0x158>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002cac:	30 09       	mov	r9,0
80002cae:	12 9a       	mov	r10,r9
80002cb0:	12 9b       	mov	r11,r9
80002cb2:	30 5c       	mov	r12,5
80002cb4:	f0 1f 00 15 	mcall	80002d08 <data_flash_init+0x158>
	
	return;
}
80002cb8:	2f bd       	sub	sp,-20
80002cba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002cbe:	00 00       	add	r0,r0
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	d9 60       	acall	0x96
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	d9 40       	acall	0x94
80002cc8:	80 00       	ld.sh	r0,r0[0x0]
80002cca:	54 f4       	stdsp	sp[0x13c],r4
80002ccc:	80 00       	ld.sh	r0,r0[0x0]
80002cce:	55 24       	stdsp	sp[0x148],r4
80002cd0:	00 00       	add	r0,r0
80002cd2:	20 24       	sub	r4,2
80002cd4:	80 00       	ld.sh	r0,r0[0x0]
80002cd6:	59 64       	cp.w	r4,22
80002cd8:	80 00       	ld.sh	r0,r0[0x0]
80002cda:	59 9c       	cp.w	r12,25
80002cdc:	80 00       	ld.sh	r0,r0[0x0]
80002cde:	59 c8       	cp.w	r8,28
80002ce0:	80 00       	ld.sh	r0,r0[0x0]
80002ce2:	5a 0c       	cp.w	r12,-32
80002ce4:	00 00       	add	r0,r0
80002ce6:	0a 6c       	and	r12,r5
80002ce8:	80 00       	ld.sh	r0,r0[0x0]
80002cea:	d9 3a       	popm	r0-r7,r11,pc,r12=0
80002cec:	80 00       	ld.sh	r0,r0[0x0]
80002cee:	79 8c       	ld.w	r12,r12[0x60]
80002cf0:	80 00       	ld.sh	r0,r0[0x0]
80002cf2:	55 58       	stdsp	sp[0x154],r8
80002cf4:	80 00       	ld.sh	r0,r0[0x0]
80002cf6:	5b 34       	cp.w	r4,-13
80002cf8:	80 00       	ld.sh	r0,r0[0x0]
80002cfa:	59 ce       	cp.w	lr,28
80002cfc:	80 00       	ld.sh	r0,r0[0x0]
80002cfe:	59 ea       	cp.w	r10,30
80002d00:	80 00       	ld.sh	r0,r0[0x0]
80002d02:	5a f4       	cp.w	r4,-17
80002d04:	80 00       	ld.sh	r0,r0[0x0]
80002d06:	55 3c       	stdsp	sp[0x14c],r12
80002d08:	80 00       	ld.sh	r0,r0[0x0]
80002d0a:	2a 00       	sub	r0,-96

80002d0c <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80002d0c:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
80002d0e:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
80002d10:	30 0a       	mov	r10,0
80002d12:	32 8b       	mov	r11,40
80002d14:	49 5c       	lddpc	r12,80002d68 <xg_rtc_init+0x5c>
80002d16:	f0 1f 00 16 	mcall	80002d6c <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
80002d1a:	30 ea       	mov	r10,14
80002d1c:	30 1b       	mov	r11,1
80002d1e:	fe 7c 0d 00 	mov	r12,-62208
80002d22:	f0 1f 00 14 	mcall	80002d70 <xg_rtc_init+0x64>
80002d26:	c0 41       	brne	80002d2e <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80002d28:	49 3c       	lddpc	r12,80002d74 <xg_rtc_init+0x68>
80002d2a:	f0 1f 00 14 	mcall	80002d78 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
80002d2e:	30 0b       	mov	r11,0
80002d30:	fe 7c 0d 00 	mov	r12,-62208
80002d34:	f0 1f 00 12 	mcall	80002d7c <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80002d38:	fe 7c 0d 00 	mov	r12,-62208
80002d3c:	f0 1f 00 11 	mcall	80002d80 <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
80002d40:	fe 7c 0d 00 	mov	r12,-62208
80002d44:	f0 1f 00 10 	mcall	80002d84 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80002d48:	49 08       	lddpc	r8,80002d88 <xg_rtc_init+0x7c>
80002d4a:	31 09       	mov	r9,16
80002d4c:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
80002d4e:	30 29       	mov	r9,2
80002d50:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
80002d52:	31 d9       	mov	r9,29
80002d54:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80002d56:	31 79       	mov	r9,23
80002d58:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80002d5a:	33 b9       	mov	r9,59
80002d5c:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
80002d5e:	32 89       	mov	r9,40
80002d60:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
80002d62:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80002d64:	d8 02       	popm	pc
80002d66:	00 00       	add	r0,r0
80002d68:	80 00       	ld.sh	r0,r0[0x0]
80002d6a:	2d 8c       	sub	r12,-40
80002d6c:	80 00       	ld.sh	r0,r0[0x0]
80002d6e:	55 78       	stdsp	sp[0x15c],r8
80002d70:	80 00       	ld.sh	r0,r0[0x0]
80002d72:	58 c4       	cp.w	r4,12
80002d74:	80 00       	ld.sh	r0,r0[0x0]
80002d76:	d9 70       	acall	0x97
80002d78:	80 00       	ld.sh	r0,r0[0x0]
80002d7a:	71 10       	ld.w	r0,r8[0x44]
80002d7c:	80 00       	ld.sh	r0,r0[0x0]
80002d7e:	58 80       	cp.w	r0,8
80002d80:	80 00       	ld.sh	r0,r0[0x0]
80002d82:	58 78       	cp.w	r8,7
80002d84:	80 00       	ld.sh	r0,r0[0x0]
80002d86:	58 54       	cp.w	r4,5
80002d88:	00 00       	add	r0,r0
80002d8a:	0d 9c       	ld.ub	r12,r6[0x1]

80002d8c <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
80002d8c:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
80002d8e:	4b 98       	lddpc	r8,80002e70 <rtc_irq+0xe4>
80002d90:	11 d9       	ld.ub	r9,r8[0x5]
80002d92:	2f f9       	sub	r9,-1
80002d94:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
80002d96:	11 d9       	ld.ub	r9,r8[0x5]
80002d98:	33 b8       	mov	r8,59
80002d9a:	f0 09 18 00 	cp.b	r9,r8
80002d9e:	e0 88 00 5f 	brls	80002e5c <rtc_irq+0xd0>
	{
		Current_time.Second =0;
80002da2:	4b 48       	lddpc	r8,80002e70 <rtc_irq+0xe4>
80002da4:	30 09       	mov	r9,0
80002da6:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
80002da8:	11 c9       	ld.ub	r9,r8[0x4]
80002daa:	2f f9       	sub	r9,-1
80002dac:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
80002dae:	11 c9       	ld.ub	r9,r8[0x4]
80002db0:	33 b8       	mov	r8,59
80002db2:	f0 09 18 00 	cp.b	r9,r8
80002db6:	e0 88 00 53 	brls	80002e5c <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
80002dba:	4a e8       	lddpc	r8,80002e70 <rtc_irq+0xe4>
80002dbc:	30 09       	mov	r9,0
80002dbe:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
80002dc0:	11 b9       	ld.ub	r9,r8[0x3]
80002dc2:	2f f9       	sub	r9,-1
80002dc4:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
80002dc6:	11 b9       	ld.ub	r9,r8[0x3]
80002dc8:	31 78       	mov	r8,23
80002dca:	f0 09 18 00 	cp.b	r9,r8
80002dce:	e0 88 00 47 	brls	80002e5c <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
80002dd2:	4a 88       	lddpc	r8,80002e70 <rtc_irq+0xe4>
80002dd4:	30 09       	mov	r9,0
80002dd6:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80002dd8:	11 88       	ld.ub	r8,r8[0x0]
80002dda:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002dde:	e0 69 01 6e 	mov	r9,366
80002de2:	e0 6a 01 6d 	mov	r10,365
80002de6:	f4 08 17 10 	movne	r8,r10
80002dea:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
80002dee:	4a 19       	lddpc	r9,80002e70 <rtc_irq+0xe4>
80002df0:	13 9a       	ld.ub	r10,r9[0x1]
80002df2:	30 29       	mov	r9,2
80002df4:	f2 0a 18 00 	cp.b	r10,r9
80002df8:	c0 b0       	breq	80002e0e <rtc_irq+0x82>
80002dfa:	49 e8       	lddpc	r8,80002e70 <rtc_irq+0xe4>
80002dfc:	11 99       	ld.ub	r9,r8[0x1]
80002dfe:	11 9a       	ld.ub	r10,r8[0x1]
80002e00:	a3 9a       	lsr	r10,0x3
80002e02:	12 0a       	add	r10,r9
80002e04:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80002e08:	2e 2a       	sub	r10,-30
80002e0a:	5c 5a       	castu.b	r10
80002e0c:	c0 58       	rjmp	80002e16 <rtc_irq+0x8a>
80002e0e:	f0 c8 01 51 	sub	r8,r8,337
80002e12:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80002e16:	49 78       	lddpc	r8,80002e70 <rtc_irq+0xe4>
80002e18:	11 a9       	ld.ub	r9,r8[0x2]
80002e1a:	2f f9       	sub	r9,-1
80002e1c:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
80002e1e:	11 a8       	ld.ub	r8,r8[0x2]
80002e20:	f0 0a 18 00 	cp.b	r10,r8
80002e24:	c1 c2       	brcc	80002e5c <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80002e26:	49 38       	lddpc	r8,80002e70 <rtc_irq+0xe4>
80002e28:	30 19       	mov	r9,1
80002e2a:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80002e2c:	11 99       	ld.ub	r9,r8[0x1]
80002e2e:	2f f9       	sub	r9,-1
80002e30:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
80002e32:	11 99       	ld.ub	r9,r8[0x1]
80002e34:	30 c8       	mov	r8,12
80002e36:	f0 09 18 00 	cp.b	r9,r8
80002e3a:	e0 88 00 11 	brls	80002e5c <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
80002e3e:	48 d8       	lddpc	r8,80002e70 <rtc_irq+0xe4>
80002e40:	30 19       	mov	r9,1
80002e42:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80002e44:	11 89       	ld.ub	r9,r8[0x0]
80002e46:	2f f9       	sub	r9,-1
80002e48:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80002e4a:	11 89       	ld.ub	r9,r8[0x0]
80002e4c:	39 68       	mov	r8,-106
80002e4e:	f0 09 18 00 	cp.b	r9,r8
80002e52:	e0 88 00 05 	brls	80002e5c <rtc_irq+0xd0>
80002e56:	30 09       	mov	r9,0
80002e58:	48 68       	lddpc	r8,80002e70 <rtc_irq+0xe4>
80002e5a:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80002e5c:	fe 7c 0d 00 	mov	r12,-62208
80002e60:	f0 1f 00 05 	mcall	80002e74 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80002e64:	30 19       	mov	r9,1
80002e66:	48 58       	lddpc	r8,80002e78 <rtc_irq+0xec>
80002e68:	91 09       	st.w	r8[0x0],r9
}
80002e6a:	d4 02       	popm	lr
80002e6c:	d6 03       	rete
80002e6e:	00 00       	add	r0,r0
80002e70:	00 00       	add	r0,r0
80002e72:	0d 9c       	ld.ub	r12,r6[0x1]
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	58 a4       	cp.w	r4,10
80002e78:	00 00       	add	r0,r0
80002e7a:	04 f4       	st.b	--r2,r4

80002e7c <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
80002e7c:	20 1c       	sub	r12,1
80002e7e:	5c 5c       	castu.b	r12
80002e80:	31 18       	mov	r8,17
80002e82:	f0 0c 18 00 	cp.b	r12,r8
80002e86:	e0 88 00 03 	brls	80002e8c <CalculateBurst+0x10>
80002e8a:	5e fd       	retal	0
80002e8c:	48 28       	lddpc	r8,80002e94 <CalculateBurst+0x18>
80002e8e:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
80002e92:	5e fc       	retal	r12
80002e94:	80 00       	ld.sh	r0,r0[0x0]
80002e96:	d9 90       	acall	0x99

80002e98 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
80002e98:	48 38       	lddpc	r8,80002ea4 <payload_init+0xc>
80002e9a:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
80002e9c:	48 38       	lddpc	r8,80002ea8 <payload_init+0x10>
80002e9e:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
80002ea0:	5e fc       	retal	r12
80002ea2:	00 00       	add	r0,r0
80002ea4:	00 00       	add	r0,r0
80002ea6:	0a 70       	tst	r0,r5
80002ea8:	00 00       	add	r0,r0
80002eaa:	0a 74       	tst	r4,r5

80002eac <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
80002eac:	d4 01       	pushm	lr
80002eae:	20 2d       	sub	sp,8
80002eb0:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002eb2:	30 09       	mov	r9,0
80002eb4:	fa ca ff f8 	sub	r10,sp,-8
80002eb8:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002eba:	1a 9b       	mov	r11,sp
80002ebc:	f0 1f 00 02 	mcall	80002ec4 <set_idle_store_isr+0x18>
}
80002ec0:	2f ed       	sub	sp,-8
80002ec2:	d8 02       	popm	pc
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	64 88       	ld.w	r8,r2[0x20]

80002ec8 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002ec8:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002eca:	48 48       	lddpc	r8,80002ed8 <payload_rx+0x10>
80002ecc:	70 08       	ld.w	r8,r8[0x0]
80002ece:	18 9b       	mov	r11,r12
80002ed0:	10 9c       	mov	r12,r8
80002ed2:	f0 1f 00 03 	mcall	80002edc <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002ed6:	d8 02       	popm	pc
80002ed8:	00 00       	add	r0,r0
80002eda:	0a ac       	st.w	r5++,r12
80002edc:	80 00       	ld.sh	r0,r0[0x0]
80002ede:	2e ac       	sub	r12,-22

80002ee0 <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002ee0:	d4 01       	pushm	lr
80002ee2:	20 2d       	sub	sp,8
80002ee4:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002ee6:	58 0c       	cp.w	r12,0
80002ee8:	c1 10       	breq	80002f0a <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002eea:	30 08       	mov	r8,0
80002eec:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002eee:	98 88       	ld.uh	r8,r12[0x0]
80002ef0:	e2 18 f0 00 	andl	r8,0xf000,COH
80002ef4:	e0 48 40 00 	cp.w	r8,16384
80002ef8:	c0 91       	brne	80002f0a <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002efa:	48 68       	lddpc	r8,80002f10 <phy_rx+0x30>
80002efc:	70 0c       	ld.w	r12,r8[0x0]
80002efe:	30 09       	mov	r9,0
80002f00:	fa ca ff fc 	sub	r10,sp,-4
80002f04:	1a 9b       	mov	r11,sp
80002f06:	f0 1f 00 04 	mcall	80002f14 <phy_rx+0x34>
		}	

    }
		
 
}
80002f0a:	2f ed       	sub	sp,-8
80002f0c:	d8 02       	popm	pc
80002f0e:	00 00       	add	r0,r0
80002f10:	00 00       	add	r0,r0
80002f12:	0a b8       	st.h	r5++,r8
80002f14:	80 00       	ld.sh	r0,r0[0x0]
80002f16:	64 88       	ld.w	r8,r2[0x20]

80002f18 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002f18:	eb cd 40 80 	pushm	r7,lr
80002f1c:	20 1d       	sub	sp,4
80002f1e:	fa c7 ff fc 	sub	r7,sp,-4
80002f22:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002f24:	30 09       	mov	r9,0
80002f26:	12 9a       	mov	r10,r9
80002f28:	1a 9b       	mov	r11,sp
80002f2a:	f0 1f 00 03 	mcall	80002f34 <set_idle_store+0x1c>
}
80002f2e:	2f fd       	sub	sp,-4
80002f30:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f34:	80 00       	ld.sh	r0,r0[0x0]
80002f36:	64 d8       	ld.w	r8,r2[0x34]

80002f38 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002f38:	d4 01       	pushm	lr
80002f3a:	20 1d       	sub	sp,4
80002f3c:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002f3e:	98 88       	ld.uh	r8,r12[0x0]
80002f40:	e2 18 f0 00 	andl	r8,0xf000,COH
80002f44:	e0 48 40 00 	cp.w	r8,16384
80002f48:	c0 d1       	brne	80002f62 <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002f4a:	49 08       	lddpc	r8,80002f88 <phy_tx+0x50>
80002f4c:	70 08       	ld.w	r8,r8[0x0]
80002f4e:	58 08       	cp.w	r8,0
80002f50:	c1 a0       	breq	80002f84 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002f52:	48 e8       	lddpc	r8,80002f88 <phy_tx+0x50>
80002f54:	70 0c       	ld.w	r12,r8[0x0]
80002f56:	30 09       	mov	r9,0
80002f58:	12 9a       	mov	r10,r9
80002f5a:	1a 9b       	mov	r11,sp
80002f5c:	f0 1f 00 0c 	mcall	80002f8c <phy_tx+0x54>
80002f60:	c1 28       	rjmp	80002f84 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002f62:	e0 48 10 00 	cp.w	r8,4096
80002f66:	5f 0a       	sreq	r10
80002f68:	e0 48 20 00 	cp.w	r8,8192
80002f6c:	5f 09       	sreq	r9
80002f6e:	f5 e9 10 09 	or	r9,r10,r9
80002f72:	c0 71       	brne	80002f80 <phy_tx+0x48>
80002f74:	e0 48 50 00 	cp.w	r8,20480
80002f78:	c0 40       	breq	80002f80 <phy_tx+0x48>
80002f7a:	e0 48 60 00 	cp.w	r8,24576
80002f7e:	c0 31       	brne	80002f84 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002f80:	48 48       	lddpc	r8,80002f90 <phy_tx+0x58>
80002f82:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002f84:	2f fd       	sub	sp,-4
80002f86:	d8 02       	popm	pc
80002f88:	00 00       	add	r0,r0
80002f8a:	0a d8       	st.w	--r5,r8
80002f8c:	80 00       	ld.sh	r0,r0[0x0]
80002f8e:	64 d8       	ld.w	r8,r2[0x34]
80002f90:	00 00       	add	r0,r0
80002f92:	0a cc       	st.b	r5++,r12

80002f94 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002f94:	d4 01       	pushm	lr
80002f96:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002f98:	30 08       	mov	r8,0
80002f9a:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002f9c:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002f9e:	1a 9a       	mov	r10,sp
80002fa0:	fa cb ff fc 	sub	r11,sp,-4
80002fa4:	f0 1f 00 05 	mcall	80002fb8 <get_idle_store_isr+0x24>
80002fa8:	58 1c       	cp.w	r12,1
80002faa:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002fae:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002fb2:	2f ed       	sub	sp,-8
80002fb4:	d8 02       	popm	pc
80002fb6:	00 00       	add	r0,r0
80002fb8:	80 00       	ld.sh	r0,r0[0x0]
80002fba:	61 dc       	ld.w	r12,r0[0x74]

80002fbc <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002fbc:	eb cd 40 c0 	pushm	r6-r7,lr
80002fc0:	20 1d       	sub	sp,4
80002fc2:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002fc4:	4b a8       	lddpc	r8,800030ac <phy_tx_func+0xf0>
80002fc6:	70 08       	ld.w	r8,r8[0x0]
80002fc8:	58 08       	cp.w	r8,0
80002fca:	c6 60       	breq	80003096 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002fcc:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002fce:	30 08       	mov	r8,0
80002fd0:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002fd2:	4b 88       	lddpc	r8,800030b0 <phy_tx_func+0xf4>
80002fd4:	70 08       	ld.w	r8,r8[0x0]
80002fd6:	58 18       	cp.w	r8,1
80002fd8:	c2 60       	breq	80003024 <phy_tx_func+0x68>
80002fda:	c0 43       	brcs	80002fe2 <phy_tx_func+0x26>
80002fdc:	58 28       	cp.w	r8,2
80002fde:	c5 c1       	brne	80003096 <phy_tx_func+0xda>
80002fe0:	c5 58       	rjmp	8000308a <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002fe2:	4b 38       	lddpc	r8,800030ac <phy_tx_func+0xf0>
80002fe4:	70 0c       	ld.w	r12,r8[0x0]
80002fe6:	1a 9a       	mov	r10,sp
80002fe8:	4b 3b       	lddpc	r11,800030b4 <phy_tx_func+0xf8>
80002fea:	f0 1f 00 34 	mcall	800030b8 <phy_tx_func+0xfc>
80002fee:	58 1c       	cp.w	r12,1
80002ff0:	c1 41       	brne	80003018 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002ff2:	4b 18       	lddpc	r8,800030b4 <phy_tx_func+0xf8>
80002ff4:	70 08       	ld.w	r8,r8[0x0]
80002ff6:	90 08       	ld.sh	r8,r8[0x0]
80002ff8:	10 9a       	mov	r10,r8
80002ffa:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002ffe:	4b 09       	lddpc	r9,800030bc <phy_tx_func+0x100>
80003000:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80003002:	5c 78       	castu.h	r8
80003004:	ea 18 ab cd 	orh	r8,0xabcd
80003008:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
8000300a:	30 19       	mov	r9,1
8000300c:	4a d8       	lddpc	r8,800030c0 <phy_tx_func+0x104>
8000300e:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80003010:	30 19       	mov	r9,1
80003012:	4a 88       	lddpc	r8,800030b0 <phy_tx_func+0xf4>
80003014:	91 09       	st.w	r8[0x0],r9
80003016:	c4 08       	rjmp	80003096 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80003018:	e0 68 5a 5a 	mov	r8,23130
8000301c:	ea 18 ab cd 	orh	r8,0xabcd
80003020:	8f 18       	st.w	r7[0x4],r8
80003022:	c3 a8       	rjmp	80003096 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003024:	4a 7a       	lddpc	r10,800030c0 <phy_tx_func+0x104>
80003026:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80003028:	4a 39       	lddpc	r9,800030b4 <phy_tx_func+0xf8>
8000302a:	72 09       	ld.w	r9,r9[0x0]
8000302c:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80003030:	b1 69       	lsl	r9,0x10
80003032:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80003034:	2f f8       	sub	r8,-1
80003036:	5c 58       	castu.b	r8
80003038:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
8000303a:	4a 1b       	lddpc	r11,800030bc <phy_tx_func+0x100>
8000303c:	96 0c       	ld.sh	r12,r11[0x0]
8000303e:	20 2c       	sub	r12,2
80003040:	5c 8c       	casts.h	r12
80003042:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80003046:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003048:	30 0b       	mov	r11,0
8000304a:	f6 0a 19 00 	cp.h	r10,r11
8000304e:	e0 89 00 09 	brgt	80003060 <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80003052:	e8 19 00 ba 	orl	r9,0xba
80003056:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80003058:	30 09       	mov	r9,0
8000305a:	49 68       	lddpc	r8,800030b0 <phy_tx_func+0xf4>
8000305c:	91 09       	st.w	r8[0x0],r9
8000305e:	c1 c8       	rjmp	80003096 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80003060:	49 5a       	lddpc	r10,800030b4 <phy_tx_func+0xf8>
80003062:	74 0a       	ld.w	r10,r10[0x0]
80003064:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80003068:	14 49       	or	r9,r10
8000306a:	8f 19       	st.w	r7[0x4],r9
8000306c:	2f f8       	sub	r8,-1
8000306e:	49 59       	lddpc	r9,800030c0 <phy_tx_func+0x104>
80003070:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80003072:	20 2c       	sub	r12,2
80003074:	49 28       	lddpc	r8,800030bc <phy_tx_func+0x100>
80003076:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80003078:	30 08       	mov	r8,0
8000307a:	f0 0c 19 00 	cp.h	r12,r8
8000307e:	e0 89 00 0c 	brgt	80003096 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80003082:	30 29       	mov	r9,2
80003084:	48 b8       	lddpc	r8,800030b0 <phy_tx_func+0xf4>
80003086:	91 09       	st.w	r8[0x0],r9
80003088:	c0 78       	rjmp	80003096 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
8000308a:	fc 18 00 ba 	movh	r8,0xba
8000308e:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80003090:	30 09       	mov	r9,0
80003092:	48 88       	lddpc	r8,800030b0 <phy_tx_func+0xf4>
80003094:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80003096:	e0 68 5a 5a 	mov	r8,23130
8000309a:	ea 18 ab cd 	orh	r8,0xabcd
8000309e:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
800030a0:	30 08       	mov	r8,0
800030a2:	8f 38       	st.w	r7[0xc],r8
}
800030a4:	2f fd       	sub	sp,-4
800030a6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800030aa:	00 00       	add	r0,r0
800030ac:	00 00       	add	r0,r0
800030ae:	0a d8       	st.w	--r5,r8
800030b0:	00 00       	add	r0,r0
800030b2:	0a 98       	mov	r8,r5
800030b4:	00 00       	add	r0,r0
800030b6:	0a a4       	st.w	r5++,r4
800030b8:	80 00       	ld.sh	r0,r0[0x0]
800030ba:	61 dc       	ld.w	r12,r0[0x74]
800030bc:	00 00       	add	r0,r0
800030be:	0a c0       	st.b	r5++,r0
800030c0:	00 00       	add	r0,r0
800030c2:	0a 78       	tst	r8,r5

800030c4 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800030c4:	d4 01       	pushm	lr
800030c6:	20 1d       	sub	sp,4
	void * ptr = NULL;
800030c8:	30 0a       	mov	r10,0
800030ca:	fa cb ff fc 	sub	r11,sp,-4
800030ce:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800030d0:	14 99       	mov	r9,r10
800030d2:	1a 9b       	mov	r11,sp
800030d4:	f0 1f 00 05 	mcall	800030e8 <get_idle_store+0x24>
800030d8:	58 1c       	cp.w	r12,1
800030da:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800030de:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800030e2:	2f fd       	sub	sp,-4
800030e4:	d8 02       	popm	pc
800030e6:	00 00       	add	r0,r0
800030e8:	80 00       	ld.sh	r0,r0[0x0]
800030ea:	62 cc       	ld.w	r12,r1[0x30]

800030ec <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
800030ec:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
800030ee:	48 5b       	lddpc	r11,80003100 <phy_init+0x14>
800030f0:	48 5c       	lddpc	r12,80003104 <phy_init+0x18>
800030f2:	f0 1f 00 06 	mcall	80003108 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
800030f6:	f0 1f 00 06 	mcall	8000310c <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
800030fa:	f0 1f 00 06 	mcall	80003110 <phy_init+0x24>
	
}
800030fe:	d8 02       	popm	pc
80003100:	80 00       	ld.sh	r0,r0[0x0]
80003102:	2f bc       	sub	r12,-5
80003104:	80 00       	ld.sh	r0,r0[0x0]
80003106:	31 14       	mov	r4,17
80003108:	80 00       	ld.sh	r0,r0[0x0]
8000310a:	41 74       	lddsp	r4,sp[0x5c]
8000310c:	80 00       	ld.sh	r0,r0[0x0]
8000310e:	41 88       	lddsp	r8,sp[0x60]
80003110:	80 00       	ld.sh	r0,r0[0x0]
80003112:	4b 34       	lddpc	r4,800031dc <phy_rx_func+0xc8>

80003114 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80003114:	eb cd 40 e0 	pushm	r5-r7,lr
80003118:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
8000311a:	fe f8 0e 7a 	ld.w	r8,pc[3706]
8000311e:	70 08       	ld.w	r8,r8[0x0]
80003120:	58 08       	cp.w	r8,0
80003122:	e0 80 01 08 	breq	80003332 <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80003126:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80003128:	fe f8 0e 70 	ld.w	r8,pc[3696]
8000312c:	70 09       	ld.w	r9,r8[0x0]
8000312e:	2f f9       	sub	r9,-1
80003130:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80003132:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80003136:	70 08       	ld.w	r8,r8[0x0]
80003138:	58 18       	cp.w	r8,1
8000313a:	e0 80 00 85 	breq	80003244 <phy_rx_func+0x130>
8000313e:	c0 73       	brcs	8000314c <phy_rx_func+0x38>
80003140:	58 28       	cp.w	r8,2
80003142:	c5 c0       	breq	800031fa <phy_rx_func+0xe6>
80003144:	58 38       	cp.w	r8,3
80003146:	e0 81 00 f6 	brne	80003332 <phy_rx_func+0x21e>
8000314a:	cd 58       	rjmp	800032f4 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
8000314c:	e0 6a 5a 5a 	mov	r10,23130
80003150:	ea 1a ab cd 	orh	r10,0xabcd
80003154:	14 36       	cp.w	r6,r10
80003156:	e0 80 00 ee 	breq	80003332 <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
8000315a:	ec 08 16 10 	lsr	r8,r6,0x10
8000315e:	e0 48 ab cd 	cp.w	r8,43981
80003162:	e0 81 00 e8 	brne	80003332 <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80003166:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
8000316a:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
8000316e:	20 28       	sub	r8,2
80003170:	fe f9 0e 30 	ld.w	r9,pc[3632]
80003174:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80003176:	30 09       	mov	r9,0
80003178:	f2 08 19 00 	cp.h	r8,r9
8000317c:	e0 8a 00 db 	brle	80003332 <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80003180:	fe f8 0e 24 	ld.w	r8,pc[3620]
80003184:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80003186:	fe f8 0e 22 	ld.w	r8,pc[3618]
8000318a:	70 0c       	ld.w	r12,r8[0x0]
8000318c:	f0 1f 03 88 	mcall	80003fac <phy_rx_func+0xe98>
80003190:	fe f8 0e 20 	ld.w	r8,pc[3616]
80003194:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80003196:	58 0c       	cp.w	r12,0
80003198:	e0 80 00 cd 	breq	80003332 <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
8000319c:	fe f8 0e 08 	ld.w	r8,pc[3592]
800031a0:	90 09       	ld.sh	r9,r8[0x0]
800031a2:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
800031a6:	2f f9       	sub	r9,-1
800031a8:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
800031aa:	fe fa 0e 06 	ld.w	r10,pc[3590]
800031ae:	74 0a       	ld.w	r10,r10[0x0]
800031b0:	fe fb 0d e8 	ld.w	r11,pc[3560]
800031b4:	76 0b       	ld.w	r11,r11[0x0]
800031b6:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
800031ba:	2f f9       	sub	r9,-1
800031bc:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
800031be:	e2 16 0f 00 	andl	r6,0xf00,COH
800031c2:	e0 46 01 00 	cp.w	r6,256
800031c6:	c0 c0       	breq	800031de <phy_rx_func+0xca>
800031c8:	e0 8b 00 05 	brhi	800031d2 <phy_rx_func+0xbe>
800031cc:	58 06       	cp.w	r6,0
800031ce:	c0 80       	breq	800031de <phy_rx_func+0xca>
800031d0:	c0 c8       	rjmp	800031e8 <phy_rx_func+0xd4>
800031d2:	e0 46 02 00 	cp.w	r6,512
800031d6:	c0 40       	breq	800031de <phy_rx_func+0xca>
800031d8:	e0 46 03 00 	cp.w	r6,768
800031dc:	c0 61       	brne	800031e8 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
800031de:	30 29       	mov	r9,2
800031e0:	fe f8 0d bc 	ld.w	r8,pc[3516]
800031e4:	91 09       	st.w	r8[0x0],r9
800031e6:	ca 68       	rjmp	80003332 <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
800031e8:	fe f8 0d c0 	ld.w	r8,pc[3520]
800031ec:	70 0c       	ld.w	r12,r8[0x0]
800031ee:	fe f8 0d c2 	ld.w	r8,pc[3522]
800031f2:	70 0b       	ld.w	r11,r8[0x0]
800031f4:	f0 1f 03 70 	mcall	80003fb4 <phy_rx_func+0xea0>
800031f8:	c9 d8       	rjmp	80003332 <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
800031fa:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
800031fe:	b1 86       	lsr	r6,0x10
80003200:	14 06       	add	r6,r10
80003202:	fe f8 0d b6 	ld.w	r8,pc[3510]
80003206:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80003208:	fe f8 0d 9c 	ld.w	r8,pc[3484]
8000320c:	90 09       	ld.sh	r9,r8[0x0]
8000320e:	fe fb 0d a2 	ld.w	r11,pc[3490]
80003212:	76 0b       	ld.w	r11,r11[0x0]
80003214:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80003218:	2f f9       	sub	r9,-1
8000321a:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
8000321c:	fe f9 0d 84 	ld.w	r9,pc[3460]
80003220:	92 08       	ld.sh	r8,r9[0x0]
80003222:	20 28       	sub	r8,2
80003224:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80003226:	30 09       	mov	r9,0
80003228:	f2 08 19 00 	cp.h	r8,r9
8000322c:	e0 8a 00 07 	brle	8000323a <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80003230:	30 19       	mov	r9,1
80003232:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80003236:	91 09       	st.w	r8[0x0],r9
80003238:	c7 d8       	rjmp	80003332 <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
8000323a:	30 39       	mov	r9,3
8000323c:	fe f8 0d 60 	ld.w	r8,pc[3424]
80003240:	91 09       	st.w	r8[0x0],r9
80003242:	c7 88       	rjmp	80003332 <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80003244:	ec 0a 14 10 	asr	r10,r6,0x10
80003248:	fe f8 0d 70 	ld.w	r8,pc[3440]
8000324c:	90 09       	ld.sh	r9,r8[0x0]
8000324e:	14 09       	add	r9,r10
80003250:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80003252:	fe f9 0d 52 	ld.w	r9,pc[3410]
80003256:	92 08       	ld.sh	r8,r9[0x0]
80003258:	fe fb 0d 58 	ld.w	r11,pc[3416]
8000325c:	76 0b       	ld.w	r11,r11[0x0]
8000325e:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80003262:	2f f8       	sub	r8,-1
80003264:	5c 88       	casts.h	r8
80003266:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80003268:	fe fa 0d 38 	ld.w	r10,pc[3384]
8000326c:	94 09       	ld.sh	r9,r10[0x0]
8000326e:	20 29       	sub	r9,2
80003270:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80003272:	30 0a       	mov	r10,0
80003274:	f4 09 19 00 	cp.h	r9,r10
80003278:	e0 89 00 20 	brgt	800032b8 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
8000327c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80003280:	e0 46 00 ba 	cp.w	r6,186
80003284:	c0 d1       	brne	8000329e <phy_rx_func+0x18a>
80003286:	fe f8 0d 32 	ld.w	r8,pc[3378]
8000328a:	90 09       	ld.sh	r9,r8[0x0]
8000328c:	f4 09 19 00 	cp.h	r9,r10
80003290:	c0 71       	brne	8000329e <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80003292:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80003296:	70 0c       	ld.w	r12,r8[0x0]
80003298:	f0 1f 03 49 	mcall	80003fbc <phy_rx_func+0xea8>
8000329c:	c0 98       	rjmp	800032ae <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
8000329e:	fe f8 0d 0a 	ld.w	r8,pc[3338]
800032a2:	70 0c       	ld.w	r12,r8[0x0]
800032a4:	fe f8 0d 0c 	ld.w	r8,pc[3340]
800032a8:	70 0b       	ld.w	r11,r8[0x0]
800032aa:	f0 1f 03 43 	mcall	80003fb4 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
800032ae:	30 09       	mov	r9,0
800032b0:	fe f8 0c ec 	ld.w	r8,pc[3308]
800032b4:	91 09       	st.w	r8[0x0],r9
800032b6:	c3 e8       	rjmp	80003332 <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
800032b8:	5c 86       	casts.h	r6
800032ba:	fe f9 0c fe 	ld.w	r9,pc[3326]
800032be:	92 0a       	ld.sh	r10,r9[0x0]
800032c0:	0c 0a       	add	r10,r6
800032c2:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
800032c4:	fe f9 0c ec 	ld.w	r9,pc[3308]
800032c8:	72 09       	ld.w	r9,r9[0x0]
800032ca:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
800032ce:	2f f8       	sub	r8,-1
800032d0:	fe f9 0c d4 	ld.w	r9,pc[3284]
800032d4:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
800032d6:	fe f9 0c ca 	ld.w	r9,pc[3274]
800032da:	92 08       	ld.sh	r8,r9[0x0]
800032dc:	20 28       	sub	r8,2
800032de:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
800032e0:	30 09       	mov	r9,0
800032e2:	f2 08 19 00 	cp.h	r8,r9
800032e6:	e0 89 00 26 	brgt	80003332 <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
800032ea:	30 39       	mov	r9,3
800032ec:	fe f8 0c b0 	ld.w	r8,pc[3248]
800032f0:	91 09       	st.w	r8[0x0],r9
800032f2:	c2 08       	rjmp	80003332 <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
800032f4:	e6 16 00 ff 	andh	r6,0xff,COH
800032f8:	fc 19 00 ba 	movh	r9,0xba
800032fc:	12 36       	cp.w	r6,r9
800032fe:	c0 e1       	brne	8000331a <phy_rx_func+0x206>
80003300:	fe f8 0c b8 	ld.w	r8,pc[3256]
80003304:	90 09       	ld.sh	r9,r8[0x0]
80003306:	30 08       	mov	r8,0
80003308:	f0 09 19 00 	cp.h	r9,r8
8000330c:	c0 71       	brne	8000331a <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
8000330e:	fe f8 0c a2 	ld.w	r8,pc[3234]
80003312:	70 0c       	ld.w	r12,r8[0x0]
80003314:	f0 1f 03 2a 	mcall	80003fbc <phy_rx_func+0xea8>
80003318:	c0 98       	rjmp	8000332a <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
8000331a:	fe f8 0c 8e 	ld.w	r8,pc[3214]
8000331e:	70 0c       	ld.w	r12,r8[0x0]
80003320:	fe f8 0c 90 	ld.w	r8,pc[3216]
80003324:	70 0b       	ld.w	r11,r8[0x0]
80003326:	f0 1f 03 24 	mcall	80003fb4 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
8000332a:	30 09       	mov	r9,0
8000332c:	fe f8 0c 70 	ld.w	r8,pc[3184]
80003330:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80003332:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80003336:	11 89       	ld.ub	r9,r8[0x0]
80003338:	30 08       	mov	r8,0
8000333a:	f0 09 18 00 	cp.b	r9,r8
8000333e:	c1 31       	brne	80003364 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80003340:	fe f6 0c 84 	ld.w	r6,pc[3204]
80003344:	6c 0c       	ld.w	r12,r6[0x0]
80003346:	f0 1f 03 1a 	mcall	80003fac <phy_rx_func+0xe98>
8000334a:	fe f8 0c 7e 	ld.w	r8,pc[3198]
8000334e:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80003350:	6c 0c       	ld.w	r12,r6[0x0]
80003352:	f0 1f 03 17 	mcall	80003fac <phy_rx_func+0xe98>
80003356:	fe f8 0c 76 	ld.w	r8,pc[3190]
8000335a:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
8000335c:	30 19       	mov	r9,1
8000335e:	fe f8 0c 62 	ld.w	r8,pc[3170]
80003362:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80003364:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80003368:	70 08       	ld.w	r8,r8[0x0]
8000336a:	58 28       	cp.w	r8,2
8000336c:	e0 80 01 98 	breq	8000369c <phy_rx_func+0x588>
80003370:	e0 8b 00 06 	brhi	8000337c <phy_rx_func+0x268>
80003374:	58 08       	cp.w	r8,0
80003376:	c0 b0       	breq	8000338c <phy_rx_func+0x278>
80003378:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000337c:	58 38       	cp.w	r8,3
8000337e:	e0 80 05 c5 	breq	80003f08 <phy_rx_func+0xdf4>
80003382:	58 48       	cp.w	r8,4
80003384:	e0 81 06 05 	brne	80003f8e <phy_rx_func+0xe7a>
80003388:	e0 8f 02 4b 	bral	8000381e <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
8000338c:	6e 28       	ld.w	r8,r7[0x8]
8000338e:	e0 6a 5a 5a 	mov	r10,23130
80003392:	ea 1a ab cd 	orh	r10,0xabcd
80003396:	14 38       	cp.w	r8,r10
80003398:	c0 71       	brne	800033a6 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
8000339a:	30 09       	mov	r9,0
8000339c:	fe f8 0c 38 	ld.w	r8,pc[3128]
800033a0:	91 09       	st.w	r8[0x0],r9
800033a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
800033a6:	10 99       	mov	r9,r8
800033a8:	e0 19 00 00 	andl	r9,0x0
800033ac:	fc 1a ab cd 	movh	r10,0xabcd
800033b0:	14 39       	cp.w	r9,r10
800033b2:	e0 81 05 ee 	brne	80003f8e <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
800033b6:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800033ba:	fe f9 0c 1e 	ld.w	r9,pc[3102]
800033be:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
800033c0:	6e 29       	ld.w	r9,r7[0x8]
800033c2:	e2 19 f0 00 	andl	r9,0xf000,COH
800033c6:	e0 49 c0 00 	cp.w	r9,49152
800033ca:	e0 81 00 ce 	brne	80003566 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
800033ce:	30 1a       	mov	r10,1
800033d0:	fe f9 0c 0c 	ld.w	r9,pc[3084]
800033d4:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
800033d6:	fe f9 0b f6 	ld.w	r9,pc[3062]
800033da:	72 09       	ld.w	r9,r9[0x0]
800033dc:	58 09       	cp.w	r9,0
800033de:	c0 71       	brne	800033ec <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800033e0:	fe fc 0c 00 	ld.w	r12,pc[3072]
800033e4:	f0 1f 03 00 	mcall	80003fe4 <phy_rx_func+0xed0>
800033e8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
800033ec:	ef 3a 00 0d 	ld.ub	r10,r7[13]
800033f0:	fe f9 0b f8 	ld.w	r9,pc[3064]
800033f4:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
800033f6:	ef 3b 00 0c 	ld.ub	r11,r7[12]
800033fa:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
800033fe:	fe fa 0b ee 	ld.w	r10,pc[3054]
80003402:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80003404:	13 89       	ld.ub	r9,r9[0x0]
80003406:	37 fa       	mov	r10,127
80003408:	f4 09 18 00 	cp.b	r9,r10
8000340c:	c6 d0       	breq	800034e6 <phy_rx_func+0x3d2>
8000340e:	e0 8b 00 0c 	brhi	80003426 <phy_rx_func+0x312>
80003412:	31 2a       	mov	r10,18
80003414:	f4 09 18 00 	cp.b	r9,r10
80003418:	c4 20       	breq	8000349c <phy_rx_func+0x388>
8000341a:	31 3a       	mov	r10,19
8000341c:	f4 09 18 00 	cp.b	r9,r10
80003420:	e0 81 00 83 	brne	80003526 <phy_rx_func+0x412>
80003424:	c5 b8       	rjmp	800034da <phy_rx_func+0x3c6>
80003426:	2f 09       	sub	r9,-16
80003428:	30 1a       	mov	r10,1
8000342a:	f4 09 18 00 	cp.b	r9,r10
8000342e:	e0 8b 00 7c 	brhi	80003526 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80003432:	ef 38 00 0e 	ld.ub	r8,r7[14]
80003436:	e2 18 00 f0 	andl	r8,0xf0,COH
8000343a:	59 08       	cp.w	r8,16
8000343c:	c0 71       	brne	8000344a <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
8000343e:	30 19       	mov	r9,1
80003440:	fe f8 0b 94 	ld.w	r8,pc[2964]
80003444:	91 09       	st.w	r8[0x0],r9
80003446:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
8000344a:	e0 48 00 20 	cp.w	r8,32
8000344e:	c2 11       	brne	80003490 <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80003450:	30 a9       	mov	r9,10
80003452:	fe f8 0b 82 	ld.w	r8,pc[2946]
80003456:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80003458:	fe f6 0b 98 	ld.w	r6,pc[2968]
8000345c:	6c 08       	ld.w	r8,r6[0x0]
8000345e:	f0 0a 11 ff 	rsub	r10,r8,-1
80003462:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80003466:	2f f8       	sub	r8,-1
80003468:	6e 0c       	ld.w	r12,r7[0x0]
8000346a:	f4 ca fe 00 	sub	r10,r10,-512
8000346e:	30 0b       	mov	r11,0
80003470:	10 0c       	add	r12,r8
80003472:	f0 1f 02 e1 	mcall	80003ff4 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80003476:	30 08       	mov	r8,0
80003478:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
8000347a:	6e 0c       	ld.w	r12,r7[0x0]
8000347c:	f0 1f 02 df 	mcall	80003ff8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003480:	fe f8 0b 44 	ld.w	r8,pc[2884]
80003484:	70 0c       	ld.w	r12,r8[0x0]
80003486:	f0 1f 02 ca 	mcall	80003fac <phy_rx_func+0xe98>
8000348a:	8f 0c       	st.w	r7[0x0],r12
8000348c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80003490:	30 09       	mov	r9,0
80003492:	fe f8 0b 42 	ld.w	r8,pc[2882]
80003496:	91 09       	st.w	r8[0x0],r9
80003498:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
8000349c:	20 48       	sub	r8,4
8000349e:	fe f9 0b 3a 	ld.w	r9,pc[2874]
800034a2:	93 08       	st.w	r9[0x0],r8
800034a4:	58 08       	cp.w	r8,0
800034a6:	e0 80 05 74 	breq	80003f8e <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
800034aa:	ef 3c 00 0f 	ld.ub	r12,r7[15]
800034ae:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
800034b2:	fe f8 0b 4a 	ld.w	r8,pc[2890]
800034b6:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
800034b8:	8e 69       	ld.sh	r9,r7[0xc]
800034ba:	fe f8 0b 46 	ld.w	r8,pc[2886]
800034be:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
800034c0:	8e 79       	ld.sh	r9,r7[0xe]
800034c2:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
800034c4:	f0 1f 02 d0 	mcall	80004004 <phy_rx_func+0xef0>
800034c8:	fe f8 0b 0c 	ld.w	r8,pc[2828]
800034cc:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
800034ce:	30 49       	mov	r9,4
800034d0:	fe f8 0b 00 	ld.w	r8,pc[2816]
800034d4:	91 09       	st.w	r8[0x0],r9
800034d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
800034da:	30 09       	mov	r9,0
800034dc:	fe f8 0a f8 	ld.w	r8,pc[2808]
800034e0:	91 09       	st.w	r8[0x0],r9
800034e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
800034e6:	20 48       	sub	r8,4
800034e8:	fe f9 0a f0 	ld.w	r9,pc[2800]
800034ec:	93 08       	st.w	r9[0x0],r8
800034ee:	58 08       	cp.w	r8,0
800034f0:	e0 80 05 4f 	breq	80003f8e <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
800034f4:	fe f8 0b 14 	ld.w	r8,pc[2836]
800034f8:	70 09       	ld.w	r9,r8[0x0]
800034fa:	8e 7b       	ld.sh	r11,r7[0xe]
800034fc:	fe fa 0b 10 	ld.w	r10,pc[2832]
80003500:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003504:	2f f9       	sub	r9,-1
80003506:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003508:	fe f8 0a e4 	ld.w	r8,pc[2788]
8000350c:	70 09       	ld.w	r9,r8[0x0]
8000350e:	20 29       	sub	r9,2
80003510:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
80003512:	30 29       	mov	r9,2
80003514:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003518:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
8000351a:	30 39       	mov	r9,3
8000351c:	fe f8 0a b4 	ld.w	r8,pc[2740]
80003520:	91 09       	st.w	r8[0x0],r9
80003522:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003526:	30 3a       	mov	r10,3
80003528:	fe f9 0a ac 	ld.w	r9,pc[2732]
8000352c:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000352e:	6e 2a       	ld.w	r10,r7[0x8]
80003530:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003534:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003536:	6e 3a       	ld.w	r10,r7[0xc]
80003538:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
8000353a:	59 48       	cp.w	r8,20
8000353c:	c0 61       	brne	80003548 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000353e:	31 89       	mov	r9,24
80003540:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003544:	91 09       	st.w	r8[0x0],r9
80003546:	c0 a8       	rjmp	8000355a <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003548:	fe f8 0a 90 	ld.w	r8,pc[2704]
8000354c:	70 08       	ld.w	r8,r8[0x0]
8000354e:	59 08       	cp.w	r8,16
80003550:	c0 51       	brne	8000355a <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
80003552:	31 09       	mov	r9,16
80003554:	fe f8 0a 84 	ld.w	r8,pc[2692]
80003558:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000355a:	30 49       	mov	r9,4
8000355c:	fe f8 0a 74 	ld.w	r8,pc[2676]
80003560:	91 09       	st.w	r8[0x0],r9
80003562:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
80003566:	e0 49 10 00 	cp.w	r9,4096
8000356a:	5f 1a       	srne	r10
8000356c:	e0 49 20 00 	cp.w	r9,8192
80003570:	5f 19       	srne	r9
80003572:	f5 e9 00 09 	and	r9,r10,r9
80003576:	e0 81 05 0c 	brne	80003f8e <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
8000357a:	fe fa 0a 9a 	ld.w	r10,pc[2714]
8000357e:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
80003580:	fe fa 0a 98 	ld.w	r10,pc[2712]
80003584:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
80003586:	fe fa 0a 62 	ld.w	r10,pc[2658]
8000358a:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
8000358c:	fe f9 0a 3c 	ld.w	r9,pc[2620]
80003590:	72 09       	ld.w	r9,r9[0x0]
80003592:	58 09       	cp.w	r9,0
80003594:	c0 71       	brne	800035a2 <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80003596:	fe fc 0a 4a 	ld.w	r12,pc[2634]
8000359a:	f0 1f 02 93 	mcall	80003fe4 <phy_rx_func+0xed0>
8000359e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800035a2:	6e 2a       	ld.w	r10,r7[0x8]
800035a4:	e2 1a 0f 00 	andl	r10,0xf00,COH
800035a8:	58 1a       	cp.w	r10,1
800035aa:	e0 8b 00 4d 	brhi	80003644 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800035ae:	20 48       	sub	r8,4
800035b0:	fe f9 0a 28 	ld.w	r9,pc[2600]
800035b4:	93 08       	st.w	r9[0x0],r8
800035b6:	58 08       	cp.w	r8,0
800035b8:	e0 80 04 eb 	breq	80003f8e <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
800035bc:	8e 68       	ld.sh	r8,r7[0xc]
800035be:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800035c2:	fe f9 0a 5a 	ld.w	r9,pc[2650]
800035c6:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
800035c8:	30 09       	mov	r9,0
800035ca:	f2 08 19 00 	cp.h	r8,r9
800035ce:	c0 70       	breq	800035dc <phy_rx_func+0x4c8>
800035d0:	30 19       	mov	r9,1
800035d2:	f2 08 19 00 	cp.h	r8,r9
800035d6:	e0 81 04 dc 	brne	80003f8e <phy_rx_func+0xe7a>
800035da:	c2 68       	rjmp	80003626 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800035dc:	fe f8 0a 44 	ld.w	r8,pc[2628]
800035e0:	70 0a       	ld.w	r10,r8[0x0]
800035e2:	fe f9 09 e6 	ld.w	r9,pc[2534]
800035e6:	72 09       	ld.w	r9,r9[0x0]
800035e8:	8e 7b       	ld.sh	r11,r7[0xe]
800035ea:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
800035ee:	70 09       	ld.w	r9,r8[0x0]
800035f0:	2f f9       	sub	r9,-1
800035f2:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800035f4:	e0 49 00 ff 	cp.w	r9,255
800035f8:	e0 88 00 11 	brls	8000361a <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
800035fc:	30 09       	mov	r9,0
800035fe:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
80003600:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003604:	6e 0c       	ld.w	r12,r7[0x0]
80003606:	f0 1f 02 7d 	mcall	80003ff8 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
8000360a:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000360e:	70 0c       	ld.w	r12,r8[0x0]
80003610:	f0 1f 02 67 	mcall	80003fac <phy_rx_func+0xe98>
80003614:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003616:	e0 80 04 bc 	breq	80003f8e <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
8000361a:	30 29       	mov	r9,2
8000361c:	fe f8 09 b4 	ld.w	r8,pc[2484]
80003620:	91 09       	st.w	r8[0x0],r9
80003622:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003626:	8e 79       	ld.sh	r9,r7[0xe]
80003628:	30 38       	mov	r8,3
8000362a:	f0 09 19 00 	cp.h	r9,r8
8000362e:	c0 51       	brne	80003638 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
80003630:	30 19       	mov	r9,1
80003632:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003636:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003638:	30 29       	mov	r9,2
8000363a:	fe f8 09 96 	ld.w	r8,pc[2454]
8000363e:	91 09       	st.w	r8[0x0],r9
80003640:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003644:	58 18       	cp.w	r8,1
80003646:	e0 88 04 a4 	brls	80003f8e <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
8000364a:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000364e:	70 0a       	ld.w	r10,r8[0x0]
80003650:	6e 3b       	ld.w	r11,r7[0xc]
80003652:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
80003656:	70 09       	ld.w	r9,r8[0x0]
80003658:	2f f9       	sub	r9,-1
8000365a:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
8000365c:	e0 49 00 ff 	cp.w	r9,255
80003660:	e0 88 00 11 	brls	80003682 <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
80003664:	30 09       	mov	r9,0
80003666:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003668:	fe f7 09 60 	ld.w	r7,pc[2400]
8000366c:	6e 0c       	ld.w	r12,r7[0x0]
8000366e:	f0 1f 02 63 	mcall	80003ff8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003672:	fe f8 09 52 	ld.w	r8,pc[2386]
80003676:	70 0c       	ld.w	r12,r8[0x0]
80003678:	f0 1f 02 4d 	mcall	80003fac <phy_rx_func+0xe98>
8000367c:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
8000367e:	e0 80 04 88 	breq	80003f8e <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
80003682:	fe f9 09 56 	ld.w	r9,pc[2390]
80003686:	72 08       	ld.w	r8,r9[0x0]
80003688:	20 28       	sub	r8,2
8000368a:	93 08       	st.w	r9[0x0],r8
8000368c:	e0 80 04 81 	breq	80003f8e <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
80003690:	30 29       	mov	r9,2
80003692:	fe f8 09 3e 	ld.w	r8,pc[2366]
80003696:	91 09       	st.w	r8[0x0],r9
80003698:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
8000369c:	fe f8 09 84 	ld.w	r8,pc[2436]
800036a0:	70 0a       	ld.w	r10,r8[0x0]
800036a2:	fe f9 09 26 	ld.w	r9,pc[2342]
800036a6:	72 09       	ld.w	r9,r9[0x0]
800036a8:	8e 4b       	ld.sh	r11,r7[0x8]
800036aa:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800036ae:	70 09       	ld.w	r9,r8[0x0]
800036b0:	2f f9       	sub	r9,-1
800036b2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800036b4:	e0 49 00 ff 	cp.w	r9,255
800036b8:	e0 88 00 16 	brls	800036e4 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
800036bc:	30 09       	mov	r9,0
800036be:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800036c0:	fe f6 09 08 	ld.w	r6,pc[2312]
800036c4:	6c 0c       	ld.w	r12,r6[0x0]
800036c6:	f0 1f 02 4d 	mcall	80003ff8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800036ca:	fe f8 08 fa 	ld.w	r8,pc[2298]
800036ce:	70 0c       	ld.w	r12,r8[0x0]
800036d0:	f0 1f 02 37 	mcall	80003fac <phy_rx_func+0xe98>
800036d4:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800036d6:	c0 71       	brne	800036e4 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
800036d8:	30 09       	mov	r9,0
800036da:	fe f8 08 f6 	ld.w	r8,pc[2294]
800036de:	91 09       	st.w	r8[0x0],r9
800036e0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
800036e4:	fe f9 08 f4 	ld.w	r9,pc[2292]
800036e8:	72 08       	ld.w	r8,r9[0x0]
800036ea:	20 28       	sub	r8,2
800036ec:	93 08       	st.w	r9[0x0],r8
800036ee:	c0 71       	brne	800036fc <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
800036f0:	30 09       	mov	r9,0
800036f2:	fe f8 08 de 	ld.w	r8,pc[2270]
800036f6:	91 09       	st.w	r8[0x0],r9
800036f8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
800036fc:	fe f8 09 24 	ld.w	r8,pc[2340]
80003700:	70 0a       	ld.w	r10,r8[0x0]
80003702:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003706:	72 09       	ld.w	r9,r9[0x0]
80003708:	8e 5b       	ld.sh	r11,r7[0xa]
8000370a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000370e:	70 09       	ld.w	r9,r8[0x0]
80003710:	2f f9       	sub	r9,-1
80003712:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003714:	e0 49 00 ff 	cp.w	r9,255
80003718:	e0 88 00 16 	brls	80003744 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
8000371c:	30 09       	mov	r9,0
8000371e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003720:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003724:	6c 0c       	ld.w	r12,r6[0x0]
80003726:	f0 1f 02 35 	mcall	80003ff8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000372a:	fe f8 08 9a 	ld.w	r8,pc[2202]
8000372e:	70 0c       	ld.w	r12,r8[0x0]
80003730:	f0 1f 02 1f 	mcall	80003fac <phy_rx_func+0xe98>
80003734:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003736:	c0 71       	brne	80003744 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003738:	30 09       	mov	r9,0
8000373a:	fe f8 08 96 	ld.w	r8,pc[2198]
8000373e:	91 09       	st.w	r8[0x0],r9
80003740:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003744:	fe f9 08 94 	ld.w	r9,pc[2196]
80003748:	72 08       	ld.w	r8,r9[0x0]
8000374a:	20 28       	sub	r8,2
8000374c:	93 08       	st.w	r9[0x0],r8
8000374e:	c0 71       	brne	8000375c <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
80003750:	30 09       	mov	r9,0
80003752:	fe f8 08 7e 	ld.w	r8,pc[2174]
80003756:	91 09       	st.w	r8[0x0],r9
80003758:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
8000375c:	fe f8 08 c4 	ld.w	r8,pc[2244]
80003760:	70 0a       	ld.w	r10,r8[0x0]
80003762:	fe f9 08 66 	ld.w	r9,pc[2150]
80003766:	72 09       	ld.w	r9,r9[0x0]
80003768:	8e 6b       	ld.sh	r11,r7[0xc]
8000376a:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000376e:	70 09       	ld.w	r9,r8[0x0]
80003770:	2f f9       	sub	r9,-1
80003772:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003774:	e0 49 00 ff 	cp.w	r9,255
80003778:	e0 88 00 16 	brls	800037a4 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
8000377c:	30 09       	mov	r9,0
8000377e:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
80003780:	fe f6 08 48 	ld.w	r6,pc[2120]
80003784:	6c 0c       	ld.w	r12,r6[0x0]
80003786:	f0 1f 02 1d 	mcall	80003ff8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
8000378a:	fe f8 08 3a 	ld.w	r8,pc[2106]
8000378e:	70 0c       	ld.w	r12,r8[0x0]
80003790:	f0 1f 02 07 	mcall	80003fac <phy_rx_func+0xe98>
80003794:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003796:	c0 71       	brne	800037a4 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
80003798:	30 09       	mov	r9,0
8000379a:	fe f8 08 36 	ld.w	r8,pc[2102]
8000379e:	91 09       	st.w	r8[0x0],r9
800037a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800037a4:	fe f9 08 34 	ld.w	r9,pc[2100]
800037a8:	72 08       	ld.w	r8,r9[0x0]
800037aa:	20 28       	sub	r8,2
800037ac:	93 08       	st.w	r9[0x0],r8
800037ae:	c0 71       	brne	800037bc <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800037b0:	30 09       	mov	r9,0
800037b2:	fe f8 08 1e 	ld.w	r8,pc[2078]
800037b6:	91 09       	st.w	r8[0x0],r9
800037b8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
800037bc:	fe f8 08 64 	ld.w	r8,pc[2148]
800037c0:	70 0a       	ld.w	r10,r8[0x0]
800037c2:	fe f9 08 06 	ld.w	r9,pc[2054]
800037c6:	72 09       	ld.w	r9,r9[0x0]
800037c8:	8e 7b       	ld.sh	r11,r7[0xe]
800037ca:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800037ce:	70 09       	ld.w	r9,r8[0x0]
800037d0:	2f f9       	sub	r9,-1
800037d2:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800037d4:	e0 49 00 ff 	cp.w	r9,255
800037d8:	e0 88 00 16 	brls	80003804 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
800037dc:	30 09       	mov	r9,0
800037de:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800037e0:	fe f7 07 e8 	ld.w	r7,pc[2024]
800037e4:	6e 0c       	ld.w	r12,r7[0x0]
800037e6:	f0 1f 02 05 	mcall	80003ff8 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800037ea:	fe f8 07 da 	ld.w	r8,pc[2010]
800037ee:	70 0c       	ld.w	r12,r8[0x0]
800037f0:	f0 1f 01 ef 	mcall	80003fac <phy_rx_func+0xe98>
800037f4:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800037f6:	c0 71       	brne	80003804 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
800037f8:	30 09       	mov	r9,0
800037fa:	fe f8 07 d6 	ld.w	r8,pc[2006]
800037fe:	91 09       	st.w	r8[0x0],r9
80003800:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003804:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003808:	72 08       	ld.w	r8,r9[0x0]
8000380a:	20 28       	sub	r8,2
8000380c:	93 08       	st.w	r9[0x0],r8
8000380e:	e0 81 03 c0 	brne	80003f8e <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
80003812:	30 09       	mov	r9,0
80003814:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003818:	91 09       	st.w	r8[0x0],r9
8000381a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000381e:	fe f8 07 ca 	ld.w	r8,pc[1994]
80003822:	11 89       	ld.ub	r9,r8[0x0]
80003824:	31 28       	mov	r8,18
80003826:	f0 09 18 00 	cp.b	r9,r8
8000382a:	e0 81 01 4c 	brne	80003ac2 <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
8000382e:	ef 39 00 09 	ld.ub	r9,r7[9]
80003832:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003836:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003838:	11 89       	ld.ub	r9,r8[0x0]
8000383a:	3f 28       	mov	r8,-14
8000383c:	f0 09 18 00 	cp.b	r9,r8
80003840:	e0 81 01 3b 	brne	80003ab6 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003844:	30 19       	mov	r9,1
80003846:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000384a:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
8000384c:	6e 29       	ld.w	r9,r7[0x8]
8000384e:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
80003852:	fe f8 07 86 	ld.w	r8,pc[1926]
80003856:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
80003858:	8e 59       	ld.sh	r9,r7[0xa]
8000385a:	fe f8 07 ce 	ld.w	r8,pc[1998]
8000385e:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
80003860:	8e 69       	ld.sh	r9,r7[0xc]
80003862:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
80003864:	8e 79       	ld.sh	r9,r7[0xe]
80003866:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
80003868:	fe f8 07 88 	ld.w	r8,pc[1928]
8000386c:	fe f9 07 60 	ld.w	r9,pc[1888]
80003870:	72 0a       	ld.w	r10,r9[0x0]
80003872:	70 09       	ld.w	r9,r8[0x0]
80003874:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003878:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000387c:	70 09       	ld.w	r9,r8[0x0]
8000387e:	2f f9       	sub	r9,-1
80003880:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003882:	e0 49 01 ff 	cp.w	r9,511
80003886:	e0 88 00 16 	brls	800038b2 <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
8000388a:	30 09       	mov	r9,0
8000388c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000388e:	fe f6 07 3e 	ld.w	r6,pc[1854]
80003892:	6c 0c       	ld.w	r12,r6[0x0]
80003894:	f0 1f 01 d9 	mcall	80003ff8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003898:	fe f8 07 2c 	ld.w	r8,pc[1836]
8000389c:	70 0c       	ld.w	r12,r8[0x0]
8000389e:	f0 1f 01 c4 	mcall	80003fac <phy_rx_func+0xe98>
800038a2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800038a4:	c0 71       	brne	800038b2 <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800038a6:	30 09       	mov	r9,0
800038a8:	fe f8 07 28 	ld.w	r8,pc[1832]
800038ac:	91 09       	st.w	r8[0x0],r9
800038ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800038b2:	fe f9 07 26 	ld.w	r9,pc[1830]
800038b6:	72 08       	ld.w	r8,r9[0x0]
800038b8:	20 18       	sub	r8,1
800038ba:	93 08       	st.w	r9[0x0],r8
800038bc:	c0 71       	brne	800038ca <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
800038be:	30 09       	mov	r9,0
800038c0:	fe f8 07 10 	ld.w	r8,pc[1808]
800038c4:	91 09       	st.w	r8[0x0],r9
800038c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
800038ca:	fe f8 07 26 	ld.w	r8,pc[1830]
800038ce:	fe f9 06 fe 	ld.w	r9,pc[1790]
800038d2:	72 0a       	ld.w	r10,r9[0x0]
800038d4:	70 09       	ld.w	r9,r8[0x0]
800038d6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800038da:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800038de:	70 09       	ld.w	r9,r8[0x0]
800038e0:	2f f9       	sub	r9,-1
800038e2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800038e4:	e0 49 01 ff 	cp.w	r9,511
800038e8:	e0 88 00 16 	brls	80003914 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
800038ec:	30 09       	mov	r9,0
800038ee:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800038f0:	fe f6 06 dc 	ld.w	r6,pc[1756]
800038f4:	6c 0c       	ld.w	r12,r6[0x0]
800038f6:	f0 1f 01 c1 	mcall	80003ff8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800038fa:	fe f8 06 ca 	ld.w	r8,pc[1738]
800038fe:	70 0c       	ld.w	r12,r8[0x0]
80003900:	f0 1f 01 ab 	mcall	80003fac <phy_rx_func+0xe98>
80003904:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003906:	c0 71       	brne	80003914 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003908:	30 09       	mov	r9,0
8000390a:	fe f8 06 c6 	ld.w	r8,pc[1734]
8000390e:	91 09       	st.w	r8[0x0],r9
80003910:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003914:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003918:	72 08       	ld.w	r8,r9[0x0]
8000391a:	20 18       	sub	r8,1
8000391c:	93 08       	st.w	r9[0x0],r8
8000391e:	c0 71       	brne	8000392c <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
80003920:	30 09       	mov	r9,0
80003922:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003926:	91 09       	st.w	r8[0x0],r9
80003928:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
8000392c:	fe f8 06 c4 	ld.w	r8,pc[1732]
80003930:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003934:	72 0a       	ld.w	r10,r9[0x0]
80003936:	70 09       	ld.w	r9,r8[0x0]
80003938:	ef 3b 00 0c 	ld.ub	r11,r7[12]
8000393c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003940:	70 09       	ld.w	r9,r8[0x0]
80003942:	2f f9       	sub	r9,-1
80003944:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003946:	e0 49 01 ff 	cp.w	r9,511
8000394a:	e0 88 00 16 	brls	80003976 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000394e:	30 09       	mov	r9,0
80003950:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003952:	fe f6 06 7a 	ld.w	r6,pc[1658]
80003956:	6c 0c       	ld.w	r12,r6[0x0]
80003958:	f0 1f 01 a8 	mcall	80003ff8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000395c:	fe f8 06 68 	ld.w	r8,pc[1640]
80003960:	70 0c       	ld.w	r12,r8[0x0]
80003962:	f0 1f 01 93 	mcall	80003fac <phy_rx_func+0xe98>
80003966:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003968:	c0 71       	brne	80003976 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
8000396a:	30 09       	mov	r9,0
8000396c:	fe f8 06 64 	ld.w	r8,pc[1636]
80003970:	91 09       	st.w	r8[0x0],r9
80003972:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003976:	fe f9 06 62 	ld.w	r9,pc[1634]
8000397a:	72 08       	ld.w	r8,r9[0x0]
8000397c:	20 18       	sub	r8,1
8000397e:	93 08       	st.w	r9[0x0],r8
80003980:	c0 71       	brne	8000398e <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
80003982:	30 09       	mov	r9,0
80003984:	fe f8 06 4c 	ld.w	r8,pc[1612]
80003988:	91 09       	st.w	r8[0x0],r9
8000398a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
8000398e:	fe f8 06 62 	ld.w	r8,pc[1634]
80003992:	fe f9 06 3a 	ld.w	r9,pc[1594]
80003996:	72 0a       	ld.w	r10,r9[0x0]
80003998:	70 09       	ld.w	r9,r8[0x0]
8000399a:	ef 3b 00 0d 	ld.ub	r11,r7[13]
8000399e:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800039a2:	70 09       	ld.w	r9,r8[0x0]
800039a4:	2f f9       	sub	r9,-1
800039a6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039a8:	e0 49 01 ff 	cp.w	r9,511
800039ac:	e0 88 00 16 	brls	800039d8 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800039b0:	30 09       	mov	r9,0
800039b2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800039b4:	fe f6 06 18 	ld.w	r6,pc[1560]
800039b8:	6c 0c       	ld.w	r12,r6[0x0]
800039ba:	f0 1f 01 90 	mcall	80003ff8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800039be:	fe f8 06 06 	ld.w	r8,pc[1542]
800039c2:	70 0c       	ld.w	r12,r8[0x0]
800039c4:	f0 1f 01 7a 	mcall	80003fac <phy_rx_func+0xe98>
800039c8:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800039ca:	c0 71       	brne	800039d8 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
800039cc:	30 09       	mov	r9,0
800039ce:	fe f8 06 02 	ld.w	r8,pc[1538]
800039d2:	91 09       	st.w	r8[0x0],r9
800039d4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800039d8:	fe f9 06 00 	ld.w	r9,pc[1536]
800039dc:	72 08       	ld.w	r8,r9[0x0]
800039de:	20 18       	sub	r8,1
800039e0:	93 08       	st.w	r9[0x0],r8
800039e2:	c0 71       	brne	800039f0 <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
800039e4:	30 09       	mov	r9,0
800039e6:	fe f8 05 ea 	ld.w	r8,pc[1514]
800039ea:	91 09       	st.w	r8[0x0],r9
800039ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
800039f0:	fe f8 06 00 	ld.w	r8,pc[1536]
800039f4:	fe f9 05 d8 	ld.w	r9,pc[1496]
800039f8:	72 0a       	ld.w	r10,r9[0x0]
800039fa:	70 09       	ld.w	r9,r8[0x0]
800039fc:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003a00:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a04:	70 09       	ld.w	r9,r8[0x0]
80003a06:	2f f9       	sub	r9,-1
80003a08:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a0a:	e0 49 01 ff 	cp.w	r9,511
80003a0e:	e0 88 00 16 	brls	80003a3a <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a12:	30 09       	mov	r9,0
80003a14:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a16:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003a1a:	6c 0c       	ld.w	r12,r6[0x0]
80003a1c:	f0 1f 01 77 	mcall	80003ff8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a20:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003a24:	70 0c       	ld.w	r12,r8[0x0]
80003a26:	f0 1f 01 62 	mcall	80003fac <phy_rx_func+0xe98>
80003a2a:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a2c:	c0 71       	brne	80003a3a <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
80003a2e:	30 09       	mov	r9,0
80003a30:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003a34:	91 09       	st.w	r8[0x0],r9
80003a36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a3a:	fe f9 05 9e 	ld.w	r9,pc[1438]
80003a3e:	72 08       	ld.w	r8,r9[0x0]
80003a40:	20 18       	sub	r8,1
80003a42:	93 08       	st.w	r9[0x0],r8
80003a44:	c0 71       	brne	80003a52 <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003a46:	30 09       	mov	r9,0
80003a48:	fe f8 05 88 	ld.w	r8,pc[1416]
80003a4c:	91 09       	st.w	r8[0x0],r9
80003a4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
80003a52:	fe f8 05 9e 	ld.w	r8,pc[1438]
80003a56:	fe f9 05 76 	ld.w	r9,pc[1398]
80003a5a:	72 0a       	ld.w	r10,r9[0x0]
80003a5c:	70 09       	ld.w	r9,r8[0x0]
80003a5e:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003a62:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003a66:	70 09       	ld.w	r9,r8[0x0]
80003a68:	2f f9       	sub	r9,-1
80003a6a:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003a6c:	e0 49 01 ff 	cp.w	r9,511
80003a70:	e0 88 00 16 	brls	80003a9c <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
80003a74:	30 09       	mov	r9,0
80003a76:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003a78:	fe f7 05 54 	ld.w	r7,pc[1364]
80003a7c:	6e 0c       	ld.w	r12,r7[0x0]
80003a7e:	f0 1f 01 5f 	mcall	80003ff8 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003a82:	fe f8 05 42 	ld.w	r8,pc[1346]
80003a86:	70 0c       	ld.w	r12,r8[0x0]
80003a88:	f0 1f 01 49 	mcall	80003fac <phy_rx_func+0xe98>
80003a8c:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003a8e:	c0 71       	brne	80003a9c <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
80003a90:	30 09       	mov	r9,0
80003a92:	fe f8 05 3e 	ld.w	r8,pc[1342]
80003a96:	91 09       	st.w	r8[0x0],r9
80003a98:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003a9c:	fe f9 05 3c 	ld.w	r9,pc[1340]
80003aa0:	72 08       	ld.w	r8,r9[0x0]
80003aa2:	20 18       	sub	r8,1
80003aa4:	93 08       	st.w	r9[0x0],r8
80003aa6:	e0 81 02 74 	brne	80003f8e <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
80003aaa:	30 09       	mov	r9,0
80003aac:	fe f8 05 24 	ld.w	r8,pc[1316]
80003ab0:	91 09       	st.w	r8[0x0],r9
80003ab2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003ab6:	30 09       	mov	r9,0
80003ab8:	fe f8 05 18 	ld.w	r8,pc[1304]
80003abc:	91 09       	st.w	r8[0x0],r9
80003abe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
80003ac2:	fe f8 05 26 	ld.w	r8,pc[1318]
80003ac6:	11 89       	ld.ub	r9,r8[0x0]
80003ac8:	3f 28       	mov	r8,-14
80003aca:	f0 09 18 00 	cp.b	r9,r8
80003ace:	c4 31       	brne	80003b54 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
80003ad0:	8e 49       	ld.sh	r9,r7[0x8]
80003ad2:	fe f8 05 56 	ld.w	r8,pc[1366]
80003ad6:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003ad8:	fe f8 05 18 	ld.w	r8,pc[1304]
80003adc:	fe f9 04 f0 	ld.w	r9,pc[1264]
80003ae0:	72 0a       	ld.w	r10,r9[0x0]
80003ae2:	70 09       	ld.w	r9,r8[0x0]
80003ae4:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003ae8:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003aec:	70 09       	ld.w	r9,r8[0x0]
80003aee:	2f f9       	sub	r9,-1
80003af0:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003af2:	e0 49 01 ff 	cp.w	r9,511
80003af6:	e0 88 00 16 	brls	80003b22 <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003afa:	30 09       	mov	r9,0
80003afc:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003afe:	fe f7 04 ce 	ld.w	r7,pc[1230]
80003b02:	6e 0c       	ld.w	r12,r7[0x0]
80003b04:	f0 1f 01 3d 	mcall	80003ff8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003b08:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003b0c:	70 0c       	ld.w	r12,r8[0x0]
80003b0e:	f0 1f 01 28 	mcall	80003fac <phy_rx_func+0xe98>
80003b12:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003b14:	c0 71       	brne	80003b22 <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003b16:	30 09       	mov	r9,0
80003b18:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003b1c:	91 09       	st.w	r8[0x0],r9
80003b1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003b22:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003b26:	72 08       	ld.w	r8,r9[0x0]
80003b28:	20 18       	sub	r8,1
80003b2a:	93 08       	st.w	r9[0x0],r8
80003b2c:	c0 71       	brne	80003b3a <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
80003b2e:	30 09       	mov	r9,0
80003b30:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003b34:	91 09       	st.w	r8[0x0],r9
80003b36:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003b3a:	20 18       	sub	r8,1
80003b3c:	fe f9 04 9c 	ld.w	r9,pc[1180]
80003b40:	93 08       	st.w	r9[0x0],r8
80003b42:	58 08       	cp.w	r8,0
80003b44:	e0 81 02 25 	brne	80003f8e <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003b48:	30 09       	mov	r9,0
80003b4a:	fe f8 04 86 	ld.w	r8,pc[1158]
80003b4e:	91 09       	st.w	r8[0x0],r9
80003b50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
80003b54:	fe f8 04 94 	ld.w	r8,pc[1172]
80003b58:	11 89       	ld.ub	r9,r8[0x0]
80003b5a:	3f 38       	mov	r8,-13
80003b5c:	f0 09 18 00 	cp.b	r9,r8
80003b60:	e0 81 01 0c 	brne	80003d78 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
80003b64:	8e 49       	ld.sh	r9,r7[0x8]
80003b66:	fe f8 04 c2 	ld.w	r8,pc[1218]
80003b6a:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
80003b6c:	8e 59       	ld.sh	r9,r7[0xa]
80003b6e:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
80003b70:	8e 69       	ld.sh	r9,r7[0xc]
80003b72:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
80003b74:	fe f8 04 7c 	ld.w	r8,pc[1148]
80003b78:	fe f9 04 54 	ld.w	r9,pc[1108]
80003b7c:	72 0a       	ld.w	r10,r9[0x0]
80003b7e:	70 09       	ld.w	r9,r8[0x0]
80003b80:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003b84:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003b88:	70 09       	ld.w	r9,r8[0x0]
80003b8a:	2f f9       	sub	r9,-1
80003b8c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003b8e:	e0 49 01 ff 	cp.w	r9,511
80003b92:	e0 88 00 16 	brls	80003bbe <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
80003b96:	30 09       	mov	r9,0
80003b98:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003b9a:	fe f6 04 32 	ld.w	r6,pc[1074]
80003b9e:	6c 0c       	ld.w	r12,r6[0x0]
80003ba0:	f0 1f 01 16 	mcall	80003ff8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003ba4:	fe f8 04 20 	ld.w	r8,pc[1056]
80003ba8:	70 0c       	ld.w	r12,r8[0x0]
80003baa:	f0 1f 01 01 	mcall	80003fac <phy_rx_func+0xe98>
80003bae:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003bb0:	c0 71       	brne	80003bbe <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
80003bb2:	30 09       	mov	r9,0
80003bb4:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003bb8:	91 09       	st.w	r8[0x0],r9
80003bba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003bbe:	fe f9 04 1a 	ld.w	r9,pc[1050]
80003bc2:	72 08       	ld.w	r8,r9[0x0]
80003bc4:	20 18       	sub	r8,1
80003bc6:	93 08       	st.w	r9[0x0],r8
80003bc8:	c0 71       	brne	80003bd6 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003bca:	30 09       	mov	r9,0
80003bcc:	fe f8 04 04 	ld.w	r8,pc[1028]
80003bd0:	91 09       	st.w	r8[0x0],r9
80003bd2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003bd6:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003bda:	fe f9 03 f2 	ld.w	r9,pc[1010]
80003bde:	72 0a       	ld.w	r10,r9[0x0]
80003be0:	70 09       	ld.w	r9,r8[0x0]
80003be2:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003be6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003bea:	70 09       	ld.w	r9,r8[0x0]
80003bec:	2f f9       	sub	r9,-1
80003bee:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003bf0:	e0 49 01 ff 	cp.w	r9,511
80003bf4:	e0 88 00 16 	brls	80003c20 <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003bf8:	30 09       	mov	r9,0
80003bfa:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003bfc:	fe f6 03 d0 	ld.w	r6,pc[976]
80003c00:	6c 0c       	ld.w	r12,r6[0x0]
80003c02:	f0 1f 00 fe 	mcall	80003ff8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c06:	fe f8 03 be 	ld.w	r8,pc[958]
80003c0a:	70 0c       	ld.w	r12,r8[0x0]
80003c0c:	f0 1f 00 e8 	mcall	80003fac <phy_rx_func+0xe98>
80003c10:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c12:	c0 71       	brne	80003c20 <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003c14:	30 09       	mov	r9,0
80003c16:	fe f8 03 ba 	ld.w	r8,pc[954]
80003c1a:	91 09       	st.w	r8[0x0],r9
80003c1c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c20:	fe f9 03 b8 	ld.w	r9,pc[952]
80003c24:	72 08       	ld.w	r8,r9[0x0]
80003c26:	20 18       	sub	r8,1
80003c28:	93 08       	st.w	r9[0x0],r8
80003c2a:	c0 71       	brne	80003c38 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003c2c:	30 09       	mov	r9,0
80003c2e:	fe f8 03 a2 	ld.w	r8,pc[930]
80003c32:	91 09       	st.w	r8[0x0],r9
80003c34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003c38:	fe f8 03 b8 	ld.w	r8,pc[952]
80003c3c:	fe f9 03 90 	ld.w	r9,pc[912]
80003c40:	72 0a       	ld.w	r10,r9[0x0]
80003c42:	70 09       	ld.w	r9,r8[0x0]
80003c44:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003c48:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003c4c:	70 09       	ld.w	r9,r8[0x0]
80003c4e:	2f f9       	sub	r9,-1
80003c50:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003c52:	e0 49 01 ff 	cp.w	r9,511
80003c56:	e0 88 00 16 	brls	80003c82 <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003c5a:	30 09       	mov	r9,0
80003c5c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003c5e:	fe f6 03 6e 	ld.w	r6,pc[878]
80003c62:	6c 0c       	ld.w	r12,r6[0x0]
80003c64:	f0 1f 00 e5 	mcall	80003ff8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003c68:	fe f8 03 5c 	ld.w	r8,pc[860]
80003c6c:	70 0c       	ld.w	r12,r8[0x0]
80003c6e:	f0 1f 00 d0 	mcall	80003fac <phy_rx_func+0xe98>
80003c72:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003c74:	c0 71       	brne	80003c82 <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
80003c76:	30 09       	mov	r9,0
80003c78:	fe f8 03 58 	ld.w	r8,pc[856]
80003c7c:	91 09       	st.w	r8[0x0],r9
80003c7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003c82:	fe f9 03 56 	ld.w	r9,pc[854]
80003c86:	72 08       	ld.w	r8,r9[0x0]
80003c88:	20 18       	sub	r8,1
80003c8a:	93 08       	st.w	r9[0x0],r8
80003c8c:	c0 71       	brne	80003c9a <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
80003c8e:	30 09       	mov	r9,0
80003c90:	fe f8 03 40 	ld.w	r8,pc[832]
80003c94:	91 09       	st.w	r8[0x0],r9
80003c96:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
80003c9a:	fe f8 03 56 	ld.w	r8,pc[854]
80003c9e:	fe f9 03 2e 	ld.w	r9,pc[814]
80003ca2:	72 0a       	ld.w	r10,r9[0x0]
80003ca4:	70 09       	ld.w	r9,r8[0x0]
80003ca6:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003caa:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003cae:	70 09       	ld.w	r9,r8[0x0]
80003cb0:	2f f9       	sub	r9,-1
80003cb2:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003cb4:	e0 49 01 ff 	cp.w	r9,511
80003cb8:	e0 88 00 16 	brls	80003ce4 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003cbc:	30 09       	mov	r9,0
80003cbe:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003cc0:	fe f6 03 0c 	ld.w	r6,pc[780]
80003cc4:	6c 0c       	ld.w	r12,r6[0x0]
80003cc6:	f0 1f 00 cd 	mcall	80003ff8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003cca:	fe f8 02 fa 	ld.w	r8,pc[762]
80003cce:	70 0c       	ld.w	r12,r8[0x0]
80003cd0:	f0 1f 00 b7 	mcall	80003fac <phy_rx_func+0xe98>
80003cd4:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003cd6:	c0 71       	brne	80003ce4 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003cd8:	30 09       	mov	r9,0
80003cda:	fe f8 02 f6 	ld.w	r8,pc[758]
80003cde:	91 09       	st.w	r8[0x0],r9
80003ce0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003ce4:	fe f9 02 f4 	ld.w	r9,pc[756]
80003ce8:	72 08       	ld.w	r8,r9[0x0]
80003cea:	20 18       	sub	r8,1
80003cec:	93 08       	st.w	r9[0x0],r8
80003cee:	c0 71       	brne	80003cfc <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
80003cf0:	30 09       	mov	r9,0
80003cf2:	fe f8 02 de 	ld.w	r8,pc[734]
80003cf6:	91 09       	st.w	r8[0x0],r9
80003cf8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003cfc:	fe f8 02 f4 	ld.w	r8,pc[756]
80003d00:	fe f9 02 cc 	ld.w	r9,pc[716]
80003d04:	72 0a       	ld.w	r10,r9[0x0]
80003d06:	70 09       	ld.w	r9,r8[0x0]
80003d08:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003d0c:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003d10:	70 09       	ld.w	r9,r8[0x0]
80003d12:	2f f9       	sub	r9,-1
80003d14:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003d16:	e0 49 01 ff 	cp.w	r9,511
80003d1a:	e0 88 00 16 	brls	80003d46 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
80003d1e:	30 09       	mov	r9,0
80003d20:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003d22:	fe f7 02 aa 	ld.w	r7,pc[682]
80003d26:	6e 0c       	ld.w	r12,r7[0x0]
80003d28:	f0 1f 00 b4 	mcall	80003ff8 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003d2c:	fe f8 02 98 	ld.w	r8,pc[664]
80003d30:	70 0c       	ld.w	r12,r8[0x0]
80003d32:	f0 1f 00 9f 	mcall	80003fac <phy_rx_func+0xe98>
80003d36:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003d38:	c0 71       	brne	80003d46 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003d3a:	30 09       	mov	r9,0
80003d3c:	fe f8 02 94 	ld.w	r8,pc[660]
80003d40:	91 09       	st.w	r8[0x0],r9
80003d42:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003d46:	fe f9 02 92 	ld.w	r9,pc[658]
80003d4a:	72 08       	ld.w	r8,r9[0x0]
80003d4c:	20 18       	sub	r8,1
80003d4e:	93 08       	st.w	r9[0x0],r8
80003d50:	c0 71       	brne	80003d5e <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
80003d52:	30 09       	mov	r9,0
80003d54:	fe f8 02 7c 	ld.w	r8,pc[636]
80003d58:	91 09       	st.w	r8[0x0],r9
80003d5a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
80003d5e:	20 18       	sub	r8,1
80003d60:	fe f9 02 78 	ld.w	r9,pc[632]
80003d64:	93 08       	st.w	r9[0x0],r8
80003d66:	58 08       	cp.w	r8,0
80003d68:	e0 81 01 13 	brne	80003f8e <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
80003d6c:	30 09       	mov	r9,0
80003d6e:	fe f8 02 62 	ld.w	r8,pc[610]
80003d72:	91 09       	st.w	r8[0x0],r9
80003d74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
80003d78:	fe f8 02 70 	ld.w	r8,pc[624]
80003d7c:	11 89       	ld.ub	r9,r8[0x0]
80003d7e:	30 48       	mov	r8,4
80003d80:	f0 09 18 00 	cp.b	r9,r8
80003d84:	c0 80       	breq	80003d94 <phy_rx_func+0xc80>
80003d86:	fe f8 02 62 	ld.w	r8,pc[610]
80003d8a:	11 89       	ld.ub	r9,r8[0x0]
80003d8c:	30 38       	mov	r8,3
80003d8e:	f0 09 18 00 	cp.b	r9,r8
80003d92:	c1 41       	brne	80003dba <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
80003d94:	6e 29       	ld.w	r9,r7[0x8]
80003d96:	fe f8 02 7a 	ld.w	r8,pc[634]
80003d9a:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
80003d9c:	6e 39       	ld.w	r9,r7[0xc]
80003d9e:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
80003da0:	fe f9 02 38 	ld.w	r9,pc[568]
80003da4:	72 08       	ld.w	r8,r9[0x0]
80003da6:	20 88       	sub	r8,8
80003da8:	93 08       	st.w	r9[0x0],r8
80003daa:	e0 81 00 f2 	brne	80003f8e <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
80003dae:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
80003db0:	fe f9 02 20 	ld.w	r9,pc[544]
80003db4:	93 08       	st.w	r9[0x0],r8
80003db6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003dba:	fe f8 02 2e 	ld.w	r8,pc[558]
80003dbe:	11 89       	ld.ub	r9,r8[0x0]
80003dc0:	31 38       	mov	r8,19
80003dc2:	f0 09 18 00 	cp.b	r9,r8
80003dc6:	e0 81 00 9c 	brne	80003efe <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003dca:	fe f8 02 62 	ld.w	r8,pc[610]
80003dce:	11 88       	ld.ub	r8,r8[0x0]
80003dd0:	30 c9       	mov	r9,12
80003dd2:	f2 08 18 00 	cp.b	r8,r9
80003dd6:	e0 81 00 7b 	brne	80003ecc <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003dda:	8e 49       	ld.sh	r9,r7[0x8]
80003ddc:	fe f8 02 54 	ld.w	r8,pc[596]
80003de0:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003de4:	30 09       	mov	r9,0
80003de6:	fe f8 02 46 	ld.w	r8,pc[582]
80003dea:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003dec:	ef 39 00 0d 	ld.ub	r9,r7[13]
80003df0:	3f 38       	mov	r8,-13
80003df2:	f0 09 18 00 	cp.b	r9,r8
80003df6:	c6 61       	brne	80003ec2 <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003df8:	10 99       	mov	r9,r8
80003dfa:	4f c8       	lddpc	r8,80003fe8 <phy_rx_func+0xed4>
80003dfc:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
80003dfe:	ef 39 00 0c 	ld.ub	r9,r7[12]
80003e02:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003e06:	4f 58       	lddpc	r8,80003fd8 <phy_rx_func+0xec4>
80003e08:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003e0a:	30 19       	mov	r9,1
80003e0c:	fe f8 02 0c 	ld.w	r8,pc[524]
80003e10:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
80003e12:	8e 79       	ld.sh	r9,r7[0xe]
80003e14:	fe f8 02 14 	ld.w	r8,pc[532]
80003e18:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003e1a:	4f 68       	lddpc	r8,80003ff0 <phy_rx_func+0xedc>
80003e1c:	4e c9       	lddpc	r9,80003fcc <phy_rx_func+0xeb8>
80003e1e:	72 0a       	ld.w	r10,r9[0x0]
80003e20:	70 09       	ld.w	r9,r8[0x0]
80003e22:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003e26:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003e2a:	70 09       	ld.w	r9,r8[0x0]
80003e2c:	2f f9       	sub	r9,-1
80003e2e:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e30:	e0 49 01 ff 	cp.w	r9,511
80003e34:	e0 88 00 13 	brls	80003e5a <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003e38:	30 09       	mov	r9,0
80003e3a:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003e3c:	4e 46       	lddpc	r6,80003fcc <phy_rx_func+0xeb8>
80003e3e:	6c 0c       	ld.w	r12,r6[0x0]
80003e40:	f0 1f 00 6e 	mcall	80003ff8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003e44:	4e 08       	lddpc	r8,80003fc4 <phy_rx_func+0xeb0>
80003e46:	70 0c       	ld.w	r12,r8[0x0]
80003e48:	f0 1f 00 59 	mcall	80003fac <phy_rx_func+0xe98>
80003e4c:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003e4e:	c0 61       	brne	80003e5a <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
80003e50:	30 09       	mov	r9,0
80003e52:	4e 08       	lddpc	r8,80003fd0 <phy_rx_func+0xebc>
80003e54:	91 09       	st.w	r8[0x0],r9
80003e56:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003e5a:	4e 09       	lddpc	r9,80003fd8 <phy_rx_func+0xec4>
80003e5c:	72 08       	ld.w	r8,r9[0x0]
80003e5e:	20 18       	sub	r8,1
80003e60:	93 08       	st.w	r9[0x0],r8
80003e62:	c0 61       	brne	80003e6e <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
80003e64:	30 09       	mov	r9,0
80003e66:	4d b8       	lddpc	r8,80003fd0 <phy_rx_func+0xebc>
80003e68:	91 09       	st.w	r8[0x0],r9
80003e6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
80003e6e:	4e 18       	lddpc	r8,80003ff0 <phy_rx_func+0xedc>
80003e70:	4d 79       	lddpc	r9,80003fcc <phy_rx_func+0xeb8>
80003e72:	72 0a       	ld.w	r10,r9[0x0]
80003e74:	70 09       	ld.w	r9,r8[0x0]
80003e76:	ef 3b 00 0f 	ld.ub	r11,r7[15]
80003e7a:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003e7e:	70 09       	ld.w	r9,r8[0x0]
80003e80:	2f f9       	sub	r9,-1
80003e82:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003e84:	e0 49 01 ff 	cp.w	r9,511
80003e88:	e0 88 00 13 	brls	80003eae <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
80003e8c:	30 09       	mov	r9,0
80003e8e:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003e90:	4c f7       	lddpc	r7,80003fcc <phy_rx_func+0xeb8>
80003e92:	6e 0c       	ld.w	r12,r7[0x0]
80003e94:	f0 1f 00 59 	mcall	80003ff8 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003e98:	4c b8       	lddpc	r8,80003fc4 <phy_rx_func+0xeb0>
80003e9a:	70 0c       	ld.w	r12,r8[0x0]
80003e9c:	f0 1f 00 44 	mcall	80003fac <phy_rx_func+0xe98>
80003ea0:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
80003ea2:	c0 61       	brne	80003eae <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
80003ea4:	30 09       	mov	r9,0
80003ea6:	4c b8       	lddpc	r8,80003fd0 <phy_rx_func+0xebc>
80003ea8:	91 09       	st.w	r8[0x0],r9
80003eaa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
80003eae:	4c b9       	lddpc	r9,80003fd8 <phy_rx_func+0xec4>
80003eb0:	72 08       	ld.w	r8,r9[0x0]
80003eb2:	20 18       	sub	r8,1
80003eb4:	93 08       	st.w	r9[0x0],r8
80003eb6:	c6 c1       	brne	80003f8e <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003eb8:	30 09       	mov	r9,0
80003eba:	4c 68       	lddpc	r8,80003fd0 <phy_rx_func+0xebc>
80003ebc:	91 09       	st.w	r8[0x0],r9
80003ebe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003ec2:	30 09       	mov	r9,0
80003ec4:	4c 38       	lddpc	r8,80003fd0 <phy_rx_func+0xebc>
80003ec6:	91 09       	st.w	r8[0x0],r9
80003ec8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003ecc:	8e 4a       	ld.sh	r10,r7[0x8]
80003ece:	4d 99       	lddpc	r9,80004030 <phy_rx_func+0xf1c>
80003ed0:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003ed4:	4d 6a       	lddpc	r10,8000402c <phy_rx_func+0xf18>
80003ed6:	15 88       	ld.ub	r8,r10[0x0]
80003ed8:	f0 cb ff ff 	sub	r11,r8,-1
80003edc:	8e 5c       	ld.sh	r12,r7[0xa]
80003ede:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003ee2:	f0 cb ff fe 	sub	r11,r8,-2
80003ee6:	8e 6c       	ld.sh	r12,r7[0xc]
80003ee8:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003eec:	f0 cb ff fd 	sub	r11,r8,-3
80003ef0:	8e 7c       	ld.sh	r12,r7[0xe]
80003ef2:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003ef6:	2f c8       	sub	r8,-4
80003ef8:	b4 88       	st.b	r10[0x0],r8
80003efa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003efe:	30 09       	mov	r9,0
80003f00:	4b 48       	lddpc	r8,80003fd0 <phy_rx_func+0xebc>
80003f02:	91 09       	st.w	r8[0x0],r9
80003f04:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003f08:	4c 08       	lddpc	r8,80004008 <phy_rx_func+0xef4>
80003f0a:	70 09       	ld.w	r9,r8[0x0]
80003f0c:	8e 4b       	ld.sh	r11,r7[0x8]
80003f0e:	4c 0a       	lddpc	r10,8000400c <phy_rx_func+0xef8>
80003f10:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003f14:	2f f9       	sub	r9,-1
80003f16:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003f18:	4b 58       	lddpc	r8,80003fec <phy_rx_func+0xed8>
80003f1a:	70 09       	ld.w	r9,r8[0x0]
80003f1c:	20 29       	sub	r9,2
80003f1e:	91 09       	st.w	r8[0x0],r9
80003f20:	70 08       	ld.w	r8,r8[0x0]
80003f22:	58 08       	cp.w	r8,0
80003f24:	c2 f1       	brne	80003f82 <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003f26:	30 09       	mov	r9,0
80003f28:	4b 88       	lddpc	r8,80004008 <phy_rx_func+0xef4>
80003f2a:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003f2c:	8e 59       	ld.sh	r9,r7[0xa]
80003f2e:	fe 78 82 12 	mov	r8,-32238
80003f32:	f0 09 19 00 	cp.h	r9,r8
80003f36:	c2 11       	brne	80003f78 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003f38:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003f3c:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003f40:	4a f8       	lddpc	r8,80003ffc <phy_rx_func+0xee8>
80003f42:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003f44:	8e 59       	ld.sh	r9,r7[0xa]
80003f46:	4a f8       	lddpc	r8,80004000 <phy_rx_func+0xeec>
80003f48:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003f4a:	8e 69       	ld.sh	r9,r7[0xc]
80003f4c:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003f4e:	f0 1f 00 2e 	mcall	80004004 <phy_rx_func+0xef0>
80003f52:	4a 18       	lddpc	r8,80003fd4 <phy_rx_func+0xec0>
80003f54:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003f56:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003f5a:	31 38       	mov	r8,19
80003f5c:	f0 09 18 00 	cp.b	r9,r8
80003f60:	c0 71       	brne	80003f6e <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003f62:	10 99       	mov	r9,r8
80003f64:	4a 18       	lddpc	r8,80003fe8 <phy_rx_func+0xed4>
80003f66:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003f68:	30 09       	mov	r9,0
80003f6a:	49 c8       	lddpc	r8,80003fd8 <phy_rx_func+0xec4>
80003f6c:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003f6e:	30 49       	mov	r9,4
80003f70:	49 88       	lddpc	r8,80003fd0 <phy_rx_func+0xebc>
80003f72:	91 09       	st.w	r8[0x0],r9
80003f74:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003f78:	30 09       	mov	r9,0
80003f7a:	49 68       	lddpc	r8,80003fd0 <phy_rx_func+0xebc>
80003f7c:	91 09       	st.w	r8[0x0],r9
80003f7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003f82:	4a dc       	lddpc	r12,80004034 <phy_rx_func+0xf20>
80003f84:	f0 1f 00 18 	mcall	80003fe4 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003f88:	30 09       	mov	r9,0
80003f8a:	49 28       	lddpc	r8,80003fd0 <phy_rx_func+0xebc>
80003f8c:	91 09       	st.w	r8[0x0],r9
80003f8e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003f92:	00 00       	add	r0,r0
80003f94:	00 00       	add	r0,r0
80003f96:	0a b8       	st.h	r5++,r8
80003f98:	00 00       	add	r0,r0
80003f9a:	0a d0       	st.w	--r5,r0
80003f9c:	00 00       	add	r0,r0
80003f9e:	0a b0       	st.h	r5++,r0
80003fa0:	00 00       	add	r0,r0
80003fa2:	0a 92       	mov	r2,r5
80003fa4:	00 00       	add	r0,r0
80003fa6:	0a 80       	andn	r0,r5
80003fa8:	00 00       	add	r0,r0
80003faa:	0a a8       	st.w	r5++,r8
80003fac:	80 00       	ld.sh	r0,r0[0x0]
80003fae:	2f 94       	sub	r4,-7
80003fb0:	00 00       	add	r0,r0
80003fb2:	0a a0       	st.w	r5++,r0
80003fb4:	80 00       	ld.sh	r0,r0[0x0]
80003fb6:	2e ac       	sub	r12,-22
80003fb8:	00 00       	add	r0,r0
80003fba:	0a b4       	st.h	r5++,r4
80003fbc:	80 00       	ld.sh	r0,r0[0x0]
80003fbe:	2e e0       	sub	r0,-18
80003fc0:	00 00       	add	r0,r0
80003fc2:	0a 91       	mov	r1,r5
80003fc4:	00 00       	add	r0,r0
80003fc6:	0a ac       	st.w	r5++,r12
80003fc8:	00 00       	add	r0,r0
80003fca:	0a bc       	st.h	r5++,r12
80003fcc:	00 00       	add	r0,r0
80003fce:	0a 94       	mov	r4,r5
80003fd0:	00 00       	add	r0,r0
80003fd2:	0a dc       	st.w	--r5,r12
80003fd4:	00 00       	add	r0,r0
80003fd6:	0a c4       	st.b	r5++,r4
80003fd8:	00 00       	add	r0,r0
80003fda:	0a 7c       	tst	r12,r5
80003fdc:	00 00       	add	r0,r0
80003fde:	0a 55       	eor	r5,r5
80003fe0:	80 00       	ld.sh	r0,r0[0x0]
80003fe2:	d9 d8       	*unknown*
80003fe4:	80 00       	ld.sh	r0,r0[0x0]
80003fe6:	72 9c       	ld.w	r12,r9[0x24]
80003fe8:	00 00       	add	r0,r0
80003fea:	0a 90       	mov	r0,r5
80003fec:	00 00       	add	r0,r0
80003fee:	0a e8       	st.h	--r5,r8
80003ff0:	00 00       	add	r0,r0
80003ff2:	0a c8       	st.b	r5++,r8
80003ff4:	80 00       	ld.sh	r0,r0[0x0]
80003ff6:	7a d4       	ld.w	r4,sp[0x34]
80003ff8:	80 00       	ld.sh	r0,r0[0x0]
80003ffa:	2e c8       	sub	r8,-20
80003ffc:	00 00       	add	r0,r0
80003ffe:	0a 4a       	or	r10,r5
80004000:	00 00       	add	r0,r0
80004002:	21 2c       	sub	r12,18
80004004:	80 00       	ld.sh	r0,r0[0x0]
80004006:	2e 7c       	sub	r12,-25
80004008:	00 00       	add	r0,r0
8000400a:	0a 84       	andn	r4,r5
8000400c:	00 00       	add	r0,r0
8000400e:	20 30       	sub	r0,3
80004010:	00 00       	add	r0,r0
80004012:	0a 88       	andn	r8,r5
80004014:	00 00       	add	r0,r0
80004016:	0a 4b       	or	r11,r5
80004018:	00 00       	add	r0,r0
8000401a:	0a 49       	or	r9,r5
8000401c:	00 00       	add	r0,r0
8000401e:	0a e0       	st.h	--r5,r0
80004020:	00 00       	add	r0,r0
80004022:	0a 9c       	mov	r12,r5
80004024:	00 00       	add	r0,r0
80004026:	0a 64       	and	r4,r5
80004028:	00 00       	add	r0,r0
8000402a:	20 28       	sub	r8,2
8000402c:	00 00       	add	r0,r0
8000402e:	0a d4       	st.w	--r5,r4
80004030:	00 00       	add	r0,r0
80004032:	21 30       	sub	r0,19
80004034:	80 00       	ld.sh	r0,r0[0x0]
80004036:	d9 f0       	acall	0x9f

80004038 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80004038:	d4 01       	pushm	lr
    
	static portBASE_TYPE xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
8000403a:	30 09       	mov	r9,0
8000403c:	49 b8       	lddpc	r8,800040a8 <pdca_int_handler+0x70>
8000403e:	91 09       	st.w	r8[0x0],r9
	
	static U32 count=0;
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	count++;
80004040:	49 b8       	lddpc	r8,800040ac <pdca_int_handler+0x74>
80004042:	70 09       	ld.w	r9,r8[0x0]
80004044:	2f f9       	sub	r9,-1
80004046:	91 09       	st.w	r8[0x0],r9
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80004048:	49 a8       	lddpc	r8,800040b0 <pdca_int_handler+0x78>
8000404a:	11 89       	ld.ub	r9,r8[0x0]
8000404c:	ec 19 00 01 	eorl	r9,0x1
80004050:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80004052:	11 89       	ld.ub	r9,r8[0x0]
80004054:	a5 69       	lsl	r9,0x4
80004056:	2f c9       	sub	r9,-4
80004058:	49 7a       	lddpc	r10,800040b4 <pdca_int_handler+0x7c>
8000405a:	14 09       	add	r9,r10
	count++;
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
8000405c:	fe 7a 00 40 	mov	r10,-65472
80004060:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004062:	30 39       	mov	r9,3
80004064:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80004066:	11 8a       	ld.ub	r10,r8[0x0]
80004068:	a5 6a       	lsl	r10,0x4
8000406a:	2f ca       	sub	r10,-4
8000406c:	49 38       	lddpc	r8,800040b8 <pdca_int_handler+0x80>
8000406e:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80004070:	fe 78 00 00 	mov	r8,-65536
80004074:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80004076:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80004078:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
8000407a:	49 18       	lddpc	r8,800040bc <pdca_int_handler+0x84>
8000407c:	70 08       	ld.w	r8,r8[0x0]
8000407e:	58 08       	cp.w	r8,0
80004080:	c0 70       	breq	8000408e <pdca_int_handler+0x56>
80004082:	48 c9       	lddpc	r9,800040b0 <pdca_int_handler+0x78>
80004084:	13 89       	ld.ub	r9,r9[0x0]
80004086:	a5 69       	lsl	r9,0x4
80004088:	48 cc       	lddpc	r12,800040b8 <pdca_int_handler+0x80>
8000408a:	12 0c       	add	r12,r9
8000408c:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
8000408e:	48 d8       	lddpc	r8,800040c0 <pdca_int_handler+0x88>
80004090:	70 08       	ld.w	r8,r8[0x0]
80004092:	58 08       	cp.w	r8,0
80004094:	c0 70       	breq	800040a2 <pdca_int_handler+0x6a>
80004096:	48 79       	lddpc	r9,800040b0 <pdca_int_handler+0x78>
80004098:	13 89       	ld.ub	r9,r9[0x0]
8000409a:	a5 69       	lsl	r9,0x4
8000409c:	48 6c       	lddpc	r12,800040b4 <pdca_int_handler+0x7c>
8000409e:	12 0c       	add	r12,r9
800040a0:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
800040a2:	d4 02       	popm	lr
800040a4:	d6 03       	rete
800040a6:	00 00       	add	r0,r0
800040a8:	00 00       	add	r0,r0
800040aa:	0a f0       	st.b	--r5,r0
800040ac:	00 00       	add	r0,r0
800040ae:	0a f4       	st.b	--r5,r4
800040b0:	00 00       	add	r0,r0
800040b2:	53 50       	stdsp	sp[0xd4],r0
800040b4:	00 00       	add	r0,r0
800040b6:	53 78       	stdsp	sp[0xdc],r8
800040b8:	00 00       	add	r0,r0
800040ba:	53 58       	stdsp	sp[0xd4],r8
800040bc:	00 00       	add	r0,r0
800040be:	0a ec       	st.h	--r5,r12
800040c0:	00 00       	add	r0,r0
800040c2:	0a f8       	st.b	--r5,r8

800040c4 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
800040c4:	fe 78 10 00 	mov	r8,-61440
800040c8:	e0 69 0d c0 	mov	r9,3520
800040cc:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
800040d0:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
800040d4:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
800040d8:	fe 78 34 00 	mov	r8,-52224
800040dc:	e0 69 80 00 	mov	r9,32768
800040e0:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
800040e2:	30 09       	mov	r9,0
800040e4:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
800040e6:	e0 69 04 21 	mov	r9,1057
800040ea:	ea 19 3f 20 	orh	r9,0x3f20
800040ee:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
800040f0:	e0 69 02 9f 	mov	r9,671
800040f4:	ea 19 01 00 	orh	r9,0x100
800040f8:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
800040fa:	e0 6a 04 02 	mov	r10,1026
800040fe:	ea 1a 3f 20 	orh	r10,0x3f20
80004102:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80004104:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80004106:	5e fc       	retal	r12

80004108 <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80004108:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
8000410a:	30 19       	mov	r9,1
8000410c:	49 78       	lddpc	r8,80004168 <local_start_PDC+0x60>
8000410e:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80004110:	fe 78 00 00 	mov	r8,-65536
80004114:	30 7b       	mov	r11,7
80004116:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80004118:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
8000411a:	49 59       	lddpc	r9,8000416c <local_start_PDC+0x64>
8000411c:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80004120:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80004122:	30 3a       	mov	r10,3
80004124:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80004126:	30 1c       	mov	r12,1
80004128:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
8000412a:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
8000412c:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
8000412e:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004130:	30 2c       	mov	r12,2
80004132:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80004134:	48 f9       	lddpc	r9,80004170 <local_start_PDC+0x68>
80004136:	e0 68 5a 5a 	mov	r8,23130
8000413a:	ea 18 ab cd 	orh	r8,0xabcd
8000413e:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80004140:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80004142:	30 0e       	mov	lr,0
80004144:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80004146:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80004148:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
8000414a:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
8000414c:	fe 78 00 40 	mov	r8,-65472
80004150:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80004152:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80004154:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80004158:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
8000415a:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
8000415c:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
8000415e:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80004160:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80004162:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80004164:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80004166:	d8 02       	popm	pc
80004168:	00 00       	add	r0,r0
8000416a:	53 50       	stdsp	sp[0xd4],r0
8000416c:	00 00       	add	r0,r0
8000416e:	53 58       	stdsp	sp[0xd4],r8
80004170:	00 00       	add	r0,r0
80004172:	53 78       	stdsp	sp[0xdc],r8

80004174 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80004174:	48 38       	lddpc	r8,80004180 <register_rx_tx_func+0xc>
80004176:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80004178:	48 38       	lddpc	r8,80004184 <register_rx_tx_func+0x10>
8000417a:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
8000417c:	5e fc       	retal	r12
8000417e:	00 00       	add	r0,r0
80004180:	00 00       	add	r0,r0
80004182:	0a ec       	st.h	--r5,r12
80004184:	00 00       	add	r0,r0
80004186:	0a f8       	st.b	--r5,r8

80004188 <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80004188:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
8000418a:	fe 78 10 00 	mov	r8,-61440
8000418e:	30 29       	mov	r9,2
80004190:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80004194:	f1 49 01 04 	st.w	r8[260],r9
	
	Disable_global_interrupt();
80004198:	d3 03       	ssrf	0x10
	
	INTC_register_interrupt (
8000419a:	30 3a       	mov	r10,3
8000419c:	36 0b       	mov	r11,96
8000419e:	49 4c       	lddpc	r12,800041ec <ssc_init+0x64>
800041a0:	f0 1f 00 14 	mcall	800041f0 <ssc_init+0x68>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0 //PDCA_CHANNEL_SSCRX_EXAMPLE = 0
	, AVR32_INTC_INT3 //highest priority.
	);
	
	Enable_global_interrupt();
800041a4:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
800041a6:	fe 79 10 00 	mov	r9,-61440
800041aa:	f2 f8 01 60 	ld.w	r8,r9[352]
800041ae:	e2 18 00 02 	andl	r8,0x2,COH
800041b2:	cf c0       	breq	800041aa <ssc_init+0x22>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
800041b4:	fe 79 10 00 	mov	r9,-61440
800041b8:	f2 f8 01 60 	ld.w	r8,r9[352]
800041bc:	e2 18 00 02 	andl	r8,0x2,COH
800041c0:	cf c1       	brne	800041b8 <ssc_init+0x30>
			
	Disable_global_interrupt(); // resume to before
800041c2:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
800041c4:	f0 1f 00 0c 	mcall	800041f4 <ssc_init+0x6c>

    /*config the PDCA*/
    local_start_PDC();
800041c8:	f0 1f 00 0c 	mcall	800041f8 <ssc_init+0x70>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800041cc:	fe 79 00 00 	mov	r9,-65536
800041d0:	30 18       	mov	r8,1
800041d2:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
800041d4:	fe 7a 00 40 	mov	r10,-65472
800041d8:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
800041da:	e0 6b 01 01 	mov	r11,257
800041de:	fe 7a 34 00 	mov	r10,-52224
800041e2:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
800041e4:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
800041e6:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
800041e8:	d8 02       	popm	pc
800041ea:	00 00       	add	r0,r0
800041ec:	80 00       	ld.sh	r0,r0[0x0]
800041ee:	40 38       	lddsp	r8,sp[0xc]
800041f0:	80 00       	ld.sh	r0,r0[0x0]
800041f2:	55 78       	stdsp	sp[0x15c],r8
800041f4:	80 00       	ld.sh	r0,r0[0x0]
800041f6:	40 c4       	lddsp	r4,sp[0x30]
800041f8:	80 00       	ld.sh	r0,r0[0x0]
800041fa:	41 08       	lddsp	r8,sp[0x40]

800041fc <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
800041fc:	48 28       	lddpc	r8,80004204 <xcmp_register_app_list+0x8>
800041fe:	91 0c       	st.w	r8[0x0],r12
}
80004200:	5e fc       	retal	r12
80004202:	00 00       	add	r0,r0
80004204:	00 00       	add	r0,r0
80004206:	53 98       	stdsp	sp[0xe4],r8

80004208 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80004208:	eb cd 40 80 	pushm	r7,lr
8000420c:	fa cd 01 00 	sub	sp,sp,256
80004210:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80004212:	16 98       	mov	r8,r11
80004214:	2f 08       	sub	r8,-16
80004216:	af a8       	sbr	r8,0xe
80004218:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
8000421a:	3f f8       	mov	r8,-1
8000421c:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
8000421e:	30 b9       	mov	r9,11
80004220:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80004222:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80004224:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80004226:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004228:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
8000422a:	f6 ca ff fe 	sub	r10,r11,-2
8000422e:	18 9b       	mov	r11,r12
80004230:	fa cc ff f0 	sub	r12,sp,-16
80004234:	f0 1f 00 05 	mcall	80004248 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80004238:	2f e7       	sub	r7,-2
8000423a:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
8000423c:	1a 9c       	mov	r12,sp
8000423e:	f0 1f 00 04 	mcall	8000424c <xcmp_tx+0x44>
}
80004242:	2c 0d       	sub	sp,-256
80004244:	e3 cd 80 80 	ldm	sp++,r7,pc
80004248:	80 00       	ld.sh	r0,r0[0x0]
8000424a:	79 8c       	ld.w	r12,r12[0x60]
8000424c:	80 00       	ld.sh	r0,r0[0x0]
8000424e:	48 14       	lddpc	r4,80004250 <xcmp_data_session_req>

80004250 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80004250:	d4 21       	pushm	r4-r7,lr
80004252:	fa cd 00 d0 	sub	sp,sp,208
80004256:	18 94       	mov	r4,r12
80004258:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
8000425a:	e0 68 01 00 	mov	r8,256
8000425e:	f0 0b 19 00 	cp.h	r11,r8
80004262:	e0 8b 00 36 	brhi	800042ce <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80004266:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
8000426a:	e0 68 04 1d 	mov	r8,1053
8000426e:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80004270:	30 18       	mov	r8,1
80004272:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80004274:	32 08       	mov	r8,32
80004276:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80004278:	30 28       	mov	r8,2
8000427a:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
8000427c:	30 48       	mov	r8,4
8000427e:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80004280:	ea 1a 0c 00 	orh	r10,0xc00
80004284:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80004286:	30 4a       	mov	r10,4
80004288:	1a 9b       	mov	r11,sp
8000428a:	fa cc ff f4 	sub	r12,sp,-12
8000428e:	f0 1f 00 12 	mcall	800042d4 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80004292:	30 f8       	mov	r8,15
80004294:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80004298:	3a 78       	mov	r8,-89
8000429a:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
8000429e:	30 08       	mov	r8,0
800042a0:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
800042a4:	0e 9a       	mov	r10,r7
800042a6:	5c 7a       	castu.h	r10
800042a8:	f4 08 16 08 	lsr	r8,r10,0x8
800042ac:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
800042b0:	0e 96       	mov	r6,r7
800042b2:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
800042b6:	08 9b       	mov	r11,r4
800042b8:	fa cc ff eb 	sub	r12,sp,-21
800042bc:	f0 1f 00 06 	mcall	800042d4 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
800042c0:	ee cb ff f3 	sub	r11,r7,-13
800042c4:	5c 5b       	castu.b	r11
800042c6:	fa cc ff fa 	sub	r12,sp,-6
800042ca:	f0 1f 00 04 	mcall	800042d8 <xcmp_data_session_req+0x88>
}
800042ce:	2c cd       	sub	sp,-208
800042d0:	d8 22       	popm	r4-r7,pc
800042d2:	00 00       	add	r0,r0
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	79 8c       	ld.w	r12,r12[0x60]
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	42 08       	lddsp	r8,sp[0x80]

800042dc <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800042dc:	d4 01       	pushm	lr
800042de:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800042e2:	fe 78 b4 00 	mov	r8,-19456
800042e6:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800042e8:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800042ec:	30 89       	mov	r9,8
800042ee:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800042f0:	30 19       	mov	r9,1
800042f2:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800042f4:	30 09       	mov	r9,0
800042f6:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
800042f8:	30 5a       	mov	r10,5
800042fa:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
800042fc:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
800042fe:	30 7a       	mov	r10,7
80004300:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80004302:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80004304:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80004306:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
8000430a:	30 9b       	mov	r11,9
8000430c:	fa cc ff fe 	sub	r12,sp,-2
80004310:	f0 1f 00 02 	mcall	80004318 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80004314:	2c dd       	sub	sp,-204
80004316:	d8 02       	popm	pc
80004318:	80 00       	ld.sh	r0,r0[0x0]
8000431a:	42 08       	lddsp	r8,sp[0x80]

8000431c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
8000431c:	d4 01       	pushm	lr
8000431e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80004322:	fe 78 80 00 	mov	r8,-32768
80004326:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80004328:	30 38       	mov	r8,3
8000432a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
8000432c:	30 1b       	mov	r11,1
8000432e:	fa cc ff fe 	sub	r12,sp,-2
80004332:	f0 1f 00 03 	mcall	8000433c <xcmp_opcode_not_supported+0x20>
}
80004336:	2c dd       	sub	sp,-204
80004338:	d8 02       	popm	pc
8000433a:	00 00       	add	r0,r0
8000433c:	80 00       	ld.sh	r0,r0[0x0]
8000433e:	42 08       	lddsp	r8,sp[0x80]

80004340 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80004340:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80004342:	96 88       	ld.uh	r8,r11[0x0]
80004344:	e2 18 f0 00 	andl	r8,0xf000,COH
80004348:	e0 48 80 00 	cp.w	r8,32768
8000434c:	c0 f0       	breq	8000436a <xcmp_exec_func+0x2a>
8000434e:	e0 48 b0 00 	cp.w	r8,45056
80004352:	c1 20       	breq	80004376 <xcmp_exec_func+0x36>
80004354:	58 08       	cp.w	r8,0
80004356:	c1 51       	brne	80004380 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80004358:	78 08       	ld.w	r8,r12[0x0]
8000435a:	58 08       	cp.w	r8,0
8000435c:	c0 40       	breq	80004364 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
8000435e:	16 9c       	mov	r12,r11
80004360:	5d 18       	icall	r8
80004362:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80004364:	f0 1f 00 08 	mcall	80004384 <xcmp_exec_func+0x44>
80004368:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
8000436a:	78 18       	ld.w	r8,r12[0x4]
8000436c:	58 08       	cp.w	r8,0
8000436e:	c0 90       	breq	80004380 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80004370:	16 9c       	mov	r12,r11
80004372:	5d 18       	icall	r8
80004374:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80004376:	78 28       	ld.w	r8,r12[0x8]
80004378:	58 08       	cp.w	r8,0
8000437a:	c0 30       	breq	80004380 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
8000437c:	16 9c       	mov	r12,r11
8000437e:	5d 18       	icall	r8
80004380:	d8 02       	popm	pc
80004382:	00 00       	add	r0,r0
80004384:	80 00       	ld.sh	r0,r0[0x0]
80004386:	43 1c       	lddsp	r12,sp[0xc4]

80004388 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80004388:	d4 01       	pushm	lr
8000438a:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000438e:	e0 68 04 09 	mov	r8,1033
80004392:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80004394:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80004398:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
8000439a:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000439e:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
800043a0:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
800043a2:	30 09       	mov	r9,0
800043a4:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
800043a6:	fb 69 00 08 	st.b	sp[8],r9
800043aa:	fa c8 ff f7 	sub	r8,sp,-9
800043ae:	b0 89       	st.b	r8[0x0],r9
800043b0:	fa c8 ff f6 	sub	r8,sp,-10
800043b4:	b0 89       	st.b	r8[0x0],r9
800043b6:	fa c8 ff f5 	sub	r8,sp,-11
800043ba:	b0 89       	st.b	r8[0x0],r9
800043bc:	fa c8 ff f4 	sub	r8,sp,-12
800043c0:	b0 89       	st.b	r8[0x0],r9
800043c2:	fa c8 ff f3 	sub	r8,sp,-13
800043c6:	b0 89       	st.b	r8[0x0],r9
800043c8:	fa c8 ff f2 	sub	r8,sp,-14
800043cc:	b0 89       	st.b	r8[0x0],r9
800043ce:	fa c8 ff f1 	sub	r8,sp,-15
800043d2:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
800043d4:	30 cb       	mov	r11,12
800043d6:	fa cc ff fe 	sub	r12,sp,-2
800043da:	f0 1f 00 03 	mcall	800043e4 <xcmp_IdleTestTone+0x5c>
}
800043de:	2c dd       	sub	sp,-204
800043e0:	d8 02       	popm	pc
800043e2:	00 00       	add	r0,r0
800043e4:	80 00       	ld.sh	r0,r0[0x0]
800043e6:	42 08       	lddsp	r8,sp[0x80]

800043e8 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
800043e8:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
800043ea:	48 dc       	lddpc	r12,8000441c <xcmp_init+0x34>
800043ec:	f0 1f 00 0d 	mcall	80004420 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
800043f0:	30 4b       	mov	r11,4
800043f2:	31 4c       	mov	r12,20
800043f4:	f0 1f 00 0c 	mcall	80004424 <xcmp_init+0x3c>
800043f8:	48 c8       	lddpc	r8,80004428 <xcmp_init+0x40>
800043fa:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
800043fc:	30 09       	mov	r9,0
800043fe:	1a d9       	st.w	--sp,r9
80004400:	1a d9       	st.w	--sp,r9
80004402:	1a d9       	st.w	--sp,r9
80004404:	30 38       	mov	r8,3
80004406:	e0 6a 04 00 	mov	r10,1024
8000440a:	48 9b       	lddpc	r11,8000442c <xcmp_init+0x44>
8000440c:	48 9c       	lddpc	r12,80004430 <xcmp_init+0x48>
8000440e:	f0 1f 00 0a 	mcall	80004434 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80004412:	f0 1f 00 0a 	mcall	80004438 <xcmp_init+0x50>
80004416:	2f dd       	sub	sp,-12
	
}
80004418:	d8 02       	popm	pc
8000441a:	00 00       	add	r0,r0
8000441c:	80 00       	ld.sh	r0,r0[0x0]
8000441e:	45 38       	lddsp	r8,sp[0x14c]
80004420:	80 00       	ld.sh	r0,r0[0x0]
80004422:	45 84       	lddsp	r4,sp[0x160]
80004424:	80 00       	ld.sh	r0,r0[0x0]
80004426:	66 30       	ld.w	r0,r3[0xc]
80004428:	00 00       	add	r0,r0
8000442a:	0b 14       	ld.sh	r4,r5++
8000442c:	80 00       	ld.sh	r0,r0[0x0]
8000442e:	da 1c       	*unknown*
80004430:	80 00       	ld.sh	r0,r0[0x0]
80004432:	44 3c       	lddsp	r12,sp[0x10c]
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	6d 4c       	ld.w	r12,r6[0x50]
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	45 bc       	lddsp	r12,sp[0x16c]

8000443c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
8000443c:	d4 31       	pushm	r0-r7,lr
8000443e:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80004440:	4b 16       	lddpc	r6,80004504 <xcmp_rx_process+0xc8>
80004442:	30 05       	mov	r5,0
80004444:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004446:	4b 13       	lddpc	r3,80004508 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80004448:	4b 12       	lddpc	r2,8000450c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
8000444a:	4b 21       	lddpc	r1,80004510 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
8000444c:	4b 20       	lddpc	r0,80004514 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
8000444e:	6c 0c       	ld.w	r12,r6[0x0]
80004450:	0a 99       	mov	r9,r5
80004452:	08 9a       	mov	r10,r4
80004454:	1a 9b       	mov	r11,sp
80004456:	f0 1f 00 31 	mcall	80004518 <xcmp_rx_process+0xdc>
8000445a:	58 1c       	cp.w	r12,1
8000445c:	cf 91       	brne	8000444e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
8000445e:	40 0b       	lddsp	r11,sp[0x0]
80004460:	58 0b       	cp.w	r11,0
80004462:	cf 60       	breq	8000444e <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80004464:	96 0a       	ld.sh	r10,r11[0x0]
80004466:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
8000446a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
8000446e:	59 c8       	cp.w	r8,28
80004470:	c1 e0       	breq	800044ac <xcmp_rx_process+0x70>
80004472:	e0 89 00 07 	brgt	80004480 <xcmp_rx_process+0x44>
80004476:	58 e8       	cp.w	r8,14
80004478:	c0 e0       	breq	80004494 <xcmp_rx_process+0x58>
8000447a:	58 f8       	cp.w	r8,15
8000447c:	c2 41       	brne	800044c4 <xcmp_rx_process+0x88>
8000447e:	c0 f8       	rjmp	8000449c <xcmp_rx_process+0x60>
80004480:	e0 48 01 09 	cp.w	r8,265
80004484:	c1 80       	breq	800044b4 <xcmp_rx_process+0x78>
80004486:	e0 48 01 0a 	cp.w	r8,266
8000448a:	c1 90       	breq	800044bc <xcmp_rx_process+0x80>
8000448c:	e0 48 00 2c 	cp.w	r8,44
80004490:	c1 a1       	brne	800044c4 <xcmp_rx_process+0x88>
80004492:	c0 98       	rjmp	800044a4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80004494:	4a 2c       	lddpc	r12,8000451c <xcmp_rx_process+0xe0>
80004496:	f0 1f 00 23 	mcall	80004520 <xcmp_rx_process+0xe4>
					break;
8000449a:	c2 f8       	rjmp	800044f8 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
8000449c:	4a 2c       	lddpc	r12,80004524 <xcmp_rx_process+0xe8>
8000449e:	f0 1f 00 21 	mcall	80004520 <xcmp_rx_process+0xe4>
					break;
800044a2:	c2 b8       	rjmp	800044f8 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
800044a4:	4a 1c       	lddpc	r12,80004528 <xcmp_rx_process+0xec>
800044a6:	f0 1f 00 1f 	mcall	80004520 <xcmp_rx_process+0xe4>
					break;
800044aa:	c2 78       	rjmp	800044f8 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
800044ac:	04 9c       	mov	r12,r2
800044ae:	f0 1f 00 1d 	mcall	80004520 <xcmp_rx_process+0xe4>
						, ptr);
					break;
800044b2:	c2 38       	rjmp	800044f8 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
800044b4:	02 9c       	mov	r12,r1
800044b6:	f0 1f 00 1b 	mcall	80004520 <xcmp_rx_process+0xe4>
					break;
800044ba:	c1 f8       	rjmp	800044f8 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
800044bc:	00 9c       	mov	r12,r0
800044be:	f0 1f 00 19 	mcall	80004520 <xcmp_rx_process+0xe4>
					break;
800044c2:	c1 b8       	rjmp	800044f8 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
800044c4:	12 98       	mov	r8,r9
800044c6:	e2 18 04 00 	andl	r8,0x400,COH
800044ca:	c0 70       	breq	800044d8 <xcmp_rx_process+0x9c>
800044cc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
800044d0:	e0 48 00 68 	cp.w	r8,104
800044d4:	e0 8a 00 08 	brle	800044e4 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
800044d8:	e2 19 f0 00 	andl	r9,0xf000,COH
800044dc:	c0 e1       	brne	800044f8 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
800044de:	f0 1f 00 14 	mcall	8000452c <xcmp_rx_process+0xf0>
800044e2:	c0 b8       	rjmp	800044f8 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
800044e4:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
800044e8:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
800044ec:	49 19       	lddpc	r9,80004530 <xcmp_rx_process+0xf4>
800044ee:	72 08       	ld.w	r8,r9[0x0]
800044f0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800044f4:	f0 1f 00 0b 	mcall	80004520 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
800044f8:	66 0c       	ld.w	r12,r3[0x0]
800044fa:	40 0b       	lddsp	r11,sp[0x0]
800044fc:	f0 1f 00 0e 	mcall	80004534 <xcmp_rx_process+0xf8>
80004500:	ca 7b       	rjmp	8000444e <xcmp_rx_process+0x12>
80004502:	00 00       	add	r0,r0
80004504:	00 00       	add	r0,r0
80004506:	0b 14       	ld.sh	r4,r5++
80004508:	00 00       	add	r0,r0
8000450a:	0a a8       	st.w	r5++,r8
8000450c:	00 00       	add	r0,r0
8000450e:	0b 24       	ld.uh	r4,r5++
80004510:	00 00       	add	r0,r0
80004512:	0b 18       	ld.sh	r8,r5++
80004514:	00 00       	add	r0,r0
80004516:	0b 08       	ld.w	r8,r5++
80004518:	80 00       	ld.sh	r0,r0[0x0]
8000451a:	62 cc       	ld.w	r12,r1[0x30]
8000451c:	00 00       	add	r0,r0
8000451e:	0b 3c       	ld.ub	r12,r5++
80004520:	80 00       	ld.sh	r0,r0[0x0]
80004522:	43 40       	lddsp	r0,sp[0xd0]
80004524:	00 00       	add	r0,r0
80004526:	0a fc       	st.b	--r5,r12
80004528:	00 00       	add	r0,r0
8000452a:	0b 30       	ld.ub	r0,r5++
8000452c:	80 00       	ld.sh	r0,r0[0x0]
8000452e:	43 1c       	lddsp	r12,sp[0xc4]
80004530:	00 00       	add	r0,r0
80004532:	53 98       	stdsp	sp[0xe4],r8
80004534:	80 00       	ld.sh	r0,r0[0x0]
80004536:	2f 18       	sub	r8,-15

80004538 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004538:	eb cd 40 90 	pushm	r4,r7,lr
8000453c:	20 1d       	sub	sp,4
8000453e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004542:	48 c8       	lddpc	r8,80004570 <xcmp_rx+0x38>
80004544:	70 0c       	ld.w	r12,r8[0x0]
80004546:	f0 1f 00 0c 	mcall	80004574 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000454a:	c1 00       	breq	8000456a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000454c:	fa c7 ff fc 	sub	r7,sp,-4
80004550:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004552:	e0 6a 00 ca 	mov	r10,202
80004556:	08 9b       	mov	r11,r4
80004558:	f0 1f 00 08 	mcall	80004578 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000455c:	48 88       	lddpc	r8,8000457c <xcmp_rx+0x44>
8000455e:	70 0c       	ld.w	r12,r8[0x0]
80004560:	30 09       	mov	r9,0
80004562:	12 9a       	mov	r10,r9
80004564:	1a 9b       	mov	r11,sp
80004566:	f0 1f 00 07 	mcall	80004580 <xcmp_rx+0x48>
	}	
}
8000456a:	2f fd       	sub	sp,-4
8000456c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
80004570:	00 00       	add	r0,r0
80004572:	0a a8       	st.w	r5++,r8
80004574:	80 00       	ld.sh	r0,r0[0x0]
80004576:	30 c4       	mov	r4,12
80004578:	80 00       	ld.sh	r0,r0[0x0]
8000457a:	79 8c       	ld.w	r12,r12[0x60]
8000457c:	00 00       	add	r0,r0
8000457e:	0b 14       	ld.sh	r4,r5++
80004580:	80 00       	ld.sh	r0,r0[0x0]
80004582:	64 d8       	ld.w	r8,r2[0x34]

80004584 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
80004584:	48 28       	lddpc	r8,8000458c <xnl_register_xcmp_func+0x8>
80004586:	91 0c       	st.w	r8[0x0],r12
}
80004588:	5e fc       	retal	r12
8000458a:	00 00       	add	r0,r0
8000458c:	00 00       	add	r0,r0
8000458e:	0b 68       	ld.uh	r8,--r5

80004590 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
80004590:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
80004592:	48 88       	lddpc	r8,800045b0 <xnl_get_msg_ack_func+0x20>
80004594:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
80004596:	98 49       	ld.sh	r9,r12[0x8]
80004598:	f0 09 19 00 	cp.h	r9,r8
8000459c:	c0 81       	brne	800045ac <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
8000459e:	48 68       	lddpc	r8,800045b4 <xnl_get_msg_ack_func+0x24>
800045a0:	70 0c       	ld.w	r12,r8[0x0]
800045a2:	30 09       	mov	r9,0
800045a4:	12 9a       	mov	r10,r9
800045a6:	12 9b       	mov	r11,r9
800045a8:	f0 1f 00 04 	mcall	800045b8 <xnl_get_msg_ack_func+0x28>
800045ac:	d8 02       	popm	pc
800045ae:	00 00       	add	r0,r0
800045b0:	00 00       	add	r0,r0
800045b2:	0b 4e       	ld.w	lr,--r5
800045b4:	00 00       	add	r0,r0
800045b6:	0b 48       	ld.w	r8,--r5
800045b8:	80 00       	ld.sh	r0,r0[0x0]
800045ba:	64 d8       	ld.w	r8,r2[0x34]

800045bc <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800045bc:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800045c0:	30 09       	mov	r9,0
800045c2:	4b 78       	lddpc	r8,8000469c <xnl_init+0xe0>
800045c4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800045c6:	30 0b       	mov	r11,0
800045c8:	30 1c       	mov	r12,1
800045ca:	f0 1f 00 36 	mcall	800046a0 <xnl_init+0xe4>
800045ce:	4b 68       	lddpc	r8,800046a4 <xnl_init+0xe8>
800045d0:	91 0c       	st.w	r8[0x0],r12
800045d2:	70 08       	ld.w	r8,r8[0x0]
800045d4:	58 08       	cp.w	r8,0
800045d6:	c0 80       	breq	800045e6 <xnl_init+0x2a>
800045d8:	4b 38       	lddpc	r8,800046a4 <xnl_init+0xe8>
800045da:	70 0c       	ld.w	r12,r8[0x0]
800045dc:	30 09       	mov	r9,0
800045de:	12 9a       	mov	r10,r9
800045e0:	12 9b       	mov	r11,r9
800045e2:	f0 1f 00 32 	mcall	800046a8 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
800045e6:	30 4b       	mov	r11,4
800045e8:	31 4c       	mov	r12,20
800045ea:	f0 1f 00 2e 	mcall	800046a0 <xnl_init+0xe4>
800045ee:	4b 08       	lddpc	r8,800046ac <xnl_init+0xf0>
800045f0:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
800045f2:	30 4b       	mov	r11,4
800045f4:	31 ec       	mov	r12,30
800045f6:	f0 1f 00 2b 	mcall	800046a0 <xnl_init+0xe4>
800045fa:	4a e8       	lddpc	r8,800046b0 <xnl_init+0xf4>
800045fc:	91 0c       	st.w	r8[0x0],r12
800045fe:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004600:	10 96       	mov	r6,r8
80004602:	4a d5       	lddpc	r5,800046b4 <xnl_init+0xf8>
80004604:	6c 0c       	ld.w	r12,r6[0x0]
80004606:	ea 07 00 0b 	add	r11,r5,r7
8000460a:	f0 1f 00 2c 	mcall	800046b8 <xnl_init+0xfc>
8000460e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004612:	e0 47 1e 00 	cp.w	r7,7680
80004616:	cf 71       	brne	80004604 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004618:	30 4b       	mov	r11,4
8000461a:	31 4c       	mov	r12,20
8000461c:	f0 1f 00 21 	mcall	800046a0 <xnl_init+0xe4>
80004620:	4a 78       	lddpc	r8,800046bc <xnl_init+0x100>
80004622:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004624:	30 4b       	mov	r11,4
80004626:	30 ac       	mov	r12,10
80004628:	f0 1f 00 1e 	mcall	800046a0 <xnl_init+0xe4>
8000462c:	4a 58       	lddpc	r8,800046c0 <xnl_init+0x104>
8000462e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004630:	30 4b       	mov	r11,4
80004632:	30 ac       	mov	r12,10
80004634:	f0 1f 00 1b 	mcall	800046a0 <xnl_init+0xe4>
80004638:	4a 38       	lddpc	r8,800046c4 <xnl_init+0x108>
8000463a:	91 0c       	st.w	r8[0x0],r12
8000463c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000463e:	10 96       	mov	r6,r8
80004640:	4a 25       	lddpc	r5,800046c8 <xnl_init+0x10c>
80004642:	6c 0c       	ld.w	r12,r6[0x0]
80004644:	ea 07 00 0b 	add	r11,r5,r7
80004648:	f0 1f 00 1c 	mcall	800046b8 <xnl_init+0xfc>
8000464c:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004650:	e0 47 14 00 	cp.w	r7,5120
80004654:	cf 71       	brne	80004642 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004656:	30 4b       	mov	r11,4
80004658:	30 5c       	mov	r12,5
8000465a:	f0 1f 00 12 	mcall	800046a0 <xnl_init+0xe4>
8000465e:	49 c8       	lddpc	r8,800046cc <xnl_init+0x110>
80004660:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004662:	30 07       	mov	r7,0
80004664:	1a d7       	st.w	--sp,r7
80004666:	1a d7       	st.w	--sp,r7
80004668:	1a d7       	st.w	--sp,r7
8000466a:	30 38       	mov	r8,3
8000466c:	0e 99       	mov	r9,r7
8000466e:	e0 6a 00 dc 	mov	r10,220
80004672:	49 8b       	lddpc	r11,800046d0 <xnl_init+0x114>
80004674:	49 8c       	lddpc	r12,800046d4 <xnl_init+0x118>
80004676:	f0 1f 00 19 	mcall	800046d8 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
8000467a:	1a d7       	st.w	--sp,r7
8000467c:	1a d7       	st.w	--sp,r7
8000467e:	1a d7       	st.w	--sp,r7
80004680:	30 38       	mov	r8,3
80004682:	0e 99       	mov	r9,r7
80004684:	e0 6a 00 82 	mov	r10,130
80004688:	49 5b       	lddpc	r11,800046dc <xnl_init+0x120>
8000468a:	49 6c       	lddpc	r12,800046e0 <xnl_init+0x124>
8000468c:	f0 1f 00 13 	mcall	800046d8 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
80004690:	f0 1f 00 15 	mcall	800046e4 <xnl_init+0x128>
80004694:	2f ad       	sub	sp,-24
}
80004696:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000469a:	00 00       	add	r0,r0
8000469c:	00 00       	add	r0,r0
8000469e:	0b 4e       	ld.w	lr,--r5
800046a0:	80 00       	ld.sh	r0,r0[0x0]
800046a2:	66 30       	ld.w	r0,r3[0xc]
800046a4:	00 00       	add	r0,r0
800046a6:	0b 48       	ld.w	r8,--r5
800046a8:	80 00       	ld.sh	r0,r0[0x0]
800046aa:	64 d8       	ld.w	r8,r2[0x34]
800046ac:	00 00       	add	r0,r0
800046ae:	0b 5c       	ld.sh	r12,--r5
800046b0:	00 00       	add	r0,r0
800046b2:	0a a8       	st.w	r5++,r8
800046b4:	00 00       	add	r0,r0
800046b6:	35 4a       	mov	r10,84
800046b8:	80 00       	ld.sh	r0,r0[0x0]
800046ba:	2f 18       	sub	r8,-15
800046bc:	00 00       	add	r0,r0
800046be:	0a d8       	st.w	--r5,r8
800046c0:	00 00       	add	r0,r0
800046c2:	0a b8       	st.h	r5++,r8
800046c4:	00 00       	add	r0,r0
800046c6:	0a ac       	st.w	r5++,r12
800046c8:	00 00       	add	r0,r0
800046ca:	21 4a       	sub	r10,20
800046cc:	00 00       	add	r0,r0
800046ce:	0a e4       	st.h	--r5,r4
800046d0:	80 00       	ld.sh	r0,r0[0x0]
800046d2:	da 24       	*unknown*
800046d4:	80 00       	ld.sh	r0,r0[0x0]
800046d6:	46 e8       	lddsp	r8,sp[0x1b8]
800046d8:	80 00       	ld.sh	r0,r0[0x0]
800046da:	6d 4c       	ld.w	r12,r6[0x50]
800046dc:	80 00       	ld.sh	r0,r0[0x0]
800046de:	da 2c       	*unknown*
800046e0:	80 00       	ld.sh	r0,r0[0x0]
800046e2:	47 48       	lddsp	r8,sp[0x1d0]
800046e4:	80 00       	ld.sh	r0,r0[0x0]
800046e6:	30 ec       	mov	r12,14

800046e8 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
800046e8:	eb cd 40 fe 	pushm	r1-r7,lr
800046ec:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800046ee:	49 26       	lddpc	r6,80004734 <xnl_rx_process+0x4c>
800046f0:	30 05       	mov	r5,0
800046f2:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
800046f4:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
800046f6:	49 11       	lddpc	r1,80004738 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
800046f8:	49 12       	lddpc	r2,8000473c <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
800046fa:	6c 0c       	ld.w	r12,r6[0x0]
800046fc:	0a 99       	mov	r9,r5
800046fe:	08 9a       	mov	r10,r4
80004700:	1a 9b       	mov	r11,sp
80004702:	f0 1f 00 10 	mcall	80004740 <xnl_rx_process+0x58>
80004706:	58 1c       	cp.w	r12,1
80004708:	cf 91       	brne	800046fa <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000470a:	40 0c       	lddsp	r12,sp[0x0]
8000470c:	58 0c       	cp.w	r12,0
8000470e:	cf 60       	breq	800046fa <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004710:	98 28       	ld.sh	r8,r12[0x4]
80004712:	e6 08 19 00 	cp.h	r8,r3
80004716:	e0 8b 00 0a 	brhi	8000472a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000471a:	5c 78       	castu.h	r8
8000471c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004720:	58 09       	cp.w	r9,0
80004722:	c0 40       	breq	8000472a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004724:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004728:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000472a:	62 0c       	ld.w	r12,r1[0x0]
8000472c:	40 0b       	lddsp	r11,sp[0x0]
8000472e:	f0 1f 00 06 	mcall	80004744 <xnl_rx_process+0x5c>
80004732:	ce 4b       	rjmp	800046fa <xnl_rx_process+0x12>
80004734:	00 00       	add	r0,r0
80004736:	0a b8       	st.h	r5++,r8
80004738:	00 00       	add	r0,r0
8000473a:	0a a8       	st.w	r5++,r8
8000473c:	00 00       	add	r0,r0
8000473e:	04 f8       	st.b	--r2,r8
80004740:	80 00       	ld.sh	r0,r0[0x0]
80004742:	62 cc       	ld.w	r12,r1[0x30]
80004744:	80 00       	ld.sh	r0,r0[0x0]
80004746:	2f 18       	sub	r8,-15

80004748 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004748:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000474a:	4a a6       	lddpc	r6,800047f0 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000474c:	4a a2       	lddpc	r2,800047f4 <xnl_tx_process+0xac>
8000474e:	4a b4       	lddpc	r4,800047f8 <xnl_tx_process+0xb0>
80004750:	30 07       	mov	r7,0
80004752:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004754:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004756:	4a a5       	lddpc	r5,800047fc <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004758:	4a a3       	lddpc	r3,80004800 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000475a:	6c 08       	ld.w	r8,r6[0x0]
8000475c:	58 08       	cp.w	r8,0
8000475e:	c0 40       	breq	80004766 <xnl_tx_process+0x1e>
80004760:	58 18       	cp.w	r8,1
80004762:	cf d1       	brne	8000475c <xnl_tx_process+0x14>
80004764:	c2 48       	rjmp	800047ac <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004766:	64 0c       	ld.w	r12,r2[0x0]
80004768:	0e 99       	mov	r9,r7
8000476a:	02 9a       	mov	r10,r1
8000476c:	08 9b       	mov	r11,r4
8000476e:	f0 1f 00 26 	mcall	80004804 <xnl_tx_process+0xbc>
80004772:	58 1c       	cp.w	r12,1
80004774:	cf 31       	brne	8000475a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
80004776:	68 0b       	ld.w	r11,r4[0x0]
80004778:	58 0b       	cp.w	r11,0
8000477a:	cf 00       	breq	8000475a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
8000477c:	96 28       	ld.sh	r8,r11[0x4]
8000477e:	e0 08 19 00 	cp.h	r8,r0
80004782:	c0 71       	brne	80004790 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
80004784:	4a 18       	lddpc	r8,80004808 <xnl_tx_process+0xc0>
80004786:	70 08       	ld.w	r8,r8[0x0]
80004788:	10 9c       	mov	r12,r8
8000478a:	f0 1f 00 21 	mcall	8000480c <xnl_tx_process+0xc4>
						break;
8000478e:	ce 6b       	rjmp	8000475a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
80004790:	16 9c       	mov	r12,r11
80004792:	f0 1f 00 20 	mcall	80004810 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004796:	30 18       	mov	r8,1
80004798:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
8000479a:	66 0c       	ld.w	r12,r3[0x0]
8000479c:	0e 99       	mov	r9,r7
8000479e:	0e 9a       	mov	r10,r7
800047a0:	0e 9b       	mov	r11,r7
800047a2:	f0 1f 00 19 	mcall	80004804 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800047a6:	30 18       	mov	r8,1
800047a8:	8d 08       	st.w	r6[0x0],r8
800047aa:	cd 8b       	rjmp	8000475a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800047ac:	66 0c       	ld.w	r12,r3[0x0]
800047ae:	0e 99       	mov	r9,r7
800047b0:	36 4a       	mov	r10,100
800047b2:	0e 9b       	mov	r11,r7
800047b4:	f0 1f 00 14 	mcall	80004804 <xnl_tx_process+0xbc>
800047b8:	58 1c       	cp.w	r12,1
800047ba:	c0 81       	brne	800047ca <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800047bc:	49 38       	lddpc	r8,80004808 <xnl_tx_process+0xc0>
800047be:	70 0c       	ld.w	r12,r8[0x0]
800047c0:	68 0b       	ld.w	r11,r4[0x0]
800047c2:	f0 1f 00 13 	mcall	8000480c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800047c6:	8d 07       	st.w	r6[0x0],r7
800047c8:	cc 9b       	rjmp	8000475a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800047ca:	6a 08       	ld.w	r8,r5[0x0]
800047cc:	58 38       	cp.w	r8,3
800047ce:	e0 89 00 09 	brgt	800047e0 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
800047d2:	68 0c       	ld.w	r12,r4[0x0]
800047d4:	f0 1f 00 0f 	mcall	80004810 <xnl_tx_process+0xc8>
						xnl_send_times++;
800047d8:	6a 08       	ld.w	r8,r5[0x0]
800047da:	2f f8       	sub	r8,-1
800047dc:	8b 08       	st.w	r5[0x0],r8
800047de:	cb eb       	rjmp	8000475a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
800047e0:	48 a8       	lddpc	r8,80004808 <xnl_tx_process+0xc0>
800047e2:	70 0c       	ld.w	r12,r8[0x0]
800047e4:	68 0b       	ld.w	r11,r4[0x0]
800047e6:	f0 1f 00 0a 	mcall	8000480c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
800047ea:	8d 07       	st.w	r6[0x0],r7
800047ec:	cb 7b       	rjmp	8000475a <xnl_tx_process+0x12>
800047ee:	00 00       	add	r0,r0
800047f0:	00 00       	add	r0,r0
800047f2:	0b 58       	ld.sh	r8,--r5
800047f4:	00 00       	add	r0,r0
800047f6:	0b 5c       	ld.sh	r12,--r5
800047f8:	00 00       	add	r0,r0
800047fa:	0b 64       	ld.uh	r4,--r5
800047fc:	00 00       	add	r0,r0
800047fe:	0b 60       	ld.uh	r0,--r5
80004800:	00 00       	add	r0,r0
80004802:	0b 48       	ld.w	r8,--r5
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	62 cc       	ld.w	r12,r1[0x30]
80004808:	00 00       	add	r0,r0
8000480a:	0a a8       	st.w	r5++,r8
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	2f 18       	sub	r8,-15
80004810:	80 00       	ld.sh	r0,r0[0x0]
80004812:	2f 38       	sub	r8,-13

80004814 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004814:	eb cd 40 c0 	pushm	r6-r7,lr
80004818:	20 1d       	sub	sp,4
8000481a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000481c:	98 39       	ld.sh	r9,r12[0x6]
8000481e:	3f f8       	mov	r8,-1
80004820:	f0 09 19 00 	cp.h	r9,r8
80004824:	c0 a1       	brne	80004838 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004826:	4a e9       	lddpc	r9,800048dc <xnl_tx+0xc8>
80004828:	13 88       	ld.ub	r8,r9[0x0]
8000482a:	2f f8       	sub	r8,-1
8000482c:	5c 58       	castu.b	r8
8000482e:	b2 88       	st.b	r9[0x0],r8
80004830:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004834:	a9 a8       	sbr	r8,0x8
80004836:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004838:	8c 49       	ld.sh	r9,r6[0x8]
8000483a:	3f f8       	mov	r8,-1
8000483c:	f0 09 19 00 	cp.h	r9,r8
80004840:	c0 41       	brne	80004848 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004842:	4a 88       	lddpc	r8,800048e0 <xnl_tx+0xcc>
80004844:	90 18       	ld.sh	r8,r8[0x2]
80004846:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004848:	8c 59       	ld.sh	r9,r6[0xa]
8000484a:	3f f8       	mov	r8,-1
8000484c:	f0 09 19 00 	cp.h	r9,r8
80004850:	c0 41       	brne	80004858 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004852:	4a 48       	lddpc	r8,800048e0 <xnl_tx+0xcc>
80004854:	90 28       	ld.sh	r8,r8[0x4]
80004856:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004858:	8c 69       	ld.sh	r9,r6[0xc]
8000485a:	3f f8       	mov	r8,-1
8000485c:	f0 09 19 00 	cp.h	r9,r8
80004860:	c0 e1       	brne	8000487c <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004862:	4a 08       	lddpc	r8,800048e0 <xnl_tx+0xcc>
80004864:	90 49       	ld.sh	r9,r8[0x8]
80004866:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004868:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000486a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000486c:	90 49       	ld.sh	r9,r8[0x8]
8000486e:	e0 19 ff 00 	andl	r9,0xff00
80004872:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
80004876:	f3 e8 10 08 	or	r8,r9,r8
8000487a:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
8000487c:	0d 98       	ld.ub	r8,r6[0x1]
8000487e:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
80004880:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80004884:	10 0c       	add	r12,r8
80004886:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80004888:	58 0c       	cp.w	r12,0
8000488a:	e0 89 00 04 	brgt	80004892 <xnl_tx+0x7e>
8000488e:	30 09       	mov	r9,0
80004890:	c0 d8       	rjmp	800048aa <xnl_tx+0x96>
80004892:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80004896:	2f ec       	sub	r12,-2
80004898:	30 09       	mov	r9,0
8000489a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000489c:	15 1b       	ld.sh	r11,r10++
8000489e:	f6 09 00 09 	add	r9,r11,r9
800048a2:	5c 89       	casts.h	r9
		indextohWord     += 1;
800048a4:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800048a6:	18 38       	cp.w	r8,r12
800048a8:	cf a1       	brne	8000489c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800048aa:	5c 39       	neg	r9
800048ac:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800048ae:	48 e8       	lddpc	r8,800048e4 <xnl_tx+0xd0>
800048b0:	70 0c       	ld.w	r12,r8[0x0]
800048b2:	f0 1f 00 0e 	mcall	800048e8 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800048b6:	c1 00       	breq	800048d6 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800048b8:	fa c7 ff fc 	sub	r7,sp,-4
800048bc:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800048be:	e0 6a 01 00 	mov	r10,256
800048c2:	0c 9b       	mov	r11,r6
800048c4:	f0 1f 00 0a 	mcall	800048ec <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800048c8:	48 a8       	lddpc	r8,800048f0 <xnl_tx+0xdc>
800048ca:	70 0c       	ld.w	r12,r8[0x0]
800048cc:	30 09       	mov	r9,0
800048ce:	12 9a       	mov	r10,r9
800048d0:	1a 9b       	mov	r11,sp
800048d2:	f0 1f 00 09 	mcall	800048f4 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
800048d6:	2f fd       	sub	sp,-4
800048d8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048dc:	00 00       	add	r0,r0
800048de:	0b 4c       	ld.w	r12,--r5
800048e0:	00 00       	add	r0,r0
800048e2:	0b 4e       	ld.w	lr,--r5
800048e4:	00 00       	add	r0,r0
800048e6:	0a a8       	st.w	r5++,r8
800048e8:	80 00       	ld.sh	r0,r0[0x0]
800048ea:	30 c4       	mov	r4,12
800048ec:	80 00       	ld.sh	r0,r0[0x0]
800048ee:	79 8c       	ld.w	r12,r12[0x60]
800048f0:	00 00       	add	r0,r0
800048f2:	0b 5c       	ld.sh	r12,--r5
800048f4:	80 00       	ld.sh	r0,r0[0x0]
800048f6:	64 d8       	ld.w	r8,r2[0x34]

800048f8 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
800048f8:	eb cd 40 80 	pushm	r7,lr
800048fc:	fa cd 01 00 	sub	sp,sp,256
80004900:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004902:	e0 68 40 0e 	mov	r8,16398
80004906:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004908:	3f f8       	mov	r8,-1
8000490a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000490c:	30 c8       	mov	r8,12
8000490e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004910:	98 38       	ld.sh	r8,r12[0x6]
80004912:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004914:	98 58       	ld.sh	r8,r12[0xa]
80004916:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004918:	98 48       	ld.sh	r8,r12[0x8]
8000491a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000491c:	98 68       	ld.sh	r8,r12[0xc]
8000491e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004920:	30 08       	mov	r8,0
80004922:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004924:	1a 9c       	mov	r12,sp
80004926:	f0 1f 00 0a 	mcall	8000494c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000492a:	fa cd 00 cc 	sub	sp,sp,204
8000492e:	e0 6a 00 ca 	mov	r10,202
80004932:	ee cb ff f0 	sub	r11,r7,-16
80004936:	1a 9c       	mov	r12,sp
80004938:	f0 1f 00 06 	mcall	80004950 <xnl_data_msg_func+0x58>
8000493c:	48 68       	lddpc	r8,80004954 <xnl_data_msg_func+0x5c>
8000493e:	70 08       	ld.w	r8,r8[0x0]
80004940:	5d 18       	icall	r8
80004942:	fa cd ff 34 	sub	sp,sp,-204
}
80004946:	2c 0d       	sub	sp,-256
80004948:	e3 cd 80 80 	ldm	sp++,r7,pc
8000494c:	80 00       	ld.sh	r0,r0[0x0]
8000494e:	48 14       	lddpc	r4,80004950 <xnl_data_msg_func+0x58>
80004950:	80 00       	ld.sh	r0,r0[0x0]
80004952:	79 8c       	ld.w	r12,r12[0x60]
80004954:	00 00       	add	r0,r0
80004956:	0b 68       	ld.uh	r8,--r5

80004958 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004958:	d4 21       	pushm	r4-r7,lr
8000495a:	fa cd 01 00 	sub	sp,sp,256
8000495e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004960:	4c 28       	lddpc	r8,80004a68 <xnl_device_auth_reply_func+0x110>
80004962:	11 88       	ld.ub	r8,r8[0x0]
80004964:	58 08       	cp.w	r8,0
80004966:	e0 81 00 7f 	brne	80004a64 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000496a:	4c 18       	lddpc	r8,80004a6c <xnl_device_auth_reply_func+0x114>
8000496c:	70 0c       	ld.w	r12,r8[0x0]
8000496e:	30 09       	mov	r9,0
80004970:	12 9a       	mov	r10,r9
80004972:	12 9b       	mov	r11,r9
80004974:	f0 1f 00 3f 	mcall	80004a70 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
80004978:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
8000497c:	4b b8       	lddpc	r8,80004a68 <xnl_device_auth_reply_func+0x110>
8000497e:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
80004980:	ef 39 00 12 	ld.ub	r9,r7[18]
80004984:	ef 38 00 13 	ld.ub	r8,r7[19]
80004988:	b1 68       	lsl	r8,0x10
8000498a:	f1 e9 11 89 	or	r9,r8,r9<<0x18
8000498e:	ef 38 00 15 	ld.ub	r8,r7[21]
80004992:	f3 e8 10 08 	or	r8,r9,r8
80004996:	ef 39 00 14 	ld.ub	r9,r7[20]
8000499a:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
8000499e:	ef 3a 00 16 	ld.ub	r10,r7[22]
800049a2:	ef 38 00 17 	ld.ub	r8,r7[23]
800049a6:	b1 68       	lsl	r8,0x10
800049a8:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800049ac:	ef 38 00 19 	ld.ub	r8,r7[25]
800049b0:	f5 e8 10 08 	or	r8,r10,r8
800049b4:	ef 3a 00 18 	ld.ub	r10,r7[24]
800049b8:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800049bc:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800049be:	e0 64 79 b9 	mov	r4,31161
800049c2:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800049c6:	e0 65 45 07 	mov	r5,17671
800049ca:	ea 15 8a bd 	orh	r5,0x8abd
800049ce:	e0 66 f9 3d 	mov	r6,63805
800049d2:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
800049d6:	e0 6e b8 cf 	mov	lr,47311
800049da:	ea 1e 36 83 	orh	lr,0x3683
800049de:	e0 67 aa 1c 	mov	r7,43548
800049e2:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800049e6:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800049e8:	f4 08 00 0c 	add	r12,r10,r8
800049ec:	f0 0b 15 04 	lsl	r11,r8,0x4
800049f0:	0a 0b       	add	r11,r5
800049f2:	f9 eb 20 0b 	eor	r11,r12,r11
800049f6:	f0 0c 16 05 	lsr	r12,r8,0x5
800049fa:	0c 0c       	add	r12,r6
800049fc:	18 5b       	eor	r11,r12
800049fe:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004a00:	f2 0c 15 04 	lsl	r12,r9,0x4
80004a04:	1c 0c       	add	r12,lr
80004a06:	f2 0b 16 05 	lsr	r11,r9,0x5
80004a0a:	0e 0b       	add	r11,r7
80004a0c:	f9 eb 20 0b 	eor	r11,r12,r11
80004a10:	f2 0a 00 0c 	add	r12,r9,r10
80004a14:	18 5b       	eor	r11,r12
80004a16:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004a18:	e0 6b 37 20 	mov	r11,14112
80004a1c:	ea 1b c6 ef 	orh	r11,0xc6ef
80004a20:	16 3a       	cp.w	r10,r11
80004a22:	ce 21       	brne	800049e6 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004a24:	e0 6a 40 1a 	mov	r10,16410
80004a28:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004a2a:	3f fa       	mov	r10,-1
80004a2c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
80004a2e:	30 6b       	mov	r11,6
80004a30:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004a32:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004a34:	48 db       	lddpc	r11,80004a68 <xnl_device_auth_reply_func+0x110>
80004a36:	96 1c       	ld.sh	r12,r11[0x2]
80004a38:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
80004a3a:	96 2b       	ld.sh	r11,r11[0x4]
80004a3c:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004a3e:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004a40:	30 ca       	mov	r10,12
80004a42:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004a44:	30 0a       	mov	r10,0
80004a46:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
80004a4a:	30 7a       	mov	r10,7
80004a4c:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004a50:	30 2a       	mov	r10,2
80004a52:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004a56:	fa ca ff ec 	sub	r10,sp,-20
80004a5a:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004a5c:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004a5e:	1a 9c       	mov	r12,sp
80004a60:	f0 1f 00 05 	mcall	80004a74 <xnl_device_auth_reply_func+0x11c>
}
80004a64:	2c 0d       	sub	sp,-256
80004a66:	d8 22       	popm	r4-r7,pc
80004a68:	00 00       	add	r0,r0
80004a6a:	0b 4e       	ld.w	lr,--r5
80004a6c:	00 00       	add	r0,r0
80004a6e:	0b 48       	ld.w	r8,--r5
80004a70:	80 00       	ld.sh	r0,r0[0x0]
80004a72:	64 d8       	ld.w	r8,r2[0x34]
80004a74:	80 00       	ld.sh	r0,r0[0x0]
80004a76:	48 14       	lddpc	r4,80004a78 <xnl_master_status_brdcst_func>

80004a78 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
80004a78:	eb cd 40 80 	pushm	r7,lr
80004a7c:	fa cd 01 00 	sub	sp,sp,256
80004a80:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
80004a82:	49 28       	lddpc	r8,80004ac8 <xnl_master_status_brdcst_func+0x50>
80004a84:	11 88       	ld.ub	r8,r8[0x0]
80004a86:	58 08       	cp.w	r8,0
80004a88:	c1 c1       	brne	80004ac0 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
80004a8a:	49 18       	lddpc	r8,80004acc <xnl_master_status_brdcst_func+0x54>
80004a8c:	70 0c       	ld.w	r12,r8[0x0]
80004a8e:	30 09       	mov	r9,0
80004a90:	12 9a       	mov	r10,r9
80004a92:	12 9b       	mov	r11,r9
80004a94:	f0 1f 00 0f 	mcall	80004ad0 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
80004a98:	8e 58       	ld.sh	r8,r7[0xa]
80004a9a:	48 c9       	lddpc	r9,80004ac8 <xnl_master_status_brdcst_func+0x50>
80004a9c:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004a9e:	e0 68 40 0e 	mov	r8,16398
80004aa2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004aa4:	3f f8       	mov	r8,-1
80004aa6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
80004aa8:	30 4a       	mov	r10,4
80004aaa:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004aac:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004aae:	92 19       	ld.sh	r9,r9[0x2]
80004ab0:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
80004ab2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80004ab4:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
80004ab6:	30 08       	mov	r8,0
80004ab8:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
80004aba:	1a 9c       	mov	r12,sp
80004abc:	f0 1f 00 06 	mcall	80004ad4 <xnl_master_status_brdcst_func+0x5c>
}
80004ac0:	2c 0d       	sub	sp,-256
80004ac2:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ac6:	00 00       	add	r0,r0
80004ac8:	00 00       	add	r0,r0
80004aca:	0b 4e       	ld.w	lr,--r5
80004acc:	00 00       	add	r0,r0
80004ace:	0b 48       	ld.w	r8,--r5
80004ad0:	80 00       	ld.sh	r0,r0[0x0]
80004ad2:	64 d8       	ld.w	r8,r2[0x34]
80004ad4:	80 00       	ld.sh	r0,r0[0x0]
80004ad6:	48 14       	lddpc	r4,80004ad8 <xnl_device_conn_reply_func>

80004ad8 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004ad8:	eb cd 40 80 	pushm	r7,lr
80004adc:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
80004ade:	49 28       	lddpc	r8,80004b24 <xnl_device_conn_reply_func+0x4c>
80004ae0:	70 0c       	ld.w	r12,r8[0x0]
80004ae2:	30 09       	mov	r9,0
80004ae4:	12 9a       	mov	r10,r9
80004ae6:	12 9b       	mov	r11,r9
80004ae8:	f0 1f 00 10 	mcall	80004b28 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
80004aec:	ef 18 00 10 	ld.uh	r8,r7[16]
80004af0:	10 99       	mov	r9,r8
80004af2:	e2 19 ff 00 	andl	r9,0xff00,COH
80004af6:	e0 49 01 00 	cp.w	r9,256
80004afa:	c0 60       	breq	80004b06 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
80004afc:	0e 9c       	mov	r12,r7
80004afe:	f0 1f 00 0c 	mcall	80004b2c <xnl_device_conn_reply_func+0x54>
80004b02:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004b06:	a9 68       	lsl	r8,0x8
80004b08:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80004b0c:	48 98       	lddpc	r8,80004b30 <xnl_device_conn_reply_func+0x58>
80004b0e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004b10:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004b14:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004b16:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
80004b1a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
80004b1c:	30 19       	mov	r9,1
80004b1e:	b0 89       	st.b	r8[0x0],r9
80004b20:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b24:	00 00       	add	r0,r0
80004b26:	0b 48       	ld.w	r8,--r5
80004b28:	80 00       	ld.sh	r0,r0[0x0]
80004b2a:	64 d8       	ld.w	r8,r2[0x34]
80004b2c:	80 00       	ld.sh	r0,r0[0x0]
80004b2e:	4a 78       	lddpc	r8,80004bc8 <RC522_WriteByte+0x20>
80004b30:	00 00       	add	r0,r0
80004b32:	0b 4e       	ld.w	lr,--r5

80004b34 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004b34:	d4 01       	pushm	lr
80004b36:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004b3a:	e0 68 40 0e 	mov	r8,16398
80004b3e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004b40:	3f f8       	mov	r8,-1
80004b42:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004b44:	30 38       	mov	r8,3
80004b46:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004b48:	30 08       	mov	r8,0
80004b4a:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
80004b4c:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
80004b4e:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004b50:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004b52:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004b54:	1a 9c       	mov	r12,sp
80004b56:	f0 1f 00 03 	mcall	80004b60 <xnl_send_device_master_query+0x2c>
}
80004b5a:	2c 0d       	sub	sp,-256
80004b5c:	d8 02       	popm	pc
80004b5e:	00 00       	add	r0,r0
80004b60:	80 00       	ld.sh	r0,r0[0x0]
80004b62:	48 14       	lddpc	r4,80004b64 <RC522_ReadByte>

80004b64 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
80004b64:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
80004b68:	48 b7       	lddpc	r7,80004b94 <RC522_ReadByte+0x30>
80004b6a:	30 0b       	mov	r11,0
80004b6c:	6e 0c       	ld.w	r12,r7[0x0]
80004b6e:	f0 1f 00 0b 	mcall	80004b98 <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
80004b72:	e0 6b 00 ff 	mov	r11,255
80004b76:	6e 0c       	ld.w	r12,r7[0x0]
80004b78:	f0 1f 00 09 	mcall	80004b9c <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
80004b7c:	30 06       	mov	r6,0
80004b7e:	0c 9b       	mov	r11,r6
80004b80:	6e 0c       	ld.w	r12,r7[0x0]
80004b82:	f0 1f 00 08 	mcall	80004ba0 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004b86:	0c 9b       	mov	r11,r6
80004b88:	6e 0c       	ld.w	r12,r7[0x0]
80004b8a:	f0 1f 00 07 	mcall	80004ba4 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
80004b8e:	0d 9c       	ld.ub	r12,r6[0x1]
80004b90:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004b94:	00 00       	add	r0,r0
80004b96:	20 24       	sub	r4,2
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	5b 34       	cp.w	r4,-13
80004b9c:	80 00       	ld.sh	r0,r0[0x0]
80004b9e:	59 ce       	cp.w	lr,28
80004ba0:	80 00       	ld.sh	r0,r0[0x0]
80004ba2:	59 ea       	cp.w	r10,30
80004ba4:	80 00       	ld.sh	r0,r0[0x0]
80004ba6:	5a f4       	cp.w	r4,-17

80004ba8 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
80004ba8:	eb cd 40 c0 	pushm	r6-r7,lr
80004bac:	20 1d       	sub	sp,4
80004bae:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004bb0:	48 c7       	lddpc	r7,80004be0 <RC522_WriteByte+0x38>
80004bb2:	30 0b       	mov	r11,0
80004bb4:	6e 0c       	ld.w	r12,r7[0x0]
80004bb6:	f0 1f 00 0c 	mcall	80004be4 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
80004bba:	1b 8b       	ld.ub	r11,sp[0x0]
80004bbc:	6e 0c       	ld.w	r12,r7[0x0]
80004bbe:	f0 1f 00 0b 	mcall	80004be8 <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004bc2:	1a 9b       	mov	r11,sp
80004bc4:	6e 0c       	ld.w	r12,r7[0x0]
80004bc6:	f0 1f 00 0a 	mcall	80004bec <RC522_WriteByte+0x44>
80004bca:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004bcc:	30 0b       	mov	r11,0
80004bce:	6e 0c       	ld.w	r12,r7[0x0]
80004bd0:	f0 1f 00 08 	mcall	80004bf0 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004bd4:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80004bd8:	2f fd       	sub	sp,-4
80004bda:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004bde:	00 00       	add	r0,r0
80004be0:	00 00       	add	r0,r0
80004be2:	20 24       	sub	r4,2
80004be4:	80 00       	ld.sh	r0,r0[0x0]
80004be6:	5b 34       	cp.w	r4,-13
80004be8:	80 00       	ld.sh	r0,r0[0x0]
80004bea:	59 ce       	cp.w	lr,28
80004bec:	80 00       	ld.sh	r0,r0[0x0]
80004bee:	59 ea       	cp.w	r10,30
80004bf0:	80 00       	ld.sh	r0,r0[0x0]
80004bf2:	5a f4       	cp.w	r4,-17

80004bf4 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004bf4:	eb cd 40 c0 	pushm	r6-r7,lr
80004bf8:	18 96       	mov	r6,r12
80004bfa:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
80004bfc:	31 8c       	mov	r12,24
80004bfe:	f0 1f 00 09 	mcall	80004c20 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004c02:	ec 0c 15 01 	lsl	r12,r6,0x1
80004c06:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004c0a:	f0 1f 00 07 	mcall	80004c24 <WriteRawRC+0x30>
	RC522_WriteByte(value);
80004c0e:	0e 9c       	mov	r12,r7
80004c10:	f0 1f 00 05 	mcall	80004c24 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80004c14:	31 8c       	mov	r12,24
80004c16:	f0 1f 00 05 	mcall	80004c28 <WriteRawRC+0x34>

}
80004c1a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c1e:	00 00       	add	r0,r0
80004c20:	80 00       	ld.sh	r0,r0[0x0]
80004c22:	55 58       	stdsp	sp[0x154],r8
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	4b a8       	lddpc	r8,80004d0c <SetBitMask+0x20>
80004c28:	80 00       	ld.sh	r0,r0[0x0]
80004c2a:	55 3c       	stdsp	sp[0x14c],r12

80004c2c <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004c2c:	d4 01       	pushm	lr

	SET_RC522RST;
80004c2e:	31 9c       	mov	r12,25
80004c30:	f0 1f 00 1b 	mcall	80004c9c <PcdReset+0x70>
	delay_ns(10);
80004c34:	30 ac       	mov	r12,10
80004c36:	f0 1f 00 1b 	mcall	80004ca0 <PcdReset+0x74>

	CLR_RC522RST;
80004c3a:	31 9c       	mov	r12,25
80004c3c:	f0 1f 00 1a 	mcall	80004ca4 <PcdReset+0x78>
	delay_ns(10);
80004c40:	30 ac       	mov	r12,10
80004c42:	f0 1f 00 18 	mcall	80004ca0 <PcdReset+0x74>

	SET_RC522RST;
80004c46:	31 9c       	mov	r12,25
80004c48:	f0 1f 00 15 	mcall	80004c9c <PcdReset+0x70>
	delay_ns(10);
80004c4c:	30 ac       	mov	r12,10
80004c4e:	f0 1f 00 15 	mcall	80004ca0 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004c52:	30 fb       	mov	r11,15
80004c54:	30 1c       	mov	r12,1
80004c56:	f0 1f 00 15 	mcall	80004ca8 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80004c5a:	30 fb       	mov	r11,15
80004c5c:	30 1c       	mov	r12,1
80004c5e:	f0 1f 00 13 	mcall	80004ca8 <PcdReset+0x7c>
	delay_ns(10);
80004c62:	30 ac       	mov	r12,10
80004c64:	f0 1f 00 0f 	mcall	80004ca0 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80004c68:	33 db       	mov	r11,61
80004c6a:	31 1c       	mov	r12,17
80004c6c:	f0 1f 00 0f 	mcall	80004ca8 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
80004c70:	31 eb       	mov	r11,30
80004c72:	32 dc       	mov	r12,45
80004c74:	f0 1f 00 0d 	mcall	80004ca8 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80004c78:	30 0b       	mov	r11,0
80004c7a:	32 cc       	mov	r12,44
80004c7c:	f0 1f 00 0b 	mcall	80004ca8 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
80004c80:	e0 6b 00 8d 	mov	r11,141
80004c84:	32 ac       	mov	r12,42
80004c86:	f0 1f 00 09 	mcall	80004ca8 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80004c8a:	33 eb       	mov	r11,62
80004c8c:	32 bc       	mov	r12,43
80004c8e:	f0 1f 00 07 	mcall	80004ca8 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
80004c92:	34 0b       	mov	r11,64
80004c94:	31 5c       	mov	r12,21
80004c96:	f0 1f 00 05 	mcall	80004ca8 <PcdReset+0x7c>
	
	return MI_OK;
}
80004c9a:	d8 0a       	popm	pc,r12=0
80004c9c:	80 00       	ld.sh	r0,r0[0x0]
80004c9e:	55 3c       	stdsp	sp[0x14c],r12
80004ca0:	80 00       	ld.sh	r0,r0[0x0]
80004ca2:	53 1c       	stdsp	sp[0xc4],r12
80004ca4:	80 00       	ld.sh	r0,r0[0x0]
80004ca6:	55 58       	stdsp	sp[0x154],r8
80004ca8:	80 00       	ld.sh	r0,r0[0x0]
80004caa:	4b f4       	lddpc	r4,80004da4 <PcdComMF522+0x6c>

80004cac <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004cac:	eb cd 40 80 	pushm	r7,lr
80004cb0:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
80004cb2:	31 8c       	mov	r12,24
80004cb4:	f0 1f 00 0a 	mcall	80004cdc <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
80004cb8:	ee 08 15 01 	lsl	r8,r7,0x1
80004cbc:	10 9c       	mov	r12,r8
80004cbe:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004cc2:	a7 bc       	sbr	r12,0x7
80004cc4:	f0 1f 00 07 	mcall	80004ce0 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
80004cc8:	f0 1f 00 07 	mcall	80004ce4 <ReadRawRC+0x38>
80004ccc:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
80004cce:	31 8c       	mov	r12,24
80004cd0:	f0 1f 00 06 	mcall	80004ce8 <ReadRawRC+0x3c>
	return ucResult;
}
80004cd4:	0e 9c       	mov	r12,r7
80004cd6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004cda:	00 00       	add	r0,r0
80004cdc:	80 00       	ld.sh	r0,r0[0x0]
80004cde:	55 58       	stdsp	sp[0x154],r8
80004ce0:	80 00       	ld.sh	r0,r0[0x0]
80004ce2:	4b a8       	lddpc	r8,80004dc8 <PcdComMF522+0x90>
80004ce4:	80 00       	ld.sh	r0,r0[0x0]
80004ce6:	4b 64       	lddpc	r4,80004dbc <PcdComMF522+0x84>
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	55 3c       	stdsp	sp[0x14c],r12

80004cec <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004cec:	eb cd 40 c0 	pushm	r6-r7,lr
80004cf0:	18 97       	mov	r7,r12
80004cf2:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004cf4:	f0 1f 00 05 	mcall	80004d08 <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
80004cf8:	f9 e6 10 0b 	or	r11,r12,r6
80004cfc:	5c 5b       	castu.b	r11
80004cfe:	0e 9c       	mov	r12,r7
80004d00:	f0 1f 00 03 	mcall	80004d0c <SetBitMask+0x20>
}
80004d04:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	4c ac       	lddpc	r12,80004e30 <PcdComMF522+0xf8>
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	4b f4       	lddpc	r4,80004e08 <PcdComMF522+0xd0>

80004d10 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004d10:	eb cd 40 c0 	pushm	r6-r7,lr
80004d14:	18 97       	mov	r7,r12
80004d16:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
80004d18:	f0 1f 00 06 	mcall	80004d30 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80004d1c:	5c d6       	com	r6
80004d1e:	f9 e6 00 06 	and	r6,r12,r6
80004d22:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
80004d26:	0e 9c       	mov	r12,r7
80004d28:	f0 1f 00 03 	mcall	80004d34 <ClearBitMask+0x24>
	
}
80004d2c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004d30:	80 00       	ld.sh	r0,r0[0x0]
80004d32:	4c ac       	lddpc	r12,80004e58 <PcdComMF522+0x120>
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	4b f4       	lddpc	r4,80004e30 <PcdComMF522+0xf8>

80004d38 <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004d38:	d4 31       	pushm	r0-r7,lr
80004d3a:	20 1d       	sub	sp,4
80004d3c:	18 92       	mov	r2,r12
80004d3e:	16 95       	mov	r5,r11
80004d40:	14 96       	mov	r6,r10
80004d42:	50 09       	stdsp	sp[0x0],r9
80004d44:	10 90       	mov	r0,r8
80004d46:	f8 c8 00 0c 	sub	r8,r12,12
80004d4a:	5c 58       	castu.b	r8
80004d4c:	30 29       	mov	r9,2
80004d4e:	f2 08 18 00 	cp.b	r8,r9
80004d52:	e0 88 00 05 	brls	80004d5c <PcdComMF522+0x24>
80004d56:	30 03       	mov	r3,0
80004d58:	06 91       	mov	r1,r3
80004d5a:	c0 78       	rjmp	80004d68 <PcdComMF522+0x30>
80004d5c:	4c f9       	lddpc	r9,80004e98 <PcdComMF522+0x160>
80004d5e:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004d62:	4c f9       	lddpc	r9,80004e9c <PcdComMF522+0x164>
80004d64:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004d68:	02 9b       	mov	r11,r1
80004d6a:	a7 bb       	sbr	r11,0x7
80004d6c:	30 2c       	mov	r12,2
80004d6e:	f0 1f 00 4d 	mcall	80004ea0 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004d72:	e0 6b 00 80 	mov	r11,128
80004d76:	30 4c       	mov	r12,4
80004d78:	f0 1f 00 4b 	mcall	80004ea4 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004d7c:	30 0b       	mov	r11,0
80004d7e:	30 1c       	mov	r12,1
80004d80:	f0 1f 00 48 	mcall	80004ea0 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004d84:	e0 6b 00 80 	mov	r11,128
80004d88:	30 ac       	mov	r12,10
80004d8a:	f0 1f 00 48 	mcall	80004ea8 <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004d8e:	58 06       	cp.w	r6,0
80004d90:	c0 c0       	breq	80004da8 <PcdComMF522+0x70>
80004d92:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004d94:	30 94       	mov	r4,9
80004d96:	0f 3b       	ld.ub	r11,r7++
80004d98:	08 9c       	mov	r12,r4
80004d9a:	f0 1f 00 42 	mcall	80004ea0 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004d9e:	0e 98       	mov	r8,r7
80004da0:	0a 18       	sub	r8,r5
80004da2:	ec 08 19 00 	cp.h	r8,r6
80004da6:	cf 83       	brcs	80004d96 <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004da8:	04 9b       	mov	r11,r2
80004daa:	30 1c       	mov	r12,1
80004dac:	f0 1f 00 3d 	mcall	80004ea0 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004db0:	30 c8       	mov	r8,12
80004db2:	f0 02 18 00 	cp.b	r2,r8
80004db6:	c0 61       	brne	80004dc2 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004db8:	e0 6b 00 80 	mov	r11,128
80004dbc:	30 dc       	mov	r12,13
80004dbe:	f0 1f 00 3b 	mcall	80004ea8 <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004dc2:	30 4c       	mov	r12,4
80004dc4:	f0 1f 00 3a 	mcall	80004eac <PcdComMF522+0x174>
80004dc8:	18 97       	mov	r7,r12
80004dca:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004dce:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004dd0:	30 44       	mov	r4,4
80004dd2:	c0 88       	rjmp	80004de2 <PcdComMF522+0xaa>
80004dd4:	08 9c       	mov	r12,r4
80004dd6:	f0 1f 00 36 	mcall	80004eac <PcdComMF522+0x174>
80004dda:	18 97       	mov	r7,r12
		i--;
80004ddc:	20 16       	sub	r6,1
80004dde:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004de0:	c0 a0       	breq	80004df4 <PcdComMF522+0xbc>
80004de2:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004de6:	c4 c1       	brne	80004e7e <PcdComMF522+0x146>
80004de8:	ef e3 00 08 	and	r8,r7,r3
80004dec:	ea 08 18 00 	cp.b	r8,r5
80004df0:	cf 20       	breq	80004dd4 <PcdComMF522+0x9c>
80004df2:	c4 68       	rjmp	80004e7e <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004df4:	e0 6b 00 80 	mov	r11,128
80004df8:	30 dc       	mov	r12,13
80004dfa:	f0 1f 00 2b 	mcall	80004ea4 <PcdComMF522+0x16c>
80004dfe:	30 27       	mov	r7,2
80004e00:	c3 38       	rjmp	80004e66 <PcdComMF522+0x12e>
80004e02:	02 67       	and	r7,r1
80004e04:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004e08:	30 c8       	mov	r8,12
80004e0a:	f0 02 18 00 	cp.b	r2,r8
80004e0e:	c2 c1       	brne	80004e66 <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004e10:	30 ac       	mov	r12,10
80004e12:	f0 1f 00 27 	mcall	80004eac <PcdComMF522+0x174>
80004e16:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004e18:	30 cc       	mov	r12,12
80004e1a:	f0 1f 00 25 	mcall	80004eac <PcdComMF522+0x174>
80004e1e:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004e22:	c0 70       	breq	80004e30 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004e24:	08 98       	mov	r8,r4
80004e26:	20 18       	sub	r8,1
80004e28:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004e2c:	a0 8c       	st.b	r0[0x0],r12
80004e2e:	c0 48       	rjmp	80004e36 <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004e30:	e8 08 15 03 	lsl	r8,r4,0x3
80004e34:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004e36:	58 04       	cp.w	r4,0
80004e38:	c0 61       	brne	80004e44 <PcdComMF522+0x10c>
80004e3a:	30 14       	mov	r4,1
80004e3c:	40 05       	lddsp	r5,sp[0x0]
80004e3e:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004e40:	30 93       	mov	r3,9
80004e42:	c0 98       	rjmp	80004e54 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004e44:	31 28       	mov	r8,18
80004e46:	f0 04 18 00 	cp.b	r4,r8
80004e4a:	f9 b4 0b 12 	movhi	r4,18
80004e4e:	58 04       	cp.w	r4,0
80004e50:	cf 61       	brne	80004e3c <PcdComMF522+0x104>
80004e52:	c0 a8       	rjmp	80004e66 <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004e54:	06 9c       	mov	r12,r3
80004e56:	f0 1f 00 16 	mcall	80004eac <PcdComMF522+0x174>
80004e5a:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004e5c:	ec 05 01 08 	sub	r8,r6,r5
80004e60:	e8 08 19 00 	cp.h	r8,r4
80004e64:	cf 83       	brcs	80004e54 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004e66:	e0 6b 00 80 	mov	r11,128
80004e6a:	30 cc       	mov	r12,12
80004e6c:	f0 1f 00 0f 	mcall	80004ea8 <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004e70:	30 0b       	mov	r11,0
80004e72:	30 1c       	mov	r12,1
80004e74:	f0 1f 00 0b 	mcall	80004ea0 <PcdComMF522+0x168>
	return status;
}
80004e78:	0e 9c       	mov	r12,r7
80004e7a:	2f fd       	sub	sp,-4
80004e7c:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004e7e:	e0 6b 00 80 	mov	r11,128
80004e82:	30 dc       	mov	r12,13
80004e84:	f0 1f 00 08 	mcall	80004ea4 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004e88:	30 6c       	mov	r12,6
80004e8a:	f0 1f 00 09 	mcall	80004eac <PcdComMF522+0x174>
80004e8e:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004e92:	cb 80       	breq	80004e02 <PcdComMF522+0xca>
80004e94:	30 27       	mov	r7,2
80004e96:	ce 8b       	rjmp	80004e66 <PcdComMF522+0x12e>
80004e98:	80 00       	ld.sh	r0,r0[0x0]
80004e9a:	da 34       	*unknown*
80004e9c:	80 00       	ld.sh	r0,r0[0x0]
80004e9e:	da 38       	*unknown*
80004ea0:	80 00       	ld.sh	r0,r0[0x0]
80004ea2:	4b f4       	lddpc	r4,80004f9c <CalulateCRC+0x4>
80004ea4:	80 00       	ld.sh	r0,r0[0x0]
80004ea6:	4d 10       	lddpc	r0,80004fe8 <CalulateCRC+0x50>
80004ea8:	80 00       	ld.sh	r0,r0[0x0]
80004eaa:	4c ec       	lddpc	r12,80004fe0 <CalulateCRC+0x48>
80004eac:	80 00       	ld.sh	r0,r0[0x0]
80004eae:	4c ac       	lddpc	r12,80004fd4 <CalulateCRC+0x3c>

80004eb0 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004eb0:	eb cd 40 c0 	pushm	r6-r7,lr
80004eb4:	20 5d       	sub	sp,20
80004eb6:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004eb8:	30 8b       	mov	r11,8
80004eba:	16 9c       	mov	r12,r11
80004ebc:	f0 1f 00 1a 	mcall	80004f24 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004ec0:	30 0b       	mov	r11,0
80004ec2:	30 dc       	mov	r12,13
80004ec4:	f0 1f 00 19 	mcall	80004f28 <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004ec8:	e0 6b 00 80 	mov	r11,128
80004ecc:	30 ec       	mov	r12,14
80004ece:	f0 1f 00 16 	mcall	80004f24 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004ed2:	39 38       	mov	r8,-109
80004ed4:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004ed6:	32 08       	mov	r8,32
80004ed8:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004eda:	1a 9b       	mov	r11,sp
80004edc:	fa c8 ff ed 	sub	r8,sp,-19
80004ee0:	1a 99       	mov	r9,sp
80004ee2:	30 2a       	mov	r10,2
80004ee4:	30 cc       	mov	r12,12
80004ee6:	f0 1f 00 12 	mcall	80004f2c <PcdAnticoll+0x7c>
80004eea:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004eec:	c1 21       	brne	80004f10 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004eee:	1b 89       	ld.ub	r9,sp[0x0]
80004ef0:	ac 89       	st.b	r6[0x0],r9
80004ef2:	1b 98       	ld.ub	r8,sp[0x1]
80004ef4:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004ef6:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004ef8:	1b a8       	ld.ub	r8,sp[0x2]
80004efa:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004efc:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004f00:	1b b9       	ld.ub	r9,sp[0x3]
80004f02:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004f04:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004f06:	1b c9       	ld.ub	r9,sp[0x4]
80004f08:	f0 09 18 00 	cp.b	r9,r8
80004f0c:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004f10:	e0 6b 00 80 	mov	r11,128
80004f14:	30 ec       	mov	r12,14
80004f16:	f0 1f 00 07 	mcall	80004f30 <PcdAnticoll+0x80>
	return status;
}
80004f1a:	0e 9c       	mov	r12,r7
80004f1c:	2f bd       	sub	sp,-20
80004f1e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f22:	00 00       	add	r0,r0
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	4d 10       	lddpc	r0,80005068 <PcdSelect+0x44>
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	4b f4       	lddpc	r4,80005024 <PcdSelect>
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	4d 38       	lddpc	r8,80005078 <PcdSelect+0x54>
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	4c ec       	lddpc	r12,80005068 <PcdSelect+0x44>

80004f34 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004f34:	eb cd 40 c0 	pushm	r6-r7,lr
80004f38:	20 5d       	sub	sp,20
80004f3a:	18 97       	mov	r7,r12
80004f3c:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004f3e:	30 8b       	mov	r11,8
80004f40:	16 9c       	mov	r12,r11
80004f42:	f0 1f 00 12 	mcall	80004f88 <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004f46:	30 7b       	mov	r11,7
80004f48:	30 dc       	mov	r12,13
80004f4a:	f0 1f 00 11 	mcall	80004f8c <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004f4e:	30 3b       	mov	r11,3
80004f50:	31 4c       	mov	r12,20
80004f52:	f0 1f 00 10 	mcall	80004f90 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004f56:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004f58:	1a 9b       	mov	r11,sp
80004f5a:	fa c8 ff ed 	sub	r8,sp,-19
80004f5e:	1a 99       	mov	r9,sp
80004f60:	30 1a       	mov	r10,1
80004f62:	30 cc       	mov	r12,12
80004f64:	f0 1f 00 0c 	mcall	80004f94 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004f68:	c0 c1       	brne	80004f80 <PcdRequest+0x4c>
80004f6a:	31 08       	mov	r8,16
80004f6c:	fb 39 00 13 	ld.ub	r9,sp[19]
80004f70:	f0 09 18 00 	cp.b	r9,r8
80004f74:	c0 61       	brne	80004f80 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004f76:	1b 88       	ld.ub	r8,sp[0x0]
80004f78:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004f7a:	1b 98       	ld.ub	r8,sp[0x1]
80004f7c:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004f7e:	c0 28       	rjmp	80004f82 <PcdRequest+0x4e>
80004f80:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004f82:	2f bd       	sub	sp,-20
80004f84:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f88:	80 00       	ld.sh	r0,r0[0x0]
80004f8a:	4d 10       	lddpc	r0,800050cc <rfid_auto_reader+0x34>
80004f8c:	80 00       	ld.sh	r0,r0[0x0]
80004f8e:	4b f4       	lddpc	r4,80005088 <PcdSelect+0x64>
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	4c ec       	lddpc	r12,800050c8 <rfid_auto_reader+0x30>
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	4d 38       	lddpc	r8,800050e0 <rfid_auto_reader+0x48>

80004f98 <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004f98:	eb cd 40 f8 	pushm	r3-r7,lr
80004f9c:	18 95       	mov	r5,r12
80004f9e:	16 96       	mov	r6,r11
80004fa0:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004fa2:	30 4b       	mov	r11,4
80004fa4:	30 5c       	mov	r12,5
80004fa6:	f0 1f 00 1c 	mcall	80005014 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004faa:	30 0b       	mov	r11,0
80004fac:	30 1c       	mov	r12,1
80004fae:	f0 1f 00 1b 	mcall	80005018 <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004fb2:	e0 6b 00 80 	mov	r11,128
80004fb6:	30 ac       	mov	r12,10
80004fb8:	f0 1f 00 19 	mcall	8000501c <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004fbc:	58 06       	cp.w	r6,0
80004fbe:	c0 c0       	breq	80004fd6 <CalulateCRC+0x3e>
80004fc0:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004fc2:	30 94       	mov	r4,9
80004fc4:	0f 3b       	ld.ub	r11,r7++
80004fc6:	08 9c       	mov	r12,r4
80004fc8:	f0 1f 00 14 	mcall	80005018 <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004fcc:	0e 98       	mov	r8,r7
80004fce:	0a 18       	sub	r8,r5
80004fd0:	ec 08 18 00 	cp.b	r8,r6
80004fd4:	cf 83       	brcs	80004fc4 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004fd6:	30 3b       	mov	r11,3
80004fd8:	30 1c       	mov	r12,1
80004fda:	f0 1f 00 10 	mcall	80005018 <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004fde:	30 5c       	mov	r12,5
80004fe0:	f0 1f 00 10 	mcall	80005020 <CalulateCRC+0x88>
80004fe4:	e0 67 00 fe 	mov	r7,254
80004fe8:	30 56       	mov	r6,5
80004fea:	c0 78       	rjmp	80004ff8 <CalulateCRC+0x60>
80004fec:	0c 9c       	mov	r12,r6
80004fee:	f0 1f 00 0d 	mcall	80005020 <CalulateCRC+0x88>
		i--;
80004ff2:	20 17       	sub	r7,1
80004ff4:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004ff6:	c0 40       	breq	80004ffe <CalulateCRC+0x66>
80004ff8:	e2 1c 00 04 	andl	r12,0x4,COH
80004ffc:	cf 80       	breq	80004fec <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004ffe:	32 2c       	mov	r12,34
80005000:	f0 1f 00 08 	mcall	80005020 <CalulateCRC+0x88>
80005004:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80005006:	32 1c       	mov	r12,33
80005008:	f0 1f 00 06 	mcall	80005020 <CalulateCRC+0x88>
8000500c:	a6 9c       	st.b	r3[0x1],r12
}
8000500e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005012:	00 00       	add	r0,r0
80005014:	80 00       	ld.sh	r0,r0[0x0]
80005016:	4d 10       	lddpc	r0,80005158 <rfid_auto_reader+0xc0>
80005018:	80 00       	ld.sh	r0,r0[0x0]
8000501a:	4b f4       	lddpc	r4,80005114 <rfid_auto_reader+0x7c>
8000501c:	80 00       	ld.sh	r0,r0[0x0]
8000501e:	4c ec       	lddpc	r12,80005154 <rfid_auto_reader+0xbc>
80005020:	80 00       	ld.sh	r0,r0[0x0]
80005022:	4c ac       	lddpc	r12,80005148 <rfid_auto_reader+0xb0>

80005024 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80005024:	eb cd 40 80 	pushm	r7,lr
80005028:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
8000502a:	39 38       	mov	r8,-109
8000502c:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
8000502e:	37 08       	mov	r8,112
80005030:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80005032:	30 08       	mov	r8,0
80005034:	ba e8       	st.b	sp[0x6],r8
80005036:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
8000503a:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
8000503e:	19 89       	ld.ub	r9,r12[0x0]
80005040:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80005042:	19 3a       	ld.ub	r10,r12++
80005044:	1b e9       	ld.ub	r9,sp[0x6]
80005046:	f5 e9 20 09 	eor	r9,r10,r9
8000504a:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
8000504c:	16 38       	cp.w	r8,r11
8000504e:	cf 81       	brne	8000503e <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80005050:	1a 97       	mov	r7,sp
80005052:	fa ca ff f9 	sub	r10,sp,-7
80005056:	30 7b       	mov	r11,7
80005058:	1a 9c       	mov	r12,sp
8000505a:	f0 1f 00 0d 	mcall	8000508c <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
8000505e:	30 8b       	mov	r11,8
80005060:	16 9c       	mov	r12,r11
80005062:	f0 1f 00 0c 	mcall	80005090 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80005066:	fa c8 ff ed 	sub	r8,sp,-19
8000506a:	1a 99       	mov	r9,sp
8000506c:	30 9a       	mov	r10,9
8000506e:	1a 9b       	mov	r11,sp
80005070:	30 cc       	mov	r12,12
80005072:	f0 1f 00 09 	mcall	80005094 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80005076:	c0 71       	brne	80005084 <PcdSelect+0x60>
80005078:	31 88       	mov	r8,24
8000507a:	fb 39 00 13 	ld.ub	r9,sp[19]
8000507e:	f0 09 18 00 	cp.b	r9,r8
80005082:	c0 20       	breq	80005086 <PcdSelect+0x62>
80005084:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80005086:	2f bd       	sub	sp,-20
80005088:	e3 cd 80 80 	ldm	sp++,r7,pc
8000508c:	80 00       	ld.sh	r0,r0[0x0]
8000508e:	4f 98       	lddpc	r8,80005270 <rfid_sendID_message+0xc4>
80005090:	80 00       	ld.sh	r0,r0[0x0]
80005092:	4d 10       	lddpc	r0,800051d4 <rfid_sendID_message+0x28>
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	4d 38       	lddpc	r8,800051e0 <rfid_sendID_message+0x34>

80005098 <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80005098:	d4 31       	pushm	r0-r7,lr
8000509a:	18 92       	mov	r2,r12
	U8 status = MI_ERR;
	
	PcdReset();
8000509c:	f0 1f 00 34 	mcall	8000516c <rfid_auto_reader+0xd4>
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
800050a0:	4b 47       	lddpc	r7,80005170 <rfid_auto_reader+0xd8>
800050a2:	35 25       	mov	r5,82
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800050a4:	30 44       	mov	r4,4
	else if(CT[0]==0x44&&CT[1]==0x03)
		log("MF Desire\n");
	else
		log("Unknown\n");
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
800050a6:	4b 46       	lddpc	r6,80005174 <rfid_auto_reader+0xdc>
	status=PcdSelect(SN);//
	if(status!=MI_OK)//return status;
	continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
800050a8:	30 41       	mov	r1,4
		log("select okay\n");
800050aa:	4b 40       	lddpc	r0,80005178 <rfid_auto_reader+0xe0>
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800050ac:	30 23       	mov	r3,2
{
	U8 status = MI_ERR;
	
	PcdReset();
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
800050ae:	0e 9b       	mov	r11,r7
800050b0:	0a 9c       	mov	r12,r5
800050b2:	f0 1f 00 33 	mcall	8000517c <rfid_auto_reader+0xe4>
	if(status!=MI_OK) //return status;
800050b6:	cf c1       	brne	800050ae <rfid_auto_reader+0x16>
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800050b8:	0f 88       	ld.ub	r8,r7[0x0]
800050ba:	e8 08 18 00 	cp.b	r8,r4
800050be:	c0 a1       	brne	800050d2 <rfid_auto_reader+0x3a>
800050c0:	0f 9a       	ld.ub	r10,r7[0x1]
800050c2:	30 09       	mov	r9,0
800050c4:	f2 0a 18 00 	cp.b	r10,r9
800050c8:	c0 51       	brne	800050d2 <rfid_auto_reader+0x3a>
		log("MFOne-S50\n");
800050ca:	4a ec       	lddpc	r12,80005180 <rfid_auto_reader+0xe8>
800050cc:	f0 1f 00 2e 	mcall	80005184 <rfid_auto_reader+0xec>
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
800050d0:	c3 78       	rjmp	8000513e <rfid_auto_reader+0xa6>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800050d2:	e6 08 18 00 	cp.b	r8,r3
800050d6:	c0 a1       	brne	800050ea <rfid_auto_reader+0x52>
800050d8:	0f 9a       	ld.ub	r10,r7[0x1]
800050da:	30 09       	mov	r9,0
800050dc:	f2 0a 18 00 	cp.b	r10,r9
800050e0:	c0 51       	brne	800050ea <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
800050e2:	4a ac       	lddpc	r12,80005188 <rfid_auto_reader+0xf0>
800050e4:	f0 1f 00 28 	mcall	80005184 <rfid_auto_reader+0xec>
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
800050e8:	c2 b8       	rjmp	8000513e <rfid_auto_reader+0xa6>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
800050ea:	34 49       	mov	r9,68
800050ec:	f2 08 18 00 	cp.b	r8,r9
800050f0:	c0 a1       	brne	80005104 <rfid_auto_reader+0x6c>
800050f2:	0f 9a       	ld.ub	r10,r7[0x1]
800050f4:	30 09       	mov	r9,0
800050f6:	f2 0a 18 00 	cp.b	r10,r9
800050fa:	c0 51       	brne	80005104 <rfid_auto_reader+0x6c>
		log("MF-UltraLight\n");
800050fc:	4a 4c       	lddpc	r12,8000518c <rfid_auto_reader+0xf4>
800050fe:	f0 1f 00 22 	mcall	80005184 <rfid_auto_reader+0xec>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80005102:	c1 e8       	rjmp	8000513e <rfid_auto_reader+0xa6>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80005104:	30 89       	mov	r9,8
80005106:	f2 08 18 00 	cp.b	r8,r9
8000510a:	c0 a1       	brne	8000511e <rfid_auto_reader+0x86>
8000510c:	0f 9a       	ld.ub	r10,r7[0x1]
8000510e:	30 09       	mov	r9,0
80005110:	f2 0a 18 00 	cp.b	r10,r9
80005114:	c0 51       	brne	8000511e <rfid_auto_reader+0x86>
		log("MF-Pro\n");
80005116:	49 fc       	lddpc	r12,80005190 <rfid_auto_reader+0xf8>
80005118:	f0 1f 00 1b 	mcall	80005184 <rfid_auto_reader+0xec>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
8000511c:	c1 18       	rjmp	8000513e <rfid_auto_reader+0xa6>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
8000511e:	34 49       	mov	r9,68
80005120:	f2 08 18 00 	cp.b	r8,r9
80005124:	c0 a1       	brne	80005138 <rfid_auto_reader+0xa0>
80005126:	0f 99       	ld.ub	r9,r7[0x1]
80005128:	30 38       	mov	r8,3
8000512a:	f0 09 18 00 	cp.b	r9,r8
8000512e:	c0 51       	brne	80005138 <rfid_auto_reader+0xa0>
		log("MF Desire\n");
80005130:	49 9c       	lddpc	r12,80005194 <rfid_auto_reader+0xfc>
80005132:	f0 1f 00 15 	mcall	80005184 <rfid_auto_reader+0xec>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80005136:	c0 48       	rjmp	8000513e <rfid_auto_reader+0xa6>
		log("MF Desire\n");
	else
		log("Unknown\n");
80005138:	49 8c       	lddpc	r12,80005198 <rfid_auto_reader+0x100>
8000513a:	f0 1f 00 13 	mcall	80005184 <rfid_auto_reader+0xec>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
8000513e:	0c 9c       	mov	r12,r6
80005140:	f0 1f 00 17 	mcall	8000519c <rfid_auto_reader+0x104>
	if(status!=MI_OK)
80005144:	c0 60       	breq	80005150 <rfid_auto_reader+0xb8>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80005146:	37 8b       	mov	r11,120
80005148:	30 1c       	mov	r12,1
8000514a:	f0 1f 00 16 	mcall	800051a0 <rfid_auto_reader+0x108>
		//return status;
		continue;
8000514e:	cb 0b       	rjmp	800050ae <rfid_auto_reader+0x16>
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80005150:	0c 9c       	mov	r12,r6
80005152:	f0 1f 00 15 	mcall	800051a4 <rfid_auto_reader+0x10c>
	if(status!=MI_OK)//return status;
80005156:	ca c1       	brne	800050ae <rfid_auto_reader+0x16>
	continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80005158:	02 9a       	mov	r10,r1
8000515a:	0c 9b       	mov	r11,r6
8000515c:	04 9c       	mov	r12,r2
8000515e:	f0 1f 00 13 	mcall	800051a8 <rfid_auto_reader+0x110>
		log("select okay\n");
80005162:	00 9c       	mov	r12,r0
80005164:	f0 1f 00 08 	mcall	80005184 <rfid_auto_reader+0xec>
80005168:	ca 3b       	rjmp	800050ae <rfid_auto_reader+0x16>
8000516a:	00 00       	add	r0,r0
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	4c 2c       	lddpc	r12,80005274 <rfid_sendID_message+0xc8>
80005170:	00 00       	add	r0,r0
80005172:	53 ac       	stdsp	sp[0xe8],r12
80005174:	00 00       	add	r0,r0
80005176:	53 b0       	stdsp	sp[0xec],r0
80005178:	80 00       	ld.sh	r0,r0[0x0]
8000517a:	da 84       	*unknown*
8000517c:	80 00       	ld.sh	r0,r0[0x0]
8000517e:	4f 34       	lddpc	r4,80005348 <local_start_timer+0x14>
80005180:	80 00       	ld.sh	r0,r0[0x0]
80005182:	da 3c       	*unknown*
80005184:	80 00       	ld.sh	r0,r0[0x0]
80005186:	71 10       	ld.w	r0,r8[0x44]
80005188:	80 00       	ld.sh	r0,r0[0x0]
8000518a:	da 48       	*unknown*
8000518c:	80 00       	ld.sh	r0,r0[0x0]
8000518e:	da 54       	*unknown*
80005190:	80 00       	ld.sh	r0,r0[0x0]
80005192:	da 64       	*unknown*
80005194:	80 00       	ld.sh	r0,r0[0x0]
80005196:	da 6c       	*unknown*
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	da 78       	*unknown*
8000519c:	80 00       	ld.sh	r0,r0[0x0]
8000519e:	4e b0       	lddpc	r0,80005348 <local_start_timer+0x14>
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	43 88       	lddsp	r8,sp[0xe0]
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	50 24       	stdsp	sp[0x8],r4
800051a8:	80 00       	ld.sh	r0,r0[0x0]
800051aa:	79 8c       	ld.w	r12,r12[0x60]

800051ac <rfid_sendID_message>:
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
800051ac:	eb cd 40 e0 	pushm	r5-r7,lr
800051b0:	21 fd       	sub	sp,124
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
800051b2:	fa cc ff 90 	sub	r12,sp,-112
800051b6:	30 08       	mov	r8,0
800051b8:	30 09       	mov	r9,0
800051ba:	f8 e9 00 00 	st.d	r12[0],r8
800051be:	30 0a       	mov	r10,0
800051c0:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
800051c2:	fa e9 00 20 	st.d	sp[32],r8
800051c6:	fa e9 00 28 	st.d	sp[40],r8
800051ca:	fa e9 00 30 	st.d	sp[48],r8
800051ce:	fa e9 00 38 	st.d	sp[56],r8
800051d2:	fa e9 00 40 	st.d	sp[64],r8
800051d6:	fa e9 00 48 	st.d	sp[72],r8
800051da:	fa e9 00 50 	st.d	sp[80],r8
800051de:	fa e9 00 58 	st.d	sp[88],r8
800051e2:	fa e9 00 60 	st.d	sp[96],r8
800051e6:	fa e9 00 68 	st.d	sp[104],r8

	return_err = rfid_auto_reader(SN);
800051ea:	f0 1f 00 43 	mcall	800052f4 <rfid_sendID_message+0x148>
800051ee:	18 97       	mov	r7,r12
	
	if(return_err == 0){
800051f0:	c7 61       	brne	800052dc <rfid_sendID_message+0x130>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
800051f2:	fb 38 00 73 	ld.ub	r8,sp[115]
800051f6:	1a d8       	st.w	--sp,r8
800051f8:	fb 38 00 76 	ld.ub	r8,sp[118]
800051fc:	1a d8       	st.w	--sp,r8
800051fe:	fb 38 00 79 	ld.ub	r8,sp[121]
80005202:	1a d8       	st.w	--sp,r8
80005204:	fb 38 00 7c 	ld.ub	r8,sp[124]
80005208:	1a d8       	st.w	--sp,r8
8000520a:	4b cc       	lddpc	r12,800052f8 <rfid_sendID_message+0x14c>
8000520c:	f0 1f 00 3c 	mcall	800052fc <rfid_sendID_message+0x150>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80005210:	37 7b       	mov	r11,119
80005212:	30 1c       	mov	r12,1
80005214:	f0 1f 00 3b 	mcall	80005300 <rfid_sendID_message+0x154>
80005218:	fa c9 ff 80 	sub	r9,sp,-128
8000521c:	fa c8 ff f0 	sub	r8,sp,-16
80005220:	fa ca ff ee 	sub	r10,sp,-18
}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
80005224:	fa c5 ff 7c 	sub	r5,sp,-132
80005228:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
8000522a:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
8000522c:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
8000522e:	13 8b       	ld.ub	r11,r9[0x0]
80005230:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80005234:	fc 0c 18 00 	cp.b	r12,lr
80005238:	f7 bc 08 d0 	subls	r12,-48
8000523c:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80005240:	f7 bc 0b a9 	subhi	r12,-87
80005244:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80005248:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
8000524a:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
8000524e:	fc 0b 18 00 	cp.b	r11,lr
80005252:	f7 bb 08 d0 	subls	r11,-48
80005256:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
8000525a:	f7 bb 0b a9 	subhi	r11,-87
8000525e:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80005262:	b0 b6       	st.b	r8[0x3],r6
80005264:	2f f9       	sub	r9,-1
80005266:	2f c8       	sub	r8,-4
80005268:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
8000526a:	0a 39       	cp.w	r9,r5
8000526c:	ce 11       	brne	8000522e <rfid_sendID_message+0x82>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
8000526e:	30 6a       	mov	r10,6
80005270:	4a 5b       	lddpc	r11,80005304 <rfid_sendID_message+0x158>
80005272:	fa cc ff f0 	sub	r12,sp,-16
80005276:	f0 1f 00 25 	mcall	80005308 <rfid_sendID_message+0x15c>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
8000527a:	4a 58       	lddpc	r8,8000530c <rfid_sendID_message+0x160>
8000527c:	11 89       	ld.ub	r9,r8[0x0]
8000527e:	39 f8       	mov	r8,-97
80005280:	f0 09 18 00 	cp.b	r9,r8
80005284:	e0 88 00 05 	brls	8000528e <rfid_sendID_message+0xe2>
80005288:	38 09       	mov	r9,-128
8000528a:	4a 18       	lddpc	r8,8000530c <rfid_sendID_message+0x160>
8000528c:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
8000528e:	4a 08       	lddpc	r8,8000530c <rfid_sendID_message+0x160>
80005290:	11 86       	ld.ub	r6,r8[0x0]
80005292:	2f f6       	sub	r6,-1
80005294:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80005296:	30 5a       	mov	r10,5
80005298:	49 eb       	lddpc	r11,80005310 <rfid_sendID_message+0x164>
8000529a:	fa cc ff e5 	sub	r12,sp,-27
8000529e:	f0 1f 00 1b 	mcall	80005308 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
800052a2:	31 e8       	mov	r8,30
800052a4:	fb 58 00 16 	st.h	sp[22],r8
800052a8:	fb 66 00 1a 	st.b	sp[26],r6
800052ac:	fe 78 e0 00 	mov	r8,-8192
800052b0:	fb 58 00 18 	st.h	sp[24],r8
800052b4:	fa c6 ff e0 	sub	r6,sp,-32
800052b8:	30 aa       	mov	r10,10
800052ba:	fa cb ff ea 	sub	r11,sp,-22
800052be:	0c 9c       	mov	r12,r6
800052c0:	f0 1f 00 12 	mcall	80005308 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
800052c4:	31 6a       	mov	r10,22
800052c6:	1a 9b       	mov	r11,sp
800052c8:	fa cc ff d6 	sub	r12,sp,-42
800052cc:	f0 1f 00 0f 	mcall	80005308 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
800052d0:	30 9a       	mov	r10,9
800052d2:	32 0b       	mov	r11,32
800052d4:	0c 9c       	mov	r12,r6
800052d6:	f0 1f 00 10 	mcall	80005314 <rfid_sendID_message+0x168>
800052da:	c0 88       	rjmp	800052ea <rfid_sendID_message+0x13e>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
800052dc:	37 8b       	mov	r11,120
800052de:	30 1c       	mov	r12,1
800052e0:	f0 1f 00 08 	mcall	80005300 <rfid_sendID_message+0x154>
		log("no card find...\n");
800052e4:	48 dc       	lddpc	r12,80005318 <rfid_sendID_message+0x16c>
800052e6:	f0 1f 00 06 	mcall	800052fc <rfid_sendID_message+0x150>
	}
	
	return return_err;
	
}
800052ea:	0e 9c       	mov	r12,r7
800052ec:	2e 1d       	sub	sp,-124
800052ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800052f2:	00 00       	add	r0,r0
800052f4:	80 00       	ld.sh	r0,r0[0x0]
800052f6:	50 98       	stdsp	sp[0x24],r8
800052f8:	80 00       	ld.sh	r0,r0[0x0]
800052fa:	da 94       	*unknown*
800052fc:	80 00       	ld.sh	r0,r0[0x0]
800052fe:	71 10       	ld.w	r0,r8[0x44]
80005300:	80 00       	ld.sh	r0,r0[0x0]
80005302:	43 88       	lddsp	r8,sp[0xe0]
80005304:	00 00       	add	r0,r0
80005306:	0d 9c       	ld.ub	r12,r6[0x1]
80005308:	80 00       	ld.sh	r0,r0[0x0]
8000530a:	79 8c       	ld.w	r12,r12[0x60]
8000530c:	00 00       	add	r0,r0
8000530e:	05 34       	ld.ub	r4,r2++
80005310:	00 00       	add	r0,r0
80005312:	05 2c       	ld.uh	r12,r2++
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	42 50       	lddsp	r0,sp[0x94]
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	da b0       	acall	0xab

8000531c <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
8000531c:	58 0c       	cp.w	r12,0
8000531e:	5e 0c       	reteq	r12
80005320:	30 08       	mov	r8,0
	{
		nop();
80005322:	d7 03       	nop
		nop();
80005324:	d7 03       	nop
		nop();
80005326:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005328:	2f f8       	sub	r8,-1
8000532a:	10 3c       	cp.w	r12,r8
8000532c:	fe 9b ff fb 	brhi	80005322 <delay_ns+0x6>
80005330:	5e fc       	retal	r12
80005332:	d7 03       	nop

80005334 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80005334:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80005336:	30 3b       	mov	r11,3
80005338:	48 8c       	lddpc	r12,80005358 <local_start_timer+0x24>
8000533a:	f0 1f 00 09 	mcall	8000535c <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
8000533e:	fe 78 38 00 	mov	r8,-51200
80005342:	e0 69 91 0d 	mov	r9,37133
80005346:	ea 19 00 52 	orh	r9,0x52
8000534a:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
8000534c:	32 09       	mov	r9,32
8000534e:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80005350:	30 59       	mov	r9,5
80005352:	91 09       	st.w	r8[0x0],r9
}
80005354:	d8 02       	popm	pc
80005356:	00 00       	add	r0,r0
80005358:	80 00       	ld.sh	r0,r0[0x0]
8000535a:	da e8       	*unknown*
8000535c:	80 00       	ld.sh	r0,r0[0x0]
8000535e:	54 f4       	stdsp	sp[0x13c],r4

80005360 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80005360:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80005362:	30 3a       	mov	r10,3
80005364:	e0 6b 1b 00 	mov	r11,6912
80005368:	ea 1b 00 b7 	orh	r11,0xb7
8000536c:	fe 7c 0c 00 	mov	r12,-62464
80005370:	f0 1f 00 19 	mcall	800053d4 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80005374:	31 08       	mov	r8,16
80005376:	1a d8       	st.w	--sp,r8
80005378:	30 08       	mov	r8,0
8000537a:	30 19       	mov	r9,1
8000537c:	30 7a       	mov	r10,7
8000537e:	10 9b       	mov	r11,r8
80005380:	fe 7c 0c 00 	mov	r12,-62464
80005384:	f0 1f 00 15 	mcall	800053d8 <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80005388:	30 08       	mov	r8,0
8000538a:	30 19       	mov	r9,1
8000538c:	12 9a       	mov	r10,r9
8000538e:	10 9b       	mov	r11,r8
80005390:	fe 7c 0c 00 	mov	r12,-62464
80005394:	f0 1f 00 12 	mcall	800053dc <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80005398:	30 0b       	mov	r11,0
8000539a:	fe 7c 0c 00 	mov	r12,-62464
8000539e:	f0 1f 00 11 	mcall	800053e0 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
800053a2:	fe 7c 0c 00 	mov	r12,-62464
800053a6:	f0 1f 00 10 	mcall	800053e4 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
800053aa:	30 0a       	mov	r10,0
800053ac:	1a da       	st.w	--sp,r10
800053ae:	1a da       	st.w	--sp,r10
800053b0:	14 98       	mov	r8,r10
800053b2:	14 99       	mov	r9,r10
800053b4:	30 1b       	mov	r11,1
800053b6:	fe 7c 0c 00 	mov	r12,-62464
800053ba:	f0 1f 00 0c 	mcall	800053e8 <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
800053be:	30 1c       	mov	r12,1
800053c0:	f0 1f 00 0b 	mcall	800053ec <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
800053c4:	30 2b       	mov	r11,2
800053c6:	fe 7c 0c 00 	mov	r12,-62464
800053ca:	f0 1f 00 0a 	mcall	800053f0 <local_start_pll0+0x90>
800053ce:	2f dd       	sub	sp,-12
/****/
}
800053d0:	d8 02       	popm	pc
800053d2:	00 00       	add	r0,r0
800053d4:	80 00       	ld.sh	r0,r0[0x0]
800053d6:	57 fc       	stdsp	sp[0x1fc],r12
800053d8:	80 00       	ld.sh	r0,r0[0x0]
800053da:	57 9e       	stdsp	sp[0x1e4],lr
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	57 c0       	stdsp	sp[0x1f0],r0
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	57 da       	stdsp	sp[0x1f4],r10
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	57 e8       	stdsp	sp[0x1f8],r8
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	57 58       	stdsp	sp[0x1d4],r8
800053ec:	80 00       	ld.sh	r0,r0[0x0]
800053ee:	54 94       	stdsp	sp[0x124],r4
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	57 f2       	stdsp	sp[0x1fc],r2

800053f4 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800053f4:	eb cd 40 e0 	pushm	r5-r7,lr
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
800053f8:	f0 1f 00 1b 	mcall	80005464 <xg_flashc_init+0x70>
800053fc:	49 b8       	lddpc	r8,80005468 <xg_flashc_init+0x74>
800053fe:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80005400:	70 08       	ld.w	r8,r8[0x0]
80005402:	58 08       	cp.w	r8,0
80005404:	c0 41       	brne	8000540c <xg_flashc_init+0x18>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005406:	49 ac       	lddpc	r12,8000546c <xg_flashc_init+0x78>
80005408:	f0 1f 00 1a 	mcall	80005470 <xg_flashc_init+0x7c>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
8000540c:	30 0b       	mov	r11,0
8000540e:	30 1c       	mov	r12,1
80005410:	f0 1f 00 19 	mcall	80005474 <xg_flashc_init+0x80>
80005414:	49 98       	lddpc	r8,80005478 <xg_flashc_init+0x84>
80005416:	91 0c       	st.w	r8[0x0],r12
80005418:	70 08       	ld.w	r8,r8[0x0]
8000541a:	58 08       	cp.w	r8,0
8000541c:	c0 80       	breq	8000542c <xg_flashc_init+0x38>
8000541e:	49 78       	lddpc	r8,80005478 <xg_flashc_init+0x84>
80005420:	70 0c       	ld.w	r12,r8[0x0]
80005422:	30 09       	mov	r9,0
80005424:	12 9a       	mov	r10,r9
80005426:	12 9b       	mov	r11,r9
80005428:	f0 1f 00 15 	mcall	8000547c <xg_flashc_init+0x88>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
8000542c:	30 4b       	mov	r11,4
8000542e:	31 4c       	mov	r12,20
80005430:	f0 1f 00 11 	mcall	80005474 <xg_flashc_init+0x80>
80005434:	49 38       	lddpc	r8,80005480 <xg_flashc_init+0x8c>
80005436:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80005438:	30 4b       	mov	r11,4
8000543a:	31 4c       	mov	r12,20
8000543c:	f0 1f 00 0e 	mcall	80005474 <xg_flashc_init+0x80>
80005440:	49 18       	lddpc	r8,80005484 <xg_flashc_init+0x90>
80005442:	91 0c       	st.w	r8[0x0],r12
80005444:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005446:	10 96       	mov	r6,r8
80005448:	49 05       	lddpc	r5,80005488 <xg_flashc_init+0x94>
8000544a:	6c 0c       	ld.w	r12,r6[0x0]
8000544c:	ea 07 00 0b 	add	r11,r5,r7
80005450:	f0 1f 00 0f 	mcall	8000548c <xg_flashc_init+0x98>
80005454:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005456:	e0 47 02 80 	cp.w	r7,640
8000545a:	cf 81       	brne	8000544a <xg_flashc_init+0x56>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
8000545c:	f0 1f 00 0d 	mcall	80005490 <xg_flashc_init+0x9c>
	////flash_rw_example(ch, flash_nvram_data);
	////flash_rw_example(ch, &temp_data);
	
	#endif
	
}
80005460:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005464:	80 00       	ld.sh	r0,r0[0x0]
80005466:	65 d8       	ld.w	r8,r2[0x74]
80005468:	00 00       	add	r0,r0
8000546a:	0b 70       	ld.ub	r0,--r5
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	db 00       	acall	0xb0
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	71 10       	ld.w	r0,r8[0x44]
80005474:	80 00       	ld.sh	r0,r0[0x0]
80005476:	66 30       	ld.w	r0,r3[0xc]
80005478:	00 00       	add	r0,r0
8000547a:	53 b4       	stdsp	sp[0xec],r4
8000547c:	80 00       	ld.sh	r0,r0[0x0]
8000547e:	64 d8       	ld.w	r8,r2[0x34]
80005480:	00 00       	add	r0,r0
80005482:	0b 6c       	ld.uh	r12,--r5
80005484:	00 00       	add	r0,r0
80005486:	0b 74       	ld.ub	r4,--r5
80005488:	00 00       	add	r0,r0
8000548a:	0d a2       	ld.ub	r2,r6[0x2]
8000548c:	80 00       	ld.sh	r0,r0[0x0]
8000548e:	2f 18       	sub	r8,-15
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	2b b0       	sub	r0,-69

80005494 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80005494:	fe 68 14 00 	mov	r8,-125952
80005498:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000549a:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
8000549e:	91 09       	st.w	r8[0x0],r9
}
800054a0:	5e fc       	retal	r12

800054a2 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800054a2:	f8 08 16 05 	lsr	r8,r12,0x5
800054a6:	a9 68       	lsl	r8,0x8
800054a8:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800054ac:	58 1b       	cp.w	r11,1
800054ae:	c0 d0       	breq	800054c8 <gpio_enable_module_pin+0x26>
800054b0:	c0 63       	brcs	800054bc <gpio_enable_module_pin+0x1a>
800054b2:	58 2b       	cp.w	r11,2
800054b4:	c1 00       	breq	800054d4 <gpio_enable_module_pin+0x32>
800054b6:	58 3b       	cp.w	r11,3
800054b8:	c1 40       	breq	800054e0 <gpio_enable_module_pin+0x3e>
800054ba:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800054bc:	30 19       	mov	r9,1
800054be:	f2 0c 09 49 	lsl	r9,r9,r12
800054c2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800054c4:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800054c6:	c1 28       	rjmp	800054ea <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800054c8:	30 19       	mov	r9,1
800054ca:	f2 0c 09 49 	lsl	r9,r9,r12
800054ce:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800054d0:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800054d2:	c0 c8       	rjmp	800054ea <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800054d4:	30 19       	mov	r9,1
800054d6:	f2 0c 09 49 	lsl	r9,r9,r12
800054da:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800054dc:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800054de:	c0 68       	rjmp	800054ea <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800054e0:	30 19       	mov	r9,1
800054e2:	f2 0c 09 49 	lsl	r9,r9,r12
800054e6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800054e8:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800054ea:	30 19       	mov	r9,1
800054ec:	f2 0c 09 4c 	lsl	r12,r9,r12
800054f0:	91 2c       	st.w	r8[0x8],r12
800054f2:	5e fd       	retal	0

800054f4 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800054f4:	d4 21       	pushm	r4-r7,lr
800054f6:	18 97       	mov	r7,r12
800054f8:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800054fa:	58 0b       	cp.w	r11,0
800054fc:	c0 31       	brne	80005502 <gpio_enable_module+0xe>
800054fe:	30 05       	mov	r5,0
80005500:	c0 d8       	rjmp	8000551a <gpio_enable_module+0x26>
80005502:	30 06       	mov	r6,0
80005504:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80005506:	6e 1b       	ld.w	r11,r7[0x4]
80005508:	6e 0c       	ld.w	r12,r7[0x0]
8000550a:	f0 1f 00 06 	mcall	80005520 <gpio_enable_module+0x2c>
8000550e:	18 45       	or	r5,r12
		gpiomap++;
80005510:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80005512:	2f f6       	sub	r6,-1
80005514:	0c 34       	cp.w	r4,r6
80005516:	fe 9b ff f8 	brhi	80005506 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000551a:	0a 9c       	mov	r12,r5
8000551c:	d8 22       	popm	r4-r7,pc
8000551e:	00 00       	add	r0,r0
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	54 a2       	stdsp	sp[0x128],r2

80005524 <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005524:	f8 08 16 05 	lsr	r8,r12,0x5
80005528:	a9 68       	lsl	r8,0x8
8000552a:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
8000552e:	30 19       	mov	r9,1
80005530:	f2 0c 09 4c 	lsl	r12,r9,r12
80005534:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005538:	91 1c       	st.w	r8[0x4],r12
}
8000553a:	5e fc       	retal	r12

8000553c <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000553c:	f8 08 16 05 	lsr	r8,r12,0x5
80005540:	a9 68       	lsl	r8,0x8
80005542:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80005546:	30 19       	mov	r9,1
80005548:	f2 0c 09 4c 	lsl	r12,r9,r12
8000554c:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005550:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005554:	91 1c       	st.w	r8[0x4],r12
}
80005556:	5e fc       	retal	r12

80005558 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005558:	f8 08 16 05 	lsr	r8,r12,0x5
8000555c:	a9 68       	lsl	r8,0x8
8000555e:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
80005562:	30 19       	mov	r9,1
80005564:	f2 0c 09 4c 	lsl	r12,r9,r12
80005568:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
8000556c:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005570:	91 1c       	st.w	r8[0x4],r12
}
80005572:	5e fc       	retal	r12

80005574 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80005574:	c0 08       	rjmp	80005574 <_unhandled_interrupt>
80005576:	d7 03       	nop

80005578 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005578:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
8000557c:	49 99       	lddpc	r9,800055e0 <INTC_register_interrupt+0x68>
8000557e:	f2 08 00 39 	add	r9,r9,r8<<0x3
80005582:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80005586:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005588:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
8000558c:	58 0a       	cp.w	r10,0
8000558e:	c0 91       	brne	800055a0 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005590:	49 59       	lddpc	r9,800055e4 <INTC_register_interrupt+0x6c>
80005592:	49 6a       	lddpc	r10,800055e8 <INTC_register_interrupt+0x70>
80005594:	12 1a       	sub	r10,r9
80005596:	fe 79 08 00 	mov	r9,-63488
8000559a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000559e:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800055a0:	58 1a       	cp.w	r10,1
800055a2:	c0 a1       	brne	800055b6 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
800055a4:	49 09       	lddpc	r9,800055e4 <INTC_register_interrupt+0x6c>
800055a6:	49 2a       	lddpc	r10,800055ec <INTC_register_interrupt+0x74>
800055a8:	12 1a       	sub	r10,r9
800055aa:	bf aa       	sbr	r10,0x1e
800055ac:	fe 79 08 00 	mov	r9,-63488
800055b0:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800055b4:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800055b6:	58 2a       	cp.w	r10,2
800055b8:	c0 a1       	brne	800055cc <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800055ba:	48 b9       	lddpc	r9,800055e4 <INTC_register_interrupt+0x6c>
800055bc:	48 da       	lddpc	r10,800055f0 <INTC_register_interrupt+0x78>
800055be:	12 1a       	sub	r10,r9
800055c0:	bf ba       	sbr	r10,0x1f
800055c2:	fe 79 08 00 	mov	r9,-63488
800055c6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800055ca:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800055cc:	48 69       	lddpc	r9,800055e4 <INTC_register_interrupt+0x6c>
800055ce:	48 aa       	lddpc	r10,800055f4 <INTC_register_interrupt+0x7c>
800055d0:	12 1a       	sub	r10,r9
800055d2:	ea 1a c0 00 	orh	r10,0xc000
800055d6:	fe 79 08 00 	mov	r9,-63488
800055da:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800055de:	5e fc       	retal	r12
800055e0:	80 00       	ld.sh	r0,r0[0x0]
800055e2:	db b0       	acall	0xbb
800055e4:	80 00       	ld.sh	r0,r0[0x0]
800055e6:	d0 00       	acall	0x0
800055e8:	80 00       	ld.sh	r0,r0[0x0]
800055ea:	d1 04       	*unknown*
800055ec:	80 00       	ld.sh	r0,r0[0x0]
800055ee:	d1 12       	popm	r0-r3,r11
800055f0:	80 00       	ld.sh	r0,r0[0x0]
800055f2:	d1 20       	acall	0x12
800055f4:	80 00       	ld.sh	r0,r0[0x0]
800055f6:	d1 2e       	*unknown*

800055f8 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800055f8:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800055fa:	49 18       	lddpc	r8,8000563c <INTC_init_interrupts+0x44>
800055fc:	e3 b8 00 01 	mtsr	0x4,r8
80005600:	49 0e       	lddpc	lr,80005640 <INTC_init_interrupts+0x48>
80005602:	30 07       	mov	r7,0
80005604:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005606:	49 0c       	lddpc	r12,80005644 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005608:	49 05       	lddpc	r5,80005648 <INTC_init_interrupts+0x50>
8000560a:	10 15       	sub	r5,r8
8000560c:	fe 76 08 00 	mov	r6,-63488
80005610:	c1 08       	rjmp	80005630 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005612:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005614:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005616:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005618:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
8000561c:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000561e:	10 3a       	cp.w	r10,r8
80005620:	fe 9b ff fc 	brhi	80005618 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005624:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005628:	2f f7       	sub	r7,-1
8000562a:	2f 8e       	sub	lr,-8
8000562c:	59 37       	cp.w	r7,19
8000562e:	c0 50       	breq	80005638 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005630:	7c 08       	ld.w	r8,lr[0x0]
80005632:	58 08       	cp.w	r8,0
80005634:	ce f1       	brne	80005612 <INTC_init_interrupts+0x1a>
80005636:	cf 7b       	rjmp	80005624 <INTC_init_interrupts+0x2c>
80005638:	d8 22       	popm	r4-r7,pc
8000563a:	00 00       	add	r0,r0
8000563c:	80 00       	ld.sh	r0,r0[0x0]
8000563e:	d0 00       	acall	0x0
80005640:	80 00       	ld.sh	r0,r0[0x0]
80005642:	db b0       	acall	0xbb
80005644:	80 00       	ld.sh	r0,r0[0x0]
80005646:	55 74       	stdsp	sp[0x15c],r4
80005648:	80 00       	ld.sh	r0,r0[0x0]
8000564a:	d1 04       	*unknown*

8000564c <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
8000564c:	fe 78 08 00 	mov	r8,-63488
80005650:	e0 69 00 83 	mov	r9,131
80005654:	f2 0c 01 0c 	sub	r12,r9,r12
80005658:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000565c:	f2 ca ff c0 	sub	r10,r9,-64
80005660:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005664:	58 08       	cp.w	r8,0
80005666:	c0 21       	brne	8000566a <_get_interrupt_handler+0x1e>
80005668:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
8000566a:	f0 08 12 00 	clz	r8,r8
8000566e:	48 5a       	lddpc	r10,80005680 <_get_interrupt_handler+0x34>
80005670:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005674:	f0 08 11 1f 	rsub	r8,r8,31
80005678:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000567a:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
8000567e:	5e fc       	retal	r12
80005680:	80 00       	ld.sh	r0,r0[0x0]
80005682:	db b0       	acall	0xbb

80005684 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80005684:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80005686:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
8000568a:	99 a8       	st.w	r12[0x28],r8
}
8000568c:	5e fc       	retal	r12
8000568e:	d7 03       	nop

80005690 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80005690:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80005692:	ec 5b bb 9f 	cp.w	r11,899999
80005696:	e0 8b 00 04 	brhi	8000569e <pm_enable_osc0_crystal+0xe>
8000569a:	30 4b       	mov	r11,4
8000569c:	c1 38       	rjmp	800056c2 <pm_enable_osc0_crystal+0x32>
8000569e:	e0 68 c6 bf 	mov	r8,50879
800056a2:	ea 18 00 2d 	orh	r8,0x2d
800056a6:	10 3b       	cp.w	r11,r8
800056a8:	e0 8b 00 04 	brhi	800056b0 <pm_enable_osc0_crystal+0x20>
800056ac:	30 5b       	mov	r11,5
800056ae:	c0 a8       	rjmp	800056c2 <pm_enable_osc0_crystal+0x32>
800056b0:	e0 68 12 00 	mov	r8,4608
800056b4:	ea 18 00 7a 	orh	r8,0x7a
800056b8:	10 3b       	cp.w	r11,r8
800056ba:	f9 bb 03 06 	movlo	r11,6
800056be:	f9 bb 02 07 	movhs	r11,7
800056c2:	f0 1f 00 02 	mcall	800056c8 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800056c6:	d8 02       	popm	pc
800056c8:	80 00       	ld.sh	r0,r0[0x0]
800056ca:	56 84       	stdsp	sp[0x1a0],r4

800056cc <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800056cc:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800056ce:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800056d2:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800056d4:	78 08       	ld.w	r8,r12[0x0]
800056d6:	a3 a8       	sbr	r8,0x2
800056d8:	99 08       	st.w	r12[0x0],r8
}
800056da:	5e fc       	retal	r12

800056dc <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800056dc:	79 58       	ld.w	r8,r12[0x54]
800056de:	e2 18 00 80 	andl	r8,0x80,COH
800056e2:	cf d0       	breq	800056dc <pm_wait_for_clk0_ready>
}
800056e4:	5e fc       	retal	r12
800056e6:	d7 03       	nop

800056e8 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800056e8:	eb cd 40 80 	pushm	r7,lr
800056ec:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800056ee:	f0 1f 00 04 	mcall	800056fc <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800056f2:	0e 9c       	mov	r12,r7
800056f4:	f0 1f 00 03 	mcall	80005700 <pm_enable_clk0+0x18>
}
800056f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800056fc:	80 00       	ld.sh	r0,r0[0x0]
800056fe:	56 cc       	stdsp	sp[0x1b0],r12
80005700:	80 00       	ld.sh	r0,r0[0x0]
80005702:	56 dc       	stdsp	sp[0x1b4],r12

80005704 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005704:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
80005706:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
8000570a:	99 c8       	st.w	r12[0x30],r8
}
8000570c:	5e fc       	retal	r12
8000570e:	d7 03       	nop

80005710 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80005710:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
80005712:	30 1b       	mov	r11,1
80005714:	f0 1f 00 02 	mcall	8000571c <pm_enable_osc32_crystal+0xc>
}
80005718:	d8 02       	popm	pc
8000571a:	00 00       	add	r0,r0
8000571c:	80 00       	ld.sh	r0,r0[0x0]
8000571e:	57 04       	stdsp	sp[0x1c0],r4

80005720 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80005720:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
80005722:	30 19       	mov	r9,1
80005724:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80005728:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
8000572c:	99 c8       	st.w	r12[0x30],r8
}
8000572e:	5e fc       	retal	r12

80005730 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80005730:	79 58       	ld.w	r8,r12[0x54]
80005732:	e2 18 02 00 	andl	r8,0x200,COH
80005736:	cf d0       	breq	80005730 <pm_wait_for_clk32_ready>
}
80005738:	5e fc       	retal	r12
8000573a:	d7 03       	nop

8000573c <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
8000573c:	eb cd 40 80 	pushm	r7,lr
80005740:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
80005742:	f0 1f 00 04 	mcall	80005750 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
80005746:	0e 9c       	mov	r12,r7
80005748:	f0 1f 00 03 	mcall	80005754 <pm_enable_clk32+0x18>
}
8000574c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005750:	80 00       	ld.sh	r0,r0[0x0]
80005752:	57 20       	stdsp	sp[0x1c8],r0
80005754:	80 00       	ld.sh	r0,r0[0x0]
80005756:	57 30       	stdsp	sp[0x1cc],r0

80005758 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80005758:	eb cd 40 d0 	pushm	r4,r6-r7,lr
8000575c:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80005760:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80005762:	09 f7       	ld.ub	r7,r4[0x7]
80005764:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80005768:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
8000576c:	09 b4       	ld.ub	r4,r4[0x3]
8000576e:	08 96       	mov	r6,r4
80005770:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
80005774:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80005778:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
8000577c:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80005780:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80005784:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80005788:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
8000578c:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80005790:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80005792:	79 58       	ld.w	r8,r12[0x54]
80005794:	e2 18 00 20 	andl	r8,0x20,COH
80005798:	cf d0       	breq	80005792 <pm_cksel+0x3a>
}
8000579a:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

8000579e <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000579e:	eb cd 40 80 	pushm	r7,lr
800057a2:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800057a4:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
800057a6:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800057aa:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
800057ae:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
800057b2:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
800057b6:	2f 8b       	sub	r11,-8
800057b8:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800057bc:	e3 cd 80 80 	ldm	sp++,r7,pc

800057c0 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
800057c0:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
800057c2:	2f 8b       	sub	r11,-8
800057c4:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
800057c8:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800057cc:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800057d0:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800057d4:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800057d8:	d8 02       	popm	pc

800057da <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800057da:	2f 8b       	sub	r11,-8
800057dc:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800057e0:	a1 a8       	sbr	r8,0x0
800057e2:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800057e6:	5e fc       	retal	r12

800057e8 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800057e8:	79 58       	ld.w	r8,r12[0x54]
800057ea:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800057ee:	cf d0       	breq	800057e8 <pm_wait_for_pll0_locked>
}
800057f0:	5e fc       	retal	r12

800057f2 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800057f2:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800057f4:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800057f8:	99 08       	st.w	r12[0x0],r8
}
800057fa:	5e fc       	retal	r12

800057fc <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800057fc:	eb cd 40 c0 	pushm	r6-r7,lr
80005800:	18 97       	mov	r7,r12
80005802:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80005804:	f0 1f 00 06 	mcall	8000581c <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80005808:	0c 9b       	mov	r11,r6
8000580a:	0e 9c       	mov	r12,r7
8000580c:	f0 1f 00 05 	mcall	80005820 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80005810:	30 1b       	mov	r11,1
80005812:	0e 9c       	mov	r12,r7
80005814:	f0 1f 00 04 	mcall	80005824 <pm_switch_to_osc0+0x28>
}
80005818:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000581c:	80 00       	ld.sh	r0,r0[0x0]
8000581e:	56 90       	stdsp	sp[0x1a4],r0
80005820:	80 00       	ld.sh	r0,r0[0x0]
80005822:	56 e8       	stdsp	sp[0x1b8],r8
80005824:	80 00       	ld.sh	r0,r0[0x0]
80005826:	57 f2       	stdsp	sp[0x1fc],r2

80005828 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80005828:	78 0c       	ld.w	r12,r12[0x0]
}
8000582a:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
8000582e:	5e fc       	retal	r12

80005830 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80005830:	eb cd 40 c0 	pushm	r6-r7,lr
80005834:	18 97       	mov	r7,r12
80005836:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005838:	0e 9c       	mov	r12,r7
8000583a:	f0 1f 00 06 	mcall	80005850 <rtc_set_value+0x20>
8000583e:	cf d1       	brne	80005838 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80005840:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005842:	0e 9c       	mov	r12,r7
80005844:	f0 1f 00 03 	mcall	80005850 <rtc_set_value+0x20>
80005848:	cf d1       	brne	80005842 <rtc_set_value+0x12>
}
8000584a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000584e:	00 00       	add	r0,r0
80005850:	80 00       	ld.sh	r0,r0[0x0]
80005852:	58 28       	cp.w	r8,2

80005854 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80005854:	eb cd 40 80 	pushm	r7,lr
80005858:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
8000585a:	0e 9c       	mov	r12,r7
8000585c:	f0 1f 00 06 	mcall	80005874 <rtc_enable+0x20>
80005860:	cf d1       	brne	8000585a <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80005862:	6e 08       	ld.w	r8,r7[0x0]
80005864:	a1 a8       	sbr	r8,0x0
80005866:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005868:	0e 9c       	mov	r12,r7
8000586a:	f0 1f 00 03 	mcall	80005874 <rtc_enable+0x20>
8000586e:	cf d1       	brne	80005868 <rtc_enable+0x14>
}
80005870:	e3 cd 80 80 	ldm	sp++,r7,pc
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	58 28       	cp.w	r8,2

80005878 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80005878:	30 18       	mov	r8,1
8000587a:	99 48       	st.w	r12[0x10],r8
}
8000587c:	5e fc       	retal	r12
8000587e:	d7 03       	nop

80005880 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80005880:	eb cd 40 c0 	pushm	r6-r7,lr
80005884:	18 97       	mov	r7,r12
80005886:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80005888:	0e 9c       	mov	r12,r7
8000588a:	f0 1f 00 06 	mcall	800058a0 <rtc_set_top_value+0x20>
8000588e:	cf d1       	brne	80005888 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80005890:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80005892:	0e 9c       	mov	r12,r7
80005894:	f0 1f 00 03 	mcall	800058a0 <rtc_set_top_value+0x20>
80005898:	cf d1       	brne	80005892 <rtc_set_top_value+0x12>
}
8000589a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000589e:	00 00       	add	r0,r0
800058a0:	80 00       	ld.sh	r0,r0[0x0]
800058a2:	58 28       	cp.w	r8,2

800058a4 <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800058a4:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
800058a8:	e6 18 00 01 	andh	r8,0x1,COH
800058ac:	c0 71       	brne	800058ba <rtc_clear_interrupt+0x16>
800058ae:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
800058b0:	30 18       	mov	r8,1
800058b2:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
800058b4:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
800058b6:	d5 03       	csrf	0x10
800058b8:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
800058ba:	30 18       	mov	r8,1
800058bc:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
800058be:	78 78       	ld.w	r8,r12[0x1c]
800058c0:	5e fc       	retal	r12
800058c2:	d7 03       	nop

800058c4 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
800058c4:	eb cd 40 e0 	pushm	r5-r7,lr
800058c8:	18 97       	mov	r7,r12
800058ca:	16 96       	mov	r6,r11
800058cc:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
800058ce:	30 18       	mov	r8,1
800058d0:	f0 0b 18 00 	cp.b	r11,r8
800058d4:	5f b9       	srhi	r9
800058d6:	30 f8       	mov	r8,15
800058d8:	f0 0a 18 00 	cp.b	r10,r8
800058dc:	5f b8       	srhi	r8
800058de:	f3 e8 10 08 	or	r8,r9,r8
800058e2:	c0 30       	breq	800058e8 <rtc_init+0x24>
800058e4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
800058e8:	30 18       	mov	r8,1
800058ea:	f0 0b 18 00 	cp.b	r11,r8
800058ee:	c0 a1       	brne	80005902 <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
800058f0:	fe 7c 0c 00 	mov	r12,-62464
800058f4:	f0 1f 00 0f 	mcall	80005930 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
800058f8:	30 0b       	mov	r11,0
800058fa:	fe 7c 0c 00 	mov	r12,-62464
800058fe:	f0 1f 00 0e 	mcall	80005934 <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
80005902:	0e 9c       	mov	r12,r7
80005904:	f0 1f 00 0d 	mcall	80005938 <rtc_init+0x74>
80005908:	cf d1       	brne	80005902 <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
8000590a:	a3 76       	lsl	r6,0x3
8000590c:	b1 a6       	sbr	r6,0x10
8000590e:	ed e5 10 85 	or	r5,r6,r5<<0x8
80005912:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80005914:	0e 9c       	mov	r12,r7
80005916:	f0 1f 00 09 	mcall	80005938 <rtc_init+0x74>
8000591a:	cf d1       	brne	80005914 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
8000591c:	30 0b       	mov	r11,0
8000591e:	0e 9c       	mov	r12,r7
80005920:	f0 1f 00 07 	mcall	8000593c <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80005924:	3f fb       	mov	r11,-1
80005926:	0e 9c       	mov	r12,r7
80005928:	f0 1f 00 06 	mcall	80005940 <rtc_init+0x7c>
8000592c:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005930:	80 00       	ld.sh	r0,r0[0x0]
80005932:	57 10       	stdsp	sp[0x1c4],r0
80005934:	80 00       	ld.sh	r0,r0[0x0]
80005936:	57 3c       	stdsp	sp[0x1cc],r12
80005938:	80 00       	ld.sh	r0,r0[0x0]
8000593a:	58 28       	cp.w	r8,2
8000593c:	80 00       	ld.sh	r0,r0[0x0]
8000593e:	58 30       	cp.w	r0,3
80005940:	80 00       	ld.sh	r0,r0[0x0]
80005942:	58 80       	cp.w	r0,8

80005944 <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005944:	f8 c8 00 01 	sub	r8,r12,1
80005948:	f0 0b 00 0b 	add	r11,r8,r11
8000594c:	f6 0c 0d 0a 	divu	r10,r11,r12
80005950:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005952:	f4 c8 00 01 	sub	r8,r10,1
80005956:	e0 48 00 fe 	cp.w	r8,254
8000595a:	e0 88 00 03 	brls	80005960 <getBaudDiv+0x1c>
8000595e:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005960:	5c 8c       	casts.h	r12
}
80005962:	5e fc       	retal	r12

80005964 <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005964:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005968:	30 18       	mov	r8,1
8000596a:	f0 09 18 00 	cp.b	r9,r8
8000596e:	e0 88 00 04 	brls	80005976 <spi_initMaster+0x12>
80005972:	30 2c       	mov	r12,2
80005974:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005976:	e0 68 00 80 	mov	r8,128
8000597a:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
8000597c:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
8000597e:	30 19       	mov	r9,1
80005980:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005984:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005988:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
8000598c:	30 09       	mov	r9,0
8000598e:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005992:	30 fa       	mov	r10,15
80005994:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005998:	99 18       	st.w	r12[0x4],r8
8000599a:	5e f9       	retal	r9

8000599c <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
8000599c:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
8000599e:	30 18       	mov	r8,1
800059a0:	f0 0b 18 00 	cp.b	r11,r8
800059a4:	5f be       	srhi	lr
800059a6:	f0 0a 18 00 	cp.b	r10,r8
800059aa:	5f b8       	srhi	r8
800059ac:	fd e8 10 08 	or	r8,lr,r8
800059b0:	c0 30       	breq	800059b6 <spi_selectionMode+0x1a>
800059b2:	30 2c       	mov	r12,2
800059b4:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800059b6:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800059b8:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800059bc:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800059c0:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800059c4:	99 18       	st.w	r12[0x4],r8
800059c6:	d8 0a       	popm	pc,r12=0

800059c8 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800059c8:	30 18       	mov	r8,1
800059ca:	99 08       	st.w	r12[0x0],r8
}
800059cc:	5e fc       	retal	r12

800059ce <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800059ce:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800059d2:	c0 58       	rjmp	800059dc <spi_write+0xe>
		if (!timeout--) {
800059d4:	58 08       	cp.w	r8,0
800059d6:	c0 21       	brne	800059da <spi_write+0xc>
800059d8:	5e ff       	retal	1
800059da:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800059dc:	78 49       	ld.w	r9,r12[0x10]
800059de:	e2 19 00 02 	andl	r9,0x2,COH
800059e2:	cf 90       	breq	800059d4 <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800059e4:	5c 7b       	castu.h	r11
800059e6:	99 3b       	st.w	r12[0xc],r11
800059e8:	5e fd       	retal	0

800059ea <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800059ea:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800059ee:	c0 58       	rjmp	800059f8 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800059f0:	58 08       	cp.w	r8,0
800059f2:	c0 21       	brne	800059f6 <spi_read+0xc>
800059f4:	5e ff       	retal	1
800059f6:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800059f8:	78 49       	ld.w	r9,r12[0x10]
800059fa:	e2 19 02 01 	andl	r9,0x201,COH
800059fe:	e0 49 02 01 	cp.w	r9,513
80005a02:	cf 71       	brne	800059f0 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005a04:	78 28       	ld.w	r8,r12[0x8]
80005a06:	b6 08       	st.h	r11[0x0],r8
80005a08:	5e fd       	retal	0
80005a0a:	d7 03       	nop

80005a0c <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005a0c:	eb cd 40 f8 	pushm	r3-r7,lr
80005a10:	18 95       	mov	r5,r12
80005a12:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005a14:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005a18:	30 38       	mov	r8,3
80005a1a:	f0 06 18 00 	cp.b	r6,r8
80005a1e:	e0 8b 00 5e 	brhi	80005ada <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005a22:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005a26:	30 18       	mov	r8,1
80005a28:	f0 04 18 00 	cp.b	r4,r8
80005a2c:	e0 8b 00 57 	brhi	80005ada <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005a30:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005a34:	30 78       	mov	r8,7
80005a36:	f0 03 18 00 	cp.b	r3,r8
80005a3a:	e0 88 00 50 	brls	80005ada <spi_setupChipReg+0xce>
80005a3e:	31 08       	mov	r8,16
80005a40:	f0 03 18 00 	cp.b	r3,r8
80005a44:	e0 8b 00 4b 	brhi	80005ada <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005a48:	14 9b       	mov	r11,r10
80005a4a:	6e 1c       	ld.w	r12,r7[0x4]
80005a4c:	f0 1f 00 26 	mcall	80005ae4 <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005a50:	c4 55       	brlt	80005ada <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005a52:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005a54:	ec 09 16 01 	lsr	r9,r6,0x1
80005a58:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005a5c:	ec 16 00 01 	eorl	r6,0x1
80005a60:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005a64:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005a68:	20 83       	sub	r3,8
80005a6a:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005a6e:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005a72:	ef 39 00 09 	ld.ub	r9,r7[9]
80005a76:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005a7a:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005a7e:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005a82:	0f 89       	ld.ub	r9,r7[0x0]
80005a84:	30 1a       	mov	r10,1
80005a86:	f4 09 18 00 	cp.b	r9,r10
80005a8a:	c0 d0       	breq	80005aa4 <spi_setupChipReg+0x98>
80005a8c:	c0 a3       	brcs	80005aa0 <spi_setupChipReg+0x94>
80005a8e:	30 2a       	mov	r10,2
80005a90:	f4 09 18 00 	cp.b	r9,r10
80005a94:	c0 a0       	breq	80005aa8 <spi_setupChipReg+0x9c>
80005a96:	30 3a       	mov	r10,3
80005a98:	f4 09 18 00 	cp.b	r9,r10
80005a9c:	c1 f1       	brne	80005ada <spi_setupChipReg+0xce>
80005a9e:	c0 78       	rjmp	80005aac <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005aa0:	8b c8       	st.w	r5[0x30],r8
		break;
80005aa2:	c0 68       	rjmp	80005aae <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005aa4:	8b d8       	st.w	r5[0x34],r8
		break;
80005aa6:	c0 48       	rjmp	80005aae <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005aa8:	8b e8       	st.w	r5[0x38],r8
		break;
80005aaa:	c0 28       	rjmp	80005aae <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005aac:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005aae:	48 f8       	lddpc	r8,80005ae8 <spi_setupChipReg+0xdc>
80005ab0:	70 08       	ld.w	r8,r8[0x0]
80005ab2:	58 08       	cp.w	r8,0
80005ab4:	c1 61       	brne	80005ae0 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005ab6:	30 0b       	mov	r11,0
80005ab8:	30 1c       	mov	r12,1
80005aba:	f0 1f 00 0d 	mcall	80005aec <spi_setupChipReg+0xe0>
80005abe:	48 b8       	lddpc	r8,80005ae8 <spi_setupChipReg+0xdc>
80005ac0:	91 0c       	st.w	r8[0x0],r12
80005ac2:	58 0c       	cp.w	r12,0
80005ac4:	c0 a0       	breq	80005ad8 <spi_setupChipReg+0xcc>
80005ac6:	30 09       	mov	r9,0
80005ac8:	12 9a       	mov	r10,r9
80005aca:	12 9b       	mov	r11,r9
80005acc:	f0 1f 00 09 	mcall	80005af0 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005ad0:	48 68       	lddpc	r8,80005ae8 <spi_setupChipReg+0xdc>
80005ad2:	70 08       	ld.w	r8,r8[0x0]
80005ad4:	58 08       	cp.w	r8,0
80005ad6:	c0 51       	brne	80005ae0 <spi_setupChipReg+0xd4>
80005ad8:	c0 08       	rjmp	80005ad8 <spi_setupChipReg+0xcc>
80005ada:	30 2c       	mov	r12,2
80005adc:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005ae0:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005ae4:	80 00       	ld.sh	r0,r0[0x0]
80005ae6:	59 44       	cp.w	r4,20
80005ae8:	00 00       	add	r0,r0
80005aea:	53 bc       	stdsp	sp[0xec],r12
80005aec:	80 00       	ld.sh	r0,r0[0x0]
80005aee:	66 30       	ld.w	r0,r3[0xc]
80005af0:	80 00       	ld.sh	r0,r0[0x0]
80005af2:	64 d8       	ld.w	r8,r2[0x34]

80005af4 <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005af4:	d4 01       	pushm	lr
80005af6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005afa:	c0 58       	rjmp	80005b04 <spi_unselectChip+0x10>
		if (!timeout--) {
80005afc:	58 08       	cp.w	r8,0
80005afe:	c0 21       	brne	80005b02 <spi_unselectChip+0xe>
80005b00:	da 0a       	popm	pc,r12=1
80005b02:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005b04:	78 49       	ld.w	r9,r12[0x10]
80005b06:	e2 19 02 00 	andl	r9,0x200,COH
80005b0a:	cf 90       	breq	80005afc <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005b0c:	78 18       	ld.w	r8,r12[0x4]
80005b0e:	ea 18 00 0f 	orh	r8,0xf
80005b12:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005b14:	fc 18 01 00 	movh	r8,0x100
80005b18:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005b1a:	30 09       	mov	r9,0
80005b1c:	12 9a       	mov	r10,r9
80005b1e:	12 9b       	mov	r11,r9
80005b20:	48 38       	lddpc	r8,80005b2c <spi_unselectChip+0x38>
80005b22:	70 0c       	ld.w	r12,r8[0x0]
80005b24:	f0 1f 00 03 	mcall	80005b30 <spi_unselectChip+0x3c>
80005b28:	d8 0a       	popm	pc,r12=0
80005b2a:	00 00       	add	r0,r0
80005b2c:	00 00       	add	r0,r0
80005b2e:	53 bc       	stdsp	sp[0xec],r12
80005b30:	80 00       	ld.sh	r0,r0[0x0]
80005b32:	64 d8       	ld.w	r8,r2[0x34]

80005b34 <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005b34:	eb cd 40 f8 	pushm	r3-r7,lr
80005b38:	18 94       	mov	r4,r12
80005b3a:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005b3c:	49 a6       	lddpc	r6,80005ba4 <spi_selectChip+0x70>
80005b3e:	30 07       	mov	r7,0
80005b40:	31 45       	mov	r5,20
80005b42:	0e 99       	mov	r9,r7
80005b44:	0a 9a       	mov	r10,r5
80005b46:	0e 9b       	mov	r11,r7
80005b48:	6c 0c       	ld.w	r12,r6[0x0]
80005b4a:	f0 1f 00 18 	mcall	80005ba8 <spi_selectChip+0x74>
80005b4e:	cf a0       	breq	80005b42 <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005b50:	68 18       	ld.w	r8,r4[0x4]
80005b52:	ea 18 00 0f 	orh	r8,0xf
80005b56:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005b58:	68 18       	ld.w	r8,r4[0x4]
80005b5a:	e2 18 00 04 	andl	r8,0x4,COH
80005b5e:	c1 10       	breq	80005b80 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005b60:	30 e8       	mov	r8,14
80005b62:	f0 03 18 00 	cp.b	r3,r8
80005b66:	e0 8b 00 1c 	brhi	80005b9e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005b6a:	68 19       	ld.w	r9,r4[0x4]
80005b6c:	e6 08 15 10 	lsl	r8,r3,0x10
80005b70:	ea 18 ff f0 	orh	r8,0xfff0
80005b74:	e8 18 ff ff 	orl	r8,0xffff
80005b78:	12 68       	and	r8,r9
80005b7a:	89 18       	st.w	r4[0x4],r8
80005b7c:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005b80:	30 38       	mov	r8,3
80005b82:	f0 03 18 00 	cp.b	r3,r8
80005b86:	e0 8b 00 0c 	brhi	80005b9e <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005b8a:	68 19       	ld.w	r9,r4[0x4]
80005b8c:	2f 03       	sub	r3,-16
80005b8e:	30 18       	mov	r8,1
80005b90:	f0 03 09 48 	lsl	r8,r8,r3
80005b94:	5c d8       	com	r8
80005b96:	12 68       	and	r8,r9
80005b98:	89 18       	st.w	r4[0x4],r8
80005b9a:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005b9e:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005ba0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005ba4:	00 00       	add	r0,r0
80005ba6:	53 bc       	stdsp	sp[0xec],r12
80005ba8:	80 00       	ld.sh	r0,r0[0x0]
80005baa:	62 cc       	ld.w	r12,r1[0x30]

80005bac <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005bac:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005bae:	f6 08 15 04 	lsl	r8,r11,0x4
80005bb2:	14 38       	cp.w	r8,r10
80005bb4:	f9 b8 08 10 	movls	r8,16
80005bb8:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005bbc:	f0 0b 02 4b 	mul	r11,r8,r11
80005bc0:	f6 09 16 01 	lsr	r9,r11,0x1
80005bc4:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005bc8:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005bcc:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005bd0:	f2 cb 00 01 	sub	r11,r9,1
80005bd4:	e0 4b ff fe 	cp.w	r11,65534
80005bd8:	e0 88 00 03 	brls	80005bde <usart_set_async_baudrate+0x32>
80005bdc:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005bde:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005be0:	e8 6e 00 00 	mov	lr,524288
80005be4:	59 08       	cp.w	r8,16
80005be6:	fc 08 17 10 	movne	r8,lr
80005bea:	f9 b8 00 00 	moveq	r8,0
80005bee:	e4 1b ff f7 	andh	r11,0xfff7
80005bf2:	e0 1b fe cf 	andl	r11,0xfecf
80005bf6:	16 48       	or	r8,r11
80005bf8:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005bfa:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005bfe:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005c02:	99 89       	st.w	r12[0x20],r9
80005c04:	d8 0a       	popm	pc,r12=0

80005c06 <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005c06:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005c08:	e2 18 00 02 	andl	r8,0x2,COH
80005c0c:	c0 31       	brne	80005c12 <usart_write_char+0xc>
80005c0e:	30 2c       	mov	r12,2
80005c10:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005c12:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005c16:	99 7b       	st.w	r12[0x1c],r11
80005c18:	5e fd       	retal	0
80005c1a:	d7 03       	nop

80005c1c <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005c1c:	eb cd 40 e0 	pushm	r5-r7,lr
80005c20:	18 96       	mov	r6,r12
80005c22:	16 95       	mov	r5,r11
80005c24:	e0 67 27 0f 	mov	r7,9999
80005c28:	c0 68       	rjmp	80005c34 <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005c2a:	58 07       	cp.w	r7,0
80005c2c:	c0 31       	brne	80005c32 <usart_putchar+0x16>
80005c2e:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005c32:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005c34:	0a 9b       	mov	r11,r5
80005c36:	0c 9c       	mov	r12,r6
80005c38:	f0 1f 00 03 	mcall	80005c44 <usart_putchar+0x28>
80005c3c:	cf 71       	brne	80005c2a <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005c3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005c42:	00 00       	add	r0,r0
80005c44:	80 00       	ld.sh	r0,r0[0x0]
80005c46:	5c 06       	acr	r6

80005c48 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005c48:	78 58       	ld.w	r8,r12[0x14]
80005c4a:	e2 18 00 e0 	andl	r8,0xe0,COH
80005c4e:	c0 30       	breq	80005c54 <usart_read_char+0xc>
80005c50:	30 4c       	mov	r12,4
80005c52:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005c54:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005c56:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005c5a:	c0 31       	brne	80005c60 <usart_read_char+0x18>
80005c5c:	30 3c       	mov	r12,3
80005c5e:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005c60:	78 68       	ld.w	r8,r12[0x18]
80005c62:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005c66:	97 08       	st.w	r11[0x0],r8
80005c68:	5e fd       	retal	0
80005c6a:	d7 03       	nop

80005c6c <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005c6c:	eb cd 40 c0 	pushm	r6-r7,lr
80005c70:	20 1d       	sub	sp,4
80005c72:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005c74:	1a 97       	mov	r7,sp
80005c76:	1a 9b       	mov	r11,sp
80005c78:	0c 9c       	mov	r12,r6
80005c7a:	f0 1f 00 07 	mcall	80005c94 <usart_getchar+0x28>
80005c7e:	58 3c       	cp.w	r12,3
80005c80:	cf b0       	breq	80005c76 <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005c82:	58 4c       	cp.w	r12,4
80005c84:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005c88:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005c8c:	2f fd       	sub	sp,-4
80005c8e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005c92:	00 00       	add	r0,r0
80005c94:	80 00       	ld.sh	r0,r0[0x0]
80005c96:	5c 48       	abs	r8

80005c98 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005c98:	eb cd 40 c0 	pushm	r6-r7,lr
80005c9c:	18 96       	mov	r6,r12
80005c9e:	16 97       	mov	r7,r11
  while (*string != '\0')
80005ca0:	17 8b       	ld.ub	r11,r11[0x0]
80005ca2:	58 0b       	cp.w	r11,0
80005ca4:	c0 80       	breq	80005cb4 <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005ca6:	2f f7       	sub	r7,-1
80005ca8:	0c 9c       	mov	r12,r6
80005caa:	f0 1f 00 04 	mcall	80005cb8 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005cae:	0f 8b       	ld.ub	r11,r7[0x0]
80005cb0:	58 0b       	cp.w	r11,0
80005cb2:	cf a1       	brne	80005ca6 <usart_write_line+0xe>
80005cb4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005cb8:	80 00       	ld.sh	r0,r0[0x0]
80005cba:	5c 1c       	scr	r12

80005cbc <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005cbc:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005cc0:	e6 18 00 01 	andh	r8,0x1,COH
80005cc4:	c0 71       	brne	80005cd2 <usart_reset+0x16>
80005cc6:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005cc8:	3f f8       	mov	r8,-1
80005cca:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005ccc:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005cce:	d5 03       	csrf	0x10
80005cd0:	c0 48       	rjmp	80005cd8 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005cd2:	3f f8       	mov	r8,-1
80005cd4:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005cd6:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005cd8:	30 08       	mov	r8,0
80005cda:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005cdc:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005cde:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005ce0:	ea 68 61 0c 	mov	r8,680204
80005ce4:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005ce6:	5e fc       	retal	r12

80005ce8 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005ce8:	eb cd 40 e0 	pushm	r5-r7,lr
80005cec:	18 96       	mov	r6,r12
80005cee:	16 97       	mov	r7,r11
80005cf0:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005cf2:	f0 1f 00 2f 	mcall	80005dac <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005cf6:	58 07       	cp.w	r7,0
80005cf8:	c5 80       	breq	80005da8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005cfa:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005cfc:	30 49       	mov	r9,4
80005cfe:	f2 08 18 00 	cp.b	r8,r9
80005d02:	e0 88 00 53 	brls	80005da8 <usart_init_rs232+0xc0>
80005d06:	30 99       	mov	r9,9
80005d08:	f2 08 18 00 	cp.b	r8,r9
80005d0c:	e0 8b 00 4e 	brhi	80005da8 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005d10:	0f d9       	ld.ub	r9,r7[0x5]
80005d12:	30 78       	mov	r8,7
80005d14:	f0 09 18 00 	cp.b	r9,r8
80005d18:	e0 8b 00 48 	brhi	80005da8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005d1c:	8e 39       	ld.sh	r9,r7[0x6]
80005d1e:	e0 68 01 01 	mov	r8,257
80005d22:	f0 09 19 00 	cp.h	r9,r8
80005d26:	e0 8b 00 41 	brhi	80005da8 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005d2a:	ef 39 00 08 	ld.ub	r9,r7[8]
80005d2e:	30 38       	mov	r8,3
80005d30:	f0 09 18 00 	cp.b	r9,r8
80005d34:	e0 8b 00 3a 	brhi	80005da8 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005d38:	0a 9a       	mov	r10,r5
80005d3a:	6e 0b       	ld.w	r11,r7[0x0]
80005d3c:	0c 9c       	mov	r12,r6
80005d3e:	f0 1f 00 1d 	mcall	80005db0 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005d42:	58 1c       	cp.w	r12,1
80005d44:	c3 20       	breq	80005da8 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005d46:	0f c8       	ld.ub	r8,r7[0x4]
80005d48:	30 99       	mov	r9,9
80005d4a:	f2 08 18 00 	cp.b	r8,r9
80005d4e:	c0 51       	brne	80005d58 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005d50:	6c 18       	ld.w	r8,r6[0x4]
80005d52:	b1 b8       	sbr	r8,0x11
80005d54:	8d 18       	st.w	r6[0x4],r8
80005d56:	c0 68       	rjmp	80005d62 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005d58:	6c 19       	ld.w	r9,r6[0x4]
80005d5a:	20 58       	sub	r8,5
80005d5c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005d60:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005d62:	6c 19       	ld.w	r9,r6[0x4]
80005d64:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005d68:	0f d8       	ld.ub	r8,r7[0x5]
80005d6a:	a9 78       	lsl	r8,0x9
80005d6c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005d70:	12 48       	or	r8,r9
80005d72:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005d74:	8e 38       	ld.sh	r8,r7[0x6]
80005d76:	30 29       	mov	r9,2
80005d78:	f2 08 19 00 	cp.h	r8,r9
80005d7c:	e0 88 00 09 	brls	80005d8e <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005d80:	6c 18       	ld.w	r8,r6[0x4]
80005d82:	ad b8       	sbr	r8,0xd
80005d84:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005d86:	8e b8       	ld.uh	r8,r7[0x6]
80005d88:	20 28       	sub	r8,2
80005d8a:	8d a8       	st.w	r6[0x28],r8
80005d8c:	c0 68       	rjmp	80005d98 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005d8e:	6c 19       	ld.w	r9,r6[0x4]
80005d90:	5c 78       	castu.h	r8
80005d92:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005d96:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005d98:	6c 18       	ld.w	r8,r6[0x4]
80005d9a:	e0 18 ff f0 	andl	r8,0xfff0
80005d9e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005da0:	35 08       	mov	r8,80
80005da2:	8d 08       	st.w	r6[0x0],r8
80005da4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005da8:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005dac:	80 00       	ld.sh	r0,r0[0x0]
80005dae:	5c bc       	swap.b	r12
80005db0:	80 00       	ld.sh	r0,r0[0x0]
80005db2:	5b ac       	cp.w	r12,-6

80005db4 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005db4:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005db8:	fe c0 8d b8 	sub	r0,pc,-29256

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005dbc:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005dc0:	d5 53       	csrf	0x15
  cp      r0, r1
80005dc2:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005dc4:	e0 61 0a 48 	mov	r1,2632
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005dc8:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005dca:	c0 62       	brcc	80005dd6 <idata_load_loop_end>
  cp      r0, r1
80005dcc:	48 92       	lddpc	r2,80005df0 <udata_clear_loop_end+0x4>

80005dce <idata_load_loop>:
  brlo    idata_load_loop
80005dce:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005dd0:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005dd2:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005dd4:	cf d3       	brcs	80005dce <idata_load_loop>

80005dd6 <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005dd6:	e0 60 0a 48 	mov	r0,2632
  mov     r2, 0
  mov     r3, 0
80005dda:	e0 61 53 d0 	mov	r1,21456
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005dde:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005de0:	c0 62       	brcc	80005dec <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005de2:	30 02       	mov	r2,0
80005de4:	30 03       	mov	r3,0

80005de6 <udata_clear_loop>:
80005de6:	a1 22       	st.d	r0++,r2
80005de8:	02 30       	cp.w	r0,r1
80005dea:	cf e3       	brcs	80005de6 <udata_clear_loop>

80005dec <udata_clear_loop_end>:
80005dec:	fe cf e9 28 	sub	pc,pc,-5848
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	e4 e0 f8 c8 	ld.d	r0,r2[-1848]

80005df4 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005df4:	f8 c8 ff f8 	sub	r8,r12,-8
80005df8:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005dfa:	3f f9       	mov	r9,-1
80005dfc:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005dfe:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005e00:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005e02:	30 08       	mov	r8,0
80005e04:	99 08       	st.w	r12[0x0],r8
}
80005e06:	5e fc       	retal	r12

80005e08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005e08:	30 08       	mov	r8,0
80005e0a:	99 48       	st.w	r12[0x10],r8
}
80005e0c:	5e fc       	retal	r12

80005e0e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005e0e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005e10:	70 19       	ld.w	r9,r8[0x4]
80005e12:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005e14:	78 19       	ld.w	r9,r12[0x4]
80005e16:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005e18:	70 19       	ld.w	r9,r8[0x4]
80005e1a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005e1c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005e1e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005e20:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005e22:	78 08       	ld.w	r8,r12[0x0]
80005e24:	2f f8       	sub	r8,-1
80005e26:	99 08       	st.w	r12[0x0],r8
}
80005e28:	5e fc       	retal	r12

80005e2a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005e2a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005e2c:	5b fa       	cp.w	r10,-1
80005e2e:	c0 31       	brne	80005e34 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005e30:	78 48       	ld.w	r8,r12[0x10]
80005e32:	c0 c8       	rjmp	80005e4a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005e34:	f8 c8 ff f8 	sub	r8,r12,-8
80005e38:	70 19       	ld.w	r9,r8[0x4]
80005e3a:	72 09       	ld.w	r9,r9[0x0]
80005e3c:	12 3a       	cp.w	r10,r9
80005e3e:	c0 63       	brcs	80005e4a <vListInsert+0x20>
80005e40:	70 18       	ld.w	r8,r8[0x4]
80005e42:	70 19       	ld.w	r9,r8[0x4]
80005e44:	72 09       	ld.w	r9,r9[0x0]
80005e46:	12 3a       	cp.w	r10,r9
80005e48:	cf c2       	brcc	80005e40 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005e4a:	70 19       	ld.w	r9,r8[0x4]
80005e4c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005e4e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005e50:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005e52:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005e54:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005e56:	78 08       	ld.w	r8,r12[0x0]
80005e58:	2f f8       	sub	r8,-1
80005e5a:	99 08       	st.w	r12[0x0],r8
}
80005e5c:	5e fc       	retal	r12

80005e5e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005e5e:	78 18       	ld.w	r8,r12[0x4]
80005e60:	78 29       	ld.w	r9,r12[0x8]
80005e62:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005e64:	78 28       	ld.w	r8,r12[0x8]
80005e66:	78 19       	ld.w	r9,r12[0x4]
80005e68:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005e6a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005e6c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005e6e:	18 39       	cp.w	r9,r12
80005e70:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005e74:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005e78:	30 09       	mov	r9,0
80005e7a:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005e7c:	70 09       	ld.w	r9,r8[0x0]
80005e7e:	20 19       	sub	r9,1
80005e80:	91 09       	st.w	r8[0x0],r9
}
80005e82:	5e fc       	retal	r12

80005e84 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005e84:	e0 68 08 08 	mov	r8,2056
80005e88:	ea 18 08 08 	orh	r8,0x808
80005e8c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005e8e:	e0 68 09 09 	mov	r8,2313
80005e92:	ea 18 09 09 	orh	r8,0x909
80005e96:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005e98:	e0 68 0a 0a 	mov	r8,2570
80005e9c:	ea 18 0a 0a 	orh	r8,0xa0a
80005ea0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005ea2:	e0 68 0b 0b 	mov	r8,2827
80005ea6:	ea 18 0b 0b 	orh	r8,0xb0b
80005eaa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005eac:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005eae:	e0 68 be ef 	mov	r8,48879
80005eb2:	ea 18 de ad 	orh	r8,0xdead
80005eb6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005eb8:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005eba:	fc 18 00 40 	movh	r8,0x40
80005ebe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005ec0:	e0 68 00 ff 	mov	r8,255
80005ec4:	ea 18 ff 00 	orh	r8,0xff00
80005ec8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80005eca:	e0 68 01 01 	mov	r8,257
80005ece:	ea 18 01 01 	orh	r8,0x101
80005ed2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005ed4:	e0 68 02 02 	mov	r8,514
80005ed8:	ea 18 02 02 	orh	r8,0x202
80005edc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005ede:	e0 68 03 03 	mov	r8,771
80005ee2:	ea 18 03 03 	orh	r8,0x303
80005ee6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005ee8:	e0 68 04 04 	mov	r8,1028
80005eec:	ea 18 04 04 	orh	r8,0x404
80005ef0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005ef2:	e0 68 05 05 	mov	r8,1285
80005ef6:	ea 18 05 05 	orh	r8,0x505
80005efa:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005efc:	e0 68 06 06 	mov	r8,1542
80005f00:	ea 18 06 06 	orh	r8,0x606
80005f04:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005f06:	e0 68 07 07 	mov	r8,1799
80005f0a:	ea 18 07 07 	orh	r8,0x707
80005f0e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005f10:	30 08       	mov	r8,0
80005f12:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005f14:	5e fc       	retal	r12
80005f16:	d7 03       	nop

80005f18 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005f18:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80005f1a:	48 38       	lddpc	r8,80005f24 <vPortEnterCritical+0xc>
80005f1c:	70 09       	ld.w	r9,r8[0x0]
80005f1e:	2f f9       	sub	r9,-1
80005f20:	91 09       	st.w	r8[0x0],r9
}
80005f22:	5e fc       	retal	r12
80005f24:	00 00       	add	r0,r0
80005f26:	05 38       	ld.ub	r8,r2++

80005f28 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005f28:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80005f2a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005f2c:	30 0a       	mov	r10,0
80005f2e:	14 9b       	mov	r11,r10
80005f30:	49 2c       	lddpc	r12,80005f78 <xPortStartScheduler+0x50>
80005f32:	f0 1f 00 13 	mcall	80005f7c <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80005f36:	e0 68 5d c0 	mov	r8,24000
80005f3a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005f3e:	30 08       	mov	r8,0
80005f40:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005f44:	e0 68 0c f0 	mov	r8,3312
80005f48:	ea 18 00 00 	orh	r8,0x0
80005f4c:	70 00       	ld.w	r0,r8[0x0]
80005f4e:	60 0d       	ld.w	sp,r0[0x0]
80005f50:	1b 00       	ld.w	r0,sp++
80005f52:	e0 68 05 38 	mov	r8,1336
80005f56:	ea 18 00 00 	orh	r8,0x0
80005f5a:	91 00       	st.w	r8[0x0],r0
80005f5c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005f60:	2f ed       	sub	sp,-8
80005f62:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005f66:	fa f0 ff e0 	ld.w	r0,sp[-32]
80005f6a:	e3 b0 00 00 	mtsr	0x0,r0
80005f6e:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005f72:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80005f76:	d8 0a       	popm	pc,r12=0
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	60 44       	ld.w	r4,r0[0x10]
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	55 78       	stdsp	sp[0x15c],r8

80005f80 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005f80:	20 6d       	sub	sp,24
80005f82:	eb cd 00 ff 	pushm	r0-r7
80005f86:	fa c7 ff c0 	sub	r7,sp,-64
80005f8a:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005f8e:	ef 40 ff e0 	st.w	r7[-32],r0
80005f92:	ee f0 ff fc 	ld.w	r0,r7[-4]
80005f96:	ef 40 ff e4 	st.w	r7[-28],r0
80005f9a:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005f9e:	e0 68 05 38 	mov	r8,1336
80005fa2:	ea 18 00 00 	orh	r8,0x0
80005fa6:	70 00       	ld.w	r0,r8[0x0]
80005fa8:	1a d0       	st.w	--sp,r0
80005faa:	f0 1f 00 1a 	mcall	80006010 <LABEL_RET_SCALL_263+0x14>
80005fae:	e0 68 0c f0 	mov	r8,3312
80005fb2:	ea 18 00 00 	orh	r8,0x0
80005fb6:	70 00       	ld.w	r0,r8[0x0]
80005fb8:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80005fba:	f0 1f 00 17 	mcall	80006014 <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80005fbe:	e0 68 0c f0 	mov	r8,3312
80005fc2:	ea 18 00 00 	orh	r8,0x0
80005fc6:	70 00       	ld.w	r0,r8[0x0]
80005fc8:	60 0d       	ld.w	sp,r0[0x0]
80005fca:	1b 00       	ld.w	r0,sp++
80005fcc:	e0 68 05 38 	mov	r8,1336
80005fd0:	ea 18 00 00 	orh	r8,0x0
80005fd4:	91 00       	st.w	r8[0x0],r0
80005fd6:	fa c7 ff d8 	sub	r7,sp,-40
80005fda:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005fde:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005fe2:	e0 61 05 38 	mov	r1,1336
80005fe6:	ea 11 00 00 	orh	r1,0x0
80005fea:	62 02       	ld.w	r2,r1[0x0]
80005fec:	58 02       	cp.w	r2,0
80005fee:	c0 70       	breq	80005ffc <LABEL_RET_SCALL_263>
80005ff0:	e4 c2 00 01 	sub	r2,r2,1
80005ff4:	83 02       	st.w	r1[0x0],r2
80005ff6:	58 02       	cp.w	r2,0
80005ff8:	c0 21       	brne	80005ffc <LABEL_RET_SCALL_263>
80005ffa:	b1 c0       	cbr	r0,0x10

80005ffc <LABEL_RET_SCALL_263>:
80005ffc:	ef 40 ff f8 	st.w	r7[-8],r0
80006000:	ee f0 ff e4 	ld.w	r0,r7[-28]
80006004:	ef 40 ff fc 	st.w	r7[-4],r0
80006008:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000600c:	2f ad       	sub	sp,-24
8000600e:	d6 13       	rets
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	5f 18       	srne	r8
80006014:	80 00       	ld.sh	r0,r0[0x0]
80006016:	66 b4       	ld.w	r4,r3[0x2c]

80006018 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006018:	e1 b8 00 43 	mfsr	r8,0x10c
8000601c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006020:	5e fc       	retal	r12
80006022:	d7 03       	nop

80006024 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80006024:	48 78       	lddpc	r8,80006040 <vPortExitCritical+0x1c>
80006026:	70 08       	ld.w	r8,r8[0x0]
80006028:	58 08       	cp.w	r8,0
8000602a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
8000602c:	48 58       	lddpc	r8,80006040 <vPortExitCritical+0x1c>
8000602e:	70 09       	ld.w	r9,r8[0x0]
80006030:	20 19       	sub	r9,1
80006032:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80006034:	70 08       	ld.w	r8,r8[0x0]
80006036:	58 08       	cp.w	r8,0
80006038:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000603a:	d5 03       	csrf	0x10
8000603c:	5e fc       	retal	r12
8000603e:	00 00       	add	r0,r0
80006040:	00 00       	add	r0,r0
80006042:	05 38       	ld.ub	r8,r2++

80006044 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80006044:	eb cd 00 ff 	pushm	r0-r7
80006048:	e0 68 05 38 	mov	r8,1336
8000604c:	ea 18 00 00 	orh	r8,0x0
80006050:	70 00       	ld.w	r0,r8[0x0]
80006052:	1a d0       	st.w	--sp,r0
80006054:	7a 90       	ld.w	r0,sp[0x24]
80006056:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000605a:	58 10       	cp.w	r0,1
8000605c:	e0 8b 00 08 	brhi	8000606c <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006060:	e0 68 0c f0 	mov	r8,3312
80006064:	ea 18 00 00 	orh	r8,0x0
80006068:	70 00       	ld.w	r0,r8[0x0]
8000606a:	81 0d       	st.w	r0[0x0],sp

8000606c <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
8000606c:	f0 1f 00 12 	mcall	800060b4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80006070:	f0 1f 00 12 	mcall	800060b8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80006074:	f0 1f 00 12 	mcall	800060bc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80006078:	f0 1f 00 12 	mcall	800060c0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
8000607c:	7a 90       	ld.w	r0,sp[0x24]
8000607e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006082:	58 10       	cp.w	r0,1
80006084:	e0 8b 00 0e 	brhi	800060a0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80006088:	f0 1f 00 0c 	mcall	800060b8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
8000608c:	f0 1f 00 0e 	mcall	800060c4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80006090:	f0 1f 00 0c 	mcall	800060c0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80006094:	e0 68 0c f0 	mov	r8,3312
80006098:	ea 18 00 00 	orh	r8,0x0
8000609c:	70 00       	ld.w	r0,r8[0x0]
8000609e:	60 0d       	ld.w	sp,r0[0x0]

800060a0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800060a0:	1b 00       	ld.w	r0,sp++
800060a2:	e0 68 05 38 	mov	r8,1336
800060a6:	ea 18 00 00 	orh	r8,0x0
800060aa:	91 00       	st.w	r8[0x0],r0
800060ac:	e3 cd 00 ff 	ldm	sp++,r0-r7
800060b0:	d6 03       	rete
800060b2:	00 00       	add	r0,r0
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	60 18       	ld.w	r8,r0[0x4]
800060b8:	80 00       	ld.sh	r0,r0[0x0]
800060ba:	5f 18       	srne	r8
800060bc:	80 00       	ld.sh	r0,r0[0x0]
800060be:	68 b8       	ld.w	r8,r4[0x2c]
800060c0:	80 00       	ld.sh	r0,r0[0x0]
800060c2:	60 24       	ld.w	r4,r0[0x8]
800060c4:	80 00       	ld.sh	r0,r0[0x0]
800060c6:	66 b4       	ld.w	r4,r3[0x2c]

800060c8 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
800060c8:	d4 01       	pushm	lr
	vTaskSuspendAll();
800060ca:	f0 1f 00 02 	mcall	800060d0 <__malloc_lock+0x8>
}
800060ce:	d8 02       	popm	pc
800060d0:	80 00       	ld.sh	r0,r0[0x0]
800060d2:	66 a4       	ld.w	r4,r3[0x28]

800060d4 <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
800060d4:	d4 01       	pushm	lr
	xTaskResumeAll();
800060d6:	f0 1f 00 02 	mcall	800060dc <__malloc_unlock+0x8>
}
800060da:	d8 02       	popm	pc
800060dc:	80 00       	ld.sh	r0,r0[0x0]
800060de:	6a 60       	ld.w	r0,r5[0x18]

800060e0 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
800060e0:	d4 21       	pushm	r4-r7,lr
800060e2:	16 95       	mov	r5,r11
800060e4:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
800060e6:	58 0c       	cp.w	r12,0
800060e8:	c0 30       	breq	800060ee <_read+0xe>
800060ea:	3f f7       	mov	r7,-1
800060ec:	c1 48       	rjmp	80006114 <_read+0x34>
    return -1;

  for (; len > 0; --len)
800060ee:	58 0a       	cp.w	r10,0
800060f0:	e0 89 00 04 	brgt	800060f8 <_read+0x18>
800060f4:	30 07       	mov	r7,0
800060f6:	c0 f8       	rjmp	80006114 <_read+0x34>
800060f8:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
800060fa:	48 84       	lddpc	r4,80006118 <_read+0x38>
800060fc:	68 0c       	ld.w	r12,r4[0x0]
800060fe:	f0 1f 00 08 	mcall	8000611c <_read+0x3c>
    if (c < 0)
80006102:	c0 95       	brlt	80006114 <_read+0x34>
      break;

    *ptr++ = c;
80006104:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006108:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
8000610a:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
8000610e:	58 08       	cp.w	r8,0
80006110:	fe 99 ff f6 	brgt	800060fc <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80006114:	0e 9c       	mov	r12,r7
80006116:	d8 22       	popm	r4-r7,pc
80006118:	00 00       	add	r0,r0
8000611a:	53 c0       	stdsp	sp[0xf0],r0
8000611c:	80 00       	ld.sh	r0,r0[0x0]
8000611e:	5c 6c       	casts.b	r12

80006120 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006120:	d4 21       	pushm	r4-r7,lr
80006122:	16 95       	mov	r5,r11
80006124:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80006126:	20 1c       	sub	r12,1
80006128:	58 2c       	cp.w	r12,2
8000612a:	e0 8b 00 12 	brhi	8000614e <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
8000612e:	58 0a       	cp.w	r10,0
80006130:	c0 31       	brne	80006136 <_write+0x16>
80006132:	30 07       	mov	r7,0
80006134:	c0 e8       	rjmp	80006150 <_write+0x30>
80006136:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006138:	48 74       	lddpc	r4,80006154 <_write+0x34>
8000613a:	68 0c       	ld.w	r12,r4[0x0]
8000613c:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006140:	f0 1f 00 06 	mcall	80006158 <_write+0x38>
80006144:	c0 55       	brlt	8000614e <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80006146:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006148:	0e 36       	cp.w	r6,r7
8000614a:	cf 81       	brne	8000613a <_write+0x1a>
8000614c:	c0 28       	rjmp	80006150 <_write+0x30>
8000614e:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006150:	0e 9c       	mov	r12,r7
80006152:	d8 22       	popm	r4-r7,pc
80006154:	00 00       	add	r0,r0
80006156:	53 c0       	stdsp	sp[0xf0],r0
80006158:	80 00       	ld.sh	r0,r0[0x0]
8000615a:	5c 1c       	scr	r12

8000615c <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
8000615c:	eb cd 40 80 	pushm	r7,lr
80006160:	18 97       	mov	r7,r12
	if( pv )
80006162:	58 0c       	cp.w	r12,0
80006164:	c0 80       	breq	80006174 <vPortFree+0x18>
	{
		vTaskSuspendAll();
80006166:	f0 1f 00 05 	mcall	80006178 <vPortFree+0x1c>
		{
			free( pv );
8000616a:	0e 9c       	mov	r12,r7
8000616c:	f0 1f 00 04 	mcall	8000617c <vPortFree+0x20>
		}
		xTaskResumeAll();
80006170:	f0 1f 00 04 	mcall	80006180 <vPortFree+0x24>
80006174:	e3 cd 80 80 	ldm	sp++,r7,pc
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	66 a4       	ld.w	r4,r3[0x28]
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	75 34       	ld.w	r4,r10[0x4c]
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	6a 60       	ld.w	r0,r5[0x18]

80006184 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80006184:	eb cd 40 80 	pushm	r7,lr
80006188:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
8000618a:	f0 1f 00 06 	mcall	800061a0 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
8000618e:	0e 9c       	mov	r12,r7
80006190:	f0 1f 00 05 	mcall	800061a4 <pvPortMalloc+0x20>
80006194:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80006196:	f0 1f 00 05 	mcall	800061a8 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
8000619a:	0e 9c       	mov	r12,r7
8000619c:	e3 cd 80 80 	ldm	sp++,r7,pc
800061a0:	80 00       	ld.sh	r0,r0[0x0]
800061a2:	66 a4       	ld.w	r4,r3[0x28]
800061a4:	80 00       	ld.sh	r0,r0[0x0]
800061a6:	75 44       	ld.w	r4,r10[0x50]
800061a8:	80 00       	ld.sh	r0,r0[0x0]
800061aa:	6a 60       	ld.w	r0,r5[0x18]

800061ac <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800061ac:	d4 01       	pushm	lr
800061ae:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800061b0:	78 09       	ld.w	r9,r12[0x0]
800061b2:	58 09       	cp.w	r9,0
800061b4:	c1 10       	breq	800061d6 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800061b6:	78 3a       	ld.w	r10,r12[0xc]
800061b8:	79 09       	ld.w	r9,r12[0x40]
800061ba:	f4 09 00 09 	add	r9,r10,r9
800061be:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800061c0:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800061c2:	14 39       	cp.w	r9,r10
800061c4:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
800061c8:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
800061cc:	79 0a       	ld.w	r10,r12[0x40]
800061ce:	78 3b       	ld.w	r11,r12[0xc]
800061d0:	10 9c       	mov	r12,r8
800061d2:	f0 1f 00 02 	mcall	800061d8 <prvCopyDataFromQueue+0x2c>
800061d6:	d8 02       	popm	pc
800061d8:	80 00       	ld.sh	r0,r0[0x0]
800061da:	79 8c       	ld.w	r12,r12[0x60]

800061dc <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
800061dc:	eb cd 40 c0 	pushm	r6-r7,lr
800061e0:	18 97       	mov	r7,r12
800061e2:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800061e4:	78 e8       	ld.w	r8,r12[0x38]
800061e6:	58 08       	cp.w	r8,0
800061e8:	c0 31       	brne	800061ee <xQueueReceiveFromISR+0x12>
800061ea:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
800061ee:	f0 1f 00 0e 	mcall	80006224 <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
800061f2:	6e e8       	ld.w	r8,r7[0x38]
800061f4:	20 18       	sub	r8,1
800061f6:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
800061f8:	6f 18       	ld.w	r8,r7[0x44]
800061fa:	5b f8       	cp.w	r8,-1
800061fc:	c0 d1       	brne	80006216 <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800061fe:	6e 48       	ld.w	r8,r7[0x10]
80006200:	58 08       	cp.w	r8,0
80006202:	c0 f0       	breq	80006220 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006204:	ee cc ff f0 	sub	r12,r7,-16
80006208:	f0 1f 00 08 	mcall	80006228 <xQueueReceiveFromISR+0x4c>
8000620c:	c0 a0       	breq	80006220 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
8000620e:	30 1c       	mov	r12,1
80006210:	8d 0c       	st.w	r6[0x0],r12
80006212:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
80006216:	2f f8       	sub	r8,-1
80006218:	ef 48 00 44 	st.w	r7[68],r8
8000621c:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006220:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006224:	80 00       	ld.sh	r0,r0[0x0]
80006226:	61 ac       	ld.w	r12,r0[0x68]
80006228:	80 00       	ld.sh	r0,r0[0x0]
8000622a:	68 3c       	ld.w	r12,r4[0xc]

8000622c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000622c:	eb cd 40 c0 	pushm	r6-r7,lr
80006230:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80006232:	f0 1f 00 23 	mcall	800062bc <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006236:	6f 28       	ld.w	r8,r7[0x48]
80006238:	58 08       	cp.w	r8,0
8000623a:	e0 8a 00 18 	brle	8000626a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000623e:	6e 98       	ld.w	r8,r7[0x24]
80006240:	58 08       	cp.w	r8,0
80006242:	c1 40       	breq	8000626a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006244:	ee c6 ff dc 	sub	r6,r7,-36
80006248:	c0 48       	rjmp	80006250 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000624a:	6e 98       	ld.w	r8,r7[0x24]
8000624c:	58 08       	cp.w	r8,0
8000624e:	c0 e0       	breq	8000626a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006250:	0c 9c       	mov	r12,r6
80006252:	f0 1f 00 1c 	mcall	800062c0 <prvUnlockQueue+0x94>
80006256:	c0 30       	breq	8000625c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006258:	f0 1f 00 1b 	mcall	800062c4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
8000625c:	6f 28       	ld.w	r8,r7[0x48]
8000625e:	20 18       	sub	r8,1
80006260:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80006264:	58 08       	cp.w	r8,0
80006266:	fe 99 ff f2 	brgt	8000624a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000626a:	3f f8       	mov	r8,-1
8000626c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80006270:	f0 1f 00 16 	mcall	800062c8 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80006274:	f0 1f 00 12 	mcall	800062bc <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80006278:	6f 18       	ld.w	r8,r7[0x44]
8000627a:	58 08       	cp.w	r8,0
8000627c:	e0 8a 00 18 	brle	800062ac <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006280:	6e 48       	ld.w	r8,r7[0x10]
80006282:	58 08       	cp.w	r8,0
80006284:	c1 40       	breq	800062ac <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006286:	ee c6 ff f0 	sub	r6,r7,-16
8000628a:	c0 48       	rjmp	80006292 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000628c:	6e 48       	ld.w	r8,r7[0x10]
8000628e:	58 08       	cp.w	r8,0
80006290:	c0 e0       	breq	800062ac <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80006292:	0c 9c       	mov	r12,r6
80006294:	f0 1f 00 0b 	mcall	800062c0 <prvUnlockQueue+0x94>
80006298:	c0 30       	breq	8000629e <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
8000629a:	f0 1f 00 0b 	mcall	800062c4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
8000629e:	6f 18       	ld.w	r8,r7[0x44]
800062a0:	20 18       	sub	r8,1
800062a2:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800062a6:	58 08       	cp.w	r8,0
800062a8:	fe 99 ff f2 	brgt	8000628c <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800062ac:	3f f8       	mov	r8,-1
800062ae:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800062b2:	f0 1f 00 06 	mcall	800062c8 <prvUnlockQueue+0x9c>
}
800062b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800062ba:	00 00       	add	r0,r0
800062bc:	80 00       	ld.sh	r0,r0[0x0]
800062be:	5f 18       	srne	r8
800062c0:	80 00       	ld.sh	r0,r0[0x0]
800062c2:	68 3c       	ld.w	r12,r4[0xc]
800062c4:	80 00       	ld.sh	r0,r0[0x0]
800062c6:	67 48       	ld.w	r8,r3[0x50]
800062c8:	80 00       	ld.sh	r0,r0[0x0]
800062ca:	60 24       	ld.w	r4,r0[0x8]

800062cc <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800062cc:	d4 31       	pushm	r0-r7,lr
800062ce:	20 5d       	sub	sp,20
800062d0:	18 97       	mov	r7,r12
800062d2:	50 0b       	stdsp	sp[0x0],r11
800062d4:	50 2a       	stdsp	sp[0x8],r10
800062d6:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800062d8:	f8 c2 ff dc 	sub	r2,r12,-36
800062dc:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800062de:	fa c4 ff f4 	sub	r4,sp,-12
800062e2:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800062e4:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800062e6:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
800062ea:	f0 1f 00 3e 	mcall	800063e0 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
800062ee:	6e e8       	ld.w	r8,r7[0x38]
800062f0:	58 08       	cp.w	r8,0
800062f2:	c2 a0       	breq	80006346 <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
800062f4:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
800062f6:	40 0b       	lddsp	r11,sp[0x0]
800062f8:	0e 9c       	mov	r12,r7
800062fa:	f0 1f 00 3b 	mcall	800063e4 <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
800062fe:	40 18       	lddsp	r8,sp[0x4]
80006300:	58 08       	cp.w	r8,0
80006302:	c1 51       	brne	8000632c <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80006304:	6e e8       	ld.w	r8,r7[0x38]
80006306:	20 18       	sub	r8,1
80006308:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000630a:	6e 08       	ld.w	r8,r7[0x0]
8000630c:	58 08       	cp.w	r8,0
8000630e:	c0 41       	brne	80006316 <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006310:	f0 1f 00 36 	mcall	800063e8 <xQueueGenericReceive+0x11c>
80006314:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006316:	6e 48       	ld.w	r8,r7[0x10]
80006318:	58 08       	cp.w	r8,0
8000631a:	c1 20       	breq	8000633e <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
8000631c:	ee cc ff f0 	sub	r12,r7,-16
80006320:	f0 1f 00 33 	mcall	800063ec <xQueueGenericReceive+0x120>
80006324:	58 1c       	cp.w	r12,1
80006326:	c0 c1       	brne	8000633e <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006328:	d7 33       	scall
8000632a:	c0 a8       	rjmp	8000633e <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
8000632c:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000632e:	6e 98       	ld.w	r8,r7[0x24]
80006330:	58 08       	cp.w	r8,0
80006332:	c0 60       	breq	8000633e <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006334:	04 9c       	mov	r12,r2
80006336:	f0 1f 00 2e 	mcall	800063ec <xQueueGenericReceive+0x120>
8000633a:	c0 20       	breq	8000633e <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
8000633c:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
8000633e:	f0 1f 00 2d 	mcall	800063f0 <xQueueGenericReceive+0x124>
80006342:	30 1c       	mov	r12,1
				return pdPASS;
80006344:	c4 c8       	rjmp	800063dc <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006346:	40 28       	lddsp	r8,sp[0x8]
80006348:	58 08       	cp.w	r8,0
8000634a:	c0 51       	brne	80006354 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000634c:	f0 1f 00 29 	mcall	800063f0 <xQueueGenericReceive+0x124>
80006350:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80006352:	c4 58       	rjmp	800063dc <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80006354:	58 05       	cp.w	r5,0
80006356:	c0 51       	brne	80006360 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006358:	08 9c       	mov	r12,r4
8000635a:	f0 1f 00 27 	mcall	800063f4 <xQueueGenericReceive+0x128>
8000635e:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006360:	f0 1f 00 24 	mcall	800063f0 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006364:	f0 1f 00 25 	mcall	800063f8 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80006368:	f0 1f 00 1e 	mcall	800063e0 <xQueueGenericReceive+0x114>
8000636c:	6f 18       	ld.w	r8,r7[0x44]
8000636e:	5b f8       	cp.w	r8,-1
80006370:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006374:	6f 28       	ld.w	r8,r7[0x48]
80006376:	5b f8       	cp.w	r8,-1
80006378:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000637c:	f0 1f 00 1d 	mcall	800063f0 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006380:	06 9b       	mov	r11,r3
80006382:	08 9c       	mov	r12,r4
80006384:	f0 1f 00 1e 	mcall	800063fc <xQueueGenericReceive+0x130>
80006388:	c2 41       	brne	800063d0 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000638a:	f0 1f 00 16 	mcall	800063e0 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
8000638e:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80006390:	f0 1f 00 18 	mcall	800063f0 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
80006394:	58 06       	cp.w	r6,0
80006396:	c1 71       	brne	800063c4 <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006398:	6e 08       	ld.w	r8,r7[0x0]
8000639a:	58 08       	cp.w	r8,0
8000639c:	c0 81       	brne	800063ac <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
8000639e:	f0 1f 00 11 	mcall	800063e0 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800063a2:	6e 1c       	ld.w	r12,r7[0x4]
800063a4:	f0 1f 00 17 	mcall	80006400 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800063a8:	f0 1f 00 12 	mcall	800063f0 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800063ac:	40 2b       	lddsp	r11,sp[0x8]
800063ae:	04 9c       	mov	r12,r2
800063b0:	f0 1f 00 15 	mcall	80006404 <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800063b4:	0e 9c       	mov	r12,r7
800063b6:	f0 1f 00 15 	mcall	80006408 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800063ba:	f0 1f 00 15 	mcall	8000640c <xQueueGenericReceive+0x140>
800063be:	c9 61       	brne	800062ea <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800063c0:	d7 33       	scall
800063c2:	c9 4b       	rjmp	800062ea <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800063c4:	0e 9c       	mov	r12,r7
800063c6:	f0 1f 00 11 	mcall	80006408 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
800063ca:	f0 1f 00 11 	mcall	8000640c <xQueueGenericReceive+0x140>
800063ce:	c8 eb       	rjmp	800062ea <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
800063d0:	0e 9c       	mov	r12,r7
800063d2:	f0 1f 00 0e 	mcall	80006408 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
800063d6:	f0 1f 00 0e 	mcall	8000640c <xQueueGenericReceive+0x140>
800063da:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
800063dc:	2f bd       	sub	sp,-20
800063de:	d8 32       	popm	r0-r7,pc
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	5f 18       	srne	r8
800063e4:	80 00       	ld.sh	r0,r0[0x0]
800063e6:	61 ac       	ld.w	r12,r0[0x68]
800063e8:	80 00       	ld.sh	r0,r0[0x0]
800063ea:	67 54       	ld.w	r4,r3[0x54]
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	68 3c       	ld.w	r12,r4[0xc]
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	60 24       	ld.w	r4,r0[0x8]
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	67 30       	ld.w	r0,r3[0x4c]
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	66 a4       	ld.w	r4,r3[0x28]
800063fc:	80 00       	ld.sh	r0,r0[0x0]
800063fe:	69 cc       	ld.w	r12,r4[0x70]
80006400:	80 00       	ld.sh	r0,r0[0x0]
80006402:	67 b8       	ld.w	r8,r3[0x6c]
80006404:	80 00       	ld.sh	r0,r0[0x0]
80006406:	6c 6c       	ld.w	r12,r6[0x18]
80006408:	80 00       	ld.sh	r0,r0[0x0]
8000640a:	62 2c       	ld.w	r12,r1[0x8]
8000640c:	80 00       	ld.sh	r0,r0[0x0]
8000640e:	6a 60       	ld.w	r0,r5[0x18]

80006410 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006410:	eb cd 40 80 	pushm	r7,lr
80006414:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80006416:	79 08       	ld.w	r8,r12[0x40]
80006418:	58 08       	cp.w	r8,0
8000641a:	c0 a1       	brne	8000642e <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000641c:	78 08       	ld.w	r8,r12[0x0]
8000641e:	58 08       	cp.w	r8,0
80006420:	c2 b1       	brne	80006476 <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80006422:	78 1c       	ld.w	r12,r12[0x4]
80006424:	f0 1f 00 17 	mcall	80006480 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006428:	30 08       	mov	r8,0
8000642a:	8f 18       	st.w	r7[0x4],r8
8000642c:	c2 58       	rjmp	80006476 <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
8000642e:	58 0a       	cp.w	r10,0
80006430:	c1 01       	brne	80006450 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006432:	10 9a       	mov	r10,r8
80006434:	78 2c       	ld.w	r12,r12[0x8]
80006436:	f0 1f 00 14 	mcall	80006484 <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
8000643a:	6e 29       	ld.w	r9,r7[0x8]
8000643c:	6f 08       	ld.w	r8,r7[0x40]
8000643e:	f2 08 00 08 	add	r8,r9,r8
80006442:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
80006444:	6e 19       	ld.w	r9,r7[0x4]
80006446:	12 38       	cp.w	r8,r9
80006448:	c1 73       	brcs	80006476 <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
8000644a:	6e 08       	ld.w	r8,r7[0x0]
8000644c:	8f 28       	st.w	r7[0x8],r8
8000644e:	c1 48       	rjmp	80006476 <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006450:	10 9a       	mov	r10,r8
80006452:	78 3c       	ld.w	r12,r12[0xc]
80006454:	f0 1f 00 0c 	mcall	80006484 <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006458:	6f 08       	ld.w	r8,r7[0x40]
8000645a:	6e 39       	ld.w	r9,r7[0xc]
8000645c:	f2 08 01 08 	sub	r8,r9,r8
80006460:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
80006462:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80006464:	12 38       	cp.w	r8,r9
80006466:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
8000646a:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
8000646e:	f3 d8 e3 19 	subcs	r9,r9,r8
80006472:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
80006476:	6e e8       	ld.w	r8,r7[0x38]
80006478:	2f f8       	sub	r8,-1
8000647a:	8f e8       	st.w	r7[0x38],r8
}
8000647c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006480:	80 00       	ld.sh	r0,r0[0x0]
80006482:	67 60       	ld.w	r0,r3[0x58]
80006484:	80 00       	ld.sh	r0,r0[0x0]
80006486:	79 8c       	ld.w	r12,r12[0x60]

80006488 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80006488:	eb cd 40 c0 	pushm	r6-r7,lr
8000648c:	18 97       	mov	r7,r12
8000648e:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006490:	78 ec       	ld.w	r12,r12[0x38]
80006492:	6e f8       	ld.w	r8,r7[0x3c]
80006494:	10 3c       	cp.w	r12,r8
80006496:	c0 33       	brcs	8000649c <xQueueGenericSendFromISR+0x14>
80006498:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000649c:	12 9a       	mov	r10,r9
8000649e:	0e 9c       	mov	r12,r7
800064a0:	f0 1f 00 0c 	mcall	800064d0 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800064a4:	6f 28       	ld.w	r8,r7[0x48]
800064a6:	5b f8       	cp.w	r8,-1
800064a8:	c0 d1       	brne	800064c2 <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800064aa:	6e 98       	ld.w	r8,r7[0x24]
800064ac:	58 08       	cp.w	r8,0
800064ae:	c0 f0       	breq	800064cc <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800064b0:	ee cc ff dc 	sub	r12,r7,-36
800064b4:	f0 1f 00 08 	mcall	800064d4 <xQueueGenericSendFromISR+0x4c>
800064b8:	c0 a0       	breq	800064cc <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800064ba:	30 1c       	mov	r12,1
800064bc:	8d 0c       	st.w	r6[0x0],r12
800064be:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800064c2:	2f f8       	sub	r8,-1
800064c4:	ef 48 00 48 	st.w	r7[72],r8
800064c8:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800064cc:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800064d0:	80 00       	ld.sh	r0,r0[0x0]
800064d2:	64 10       	ld.w	r0,r2[0x4]
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	68 3c       	ld.w	r12,r4[0xc]

800064d8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
800064d8:	d4 31       	pushm	r0-r7,lr
800064da:	20 5d       	sub	sp,20
800064dc:	18 97       	mov	r7,r12
800064de:	50 0b       	stdsp	sp[0x0],r11
800064e0:	50 2a       	stdsp	sp[0x8],r10
800064e2:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800064e4:	f8 c0 ff f0 	sub	r0,r12,-16
800064e8:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
800064ea:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
800064ee:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800064f0:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
800064f4:	f0 1f 00 2f 	mcall	800065b0 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800064f8:	6e e9       	ld.w	r9,r7[0x38]
800064fa:	6e f8       	ld.w	r8,r7[0x3c]
800064fc:	10 39       	cp.w	r9,r8
800064fe:	c1 42       	brcc	80006526 <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006500:	40 1a       	lddsp	r10,sp[0x4]
80006502:	40 0b       	lddsp	r11,sp[0x0]
80006504:	0e 9c       	mov	r12,r7
80006506:	f0 1f 00 2c 	mcall	800065b4 <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8000650a:	6e 98       	ld.w	r8,r7[0x24]
8000650c:	58 08       	cp.w	r8,0
8000650e:	c0 80       	breq	8000651e <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006510:	ee cc ff dc 	sub	r12,r7,-36
80006514:	f0 1f 00 29 	mcall	800065b8 <xQueueGenericSend+0xe0>
80006518:	58 1c       	cp.w	r12,1
8000651a:	c0 21       	brne	8000651e <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
8000651c:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
8000651e:	f0 1f 00 28 	mcall	800065bc <xQueueGenericSend+0xe4>
80006522:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80006524:	c4 38       	rjmp	800065aa <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80006526:	40 28       	lddsp	r8,sp[0x8]
80006528:	58 08       	cp.w	r8,0
8000652a:	c0 51       	brne	80006534 <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8000652c:	f0 1f 00 24 	mcall	800065bc <xQueueGenericSend+0xe4>
80006530:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80006532:	c3 c8       	rjmp	800065aa <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
80006534:	58 04       	cp.w	r4,0
80006536:	c0 51       	brne	80006540 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006538:	06 9c       	mov	r12,r3
8000653a:	f0 1f 00 22 	mcall	800065c0 <xQueueGenericSend+0xe8>
8000653e:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006540:	f0 1f 00 1f 	mcall	800065bc <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80006544:	f0 1f 00 20 	mcall	800065c4 <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006548:	f0 1f 00 1a 	mcall	800065b0 <xQueueGenericSend+0xd8>
8000654c:	6f 18       	ld.w	r8,r7[0x44]
8000654e:	5b f8       	cp.w	r8,-1
80006550:	ef f1 0a 11 	st.weq	r7[0x44],r1
80006554:	6f 28       	ld.w	r8,r7[0x48]
80006556:	5b f8       	cp.w	r8,-1
80006558:	ef f1 0a 12 	st.weq	r7[0x48],r1
8000655c:	f0 1f 00 18 	mcall	800065bc <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006560:	04 9b       	mov	r11,r2
80006562:	06 9c       	mov	r12,r3
80006564:	f0 1f 00 19 	mcall	800065c8 <xQueueGenericSend+0xf0>
80006568:	c1 b1       	brne	8000659e <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000656a:	f0 1f 00 12 	mcall	800065b0 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000656e:	6e e5       	ld.w	r5,r7[0x38]
80006570:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80006572:	f0 1f 00 13 	mcall	800065bc <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
80006576:	0c 35       	cp.w	r5,r6
80006578:	c0 d1       	brne	80006592 <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000657a:	40 2b       	lddsp	r11,sp[0x8]
8000657c:	00 9c       	mov	r12,r0
8000657e:	f0 1f 00 14 	mcall	800065cc <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80006582:	0e 9c       	mov	r12,r7
80006584:	f0 1f 00 13 	mcall	800065d0 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
80006588:	f0 1f 00 13 	mcall	800065d4 <xQueueGenericSend+0xfc>
8000658c:	cb 41       	brne	800064f4 <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
8000658e:	d7 33       	scall
80006590:	cb 2b       	rjmp	800064f4 <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80006592:	0e 9c       	mov	r12,r7
80006594:	f0 1f 00 0f 	mcall	800065d0 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
80006598:	f0 1f 00 0f 	mcall	800065d4 <xQueueGenericSend+0xfc>
8000659c:	ca cb       	rjmp	800064f4 <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
8000659e:	0e 9c       	mov	r12,r7
800065a0:	f0 1f 00 0c 	mcall	800065d0 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800065a4:	f0 1f 00 0c 	mcall	800065d4 <xQueueGenericSend+0xfc>
800065a8:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800065aa:	2f bd       	sub	sp,-20
800065ac:	d8 32       	popm	r0-r7,pc
800065ae:	00 00       	add	r0,r0
800065b0:	80 00       	ld.sh	r0,r0[0x0]
800065b2:	5f 18       	srne	r8
800065b4:	80 00       	ld.sh	r0,r0[0x0]
800065b6:	64 10       	ld.w	r0,r2[0x4]
800065b8:	80 00       	ld.sh	r0,r0[0x0]
800065ba:	68 3c       	ld.w	r12,r4[0xc]
800065bc:	80 00       	ld.sh	r0,r0[0x0]
800065be:	60 24       	ld.w	r4,r0[0x8]
800065c0:	80 00       	ld.sh	r0,r0[0x0]
800065c2:	67 30       	ld.w	r0,r3[0x4c]
800065c4:	80 00       	ld.sh	r0,r0[0x0]
800065c6:	66 a4       	ld.w	r4,r3[0x28]
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	69 cc       	ld.w	r12,r4[0x70]
800065cc:	80 00       	ld.sh	r0,r0[0x0]
800065ce:	6c 6c       	ld.w	r12,r6[0x18]
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	62 2c       	ld.w	r12,r1[0x8]
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	6a 60       	ld.w	r0,r5[0x18]

800065d8 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
800065d8:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
800065dc:	34 cc       	mov	r12,76
800065de:	f0 1f 00 12 	mcall	80006624 <xQueueCreateMutex+0x4c>
800065e2:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
800065e4:	c1 d0       	breq	8000661e <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
800065e6:	30 06       	mov	r6,0
800065e8:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
800065ea:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
800065ec:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
800065ee:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800065f0:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
800065f2:	30 18       	mov	r8,1
800065f4:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
800065f6:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
800065fa:	3f f8       	mov	r8,-1
800065fc:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006600:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80006604:	2f 0c       	sub	r12,-16
80006606:	f0 1f 00 09 	mcall	80006628 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000660a:	ee cc ff dc 	sub	r12,r7,-36
8000660e:	f0 1f 00 07 	mcall	80006628 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
80006612:	0c 99       	mov	r9,r6
80006614:	0c 9a       	mov	r10,r6
80006616:	0c 9b       	mov	r11,r6
80006618:	0e 9c       	mov	r12,r7
8000661a:	f0 1f 00 05 	mcall	8000662c <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
8000661e:	0e 9c       	mov	r12,r7
80006620:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006624:	80 00       	ld.sh	r0,r0[0x0]
80006626:	61 84       	ld.w	r4,r0[0x60]
80006628:	80 00       	ld.sh	r0,r0[0x0]
8000662a:	5d f4       	*unknown*
8000662c:	80 00       	ld.sh	r0,r0[0x0]
8000662e:	64 d8       	ld.w	r8,r2[0x34]

80006630 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006630:	d4 21       	pushm	r4-r7,lr
80006632:	18 97       	mov	r7,r12
80006634:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
80006636:	58 0c       	cp.w	r12,0
80006638:	c2 f0       	breq	80006696 <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
8000663a:	34 cc       	mov	r12,76
8000663c:	f0 1f 00 17 	mcall	80006698 <xQueueCreate+0x68>
80006640:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80006642:	c2 a0       	breq	80006696 <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
80006644:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006648:	e8 cc ff ff 	sub	r12,r4,-1
8000664c:	f0 1f 00 13 	mcall	80006698 <xQueueCreate+0x68>
80006650:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80006652:	c1 e0       	breq	8000668e <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
80006654:	f8 04 00 04 	add	r4,r12,r4
80006658:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
8000665a:	30 08       	mov	r8,0
8000665c:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
8000665e:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006660:	ee c8 00 01 	sub	r8,r7,1
80006664:	ad 38       	mul	r8,r6
80006666:	10 0c       	add	r12,r8
80006668:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
8000666a:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000666c:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
80006670:	3f f8       	mov	r8,-1
80006672:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
80006676:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000667a:	ea cc ff f0 	sub	r12,r5,-16
8000667e:	f0 1f 00 08 	mcall	8000669c <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006682:	ea cc ff dc 	sub	r12,r5,-36
80006686:	f0 1f 00 06 	mcall	8000669c <xQueueCreate+0x6c>
8000668a:	0a 9c       	mov	r12,r5
8000668c:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
8000668e:	0a 9c       	mov	r12,r5
80006690:	f0 1f 00 04 	mcall	800066a0 <xQueueCreate+0x70>
80006694:	d8 2a       	popm	r4-r7,pc,r12=0
80006696:	d8 2a       	popm	r4-r7,pc,r12=0
80006698:	80 00       	ld.sh	r0,r0[0x0]
8000669a:	61 84       	ld.w	r4,r0[0x60]
8000669c:	80 00       	ld.sh	r0,r0[0x0]
8000669e:	5d f4       	*unknown*
800066a0:	80 00       	ld.sh	r0,r0[0x0]
800066a2:	61 5c       	ld.w	r12,r0[0x54]

800066a4 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800066a4:	48 38       	lddpc	r8,800066b0 <vTaskSuspendAll+0xc>
800066a6:	70 09       	ld.w	r9,r8[0x0]
800066a8:	2f f9       	sub	r9,-1
800066aa:	91 09       	st.w	r8[0x0],r9
}
800066ac:	5e fc       	retal	r12
800066ae:	00 00       	add	r0,r0
800066b0:	00 00       	add	r0,r0
800066b2:	0d 20       	ld.uh	r0,r6++

800066b4 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800066b4:	49 a8       	lddpc	r8,8000671c <vTaskSwitchContext+0x68>
800066b6:	70 08       	ld.w	r8,r8[0x0]
800066b8:	58 08       	cp.w	r8,0
800066ba:	c0 b1       	brne	800066d0 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800066bc:	49 98       	lddpc	r8,80006720 <vTaskSwitchContext+0x6c>
800066be:	70 08       	ld.w	r8,r8[0x0]
800066c0:	f0 08 00 28 	add	r8,r8,r8<<0x2
800066c4:	49 89       	lddpc	r9,80006724 <vTaskSwitchContext+0x70>
800066c6:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800066ca:	58 08       	cp.w	r8,0
800066cc:	c0 60       	breq	800066d8 <vTaskSwitchContext+0x24>
800066ce:	c1 18       	rjmp	800066f0 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800066d0:	30 19       	mov	r9,1
800066d2:	49 68       	lddpc	r8,80006728 <vTaskSwitchContext+0x74>
800066d4:	91 09       	st.w	r8[0x0],r9
800066d6:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800066d8:	49 28       	lddpc	r8,80006720 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800066da:	49 3a       	lddpc	r10,80006724 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800066dc:	70 09       	ld.w	r9,r8[0x0]
800066de:	20 19       	sub	r9,1
800066e0:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800066e2:	70 09       	ld.w	r9,r8[0x0]
800066e4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800066e8:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800066ec:	58 09       	cp.w	r9,0
800066ee:	cf 70       	breq	800066dc <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800066f0:	48 c8       	lddpc	r8,80006720 <vTaskSwitchContext+0x6c>
800066f2:	70 08       	ld.w	r8,r8[0x0]
800066f4:	f0 08 00 28 	add	r8,r8,r8<<0x2
800066f8:	48 b9       	lddpc	r9,80006724 <vTaskSwitchContext+0x70>
800066fa:	f2 08 00 28 	add	r8,r9,r8<<0x2
800066fe:	70 19       	ld.w	r9,r8[0x4]
80006700:	72 19       	ld.w	r9,r9[0x4]
80006702:	91 19       	st.w	r8[0x4],r9
80006704:	f0 ca ff f8 	sub	r10,r8,-8
80006708:	14 39       	cp.w	r9,r10
8000670a:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
8000670e:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80006712:	70 18       	ld.w	r8,r8[0x4]
80006714:	70 39       	ld.w	r9,r8[0xc]
80006716:	48 68       	lddpc	r8,8000672c <vTaskSwitchContext+0x78>
80006718:	91 09       	st.w	r8[0x0],r9
8000671a:	5e fc       	retal	r12
8000671c:	00 00       	add	r0,r0
8000671e:	0d 20       	ld.uh	r0,r6++
80006720:	00 00       	add	r0,r0
80006722:	0d 58       	ld.sh	r8,--r6
80006724:	00 00       	add	r0,r0
80006726:	0c 3c       	cp.w	r12,r6
80006728:	00 00       	add	r0,r0
8000672a:	0d 40       	ld.w	r0,--r6
8000672c:	00 00       	add	r0,r0
8000672e:	0c f0       	st.b	--r6,r0

80006730 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006730:	48 48       	lddpc	r8,80006740 <vTaskSetTimeOutState+0x10>
80006732:	70 08       	ld.w	r8,r8[0x0]
80006734:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80006736:	48 48       	lddpc	r8,80006744 <vTaskSetTimeOutState+0x14>
80006738:	70 08       	ld.w	r8,r8[0x0]
8000673a:	99 18       	st.w	r12[0x4],r8
}
8000673c:	5e fc       	retal	r12
8000673e:	00 00       	add	r0,r0
80006740:	00 00       	add	r0,r0
80006742:	0c 34       	cp.w	r4,r6
80006744:	00 00       	add	r0,r0
80006746:	0d 1c       	ld.sh	r12,r6++

80006748 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006748:	30 19       	mov	r9,1
8000674a:	48 28       	lddpc	r8,80006750 <vTaskMissedYield+0x8>
8000674c:	91 09       	st.w	r8[0x0],r9
}
8000674e:	5e fc       	retal	r12
80006750:	00 00       	add	r0,r0
80006752:	0d 40       	ld.w	r0,--r6

80006754 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80006754:	48 28       	lddpc	r8,8000675c <xTaskGetCurrentTaskHandle+0x8>
80006756:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
80006758:	5e fc       	retal	r12
8000675a:	00 00       	add	r0,r0
8000675c:	00 00       	add	r0,r0
8000675e:	0c f0       	st.b	--r6,r0

80006760 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80006760:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80006764:	58 0c       	cp.w	r12,0
80006766:	c1 f0       	breq	800067a4 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80006768:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000676a:	78 b9       	ld.w	r9,r12[0x2c]
8000676c:	79 18       	ld.w	r8,r12[0x44]
8000676e:	10 39       	cp.w	r9,r8
80006770:	c1 a0       	breq	800067a4 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80006772:	f8 c6 ff fc 	sub	r6,r12,-4
80006776:	0c 9c       	mov	r12,r6
80006778:	f0 1f 00 0c 	mcall	800067a8 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000677c:	6f 1c       	ld.w	r12,r7[0x44]
8000677e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80006780:	f8 08 11 08 	rsub	r8,r12,8
80006784:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80006786:	48 a8       	lddpc	r8,800067ac <vTaskPriorityDisinherit+0x4c>
80006788:	70 08       	ld.w	r8,r8[0x0]
8000678a:	10 3c       	cp.w	r12,r8
8000678c:	e0 88 00 04 	brls	80006794 <vTaskPriorityDisinherit+0x34>
80006790:	48 78       	lddpc	r8,800067ac <vTaskPriorityDisinherit+0x4c>
80006792:	91 0c       	st.w	r8[0x0],r12
80006794:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006798:	0c 9b       	mov	r11,r6
8000679a:	48 68       	lddpc	r8,800067b0 <vTaskPriorityDisinherit+0x50>
8000679c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800067a0:	f0 1f 00 05 	mcall	800067b4 <vTaskPriorityDisinherit+0x54>
800067a4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800067a8:	80 00       	ld.sh	r0,r0[0x0]
800067aa:	5e 5e       	retlt	-1
800067ac:	00 00       	add	r0,r0
800067ae:	0d 58       	ld.sh	r8,--r6
800067b0:	00 00       	add	r0,r0
800067b2:	0c 3c       	cp.w	r12,r6
800067b4:	80 00       	ld.sh	r0,r0[0x0]
800067b6:	5e 0e       	reteq	-1

800067b8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
800067b8:	eb cd 40 c0 	pushm	r6-r7,lr
800067bc:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
800067be:	49 b8       	lddpc	r8,80006828 <vTaskPriorityInherit+0x70>
800067c0:	70 08       	ld.w	r8,r8[0x0]
800067c2:	78 b9       	ld.w	r9,r12[0x2c]
800067c4:	70 b8       	ld.w	r8,r8[0x2c]
800067c6:	10 39       	cp.w	r9,r8
800067c8:	c2 d2       	brcc	80006822 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
800067ca:	49 88       	lddpc	r8,80006828 <vTaskPriorityInherit+0x70>
800067cc:	70 08       	ld.w	r8,r8[0x0]
800067ce:	70 b8       	ld.w	r8,r8[0x2c]
800067d0:	f0 08 11 08 	rsub	r8,r8,8
800067d4:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800067d6:	f2 09 00 28 	add	r8,r9,r9<<0x2
800067da:	49 59       	lddpc	r9,8000682c <vTaskPriorityInherit+0x74>
800067dc:	f2 08 00 28 	add	r8,r9,r8<<0x2
800067e0:	78 59       	ld.w	r9,r12[0x14]
800067e2:	10 39       	cp.w	r9,r8
800067e4:	c1 b1       	brne	8000681a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800067e6:	f8 c6 ff fc 	sub	r6,r12,-4
800067ea:	0c 9c       	mov	r12,r6
800067ec:	f0 1f 00 11 	mcall	80006830 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800067f0:	48 e8       	lddpc	r8,80006828 <vTaskPriorityInherit+0x70>
800067f2:	70 08       	ld.w	r8,r8[0x0]
800067f4:	70 bc       	ld.w	r12,r8[0x2c]
800067f6:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800067f8:	48 f8       	lddpc	r8,80006834 <vTaskPriorityInherit+0x7c>
800067fa:	70 08       	ld.w	r8,r8[0x0]
800067fc:	10 3c       	cp.w	r12,r8
800067fe:	e0 88 00 04 	brls	80006806 <vTaskPriorityInherit+0x4e>
80006802:	48 d8       	lddpc	r8,80006834 <vTaskPriorityInherit+0x7c>
80006804:	91 0c       	st.w	r8[0x0],r12
80006806:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000680a:	0c 9b       	mov	r11,r6
8000680c:	48 88       	lddpc	r8,8000682c <vTaskPriorityInherit+0x74>
8000680e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006812:	f0 1f 00 0a 	mcall	80006838 <vTaskPriorityInherit+0x80>
80006816:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000681a:	48 48       	lddpc	r8,80006828 <vTaskPriorityInherit+0x70>
8000681c:	70 08       	ld.w	r8,r8[0x0]
8000681e:	70 b8       	ld.w	r8,r8[0x2c]
80006820:	99 b8       	st.w	r12[0x2c],r8
80006822:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006826:	00 00       	add	r0,r0
80006828:	00 00       	add	r0,r0
8000682a:	0c f0       	st.b	--r6,r0
8000682c:	00 00       	add	r0,r0
8000682e:	0c 3c       	cp.w	r12,r6
80006830:	80 00       	ld.sh	r0,r0[0x0]
80006832:	5e 5e       	retlt	-1
80006834:	00 00       	add	r0,r0
80006836:	0d 58       	ld.sh	r8,--r6
80006838:	80 00       	ld.sh	r0,r0[0x0]
8000683a:	5e 0e       	reteq	-1

8000683c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
8000683c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80006840:	78 38       	ld.w	r8,r12[0xc]
80006842:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80006844:	ee c6 ff e8 	sub	r6,r7,-24
80006848:	0c 9c       	mov	r12,r6
8000684a:	f0 1f 00 15 	mcall	8000689c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
8000684e:	49 58       	lddpc	r8,800068a0 <xTaskRemoveFromEventList+0x64>
80006850:	70 08       	ld.w	r8,r8[0x0]
80006852:	58 08       	cp.w	r8,0
80006854:	c1 71       	brne	80006882 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80006856:	ee c6 ff fc 	sub	r6,r7,-4
8000685a:	0c 9c       	mov	r12,r6
8000685c:	f0 1f 00 10 	mcall	8000689c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80006860:	6e bc       	ld.w	r12,r7[0x2c]
80006862:	49 18       	lddpc	r8,800068a4 <xTaskRemoveFromEventList+0x68>
80006864:	70 08       	ld.w	r8,r8[0x0]
80006866:	10 3c       	cp.w	r12,r8
80006868:	e0 88 00 04 	brls	80006870 <xTaskRemoveFromEventList+0x34>
8000686c:	48 e8       	lddpc	r8,800068a4 <xTaskRemoveFromEventList+0x68>
8000686e:	91 0c       	st.w	r8[0x0],r12
80006870:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006874:	0c 9b       	mov	r11,r6
80006876:	48 d8       	lddpc	r8,800068a8 <xTaskRemoveFromEventList+0x6c>
80006878:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000687c:	f0 1f 00 0c 	mcall	800068ac <xTaskRemoveFromEventList+0x70>
80006880:	c0 58       	rjmp	8000688a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80006882:	0c 9b       	mov	r11,r6
80006884:	48 bc       	lddpc	r12,800068b0 <xTaskRemoveFromEventList+0x74>
80006886:	f0 1f 00 0a 	mcall	800068ac <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
8000688a:	48 b8       	lddpc	r8,800068b4 <xTaskRemoveFromEventList+0x78>
8000688c:	70 08       	ld.w	r8,r8[0x0]
8000688e:	6e b9       	ld.w	r9,r7[0x2c]
80006890:	70 b8       	ld.w	r8,r8[0x2c]
80006892:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006894:	5f 2c       	srhs	r12
80006896:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000689a:	00 00       	add	r0,r0
8000689c:	80 00       	ld.sh	r0,r0[0x0]
8000689e:	5e 5e       	retlt	-1
800068a0:	00 00       	add	r0,r0
800068a2:	0d 20       	ld.uh	r0,r6++
800068a4:	00 00       	add	r0,r0
800068a6:	0d 58       	ld.sh	r8,--r6
800068a8:	00 00       	add	r0,r0
800068aa:	0c 3c       	cp.w	r12,r6
800068ac:	80 00       	ld.sh	r0,r0[0x0]
800068ae:	5e 0e       	reteq	-1
800068b0:	00 00       	add	r0,r0
800068b2:	0c f4       	st.b	--r6,r4
800068b4:	00 00       	add	r0,r0
800068b6:	0c f0       	st.b	--r6,r0

800068b8 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
800068b8:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800068bc:	4b 98       	lddpc	r8,800069a0 <vTaskIncrementTick+0xe8>
800068be:	70 08       	ld.w	r8,r8[0x0]
800068c0:	58 08       	cp.w	r8,0
800068c2:	c6 91       	brne	80006994 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
800068c4:	4b 88       	lddpc	r8,800069a4 <vTaskIncrementTick+0xec>
800068c6:	70 09       	ld.w	r9,r8[0x0]
800068c8:	2f f9       	sub	r9,-1
800068ca:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
800068cc:	70 08       	ld.w	r8,r8[0x0]
800068ce:	58 08       	cp.w	r8,0
800068d0:	c1 a1       	brne	80006904 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
800068d2:	4b 68       	lddpc	r8,800069a8 <vTaskIncrementTick+0xf0>
800068d4:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
800068d6:	4b 69       	lddpc	r9,800069ac <vTaskIncrementTick+0xf4>
800068d8:	72 0b       	ld.w	r11,r9[0x0]
800068da:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
800068dc:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
800068de:	4b 59       	lddpc	r9,800069b0 <vTaskIncrementTick+0xf8>
800068e0:	72 0a       	ld.w	r10,r9[0x0]
800068e2:	2f fa       	sub	r10,-1
800068e4:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
800068e6:	70 08       	ld.w	r8,r8[0x0]
800068e8:	70 08       	ld.w	r8,r8[0x0]
800068ea:	58 08       	cp.w	r8,0
800068ec:	c0 51       	brne	800068f6 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
800068ee:	3f f9       	mov	r9,-1
800068f0:	4b 18       	lddpc	r8,800069b4 <vTaskIncrementTick+0xfc>
800068f2:	91 09       	st.w	r8[0x0],r9
800068f4:	c0 88       	rjmp	80006904 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
800068f6:	4a d8       	lddpc	r8,800069a8 <vTaskIncrementTick+0xf0>
800068f8:	70 08       	ld.w	r8,r8[0x0]
800068fa:	70 38       	ld.w	r8,r8[0xc]
800068fc:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
800068fe:	70 19       	ld.w	r9,r8[0x4]
80006900:	4a d8       	lddpc	r8,800069b4 <vTaskIncrementTick+0xfc>
80006902:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006904:	4a 88       	lddpc	r8,800069a4 <vTaskIncrementTick+0xec>
80006906:	70 09       	ld.w	r9,r8[0x0]
80006908:	4a b8       	lddpc	r8,800069b4 <vTaskIncrementTick+0xfc>
8000690a:	70 08       	ld.w	r8,r8[0x0]
8000690c:	10 39       	cp.w	r9,r8
8000690e:	c4 73       	brcs	8000699c <vTaskIncrementTick+0xe4>
80006910:	4a 68       	lddpc	r8,800069a8 <vTaskIncrementTick+0xf0>
80006912:	70 08       	ld.w	r8,r8[0x0]
80006914:	70 08       	ld.w	r8,r8[0x0]
80006916:	58 08       	cp.w	r8,0
80006918:	c0 c0       	breq	80006930 <vTaskIncrementTick+0x78>
8000691a:	4a 48       	lddpc	r8,800069a8 <vTaskIncrementTick+0xf0>
8000691c:	70 08       	ld.w	r8,r8[0x0]
8000691e:	70 38       	ld.w	r8,r8[0xc]
80006920:	70 37       	ld.w	r7,r8[0xc]
80006922:	6e 18       	ld.w	r8,r7[0x4]
80006924:	4a 09       	lddpc	r9,800069a4 <vTaskIncrementTick+0xec>
80006926:	72 09       	ld.w	r9,r9[0x0]
80006928:	12 38       	cp.w	r8,r9
8000692a:	e0 88 00 14 	brls	80006952 <vTaskIncrementTick+0x9a>
8000692e:	c0 e8       	rjmp	8000694a <vTaskIncrementTick+0x92>
80006930:	3f f9       	mov	r9,-1
80006932:	4a 18       	lddpc	r8,800069b4 <vTaskIncrementTick+0xfc>
80006934:	91 09       	st.w	r8[0x0],r9
80006936:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000693a:	6a 08       	ld.w	r8,r5[0x0]
8000693c:	70 38       	ld.w	r8,r8[0xc]
8000693e:	70 37       	ld.w	r7,r8[0xc]
80006940:	6e 18       	ld.w	r8,r7[0x4]
80006942:	64 09       	ld.w	r9,r2[0x0]
80006944:	12 38       	cp.w	r8,r9
80006946:	e0 88 00 0a 	brls	8000695a <vTaskIncrementTick+0xa2>
8000694a:	49 b9       	lddpc	r9,800069b4 <vTaskIncrementTick+0xfc>
8000694c:	93 08       	st.w	r9[0x0],r8
8000694e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006952:	49 a4       	lddpc	r4,800069b8 <vTaskIncrementTick+0x100>
80006954:	49 a3       	lddpc	r3,800069bc <vTaskIncrementTick+0x104>
80006956:	49 55       	lddpc	r5,800069a8 <vTaskIncrementTick+0xf0>
80006958:	49 32       	lddpc	r2,800069a4 <vTaskIncrementTick+0xec>
8000695a:	ee c6 ff fc 	sub	r6,r7,-4
8000695e:	0c 9c       	mov	r12,r6
80006960:	f0 1f 00 18 	mcall	800069c0 <vTaskIncrementTick+0x108>
80006964:	6e a8       	ld.w	r8,r7[0x28]
80006966:	58 08       	cp.w	r8,0
80006968:	c0 50       	breq	80006972 <vTaskIncrementTick+0xba>
8000696a:	ee cc ff e8 	sub	r12,r7,-24
8000696e:	f0 1f 00 15 	mcall	800069c0 <vTaskIncrementTick+0x108>
80006972:	6e bc       	ld.w	r12,r7[0x2c]
80006974:	68 08       	ld.w	r8,r4[0x0]
80006976:	10 3c       	cp.w	r12,r8
80006978:	e9 fc ba 00 	st.whi	r4[0x0],r12
8000697c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006980:	0c 9b       	mov	r11,r6
80006982:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006986:	f0 1f 00 10 	mcall	800069c4 <vTaskIncrementTick+0x10c>
8000698a:	6a 08       	ld.w	r8,r5[0x0]
8000698c:	70 08       	ld.w	r8,r8[0x0]
8000698e:	58 08       	cp.w	r8,0
80006990:	cd 51       	brne	8000693a <vTaskIncrementTick+0x82>
80006992:	cc fb       	rjmp	80006930 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006994:	48 d8       	lddpc	r8,800069c8 <vTaskIncrementTick+0x110>
80006996:	70 09       	ld.w	r9,r8[0x0]
80006998:	2f f9       	sub	r9,-1
8000699a:	91 09       	st.w	r8[0x0],r9
8000699c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800069a0:	00 00       	add	r0,r0
800069a2:	0d 20       	ld.uh	r0,r6++
800069a4:	00 00       	add	r0,r0
800069a6:	0d 1c       	ld.sh	r12,r6++
800069a8:	00 00       	add	r0,r0
800069aa:	0c 28       	rsub	r8,r6
800069ac:	00 00       	add	r0,r0
800069ae:	0c 38       	cp.w	r8,r6
800069b0:	00 00       	add	r0,r0
800069b2:	0c 34       	cp.w	r4,r6
800069b4:	00 00       	add	r0,r0
800069b6:	05 3c       	ld.ub	r12,r2++
800069b8:	00 00       	add	r0,r0
800069ba:	0d 58       	ld.sh	r8,--r6
800069bc:	00 00       	add	r0,r0
800069be:	0c 3c       	cp.w	r12,r6
800069c0:	80 00       	ld.sh	r0,r0[0x0]
800069c2:	5e 5e       	retlt	-1
800069c4:	80 00       	ld.sh	r0,r0[0x0]
800069c6:	5e 0e       	reteq	-1
800069c8:	00 00       	add	r0,r0
800069ca:	0c 20       	rsub	r0,r6

800069cc <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
800069cc:	eb cd 40 c0 	pushm	r6-r7,lr
800069d0:	18 97       	mov	r7,r12
800069d2:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
800069d4:	f0 1f 00 15 	mcall	80006a28 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
800069d8:	6c 08       	ld.w	r8,r6[0x0]
800069da:	5b f8       	cp.w	r8,-1
800069dc:	c0 31       	brne	800069e2 <xTaskCheckForTimeOut+0x16>
800069de:	30 07       	mov	r7,0
800069e0:	c1 f8       	rjmp	80006a1e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
800069e2:	49 39       	lddpc	r9,80006a2c <xTaskCheckForTimeOut+0x60>
800069e4:	72 09       	ld.w	r9,r9[0x0]
800069e6:	6e 0a       	ld.w	r10,r7[0x0]
800069e8:	12 3a       	cp.w	r10,r9
800069ea:	c0 70       	breq	800069f8 <xTaskCheckForTimeOut+0x2c>
800069ec:	49 19       	lddpc	r9,80006a30 <xTaskCheckForTimeOut+0x64>
800069ee:	72 09       	ld.w	r9,r9[0x0]
800069f0:	6e 1a       	ld.w	r10,r7[0x4]
800069f2:	12 3a       	cp.w	r10,r9
800069f4:	e0 88 00 14 	brls	80006a1c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
800069f8:	48 e9       	lddpc	r9,80006a30 <xTaskCheckForTimeOut+0x64>
800069fa:	72 0a       	ld.w	r10,r9[0x0]
800069fc:	6e 19       	ld.w	r9,r7[0x4]
800069fe:	12 1a       	sub	r10,r9
80006a00:	14 38       	cp.w	r8,r10
80006a02:	e0 88 00 0d 	brls	80006a1c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006a06:	48 ba       	lddpc	r10,80006a30 <xTaskCheckForTimeOut+0x64>
80006a08:	74 0a       	ld.w	r10,r10[0x0]
80006a0a:	14 19       	sub	r9,r10
80006a0c:	f2 08 00 08 	add	r8,r9,r8
80006a10:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006a12:	0e 9c       	mov	r12,r7
80006a14:	f0 1f 00 08 	mcall	80006a34 <xTaskCheckForTimeOut+0x68>
80006a18:	30 07       	mov	r7,0
80006a1a:	c0 28       	rjmp	80006a1e <xTaskCheckForTimeOut+0x52>
80006a1c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006a1e:	f0 1f 00 07 	mcall	80006a38 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006a22:	0e 9c       	mov	r12,r7
80006a24:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a28:	80 00       	ld.sh	r0,r0[0x0]
80006a2a:	5f 18       	srne	r8
80006a2c:	00 00       	add	r0,r0
80006a2e:	0c 34       	cp.w	r4,r6
80006a30:	00 00       	add	r0,r0
80006a32:	0d 1c       	ld.sh	r12,r6++
80006a34:	80 00       	ld.sh	r0,r0[0x0]
80006a36:	67 30       	ld.w	r0,r3[0x4c]
80006a38:	80 00       	ld.sh	r0,r0[0x0]
80006a3a:	60 24       	ld.w	r4,r0[0x8]

80006a3c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006a3c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006a40:	f0 1f 00 05 	mcall	80006a54 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006a44:	48 58       	lddpc	r8,80006a58 <xTaskGetTickCount+0x1c>
80006a46:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006a48:	f0 1f 00 05 	mcall	80006a5c <xTaskGetTickCount+0x20>

	return xTicks;
}
80006a4c:	0e 9c       	mov	r12,r7
80006a4e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a52:	00 00       	add	r0,r0
80006a54:	80 00       	ld.sh	r0,r0[0x0]
80006a56:	5f 18       	srne	r8
80006a58:	00 00       	add	r0,r0
80006a5a:	0d 1c       	ld.sh	r12,r6++
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	60 24       	ld.w	r4,r0[0x8]

80006a60 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006a60:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006a64:	f0 1f 00 2c 	mcall	80006b14 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006a68:	4a c8       	lddpc	r8,80006b18 <xTaskResumeAll+0xb8>
80006a6a:	70 09       	ld.w	r9,r8[0x0]
80006a6c:	20 19       	sub	r9,1
80006a6e:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006a70:	70 08       	ld.w	r8,r8[0x0]
80006a72:	58 08       	cp.w	r8,0
80006a74:	c4 91       	brne	80006b06 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006a76:	4a a8       	lddpc	r8,80006b1c <xTaskResumeAll+0xbc>
80006a78:	70 08       	ld.w	r8,r8[0x0]
80006a7a:	58 08       	cp.w	r8,0
80006a7c:	c4 50       	breq	80006b06 <xTaskResumeAll+0xa6>
80006a7e:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006a80:	4a 85       	lddpc	r5,80006b20 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006a82:	4a 93       	lddpc	r3,80006b24 <xTaskResumeAll+0xc4>
80006a84:	4a 92       	lddpc	r2,80006b28 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006a86:	4a a1       	lddpc	r1,80006b2c <xTaskResumeAll+0xcc>
80006a88:	c1 e8       	rjmp	80006ac4 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006a8a:	6a 38       	ld.w	r8,r5[0xc]
80006a8c:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006a8e:	ee cc ff e8 	sub	r12,r7,-24
80006a92:	f0 1f 00 28 	mcall	80006b30 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006a96:	ee c6 ff fc 	sub	r6,r7,-4
80006a9a:	0c 9c       	mov	r12,r6
80006a9c:	f0 1f 00 25 	mcall	80006b30 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006aa0:	6e bc       	ld.w	r12,r7[0x2c]
80006aa2:	66 08       	ld.w	r8,r3[0x0]
80006aa4:	10 3c       	cp.w	r12,r8
80006aa6:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006aaa:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006aae:	0c 9b       	mov	r11,r6
80006ab0:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006ab4:	f0 1f 00 20 	mcall	80006b34 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006ab8:	62 08       	ld.w	r8,r1[0x0]
80006aba:	6e b9       	ld.w	r9,r7[0x2c]
80006abc:	70 b8       	ld.w	r8,r8[0x2c]
80006abe:	10 39       	cp.w	r9,r8
80006ac0:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006ac4:	6a 08       	ld.w	r8,r5[0x0]
80006ac6:	58 08       	cp.w	r8,0
80006ac8:	ce 11       	brne	80006a8a <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006aca:	49 c8       	lddpc	r8,80006b38 <xTaskResumeAll+0xd8>
80006acc:	70 08       	ld.w	r8,r8[0x0]
80006ace:	58 08       	cp.w	r8,0
80006ad0:	c0 f0       	breq	80006aee <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006ad2:	49 a8       	lddpc	r8,80006b38 <xTaskResumeAll+0xd8>
80006ad4:	70 08       	ld.w	r8,r8[0x0]
80006ad6:	58 08       	cp.w	r8,0
80006ad8:	c1 10       	breq	80006afa <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006ada:	49 87       	lddpc	r7,80006b38 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006adc:	f0 1f 00 18 	mcall	80006b3c <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006ae0:	6e 08       	ld.w	r8,r7[0x0]
80006ae2:	20 18       	sub	r8,1
80006ae4:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006ae6:	6e 08       	ld.w	r8,r7[0x0]
80006ae8:	58 08       	cp.w	r8,0
80006aea:	cf 91       	brne	80006adc <xTaskResumeAll+0x7c>
80006aec:	c0 78       	rjmp	80006afa <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006aee:	58 14       	cp.w	r4,1
80006af0:	c0 50       	breq	80006afa <xTaskResumeAll+0x9a>
80006af2:	49 48       	lddpc	r8,80006b40 <xTaskResumeAll+0xe0>
80006af4:	70 08       	ld.w	r8,r8[0x0]
80006af6:	58 18       	cp.w	r8,1
80006af8:	c0 71       	brne	80006b06 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006afa:	30 09       	mov	r9,0
80006afc:	49 18       	lddpc	r8,80006b40 <xTaskResumeAll+0xe0>
80006afe:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006b00:	d7 33       	scall
80006b02:	30 17       	mov	r7,1
80006b04:	c0 28       	rjmp	80006b08 <xTaskResumeAll+0xa8>
80006b06:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006b08:	f0 1f 00 0f 	mcall	80006b44 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006b0c:	0e 9c       	mov	r12,r7
80006b0e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006b12:	00 00       	add	r0,r0
80006b14:	80 00       	ld.sh	r0,r0[0x0]
80006b16:	5f 18       	srne	r8
80006b18:	00 00       	add	r0,r0
80006b1a:	0d 20       	ld.uh	r0,r6++
80006b1c:	00 00       	add	r0,r0
80006b1e:	0d 3c       	ld.ub	r12,r6++
80006b20:	00 00       	add	r0,r0
80006b22:	0c f4       	st.b	--r6,r4
80006b24:	00 00       	add	r0,r0
80006b26:	0d 58       	ld.sh	r8,--r6
80006b28:	00 00       	add	r0,r0
80006b2a:	0c 3c       	cp.w	r12,r6
80006b2c:	00 00       	add	r0,r0
80006b2e:	0c f0       	st.b	--r6,r0
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	5e 5e       	retlt	-1
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	5e 0e       	reteq	-1
80006b38:	00 00       	add	r0,r0
80006b3a:	0c 20       	rsub	r0,r6
80006b3c:	80 00       	ld.sh	r0,r0[0x0]
80006b3e:	68 b8       	ld.w	r8,r4[0x2c]
80006b40:	00 00       	add	r0,r0
80006b42:	0d 40       	ld.w	r0,--r6
80006b44:	80 00       	ld.sh	r0,r0[0x0]
80006b46:	60 24       	ld.w	r4,r0[0x8]

80006b48 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006b48:	eb cd 40 80 	pushm	r7,lr
80006b4c:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006b4e:	49 08       	lddpc	r8,80006b8c <prvAddCurrentTaskToDelayedList+0x44>
80006b50:	70 08       	ld.w	r8,r8[0x0]
80006b52:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006b54:	48 f8       	lddpc	r8,80006b90 <prvAddCurrentTaskToDelayedList+0x48>
80006b56:	70 08       	ld.w	r8,r8[0x0]
80006b58:	10 3c       	cp.w	r12,r8
80006b5a:	c0 a2       	brcc	80006b6e <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b5c:	48 c8       	lddpc	r8,80006b8c <prvAddCurrentTaskToDelayedList+0x44>
80006b5e:	70 0b       	ld.w	r11,r8[0x0]
80006b60:	48 d8       	lddpc	r8,80006b94 <prvAddCurrentTaskToDelayedList+0x4c>
80006b62:	70 0c       	ld.w	r12,r8[0x0]
80006b64:	2f cb       	sub	r11,-4
80006b66:	f0 1f 00 0d 	mcall	80006b98 <prvAddCurrentTaskToDelayedList+0x50>
80006b6a:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006b6e:	48 88       	lddpc	r8,80006b8c <prvAddCurrentTaskToDelayedList+0x44>
80006b70:	70 0b       	ld.w	r11,r8[0x0]
80006b72:	48 b8       	lddpc	r8,80006b9c <prvAddCurrentTaskToDelayedList+0x54>
80006b74:	70 0c       	ld.w	r12,r8[0x0]
80006b76:	2f cb       	sub	r11,-4
80006b78:	f0 1f 00 08 	mcall	80006b98 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006b7c:	48 98       	lddpc	r8,80006ba0 <prvAddCurrentTaskToDelayedList+0x58>
80006b7e:	70 08       	ld.w	r8,r8[0x0]
80006b80:	10 37       	cp.w	r7,r8
80006b82:	c0 32       	brcc	80006b88 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006b84:	48 78       	lddpc	r8,80006ba0 <prvAddCurrentTaskToDelayedList+0x58>
80006b86:	91 07       	st.w	r8[0x0],r7
80006b88:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b8c:	00 00       	add	r0,r0
80006b8e:	0c f0       	st.b	--r6,r0
80006b90:	00 00       	add	r0,r0
80006b92:	0d 1c       	ld.sh	r12,r6++
80006b94:	00 00       	add	r0,r0
80006b96:	0c 38       	cp.w	r8,r6
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	5e 2a       	reths	r10
80006b9c:	00 00       	add	r0,r0
80006b9e:	0c 28       	rsub	r8,r6
80006ba0:	00 00       	add	r0,r0
80006ba2:	05 3c       	ld.ub	r12,r2++

80006ba4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006ba4:	eb cd 40 c0 	pushm	r6-r7,lr
80006ba8:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006baa:	58 0c       	cp.w	r12,0
80006bac:	c1 10       	breq	80006bce <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006bae:	f0 1f 00 0a 	mcall	80006bd4 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006bb2:	48 a8       	lddpc	r8,80006bd8 <vTaskDelay+0x34>
80006bb4:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006bb6:	48 a8       	lddpc	r8,80006bdc <vTaskDelay+0x38>
80006bb8:	70 0c       	ld.w	r12,r8[0x0]
80006bba:	2f cc       	sub	r12,-4
80006bbc:	f0 1f 00 09 	mcall	80006be0 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006bc0:	ee 06 00 0c 	add	r12,r7,r6
80006bc4:	f0 1f 00 08 	mcall	80006be4 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006bc8:	f0 1f 00 08 	mcall	80006be8 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006bcc:	c0 21       	brne	80006bd0 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006bce:	d7 33       	scall
80006bd0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006bd4:	80 00       	ld.sh	r0,r0[0x0]
80006bd6:	66 a4       	ld.w	r4,r3[0x28]
80006bd8:	00 00       	add	r0,r0
80006bda:	0d 1c       	ld.sh	r12,r6++
80006bdc:	00 00       	add	r0,r0
80006bde:	0c f0       	st.b	--r6,r0
80006be0:	80 00       	ld.sh	r0,r0[0x0]
80006be2:	5e 5e       	retlt	-1
80006be4:	80 00       	ld.sh	r0,r0[0x0]
80006be6:	6b 48       	ld.w	r8,r5[0x50]
80006be8:	80 00       	ld.sh	r0,r0[0x0]
80006bea:	6a 60       	ld.w	r0,r5[0x18]

80006bec <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006bec:	eb cd 40 c0 	pushm	r6-r7,lr
80006bf0:	18 96       	mov	r6,r12
80006bf2:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006bf4:	f0 1f 00 18 	mcall	80006c54 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006bf8:	6c 08       	ld.w	r8,r6[0x0]
80006bfa:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006bfc:	49 79       	lddpc	r9,80006c58 <vTaskDelayUntil+0x6c>
80006bfe:	72 09       	ld.w	r9,r9[0x0]
80006c00:	12 38       	cp.w	r8,r9
80006c02:	e0 88 00 0c 	brls	80006c1a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006c06:	0e 38       	cp.w	r8,r7
80006c08:	e0 88 00 22 	brls	80006c4c <vTaskDelayUntil+0x60>
80006c0c:	49 38       	lddpc	r8,80006c58 <vTaskDelayUntil+0x6c>
80006c0e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006c10:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006c12:	10 37       	cp.w	r7,r8
80006c14:	e0 88 00 14 	brls	80006c3c <vTaskDelayUntil+0x50>
80006c18:	c0 a8       	rjmp	80006c2c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006c1a:	0e 38       	cp.w	r8,r7
80006c1c:	e0 8b 00 16 	brhi	80006c48 <vTaskDelayUntil+0x5c>
80006c20:	48 e8       	lddpc	r8,80006c58 <vTaskDelayUntil+0x6c>
80006c22:	70 08       	ld.w	r8,r8[0x0]
80006c24:	10 37       	cp.w	r7,r8
80006c26:	e0 8b 00 11 	brhi	80006c48 <vTaskDelayUntil+0x5c>
80006c2a:	c1 18       	rjmp	80006c4c <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006c2c:	48 c8       	lddpc	r8,80006c5c <vTaskDelayUntil+0x70>
80006c2e:	70 0c       	ld.w	r12,r8[0x0]
80006c30:	2f cc       	sub	r12,-4
80006c32:	f0 1f 00 0c 	mcall	80006c60 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006c36:	0e 9c       	mov	r12,r7
80006c38:	f0 1f 00 0b 	mcall	80006c64 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006c3c:	f0 1f 00 0b 	mcall	80006c68 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006c40:	c0 81       	brne	80006c50 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006c42:	d7 33       	scall
80006c44:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006c48:	8d 07       	st.w	r6[0x0],r7
80006c4a:	cf 1b       	rjmp	80006c2c <vTaskDelayUntil+0x40>
80006c4c:	8d 07       	st.w	r6[0x0],r7
80006c4e:	cf 7b       	rjmp	80006c3c <vTaskDelayUntil+0x50>
80006c50:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006c54:	80 00       	ld.sh	r0,r0[0x0]
80006c56:	66 a4       	ld.w	r4,r3[0x28]
80006c58:	00 00       	add	r0,r0
80006c5a:	0d 1c       	ld.sh	r12,r6++
80006c5c:	00 00       	add	r0,r0
80006c5e:	0c f0       	st.b	--r6,r0
80006c60:	80 00       	ld.sh	r0,r0[0x0]
80006c62:	5e 5e       	retlt	-1
80006c64:	80 00       	ld.sh	r0,r0[0x0]
80006c66:	6b 48       	ld.w	r8,r5[0x50]
80006c68:	80 00       	ld.sh	r0,r0[0x0]
80006c6a:	6a 60       	ld.w	r0,r5[0x18]

80006c6c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006c6c:	eb cd 40 c0 	pushm	r6-r7,lr
80006c70:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006c72:	48 e7       	lddpc	r7,80006ca8 <vTaskPlaceOnEventList+0x3c>
80006c74:	6e 0b       	ld.w	r11,r7[0x0]
80006c76:	2e 8b       	sub	r11,-24
80006c78:	f0 1f 00 0d 	mcall	80006cac <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006c7c:	6e 0c       	ld.w	r12,r7[0x0]
80006c7e:	2f cc       	sub	r12,-4
80006c80:	f0 1f 00 0c 	mcall	80006cb0 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006c84:	5b f6       	cp.w	r6,-1
80006c86:	c0 81       	brne	80006c96 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006c88:	6e 0b       	ld.w	r11,r7[0x0]
80006c8a:	2f cb       	sub	r11,-4
80006c8c:	48 ac       	lddpc	r12,80006cb4 <vTaskPlaceOnEventList+0x48>
80006c8e:	f0 1f 00 0b 	mcall	80006cb8 <vTaskPlaceOnEventList+0x4c>
80006c92:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006c96:	48 a8       	lddpc	r8,80006cbc <vTaskPlaceOnEventList+0x50>
80006c98:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006c9a:	ec 0c 00 0c 	add	r12,r6,r12
80006c9e:	f0 1f 00 09 	mcall	80006cc0 <vTaskPlaceOnEventList+0x54>
80006ca2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006ca6:	00 00       	add	r0,r0
80006ca8:	00 00       	add	r0,r0
80006caa:	0c f0       	st.b	--r6,r0
80006cac:	80 00       	ld.sh	r0,r0[0x0]
80006cae:	5e 2a       	reths	r10
80006cb0:	80 00       	ld.sh	r0,r0[0x0]
80006cb2:	5e 5e       	retlt	-1
80006cb4:	00 00       	add	r0,r0
80006cb6:	0d 44       	ld.w	r4,--r6
80006cb8:	80 00       	ld.sh	r0,r0[0x0]
80006cba:	5e 0e       	reteq	-1
80006cbc:	00 00       	add	r0,r0
80006cbe:	0d 1c       	ld.sh	r12,r6++
80006cc0:	80 00       	ld.sh	r0,r0[0x0]
80006cc2:	6b 48       	ld.w	r8,r5[0x50]

80006cc4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006cc4:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006cc8:	49 67       	lddpc	r7,80006d20 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006cca:	49 74       	lddpc	r4,80006d24 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006ccc:	49 73       	lddpc	r3,80006d28 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006cce:	49 85       	lddpc	r5,80006d2c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006cd0:	6e 08       	ld.w	r8,r7[0x0]
80006cd2:	58 08       	cp.w	r8,0
80006cd4:	c1 e0       	breq	80006d10 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006cd6:	f0 1f 00 17 	mcall	80006d30 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006cda:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006cdc:	f0 1f 00 16 	mcall	80006d34 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006ce0:	58 06       	cp.w	r6,0
80006ce2:	c1 70       	breq	80006d10 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006ce4:	f0 1f 00 15 	mcall	80006d38 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006ce8:	68 38       	ld.w	r8,r4[0xc]
80006cea:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006cec:	ec cc ff fc 	sub	r12,r6,-4
80006cf0:	f0 1f 00 13 	mcall	80006d3c <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006cf4:	66 08       	ld.w	r8,r3[0x0]
80006cf6:	20 18       	sub	r8,1
80006cf8:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006cfa:	6e 08       	ld.w	r8,r7[0x0]
80006cfc:	20 18       	sub	r8,1
80006cfe:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006d00:	f0 1f 00 10 	mcall	80006d40 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006d04:	6c cc       	ld.w	r12,r6[0x30]
80006d06:	f0 1f 00 10 	mcall	80006d44 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006d0a:	0c 9c       	mov	r12,r6
80006d0c:	f0 1f 00 0e 	mcall	80006d44 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006d10:	6a 08       	ld.w	r8,r5[0x0]
80006d12:	58 18       	cp.w	r8,1
80006d14:	e0 88 00 03 	brls	80006d1a <prvIdleTask+0x56>
			{
				taskYIELD();
80006d18:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006d1a:	f0 1f 00 0c 	mcall	80006d48 <prvIdleTask+0x84>
		}
		#endif
	}
80006d1e:	cd 9b       	rjmp	80006cd0 <prvIdleTask+0xc>
80006d20:	00 00       	add	r0,r0
80006d22:	0c 30       	cp.w	r0,r6
80006d24:	00 00       	add	r0,r0
80006d26:	0c dc       	st.w	--r6,r12
80006d28:	00 00       	add	r0,r0
80006d2a:	0d 3c       	ld.ub	r12,r6++
80006d2c:	00 00       	add	r0,r0
80006d2e:	0c 3c       	cp.w	r12,r6
80006d30:	80 00       	ld.sh	r0,r0[0x0]
80006d32:	66 a4       	ld.w	r4,r3[0x28]
80006d34:	80 00       	ld.sh	r0,r0[0x0]
80006d36:	6a 60       	ld.w	r0,r5[0x18]
80006d38:	80 00       	ld.sh	r0,r0[0x0]
80006d3a:	5f 18       	srne	r8
80006d3c:	80 00       	ld.sh	r0,r0[0x0]
80006d3e:	5e 5e       	retlt	-1
80006d40:	80 00       	ld.sh	r0,r0[0x0]
80006d42:	60 24       	ld.w	r4,r0[0x8]
80006d44:	80 00       	ld.sh	r0,r0[0x0]
80006d46:	61 5c       	ld.w	r12,r0[0x54]
80006d48:	80 00       	ld.sh	r0,r0[0x0]
80006d4a:	20 2c       	sub	r12,2

80006d4c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006d4c:	d4 31       	pushm	r0-r7,lr
80006d4e:	20 1d       	sub	sp,4
80006d50:	fa c4 ff d8 	sub	r4,sp,-40
80006d54:	50 0c       	stdsp	sp[0x0],r12
80006d56:	16 91       	mov	r1,r11
80006d58:	14 97       	mov	r7,r10
80006d5a:	12 90       	mov	r0,r9
80006d5c:	10 93       	mov	r3,r8
80006d5e:	68 02       	ld.w	r2,r4[0x0]
80006d60:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006d62:	34 8c       	mov	r12,72
80006d64:	f0 1f 00 5c 	mcall	80006ed4 <xTaskGenericCreate+0x188>
80006d68:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006d6a:	c0 31       	brne	80006d70 <xTaskGenericCreate+0x24>
80006d6c:	3f fc       	mov	r12,-1
80006d6e:	ca f8       	rjmp	80006ecc <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006d70:	58 06       	cp.w	r6,0
80006d72:	e0 81 00 af 	brne	80006ed0 <xTaskGenericCreate+0x184>
80006d76:	0e 9c       	mov	r12,r7
80006d78:	5c 7c       	castu.h	r12
80006d7a:	a3 6c       	lsl	r12,0x2
80006d7c:	f0 1f 00 56 	mcall	80006ed4 <xTaskGenericCreate+0x188>
80006d80:	18 96       	mov	r6,r12
80006d82:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006d84:	c0 61       	brne	80006d90 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006d86:	0a 9c       	mov	r12,r5
80006d88:	f0 1f 00 54 	mcall	80006ed8 <xTaskGenericCreate+0x18c>
80006d8c:	3f fc       	mov	r12,-1
80006d8e:	c9 f8       	rjmp	80006ecc <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006d90:	5c 77       	castu.h	r7
80006d92:	ee 0a 15 02 	lsl	r10,r7,0x2
80006d96:	e0 6b 00 a5 	mov	r11,165
80006d9a:	0c 9c       	mov	r12,r6
80006d9c:	f0 1f 00 50 	mcall	80006edc <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006da0:	ee c6 00 01 	sub	r6,r7,1
80006da4:	6a c8       	ld.w	r8,r5[0x30]
80006da6:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006daa:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006dae:	31 0a       	mov	r10,16
80006db0:	02 9b       	mov	r11,r1
80006db2:	ea cc ff cc 	sub	r12,r5,-52
80006db6:	f0 1f 00 4b 	mcall	80006ee0 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006dba:	30 08       	mov	r8,0
80006dbc:	eb 68 00 43 	st.b	r5[67],r8
80006dc0:	58 73       	cp.w	r3,7
80006dc2:	e6 07 17 80 	movls	r7,r3
80006dc6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006dca:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006dcc:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006dd0:	ea c4 ff fc 	sub	r4,r5,-4
80006dd4:	08 9c       	mov	r12,r4
80006dd6:	f0 1f 00 44 	mcall	80006ee4 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006dda:	ea cc ff e8 	sub	r12,r5,-24
80006dde:	f0 1f 00 42 	mcall	80006ee4 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006de2:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006de4:	ee 07 11 08 	rsub	r7,r7,8
80006de8:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006dea:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006dec:	00 9a       	mov	r10,r0
80006dee:	40 0b       	lddsp	r11,sp[0x0]
80006df0:	0c 9c       	mov	r12,r6
80006df2:	f0 1f 00 3e 	mcall	80006ee8 <xTaskGenericCreate+0x19c>
80006df6:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006df8:	58 02       	cp.w	r2,0
80006dfa:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006dfe:	f0 1f 00 3c 	mcall	80006eec <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006e02:	4b c8       	lddpc	r8,80006ef0 <xTaskGenericCreate+0x1a4>
80006e04:	70 09       	ld.w	r9,r8[0x0]
80006e06:	2f f9       	sub	r9,-1
80006e08:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006e0a:	4b b8       	lddpc	r8,80006ef4 <xTaskGenericCreate+0x1a8>
80006e0c:	70 08       	ld.w	r8,r8[0x0]
80006e0e:	58 08       	cp.w	r8,0
80006e10:	c2 61       	brne	80006e5c <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006e12:	4b 98       	lddpc	r8,80006ef4 <xTaskGenericCreate+0x1a8>
80006e14:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006e16:	4b 78       	lddpc	r8,80006ef0 <xTaskGenericCreate+0x1a4>
80006e18:	70 08       	ld.w	r8,r8[0x0]
80006e1a:	58 18       	cp.w	r8,1
80006e1c:	c2 b1       	brne	80006e72 <xTaskGenericCreate+0x126>
80006e1e:	4b 77       	lddpc	r7,80006ef8 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006e20:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006e24:	0e 9c       	mov	r12,r7
80006e26:	f0 1f 00 36 	mcall	80006efc <xTaskGenericCreate+0x1b0>
80006e2a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006e2c:	0c 37       	cp.w	r7,r6
80006e2e:	cf b1       	brne	80006e24 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006e30:	4b 47       	lddpc	r7,80006f00 <xTaskGenericCreate+0x1b4>
80006e32:	0e 9c       	mov	r12,r7
80006e34:	f0 1f 00 32 	mcall	80006efc <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006e38:	4b 36       	lddpc	r6,80006f04 <xTaskGenericCreate+0x1b8>
80006e3a:	0c 9c       	mov	r12,r6
80006e3c:	f0 1f 00 30 	mcall	80006efc <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006e40:	4b 2c       	lddpc	r12,80006f08 <xTaskGenericCreate+0x1bc>
80006e42:	f0 1f 00 2f 	mcall	80006efc <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006e46:	4b 2c       	lddpc	r12,80006f0c <xTaskGenericCreate+0x1c0>
80006e48:	f0 1f 00 2d 	mcall	80006efc <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006e4c:	4b 1c       	lddpc	r12,80006f10 <xTaskGenericCreate+0x1c4>
80006e4e:	f0 1f 00 2c 	mcall	80006efc <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006e52:	4b 18       	lddpc	r8,80006f14 <xTaskGenericCreate+0x1c8>
80006e54:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006e56:	4b 18       	lddpc	r8,80006f18 <xTaskGenericCreate+0x1cc>
80006e58:	91 06       	st.w	r8[0x0],r6
80006e5a:	c0 c8       	rjmp	80006e72 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006e5c:	4b 08       	lddpc	r8,80006f1c <xTaskGenericCreate+0x1d0>
80006e5e:	70 08       	ld.w	r8,r8[0x0]
80006e60:	58 08       	cp.w	r8,0
80006e62:	c0 81       	brne	80006e72 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006e64:	4a 48       	lddpc	r8,80006ef4 <xTaskGenericCreate+0x1a8>
80006e66:	70 08       	ld.w	r8,r8[0x0]
80006e68:	70 b8       	ld.w	r8,r8[0x2c]
80006e6a:	10 33       	cp.w	r3,r8
80006e6c:	c0 33       	brcs	80006e72 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006e6e:	4a 28       	lddpc	r8,80006ef4 <xTaskGenericCreate+0x1a8>
80006e70:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006e72:	6a b8       	ld.w	r8,r5[0x2c]
80006e74:	4a b9       	lddpc	r9,80006f20 <xTaskGenericCreate+0x1d4>
80006e76:	72 09       	ld.w	r9,r9[0x0]
80006e78:	12 38       	cp.w	r8,r9
80006e7a:	e0 88 00 04 	brls	80006e82 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006e7e:	4a 99       	lddpc	r9,80006f20 <xTaskGenericCreate+0x1d4>
80006e80:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006e82:	4a 98       	lddpc	r8,80006f24 <xTaskGenericCreate+0x1d8>
80006e84:	70 09       	ld.w	r9,r8[0x0]
80006e86:	2f f9       	sub	r9,-1
80006e88:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006e8a:	6a b8       	ld.w	r8,r5[0x2c]
80006e8c:	4a 79       	lddpc	r9,80006f28 <xTaskGenericCreate+0x1dc>
80006e8e:	72 09       	ld.w	r9,r9[0x0]
80006e90:	12 38       	cp.w	r8,r9
80006e92:	e0 88 00 04 	brls	80006e9a <xTaskGenericCreate+0x14e>
80006e96:	4a 59       	lddpc	r9,80006f28 <xTaskGenericCreate+0x1dc>
80006e98:	93 08       	st.w	r9[0x0],r8
80006e9a:	6a bc       	ld.w	r12,r5[0x2c]
80006e9c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006ea0:	08 9b       	mov	r11,r4
80006ea2:	49 68       	lddpc	r8,80006ef8 <xTaskGenericCreate+0x1ac>
80006ea4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006ea8:	f0 1f 00 21 	mcall	80006f2c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80006eac:	f0 1f 00 21 	mcall	80006f30 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80006eb0:	49 b8       	lddpc	r8,80006f1c <xTaskGenericCreate+0x1d0>
80006eb2:	70 08       	ld.w	r8,r8[0x0]
80006eb4:	58 08       	cp.w	r8,0
80006eb6:	c0 a0       	breq	80006eca <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006eb8:	48 f8       	lddpc	r8,80006ef4 <xTaskGenericCreate+0x1a8>
80006eba:	70 08       	ld.w	r8,r8[0x0]
80006ebc:	70 b8       	ld.w	r8,r8[0x2c]
80006ebe:	10 33       	cp.w	r3,r8
80006ec0:	e0 88 00 05 	brls	80006eca <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80006ec4:	d7 33       	scall
80006ec6:	30 1c       	mov	r12,1
80006ec8:	c0 28       	rjmp	80006ecc <xTaskGenericCreate+0x180>
80006eca:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80006ecc:	2f fd       	sub	sp,-4
80006ece:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006ed0:	99 c6       	st.w	r12[0x30],r6
80006ed2:	c5 fb       	rjmp	80006d90 <xTaskGenericCreate+0x44>
80006ed4:	80 00       	ld.sh	r0,r0[0x0]
80006ed6:	61 84       	ld.w	r4,r0[0x60]
80006ed8:	80 00       	ld.sh	r0,r0[0x0]
80006eda:	61 5c       	ld.w	r12,r0[0x54]
80006edc:	80 00       	ld.sh	r0,r0[0x0]
80006ede:	7a d4       	ld.w	r4,sp[0x34]
80006ee0:	80 00       	ld.sh	r0,r0[0x0]
80006ee2:	7e 00       	ld.w	r0,pc[0x0]
80006ee4:	80 00       	ld.sh	r0,r0[0x0]
80006ee6:	5e 08       	reteq	r8
80006ee8:	80 00       	ld.sh	r0,r0[0x0]
80006eea:	5e 84       	retls	r4
80006eec:	80 00       	ld.sh	r0,r0[0x0]
80006eee:	5f 18       	srne	r8
80006ef0:	00 00       	add	r0,r0
80006ef2:	0d 3c       	ld.ub	r12,r6++
80006ef4:	00 00       	add	r0,r0
80006ef6:	0c f0       	st.b	--r6,r0
80006ef8:	00 00       	add	r0,r0
80006efa:	0c 3c       	cp.w	r12,r6
80006efc:	80 00       	ld.sh	r0,r0[0x0]
80006efe:	5d f4       	*unknown*
80006f00:	00 00       	add	r0,r0
80006f02:	0d 08       	ld.w	r8,r6++
80006f04:	00 00       	add	r0,r0
80006f06:	0d 24       	ld.uh	r4,r6++
80006f08:	00 00       	add	r0,r0
80006f0a:	0c f4       	st.b	--r6,r4
80006f0c:	00 00       	add	r0,r0
80006f0e:	0c dc       	st.w	--r6,r12
80006f10:	00 00       	add	r0,r0
80006f12:	0d 44       	ld.w	r4,--r6
80006f14:	00 00       	add	r0,r0
80006f16:	0c 28       	rsub	r8,r6
80006f18:	00 00       	add	r0,r0
80006f1a:	0c 38       	cp.w	r8,r6
80006f1c:	00 00       	add	r0,r0
80006f1e:	0c 2c       	rsub	r12,r6
80006f20:	00 00       	add	r0,r0
80006f22:	0c 24       	rsub	r4,r6
80006f24:	00 00       	add	r0,r0
80006f26:	0d 38       	ld.ub	r8,r6++
80006f28:	00 00       	add	r0,r0
80006f2a:	0d 58       	ld.sh	r8,--r6
80006f2c:	80 00       	ld.sh	r0,r0[0x0]
80006f2e:	5e 0e       	reteq	-1
80006f30:	80 00       	ld.sh	r0,r0[0x0]
80006f32:	60 24       	ld.w	r4,r0[0x8]

80006f34 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006f34:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006f36:	30 09       	mov	r9,0
80006f38:	1a d9       	st.w	--sp,r9
80006f3a:	1a d9       	st.w	--sp,r9
80006f3c:	1a d9       	st.w	--sp,r9
80006f3e:	12 98       	mov	r8,r9
80006f40:	e0 6a 01 00 	mov	r10,256
80006f44:	48 9b       	lddpc	r11,80006f68 <vTaskStartScheduler+0x34>
80006f46:	48 ac       	lddpc	r12,80006f6c <vTaskStartScheduler+0x38>
80006f48:	f0 1f 00 0a 	mcall	80006f70 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006f4c:	2f dd       	sub	sp,-12
80006f4e:	58 1c       	cp.w	r12,1
80006f50:	c0 a1       	brne	80006f64 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80006f52:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006f54:	30 19       	mov	r9,1
80006f56:	48 88       	lddpc	r8,80006f74 <vTaskStartScheduler+0x40>
80006f58:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006f5a:	30 09       	mov	r9,0
80006f5c:	48 78       	lddpc	r8,80006f78 <vTaskStartScheduler+0x44>
80006f5e:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006f60:	f0 1f 00 07 	mcall	80006f7c <vTaskStartScheduler+0x48>
80006f64:	d8 02       	popm	pc
80006f66:	00 00       	add	r0,r0
80006f68:	80 00       	ld.sh	r0,r0[0x0]
80006f6a:	dc 48       	*unknown*
80006f6c:	80 00       	ld.sh	r0,r0[0x0]
80006f6e:	6c c4       	ld.w	r4,r6[0x30]
80006f70:	80 00       	ld.sh	r0,r0[0x0]
80006f72:	6d 4c       	ld.w	r12,r6[0x50]
80006f74:	00 00       	add	r0,r0
80006f76:	0c 2c       	rsub	r12,r6
80006f78:	00 00       	add	r0,r0
80006f7a:	0d 1c       	ld.sh	r12,r6++
80006f7c:	80 00       	ld.sh	r0,r0[0x0]
80006f7e:	5f 28       	srhs	r8

80006f80 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80006f80:	16 cc       	st.b	r11++,r12
	return str;
}
80006f82:	5e fb       	retal	r11

80006f84 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80006f84:	eb cd 40 c0 	pushm	r6-r7,lr
80006f88:	20 3d       	sub	sp,12
80006f8a:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80006f8c:	30 06       	mov	r6,0
80006f8e:	30 07       	mov	r7,0
80006f90:	fa e7 00 00 	st.d	sp[0],r6
80006f94:	30 0c       	mov	r12,0
80006f96:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80006f98:	58 08       	cp.w	r8,0
80006f9a:	c1 30       	breq	80006fc0 <PrintHex+0x3c>
80006f9c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80006f9e:	1a 9c       	mov	r12,sp
80006fa0:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006fa4:	58 9e       	cp.w	lr,9
80006fa6:	e0 8a 00 04 	brle	80006fae <PrintHex+0x2a>
80006faa:	2c 9e       	sub	lr,-55
80006fac:	c0 48       	rjmp	80006fb4 <PrintHex+0x30>
80006fae:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80006fb2:	2d 0e       	sub	lr,-48
80006fb4:	f8 09 0b 0e 	st.b	r12[r9],lr
80006fb8:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80006fba:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80006fbc:	cf 21       	brne	80006fa0 <PrintHex+0x1c>
80006fbe:	c0 48       	rjmp	80006fc6 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80006fc0:	33 08       	mov	r8,48
80006fc2:	ba 88       	st.b	sp[0x0],r8
80006fc4:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80006fc6:	f6 09 01 08 	sub	r8,r11,r9
80006fca:	58 08       	cp.w	r8,0
80006fcc:	e0 8a 00 13 	brle	80006ff2 <PrintHex+0x6e>
	{
		char num = len - cnt;
80006fd0:	12 1b       	sub	r11,r9
80006fd2:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80006fd6:	18 9e       	mov	lr,r12
80006fd8:	58 0c       	cp.w	r12,0
80006fda:	e0 8a 00 0c 	brle	80006ff2 <PrintHex+0x6e>
80006fde:	1a 9b       	mov	r11,sp
80006fe0:	12 0b       	add	r11,r9
80006fe2:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80006fe4:	33 07       	mov	r7,48
80006fe6:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80006fe8:	2f f8       	sub	r8,-1
80006fea:	1c 38       	cp.w	r8,lr
80006fec:	cf d5       	brlt	80006fe6 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80006fee:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80006ff2:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80006ff6:	f0 cb ff ff 	sub	r11,r8,-1
80006ffa:	58 0b       	cp.w	r11,0
80006ffc:	e0 8a 00 19 	brle	8000702e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007000:	fa cb ff f4 	sub	r11,sp,-12
80007004:	f6 09 00 09 	add	r9,r11,r9
80007008:	37 8b       	mov	r11,120
8000700a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000700e:	fa c9 ff f4 	sub	r9,sp,-12
80007012:	10 09       	add	r9,r8
80007014:	33 0b       	mov	r11,48
80007016:	f3 6b ff f4 	st.b	r9[-12],r11
8000701a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000701e:	fa ce 00 01 	sub	lr,sp,1
80007022:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007024:	11 8b       	ld.ub	r11,r8[0x0]
80007026:	12 cb       	st.b	r9++,r11
80007028:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000702a:	1c 38       	cp.w	r8,lr
8000702c:	cf c1       	brne	80007024 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000702e:	14 9c       	mov	r12,r10
80007030:	2f dd       	sub	sp,-12
80007032:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80007036 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80007036:	d4 21       	pushm	r4-r7,lr
80007038:	20 3d       	sub	sp,12
8000703a:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
8000703c:	30 06       	mov	r6,0
8000703e:	30 07       	mov	r7,0
80007040:	fa e7 00 00 	st.d	sp[0],r6
80007044:	30 0c       	mov	r12,0
80007046:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80007048:	58 08       	cp.w	r8,0
8000704a:	c0 35       	brlt	80007050 <PrintDec+0x1a>
8000704c:	14 97       	mov	r7,r10
8000704e:	c0 58       	rjmp	80007058 <PrintDec+0x22>
	{
		*p++ = '-';
80007050:	14 97       	mov	r7,r10
80007052:	32 d9       	mov	r9,45
80007054:	0e c9       	st.b	r7++,r9
		i = -i;
80007056:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80007058:	58 08       	cp.w	r8,0
8000705a:	c0 51       	brne	80007064 <PrintDec+0x2e>
8000705c:	33 08       	mov	r8,48
8000705e:	ba 88       	st.b	sp[0x0],r8
80007060:	30 1e       	mov	lr,1
80007062:	c2 f8       	rjmp	800070c0 <PrintDec+0x8a>
	
	int ten = i%10;
80007064:	e0 65 66 67 	mov	r5,26215
80007068:	ea 15 66 66 	orh	r5,0x6666
8000706c:	f0 05 04 44 	muls.d	r4,r8,r5
80007070:	ea 0c 14 02 	asr	r12,r5,0x2
80007074:	f0 09 14 1f 	asr	r9,r8,0x1f
80007078:	f8 09 01 09 	sub	r9,r12,r9
8000707c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007080:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80007084:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80007086:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80007088:	e0 66 66 67 	mov	r6,26215
8000708c:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80007090:	2d 09       	sub	r9,-48
80007092:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80007096:	2f fe       	sub	lr,-1
		i /= 10;
80007098:	f0 06 04 44 	muls.d	r4,r8,r6
8000709c:	ea 09 14 02 	asr	r9,r5,0x2
800070a0:	bf 58       	asr	r8,0x1f
800070a2:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
800070a6:	f0 06 04 44 	muls.d	r4,r8,r6
800070aa:	ea 09 14 02 	asr	r9,r5,0x2
800070ae:	f0 05 14 1f 	asr	r5,r8,0x1f
800070b2:	0a 19       	sub	r9,r5
800070b4:	f2 09 00 29 	add	r9,r9,r9<<0x2
800070b8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
800070bc:	58 08       	cp.w	r8,0
800070be:	ce 91       	brne	80007090 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
800070c0:	f6 0e 01 08 	sub	r8,r11,lr
800070c4:	58 08       	cp.w	r8,0
800070c6:	e0 89 00 06 	brgt	800070d2 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
800070ca:	58 0e       	cp.w	lr,0
800070cc:	e0 89 00 14 	brgt	800070f4 <PrintDec+0xbe>
800070d0:	c1 d8       	rjmp	8000710a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
800070d2:	1c 1b       	sub	r11,lr
800070d4:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
800070d6:	16 9c       	mov	r12,r11
800070d8:	58 0b       	cp.w	r11,0
800070da:	fe 9a ff f8 	brle	800070ca <PrintDec+0x94>
800070de:	1a 99       	mov	r9,sp
800070e0:	1c 09       	add	r9,lr
800070e2:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
800070e4:	33 06       	mov	r6,48
800070e6:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
800070e8:	2f f8       	sub	r8,-1
800070ea:	18 38       	cp.w	r8,r12
800070ec:	cf d5       	brlt	800070e6 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
800070ee:	f6 0e 00 0e 	add	lr,r11,lr
800070f2:	ce cb       	rjmp	800070ca <PrintDec+0x94>
800070f4:	fa c8 ff f4 	sub	r8,sp,-12
800070f8:	1c 08       	add	r8,lr
800070fa:	20 d8       	sub	r8,13
800070fc:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007100:	11 89       	ld.ub	r9,r8[0x0]
80007102:	0e c9       	st.b	r7++,r9
80007104:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007106:	16 38       	cp.w	r8,r11
80007108:	cf c1       	brne	80007100 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000710a:	14 9c       	mov	r12,r10
8000710c:	2f dd       	sub	sp,-12
8000710e:	d8 22       	popm	r4-r7,pc

80007110 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007110:	d4 31       	pushm	r0-r7,lr
80007112:	fa cd 02 08 	sub	sp,sp,520
80007116:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007118:	e0 6a 01 00 	mov	r10,256
8000711c:	30 0b       	mov	r11,0
8000711e:	fa cc fe f8 	sub	r12,sp,-264
80007122:	f0 1f 00 4e 	mcall	80007258 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007126:	fa c4 fd d4 	sub	r4,sp,-556
8000712a:	30 0a       	mov	r10,0
8000712c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000712e:	fa c3 ff fc 	sub	r3,sp,-4
80007132:	e0 61 01 00 	mov	r1,256
80007136:	14 90       	mov	r0,r10
			
					if(*str == '%')
80007138:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000713a:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000713e:	02 9a       	mov	r10,r1
80007140:	00 9b       	mov	r11,r0
80007142:	06 9c       	mov	r12,r3
80007144:	f0 1f 00 45 	mcall	80007258 <log+0x148>
			
					if(*str == '%')
80007148:	0f 88       	ld.ub	r8,r7[0x0]
8000714a:	e4 08 18 00 	cp.b	r8,r2
8000714e:	c5 71       	brne	800071fc <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80007150:	ee c8 ff ff 	sub	r8,r7,-1
80007154:	11 89       	ld.ub	r9,r8[0x0]
80007156:	4c 2a       	lddpc	r10,8000725c <log+0x14c>
80007158:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
8000715a:	23 09       	sub	r9,48
8000715c:	30 9a       	mov	r10,9
8000715e:	f4 09 18 00 	cp.b	r9,r10
80007162:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80007166:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
8000716a:	f7 b9 08 30 	subls	r9,48
8000716e:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80007172:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80007176:	0f 88       	ld.ub	r8,r7[0x0]
80007178:	22 58       	sub	r8,37
8000717a:	e0 48 00 53 	cp.w	r8,83
8000717e:	e0 8b 00 31 	brhi	800071e0 <log+0xd0>
80007182:	4b 89       	lddpc	r9,80007260 <log+0x150>
80007184:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80007188:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
8000718c:	06 9a       	mov	r10,r3
8000718e:	40 0b       	lddsp	r11,sp[0x0]
80007190:	5c 5b       	castu.b	r11
80007192:	68 0c       	ld.w	r12,r4[0x0]
80007194:	f0 1f 00 34 	mcall	80007264 <log+0x154>
							break;
80007198:	c2 98       	rjmp	800071ea <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000719a:	4b 4c       	lddpc	r12,80007268 <log+0x158>
8000719c:	f0 1f 00 34 	mcall	8000726c <log+0x15c>
800071a0:	08 95       	mov	r5,r4
800071a2:	06 9c       	mov	r12,r3
							break;
800071a4:	c2 38       	rjmp	800071ea <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
800071a6:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
800071aa:	06 9a       	mov	r10,r3
800071ac:	40 0b       	lddsp	r11,sp[0x0]
800071ae:	5c 5b       	castu.b	r11
800071b0:	68 0c       	ld.w	r12,r4[0x0]
800071b2:	f0 1f 00 30 	mcall	80007270 <log+0x160>
800071b6:	06 9c       	mov	r12,r3
							break;
800071b8:	c1 98       	rjmp	800071ea <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
800071ba:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
800071be:	06 9b       	mov	r11,r3
800071c0:	09 bc       	ld.ub	r12,r4[0x3]
800071c2:	f0 1f 00 2d 	mcall	80007274 <log+0x164>
800071c6:	06 9c       	mov	r12,r3
							break;
800071c8:	c1 18       	rjmp	800071ea <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
800071ca:	e8 c5 ff fc 	sub	r5,r4,-4
800071ce:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
800071d0:	c0 d8       	rjmp	800071ea <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
800071d2:	06 9b       	mov	r11,r3
800071d4:	32 5c       	mov	r12,37
800071d6:	f0 1f 00 28 	mcall	80007274 <log+0x164>
800071da:	08 95       	mov	r5,r4
800071dc:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
800071de:	c0 68       	rjmp	800071ea <log+0xda>
							
							default:
							log("I need relax.");
800071e0:	4a 6c       	lddpc	r12,80007278 <log+0x168>
800071e2:	f0 1f 00 23 	mcall	8000726c <log+0x15c>
800071e6:	08 95       	mov	r5,r4
800071e8:	06 9c       	mov	r12,r3
						}
						str++;
800071ea:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800071ec:	1a dc       	st.w	--sp,r12
800071ee:	1a d6       	st.w	--sp,r6
800071f0:	4a 3b       	lddpc	r11,8000727c <log+0x16c>
800071f2:	0c 9c       	mov	r12,r6
800071f4:	f0 1f 00 23 	mcall	80007280 <log+0x170>
800071f8:	2f ed       	sub	sp,-8
800071fa:	c0 a8       	rjmp	8000720e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800071fc:	2f f7       	sub	r7,-1
800071fe:	1a d8       	st.w	--sp,r8
80007200:	1a d6       	st.w	--sp,r6
80007202:	4a 1b       	lddpc	r11,80007284 <log+0x174>
80007204:	0c 9c       	mov	r12,r6
80007206:	f0 1f 00 1f 	mcall	80007280 <log+0x170>
8000720a:	08 95       	mov	r5,r4
8000720c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000720e:	0f 89       	ld.ub	r9,r7[0x0]
80007210:	30 08       	mov	r8,0
80007212:	f0 09 18 00 	cp.b	r9,r8
80007216:	c0 30       	breq	8000721c <log+0x10c>
80007218:	0a 94       	mov	r4,r5
8000721a:	c9 2b       	rjmp	8000713e <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000721c:	fa c7 fe f8 	sub	r7,sp,-264
80007220:	1a d7       	st.w	--sp,r7
80007222:	49 ab       	lddpc	r11,80007288 <log+0x178>
80007224:	0e 9c       	mov	r12,r7
80007226:	f0 1f 00 17 	mcall	80007280 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000722a:	5c 5c       	castu.b	r12
8000722c:	f8 c6 ff ff 	sub	r6,r12,-1
80007230:	0c 9c       	mov	r12,r6
80007232:	f0 1f 00 17 	mcall	8000728c <log+0x17c>
80007236:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80007238:	0c 9a       	mov	r10,r6
8000723a:	0e 9b       	mov	r11,r7
8000723c:	f0 1f 00 15 	mcall	80007290 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80007240:	30 09       	mov	r9,0
80007242:	30 5a       	mov	r10,5
80007244:	fa cb fe f8 	sub	r11,sp,-264
80007248:	49 38       	lddpc	r8,80007294 <log+0x184>
8000724a:	70 0c       	ld.w	r12,r8[0x0]
8000724c:	f0 1f 00 13 	mcall	80007298 <log+0x188>
80007250:	2f fd       	sub	sp,-4
	
	
}
80007252:	fe 3d fd f8 	sub	sp,-520
80007256:	d8 32       	popm	r0-r7,pc
80007258:	80 00       	ld.sh	r0,r0[0x0]
8000725a:	7a d4       	ld.w	r4,sp[0x34]
8000725c:	00 00       	add	r0,r0
8000725e:	0d 5c       	ld.sh	r12,--r6
80007260:	80 00       	ld.sh	r0,r0[0x0]
80007262:	dc 50       	acall	0xc5
80007264:	80 00       	ld.sh	r0,r0[0x0]
80007266:	70 36       	ld.w	r6,r8[0xc]
80007268:	80 00       	ld.sh	r0,r0[0x0]
8000726a:	de fc       	*unknown*
8000726c:	80 00       	ld.sh	r0,r0[0x0]
8000726e:	71 10       	ld.w	r0,r8[0x44]
80007270:	80 00       	ld.sh	r0,r0[0x0]
80007272:	6f 84       	ld.w	r4,r7[0x60]
80007274:	80 00       	ld.sh	r0,r0[0x0]
80007276:	6f 80       	ld.w	r0,r7[0x60]
80007278:	80 00       	ld.sh	r0,r0[0x0]
8000727a:	df 0c       	*unknown*
8000727c:	80 00       	ld.sh	r0,r0[0x0]
8000727e:	df 1c       	*unknown*
80007280:	80 00       	ld.sh	r0,r0[0x0]
80007282:	7d c4       	ld.w	r4,lr[0x70]
80007284:	80 00       	ld.sh	r0,r0[0x0]
80007286:	df 24       	*unknown*
80007288:	80 00       	ld.sh	r0,r0[0x0]
8000728a:	df 2c       	*unknown*
8000728c:	80 00       	ld.sh	r0,r0[0x0]
8000728e:	61 84       	ld.w	r4,r0[0x60]
80007290:	80 00       	ld.sh	r0,r0[0x0]
80007292:	79 8c       	ld.w	r12,r12[0x60]
80007294:	00 00       	add	r0,r0
80007296:	53 c4       	stdsp	sp[0xf0],r4
80007298:	80 00       	ld.sh	r0,r0[0x0]
8000729a:	64 d8       	ld.w	r8,r2[0x34]

8000729c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000729c:	d4 31       	pushm	r0-r7,lr
8000729e:	fa cd 02 0c 	sub	sp,sp,524
800072a2:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
800072a4:	e0 6a 01 00 	mov	r10,256
800072a8:	30 0b       	mov	r11,0
800072aa:	fa cc fe f4 	sub	r12,sp,-268
800072ae:	f0 1f 00 4c 	mcall	800073dc <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
800072b2:	fa c4 fd d0 	sub	r4,sp,-560
800072b6:	30 0a       	mov	r10,0
800072b8:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800072ba:	fa c3 ff fc 	sub	r3,sp,-4
800072be:	e0 61 01 00 	mov	r1,256
800072c2:	14 90       	mov	r0,r10
			
			if(*str == '%')
800072c4:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800072c6:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800072ca:	02 9a       	mov	r10,r1
800072cc:	00 9b       	mov	r11,r0
800072ce:	06 9c       	mov	r12,r3
800072d0:	f0 1f 00 43 	mcall	800073dc <logFromISR+0x140>
			
			if(*str == '%')
800072d4:	0f 88       	ld.ub	r8,r7[0x0]
800072d6:	e4 08 18 00 	cp.b	r8,r2
800072da:	c5 11       	brne	8000737c <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
800072dc:	ee c8 ff ff 	sub	r8,r7,-1
800072e0:	11 89       	ld.ub	r9,r8[0x0]
800072e2:	4c 0a       	lddpc	r10,800073e0 <logFromISR+0x144>
800072e4:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
800072e6:	23 09       	sub	r9,48
800072e8:	30 9a       	mov	r10,9
800072ea:	f4 09 18 00 	cp.b	r9,r10
800072ee:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
800072f2:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800072f6:	f7 b9 08 30 	subls	r9,48
800072fa:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
800072fe:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007302:	0f 88       	ld.ub	r8,r7[0x0]
80007304:	22 58       	sub	r8,37
80007306:	e0 48 00 53 	cp.w	r8,83
8000730a:	e0 8b 00 2b 	brhi	80007360 <logFromISR+0xc4>
8000730e:	4b 69       	lddpc	r9,800073e4 <logFromISR+0x148>
80007310:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007314:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007318:	06 9a       	mov	r10,r3
8000731a:	40 0b       	lddsp	r11,sp[0x0]
8000731c:	5c 5b       	castu.b	r11
8000731e:	68 0c       	ld.w	r12,r4[0x0]
80007320:	f0 1f 00 32 	mcall	800073e8 <logFromISR+0x14c>
					break;
80007324:	c2 38       	rjmp	8000736a <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007326:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000732a:	06 9a       	mov	r10,r3
8000732c:	40 0b       	lddsp	r11,sp[0x0]
8000732e:	5c 5b       	castu.b	r11
80007330:	68 0c       	ld.w	r12,r4[0x0]
80007332:	f0 1f 00 2f 	mcall	800073ec <logFromISR+0x150>
80007336:	06 9c       	mov	r12,r3
					break;
80007338:	c1 98       	rjmp	8000736a <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
8000733a:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
8000733e:	06 9b       	mov	r11,r3
80007340:	09 bc       	ld.ub	r12,r4[0x3]
80007342:	f0 1f 00 2c 	mcall	800073f0 <logFromISR+0x154>
80007346:	06 9c       	mov	r12,r3
					break;
80007348:	c1 18       	rjmp	8000736a <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
8000734a:	e8 c5 ff fc 	sub	r5,r4,-4
8000734e:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
80007350:	c0 d8       	rjmp	8000736a <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
80007352:	06 9b       	mov	r11,r3
80007354:	32 5c       	mov	r12,37
80007356:	f0 1f 00 27 	mcall	800073f0 <logFromISR+0x154>
8000735a:	08 95       	mov	r5,r4
8000735c:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
8000735e:	c0 68       	rjmp	8000736a <logFromISR+0xce>
					default:
					log("I need relax.");
80007360:	4a 5c       	lddpc	r12,800073f4 <logFromISR+0x158>
80007362:	f0 1f 00 26 	mcall	800073f8 <logFromISR+0x15c>
80007366:	08 95       	mov	r5,r4
80007368:	06 9c       	mov	r12,r3
				}
				str++;
8000736a:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000736c:	1a dc       	st.w	--sp,r12
8000736e:	1a d6       	st.w	--sp,r6
80007370:	4a 3b       	lddpc	r11,800073fc <logFromISR+0x160>
80007372:	0c 9c       	mov	r12,r6
80007374:	f0 1f 00 23 	mcall	80007400 <logFromISR+0x164>
80007378:	2f ed       	sub	sp,-8
8000737a:	c0 a8       	rjmp	8000738e <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000737c:	2f f7       	sub	r7,-1
8000737e:	1a d8       	st.w	--sp,r8
80007380:	1a d6       	st.w	--sp,r6
80007382:	4a 1b       	lddpc	r11,80007404 <logFromISR+0x168>
80007384:	0c 9c       	mov	r12,r6
80007386:	f0 1f 00 1f 	mcall	80007400 <logFromISR+0x164>
8000738a:	08 95       	mov	r5,r4
8000738c:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
8000738e:	0f 89       	ld.ub	r9,r7[0x0]
80007390:	30 08       	mov	r8,0
80007392:	f0 09 18 00 	cp.b	r9,r8
80007396:	c0 30       	breq	8000739c <logFromISR+0x100>
80007398:	0a 94       	mov	r4,r5
8000739a:	c9 8b       	rjmp	800072ca <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000739c:	fa c7 fe f4 	sub	r7,sp,-268
800073a0:	1a d7       	st.w	--sp,r7
800073a2:	49 ab       	lddpc	r11,80007408 <logFromISR+0x16c>
800073a4:	0e 9c       	mov	r12,r7
800073a6:	f0 1f 00 17 	mcall	80007400 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
800073aa:	5c 5c       	castu.b	r12
800073ac:	f8 c6 ff ff 	sub	r6,r12,-1
800073b0:	0c 9c       	mov	r12,r6
800073b2:	f0 1f 00 17 	mcall	8000740c <logFromISR+0x170>
800073b6:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
800073b8:	0c 9a       	mov	r10,r6
800073ba:	0e 9b       	mov	r11,r7
800073bc:	f0 1f 00 15 	mcall	80007410 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800073c0:	30 09       	mov	r9,0
800073c2:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
800073c4:	fa ca fe f8 	sub	r10,sp,-264
800073c8:	fa cb fe f4 	sub	r11,sp,-268
800073cc:	49 28       	lddpc	r8,80007414 <logFromISR+0x178>
800073ce:	70 0c       	ld.w	r12,r8[0x0]
800073d0:	f0 1f 00 12 	mcall	80007418 <logFromISR+0x17c>
800073d4:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
800073d6:	fe 3d fd f4 	sub	sp,-524
800073da:	d8 32       	popm	r0-r7,pc
800073dc:	80 00       	ld.sh	r0,r0[0x0]
800073de:	7a d4       	ld.w	r4,sp[0x34]
800073e0:	00 00       	add	r0,r0
800073e2:	0d 5d       	ld.sh	sp,--r6
800073e4:	80 00       	ld.sh	r0,r0[0x0]
800073e6:	dd a0       	acall	0xda
800073e8:	80 00       	ld.sh	r0,r0[0x0]
800073ea:	70 36       	ld.w	r6,r8[0xc]
800073ec:	80 00       	ld.sh	r0,r0[0x0]
800073ee:	6f 84       	ld.w	r4,r7[0x60]
800073f0:	80 00       	ld.sh	r0,r0[0x0]
800073f2:	6f 80       	ld.w	r0,r7[0x60]
800073f4:	80 00       	ld.sh	r0,r0[0x0]
800073f6:	df 0c       	*unknown*
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	71 10       	ld.w	r0,r8[0x44]
800073fc:	80 00       	ld.sh	r0,r0[0x0]
800073fe:	df 1c       	*unknown*
80007400:	80 00       	ld.sh	r0,r0[0x0]
80007402:	7d c4       	ld.w	r4,lr[0x70]
80007404:	80 00       	ld.sh	r0,r0[0x0]
80007406:	df 24       	*unknown*
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	df 2c       	*unknown*
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	61 84       	ld.w	r4,r0[0x60]
80007410:	80 00       	ld.sh	r0,r0[0x0]
80007412:	79 8c       	ld.w	r12,r12[0x60]
80007414:	00 00       	add	r0,r0
80007416:	53 c4       	stdsp	sp[0xf0],r4
80007418:	80 00       	ld.sh	r0,r0[0x0]
8000741a:	64 88       	ld.w	r8,r2[0x20]

8000741c <log_init>:
		
	return str;
}

void log_init(void)
{
8000741c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000741e:	30 2b       	mov	r11,2
80007420:	48 fc       	lddpc	r12,8000745c <log_init+0x40>
80007422:	f0 1f 00 10 	mcall	80007460 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007426:	e0 6a 36 00 	mov	r10,13824
8000742a:	ea 1a 01 6e 	orh	r10,0x16e
8000742e:	48 eb       	lddpc	r11,80007464 <log_init+0x48>
80007430:	fe 7c 18 00 	mov	r12,-59392
80007434:	f0 1f 00 0d 	mcall	80007468 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80007438:	30 4b       	mov	r11,4
8000743a:	33 2c       	mov	r12,50
8000743c:	f0 1f 00 0c 	mcall	8000746c <log_init+0x50>
80007440:	48 c8       	lddpc	r8,80007470 <log_init+0x54>
80007442:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80007444:	30 09       	mov	r9,0
80007446:	1a d9       	st.w	--sp,r9
80007448:	1a d9       	st.w	--sp,r9
8000744a:	1a d9       	st.w	--sp,r9
8000744c:	30 28       	mov	r8,2
8000744e:	36 4a       	mov	r10,100
80007450:	48 9b       	lddpc	r11,80007474 <log_init+0x58>
80007452:	48 ac       	lddpc	r12,80007478 <log_init+0x5c>
80007454:	f0 1f 00 0a 	mcall	8000747c <log_init+0x60>
80007458:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
8000745a:	d8 02       	popm	pc
8000745c:	80 00       	ld.sh	r0,r0[0x0]
8000745e:	df 38       	*unknown*
80007460:	80 00       	ld.sh	r0,r0[0x0]
80007462:	54 f4       	stdsp	sp[0x13c],r4
80007464:	80 00       	ld.sh	r0,r0[0x0]
80007466:	de f0       	acall	0xef
80007468:	80 00       	ld.sh	r0,r0[0x0]
8000746a:	5c e8       	tnbz	r8
8000746c:	80 00       	ld.sh	r0,r0[0x0]
8000746e:	66 30       	ld.w	r0,r3[0xc]
80007470:	00 00       	add	r0,r0
80007472:	53 c4       	stdsp	sp[0xf0],r4
80007474:	80 00       	ld.sh	r0,r0[0x0]
80007476:	df 34       	*unknown*
80007478:	80 00       	ld.sh	r0,r0[0x0]
8000747a:	74 80       	ld.w	r0,r10[0x20]
8000747c:	80 00       	ld.sh	r0,r0[0x0]
8000747e:	6d 4c       	ld.w	r12,r6[0x50]

80007480 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80007480:	eb cd 40 f8 	pushm	r3-r7,lr
80007484:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007486:	48 c7       	lddpc	r7,800074b4 <task_log+0x34>
80007488:	30 05       	mov	r5,0
8000748a:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
8000748c:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007490:	0a 99       	mov	r9,r5
80007492:	08 9a       	mov	r10,r4
80007494:	1a 9b       	mov	r11,sp
80007496:	6e 0c       	ld.w	r12,r7[0x0]
80007498:	f0 1f 00 08 	mcall	800074b8 <task_log+0x38>
8000749c:	58 1c       	cp.w	r12,1
8000749e:	cf 91       	brne	80007490 <task_log+0x10>
		{
			if( NULL != str)
800074a0:	40 0b       	lddsp	r11,sp[0x0]
800074a2:	58 0b       	cp.w	r11,0
800074a4:	cf 60       	breq	80007490 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
800074a6:	06 9c       	mov	r12,r3
800074a8:	f0 1f 00 05 	mcall	800074bc <task_log+0x3c>
				vPortFree(str);
800074ac:	40 0c       	lddsp	r12,sp[0x0]
800074ae:	f0 1f 00 05 	mcall	800074c0 <task_log+0x40>
800074b2:	ce fb       	rjmp	80007490 <task_log+0x10>
800074b4:	00 00       	add	r0,r0
800074b6:	53 c4       	stdsp	sp[0xf0],r4
800074b8:	80 00       	ld.sh	r0,r0[0x0]
800074ba:	62 cc       	ld.w	r12,r1[0x30]
800074bc:	80 00       	ld.sh	r0,r0[0x0]
800074be:	5c 98       	brev	r8
800074c0:	80 00       	ld.sh	r0,r0[0x0]
800074c2:	61 5c       	ld.w	r12,r0[0x54]

800074c4 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
800074c4:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
800074c6:	fe 78 10 00 	mov	r8,-61440
800074ca:	30 19       	mov	r9,1
800074cc:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
800074d0:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
800074d4:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
800074d8:	d3 03       	ssrf	0x10
	local_start_pll0();
800074da:	f0 1f 00 0c 	mcall	80007508 <main+0x44>
		
	INTC_init_interrupts();
800074de:	f0 1f 00 0c 	mcall	8000750c <main+0x48>
		
	log_init();
800074e2:	f0 1f 00 0c 	mcall	80007510 <main+0x4c>
	log("----start debug----");
800074e6:	48 cc       	lddpc	r12,80007514 <main+0x50>
800074e8:	f0 1f 00 0c 	mcall	80007518 <main+0x54>
	
	xg_flashc_init();
800074ec:	f0 1f 00 0c 	mcall	8000751c <main+0x58>

	//tc_init();
	
	//rfid_init();
		
	app_init();
800074f0:	f0 1f 00 0c 	mcall	80007520 <main+0x5c>
	
	xg_rtc_init();
800074f4:	f0 1f 00 0c 	mcall	80007524 <main+0x60>
		
	xcmp_init();
800074f8:	f0 1f 00 0c 	mcall	80007528 <main+0x64>

	local_start_timer();
800074fc:	f0 1f 00 0c 	mcall	8000752c <main+0x68>
		
	vTaskStartScheduler();
80007500:	f0 1f 00 0c 	mcall	80007530 <main+0x6c>
	return 0;
	
}
80007504:	d8 0a       	popm	pc,r12=0
80007506:	00 00       	add	r0,r0
80007508:	80 00       	ld.sh	r0,r0[0x0]
8000750a:	53 60       	stdsp	sp[0xd8],r0
8000750c:	80 00       	ld.sh	r0,r0[0x0]
8000750e:	55 f8       	stdsp	sp[0x17c],r8
80007510:	80 00       	ld.sh	r0,r0[0x0]
80007512:	74 1c       	ld.w	r12,r10[0x4]
80007514:	80 00       	ld.sh	r0,r0[0x0]
80007516:	df 48       	*unknown*
80007518:	80 00       	ld.sh	r0,r0[0x0]
8000751a:	71 10       	ld.w	r0,r8[0x44]
8000751c:	80 00       	ld.sh	r0,r0[0x0]
8000751e:	53 f4       	stdsp	sp[0xfc],r4
80007520:	80 00       	ld.sh	r0,r0[0x0]
80007522:	20 3c       	sub	r12,3
80007524:	80 00       	ld.sh	r0,r0[0x0]
80007526:	2d 0c       	sub	r12,-48
80007528:	80 00       	ld.sh	r0,r0[0x0]
8000752a:	43 e8       	lddsp	r8,sp[0xf8]
8000752c:	80 00       	ld.sh	r0,r0[0x0]
8000752e:	53 34       	stdsp	sp[0xcc],r4
80007530:	80 00       	ld.sh	r0,r0[0x0]
80007532:	6f 34       	ld.w	r4,r7[0x4c]

80007534 <free>:
80007534:	d4 01       	pushm	lr
80007536:	e0 68 0a 40 	mov	r8,2624
8000753a:	18 9b       	mov	r11,r12
8000753c:	70 0c       	ld.w	r12,r8[0x0]
8000753e:	e0 a0 1e 61 	rcall	8000b200 <_free_r>
80007542:	d8 02       	popm	pc

80007544 <malloc>:
80007544:	d4 01       	pushm	lr
80007546:	e0 68 0a 40 	mov	r8,2624
8000754a:	18 9b       	mov	r11,r12
8000754c:	70 0c       	ld.w	r12,r8[0x0]
8000754e:	c0 3c       	rcall	80007554 <_malloc_r>
80007550:	d8 02       	popm	pc
80007552:	d7 03       	nop

80007554 <_malloc_r>:
80007554:	d4 31       	pushm	r0-r7,lr
80007556:	f6 c8 ff f5 	sub	r8,r11,-11
8000755a:	18 95       	mov	r5,r12
8000755c:	10 97       	mov	r7,r8
8000755e:	e0 17 ff f8 	andl	r7,0xfff8
80007562:	59 68       	cp.w	r8,22
80007564:	f9 b7 08 10 	movls	r7,16
80007568:	16 37       	cp.w	r7,r11
8000756a:	5f 38       	srlo	r8
8000756c:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80007570:	c0 50       	breq	8000757a <_malloc_r+0x26>
80007572:	30 c8       	mov	r8,12
80007574:	99 38       	st.w	r12[0xc],r8
80007576:	e0 8f 01 fa 	bral	8000796a <_malloc_r+0x416>
8000757a:	fe b0 f5 a7 	rcall	800060c8 <__malloc_lock>
8000757e:	e0 47 01 f7 	cp.w	r7,503
80007582:	e0 8b 00 1d 	brhi	800075bc <_malloc_r+0x68>
80007586:	ee 03 16 03 	lsr	r3,r7,0x3
8000758a:	e0 68 05 40 	mov	r8,1344
8000758e:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007592:	70 36       	ld.w	r6,r8[0xc]
80007594:	10 36       	cp.w	r6,r8
80007596:	c0 61       	brne	800075a2 <_malloc_r+0x4e>
80007598:	ec c8 ff f8 	sub	r8,r6,-8
8000759c:	70 36       	ld.w	r6,r8[0xc]
8000759e:	10 36       	cp.w	r6,r8
800075a0:	c0 c0       	breq	800075b8 <_malloc_r+0x64>
800075a2:	6c 18       	ld.w	r8,r6[0x4]
800075a4:	e0 18 ff fc 	andl	r8,0xfffc
800075a8:	6c 3a       	ld.w	r10,r6[0xc]
800075aa:	ec 08 00 09 	add	r9,r6,r8
800075ae:	0a 9c       	mov	r12,r5
800075b0:	6c 28       	ld.w	r8,r6[0x8]
800075b2:	95 28       	st.w	r10[0x8],r8
800075b4:	91 3a       	st.w	r8[0xc],r10
800075b6:	c4 78       	rjmp	80007644 <_malloc_r+0xf0>
800075b8:	2f e3       	sub	r3,-2
800075ba:	c4 d8       	rjmp	80007654 <_malloc_r+0x100>
800075bc:	ee 03 16 09 	lsr	r3,r7,0x9
800075c0:	c0 41       	brne	800075c8 <_malloc_r+0x74>
800075c2:	ee 03 16 03 	lsr	r3,r7,0x3
800075c6:	c2 68       	rjmp	80007612 <_malloc_r+0xbe>
800075c8:	58 43       	cp.w	r3,4
800075ca:	e0 8b 00 06 	brhi	800075d6 <_malloc_r+0x82>
800075ce:	ee 03 16 06 	lsr	r3,r7,0x6
800075d2:	2c 83       	sub	r3,-56
800075d4:	c1 f8       	rjmp	80007612 <_malloc_r+0xbe>
800075d6:	59 43       	cp.w	r3,20
800075d8:	e0 8b 00 04 	brhi	800075e0 <_malloc_r+0x8c>
800075dc:	2a 53       	sub	r3,-91
800075de:	c1 a8       	rjmp	80007612 <_malloc_r+0xbe>
800075e0:	e0 43 00 54 	cp.w	r3,84
800075e4:	e0 8b 00 06 	brhi	800075f0 <_malloc_r+0x9c>
800075e8:	ee 03 16 0c 	lsr	r3,r7,0xc
800075ec:	29 23       	sub	r3,-110
800075ee:	c1 28       	rjmp	80007612 <_malloc_r+0xbe>
800075f0:	e0 43 01 54 	cp.w	r3,340
800075f4:	e0 8b 00 06 	brhi	80007600 <_malloc_r+0xac>
800075f8:	ee 03 16 0f 	lsr	r3,r7,0xf
800075fc:	28 93       	sub	r3,-119
800075fe:	c0 a8       	rjmp	80007612 <_malloc_r+0xbe>
80007600:	e0 43 05 54 	cp.w	r3,1364
80007604:	e0 88 00 04 	brls	8000760c <_malloc_r+0xb8>
80007608:	37 e3       	mov	r3,126
8000760a:	c0 48       	rjmp	80007612 <_malloc_r+0xbe>
8000760c:	ee 03 16 12 	lsr	r3,r7,0x12
80007610:	28 43       	sub	r3,-124
80007612:	e0 6a 05 40 	mov	r10,1344
80007616:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000761a:	74 36       	ld.w	r6,r10[0xc]
8000761c:	c1 98       	rjmp	8000764e <_malloc_r+0xfa>
8000761e:	6c 19       	ld.w	r9,r6[0x4]
80007620:	e0 19 ff fc 	andl	r9,0xfffc
80007624:	f2 07 01 0b 	sub	r11,r9,r7
80007628:	58 fb       	cp.w	r11,15
8000762a:	e0 8a 00 04 	brle	80007632 <_malloc_r+0xde>
8000762e:	20 13       	sub	r3,1
80007630:	c1 18       	rjmp	80007652 <_malloc_r+0xfe>
80007632:	6c 38       	ld.w	r8,r6[0xc]
80007634:	58 0b       	cp.w	r11,0
80007636:	c0 b5       	brlt	8000764c <_malloc_r+0xf8>
80007638:	6c 2a       	ld.w	r10,r6[0x8]
8000763a:	ec 09 00 09 	add	r9,r6,r9
8000763e:	0a 9c       	mov	r12,r5
80007640:	91 2a       	st.w	r8[0x8],r10
80007642:	95 38       	st.w	r10[0xc],r8
80007644:	72 18       	ld.w	r8,r9[0x4]
80007646:	a1 a8       	sbr	r8,0x0
80007648:	93 18       	st.w	r9[0x4],r8
8000764a:	cb c8       	rjmp	800077c2 <_malloc_r+0x26e>
8000764c:	10 96       	mov	r6,r8
8000764e:	14 36       	cp.w	r6,r10
80007650:	ce 71       	brne	8000761e <_malloc_r+0xca>
80007652:	2f f3       	sub	r3,-1
80007654:	e0 6a 05 40 	mov	r10,1344
80007658:	f4 cc ff f8 	sub	r12,r10,-8
8000765c:	78 26       	ld.w	r6,r12[0x8]
8000765e:	18 36       	cp.w	r6,r12
80007660:	c6 c0       	breq	80007738 <_malloc_r+0x1e4>
80007662:	6c 19       	ld.w	r9,r6[0x4]
80007664:	e0 19 ff fc 	andl	r9,0xfffc
80007668:	f2 07 01 08 	sub	r8,r9,r7
8000766c:	58 f8       	cp.w	r8,15
8000766e:	e0 89 00 8f 	brgt	8000778c <_malloc_r+0x238>
80007672:	99 3c       	st.w	r12[0xc],r12
80007674:	99 2c       	st.w	r12[0x8],r12
80007676:	58 08       	cp.w	r8,0
80007678:	c0 55       	brlt	80007682 <_malloc_r+0x12e>
8000767a:	ec 09 00 09 	add	r9,r6,r9
8000767e:	0a 9c       	mov	r12,r5
80007680:	ce 2b       	rjmp	80007644 <_malloc_r+0xf0>
80007682:	e0 49 01 ff 	cp.w	r9,511
80007686:	e0 8b 00 13 	brhi	800076ac <_malloc_r+0x158>
8000768a:	a3 99       	lsr	r9,0x3
8000768c:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007690:	70 2b       	ld.w	r11,r8[0x8]
80007692:	8d 38       	st.w	r6[0xc],r8
80007694:	8d 2b       	st.w	r6[0x8],r11
80007696:	97 36       	st.w	r11[0xc],r6
80007698:	91 26       	st.w	r8[0x8],r6
8000769a:	a3 49       	asr	r9,0x2
8000769c:	74 18       	ld.w	r8,r10[0x4]
8000769e:	30 1b       	mov	r11,1
800076a0:	f6 09 09 49 	lsl	r9,r11,r9
800076a4:	f1 e9 10 09 	or	r9,r8,r9
800076a8:	95 19       	st.w	r10[0x4],r9
800076aa:	c4 78       	rjmp	80007738 <_malloc_r+0x1e4>
800076ac:	f2 0a 16 09 	lsr	r10,r9,0x9
800076b0:	58 4a       	cp.w	r10,4
800076b2:	e0 8b 00 07 	brhi	800076c0 <_malloc_r+0x16c>
800076b6:	f2 0a 16 06 	lsr	r10,r9,0x6
800076ba:	2c 8a       	sub	r10,-56
800076bc:	c2 08       	rjmp	800076fc <_malloc_r+0x1a8>
800076be:	d7 03       	nop
800076c0:	59 4a       	cp.w	r10,20
800076c2:	e0 8b 00 04 	brhi	800076ca <_malloc_r+0x176>
800076c6:	2a 5a       	sub	r10,-91
800076c8:	c1 a8       	rjmp	800076fc <_malloc_r+0x1a8>
800076ca:	e0 4a 00 54 	cp.w	r10,84
800076ce:	e0 8b 00 06 	brhi	800076da <_malloc_r+0x186>
800076d2:	f2 0a 16 0c 	lsr	r10,r9,0xc
800076d6:	29 2a       	sub	r10,-110
800076d8:	c1 28       	rjmp	800076fc <_malloc_r+0x1a8>
800076da:	e0 4a 01 54 	cp.w	r10,340
800076de:	e0 8b 00 06 	brhi	800076ea <_malloc_r+0x196>
800076e2:	f2 0a 16 0f 	lsr	r10,r9,0xf
800076e6:	28 9a       	sub	r10,-119
800076e8:	c0 a8       	rjmp	800076fc <_malloc_r+0x1a8>
800076ea:	e0 4a 05 54 	cp.w	r10,1364
800076ee:	e0 88 00 04 	brls	800076f6 <_malloc_r+0x1a2>
800076f2:	37 ea       	mov	r10,126
800076f4:	c0 48       	rjmp	800076fc <_malloc_r+0x1a8>
800076f6:	f2 0a 16 12 	lsr	r10,r9,0x12
800076fa:	28 4a       	sub	r10,-124
800076fc:	e0 6b 05 40 	mov	r11,1344
80007700:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007704:	68 28       	ld.w	r8,r4[0x8]
80007706:	08 38       	cp.w	r8,r4
80007708:	c0 e1       	brne	80007724 <_malloc_r+0x1d0>
8000770a:	76 19       	ld.w	r9,r11[0x4]
8000770c:	a3 4a       	asr	r10,0x2
8000770e:	30 1e       	mov	lr,1
80007710:	fc 0a 09 4a 	lsl	r10,lr,r10
80007714:	f3 ea 10 0a 	or	r10,r9,r10
80007718:	10 99       	mov	r9,r8
8000771a:	97 1a       	st.w	r11[0x4],r10
8000771c:	c0 a8       	rjmp	80007730 <_malloc_r+0x1dc>
8000771e:	70 28       	ld.w	r8,r8[0x8]
80007720:	08 38       	cp.w	r8,r4
80007722:	c0 60       	breq	8000772e <_malloc_r+0x1da>
80007724:	70 1a       	ld.w	r10,r8[0x4]
80007726:	e0 1a ff fc 	andl	r10,0xfffc
8000772a:	14 39       	cp.w	r9,r10
8000772c:	cf 93       	brcs	8000771e <_malloc_r+0x1ca>
8000772e:	70 39       	ld.w	r9,r8[0xc]
80007730:	8d 39       	st.w	r6[0xc],r9
80007732:	8d 28       	st.w	r6[0x8],r8
80007734:	91 36       	st.w	r8[0xc],r6
80007736:	93 26       	st.w	r9[0x8],r6
80007738:	e6 08 14 02 	asr	r8,r3,0x2
8000773c:	30 1b       	mov	r11,1
8000773e:	e0 64 05 40 	mov	r4,1344
80007742:	f6 08 09 4b 	lsl	r11,r11,r8
80007746:	68 18       	ld.w	r8,r4[0x4]
80007748:	10 3b       	cp.w	r11,r8
8000774a:	e0 8b 00 6b 	brhi	80007820 <_malloc_r+0x2cc>
8000774e:	f7 e8 00 09 	and	r9,r11,r8
80007752:	c0 b1       	brne	80007768 <_malloc_r+0x214>
80007754:	e0 13 ff fc 	andl	r3,0xfffc
80007758:	a1 7b       	lsl	r11,0x1
8000775a:	2f c3       	sub	r3,-4
8000775c:	c0 38       	rjmp	80007762 <_malloc_r+0x20e>
8000775e:	2f c3       	sub	r3,-4
80007760:	a1 7b       	lsl	r11,0x1
80007762:	f7 e8 00 09 	and	r9,r11,r8
80007766:	cf c0       	breq	8000775e <_malloc_r+0x20a>
80007768:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000776c:	06 92       	mov	r2,r3
8000776e:	1c 91       	mov	r1,lr
80007770:	62 36       	ld.w	r6,r1[0xc]
80007772:	c2 e8       	rjmp	800077ce <_malloc_r+0x27a>
80007774:	6c 1a       	ld.w	r10,r6[0x4]
80007776:	e0 1a ff fc 	andl	r10,0xfffc
8000777a:	f4 07 01 08 	sub	r8,r10,r7
8000777e:	58 f8       	cp.w	r8,15
80007780:	e0 8a 00 15 	brle	800077aa <_malloc_r+0x256>
80007784:	6c 3a       	ld.w	r10,r6[0xc]
80007786:	6c 29       	ld.w	r9,r6[0x8]
80007788:	95 29       	st.w	r10[0x8],r9
8000778a:	93 3a       	st.w	r9[0xc],r10
8000778c:	0e 99       	mov	r9,r7
8000778e:	ec 07 00 07 	add	r7,r6,r7
80007792:	a1 a9       	sbr	r9,0x0
80007794:	99 37       	st.w	r12[0xc],r7
80007796:	99 27       	st.w	r12[0x8],r7
80007798:	8d 19       	st.w	r6[0x4],r9
8000779a:	ee 08 09 08 	st.w	r7[r8],r8
8000779e:	8f 2c       	st.w	r7[0x8],r12
800077a0:	8f 3c       	st.w	r7[0xc],r12
800077a2:	a1 a8       	sbr	r8,0x0
800077a4:	0a 9c       	mov	r12,r5
800077a6:	8f 18       	st.w	r7[0x4],r8
800077a8:	c0 d8       	rjmp	800077c2 <_malloc_r+0x26e>
800077aa:	6c 39       	ld.w	r9,r6[0xc]
800077ac:	58 08       	cp.w	r8,0
800077ae:	c0 f5       	brlt	800077cc <_malloc_r+0x278>
800077b0:	ec 0a 00 0a 	add	r10,r6,r10
800077b4:	74 18       	ld.w	r8,r10[0x4]
800077b6:	a1 a8       	sbr	r8,0x0
800077b8:	0a 9c       	mov	r12,r5
800077ba:	95 18       	st.w	r10[0x4],r8
800077bc:	6c 28       	ld.w	r8,r6[0x8]
800077be:	93 28       	st.w	r9[0x8],r8
800077c0:	91 39       	st.w	r8[0xc],r9
800077c2:	fe b0 f4 89 	rcall	800060d4 <__malloc_unlock>
800077c6:	ec cc ff f8 	sub	r12,r6,-8
800077ca:	d8 32       	popm	r0-r7,pc
800077cc:	12 96       	mov	r6,r9
800077ce:	02 36       	cp.w	r6,r1
800077d0:	cd 21       	brne	80007774 <_malloc_r+0x220>
800077d2:	2f f2       	sub	r2,-1
800077d4:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800077d8:	c0 30       	breq	800077de <_malloc_r+0x28a>
800077da:	2f 81       	sub	r1,-8
800077dc:	cc ab       	rjmp	80007770 <_malloc_r+0x21c>
800077de:	1c 98       	mov	r8,lr
800077e0:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800077e4:	c0 81       	brne	800077f4 <_malloc_r+0x2a0>
800077e6:	68 19       	ld.w	r9,r4[0x4]
800077e8:	f6 08 11 ff 	rsub	r8,r11,-1
800077ec:	f3 e8 00 08 	and	r8,r9,r8
800077f0:	89 18       	st.w	r4[0x4],r8
800077f2:	c0 78       	rjmp	80007800 <_malloc_r+0x2ac>
800077f4:	f0 c9 00 08 	sub	r9,r8,8
800077f8:	20 13       	sub	r3,1
800077fa:	70 08       	ld.w	r8,r8[0x0]
800077fc:	12 38       	cp.w	r8,r9
800077fe:	cf 10       	breq	800077e0 <_malloc_r+0x28c>
80007800:	a1 7b       	lsl	r11,0x1
80007802:	68 18       	ld.w	r8,r4[0x4]
80007804:	10 3b       	cp.w	r11,r8
80007806:	e0 8b 00 0d 	brhi	80007820 <_malloc_r+0x2cc>
8000780a:	58 0b       	cp.w	r11,0
8000780c:	c0 a0       	breq	80007820 <_malloc_r+0x2cc>
8000780e:	04 93       	mov	r3,r2
80007810:	c0 38       	rjmp	80007816 <_malloc_r+0x2c2>
80007812:	2f c3       	sub	r3,-4
80007814:	a1 7b       	lsl	r11,0x1
80007816:	f7 e8 00 09 	and	r9,r11,r8
8000781a:	ca 71       	brne	80007768 <_malloc_r+0x214>
8000781c:	cf bb       	rjmp	80007812 <_malloc_r+0x2be>
8000781e:	d7 03       	nop
80007820:	68 23       	ld.w	r3,r4[0x8]
80007822:	66 12       	ld.w	r2,r3[0x4]
80007824:	e0 12 ff fc 	andl	r2,0xfffc
80007828:	0e 32       	cp.w	r2,r7
8000782a:	5f 39       	srlo	r9
8000782c:	e4 07 01 08 	sub	r8,r2,r7
80007830:	58 f8       	cp.w	r8,15
80007832:	5f aa       	srle	r10
80007834:	f5 e9 10 09 	or	r9,r10,r9
80007838:	e0 80 00 9a 	breq	8000796c <_malloc_r+0x418>
8000783c:	e0 68 0d 68 	mov	r8,3432
80007840:	70 01       	ld.w	r1,r8[0x0]
80007842:	e0 68 09 4c 	mov	r8,2380
80007846:	2f 01       	sub	r1,-16
80007848:	70 08       	ld.w	r8,r8[0x0]
8000784a:	0e 01       	add	r1,r7
8000784c:	5b f8       	cp.w	r8,-1
8000784e:	c0 40       	breq	80007856 <_malloc_r+0x302>
80007850:	28 11       	sub	r1,-127
80007852:	e0 11 ff 80 	andl	r1,0xff80
80007856:	02 9b       	mov	r11,r1
80007858:	0a 9c       	mov	r12,r5
8000785a:	e0 a0 02 a5 	rcall	80007da4 <_sbrk_r>
8000785e:	18 96       	mov	r6,r12
80007860:	5b fc       	cp.w	r12,-1
80007862:	c7 50       	breq	8000794c <_malloc_r+0x3f8>
80007864:	e6 02 00 08 	add	r8,r3,r2
80007868:	10 3c       	cp.w	r12,r8
8000786a:	c0 32       	brcc	80007870 <_malloc_r+0x31c>
8000786c:	08 33       	cp.w	r3,r4
8000786e:	c6 f1       	brne	8000794c <_malloc_r+0x3f8>
80007870:	e0 6a 0d 6c 	mov	r10,3436
80007874:	74 09       	ld.w	r9,r10[0x0]
80007876:	e2 09 00 09 	add	r9,r1,r9
8000787a:	95 09       	st.w	r10[0x0],r9
8000787c:	10 36       	cp.w	r6,r8
8000787e:	c0 a1       	brne	80007892 <_malloc_r+0x33e>
80007880:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
80007884:	c0 71       	brne	80007892 <_malloc_r+0x33e>
80007886:	e2 02 00 02 	add	r2,r1,r2
8000788a:	68 28       	ld.w	r8,r4[0x8]
8000788c:	a1 a2       	sbr	r2,0x0
8000788e:	91 12       	st.w	r8[0x4],r2
80007890:	c4 f8       	rjmp	8000792e <_malloc_r+0x3da>
80007892:	e0 6a 09 4c 	mov	r10,2380
80007896:	74 0b       	ld.w	r11,r10[0x0]
80007898:	5b fb       	cp.w	r11,-1
8000789a:	c0 31       	brne	800078a0 <_malloc_r+0x34c>
8000789c:	95 06       	st.w	r10[0x0],r6
8000789e:	c0 78       	rjmp	800078ac <_malloc_r+0x358>
800078a0:	ec 09 00 09 	add	r9,r6,r9
800078a4:	e0 6a 0d 6c 	mov	r10,3436
800078a8:	10 19       	sub	r9,r8
800078aa:	95 09       	st.w	r10[0x0],r9
800078ac:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
800078b0:	f0 09 11 08 	rsub	r9,r8,8
800078b4:	58 08       	cp.w	r8,0
800078b6:	f2 08 17 10 	movne	r8,r9
800078ba:	ed d8 e1 06 	addne	r6,r6,r8
800078be:	28 08       	sub	r8,-128
800078c0:	ec 01 00 01 	add	r1,r6,r1
800078c4:	0a 9c       	mov	r12,r5
800078c6:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800078ca:	f0 01 01 01 	sub	r1,r8,r1
800078ce:	02 9b       	mov	r11,r1
800078d0:	e0 a0 02 6a 	rcall	80007da4 <_sbrk_r>
800078d4:	e0 68 0d 6c 	mov	r8,3436
800078d8:	5b fc       	cp.w	r12,-1
800078da:	ec 0c 17 00 	moveq	r12,r6
800078de:	f9 b1 00 00 	moveq	r1,0
800078e2:	70 09       	ld.w	r9,r8[0x0]
800078e4:	0c 1c       	sub	r12,r6
800078e6:	89 26       	st.w	r4[0x8],r6
800078e8:	02 0c       	add	r12,r1
800078ea:	12 01       	add	r1,r9
800078ec:	a1 ac       	sbr	r12,0x0
800078ee:	91 01       	st.w	r8[0x0],r1
800078f0:	8d 1c       	st.w	r6[0x4],r12
800078f2:	08 33       	cp.w	r3,r4
800078f4:	c1 d0       	breq	8000792e <_malloc_r+0x3da>
800078f6:	58 f2       	cp.w	r2,15
800078f8:	e0 8b 00 05 	brhi	80007902 <_malloc_r+0x3ae>
800078fc:	30 18       	mov	r8,1
800078fe:	8d 18       	st.w	r6[0x4],r8
80007900:	c2 68       	rjmp	8000794c <_malloc_r+0x3f8>
80007902:	30 59       	mov	r9,5
80007904:	20 c2       	sub	r2,12
80007906:	e0 12 ff f8 	andl	r2,0xfff8
8000790a:	e6 02 00 08 	add	r8,r3,r2
8000790e:	91 29       	st.w	r8[0x8],r9
80007910:	91 19       	st.w	r8[0x4],r9
80007912:	66 18       	ld.w	r8,r3[0x4]
80007914:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007918:	e5 e8 10 08 	or	r8,r2,r8
8000791c:	87 18       	st.w	r3[0x4],r8
8000791e:	58 f2       	cp.w	r2,15
80007920:	e0 88 00 07 	brls	8000792e <_malloc_r+0x3da>
80007924:	e6 cb ff f8 	sub	r11,r3,-8
80007928:	0a 9c       	mov	r12,r5
8000792a:	e0 a0 1c 6b 	rcall	8000b200 <_free_r>
8000792e:	e0 69 0d 64 	mov	r9,3428
80007932:	72 0a       	ld.w	r10,r9[0x0]
80007934:	e0 68 0d 6c 	mov	r8,3436
80007938:	70 08       	ld.w	r8,r8[0x0]
8000793a:	14 38       	cp.w	r8,r10
8000793c:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007940:	e0 69 0d 60 	mov	r9,3424
80007944:	72 0a       	ld.w	r10,r9[0x0]
80007946:	14 38       	cp.w	r8,r10
80007948:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000794c:	68 28       	ld.w	r8,r4[0x8]
8000794e:	70 18       	ld.w	r8,r8[0x4]
80007950:	e0 18 ff fc 	andl	r8,0xfffc
80007954:	0e 38       	cp.w	r8,r7
80007956:	5f 39       	srlo	r9
80007958:	0e 18       	sub	r8,r7
8000795a:	58 f8       	cp.w	r8,15
8000795c:	5f aa       	srle	r10
8000795e:	f5 e9 10 09 	or	r9,r10,r9
80007962:	c0 50       	breq	8000796c <_malloc_r+0x418>
80007964:	0a 9c       	mov	r12,r5
80007966:	fe b0 f3 b7 	rcall	800060d4 <__malloc_unlock>
8000796a:	d8 3a       	popm	r0-r7,pc,r12=0
8000796c:	68 26       	ld.w	r6,r4[0x8]
8000796e:	a1 a8       	sbr	r8,0x0
80007970:	0e 99       	mov	r9,r7
80007972:	a1 a9       	sbr	r9,0x0
80007974:	8d 19       	st.w	r6[0x4],r9
80007976:	ec 07 00 07 	add	r7,r6,r7
8000797a:	0a 9c       	mov	r12,r5
8000797c:	89 27       	st.w	r4[0x8],r7
8000797e:	8f 18       	st.w	r7[0x4],r8
80007980:	fe b0 f3 aa 	rcall	800060d4 <__malloc_unlock>
80007984:	ec cc ff f8 	sub	r12,r6,-8
80007988:	d8 32       	popm	r0-r7,pc
8000798a:	d7 03       	nop

8000798c <memcpy>:
8000798c:	58 8a       	cp.w	r10,8
8000798e:	c2 f5       	brlt	800079ec <memcpy+0x60>
80007990:	f9 eb 10 09 	or	r9,r12,r11
80007994:	e2 19 00 03 	andl	r9,0x3,COH
80007998:	e0 81 00 97 	brne	80007ac6 <memcpy+0x13a>
8000799c:	e0 4a 00 20 	cp.w	r10,32
800079a0:	c3 b4       	brge	80007a16 <memcpy+0x8a>
800079a2:	f4 08 14 02 	asr	r8,r10,0x2
800079a6:	f0 09 11 08 	rsub	r9,r8,8
800079aa:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800079ae:	76 69       	ld.w	r9,r11[0x18]
800079b0:	99 69       	st.w	r12[0x18],r9
800079b2:	76 59       	ld.w	r9,r11[0x14]
800079b4:	99 59       	st.w	r12[0x14],r9
800079b6:	76 49       	ld.w	r9,r11[0x10]
800079b8:	99 49       	st.w	r12[0x10],r9
800079ba:	76 39       	ld.w	r9,r11[0xc]
800079bc:	99 39       	st.w	r12[0xc],r9
800079be:	76 29       	ld.w	r9,r11[0x8]
800079c0:	99 29       	st.w	r12[0x8],r9
800079c2:	76 19       	ld.w	r9,r11[0x4]
800079c4:	99 19       	st.w	r12[0x4],r9
800079c6:	76 09       	ld.w	r9,r11[0x0]
800079c8:	99 09       	st.w	r12[0x0],r9
800079ca:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800079ce:	f8 08 00 28 	add	r8,r12,r8<<0x2
800079d2:	e0 1a 00 03 	andl	r10,0x3
800079d6:	f4 0a 11 04 	rsub	r10,r10,4
800079da:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800079de:	17 a9       	ld.ub	r9,r11[0x2]
800079e0:	b0 a9       	st.b	r8[0x2],r9
800079e2:	17 99       	ld.ub	r9,r11[0x1]
800079e4:	b0 99       	st.b	r8[0x1],r9
800079e6:	17 89       	ld.ub	r9,r11[0x0]
800079e8:	b0 89       	st.b	r8[0x0],r9
800079ea:	5e fc       	retal	r12
800079ec:	f4 0a 11 09 	rsub	r10,r10,9
800079f0:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800079f4:	17 f9       	ld.ub	r9,r11[0x7]
800079f6:	b8 f9       	st.b	r12[0x7],r9
800079f8:	17 e9       	ld.ub	r9,r11[0x6]
800079fa:	b8 e9       	st.b	r12[0x6],r9
800079fc:	17 d9       	ld.ub	r9,r11[0x5]
800079fe:	b8 d9       	st.b	r12[0x5],r9
80007a00:	17 c9       	ld.ub	r9,r11[0x4]
80007a02:	b8 c9       	st.b	r12[0x4],r9
80007a04:	17 b9       	ld.ub	r9,r11[0x3]
80007a06:	b8 b9       	st.b	r12[0x3],r9
80007a08:	17 a9       	ld.ub	r9,r11[0x2]
80007a0a:	b8 a9       	st.b	r12[0x2],r9
80007a0c:	17 99       	ld.ub	r9,r11[0x1]
80007a0e:	b8 99       	st.b	r12[0x1],r9
80007a10:	17 89       	ld.ub	r9,r11[0x0]
80007a12:	b8 89       	st.b	r12[0x0],r9
80007a14:	5e fc       	retal	r12
80007a16:	eb cd 40 c0 	pushm	r6-r7,lr
80007a1a:	18 99       	mov	r9,r12
80007a1c:	22 0a       	sub	r10,32
80007a1e:	b7 07       	ld.d	r6,r11++
80007a20:	b3 26       	st.d	r9++,r6
80007a22:	b7 07       	ld.d	r6,r11++
80007a24:	b3 26       	st.d	r9++,r6
80007a26:	b7 07       	ld.d	r6,r11++
80007a28:	b3 26       	st.d	r9++,r6
80007a2a:	b7 07       	ld.d	r6,r11++
80007a2c:	b3 26       	st.d	r9++,r6
80007a2e:	22 0a       	sub	r10,32
80007a30:	cf 74       	brge	80007a1e <memcpy+0x92>
80007a32:	2f 0a       	sub	r10,-16
80007a34:	c0 65       	brlt	80007a40 <memcpy+0xb4>
80007a36:	b7 07       	ld.d	r6,r11++
80007a38:	b3 26       	st.d	r9++,r6
80007a3a:	b7 07       	ld.d	r6,r11++
80007a3c:	b3 26       	st.d	r9++,r6
80007a3e:	21 0a       	sub	r10,16
80007a40:	5c 3a       	neg	r10
80007a42:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007a46:	d7 03       	nop
80007a48:	d7 03       	nop
80007a4a:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007a4e:	f3 66 00 0e 	st.b	r9[14],r6
80007a52:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007a56:	f3 66 00 0d 	st.b	r9[13],r6
80007a5a:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007a5e:	f3 66 00 0c 	st.b	r9[12],r6
80007a62:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007a66:	f3 66 00 0b 	st.b	r9[11],r6
80007a6a:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007a6e:	f3 66 00 0a 	st.b	r9[10],r6
80007a72:	f7 36 00 09 	ld.ub	r6,r11[9]
80007a76:	f3 66 00 09 	st.b	r9[9],r6
80007a7a:	f7 36 00 08 	ld.ub	r6,r11[8]
80007a7e:	f3 66 00 08 	st.b	r9[8],r6
80007a82:	f7 36 00 07 	ld.ub	r6,r11[7]
80007a86:	f3 66 00 07 	st.b	r9[7],r6
80007a8a:	f7 36 00 06 	ld.ub	r6,r11[6]
80007a8e:	f3 66 00 06 	st.b	r9[6],r6
80007a92:	f7 36 00 05 	ld.ub	r6,r11[5]
80007a96:	f3 66 00 05 	st.b	r9[5],r6
80007a9a:	f7 36 00 04 	ld.ub	r6,r11[4]
80007a9e:	f3 66 00 04 	st.b	r9[4],r6
80007aa2:	f7 36 00 03 	ld.ub	r6,r11[3]
80007aa6:	f3 66 00 03 	st.b	r9[3],r6
80007aaa:	f7 36 00 02 	ld.ub	r6,r11[2]
80007aae:	f3 66 00 02 	st.b	r9[2],r6
80007ab2:	f7 36 00 01 	ld.ub	r6,r11[1]
80007ab6:	f3 66 00 01 	st.b	r9[1],r6
80007aba:	f7 36 00 00 	ld.ub	r6,r11[0]
80007abe:	f3 66 00 00 	st.b	r9[0],r6
80007ac2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007ac6:	20 1a       	sub	r10,1
80007ac8:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007acc:	f8 0a 0b 09 	st.b	r12[r10],r9
80007ad0:	cf b1       	brne	80007ac6 <memcpy+0x13a>
80007ad2:	5e fc       	retal	r12

80007ad4 <memset>:
80007ad4:	18 98       	mov	r8,r12
80007ad6:	c0 38       	rjmp	80007adc <memset+0x8>
80007ad8:	10 cb       	st.b	r8++,r11
80007ada:	20 1a       	sub	r10,1
80007adc:	58 0a       	cp.w	r10,0
80007ade:	cf d1       	brne	80007ad8 <memset+0x4>
80007ae0:	5e fc       	retal	r12
80007ae2:	d7 03       	nop

80007ae4 <_realloc_r>:
80007ae4:	d4 31       	pushm	r0-r7,lr
80007ae6:	20 1d       	sub	sp,4
80007ae8:	16 94       	mov	r4,r11
80007aea:	18 92       	mov	r2,r12
80007aec:	14 9b       	mov	r11,r10
80007aee:	58 04       	cp.w	r4,0
80007af0:	c0 51       	brne	80007afa <_realloc_r+0x16>
80007af2:	fe b0 fd 31 	rcall	80007554 <_malloc_r>
80007af6:	18 95       	mov	r5,r12
80007af8:	c5 39       	rjmp	80007d9e <_realloc_r+0x2ba>
80007afa:	50 0a       	stdsp	sp[0x0],r10
80007afc:	fe b0 f2 e6 	rcall	800060c8 <__malloc_lock>
80007b00:	40 0b       	lddsp	r11,sp[0x0]
80007b02:	f6 c8 ff f5 	sub	r8,r11,-11
80007b06:	e8 c1 00 08 	sub	r1,r4,8
80007b0a:	10 96       	mov	r6,r8
80007b0c:	62 1c       	ld.w	r12,r1[0x4]
80007b0e:	e0 16 ff f8 	andl	r6,0xfff8
80007b12:	59 68       	cp.w	r8,22
80007b14:	f9 b6 08 10 	movls	r6,16
80007b18:	16 36       	cp.w	r6,r11
80007b1a:	5f 38       	srlo	r8
80007b1c:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007b20:	c0 50       	breq	80007b2a <_realloc_r+0x46>
80007b22:	30 c8       	mov	r8,12
80007b24:	30 05       	mov	r5,0
80007b26:	85 38       	st.w	r2[0xc],r8
80007b28:	c3 b9       	rjmp	80007d9e <_realloc_r+0x2ba>
80007b2a:	18 90       	mov	r0,r12
80007b2c:	e0 10 ff fc 	andl	r0,0xfffc
80007b30:	0c 30       	cp.w	r0,r6
80007b32:	e0 84 01 0b 	brge	80007d48 <_realloc_r+0x264>
80007b36:	e0 68 05 40 	mov	r8,1344
80007b3a:	e2 00 00 09 	add	r9,r1,r0
80007b3e:	70 25       	ld.w	r5,r8[0x8]
80007b40:	0a 39       	cp.w	r9,r5
80007b42:	c0 90       	breq	80007b54 <_realloc_r+0x70>
80007b44:	72 1a       	ld.w	r10,r9[0x4]
80007b46:	a1 ca       	cbr	r10,0x0
80007b48:	f2 0a 00 0a 	add	r10,r9,r10
80007b4c:	74 1a       	ld.w	r10,r10[0x4]
80007b4e:	ed ba 00 00 	bld	r10,0x0
80007b52:	c2 20       	breq	80007b96 <_realloc_r+0xb2>
80007b54:	72 1a       	ld.w	r10,r9[0x4]
80007b56:	e0 1a ff fc 	andl	r10,0xfffc
80007b5a:	f4 00 00 03 	add	r3,r10,r0
80007b5e:	0a 39       	cp.w	r9,r5
80007b60:	c1 31       	brne	80007b86 <_realloc_r+0xa2>
80007b62:	ec c7 ff f0 	sub	r7,r6,-16
80007b66:	0e 33       	cp.w	r3,r7
80007b68:	c1 95       	brlt	80007b9a <_realloc_r+0xb6>
80007b6a:	e2 06 00 09 	add	r9,r1,r6
80007b6e:	0c 13       	sub	r3,r6
80007b70:	a1 a3       	sbr	r3,0x0
80007b72:	93 13       	st.w	r9[0x4],r3
80007b74:	91 29       	st.w	r8[0x8],r9
80007b76:	04 9c       	mov	r12,r2
80007b78:	62 18       	ld.w	r8,r1[0x4]
80007b7a:	08 95       	mov	r5,r4
80007b7c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007b80:	10 46       	or	r6,r8
80007b82:	83 16       	st.w	r1[0x4],r6
80007b84:	c0 b9       	rjmp	80007d9a <_realloc_r+0x2b6>
80007b86:	0c 33       	cp.w	r3,r6
80007b88:	c0 95       	brlt	80007b9a <_realloc_r+0xb6>
80007b8a:	72 28       	ld.w	r8,r9[0x8]
80007b8c:	02 97       	mov	r7,r1
80007b8e:	72 39       	ld.w	r9,r9[0xc]
80007b90:	93 28       	st.w	r9[0x8],r8
80007b92:	91 39       	st.w	r8[0xc],r9
80007b94:	cd c8       	rjmp	80007d4c <_realloc_r+0x268>
80007b96:	30 0a       	mov	r10,0
80007b98:	14 99       	mov	r9,r10
80007b9a:	ed bc 00 00 	bld	r12,0x0
80007b9e:	e0 80 00 95 	breq	80007cc8 <_realloc_r+0x1e4>
80007ba2:	62 07       	ld.w	r7,r1[0x0]
80007ba4:	e2 07 01 07 	sub	r7,r1,r7
80007ba8:	6e 1c       	ld.w	r12,r7[0x4]
80007baa:	e0 1c ff fc 	andl	r12,0xfffc
80007bae:	58 09       	cp.w	r9,0
80007bb0:	c5 60       	breq	80007c5c <_realloc_r+0x178>
80007bb2:	f8 00 00 03 	add	r3,r12,r0
80007bb6:	0a 39       	cp.w	r9,r5
80007bb8:	c4 81       	brne	80007c48 <_realloc_r+0x164>
80007bba:	14 03       	add	r3,r10
80007bbc:	ec c9 ff f0 	sub	r9,r6,-16
80007bc0:	12 33       	cp.w	r3,r9
80007bc2:	c4 d5       	brlt	80007c5c <_realloc_r+0x178>
80007bc4:	6e 3a       	ld.w	r10,r7[0xc]
80007bc6:	6e 29       	ld.w	r9,r7[0x8]
80007bc8:	95 29       	st.w	r10[0x8],r9
80007bca:	93 3a       	st.w	r9[0xc],r10
80007bcc:	ee c5 ff f8 	sub	r5,r7,-8
80007bd0:	e0 ca 00 04 	sub	r10,r0,4
80007bd4:	e0 4a 00 24 	cp.w	r10,36
80007bd8:	e0 8b 00 25 	brhi	80007c22 <_realloc_r+0x13e>
80007bdc:	0a 99       	mov	r9,r5
80007bde:	59 3a       	cp.w	r10,19
80007be0:	e0 88 00 1a 	brls	80007c14 <_realloc_r+0x130>
80007be4:	09 09       	ld.w	r9,r4++
80007be6:	8b 09       	st.w	r5[0x0],r9
80007be8:	09 09       	ld.w	r9,r4++
80007bea:	8f 39       	st.w	r7[0xc],r9
80007bec:	ee c9 ff f0 	sub	r9,r7,-16
80007bf0:	59 ba       	cp.w	r10,27
80007bf2:	e0 88 00 11 	brls	80007c14 <_realloc_r+0x130>
80007bf6:	09 0b       	ld.w	r11,r4++
80007bf8:	93 0b       	st.w	r9[0x0],r11
80007bfa:	09 09       	ld.w	r9,r4++
80007bfc:	8f 59       	st.w	r7[0x14],r9
80007bfe:	ee c9 ff e8 	sub	r9,r7,-24
80007c02:	e0 4a 00 24 	cp.w	r10,36
80007c06:	c0 71       	brne	80007c14 <_realloc_r+0x130>
80007c08:	09 0a       	ld.w	r10,r4++
80007c0a:	93 0a       	st.w	r9[0x0],r10
80007c0c:	ee c9 ff e0 	sub	r9,r7,-32
80007c10:	09 0a       	ld.w	r10,r4++
80007c12:	8f 7a       	st.w	r7[0x1c],r10
80007c14:	09 0a       	ld.w	r10,r4++
80007c16:	12 aa       	st.w	r9++,r10
80007c18:	68 0a       	ld.w	r10,r4[0x0]
80007c1a:	93 0a       	st.w	r9[0x0],r10
80007c1c:	68 1a       	ld.w	r10,r4[0x4]
80007c1e:	93 1a       	st.w	r9[0x4],r10
80007c20:	c0 78       	rjmp	80007c2e <_realloc_r+0x14a>
80007c22:	50 08       	stdsp	sp[0x0],r8
80007c24:	08 9b       	mov	r11,r4
80007c26:	0a 9c       	mov	r12,r5
80007c28:	e0 a0 1d 8f 	rcall	8000b746 <memmove>
80007c2c:	40 08       	lddsp	r8,sp[0x0]
80007c2e:	ee 06 00 09 	add	r9,r7,r6
80007c32:	0c 13       	sub	r3,r6
80007c34:	a1 a3       	sbr	r3,0x0
80007c36:	93 13       	st.w	r9[0x4],r3
80007c38:	91 29       	st.w	r8[0x8],r9
80007c3a:	04 9c       	mov	r12,r2
80007c3c:	6e 18       	ld.w	r8,r7[0x4]
80007c3e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007c42:	10 46       	or	r6,r8
80007c44:	8f 16       	st.w	r7[0x4],r6
80007c46:	ca a8       	rjmp	80007d9a <_realloc_r+0x2b6>
80007c48:	14 03       	add	r3,r10
80007c4a:	0c 33       	cp.w	r3,r6
80007c4c:	c0 85       	brlt	80007c5c <_realloc_r+0x178>
80007c4e:	72 28       	ld.w	r8,r9[0x8]
80007c50:	72 39       	ld.w	r9,r9[0xc]
80007c52:	93 28       	st.w	r9[0x8],r8
80007c54:	91 39       	st.w	r8[0xc],r9
80007c56:	6e 28       	ld.w	r8,r7[0x8]
80007c58:	6e 39       	ld.w	r9,r7[0xc]
80007c5a:	c0 78       	rjmp	80007c68 <_realloc_r+0x184>
80007c5c:	f8 00 00 03 	add	r3,r12,r0
80007c60:	0c 33       	cp.w	r3,r6
80007c62:	c3 35       	brlt	80007cc8 <_realloc_r+0x1e4>
80007c64:	6e 39       	ld.w	r9,r7[0xc]
80007c66:	6e 28       	ld.w	r8,r7[0x8]
80007c68:	93 28       	st.w	r9[0x8],r8
80007c6a:	91 39       	st.w	r8[0xc],r9
80007c6c:	e0 ca 00 04 	sub	r10,r0,4
80007c70:	ee cc ff f8 	sub	r12,r7,-8
80007c74:	e0 4a 00 24 	cp.w	r10,36
80007c78:	e0 8b 00 24 	brhi	80007cc0 <_realloc_r+0x1dc>
80007c7c:	59 3a       	cp.w	r10,19
80007c7e:	e0 88 00 1a 	brls	80007cb2 <_realloc_r+0x1ce>
80007c82:	09 08       	ld.w	r8,r4++
80007c84:	99 08       	st.w	r12[0x0],r8
80007c86:	09 08       	ld.w	r8,r4++
80007c88:	8f 38       	st.w	r7[0xc],r8
80007c8a:	ee cc ff f0 	sub	r12,r7,-16
80007c8e:	59 ba       	cp.w	r10,27
80007c90:	e0 88 00 11 	brls	80007cb2 <_realloc_r+0x1ce>
80007c94:	09 08       	ld.w	r8,r4++
80007c96:	99 08       	st.w	r12[0x0],r8
80007c98:	09 08       	ld.w	r8,r4++
80007c9a:	8f 58       	st.w	r7[0x14],r8
80007c9c:	ee cc ff e8 	sub	r12,r7,-24
80007ca0:	e0 4a 00 24 	cp.w	r10,36
80007ca4:	c0 71       	brne	80007cb2 <_realloc_r+0x1ce>
80007ca6:	09 08       	ld.w	r8,r4++
80007ca8:	99 08       	st.w	r12[0x0],r8
80007caa:	ee cc ff e0 	sub	r12,r7,-32
80007cae:	09 08       	ld.w	r8,r4++
80007cb0:	8f 78       	st.w	r7[0x1c],r8
80007cb2:	09 08       	ld.w	r8,r4++
80007cb4:	18 a8       	st.w	r12++,r8
80007cb6:	68 08       	ld.w	r8,r4[0x0]
80007cb8:	99 08       	st.w	r12[0x0],r8
80007cba:	68 18       	ld.w	r8,r4[0x4]
80007cbc:	99 18       	st.w	r12[0x4],r8
80007cbe:	c4 78       	rjmp	80007d4c <_realloc_r+0x268>
80007cc0:	08 9b       	mov	r11,r4
80007cc2:	e0 a0 1d 42 	rcall	8000b746 <memmove>
80007cc6:	c4 38       	rjmp	80007d4c <_realloc_r+0x268>
80007cc8:	04 9c       	mov	r12,r2
80007cca:	fe b0 fc 45 	rcall	80007554 <_malloc_r>
80007cce:	18 95       	mov	r5,r12
80007cd0:	c3 a0       	breq	80007d44 <_realloc_r+0x260>
80007cd2:	62 18       	ld.w	r8,r1[0x4]
80007cd4:	f8 c9 00 08 	sub	r9,r12,8
80007cd8:	a1 c8       	cbr	r8,0x0
80007cda:	e2 08 00 08 	add	r8,r1,r8
80007cde:	10 39       	cp.w	r9,r8
80007ce0:	c0 71       	brne	80007cee <_realloc_r+0x20a>
80007ce2:	72 13       	ld.w	r3,r9[0x4]
80007ce4:	02 97       	mov	r7,r1
80007ce6:	e0 13 ff fc 	andl	r3,0xfffc
80007cea:	00 03       	add	r3,r0
80007cec:	c3 08       	rjmp	80007d4c <_realloc_r+0x268>
80007cee:	e0 ca 00 04 	sub	r10,r0,4
80007cf2:	e0 4a 00 24 	cp.w	r10,36
80007cf6:	e0 8b 00 20 	brhi	80007d36 <_realloc_r+0x252>
80007cfa:	08 99       	mov	r9,r4
80007cfc:	18 98       	mov	r8,r12
80007cfe:	59 3a       	cp.w	r10,19
80007d00:	e0 88 00 14 	brls	80007d28 <_realloc_r+0x244>
80007d04:	13 0b       	ld.w	r11,r9++
80007d06:	10 ab       	st.w	r8++,r11
80007d08:	13 0b       	ld.w	r11,r9++
80007d0a:	10 ab       	st.w	r8++,r11
80007d0c:	59 ba       	cp.w	r10,27
80007d0e:	e0 88 00 0d 	brls	80007d28 <_realloc_r+0x244>
80007d12:	13 0b       	ld.w	r11,r9++
80007d14:	10 ab       	st.w	r8++,r11
80007d16:	13 0b       	ld.w	r11,r9++
80007d18:	10 ab       	st.w	r8++,r11
80007d1a:	e0 4a 00 24 	cp.w	r10,36
80007d1e:	c0 51       	brne	80007d28 <_realloc_r+0x244>
80007d20:	13 0a       	ld.w	r10,r9++
80007d22:	10 aa       	st.w	r8++,r10
80007d24:	13 0a       	ld.w	r10,r9++
80007d26:	10 aa       	st.w	r8++,r10
80007d28:	13 0a       	ld.w	r10,r9++
80007d2a:	10 aa       	st.w	r8++,r10
80007d2c:	72 0a       	ld.w	r10,r9[0x0]
80007d2e:	91 0a       	st.w	r8[0x0],r10
80007d30:	72 19       	ld.w	r9,r9[0x4]
80007d32:	91 19       	st.w	r8[0x4],r9
80007d34:	c0 48       	rjmp	80007d3c <_realloc_r+0x258>
80007d36:	08 9b       	mov	r11,r4
80007d38:	e0 a0 1d 07 	rcall	8000b746 <memmove>
80007d3c:	08 9b       	mov	r11,r4
80007d3e:	04 9c       	mov	r12,r2
80007d40:	e0 a0 1a 60 	rcall	8000b200 <_free_r>
80007d44:	04 9c       	mov	r12,r2
80007d46:	c2 a8       	rjmp	80007d9a <_realloc_r+0x2b6>
80007d48:	00 93       	mov	r3,r0
80007d4a:	02 97       	mov	r7,r1
80007d4c:	e6 06 01 09 	sub	r9,r3,r6
80007d50:	6e 18       	ld.w	r8,r7[0x4]
80007d52:	58 f9       	cp.w	r9,15
80007d54:	e0 88 00 16 	brls	80007d80 <_realloc_r+0x29c>
80007d58:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007d5c:	ed e8 10 08 	or	r8,r6,r8
80007d60:	8f 18       	st.w	r7[0x4],r8
80007d62:	12 98       	mov	r8,r9
80007d64:	a1 a8       	sbr	r8,0x0
80007d66:	ee 06 00 0b 	add	r11,r7,r6
80007d6a:	f6 09 00 09 	add	r9,r11,r9
80007d6e:	97 18       	st.w	r11[0x4],r8
80007d70:	72 18       	ld.w	r8,r9[0x4]
80007d72:	a1 a8       	sbr	r8,0x0
80007d74:	2f 8b       	sub	r11,-8
80007d76:	93 18       	st.w	r9[0x4],r8
80007d78:	04 9c       	mov	r12,r2
80007d7a:	e0 a0 1a 43 	rcall	8000b200 <_free_r>
80007d7e:	c0 b8       	rjmp	80007d94 <_realloc_r+0x2b0>
80007d80:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007d84:	e7 e8 10 08 	or	r8,r3,r8
80007d88:	8f 18       	st.w	r7[0x4],r8
80007d8a:	ee 03 00 03 	add	r3,r7,r3
80007d8e:	66 18       	ld.w	r8,r3[0x4]
80007d90:	a1 a8       	sbr	r8,0x0
80007d92:	87 18       	st.w	r3[0x4],r8
80007d94:	04 9c       	mov	r12,r2
80007d96:	ee c5 ff f8 	sub	r5,r7,-8
80007d9a:	fe b0 f1 9d 	rcall	800060d4 <__malloc_unlock>
80007d9e:	0a 9c       	mov	r12,r5
80007da0:	2f fd       	sub	sp,-4
80007da2:	d8 32       	popm	r0-r7,pc

80007da4 <_sbrk_r>:
80007da4:	d4 21       	pushm	r4-r7,lr
80007da6:	30 08       	mov	r8,0
80007da8:	18 97       	mov	r7,r12
80007daa:	e0 66 53 c8 	mov	r6,21448
80007dae:	16 9c       	mov	r12,r11
80007db0:	8d 08       	st.w	r6[0x0],r8
80007db2:	c8 5c       	rcall	80007ebc <_sbrk>
80007db4:	5b fc       	cp.w	r12,-1
80007db6:	c0 51       	brne	80007dc0 <_sbrk_r+0x1c>
80007db8:	6c 08       	ld.w	r8,r6[0x0]
80007dba:	58 08       	cp.w	r8,0
80007dbc:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007dc0:	d8 22       	popm	r4-r7,pc
80007dc2:	d7 03       	nop

80007dc4 <sprintf>:
80007dc4:	d4 01       	pushm	lr
80007dc6:	21 7d       	sub	sp,92
80007dc8:	e0 68 ff ff 	mov	r8,65535
80007dcc:	ea 18 7f ff 	orh	r8,0x7fff
80007dd0:	50 58       	stdsp	sp[0x14],r8
80007dd2:	50 28       	stdsp	sp[0x8],r8
80007dd4:	e0 68 02 08 	mov	r8,520
80007dd8:	ba 68       	st.h	sp[0xc],r8
80007dda:	3f f8       	mov	r8,-1
80007ddc:	ba 78       	st.h	sp[0xe],r8
80007dde:	e0 68 0a 40 	mov	r8,2624
80007de2:	50 4c       	stdsp	sp[0x10],r12
80007de4:	16 9a       	mov	r10,r11
80007de6:	50 0c       	stdsp	sp[0x0],r12
80007de8:	fa c9 ff a0 	sub	r9,sp,-96
80007dec:	70 0c       	ld.w	r12,r8[0x0]
80007dee:	1a 9b       	mov	r11,sp
80007df0:	e0 a0 02 1a 	rcall	80008224 <_vfprintf_r>
80007df4:	30 09       	mov	r9,0
80007df6:	40 08       	lddsp	r8,sp[0x0]
80007df8:	b0 89       	st.b	r8[0x0],r9
80007dfa:	2e 9d       	sub	sp,-92
80007dfc:	d8 02       	popm	pc
80007dfe:	d7 03       	nop

80007e00 <strncpy>:
80007e00:	30 08       	mov	r8,0
80007e02:	10 3a       	cp.w	r10,r8
80007e04:	5e 0c       	reteq	r12
80007e06:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007e0a:	f8 08 0b 09 	st.b	r12[r8],r9
80007e0e:	2f f8       	sub	r8,-1
80007e10:	58 09       	cp.w	r9,0
80007e12:	cf 81       	brne	80007e02 <strncpy+0x2>
80007e14:	10 3a       	cp.w	r10,r8
80007e16:	5e 0c       	reteq	r12
80007e18:	f8 08 0b 09 	st.b	r12[r8],r9
80007e1c:	2f f8       	sub	r8,-1
80007e1e:	cf bb       	rjmp	80007e14 <strncpy+0x14>

80007e20 <_close>:
80007e20:	30 28       	mov	r8,2
80007e22:	d6 73       	breakpoint
80007e24:	3f fc       	mov	r12,-1
80007e26:	35 8b       	mov	r11,88
80007e28:	58 0c       	cp.w	r12,0
80007e2a:	5e 4c       	retge	r12
80007e2c:	e0 6a 53 c8 	mov	r10,21448
80007e30:	95 0b       	st.w	r10[0x0],r11
80007e32:	5e fc       	retal	r12

80007e34 <_lseek>:
80007e34:	30 58       	mov	r8,5
80007e36:	d6 73       	breakpoint
80007e38:	3f fc       	mov	r12,-1
80007e3a:	35 8b       	mov	r11,88
80007e3c:	58 0c       	cp.w	r12,0
80007e3e:	5e 4c       	retge	r12
80007e40:	e0 6a 53 c8 	mov	r10,21448
80007e44:	95 0b       	st.w	r10[0x0],r11
80007e46:	5e fc       	retal	r12

80007e48 <isatty>:
80007e48:	30 b8       	mov	r8,11
80007e4a:	d6 73       	breakpoint
80007e4c:	3f fc       	mov	r12,-1
80007e4e:	35 8b       	mov	r11,88
80007e50:	58 0c       	cp.w	r12,0
80007e52:	5e 4c       	retge	r12
80007e54:	e0 6a 53 c8 	mov	r10,21448
80007e58:	95 0b       	st.w	r10[0x0],r11
80007e5a:	5e fc       	retal	r12

80007e5c <_fstat_host>:
80007e5c:	30 98       	mov	r8,9
80007e5e:	d6 73       	breakpoint
80007e60:	3f fc       	mov	r12,-1
80007e62:	35 8b       	mov	r11,88
80007e64:	58 0c       	cp.w	r12,0
80007e66:	5e 4c       	retge	r12
80007e68:	e0 6a 53 c8 	mov	r10,21448
80007e6c:	95 0b       	st.w	r10[0x0],r11
80007e6e:	5e fc       	retal	r12

80007e70 <_fstat>:
80007e70:	d4 21       	pushm	r4-r7,lr
80007e72:	21 0d       	sub	sp,64
80007e74:	16 97       	mov	r7,r11
80007e76:	1a 9b       	mov	r11,sp
80007e78:	cf 2f       	rcall	80007e5c <_fstat_host>
80007e7a:	c0 34       	brge	80007e80 <_fstat+0x10>
80007e7c:	3f fc       	mov	r12,-1
80007e7e:	c1 c8       	rjmp	80007eb6 <_fstat+0x46>
80007e80:	40 08       	lddsp	r8,sp[0x0]
80007e82:	ae 08       	st.h	r7[0x0],r8
80007e84:	40 18       	lddsp	r8,sp[0x4]
80007e86:	ae 18       	st.h	r7[0x2],r8
80007e88:	40 28       	lddsp	r8,sp[0x8]
80007e8a:	8f 18       	st.w	r7[0x4],r8
80007e8c:	40 38       	lddsp	r8,sp[0xc]
80007e8e:	ae 48       	st.h	r7[0x8],r8
80007e90:	40 48       	lddsp	r8,sp[0x10]
80007e92:	ae 58       	st.h	r7[0xa],r8
80007e94:	40 58       	lddsp	r8,sp[0x14]
80007e96:	ae 68       	st.h	r7[0xc],r8
80007e98:	40 68       	lddsp	r8,sp[0x18]
80007e9a:	ae 78       	st.h	r7[0xe],r8
80007e9c:	40 88       	lddsp	r8,sp[0x20]
80007e9e:	8f 48       	st.w	r7[0x10],r8
80007ea0:	40 a8       	lddsp	r8,sp[0x28]
80007ea2:	8f b8       	st.w	r7[0x2c],r8
80007ea4:	40 c8       	lddsp	r8,sp[0x30]
80007ea6:	8f c8       	st.w	r7[0x30],r8
80007ea8:	40 d8       	lddsp	r8,sp[0x34]
80007eaa:	8f 58       	st.w	r7[0x14],r8
80007eac:	40 e8       	lddsp	r8,sp[0x38]
80007eae:	30 0c       	mov	r12,0
80007eb0:	8f 78       	st.w	r7[0x1c],r8
80007eb2:	40 f8       	lddsp	r8,sp[0x3c]
80007eb4:	8f 98       	st.w	r7[0x24],r8
80007eb6:	2f 0d       	sub	sp,-64
80007eb8:	d8 22       	popm	r4-r7,pc
80007eba:	d7 03       	nop

80007ebc <_sbrk>:
80007ebc:	d4 01       	pushm	lr
80007ebe:	e0 68 0d 94 	mov	r8,3476
80007ec2:	70 09       	ld.w	r9,r8[0x0]
80007ec4:	58 09       	cp.w	r9,0
80007ec6:	c0 41       	brne	80007ece <_sbrk+0x12>
80007ec8:	e0 69 53 d0 	mov	r9,21456
80007ecc:	91 09       	st.w	r8[0x0],r9
80007ece:	e0 69 0d 94 	mov	r9,3476
80007ed2:	e0 7a 70 00 	mov	r10,94208
80007ed6:	72 08       	ld.w	r8,r9[0x0]
80007ed8:	f0 0c 00 0c 	add	r12,r8,r12
80007edc:	14 3c       	cp.w	r12,r10
80007ede:	e0 8b 00 04 	brhi	80007ee6 <_sbrk+0x2a>
80007ee2:	93 0c       	st.w	r9[0x0],r12
80007ee4:	c0 68       	rjmp	80007ef0 <_sbrk+0x34>
80007ee6:	e0 a0 18 15 	rcall	8000af10 <__errno>
80007eea:	30 c8       	mov	r8,12
80007eec:	99 08       	st.w	r12[0x0],r8
80007eee:	3f f8       	mov	r8,-1
80007ef0:	10 9c       	mov	r12,r8
80007ef2:	d8 02       	popm	pc

80007ef4 <get_arg>:
80007ef4:	d4 31       	pushm	r0-r7,lr
80007ef6:	20 8d       	sub	sp,32
80007ef8:	fa c4 ff bc 	sub	r4,sp,-68
80007efc:	50 4b       	stdsp	sp[0x10],r11
80007efe:	68 2e       	ld.w	lr,r4[0x8]
80007f00:	50 58       	stdsp	sp[0x14],r8
80007f02:	12 96       	mov	r6,r9
80007f04:	7c 0b       	ld.w	r11,lr[0x0]
80007f06:	70 05       	ld.w	r5,r8[0x0]
80007f08:	50 6e       	stdsp	sp[0x18],lr
80007f0a:	58 0b       	cp.w	r11,0
80007f0c:	f4 0b 17 00 	moveq	r11,r10
80007f10:	68 03       	ld.w	r3,r4[0x0]
80007f12:	68 11       	ld.w	r1,r4[0x4]
80007f14:	40 49       	lddsp	r9,sp[0x10]
80007f16:	30 08       	mov	r8,0
80007f18:	c2 89       	rjmp	80008168 <get_arg+0x274>
80007f1a:	2f fb       	sub	r11,-1
80007f1c:	32 5c       	mov	r12,37
80007f1e:	17 8a       	ld.ub	r10,r11[0x0]
80007f20:	f8 0a 18 00 	cp.b	r10,r12
80007f24:	5f 1e       	srne	lr
80007f26:	f0 0a 18 00 	cp.b	r10,r8
80007f2a:	5f 1c       	srne	r12
80007f2c:	fd ec 00 0c 	and	r12,lr,r12
80007f30:	f0 0c 18 00 	cp.b	r12,r8
80007f34:	cf 31       	brne	80007f1a <get_arg+0x26>
80007f36:	58 0a       	cp.w	r10,0
80007f38:	e0 80 01 25 	breq	80008182 <get_arg+0x28e>
80007f3c:	30 0c       	mov	r12,0
80007f3e:	3f fa       	mov	r10,-1
80007f40:	18 90       	mov	r0,r12
80007f42:	50 3a       	stdsp	sp[0xc],r10
80007f44:	18 94       	mov	r4,r12
80007f46:	18 92       	mov	r2,r12
80007f48:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80007f4c:	16 97       	mov	r7,r11
80007f4e:	50 7c       	stdsp	sp[0x1c],r12
80007f50:	fe cc 9d 20 	sub	r12,pc,-25312
80007f54:	0f 3a       	ld.ub	r10,r7++
80007f56:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80007f5a:	40 7c       	lddsp	r12,sp[0x1c]
80007f5c:	1c 0c       	add	r12,lr
80007f5e:	fe ce 9d f6 	sub	lr,pc,-25098
80007f62:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80007f66:	20 1e       	sub	lr,1
80007f68:	50 0e       	stdsp	sp[0x0],lr
80007f6a:	fe ce 9e 6e 	sub	lr,pc,-24978
80007f6e:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80007f72:	50 7c       	stdsp	sp[0x1c],r12
80007f74:	40 0c       	lddsp	r12,sp[0x0]
80007f76:	58 7c       	cp.w	r12,7
80007f78:	e0 8b 00 f1 	brhi	8000815a <get_arg+0x266>
80007f7c:	fe ce a0 20 	sub	lr,pc,-24544
80007f80:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80007f84:	36 8b       	mov	r11,104
80007f86:	f6 0a 18 00 	cp.b	r10,r11
80007f8a:	e0 80 00 e8 	breq	8000815a <get_arg+0x266>
80007f8e:	37 1b       	mov	r11,113
80007f90:	f6 0a 18 00 	cp.b	r10,r11
80007f94:	c0 70       	breq	80007fa2 <get_arg+0xae>
80007f96:	34 cb       	mov	r11,76
80007f98:	f6 0a 18 00 	cp.b	r10,r11
80007f9c:	c0 51       	brne	80007fa6 <get_arg+0xb2>
80007f9e:	a3 b4       	sbr	r4,0x3
80007fa0:	cd d8       	rjmp	8000815a <get_arg+0x266>
80007fa2:	a5 b4       	sbr	r4,0x5
80007fa4:	cd b8       	rjmp	8000815a <get_arg+0x266>
80007fa6:	08 9a       	mov	r10,r4
80007fa8:	0e 9b       	mov	r11,r7
80007faa:	a5 aa       	sbr	r10,0x4
80007fac:	17 3c       	ld.ub	r12,r11++
80007fae:	a5 b4       	sbr	r4,0x5
80007fb0:	36 ce       	mov	lr,108
80007fb2:	fc 0c 18 00 	cp.b	r12,lr
80007fb6:	e0 80 00 d3 	breq	8000815c <get_arg+0x268>
80007fba:	14 94       	mov	r4,r10
80007fbc:	cc f8       	rjmp	8000815a <get_arg+0x266>
80007fbe:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80007fc2:	36 7c       	mov	r12,103
80007fc4:	f8 0a 18 00 	cp.b	r10,r12
80007fc8:	e0 8b 00 27 	brhi	80008016 <get_arg+0x122>
80007fcc:	36 5b       	mov	r11,101
80007fce:	f6 0a 18 00 	cp.b	r10,r11
80007fd2:	c4 82       	brcc	80008062 <get_arg+0x16e>
80007fd4:	34 fb       	mov	r11,79
80007fd6:	f6 0a 18 00 	cp.b	r10,r11
80007fda:	c4 80       	breq	8000806a <get_arg+0x176>
80007fdc:	e0 8b 00 0c 	brhi	80007ff4 <get_arg+0x100>
80007fe0:	34 5b       	mov	r11,69
80007fe2:	f6 0a 18 00 	cp.b	r10,r11
80007fe6:	c3 e0       	breq	80008062 <get_arg+0x16e>
80007fe8:	34 7b       	mov	r11,71
80007fea:	f6 0a 18 00 	cp.b	r10,r11
80007fee:	c3 a0       	breq	80008062 <get_arg+0x16e>
80007ff0:	34 4b       	mov	r11,68
80007ff2:	c0 88       	rjmp	80008002 <get_arg+0x10e>
80007ff4:	35 8b       	mov	r11,88
80007ff6:	f6 0a 18 00 	cp.b	r10,r11
80007ffa:	c2 c0       	breq	80008052 <get_arg+0x15e>
80007ffc:	e0 8b 00 07 	brhi	8000800a <get_arg+0x116>
80008000:	35 5b       	mov	r11,85
80008002:	f6 0a 18 00 	cp.b	r10,r11
80008006:	c3 51       	brne	80008070 <get_arg+0x17c>
80008008:	c3 18       	rjmp	8000806a <get_arg+0x176>
8000800a:	36 3b       	mov	r11,99
8000800c:	f6 0a 18 00 	cp.b	r10,r11
80008010:	c2 f0       	breq	8000806e <get_arg+0x17a>
80008012:	36 4b       	mov	r11,100
80008014:	c0 e8       	rjmp	80008030 <get_arg+0x13c>
80008016:	37 0b       	mov	r11,112
80008018:	f6 0a 18 00 	cp.b	r10,r11
8000801c:	c2 50       	breq	80008066 <get_arg+0x172>
8000801e:	e0 8b 00 0d 	brhi	80008038 <get_arg+0x144>
80008022:	36 eb       	mov	r11,110
80008024:	f6 0a 18 00 	cp.b	r10,r11
80008028:	c1 f0       	breq	80008066 <get_arg+0x172>
8000802a:	e0 8b 00 14 	brhi	80008052 <get_arg+0x15e>
8000802e:	36 9b       	mov	r11,105
80008030:	f6 0a 18 00 	cp.b	r10,r11
80008034:	c1 e1       	brne	80008070 <get_arg+0x17c>
80008036:	c0 e8       	rjmp	80008052 <get_arg+0x15e>
80008038:	37 5b       	mov	r11,117
8000803a:	f6 0a 18 00 	cp.b	r10,r11
8000803e:	c0 a0       	breq	80008052 <get_arg+0x15e>
80008040:	37 8b       	mov	r11,120
80008042:	f6 0a 18 00 	cp.b	r10,r11
80008046:	c0 60       	breq	80008052 <get_arg+0x15e>
80008048:	37 3b       	mov	r11,115
8000804a:	f6 0a 18 00 	cp.b	r10,r11
8000804e:	c1 11       	brne	80008070 <get_arg+0x17c>
80008050:	c0 b8       	rjmp	80008066 <get_arg+0x172>
80008052:	ed b4 00 04 	bld	r4,0x4
80008056:	c0 a0       	breq	8000806a <get_arg+0x176>
80008058:	ed b4 00 05 	bld	r4,0x5
8000805c:	c0 91       	brne	8000806e <get_arg+0x17a>
8000805e:	30 20       	mov	r0,2
80008060:	c0 88       	rjmp	80008070 <get_arg+0x17c>
80008062:	30 40       	mov	r0,4
80008064:	c0 68       	rjmp	80008070 <get_arg+0x17c>
80008066:	30 30       	mov	r0,3
80008068:	c0 48       	rjmp	80008070 <get_arg+0x17c>
8000806a:	30 10       	mov	r0,1
8000806c:	c0 28       	rjmp	80008070 <get_arg+0x17c>
8000806e:	30 00       	mov	r0,0
80008070:	40 3b       	lddsp	r11,sp[0xc]
80008072:	5b fb       	cp.w	r11,-1
80008074:	c0 40       	breq	8000807c <get_arg+0x188>
80008076:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000807a:	c7 08       	rjmp	8000815a <get_arg+0x266>
8000807c:	58 60       	cp.w	r0,6
8000807e:	e0 8b 00 6e 	brhi	8000815a <get_arg+0x266>
80008082:	6c 0a       	ld.w	r10,r6[0x0]
80008084:	ea cc ff ff 	sub	r12,r5,-1
80008088:	fe ce a1 0c 	sub	lr,pc,-24308
8000808c:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008090:	f4 cb ff f8 	sub	r11,r10,-8
80008094:	8d 0b       	st.w	r6[0x0],r11
80008096:	f4 ea 00 00 	ld.d	r10,r10[0]
8000809a:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000809e:	c0 f8       	rjmp	800080bc <get_arg+0x1c8>
800080a0:	f4 cb ff fc 	sub	r11,r10,-4
800080a4:	8d 0b       	st.w	r6[0x0],r11
800080a6:	74 0a       	ld.w	r10,r10[0x0]
800080a8:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800080ac:	c0 88       	rjmp	800080bc <get_arg+0x1c8>
800080ae:	f4 cb ff f8 	sub	r11,r10,-8
800080b2:	8d 0b       	st.w	r6[0x0],r11
800080b4:	f4 ea 00 00 	ld.d	r10,r10[0]
800080b8:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
800080bc:	0e 9b       	mov	r11,r7
800080be:	18 95       	mov	r5,r12
800080c0:	c4 e8       	rjmp	8000815c <get_arg+0x268>
800080c2:	62 0a       	ld.w	r10,r1[0x0]
800080c4:	5b fa       	cp.w	r10,-1
800080c6:	c0 b1       	brne	800080dc <get_arg+0x1e8>
800080c8:	50 19       	stdsp	sp[0x4],r9
800080ca:	50 28       	stdsp	sp[0x8],r8
800080cc:	e0 6a 00 80 	mov	r10,128
800080d0:	30 0b       	mov	r11,0
800080d2:	02 9c       	mov	r12,r1
800080d4:	fe b0 fd 00 	rcall	80007ad4 <memset>
800080d8:	40 28       	lddsp	r8,sp[0x8]
800080da:	40 19       	lddsp	r9,sp[0x4]
800080dc:	e4 cc 00 01 	sub	r12,r2,1
800080e0:	0e 9b       	mov	r11,r7
800080e2:	50 3c       	stdsp	sp[0xc],r12
800080e4:	f2 0c 0c 49 	max	r9,r9,r12
800080e8:	c3 a8       	rjmp	8000815c <get_arg+0x268>
800080ea:	62 0a       	ld.w	r10,r1[0x0]
800080ec:	5b fa       	cp.w	r10,-1
800080ee:	c0 b1       	brne	80008104 <get_arg+0x210>
800080f0:	50 19       	stdsp	sp[0x4],r9
800080f2:	50 28       	stdsp	sp[0x8],r8
800080f4:	e0 6a 00 80 	mov	r10,128
800080f8:	30 0b       	mov	r11,0
800080fa:	02 9c       	mov	r12,r1
800080fc:	fe b0 fc ec 	rcall	80007ad4 <memset>
80008100:	40 28       	lddsp	r8,sp[0x8]
80008102:	40 19       	lddsp	r9,sp[0x4]
80008104:	20 12       	sub	r2,1
80008106:	30 0a       	mov	r10,0
80008108:	0e 9b       	mov	r11,r7
8000810a:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000810e:	f2 02 0c 49 	max	r9,r9,r2
80008112:	c2 58       	rjmp	8000815c <get_arg+0x268>
80008114:	16 97       	mov	r7,r11
80008116:	6c 0a       	ld.w	r10,r6[0x0]
80008118:	f4 cb ff fc 	sub	r11,r10,-4
8000811c:	8d 0b       	st.w	r6[0x0],r11
8000811e:	74 0a       	ld.w	r10,r10[0x0]
80008120:	0e 9b       	mov	r11,r7
80008122:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008126:	2f f5       	sub	r5,-1
80008128:	c1 a8       	rjmp	8000815c <get_arg+0x268>
8000812a:	f4 c2 00 30 	sub	r2,r10,48
8000812e:	c0 68       	rjmp	8000813a <get_arg+0x246>
80008130:	e4 02 00 22 	add	r2,r2,r2<<0x2
80008134:	2f f7       	sub	r7,-1
80008136:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000813a:	0f 8a       	ld.ub	r10,r7[0x0]
8000813c:	58 0a       	cp.w	r10,0
8000813e:	c0 e0       	breq	8000815a <get_arg+0x266>
80008140:	23 0a       	sub	r10,48
80008142:	58 9a       	cp.w	r10,9
80008144:	fe 98 ff f6 	brls	80008130 <get_arg+0x23c>
80008148:	c0 98       	rjmp	8000815a <get_arg+0x266>
8000814a:	2f f7       	sub	r7,-1
8000814c:	0f 8a       	ld.ub	r10,r7[0x0]
8000814e:	58 0a       	cp.w	r10,0
80008150:	c0 50       	breq	8000815a <get_arg+0x266>
80008152:	23 0a       	sub	r10,48
80008154:	58 9a       	cp.w	r10,9
80008156:	fe 98 ff fa 	brls	8000814a <get_arg+0x256>
8000815a:	0e 9b       	mov	r11,r7
8000815c:	40 7c       	lddsp	r12,sp[0x1c]
8000815e:	30 ba       	mov	r10,11
80008160:	f4 0c 18 00 	cp.b	r12,r10
80008164:	fe 91 fe f2 	brne	80007f48 <get_arg+0x54>
80008168:	40 42       	lddsp	r2,sp[0x10]
8000816a:	17 8c       	ld.ub	r12,r11[0x0]
8000816c:	0a 32       	cp.w	r2,r5
8000816e:	5f 4a       	srge	r10
80008170:	f0 0c 18 00 	cp.b	r12,r8
80008174:	5f 1c       	srne	r12
80008176:	f9 ea 00 0a 	and	r10,r12,r10
8000817a:	f0 0a 18 00 	cp.b	r10,r8
8000817e:	fe 91 fe cf 	brne	80007f1c <get_arg+0x28>
80008182:	30 08       	mov	r8,0
80008184:	40 4e       	lddsp	lr,sp[0x10]
80008186:	17 8a       	ld.ub	r10,r11[0x0]
80008188:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000818c:	f0 0a 18 00 	cp.b	r10,r8
80008190:	fc 09 17 10 	movne	r9,lr
80008194:	e6 05 00 38 	add	r8,r3,r5<<0x3
80008198:	06 9e       	mov	lr,r3
8000819a:	c2 a8       	rjmp	800081ee <get_arg+0x2fa>
8000819c:	62 0a       	ld.w	r10,r1[0x0]
8000819e:	58 3a       	cp.w	r10,3
800081a0:	c1 e0       	breq	800081dc <get_arg+0x2e8>
800081a2:	e0 89 00 07 	brgt	800081b0 <get_arg+0x2bc>
800081a6:	58 1a       	cp.w	r10,1
800081a8:	c1 a0       	breq	800081dc <get_arg+0x2e8>
800081aa:	58 2a       	cp.w	r10,2
800081ac:	c1 81       	brne	800081dc <get_arg+0x2e8>
800081ae:	c0 58       	rjmp	800081b8 <get_arg+0x2c4>
800081b0:	58 5a       	cp.w	r10,5
800081b2:	c0 c0       	breq	800081ca <get_arg+0x2d6>
800081b4:	c0 b5       	brlt	800081ca <get_arg+0x2d6>
800081b6:	c1 38       	rjmp	800081dc <get_arg+0x2e8>
800081b8:	6c 0a       	ld.w	r10,r6[0x0]
800081ba:	f4 cc ff f8 	sub	r12,r10,-8
800081be:	8d 0c       	st.w	r6[0x0],r12
800081c0:	f4 e2 00 00 	ld.d	r2,r10[0]
800081c4:	f0 e3 00 00 	st.d	r8[0],r2
800081c8:	c1 08       	rjmp	800081e8 <get_arg+0x2f4>
800081ca:	6c 0a       	ld.w	r10,r6[0x0]
800081cc:	f4 cc ff f8 	sub	r12,r10,-8
800081d0:	8d 0c       	st.w	r6[0x0],r12
800081d2:	f4 e2 00 00 	ld.d	r2,r10[0]
800081d6:	f0 e3 00 00 	st.d	r8[0],r2
800081da:	c0 78       	rjmp	800081e8 <get_arg+0x2f4>
800081dc:	6c 0a       	ld.w	r10,r6[0x0]
800081de:	f4 cc ff fc 	sub	r12,r10,-4
800081e2:	8d 0c       	st.w	r6[0x0],r12
800081e4:	74 0a       	ld.w	r10,r10[0x0]
800081e6:	91 0a       	st.w	r8[0x0],r10
800081e8:	2f f5       	sub	r5,-1
800081ea:	2f 88       	sub	r8,-8
800081ec:	2f c1       	sub	r1,-4
800081ee:	12 35       	cp.w	r5,r9
800081f0:	fe 9a ff d6 	brle	8000819c <get_arg+0x2a8>
800081f4:	1c 93       	mov	r3,lr
800081f6:	40 52       	lddsp	r2,sp[0x14]
800081f8:	40 6e       	lddsp	lr,sp[0x18]
800081fa:	85 05       	st.w	r2[0x0],r5
800081fc:	9d 0b       	st.w	lr[0x0],r11
800081fe:	40 4b       	lddsp	r11,sp[0x10]
80008200:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008204:	2f 8d       	sub	sp,-32
80008206:	d8 32       	popm	r0-r7,pc

80008208 <__sprint_r>:
80008208:	d4 21       	pushm	r4-r7,lr
8000820a:	14 97       	mov	r7,r10
8000820c:	74 28       	ld.w	r8,r10[0x8]
8000820e:	58 08       	cp.w	r8,0
80008210:	c0 41       	brne	80008218 <__sprint_r+0x10>
80008212:	95 18       	st.w	r10[0x4],r8
80008214:	10 9c       	mov	r12,r8
80008216:	d8 22       	popm	r4-r7,pc
80008218:	e0 a0 18 ba 	rcall	8000b38c <__sfvwrite_r>
8000821c:	30 08       	mov	r8,0
8000821e:	8f 18       	st.w	r7[0x4],r8
80008220:	8f 28       	st.w	r7[0x8],r8
80008222:	d8 22       	popm	r4-r7,pc

80008224 <_vfprintf_r>:
80008224:	d4 31       	pushm	r0-r7,lr
80008226:	fa cd 06 bc 	sub	sp,sp,1724
8000822a:	51 09       	stdsp	sp[0x40],r9
8000822c:	16 91       	mov	r1,r11
8000822e:	14 97       	mov	r7,r10
80008230:	18 95       	mov	r5,r12
80008232:	e0 a0 1a 1d 	rcall	8000b66c <_localeconv_r>
80008236:	78 0c       	ld.w	r12,r12[0x0]
80008238:	50 cc       	stdsp	sp[0x30],r12
8000823a:	58 05       	cp.w	r5,0
8000823c:	c0 70       	breq	8000824a <_vfprintf_r+0x26>
8000823e:	6a 68       	ld.w	r8,r5[0x18]
80008240:	58 08       	cp.w	r8,0
80008242:	c0 41       	brne	8000824a <_vfprintf_r+0x26>
80008244:	0a 9c       	mov	r12,r5
80008246:	e0 a0 17 43 	rcall	8000b0cc <__sinit>
8000824a:	fe c8 9f 0a 	sub	r8,pc,-24822
8000824e:	10 31       	cp.w	r1,r8
80008250:	c0 31       	brne	80008256 <_vfprintf_r+0x32>
80008252:	6a 01       	ld.w	r1,r5[0x0]
80008254:	c0 c8       	rjmp	8000826c <_vfprintf_r+0x48>
80008256:	fe c8 9e f6 	sub	r8,pc,-24842
8000825a:	10 31       	cp.w	r1,r8
8000825c:	c0 31       	brne	80008262 <_vfprintf_r+0x3e>
8000825e:	6a 11       	ld.w	r1,r5[0x4]
80008260:	c0 68       	rjmp	8000826c <_vfprintf_r+0x48>
80008262:	fe c8 9e e2 	sub	r8,pc,-24862
80008266:	10 31       	cp.w	r1,r8
80008268:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000826c:	82 68       	ld.sh	r8,r1[0xc]
8000826e:	ed b8 00 03 	bld	r8,0x3
80008272:	c0 41       	brne	8000827a <_vfprintf_r+0x56>
80008274:	62 48       	ld.w	r8,r1[0x10]
80008276:	58 08       	cp.w	r8,0
80008278:	c0 71       	brne	80008286 <_vfprintf_r+0x62>
8000827a:	02 9b       	mov	r11,r1
8000827c:	0a 9c       	mov	r12,r5
8000827e:	e0 a0 0f 5d 	rcall	8000a138 <__swsetup_r>
80008282:	e0 81 0f 54 	brne	8000a12a <_vfprintf_r+0x1f06>
80008286:	82 68       	ld.sh	r8,r1[0xc]
80008288:	10 99       	mov	r9,r8
8000828a:	e2 19 00 1a 	andl	r9,0x1a,COH
8000828e:	58 a9       	cp.w	r9,10
80008290:	c3 c1       	brne	80008308 <_vfprintf_r+0xe4>
80008292:	82 79       	ld.sh	r9,r1[0xe]
80008294:	30 0a       	mov	r10,0
80008296:	f4 09 19 00 	cp.h	r9,r10
8000829a:	c3 75       	brlt	80008308 <_vfprintf_r+0xe4>
8000829c:	a1 d8       	cbr	r8,0x1
8000829e:	fb 58 05 d0 	st.h	sp[1488],r8
800082a2:	62 88       	ld.w	r8,r1[0x20]
800082a4:	fb 48 05 e4 	st.w	sp[1508],r8
800082a8:	62 a8       	ld.w	r8,r1[0x28]
800082aa:	fb 48 05 ec 	st.w	sp[1516],r8
800082ae:	fa c8 ff bc 	sub	r8,sp,-68
800082b2:	fb 48 05 d4 	st.w	sp[1492],r8
800082b6:	fb 48 05 c4 	st.w	sp[1476],r8
800082ba:	e0 68 04 00 	mov	r8,1024
800082be:	fb 48 05 d8 	st.w	sp[1496],r8
800082c2:	fb 48 05 cc 	st.w	sp[1484],r8
800082c6:	30 08       	mov	r8,0
800082c8:	fb 59 05 d2 	st.h	sp[1490],r9
800082cc:	0e 9a       	mov	r10,r7
800082ce:	41 09       	lddsp	r9,sp[0x40]
800082d0:	fa c7 fa 3c 	sub	r7,sp,-1476
800082d4:	fb 48 05 dc 	st.w	sp[1500],r8
800082d8:	0a 9c       	mov	r12,r5
800082da:	0e 9b       	mov	r11,r7
800082dc:	ca 4f       	rcall	80008224 <_vfprintf_r>
800082de:	50 bc       	stdsp	sp[0x2c],r12
800082e0:	c0 95       	brlt	800082f2 <_vfprintf_r+0xce>
800082e2:	0e 9b       	mov	r11,r7
800082e4:	0a 9c       	mov	r12,r5
800082e6:	e0 a0 16 1b 	rcall	8000af1c <_fflush_r>
800082ea:	40 be       	lddsp	lr,sp[0x2c]
800082ec:	f9 be 01 ff 	movne	lr,-1
800082f0:	50 be       	stdsp	sp[0x2c],lr
800082f2:	fb 08 05 d0 	ld.sh	r8,sp[1488]
800082f6:	ed b8 00 06 	bld	r8,0x6
800082fa:	e0 81 0f 1a 	brne	8000a12e <_vfprintf_r+0x1f0a>
800082fe:	82 68       	ld.sh	r8,r1[0xc]
80008300:	a7 a8       	sbr	r8,0x6
80008302:	a2 68       	st.h	r1[0xc],r8
80008304:	e0 8f 0f 15 	bral	8000a12e <_vfprintf_r+0x1f0a>
80008308:	30 08       	mov	r8,0
8000830a:	fb 48 06 b4 	st.w	sp[1716],r8
8000830e:	fb 48 06 90 	st.w	sp[1680],r8
80008312:	fb 48 06 8c 	st.w	sp[1676],r8
80008316:	fb 48 06 b0 	st.w	sp[1712],r8
8000831a:	30 08       	mov	r8,0
8000831c:	30 09       	mov	r9,0
8000831e:	50 a7       	stdsp	sp[0x28],r7
80008320:	50 78       	stdsp	sp[0x1c],r8
80008322:	fa c3 f9 e0 	sub	r3,sp,-1568
80008326:	3f f8       	mov	r8,-1
80008328:	50 59       	stdsp	sp[0x14],r9
8000832a:	fb 43 06 88 	st.w	sp[1672],r3
8000832e:	fb 48 05 44 	st.w	sp[1348],r8
80008332:	12 9c       	mov	r12,r9
80008334:	50 69       	stdsp	sp[0x18],r9
80008336:	50 d9       	stdsp	sp[0x34],r9
80008338:	50 e9       	stdsp	sp[0x38],r9
8000833a:	50 b9       	stdsp	sp[0x2c],r9
8000833c:	12 97       	mov	r7,r9
8000833e:	0a 94       	mov	r4,r5
80008340:	40 a2       	lddsp	r2,sp[0x28]
80008342:	32 5a       	mov	r10,37
80008344:	30 08       	mov	r8,0
80008346:	c0 28       	rjmp	8000834a <_vfprintf_r+0x126>
80008348:	2f f2       	sub	r2,-1
8000834a:	05 89       	ld.ub	r9,r2[0x0]
8000834c:	f0 09 18 00 	cp.b	r9,r8
80008350:	5f 1b       	srne	r11
80008352:	f4 09 18 00 	cp.b	r9,r10
80008356:	5f 19       	srne	r9
80008358:	f3 eb 00 0b 	and	r11,r9,r11
8000835c:	f0 0b 18 00 	cp.b	r11,r8
80008360:	cf 41       	brne	80008348 <_vfprintf_r+0x124>
80008362:	40 ab       	lddsp	r11,sp[0x28]
80008364:	e4 0b 01 06 	sub	r6,r2,r11
80008368:	c1 e0       	breq	800083a4 <_vfprintf_r+0x180>
8000836a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000836e:	0c 08       	add	r8,r6
80008370:	87 0b       	st.w	r3[0x0],r11
80008372:	fb 48 06 90 	st.w	sp[1680],r8
80008376:	87 16       	st.w	r3[0x4],r6
80008378:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000837c:	2f f8       	sub	r8,-1
8000837e:	fb 48 06 8c 	st.w	sp[1676],r8
80008382:	58 78       	cp.w	r8,7
80008384:	e0 89 00 04 	brgt	8000838c <_vfprintf_r+0x168>
80008388:	2f 83       	sub	r3,-8
8000838a:	c0 a8       	rjmp	8000839e <_vfprintf_r+0x17a>
8000838c:	fa ca f9 78 	sub	r10,sp,-1672
80008390:	02 9b       	mov	r11,r1
80008392:	08 9c       	mov	r12,r4
80008394:	c3 af       	rcall	80008208 <__sprint_r>
80008396:	e0 81 0e c6 	brne	8000a122 <_vfprintf_r+0x1efe>
8000839a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000839e:	40 ba       	lddsp	r10,sp[0x2c]
800083a0:	0c 0a       	add	r10,r6
800083a2:	50 ba       	stdsp	sp[0x2c],r10
800083a4:	05 89       	ld.ub	r9,r2[0x0]
800083a6:	30 08       	mov	r8,0
800083a8:	f0 09 18 00 	cp.b	r9,r8
800083ac:	e0 80 0e aa 	breq	8000a100 <_vfprintf_r+0x1edc>
800083b0:	30 09       	mov	r9,0
800083b2:	fb 68 06 bb 	st.b	sp[1723],r8
800083b6:	0e 96       	mov	r6,r7
800083b8:	e4 c8 ff ff 	sub	r8,r2,-1
800083bc:	3f fe       	mov	lr,-1
800083be:	50 93       	stdsp	sp[0x24],r3
800083c0:	50 41       	stdsp	sp[0x10],r1
800083c2:	0e 93       	mov	r3,r7
800083c4:	04 91       	mov	r1,r2
800083c6:	50 89       	stdsp	sp[0x20],r9
800083c8:	50 a8       	stdsp	sp[0x28],r8
800083ca:	50 2e       	stdsp	sp[0x8],lr
800083cc:	50 39       	stdsp	sp[0xc],r9
800083ce:	12 95       	mov	r5,r9
800083d0:	12 90       	mov	r0,r9
800083d2:	10 97       	mov	r7,r8
800083d4:	08 92       	mov	r2,r4
800083d6:	c0 78       	rjmp	800083e4 <_vfprintf_r+0x1c0>
800083d8:	3f fc       	mov	r12,-1
800083da:	08 97       	mov	r7,r4
800083dc:	50 2c       	stdsp	sp[0x8],r12
800083de:	c0 38       	rjmp	800083e4 <_vfprintf_r+0x1c0>
800083e0:	30 0b       	mov	r11,0
800083e2:	50 3b       	stdsp	sp[0xc],r11
800083e4:	0f 38       	ld.ub	r8,r7++
800083e6:	c0 28       	rjmp	800083ea <_vfprintf_r+0x1c6>
800083e8:	12 90       	mov	r0,r9
800083ea:	f0 c9 00 20 	sub	r9,r8,32
800083ee:	e0 49 00 58 	cp.w	r9,88
800083f2:	e0 8b 0a 30 	brhi	80009852 <_vfprintf_r+0x162e>
800083f6:	fe ca a4 5e 	sub	r10,pc,-23458
800083fa:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
800083fe:	50 a7       	stdsp	sp[0x28],r7
80008400:	50 80       	stdsp	sp[0x20],r0
80008402:	0c 97       	mov	r7,r6
80008404:	04 94       	mov	r4,r2
80008406:	06 96       	mov	r6,r3
80008408:	02 92       	mov	r2,r1
8000840a:	fe c9 a2 36 	sub	r9,pc,-24010
8000840e:	40 93       	lddsp	r3,sp[0x24]
80008410:	10 90       	mov	r0,r8
80008412:	40 41       	lddsp	r1,sp[0x10]
80008414:	50 d9       	stdsp	sp[0x34],r9
80008416:	e0 8f 08 8e 	bral	80009532 <_vfprintf_r+0x130e>
8000841a:	30 08       	mov	r8,0
8000841c:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80008420:	f0 09 18 00 	cp.b	r9,r8
80008424:	ce 01       	brne	800083e4 <_vfprintf_r+0x1c0>
80008426:	32 08       	mov	r8,32
80008428:	c6 e8       	rjmp	80008504 <_vfprintf_r+0x2e0>
8000842a:	a1 a5       	sbr	r5,0x0
8000842c:	cd cb       	rjmp	800083e4 <_vfprintf_r+0x1c0>
8000842e:	0f 89       	ld.ub	r9,r7[0x0]
80008430:	f2 c8 00 30 	sub	r8,r9,48
80008434:	58 98       	cp.w	r8,9
80008436:	e0 8b 00 1d 	brhi	80008470 <_vfprintf_r+0x24c>
8000843a:	ee c8 ff ff 	sub	r8,r7,-1
8000843e:	30 0b       	mov	r11,0
80008440:	23 09       	sub	r9,48
80008442:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80008446:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000844a:	11 39       	ld.ub	r9,r8++
8000844c:	f2 ca 00 30 	sub	r10,r9,48
80008450:	58 9a       	cp.w	r10,9
80008452:	fe 98 ff f7 	brls	80008440 <_vfprintf_r+0x21c>
80008456:	e0 49 00 24 	cp.w	r9,36
8000845a:	cc 31       	brne	800083e0 <_vfprintf_r+0x1bc>
8000845c:	e0 4b 00 20 	cp.w	r11,32
80008460:	e0 89 0e 60 	brgt	8000a120 <_vfprintf_r+0x1efc>
80008464:	20 1b       	sub	r11,1
80008466:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000846a:	12 3b       	cp.w	r11,r9
8000846c:	c0 95       	brlt	8000847e <_vfprintf_r+0x25a>
8000846e:	c1 08       	rjmp	8000848e <_vfprintf_r+0x26a>
80008470:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008474:	ec ca ff ff 	sub	r10,r6,-1
80008478:	12 36       	cp.w	r6,r9
8000847a:	c1 f5       	brlt	800084b8 <_vfprintf_r+0x294>
8000847c:	c2 68       	rjmp	800084c8 <_vfprintf_r+0x2a4>
8000847e:	fa ce f9 44 	sub	lr,sp,-1724
80008482:	10 97       	mov	r7,r8
80008484:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80008488:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000848c:	c3 58       	rjmp	800084f6 <_vfprintf_r+0x2d2>
8000848e:	10 97       	mov	r7,r8
80008490:	fa c8 f9 50 	sub	r8,sp,-1712
80008494:	1a d8       	st.w	--sp,r8
80008496:	fa c8 fa b8 	sub	r8,sp,-1352
8000849a:	1a d8       	st.w	--sp,r8
8000849c:	fa c8 fb b4 	sub	r8,sp,-1100
800084a0:	02 9a       	mov	r10,r1
800084a2:	1a d8       	st.w	--sp,r8
800084a4:	04 9c       	mov	r12,r2
800084a6:	fa c8 f9 40 	sub	r8,sp,-1728
800084aa:	fa c9 ff b4 	sub	r9,sp,-76
800084ae:	fe b0 fd 23 	rcall	80007ef4 <get_arg>
800084b2:	2f dd       	sub	sp,-12
800084b4:	78 00       	ld.w	r0,r12[0x0]
800084b6:	c2 08       	rjmp	800084f6 <_vfprintf_r+0x2d2>
800084b8:	fa cc f9 44 	sub	r12,sp,-1724
800084bc:	14 96       	mov	r6,r10
800084be:	f8 03 00 38 	add	r8,r12,r3<<0x3
800084c2:	f0 f0 fd 88 	ld.w	r0,r8[-632]
800084c6:	c1 88       	rjmp	800084f6 <_vfprintf_r+0x2d2>
800084c8:	41 08       	lddsp	r8,sp[0x40]
800084ca:	59 f9       	cp.w	r9,31
800084cc:	e0 89 00 11 	brgt	800084ee <_vfprintf_r+0x2ca>
800084d0:	f0 cb ff fc 	sub	r11,r8,-4
800084d4:	51 0b       	stdsp	sp[0x40],r11
800084d6:	70 00       	ld.w	r0,r8[0x0]
800084d8:	fa cb f9 44 	sub	r11,sp,-1724
800084dc:	f6 09 00 38 	add	r8,r11,r9<<0x3
800084e0:	f1 40 fd 88 	st.w	r8[-632],r0
800084e4:	2f f9       	sub	r9,-1
800084e6:	14 96       	mov	r6,r10
800084e8:	fb 49 06 b4 	st.w	sp[1716],r9
800084ec:	c0 58       	rjmp	800084f6 <_vfprintf_r+0x2d2>
800084ee:	70 00       	ld.w	r0,r8[0x0]
800084f0:	14 96       	mov	r6,r10
800084f2:	2f c8       	sub	r8,-4
800084f4:	51 08       	stdsp	sp[0x40],r8
800084f6:	58 00       	cp.w	r0,0
800084f8:	fe 94 ff 76 	brge	800083e4 <_vfprintf_r+0x1c0>
800084fc:	5c 30       	neg	r0
800084fe:	a3 a5       	sbr	r5,0x2
80008500:	c7 2b       	rjmp	800083e4 <_vfprintf_r+0x1c0>
80008502:	32 b8       	mov	r8,43
80008504:	fb 68 06 bb 	st.b	sp[1723],r8
80008508:	c6 eb       	rjmp	800083e4 <_vfprintf_r+0x1c0>
8000850a:	0f 38       	ld.ub	r8,r7++
8000850c:	e0 48 00 2a 	cp.w	r8,42
80008510:	c0 30       	breq	80008516 <_vfprintf_r+0x2f2>
80008512:	30 09       	mov	r9,0
80008514:	c7 98       	rjmp	80008606 <_vfprintf_r+0x3e2>
80008516:	0f 88       	ld.ub	r8,r7[0x0]
80008518:	f0 c9 00 30 	sub	r9,r8,48
8000851c:	58 99       	cp.w	r9,9
8000851e:	e0 8b 00 1f 	brhi	8000855c <_vfprintf_r+0x338>
80008522:	ee c4 ff ff 	sub	r4,r7,-1
80008526:	30 0b       	mov	r11,0
80008528:	23 08       	sub	r8,48
8000852a:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000852e:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
80008532:	09 38       	ld.ub	r8,r4++
80008534:	f0 c9 00 30 	sub	r9,r8,48
80008538:	58 99       	cp.w	r9,9
8000853a:	fe 98 ff f7 	brls	80008528 <_vfprintf_r+0x304>
8000853e:	e0 48 00 24 	cp.w	r8,36
80008542:	fe 91 ff 4f 	brne	800083e0 <_vfprintf_r+0x1bc>
80008546:	e0 4b 00 20 	cp.w	r11,32
8000854a:	e0 89 0d eb 	brgt	8000a120 <_vfprintf_r+0x1efc>
8000854e:	20 1b       	sub	r11,1
80008550:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008554:	10 3b       	cp.w	r11,r8
80008556:	c0 a5       	brlt	8000856a <_vfprintf_r+0x346>
80008558:	c1 18       	rjmp	8000857a <_vfprintf_r+0x356>
8000855a:	d7 03       	nop
8000855c:	fa fa 06 b4 	ld.w	r10,sp[1716]
80008560:	ec c9 ff ff 	sub	r9,r6,-1
80008564:	14 36       	cp.w	r6,r10
80008566:	c1 f5       	brlt	800085a4 <_vfprintf_r+0x380>
80008568:	c2 88       	rjmp	800085b8 <_vfprintf_r+0x394>
8000856a:	fa ca f9 44 	sub	r10,sp,-1724
8000856e:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008572:	f6 fb fd 88 	ld.w	r11,r11[-632]
80008576:	50 2b       	stdsp	sp[0x8],r11
80008578:	c3 c8       	rjmp	800085f0 <_vfprintf_r+0x3cc>
8000857a:	fa c8 f9 50 	sub	r8,sp,-1712
8000857e:	1a d8       	st.w	--sp,r8
80008580:	fa c8 fa b8 	sub	r8,sp,-1352
80008584:	1a d8       	st.w	--sp,r8
80008586:	fa c8 fb b4 	sub	r8,sp,-1100
8000858a:	02 9a       	mov	r10,r1
8000858c:	1a d8       	st.w	--sp,r8
8000858e:	04 9c       	mov	r12,r2
80008590:	fa c8 f9 40 	sub	r8,sp,-1728
80008594:	fa c9 ff b4 	sub	r9,sp,-76
80008598:	fe b0 fc ae 	rcall	80007ef4 <get_arg>
8000859c:	2f dd       	sub	sp,-12
8000859e:	78 0c       	ld.w	r12,r12[0x0]
800085a0:	50 2c       	stdsp	sp[0x8],r12
800085a2:	c2 78       	rjmp	800085f0 <_vfprintf_r+0x3cc>
800085a4:	12 96       	mov	r6,r9
800085a6:	0e 94       	mov	r4,r7
800085a8:	fa c9 f9 44 	sub	r9,sp,-1724
800085ac:	f2 03 00 38 	add	r8,r9,r3<<0x3
800085b0:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800085b4:	50 28       	stdsp	sp[0x8],r8
800085b6:	c1 d8       	rjmp	800085f0 <_vfprintf_r+0x3cc>
800085b8:	41 08       	lddsp	r8,sp[0x40]
800085ba:	59 fa       	cp.w	r10,31
800085bc:	e0 89 00 14 	brgt	800085e4 <_vfprintf_r+0x3c0>
800085c0:	f0 cb ff fc 	sub	r11,r8,-4
800085c4:	70 08       	ld.w	r8,r8[0x0]
800085c6:	51 0b       	stdsp	sp[0x40],r11
800085c8:	50 28       	stdsp	sp[0x8],r8
800085ca:	fa c6 f9 44 	sub	r6,sp,-1724
800085ce:	40 2e       	lddsp	lr,sp[0x8]
800085d0:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800085d4:	f1 4e fd 88 	st.w	r8[-632],lr
800085d8:	2f fa       	sub	r10,-1
800085da:	0e 94       	mov	r4,r7
800085dc:	fb 4a 06 b4 	st.w	sp[1716],r10
800085e0:	12 96       	mov	r6,r9
800085e2:	c0 78       	rjmp	800085f0 <_vfprintf_r+0x3cc>
800085e4:	70 0c       	ld.w	r12,r8[0x0]
800085e6:	0e 94       	mov	r4,r7
800085e8:	2f c8       	sub	r8,-4
800085ea:	50 2c       	stdsp	sp[0x8],r12
800085ec:	12 96       	mov	r6,r9
800085ee:	51 08       	stdsp	sp[0x40],r8
800085f0:	40 2b       	lddsp	r11,sp[0x8]
800085f2:	58 0b       	cp.w	r11,0
800085f4:	fe 95 fe f2 	brlt	800083d8 <_vfprintf_r+0x1b4>
800085f8:	08 97       	mov	r7,r4
800085fa:	cf 5a       	rjmp	800083e4 <_vfprintf_r+0x1c0>
800085fc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008600:	0f 38       	ld.ub	r8,r7++
80008602:	f4 09 00 19 	add	r9,r10,r9<<0x1
80008606:	f0 ca 00 30 	sub	r10,r8,48
8000860a:	58 9a       	cp.w	r10,9
8000860c:	fe 98 ff f8 	brls	800085fc <_vfprintf_r+0x3d8>
80008610:	3f fa       	mov	r10,-1
80008612:	f2 0a 0c 49 	max	r9,r9,r10
80008616:	50 29       	stdsp	sp[0x8],r9
80008618:	ce 9a       	rjmp	800083ea <_vfprintf_r+0x1c6>
8000861a:	a7 b5       	sbr	r5,0x7
8000861c:	ce 4a       	rjmp	800083e4 <_vfprintf_r+0x1c0>
8000861e:	30 09       	mov	r9,0
80008620:	23 08       	sub	r8,48
80008622:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008626:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000862a:	0f 38       	ld.ub	r8,r7++
8000862c:	f0 ca 00 30 	sub	r10,r8,48
80008630:	58 9a       	cp.w	r10,9
80008632:	fe 98 ff f7 	brls	80008620 <_vfprintf_r+0x3fc>
80008636:	e0 48 00 24 	cp.w	r8,36
8000863a:	fe 91 fe d7 	brne	800083e8 <_vfprintf_r+0x1c4>
8000863e:	e0 49 00 20 	cp.w	r9,32
80008642:	e0 89 0d 6f 	brgt	8000a120 <_vfprintf_r+0x1efc>
80008646:	f2 c3 00 01 	sub	r3,r9,1
8000864a:	30 19       	mov	r9,1
8000864c:	50 39       	stdsp	sp[0xc],r9
8000864e:	cc ba       	rjmp	800083e4 <_vfprintf_r+0x1c0>
80008650:	a3 b5       	sbr	r5,0x3
80008652:	cc 9a       	rjmp	800083e4 <_vfprintf_r+0x1c0>
80008654:	a7 a5       	sbr	r5,0x6
80008656:	cc 7a       	rjmp	800083e4 <_vfprintf_r+0x1c0>
80008658:	0a 98       	mov	r8,r5
8000865a:	a5 b5       	sbr	r5,0x5
8000865c:	a5 a8       	sbr	r8,0x4
8000865e:	0f 89       	ld.ub	r9,r7[0x0]
80008660:	36 ce       	mov	lr,108
80008662:	fc 09 18 00 	cp.b	r9,lr
80008666:	f7 b7 00 ff 	subeq	r7,-1
8000866a:	f0 05 17 10 	movne	r5,r8
8000866e:	cb ba       	rjmp	800083e4 <_vfprintf_r+0x1c0>
80008670:	a5 b5       	sbr	r5,0x5
80008672:	cb 9a       	rjmp	800083e4 <_vfprintf_r+0x1c0>
80008674:	50 a7       	stdsp	sp[0x28],r7
80008676:	50 80       	stdsp	sp[0x20],r0
80008678:	0c 97       	mov	r7,r6
8000867a:	10 90       	mov	r0,r8
8000867c:	06 96       	mov	r6,r3
8000867e:	04 94       	mov	r4,r2
80008680:	40 93       	lddsp	r3,sp[0x24]
80008682:	02 92       	mov	r2,r1
80008684:	0e 99       	mov	r9,r7
80008686:	40 41       	lddsp	r1,sp[0x10]
80008688:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000868c:	40 3c       	lddsp	r12,sp[0xc]
8000868e:	58 0c       	cp.w	r12,0
80008690:	c1 d0       	breq	800086ca <_vfprintf_r+0x4a6>
80008692:	10 36       	cp.w	r6,r8
80008694:	c0 64       	brge	800086a0 <_vfprintf_r+0x47c>
80008696:	fa cb f9 44 	sub	r11,sp,-1724
8000869a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000869e:	c1 d8       	rjmp	800086d8 <_vfprintf_r+0x4b4>
800086a0:	fa c8 f9 50 	sub	r8,sp,-1712
800086a4:	1a d8       	st.w	--sp,r8
800086a6:	fa c8 fa b8 	sub	r8,sp,-1352
800086aa:	1a d8       	st.w	--sp,r8
800086ac:	fa c8 fb b4 	sub	r8,sp,-1100
800086b0:	1a d8       	st.w	--sp,r8
800086b2:	fa c8 f9 40 	sub	r8,sp,-1728
800086b6:	fa c9 ff b4 	sub	r9,sp,-76
800086ba:	04 9a       	mov	r10,r2
800086bc:	0c 9b       	mov	r11,r6
800086be:	08 9c       	mov	r12,r4
800086c0:	fe b0 fc 1a 	rcall	80007ef4 <get_arg>
800086c4:	2f dd       	sub	sp,-12
800086c6:	19 b8       	ld.ub	r8,r12[0x3]
800086c8:	c2 28       	rjmp	8000870c <_vfprintf_r+0x4e8>
800086ca:	2f f7       	sub	r7,-1
800086cc:	10 39       	cp.w	r9,r8
800086ce:	c0 84       	brge	800086de <_vfprintf_r+0x4ba>
800086d0:	fa ca f9 44 	sub	r10,sp,-1724
800086d4:	f4 06 00 36 	add	r6,r10,r6<<0x3
800086d8:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800086dc:	c1 88       	rjmp	8000870c <_vfprintf_r+0x4e8>
800086de:	41 09       	lddsp	r9,sp[0x40]
800086e0:	59 f8       	cp.w	r8,31
800086e2:	e0 89 00 12 	brgt	80008706 <_vfprintf_r+0x4e2>
800086e6:	f2 ca ff fc 	sub	r10,r9,-4
800086ea:	51 0a       	stdsp	sp[0x40],r10
800086ec:	72 09       	ld.w	r9,r9[0x0]
800086ee:	fa c6 f9 44 	sub	r6,sp,-1724
800086f2:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800086f6:	2f f8       	sub	r8,-1
800086f8:	f5 49 fd 88 	st.w	r10[-632],r9
800086fc:	fb 48 06 b4 	st.w	sp[1716],r8
80008700:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008704:	c0 48       	rjmp	8000870c <_vfprintf_r+0x4e8>
80008706:	13 b8       	ld.ub	r8,r9[0x3]
80008708:	2f c9       	sub	r9,-4
8000870a:	51 09       	stdsp	sp[0x40],r9
8000870c:	fb 68 06 60 	st.b	sp[1632],r8
80008710:	30 0e       	mov	lr,0
80008712:	30 08       	mov	r8,0
80008714:	30 12       	mov	r2,1
80008716:	fb 68 06 bb 	st.b	sp[1723],r8
8000871a:	50 2e       	stdsp	sp[0x8],lr
8000871c:	e0 8f 08 ad 	bral	80009876 <_vfprintf_r+0x1652>
80008720:	50 a7       	stdsp	sp[0x28],r7
80008722:	50 80       	stdsp	sp[0x20],r0
80008724:	0c 97       	mov	r7,r6
80008726:	04 94       	mov	r4,r2
80008728:	06 96       	mov	r6,r3
8000872a:	02 92       	mov	r2,r1
8000872c:	40 93       	lddsp	r3,sp[0x24]
8000872e:	10 90       	mov	r0,r8
80008730:	40 41       	lddsp	r1,sp[0x10]
80008732:	a5 a5       	sbr	r5,0x4
80008734:	c0 a8       	rjmp	80008748 <_vfprintf_r+0x524>
80008736:	50 a7       	stdsp	sp[0x28],r7
80008738:	50 80       	stdsp	sp[0x20],r0
8000873a:	0c 97       	mov	r7,r6
8000873c:	04 94       	mov	r4,r2
8000873e:	06 96       	mov	r6,r3
80008740:	02 92       	mov	r2,r1
80008742:	40 93       	lddsp	r3,sp[0x24]
80008744:	10 90       	mov	r0,r8
80008746:	40 41       	lddsp	r1,sp[0x10]
80008748:	ed b5 00 05 	bld	r5,0x5
8000874c:	c5 11       	brne	800087ee <_vfprintf_r+0x5ca>
8000874e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008752:	40 3c       	lddsp	r12,sp[0xc]
80008754:	58 0c       	cp.w	r12,0
80008756:	c1 e0       	breq	80008792 <_vfprintf_r+0x56e>
80008758:	10 36       	cp.w	r6,r8
8000875a:	c0 64       	brge	80008766 <_vfprintf_r+0x542>
8000875c:	fa cb f9 44 	sub	r11,sp,-1724
80008760:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008764:	c2 08       	rjmp	800087a4 <_vfprintf_r+0x580>
80008766:	fa c8 f9 50 	sub	r8,sp,-1712
8000876a:	1a d8       	st.w	--sp,r8
8000876c:	fa c8 fa b8 	sub	r8,sp,-1352
80008770:	0c 9b       	mov	r11,r6
80008772:	1a d8       	st.w	--sp,r8
80008774:	fa c8 fb b4 	sub	r8,sp,-1100
80008778:	1a d8       	st.w	--sp,r8
8000877a:	fa c9 ff b4 	sub	r9,sp,-76
8000877e:	fa c8 f9 40 	sub	r8,sp,-1728
80008782:	04 9a       	mov	r10,r2
80008784:	08 9c       	mov	r12,r4
80008786:	fe b0 fb b7 	rcall	80007ef4 <get_arg>
8000878a:	2f dd       	sub	sp,-12
8000878c:	78 1b       	ld.w	r11,r12[0x4]
8000878e:	78 09       	ld.w	r9,r12[0x0]
80008790:	c2 b8       	rjmp	800087e6 <_vfprintf_r+0x5c2>
80008792:	ee ca ff ff 	sub	r10,r7,-1
80008796:	10 37       	cp.w	r7,r8
80008798:	c0 b4       	brge	800087ae <_vfprintf_r+0x58a>
8000879a:	fa c9 f9 44 	sub	r9,sp,-1724
8000879e:	14 97       	mov	r7,r10
800087a0:	f2 06 00 36 	add	r6,r9,r6<<0x3
800087a4:	ec fb fd 8c 	ld.w	r11,r6[-628]
800087a8:	ec f9 fd 88 	ld.w	r9,r6[-632]
800087ac:	c1 d8       	rjmp	800087e6 <_vfprintf_r+0x5c2>
800087ae:	41 09       	lddsp	r9,sp[0x40]
800087b0:	59 f8       	cp.w	r8,31
800087b2:	e0 89 00 14 	brgt	800087da <_vfprintf_r+0x5b6>
800087b6:	f2 cb ff f8 	sub	r11,r9,-8
800087ba:	51 0b       	stdsp	sp[0x40],r11
800087bc:	fa c6 f9 44 	sub	r6,sp,-1724
800087c0:	72 1b       	ld.w	r11,r9[0x4]
800087c2:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800087c6:	72 09       	ld.w	r9,r9[0x0]
800087c8:	f9 4b fd 8c 	st.w	r12[-628],r11
800087cc:	f9 49 fd 88 	st.w	r12[-632],r9
800087d0:	2f f8       	sub	r8,-1
800087d2:	14 97       	mov	r7,r10
800087d4:	fb 48 06 b4 	st.w	sp[1716],r8
800087d8:	c0 78       	rjmp	800087e6 <_vfprintf_r+0x5c2>
800087da:	f2 c8 ff f8 	sub	r8,r9,-8
800087de:	72 1b       	ld.w	r11,r9[0x4]
800087e0:	14 97       	mov	r7,r10
800087e2:	51 08       	stdsp	sp[0x40],r8
800087e4:	72 09       	ld.w	r9,r9[0x0]
800087e6:	16 98       	mov	r8,r11
800087e8:	fa e9 00 00 	st.d	sp[0],r8
800087ec:	ca e8       	rjmp	80008948 <_vfprintf_r+0x724>
800087ee:	ed b5 00 04 	bld	r5,0x4
800087f2:	c1 71       	brne	80008820 <_vfprintf_r+0x5fc>
800087f4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800087f8:	40 3e       	lddsp	lr,sp[0xc]
800087fa:	58 0e       	cp.w	lr,0
800087fc:	c0 80       	breq	8000880c <_vfprintf_r+0x5e8>
800087fe:	10 36       	cp.w	r6,r8
80008800:	c6 94       	brge	800088d2 <_vfprintf_r+0x6ae>
80008802:	fa cc f9 44 	sub	r12,sp,-1724
80008806:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000880a:	c8 28       	rjmp	8000890e <_vfprintf_r+0x6ea>
8000880c:	ee ca ff ff 	sub	r10,r7,-1
80008810:	10 37       	cp.w	r7,r8
80008812:	e0 84 00 81 	brge	80008914 <_vfprintf_r+0x6f0>
80008816:	fa cb f9 44 	sub	r11,sp,-1724
8000881a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000881e:	c7 78       	rjmp	8000890c <_vfprintf_r+0x6e8>
80008820:	ed b5 00 06 	bld	r5,0x6
80008824:	c4 b1       	brne	800088ba <_vfprintf_r+0x696>
80008826:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000882a:	40 3c       	lddsp	r12,sp[0xc]
8000882c:	58 0c       	cp.w	r12,0
8000882e:	c1 d0       	breq	80008868 <_vfprintf_r+0x644>
80008830:	10 36       	cp.w	r6,r8
80008832:	c0 64       	brge	8000883e <_vfprintf_r+0x61a>
80008834:	fa cb f9 44 	sub	r11,sp,-1724
80008838:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000883c:	c1 f8       	rjmp	8000887a <_vfprintf_r+0x656>
8000883e:	fa c8 f9 50 	sub	r8,sp,-1712
80008842:	1a d8       	st.w	--sp,r8
80008844:	fa c8 fa b8 	sub	r8,sp,-1352
80008848:	1a d8       	st.w	--sp,r8
8000884a:	fa c8 fb b4 	sub	r8,sp,-1100
8000884e:	1a d8       	st.w	--sp,r8
80008850:	fa c8 f9 40 	sub	r8,sp,-1728
80008854:	fa c9 ff b4 	sub	r9,sp,-76
80008858:	04 9a       	mov	r10,r2
8000885a:	0c 9b       	mov	r11,r6
8000885c:	08 9c       	mov	r12,r4
8000885e:	fe b0 fb 4b 	rcall	80007ef4 <get_arg>
80008862:	2f dd       	sub	sp,-12
80008864:	98 18       	ld.sh	r8,r12[0x2]
80008866:	c2 68       	rjmp	800088b2 <_vfprintf_r+0x68e>
80008868:	ee ca ff ff 	sub	r10,r7,-1
8000886c:	10 37       	cp.w	r7,r8
8000886e:	c0 94       	brge	80008880 <_vfprintf_r+0x65c>
80008870:	fa c9 f9 44 	sub	r9,sp,-1724
80008874:	14 97       	mov	r7,r10
80008876:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000887a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000887e:	c1 a8       	rjmp	800088b2 <_vfprintf_r+0x68e>
80008880:	41 09       	lddsp	r9,sp[0x40]
80008882:	59 f8       	cp.w	r8,31
80008884:	e0 89 00 13 	brgt	800088aa <_vfprintf_r+0x686>
80008888:	f2 cb ff fc 	sub	r11,r9,-4
8000888c:	51 0b       	stdsp	sp[0x40],r11
8000888e:	72 09       	ld.w	r9,r9[0x0]
80008890:	fa c6 f9 44 	sub	r6,sp,-1724
80008894:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008898:	2f f8       	sub	r8,-1
8000889a:	f7 49 fd 88 	st.w	r11[-632],r9
8000889e:	fb 48 06 b4 	st.w	sp[1716],r8
800088a2:	14 97       	mov	r7,r10
800088a4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800088a8:	c0 58       	rjmp	800088b2 <_vfprintf_r+0x68e>
800088aa:	92 18       	ld.sh	r8,r9[0x2]
800088ac:	14 97       	mov	r7,r10
800088ae:	2f c9       	sub	r9,-4
800088b0:	51 09       	stdsp	sp[0x40],r9
800088b2:	50 18       	stdsp	sp[0x4],r8
800088b4:	bf 58       	asr	r8,0x1f
800088b6:	50 08       	stdsp	sp[0x0],r8
800088b8:	c4 88       	rjmp	80008948 <_vfprintf_r+0x724>
800088ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088be:	40 3c       	lddsp	r12,sp[0xc]
800088c0:	58 0c       	cp.w	r12,0
800088c2:	c1 d0       	breq	800088fc <_vfprintf_r+0x6d8>
800088c4:	10 36       	cp.w	r6,r8
800088c6:	c0 64       	brge	800088d2 <_vfprintf_r+0x6ae>
800088c8:	fa cb f9 44 	sub	r11,sp,-1724
800088cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088d0:	c1 f8       	rjmp	8000890e <_vfprintf_r+0x6ea>
800088d2:	fa c8 f9 50 	sub	r8,sp,-1712
800088d6:	1a d8       	st.w	--sp,r8
800088d8:	fa c8 fa b8 	sub	r8,sp,-1352
800088dc:	0c 9b       	mov	r11,r6
800088de:	1a d8       	st.w	--sp,r8
800088e0:	fa c8 fb b4 	sub	r8,sp,-1100
800088e4:	04 9a       	mov	r10,r2
800088e6:	1a d8       	st.w	--sp,r8
800088e8:	08 9c       	mov	r12,r4
800088ea:	fa c8 f9 40 	sub	r8,sp,-1728
800088ee:	fa c9 ff b4 	sub	r9,sp,-76
800088f2:	fe b0 fb 01 	rcall	80007ef4 <get_arg>
800088f6:	2f dd       	sub	sp,-12
800088f8:	78 0b       	ld.w	r11,r12[0x0]
800088fa:	c2 48       	rjmp	80008942 <_vfprintf_r+0x71e>
800088fc:	ee ca ff ff 	sub	r10,r7,-1
80008900:	10 37       	cp.w	r7,r8
80008902:	c0 94       	brge	80008914 <_vfprintf_r+0x6f0>
80008904:	fa c9 f9 44 	sub	r9,sp,-1724
80008908:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000890c:	14 97       	mov	r7,r10
8000890e:	ec fb fd 88 	ld.w	r11,r6[-632]
80008912:	c1 88       	rjmp	80008942 <_vfprintf_r+0x71e>
80008914:	41 09       	lddsp	r9,sp[0x40]
80008916:	59 f8       	cp.w	r8,31
80008918:	e0 89 00 11 	brgt	8000893a <_vfprintf_r+0x716>
8000891c:	f2 cb ff fc 	sub	r11,r9,-4
80008920:	51 0b       	stdsp	sp[0x40],r11
80008922:	fa c6 f9 44 	sub	r6,sp,-1724
80008926:	72 0b       	ld.w	r11,r9[0x0]
80008928:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000892c:	f3 4b fd 88 	st.w	r9[-632],r11
80008930:	2f f8       	sub	r8,-1
80008932:	14 97       	mov	r7,r10
80008934:	fb 48 06 b4 	st.w	sp[1716],r8
80008938:	c0 58       	rjmp	80008942 <_vfprintf_r+0x71e>
8000893a:	72 0b       	ld.w	r11,r9[0x0]
8000893c:	14 97       	mov	r7,r10
8000893e:	2f c9       	sub	r9,-4
80008940:	51 09       	stdsp	sp[0x40],r9
80008942:	50 1b       	stdsp	sp[0x4],r11
80008944:	bf 5b       	asr	r11,0x1f
80008946:	50 0b       	stdsp	sp[0x0],r11
80008948:	fa ea 00 00 	ld.d	r10,sp[0]
8000894c:	58 0a       	cp.w	r10,0
8000894e:	5c 2b       	cpc	r11
80008950:	c0 e4       	brge	8000896c <_vfprintf_r+0x748>
80008952:	30 08       	mov	r8,0
80008954:	fa ea 00 00 	ld.d	r10,sp[0]
80008958:	30 09       	mov	r9,0
8000895a:	f0 0a 01 0a 	sub	r10,r8,r10
8000895e:	f2 0b 01 4b 	sbc	r11,r9,r11
80008962:	32 d8       	mov	r8,45
80008964:	fa eb 00 00 	st.d	sp[0],r10
80008968:	fb 68 06 bb 	st.b	sp[1723],r8
8000896c:	30 18       	mov	r8,1
8000896e:	e0 8f 06 fa 	bral	80009762 <_vfprintf_r+0x153e>
80008972:	50 a7       	stdsp	sp[0x28],r7
80008974:	50 80       	stdsp	sp[0x20],r0
80008976:	0c 97       	mov	r7,r6
80008978:	04 94       	mov	r4,r2
8000897a:	06 96       	mov	r6,r3
8000897c:	02 92       	mov	r2,r1
8000897e:	40 93       	lddsp	r3,sp[0x24]
80008980:	10 90       	mov	r0,r8
80008982:	40 41       	lddsp	r1,sp[0x10]
80008984:	0e 99       	mov	r9,r7
80008986:	ed b5 00 03 	bld	r5,0x3
8000898a:	c4 11       	brne	80008a0c <_vfprintf_r+0x7e8>
8000898c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008990:	40 3a       	lddsp	r10,sp[0xc]
80008992:	58 0a       	cp.w	r10,0
80008994:	c1 90       	breq	800089c6 <_vfprintf_r+0x7a2>
80008996:	10 36       	cp.w	r6,r8
80008998:	c6 45       	brlt	80008a60 <_vfprintf_r+0x83c>
8000899a:	fa c8 f9 50 	sub	r8,sp,-1712
8000899e:	1a d8       	st.w	--sp,r8
800089a0:	fa c8 fa b8 	sub	r8,sp,-1352
800089a4:	1a d8       	st.w	--sp,r8
800089a6:	fa c8 fb b4 	sub	r8,sp,-1100
800089aa:	0c 9b       	mov	r11,r6
800089ac:	1a d8       	st.w	--sp,r8
800089ae:	04 9a       	mov	r10,r2
800089b0:	fa c8 f9 40 	sub	r8,sp,-1728
800089b4:	fa c9 ff b4 	sub	r9,sp,-76
800089b8:	08 9c       	mov	r12,r4
800089ba:	fe b0 fa 9d 	rcall	80007ef4 <get_arg>
800089be:	2f dd       	sub	sp,-12
800089c0:	78 16       	ld.w	r6,r12[0x4]
800089c2:	50 76       	stdsp	sp[0x1c],r6
800089c4:	c4 88       	rjmp	80008a54 <_vfprintf_r+0x830>
800089c6:	2f f7       	sub	r7,-1
800089c8:	10 39       	cp.w	r9,r8
800089ca:	c0 c4       	brge	800089e2 <_vfprintf_r+0x7be>
800089cc:	fa ce f9 44 	sub	lr,sp,-1724
800089d0:	fc 06 00 36 	add	r6,lr,r6<<0x3
800089d4:	ec fc fd 8c 	ld.w	r12,r6[-628]
800089d8:	50 7c       	stdsp	sp[0x1c],r12
800089da:	ec f6 fd 88 	ld.w	r6,r6[-632]
800089de:	50 56       	stdsp	sp[0x14],r6
800089e0:	c6 68       	rjmp	80008aac <_vfprintf_r+0x888>
800089e2:	41 09       	lddsp	r9,sp[0x40]
800089e4:	59 f8       	cp.w	r8,31
800089e6:	e0 89 00 10 	brgt	80008a06 <_vfprintf_r+0x7e2>
800089ea:	f2 ca ff f8 	sub	r10,r9,-8
800089ee:	72 1b       	ld.w	r11,r9[0x4]
800089f0:	51 0a       	stdsp	sp[0x40],r10
800089f2:	72 09       	ld.w	r9,r9[0x0]
800089f4:	fa ca f9 44 	sub	r10,sp,-1724
800089f8:	50 7b       	stdsp	sp[0x1c],r11
800089fa:	50 59       	stdsp	sp[0x14],r9
800089fc:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008a00:	40 5b       	lddsp	r11,sp[0x14]
80008a02:	40 7a       	lddsp	r10,sp[0x1c]
80008a04:	c4 78       	rjmp	80008a92 <_vfprintf_r+0x86e>
80008a06:	72 18       	ld.w	r8,r9[0x4]
80008a08:	50 78       	stdsp	sp[0x1c],r8
80008a0a:	c4 c8       	rjmp	80008aa2 <_vfprintf_r+0x87e>
80008a0c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a10:	40 3e       	lddsp	lr,sp[0xc]
80008a12:	58 0e       	cp.w	lr,0
80008a14:	c2 30       	breq	80008a5a <_vfprintf_r+0x836>
80008a16:	10 36       	cp.w	r6,r8
80008a18:	c0 94       	brge	80008a2a <_vfprintf_r+0x806>
80008a1a:	fa cc f9 44 	sub	r12,sp,-1724
80008a1e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008a22:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008a26:	50 7b       	stdsp	sp[0x1c],r11
80008a28:	cd 9b       	rjmp	800089da <_vfprintf_r+0x7b6>
80008a2a:	fa c8 f9 50 	sub	r8,sp,-1712
80008a2e:	1a d8       	st.w	--sp,r8
80008a30:	fa c8 fa b8 	sub	r8,sp,-1352
80008a34:	04 9a       	mov	r10,r2
80008a36:	1a d8       	st.w	--sp,r8
80008a38:	fa c8 fb b4 	sub	r8,sp,-1100
80008a3c:	0c 9b       	mov	r11,r6
80008a3e:	1a d8       	st.w	--sp,r8
80008a40:	08 9c       	mov	r12,r4
80008a42:	fa c8 f9 40 	sub	r8,sp,-1728
80008a46:	fa c9 ff b4 	sub	r9,sp,-76
80008a4a:	fe b0 fa 55 	rcall	80007ef4 <get_arg>
80008a4e:	2f dd       	sub	sp,-12
80008a50:	78 1a       	ld.w	r10,r12[0x4]
80008a52:	50 7a       	stdsp	sp[0x1c],r10
80008a54:	78 0c       	ld.w	r12,r12[0x0]
80008a56:	50 5c       	stdsp	sp[0x14],r12
80008a58:	c2 a8       	rjmp	80008aac <_vfprintf_r+0x888>
80008a5a:	2f f7       	sub	r7,-1
80008a5c:	10 39       	cp.w	r9,r8
80008a5e:	c0 94       	brge	80008a70 <_vfprintf_r+0x84c>
80008a60:	fa c9 f9 44 	sub	r9,sp,-1724
80008a64:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a68:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008a6c:	50 78       	stdsp	sp[0x1c],r8
80008a6e:	cb 6b       	rjmp	800089da <_vfprintf_r+0x7b6>
80008a70:	41 09       	lddsp	r9,sp[0x40]
80008a72:	59 f8       	cp.w	r8,31
80008a74:	e0 89 00 15 	brgt	80008a9e <_vfprintf_r+0x87a>
80008a78:	f2 ca ff f8 	sub	r10,r9,-8
80008a7c:	72 16       	ld.w	r6,r9[0x4]
80008a7e:	72 09       	ld.w	r9,r9[0x0]
80008a80:	51 0a       	stdsp	sp[0x40],r10
80008a82:	50 59       	stdsp	sp[0x14],r9
80008a84:	fa ce f9 44 	sub	lr,sp,-1724
80008a88:	50 76       	stdsp	sp[0x1c],r6
80008a8a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008a8e:	40 5b       	lddsp	r11,sp[0x14]
80008a90:	0c 9a       	mov	r10,r6
80008a92:	f2 eb fd 88 	st.d	r9[-632],r10
80008a96:	2f f8       	sub	r8,-1
80008a98:	fb 48 06 b4 	st.w	sp[1716],r8
80008a9c:	c0 88       	rjmp	80008aac <_vfprintf_r+0x888>
80008a9e:	72 1c       	ld.w	r12,r9[0x4]
80008aa0:	50 7c       	stdsp	sp[0x1c],r12
80008aa2:	f2 c8 ff f8 	sub	r8,r9,-8
80008aa6:	51 08       	stdsp	sp[0x40],r8
80008aa8:	72 09       	ld.w	r9,r9[0x0]
80008aaa:	50 59       	stdsp	sp[0x14],r9
80008aac:	40 5b       	lddsp	r11,sp[0x14]
80008aae:	40 7a       	lddsp	r10,sp[0x1c]
80008ab0:	e0 a0 19 54 	rcall	8000bd58 <__isinfd>
80008ab4:	18 96       	mov	r6,r12
80008ab6:	c1 70       	breq	80008ae4 <_vfprintf_r+0x8c0>
80008ab8:	30 08       	mov	r8,0
80008aba:	30 09       	mov	r9,0
80008abc:	40 5b       	lddsp	r11,sp[0x14]
80008abe:	40 7a       	lddsp	r10,sp[0x1c]
80008ac0:	e0 a0 1d b4 	rcall	8000c628 <__avr32_f64_cmp_lt>
80008ac4:	c0 40       	breq	80008acc <_vfprintf_r+0x8a8>
80008ac6:	32 d8       	mov	r8,45
80008ac8:	fb 68 06 bb 	st.b	sp[1723],r8
80008acc:	fe c8 a8 e4 	sub	r8,pc,-22300
80008ad0:	fe c6 a8 e4 	sub	r6,pc,-22300
80008ad4:	a7 d5       	cbr	r5,0x7
80008ad6:	e0 40 00 47 	cp.w	r0,71
80008ada:	f0 06 17 a0 	movle	r6,r8
80008ade:	30 32       	mov	r2,3
80008ae0:	e0 8f 06 ce 	bral	8000987c <_vfprintf_r+0x1658>
80008ae4:	40 5b       	lddsp	r11,sp[0x14]
80008ae6:	40 7a       	lddsp	r10,sp[0x1c]
80008ae8:	e0 a0 19 4d 	rcall	8000bd82 <__isnand>
80008aec:	c0 e0       	breq	80008b08 <_vfprintf_r+0x8e4>
80008aee:	50 26       	stdsp	sp[0x8],r6
80008af0:	fe c8 a9 00 	sub	r8,pc,-22272
80008af4:	fe c6 a9 00 	sub	r6,pc,-22272
80008af8:	a7 d5       	cbr	r5,0x7
80008afa:	e0 40 00 47 	cp.w	r0,71
80008afe:	f0 06 17 a0 	movle	r6,r8
80008b02:	30 32       	mov	r2,3
80008b04:	e0 8f 06 c2 	bral	80009888 <_vfprintf_r+0x1664>
80008b08:	40 2a       	lddsp	r10,sp[0x8]
80008b0a:	5b fa       	cp.w	r10,-1
80008b0c:	c0 41       	brne	80008b14 <_vfprintf_r+0x8f0>
80008b0e:	30 69       	mov	r9,6
80008b10:	50 29       	stdsp	sp[0x8],r9
80008b12:	c1 18       	rjmp	80008b34 <_vfprintf_r+0x910>
80008b14:	e0 40 00 47 	cp.w	r0,71
80008b18:	5f 09       	sreq	r9
80008b1a:	e0 40 00 67 	cp.w	r0,103
80008b1e:	5f 08       	sreq	r8
80008b20:	f3 e8 10 08 	or	r8,r9,r8
80008b24:	f8 08 18 00 	cp.b	r8,r12
80008b28:	c0 60       	breq	80008b34 <_vfprintf_r+0x910>
80008b2a:	40 28       	lddsp	r8,sp[0x8]
80008b2c:	58 08       	cp.w	r8,0
80008b2e:	f9 b8 00 01 	moveq	r8,1
80008b32:	50 28       	stdsp	sp[0x8],r8
80008b34:	40 78       	lddsp	r8,sp[0x1c]
80008b36:	40 59       	lddsp	r9,sp[0x14]
80008b38:	fa e9 06 94 	st.d	sp[1684],r8
80008b3c:	a9 a5       	sbr	r5,0x8
80008b3e:	fa f8 06 94 	ld.w	r8,sp[1684]
80008b42:	58 08       	cp.w	r8,0
80008b44:	c0 65       	brlt	80008b50 <_vfprintf_r+0x92c>
80008b46:	40 5e       	lddsp	lr,sp[0x14]
80008b48:	30 0c       	mov	r12,0
80008b4a:	50 6e       	stdsp	sp[0x18],lr
80008b4c:	50 9c       	stdsp	sp[0x24],r12
80008b4e:	c0 78       	rjmp	80008b5c <_vfprintf_r+0x938>
80008b50:	40 5b       	lddsp	r11,sp[0x14]
80008b52:	32 da       	mov	r10,45
80008b54:	ee 1b 80 00 	eorh	r11,0x8000
80008b58:	50 9a       	stdsp	sp[0x24],r10
80008b5a:	50 6b       	stdsp	sp[0x18],r11
80008b5c:	e0 40 00 46 	cp.w	r0,70
80008b60:	5f 09       	sreq	r9
80008b62:	e0 40 00 66 	cp.w	r0,102
80008b66:	5f 08       	sreq	r8
80008b68:	f3 e8 10 08 	or	r8,r9,r8
80008b6c:	50 48       	stdsp	sp[0x10],r8
80008b6e:	c0 40       	breq	80008b76 <_vfprintf_r+0x952>
80008b70:	40 22       	lddsp	r2,sp[0x8]
80008b72:	30 39       	mov	r9,3
80008b74:	c1 08       	rjmp	80008b94 <_vfprintf_r+0x970>
80008b76:	e0 40 00 45 	cp.w	r0,69
80008b7a:	5f 09       	sreq	r9
80008b7c:	e0 40 00 65 	cp.w	r0,101
80008b80:	5f 08       	sreq	r8
80008b82:	40 22       	lddsp	r2,sp[0x8]
80008b84:	10 49       	or	r9,r8
80008b86:	2f f2       	sub	r2,-1
80008b88:	40 46       	lddsp	r6,sp[0x10]
80008b8a:	ec 09 18 00 	cp.b	r9,r6
80008b8e:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008b92:	30 29       	mov	r9,2
80008b94:	fa c8 f9 5c 	sub	r8,sp,-1700
80008b98:	1a d8       	st.w	--sp,r8
80008b9a:	fa c8 f9 54 	sub	r8,sp,-1708
80008b9e:	1a d8       	st.w	--sp,r8
80008ba0:	fa c8 f9 4c 	sub	r8,sp,-1716
80008ba4:	08 9c       	mov	r12,r4
80008ba6:	1a d8       	st.w	--sp,r8
80008ba8:	04 98       	mov	r8,r2
80008baa:	40 9b       	lddsp	r11,sp[0x24]
80008bac:	40 aa       	lddsp	r10,sp[0x28]
80008bae:	e0 a0 0b c3 	rcall	8000a334 <_dtoa_r>
80008bb2:	e0 40 00 47 	cp.w	r0,71
80008bb6:	5f 19       	srne	r9
80008bb8:	e0 40 00 67 	cp.w	r0,103
80008bbc:	5f 18       	srne	r8
80008bbe:	18 96       	mov	r6,r12
80008bc0:	2f dd       	sub	sp,-12
80008bc2:	f3 e8 00 08 	and	r8,r9,r8
80008bc6:	c0 41       	brne	80008bce <_vfprintf_r+0x9aa>
80008bc8:	ed b5 00 00 	bld	r5,0x0
80008bcc:	c3 01       	brne	80008c2c <_vfprintf_r+0xa08>
80008bce:	ec 02 00 0e 	add	lr,r6,r2
80008bd2:	50 3e       	stdsp	sp[0xc],lr
80008bd4:	40 4c       	lddsp	r12,sp[0x10]
80008bd6:	58 0c       	cp.w	r12,0
80008bd8:	c1 50       	breq	80008c02 <_vfprintf_r+0x9de>
80008bda:	0d 89       	ld.ub	r9,r6[0x0]
80008bdc:	33 08       	mov	r8,48
80008bde:	f0 09 18 00 	cp.b	r9,r8
80008be2:	c0 b1       	brne	80008bf8 <_vfprintf_r+0x9d4>
80008be4:	30 08       	mov	r8,0
80008be6:	30 09       	mov	r9,0
80008be8:	40 6b       	lddsp	r11,sp[0x18]
80008bea:	40 7a       	lddsp	r10,sp[0x1c]
80008bec:	e0 a0 1c d7 	rcall	8000c59a <__avr32_f64_cmp_eq>
80008bf0:	fb b2 00 01 	rsubeq	r2,1
80008bf4:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008bf8:	40 3b       	lddsp	r11,sp[0xc]
80008bfa:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008bfe:	10 0b       	add	r11,r8
80008c00:	50 3b       	stdsp	sp[0xc],r11
80008c02:	40 6b       	lddsp	r11,sp[0x18]
80008c04:	30 08       	mov	r8,0
80008c06:	30 09       	mov	r9,0
80008c08:	40 7a       	lddsp	r10,sp[0x1c]
80008c0a:	e0 a0 1c c8 	rcall	8000c59a <__avr32_f64_cmp_eq>
80008c0e:	c0 90       	breq	80008c20 <_vfprintf_r+0x9fc>
80008c10:	40 3a       	lddsp	r10,sp[0xc]
80008c12:	fb 4a 06 a4 	st.w	sp[1700],r10
80008c16:	c0 58       	rjmp	80008c20 <_vfprintf_r+0x9fc>
80008c18:	10 c9       	st.b	r8++,r9
80008c1a:	fb 48 06 a4 	st.w	sp[1700],r8
80008c1e:	c0 28       	rjmp	80008c22 <_vfprintf_r+0x9fe>
80008c20:	33 09       	mov	r9,48
80008c22:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008c26:	40 3e       	lddsp	lr,sp[0xc]
80008c28:	1c 38       	cp.w	r8,lr
80008c2a:	cf 73       	brcs	80008c18 <_vfprintf_r+0x9f4>
80008c2c:	e0 40 00 47 	cp.w	r0,71
80008c30:	5f 09       	sreq	r9
80008c32:	e0 40 00 67 	cp.w	r0,103
80008c36:	5f 08       	sreq	r8
80008c38:	f3 e8 10 08 	or	r8,r9,r8
80008c3c:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008c40:	0c 19       	sub	r9,r6
80008c42:	50 69       	stdsp	sp[0x18],r9
80008c44:	58 08       	cp.w	r8,0
80008c46:	c0 b0       	breq	80008c5c <_vfprintf_r+0xa38>
80008c48:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008c4c:	5b d8       	cp.w	r8,-3
80008c4e:	c0 55       	brlt	80008c58 <_vfprintf_r+0xa34>
80008c50:	40 2c       	lddsp	r12,sp[0x8]
80008c52:	18 38       	cp.w	r8,r12
80008c54:	e0 8a 00 6a 	brle	80008d28 <_vfprintf_r+0xb04>
80008c58:	20 20       	sub	r0,2
80008c5a:	c0 58       	rjmp	80008c64 <_vfprintf_r+0xa40>
80008c5c:	e0 40 00 65 	cp.w	r0,101
80008c60:	e0 89 00 46 	brgt	80008cec <_vfprintf_r+0xac8>
80008c64:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008c68:	fb 60 06 9c 	st.b	sp[1692],r0
80008c6c:	20 1b       	sub	r11,1
80008c6e:	fb 4b 06 ac 	st.w	sp[1708],r11
80008c72:	c0 47       	brpl	80008c7a <_vfprintf_r+0xa56>
80008c74:	5c 3b       	neg	r11
80008c76:	32 d8       	mov	r8,45
80008c78:	c0 28       	rjmp	80008c7c <_vfprintf_r+0xa58>
80008c7a:	32 b8       	mov	r8,43
80008c7c:	fb 68 06 9d 	st.b	sp[1693],r8
80008c80:	58 9b       	cp.w	r11,9
80008c82:	e0 8a 00 1d 	brle	80008cbc <_vfprintf_r+0xa98>
80008c86:	fa c9 fa 35 	sub	r9,sp,-1483
80008c8a:	30 aa       	mov	r10,10
80008c8c:	12 98       	mov	r8,r9
80008c8e:	0e 9c       	mov	r12,r7
80008c90:	0c 92       	mov	r2,r6
80008c92:	f6 0a 0c 06 	divs	r6,r11,r10
80008c96:	0e 9b       	mov	r11,r7
80008c98:	2d 0b       	sub	r11,-48
80008c9a:	10 fb       	st.b	--r8,r11
80008c9c:	0c 9b       	mov	r11,r6
80008c9e:	58 96       	cp.w	r6,9
80008ca0:	fe 99 ff f9 	brgt	80008c92 <_vfprintf_r+0xa6e>
80008ca4:	2d 0b       	sub	r11,-48
80008ca6:	18 97       	mov	r7,r12
80008ca8:	04 96       	mov	r6,r2
80008caa:	10 fb       	st.b	--r8,r11
80008cac:	fa ca f9 62 	sub	r10,sp,-1694
80008cb0:	c0 38       	rjmp	80008cb6 <_vfprintf_r+0xa92>
80008cb2:	11 3b       	ld.ub	r11,r8++
80008cb4:	14 cb       	st.b	r10++,r11
80008cb6:	12 38       	cp.w	r8,r9
80008cb8:	cf d3       	brcs	80008cb2 <_vfprintf_r+0xa8e>
80008cba:	c0 98       	rjmp	80008ccc <_vfprintf_r+0xaa8>
80008cbc:	2d 0b       	sub	r11,-48
80008cbe:	33 08       	mov	r8,48
80008cc0:	fb 6b 06 9f 	st.b	sp[1695],r11
80008cc4:	fb 68 06 9e 	st.b	sp[1694],r8
80008cc8:	fa ca f9 60 	sub	r10,sp,-1696
80008ccc:	fa c8 f9 64 	sub	r8,sp,-1692
80008cd0:	f4 08 01 08 	sub	r8,r10,r8
80008cd4:	50 e8       	stdsp	sp[0x38],r8
80008cd6:	10 92       	mov	r2,r8
80008cd8:	40 6b       	lddsp	r11,sp[0x18]
80008cda:	16 02       	add	r2,r11
80008cdc:	58 1b       	cp.w	r11,1
80008cde:	e0 89 00 05 	brgt	80008ce8 <_vfprintf_r+0xac4>
80008ce2:	ed b5 00 00 	bld	r5,0x0
80008ce6:	c3 51       	brne	80008d50 <_vfprintf_r+0xb2c>
80008ce8:	2f f2       	sub	r2,-1
80008cea:	c3 38       	rjmp	80008d50 <_vfprintf_r+0xb2c>
80008cec:	e0 40 00 66 	cp.w	r0,102
80008cf0:	c1 c1       	brne	80008d28 <_vfprintf_r+0xb04>
80008cf2:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008cf6:	58 02       	cp.w	r2,0
80008cf8:	e0 8a 00 0c 	brle	80008d10 <_vfprintf_r+0xaec>
80008cfc:	40 2a       	lddsp	r10,sp[0x8]
80008cfe:	58 0a       	cp.w	r10,0
80008d00:	c0 41       	brne	80008d08 <_vfprintf_r+0xae4>
80008d02:	ed b5 00 00 	bld	r5,0x0
80008d06:	c2 51       	brne	80008d50 <_vfprintf_r+0xb2c>
80008d08:	2f f2       	sub	r2,-1
80008d0a:	40 29       	lddsp	r9,sp[0x8]
80008d0c:	12 02       	add	r2,r9
80008d0e:	c0 b8       	rjmp	80008d24 <_vfprintf_r+0xb00>
80008d10:	40 28       	lddsp	r8,sp[0x8]
80008d12:	58 08       	cp.w	r8,0
80008d14:	c0 61       	brne	80008d20 <_vfprintf_r+0xafc>
80008d16:	ed b5 00 00 	bld	r5,0x0
80008d1a:	c0 30       	breq	80008d20 <_vfprintf_r+0xafc>
80008d1c:	30 12       	mov	r2,1
80008d1e:	c1 98       	rjmp	80008d50 <_vfprintf_r+0xb2c>
80008d20:	40 22       	lddsp	r2,sp[0x8]
80008d22:	2f e2       	sub	r2,-2
80008d24:	36 60       	mov	r0,102
80008d26:	c1 58       	rjmp	80008d50 <_vfprintf_r+0xb2c>
80008d28:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008d2c:	40 6e       	lddsp	lr,sp[0x18]
80008d2e:	1c 32       	cp.w	r2,lr
80008d30:	c0 65       	brlt	80008d3c <_vfprintf_r+0xb18>
80008d32:	ed b5 00 00 	bld	r5,0x0
80008d36:	f7 b2 00 ff 	subeq	r2,-1
80008d3a:	c0 a8       	rjmp	80008d4e <_vfprintf_r+0xb2a>
80008d3c:	e4 08 11 02 	rsub	r8,r2,2
80008d40:	40 6c       	lddsp	r12,sp[0x18]
80008d42:	58 02       	cp.w	r2,0
80008d44:	f0 02 17 a0 	movle	r2,r8
80008d48:	f9 b2 09 01 	movgt	r2,1
80008d4c:	18 02       	add	r2,r12
80008d4e:	36 70       	mov	r0,103
80008d50:	40 9b       	lddsp	r11,sp[0x24]
80008d52:	58 0b       	cp.w	r11,0
80008d54:	e0 80 05 94 	breq	8000987c <_vfprintf_r+0x1658>
80008d58:	32 d8       	mov	r8,45
80008d5a:	fb 68 06 bb 	st.b	sp[1723],r8
80008d5e:	e0 8f 05 93 	bral	80009884 <_vfprintf_r+0x1660>
80008d62:	50 a7       	stdsp	sp[0x28],r7
80008d64:	04 94       	mov	r4,r2
80008d66:	0c 97       	mov	r7,r6
80008d68:	02 92       	mov	r2,r1
80008d6a:	06 96       	mov	r6,r3
80008d6c:	40 41       	lddsp	r1,sp[0x10]
80008d6e:	40 93       	lddsp	r3,sp[0x24]
80008d70:	0e 99       	mov	r9,r7
80008d72:	ed b5 00 05 	bld	r5,0x5
80008d76:	c4 81       	brne	80008e06 <_vfprintf_r+0xbe2>
80008d78:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008d7c:	40 3e       	lddsp	lr,sp[0xc]
80008d7e:	58 0e       	cp.w	lr,0
80008d80:	c1 d0       	breq	80008dba <_vfprintf_r+0xb96>
80008d82:	10 36       	cp.w	r6,r8
80008d84:	c0 64       	brge	80008d90 <_vfprintf_r+0xb6c>
80008d86:	fa cc f9 44 	sub	r12,sp,-1724
80008d8a:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008d8e:	c1 d8       	rjmp	80008dc8 <_vfprintf_r+0xba4>
80008d90:	fa c8 f9 50 	sub	r8,sp,-1712
80008d94:	1a d8       	st.w	--sp,r8
80008d96:	fa c8 fa b8 	sub	r8,sp,-1352
80008d9a:	04 9a       	mov	r10,r2
80008d9c:	1a d8       	st.w	--sp,r8
80008d9e:	fa c8 fb b4 	sub	r8,sp,-1100
80008da2:	0c 9b       	mov	r11,r6
80008da4:	1a d8       	st.w	--sp,r8
80008da6:	08 9c       	mov	r12,r4
80008da8:	fa c8 f9 40 	sub	r8,sp,-1728
80008dac:	fa c9 ff b4 	sub	r9,sp,-76
80008db0:	fe b0 f8 a2 	rcall	80007ef4 <get_arg>
80008db4:	2f dd       	sub	sp,-12
80008db6:	78 0a       	ld.w	r10,r12[0x0]
80008db8:	c2 08       	rjmp	80008df8 <_vfprintf_r+0xbd4>
80008dba:	2f f7       	sub	r7,-1
80008dbc:	10 39       	cp.w	r9,r8
80008dbe:	c0 84       	brge	80008dce <_vfprintf_r+0xbaa>
80008dc0:	fa cb f9 44 	sub	r11,sp,-1724
80008dc4:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008dc8:	ec fa fd 88 	ld.w	r10,r6[-632]
80008dcc:	c1 68       	rjmp	80008df8 <_vfprintf_r+0xbd4>
80008dce:	41 09       	lddsp	r9,sp[0x40]
80008dd0:	59 f8       	cp.w	r8,31
80008dd2:	e0 89 00 10 	brgt	80008df2 <_vfprintf_r+0xbce>
80008dd6:	f2 ca ff fc 	sub	r10,r9,-4
80008dda:	51 0a       	stdsp	sp[0x40],r10
80008ddc:	fa c6 f9 44 	sub	r6,sp,-1724
80008de0:	72 0a       	ld.w	r10,r9[0x0]
80008de2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008de6:	f3 4a fd 88 	st.w	r9[-632],r10
80008dea:	2f f8       	sub	r8,-1
80008dec:	fb 48 06 b4 	st.w	sp[1716],r8
80008df0:	c0 48       	rjmp	80008df8 <_vfprintf_r+0xbd4>
80008df2:	72 0a       	ld.w	r10,r9[0x0]
80008df4:	2f c9       	sub	r9,-4
80008df6:	51 09       	stdsp	sp[0x40],r9
80008df8:	40 be       	lddsp	lr,sp[0x2c]
80008dfa:	1c 98       	mov	r8,lr
80008dfc:	95 1e       	st.w	r10[0x4],lr
80008dfe:	bf 58       	asr	r8,0x1f
80008e00:	95 08       	st.w	r10[0x0],r8
80008e02:	fe 9f fa 9f 	bral	80008340 <_vfprintf_r+0x11c>
80008e06:	ed b5 00 04 	bld	r5,0x4
80008e0a:	c4 80       	breq	80008e9a <_vfprintf_r+0xc76>
80008e0c:	e2 15 00 40 	andl	r5,0x40,COH
80008e10:	c4 50       	breq	80008e9a <_vfprintf_r+0xc76>
80008e12:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e16:	40 3c       	lddsp	r12,sp[0xc]
80008e18:	58 0c       	cp.w	r12,0
80008e1a:	c1 d0       	breq	80008e54 <_vfprintf_r+0xc30>
80008e1c:	10 36       	cp.w	r6,r8
80008e1e:	c0 64       	brge	80008e2a <_vfprintf_r+0xc06>
80008e20:	fa cb f9 44 	sub	r11,sp,-1724
80008e24:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008e28:	c1 d8       	rjmp	80008e62 <_vfprintf_r+0xc3e>
80008e2a:	fa c8 f9 50 	sub	r8,sp,-1712
80008e2e:	1a d8       	st.w	--sp,r8
80008e30:	fa c8 fa b8 	sub	r8,sp,-1352
80008e34:	04 9a       	mov	r10,r2
80008e36:	1a d8       	st.w	--sp,r8
80008e38:	fa c8 fb b4 	sub	r8,sp,-1100
80008e3c:	0c 9b       	mov	r11,r6
80008e3e:	1a d8       	st.w	--sp,r8
80008e40:	08 9c       	mov	r12,r4
80008e42:	fa c8 f9 40 	sub	r8,sp,-1728
80008e46:	fa c9 ff b4 	sub	r9,sp,-76
80008e4a:	fe b0 f8 55 	rcall	80007ef4 <get_arg>
80008e4e:	2f dd       	sub	sp,-12
80008e50:	78 0a       	ld.w	r10,r12[0x0]
80008e52:	c2 08       	rjmp	80008e92 <_vfprintf_r+0xc6e>
80008e54:	2f f7       	sub	r7,-1
80008e56:	10 39       	cp.w	r9,r8
80008e58:	c0 84       	brge	80008e68 <_vfprintf_r+0xc44>
80008e5a:	fa ca f9 44 	sub	r10,sp,-1724
80008e5e:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008e62:	ec fa fd 88 	ld.w	r10,r6[-632]
80008e66:	c1 68       	rjmp	80008e92 <_vfprintf_r+0xc6e>
80008e68:	41 09       	lddsp	r9,sp[0x40]
80008e6a:	59 f8       	cp.w	r8,31
80008e6c:	e0 89 00 10 	brgt	80008e8c <_vfprintf_r+0xc68>
80008e70:	f2 ca ff fc 	sub	r10,r9,-4
80008e74:	51 0a       	stdsp	sp[0x40],r10
80008e76:	fa c6 f9 44 	sub	r6,sp,-1724
80008e7a:	72 0a       	ld.w	r10,r9[0x0]
80008e7c:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008e80:	f3 4a fd 88 	st.w	r9[-632],r10
80008e84:	2f f8       	sub	r8,-1
80008e86:	fb 48 06 b4 	st.w	sp[1716],r8
80008e8a:	c0 48       	rjmp	80008e92 <_vfprintf_r+0xc6e>
80008e8c:	72 0a       	ld.w	r10,r9[0x0]
80008e8e:	2f c9       	sub	r9,-4
80008e90:	51 09       	stdsp	sp[0x40],r9
80008e92:	40 be       	lddsp	lr,sp[0x2c]
80008e94:	b4 0e       	st.h	r10[0x0],lr
80008e96:	fe 9f fa 55 	bral	80008340 <_vfprintf_r+0x11c>
80008e9a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008e9e:	40 3c       	lddsp	r12,sp[0xc]
80008ea0:	58 0c       	cp.w	r12,0
80008ea2:	c1 d0       	breq	80008edc <_vfprintf_r+0xcb8>
80008ea4:	10 36       	cp.w	r6,r8
80008ea6:	c0 64       	brge	80008eb2 <_vfprintf_r+0xc8e>
80008ea8:	fa cb f9 44 	sub	r11,sp,-1724
80008eac:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008eb0:	c1 d8       	rjmp	80008eea <_vfprintf_r+0xcc6>
80008eb2:	fa c8 f9 50 	sub	r8,sp,-1712
80008eb6:	1a d8       	st.w	--sp,r8
80008eb8:	fa c8 fa b8 	sub	r8,sp,-1352
80008ebc:	04 9a       	mov	r10,r2
80008ebe:	1a d8       	st.w	--sp,r8
80008ec0:	fa c8 fb b4 	sub	r8,sp,-1100
80008ec4:	0c 9b       	mov	r11,r6
80008ec6:	1a d8       	st.w	--sp,r8
80008ec8:	08 9c       	mov	r12,r4
80008eca:	fa c8 f9 40 	sub	r8,sp,-1728
80008ece:	fa c9 ff b4 	sub	r9,sp,-76
80008ed2:	fe b0 f8 11 	rcall	80007ef4 <get_arg>
80008ed6:	2f dd       	sub	sp,-12
80008ed8:	78 0a       	ld.w	r10,r12[0x0]
80008eda:	c2 08       	rjmp	80008f1a <_vfprintf_r+0xcf6>
80008edc:	2f f7       	sub	r7,-1
80008ede:	10 39       	cp.w	r9,r8
80008ee0:	c0 84       	brge	80008ef0 <_vfprintf_r+0xccc>
80008ee2:	fa ca f9 44 	sub	r10,sp,-1724
80008ee6:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008eea:	ec fa fd 88 	ld.w	r10,r6[-632]
80008eee:	c1 68       	rjmp	80008f1a <_vfprintf_r+0xcf6>
80008ef0:	41 09       	lddsp	r9,sp[0x40]
80008ef2:	59 f8       	cp.w	r8,31
80008ef4:	e0 89 00 10 	brgt	80008f14 <_vfprintf_r+0xcf0>
80008ef8:	f2 ca ff fc 	sub	r10,r9,-4
80008efc:	51 0a       	stdsp	sp[0x40],r10
80008efe:	fa c6 f9 44 	sub	r6,sp,-1724
80008f02:	72 0a       	ld.w	r10,r9[0x0]
80008f04:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f08:	f3 4a fd 88 	st.w	r9[-632],r10
80008f0c:	2f f8       	sub	r8,-1
80008f0e:	fb 48 06 b4 	st.w	sp[1716],r8
80008f12:	c0 48       	rjmp	80008f1a <_vfprintf_r+0xcf6>
80008f14:	72 0a       	ld.w	r10,r9[0x0]
80008f16:	2f c9       	sub	r9,-4
80008f18:	51 09       	stdsp	sp[0x40],r9
80008f1a:	40 be       	lddsp	lr,sp[0x2c]
80008f1c:	95 0e       	st.w	r10[0x0],lr
80008f1e:	fe 9f fa 11 	bral	80008340 <_vfprintf_r+0x11c>
80008f22:	50 a7       	stdsp	sp[0x28],r7
80008f24:	50 80       	stdsp	sp[0x20],r0
80008f26:	0c 97       	mov	r7,r6
80008f28:	04 94       	mov	r4,r2
80008f2a:	06 96       	mov	r6,r3
80008f2c:	02 92       	mov	r2,r1
80008f2e:	40 93       	lddsp	r3,sp[0x24]
80008f30:	10 90       	mov	r0,r8
80008f32:	40 41       	lddsp	r1,sp[0x10]
80008f34:	a5 a5       	sbr	r5,0x4
80008f36:	c0 a8       	rjmp	80008f4a <_vfprintf_r+0xd26>
80008f38:	50 a7       	stdsp	sp[0x28],r7
80008f3a:	50 80       	stdsp	sp[0x20],r0
80008f3c:	0c 97       	mov	r7,r6
80008f3e:	04 94       	mov	r4,r2
80008f40:	06 96       	mov	r6,r3
80008f42:	02 92       	mov	r2,r1
80008f44:	40 93       	lddsp	r3,sp[0x24]
80008f46:	10 90       	mov	r0,r8
80008f48:	40 41       	lddsp	r1,sp[0x10]
80008f4a:	ed b5 00 05 	bld	r5,0x5
80008f4e:	c5 d1       	brne	80009008 <_vfprintf_r+0xde4>
80008f50:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f54:	40 3c       	lddsp	r12,sp[0xc]
80008f56:	58 0c       	cp.w	r12,0
80008f58:	c2 60       	breq	80008fa4 <_vfprintf_r+0xd80>
80008f5a:	10 36       	cp.w	r6,r8
80008f5c:	c0 a4       	brge	80008f70 <_vfprintf_r+0xd4c>
80008f5e:	fa cb f9 44 	sub	r11,sp,-1724
80008f62:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f66:	ec e8 fd 88 	ld.d	r8,r6[-632]
80008f6a:	fa e9 00 00 	st.d	sp[0],r8
80008f6e:	c1 88       	rjmp	80008f9e <_vfprintf_r+0xd7a>
80008f70:	fa c8 f9 50 	sub	r8,sp,-1712
80008f74:	1a d8       	st.w	--sp,r8
80008f76:	fa c8 fa b8 	sub	r8,sp,-1352
80008f7a:	04 9a       	mov	r10,r2
80008f7c:	1a d8       	st.w	--sp,r8
80008f7e:	0c 9b       	mov	r11,r6
80008f80:	fa c8 fb b4 	sub	r8,sp,-1100
80008f84:	08 9c       	mov	r12,r4
80008f86:	1a d8       	st.w	--sp,r8
80008f88:	fa c8 f9 40 	sub	r8,sp,-1728
80008f8c:	fa c9 ff b4 	sub	r9,sp,-76
80008f90:	fe b0 f7 b2 	rcall	80007ef4 <get_arg>
80008f94:	2f dd       	sub	sp,-12
80008f96:	f8 ea 00 00 	ld.d	r10,r12[0]
80008f9a:	fa eb 00 00 	st.d	sp[0],r10
80008f9e:	30 08       	mov	r8,0
80008fa0:	e0 8f 03 de 	bral	8000975c <_vfprintf_r+0x1538>
80008fa4:	ee ca ff ff 	sub	r10,r7,-1
80008fa8:	10 37       	cp.w	r7,r8
80008faa:	c0 b4       	brge	80008fc0 <_vfprintf_r+0xd9c>
80008fac:	fa c9 f9 44 	sub	r9,sp,-1724
80008fb0:	14 97       	mov	r7,r10
80008fb2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008fb6:	ec ea fd 88 	ld.d	r10,r6[-632]
80008fba:	fa eb 00 00 	st.d	sp[0],r10
80008fbe:	c1 88       	rjmp	80008fee <_vfprintf_r+0xdca>
80008fc0:	41 09       	lddsp	r9,sp[0x40]
80008fc2:	59 f8       	cp.w	r8,31
80008fc4:	e0 89 00 18 	brgt	80008ff4 <_vfprintf_r+0xdd0>
80008fc8:	f2 e6 00 00 	ld.d	r6,r9[0]
80008fcc:	f2 cb ff f8 	sub	r11,r9,-8
80008fd0:	fa e7 00 00 	st.d	sp[0],r6
80008fd4:	51 0b       	stdsp	sp[0x40],r11
80008fd6:	fa c6 f9 44 	sub	r6,sp,-1724
80008fda:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008fde:	fa e6 00 00 	ld.d	r6,sp[0]
80008fe2:	f2 e7 fd 88 	st.d	r9[-632],r6
80008fe6:	2f f8       	sub	r8,-1
80008fe8:	14 97       	mov	r7,r10
80008fea:	fb 48 06 b4 	st.w	sp[1716],r8
80008fee:	40 38       	lddsp	r8,sp[0xc]
80008ff0:	e0 8f 03 b6 	bral	8000975c <_vfprintf_r+0x1538>
80008ff4:	f2 e6 00 00 	ld.d	r6,r9[0]
80008ff8:	40 38       	lddsp	r8,sp[0xc]
80008ffa:	fa e7 00 00 	st.d	sp[0],r6
80008ffe:	2f 89       	sub	r9,-8
80009000:	14 97       	mov	r7,r10
80009002:	51 09       	stdsp	sp[0x40],r9
80009004:	e0 8f 03 ac 	bral	8000975c <_vfprintf_r+0x1538>
80009008:	ed b5 00 04 	bld	r5,0x4
8000900c:	c1 61       	brne	80009038 <_vfprintf_r+0xe14>
8000900e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009012:	40 3e       	lddsp	lr,sp[0xc]
80009014:	58 0e       	cp.w	lr,0
80009016:	c0 80       	breq	80009026 <_vfprintf_r+0xe02>
80009018:	10 36       	cp.w	r6,r8
8000901a:	c6 74       	brge	800090e8 <_vfprintf_r+0xec4>
8000901c:	fa cc f9 44 	sub	r12,sp,-1724
80009020:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009024:	c8 08       	rjmp	80009124 <_vfprintf_r+0xf00>
80009026:	ee ca ff ff 	sub	r10,r7,-1
8000902a:	10 37       	cp.w	r7,r8
8000902c:	c7 f4       	brge	8000912a <_vfprintf_r+0xf06>
8000902e:	fa cb f9 44 	sub	r11,sp,-1724
80009032:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009036:	c7 68       	rjmp	80009122 <_vfprintf_r+0xefe>
80009038:	ed b5 00 06 	bld	r5,0x6
8000903c:	c4 a1       	brne	800090d0 <_vfprintf_r+0xeac>
8000903e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009042:	40 3c       	lddsp	r12,sp[0xc]
80009044:	58 0c       	cp.w	r12,0
80009046:	c1 d0       	breq	80009080 <_vfprintf_r+0xe5c>
80009048:	10 36       	cp.w	r6,r8
8000904a:	c0 64       	brge	80009056 <_vfprintf_r+0xe32>
8000904c:	fa cb f9 44 	sub	r11,sp,-1724
80009050:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009054:	c1 f8       	rjmp	80009092 <_vfprintf_r+0xe6e>
80009056:	fa c8 f9 50 	sub	r8,sp,-1712
8000905a:	1a d8       	st.w	--sp,r8
8000905c:	fa c8 fa b8 	sub	r8,sp,-1352
80009060:	1a d8       	st.w	--sp,r8
80009062:	fa c8 fb b4 	sub	r8,sp,-1100
80009066:	1a d8       	st.w	--sp,r8
80009068:	fa c8 f9 40 	sub	r8,sp,-1728
8000906c:	fa c9 ff b4 	sub	r9,sp,-76
80009070:	04 9a       	mov	r10,r2
80009072:	0c 9b       	mov	r11,r6
80009074:	08 9c       	mov	r12,r4
80009076:	fe b0 f7 3f 	rcall	80007ef4 <get_arg>
8000907a:	2f dd       	sub	sp,-12
8000907c:	98 18       	ld.sh	r8,r12[0x2]
8000907e:	c2 68       	rjmp	800090ca <_vfprintf_r+0xea6>
80009080:	ee ca ff ff 	sub	r10,r7,-1
80009084:	10 37       	cp.w	r7,r8
80009086:	c0 94       	brge	80009098 <_vfprintf_r+0xe74>
80009088:	fa c9 f9 44 	sub	r9,sp,-1724
8000908c:	14 97       	mov	r7,r10
8000908e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009092:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009096:	c1 a8       	rjmp	800090ca <_vfprintf_r+0xea6>
80009098:	41 09       	lddsp	r9,sp[0x40]
8000909a:	59 f8       	cp.w	r8,31
8000909c:	e0 89 00 13 	brgt	800090c2 <_vfprintf_r+0xe9e>
800090a0:	f2 cb ff fc 	sub	r11,r9,-4
800090a4:	51 0b       	stdsp	sp[0x40],r11
800090a6:	72 09       	ld.w	r9,r9[0x0]
800090a8:	fa c6 f9 44 	sub	r6,sp,-1724
800090ac:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800090b0:	2f f8       	sub	r8,-1
800090b2:	f7 49 fd 88 	st.w	r11[-632],r9
800090b6:	fb 48 06 b4 	st.w	sp[1716],r8
800090ba:	14 97       	mov	r7,r10
800090bc:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800090c0:	c0 58       	rjmp	800090ca <_vfprintf_r+0xea6>
800090c2:	92 18       	ld.sh	r8,r9[0x2]
800090c4:	14 97       	mov	r7,r10
800090c6:	2f c9       	sub	r9,-4
800090c8:	51 09       	stdsp	sp[0x40],r9
800090ca:	5c 78       	castu.h	r8
800090cc:	50 18       	stdsp	sp[0x4],r8
800090ce:	c4 68       	rjmp	8000915a <_vfprintf_r+0xf36>
800090d0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090d4:	40 3c       	lddsp	r12,sp[0xc]
800090d6:	58 0c       	cp.w	r12,0
800090d8:	c1 d0       	breq	80009112 <_vfprintf_r+0xeee>
800090da:	10 36       	cp.w	r6,r8
800090dc:	c0 64       	brge	800090e8 <_vfprintf_r+0xec4>
800090de:	fa cb f9 44 	sub	r11,sp,-1724
800090e2:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090e6:	c1 f8       	rjmp	80009124 <_vfprintf_r+0xf00>
800090e8:	fa c8 f9 50 	sub	r8,sp,-1712
800090ec:	1a d8       	st.w	--sp,r8
800090ee:	fa c8 fa b8 	sub	r8,sp,-1352
800090f2:	0c 9b       	mov	r11,r6
800090f4:	1a d8       	st.w	--sp,r8
800090f6:	fa c8 fb b4 	sub	r8,sp,-1100
800090fa:	04 9a       	mov	r10,r2
800090fc:	1a d8       	st.w	--sp,r8
800090fe:	08 9c       	mov	r12,r4
80009100:	fa c8 f9 40 	sub	r8,sp,-1728
80009104:	fa c9 ff b4 	sub	r9,sp,-76
80009108:	fe b0 f6 f6 	rcall	80007ef4 <get_arg>
8000910c:	2f dd       	sub	sp,-12
8000910e:	78 0b       	ld.w	r11,r12[0x0]
80009110:	c2 48       	rjmp	80009158 <_vfprintf_r+0xf34>
80009112:	ee ca ff ff 	sub	r10,r7,-1
80009116:	10 37       	cp.w	r7,r8
80009118:	c0 94       	brge	8000912a <_vfprintf_r+0xf06>
8000911a:	fa c9 f9 44 	sub	r9,sp,-1724
8000911e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009122:	14 97       	mov	r7,r10
80009124:	ec fb fd 88 	ld.w	r11,r6[-632]
80009128:	c1 88       	rjmp	80009158 <_vfprintf_r+0xf34>
8000912a:	41 09       	lddsp	r9,sp[0x40]
8000912c:	59 f8       	cp.w	r8,31
8000912e:	e0 89 00 11 	brgt	80009150 <_vfprintf_r+0xf2c>
80009132:	f2 cb ff fc 	sub	r11,r9,-4
80009136:	51 0b       	stdsp	sp[0x40],r11
80009138:	fa c6 f9 44 	sub	r6,sp,-1724
8000913c:	72 0b       	ld.w	r11,r9[0x0]
8000913e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009142:	f3 4b fd 88 	st.w	r9[-632],r11
80009146:	2f f8       	sub	r8,-1
80009148:	14 97       	mov	r7,r10
8000914a:	fb 48 06 b4 	st.w	sp[1716],r8
8000914e:	c0 58       	rjmp	80009158 <_vfprintf_r+0xf34>
80009150:	72 0b       	ld.w	r11,r9[0x0]
80009152:	14 97       	mov	r7,r10
80009154:	2f c9       	sub	r9,-4
80009156:	51 09       	stdsp	sp[0x40],r9
80009158:	50 1b       	stdsp	sp[0x4],r11
8000915a:	30 0e       	mov	lr,0
8000915c:	50 0e       	stdsp	sp[0x0],lr
8000915e:	1c 98       	mov	r8,lr
80009160:	e0 8f 02 fe 	bral	8000975c <_vfprintf_r+0x1538>
80009164:	50 a7       	stdsp	sp[0x28],r7
80009166:	50 80       	stdsp	sp[0x20],r0
80009168:	0c 97       	mov	r7,r6
8000916a:	04 94       	mov	r4,r2
8000916c:	06 96       	mov	r6,r3
8000916e:	02 92       	mov	r2,r1
80009170:	40 93       	lddsp	r3,sp[0x24]
80009172:	40 41       	lddsp	r1,sp[0x10]
80009174:	0e 99       	mov	r9,r7
80009176:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000917a:	40 3c       	lddsp	r12,sp[0xc]
8000917c:	58 0c       	cp.w	r12,0
8000917e:	c1 d0       	breq	800091b8 <_vfprintf_r+0xf94>
80009180:	10 36       	cp.w	r6,r8
80009182:	c0 64       	brge	8000918e <_vfprintf_r+0xf6a>
80009184:	fa cb f9 44 	sub	r11,sp,-1724
80009188:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000918c:	c1 d8       	rjmp	800091c6 <_vfprintf_r+0xfa2>
8000918e:	fa c8 f9 50 	sub	r8,sp,-1712
80009192:	1a d8       	st.w	--sp,r8
80009194:	fa c8 fa b8 	sub	r8,sp,-1352
80009198:	1a d8       	st.w	--sp,r8
8000919a:	fa c8 fb b4 	sub	r8,sp,-1100
8000919e:	1a d8       	st.w	--sp,r8
800091a0:	fa c9 ff b4 	sub	r9,sp,-76
800091a4:	fa c8 f9 40 	sub	r8,sp,-1728
800091a8:	04 9a       	mov	r10,r2
800091aa:	0c 9b       	mov	r11,r6
800091ac:	08 9c       	mov	r12,r4
800091ae:	fe b0 f6 a3 	rcall	80007ef4 <get_arg>
800091b2:	2f dd       	sub	sp,-12
800091b4:	78 09       	ld.w	r9,r12[0x0]
800091b6:	c2 18       	rjmp	800091f8 <_vfprintf_r+0xfd4>
800091b8:	2f f7       	sub	r7,-1
800091ba:	10 39       	cp.w	r9,r8
800091bc:	c0 84       	brge	800091cc <_vfprintf_r+0xfa8>
800091be:	fa ca f9 44 	sub	r10,sp,-1724
800091c2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800091c6:	ec f9 fd 88 	ld.w	r9,r6[-632]
800091ca:	c1 78       	rjmp	800091f8 <_vfprintf_r+0xfd4>
800091cc:	41 09       	lddsp	r9,sp[0x40]
800091ce:	59 f8       	cp.w	r8,31
800091d0:	e0 89 00 10 	brgt	800091f0 <_vfprintf_r+0xfcc>
800091d4:	f2 ca ff fc 	sub	r10,r9,-4
800091d8:	51 0a       	stdsp	sp[0x40],r10
800091da:	fa c6 f9 44 	sub	r6,sp,-1724
800091de:	72 09       	ld.w	r9,r9[0x0]
800091e0:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800091e4:	f5 49 fd 88 	st.w	r10[-632],r9
800091e8:	2f f8       	sub	r8,-1
800091ea:	fb 48 06 b4 	st.w	sp[1716],r8
800091ee:	c0 58       	rjmp	800091f8 <_vfprintf_r+0xfd4>
800091f0:	f2 c8 ff fc 	sub	r8,r9,-4
800091f4:	51 08       	stdsp	sp[0x40],r8
800091f6:	72 09       	ld.w	r9,r9[0x0]
800091f8:	33 08       	mov	r8,48
800091fa:	fb 68 06 b8 	st.b	sp[1720],r8
800091fe:	37 88       	mov	r8,120
80009200:	30 0e       	mov	lr,0
80009202:	fb 68 06 b9 	st.b	sp[1721],r8
80009206:	fe cc b0 0e 	sub	r12,pc,-20466
8000920a:	50 19       	stdsp	sp[0x4],r9
8000920c:	a1 b5       	sbr	r5,0x1
8000920e:	50 0e       	stdsp	sp[0x0],lr
80009210:	50 dc       	stdsp	sp[0x34],r12
80009212:	30 28       	mov	r8,2
80009214:	37 80       	mov	r0,120
80009216:	e0 8f 02 a3 	bral	8000975c <_vfprintf_r+0x1538>
8000921a:	50 a7       	stdsp	sp[0x28],r7
8000921c:	50 80       	stdsp	sp[0x20],r0
8000921e:	10 90       	mov	r0,r8
80009220:	30 08       	mov	r8,0
80009222:	fb 68 06 bb 	st.b	sp[1723],r8
80009226:	0c 97       	mov	r7,r6
80009228:	04 94       	mov	r4,r2
8000922a:	06 96       	mov	r6,r3
8000922c:	02 92       	mov	r2,r1
8000922e:	40 93       	lddsp	r3,sp[0x24]
80009230:	40 41       	lddsp	r1,sp[0x10]
80009232:	0e 99       	mov	r9,r7
80009234:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009238:	40 3b       	lddsp	r11,sp[0xc]
8000923a:	58 0b       	cp.w	r11,0
8000923c:	c1 d0       	breq	80009276 <_vfprintf_r+0x1052>
8000923e:	10 36       	cp.w	r6,r8
80009240:	c0 64       	brge	8000924c <_vfprintf_r+0x1028>
80009242:	fa ca f9 44 	sub	r10,sp,-1724
80009246:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000924a:	c1 d8       	rjmp	80009284 <_vfprintf_r+0x1060>
8000924c:	fa c8 f9 50 	sub	r8,sp,-1712
80009250:	1a d8       	st.w	--sp,r8
80009252:	fa c8 fa b8 	sub	r8,sp,-1352
80009256:	1a d8       	st.w	--sp,r8
80009258:	fa c8 fb b4 	sub	r8,sp,-1100
8000925c:	0c 9b       	mov	r11,r6
8000925e:	1a d8       	st.w	--sp,r8
80009260:	04 9a       	mov	r10,r2
80009262:	fa c8 f9 40 	sub	r8,sp,-1728
80009266:	fa c9 ff b4 	sub	r9,sp,-76
8000926a:	08 9c       	mov	r12,r4
8000926c:	fe b0 f6 44 	rcall	80007ef4 <get_arg>
80009270:	2f dd       	sub	sp,-12
80009272:	78 06       	ld.w	r6,r12[0x0]
80009274:	c2 08       	rjmp	800092b4 <_vfprintf_r+0x1090>
80009276:	2f f7       	sub	r7,-1
80009278:	10 39       	cp.w	r9,r8
8000927a:	c0 84       	brge	8000928a <_vfprintf_r+0x1066>
8000927c:	fa c9 f9 44 	sub	r9,sp,-1724
80009280:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009284:	ec f6 fd 88 	ld.w	r6,r6[-632]
80009288:	c1 68       	rjmp	800092b4 <_vfprintf_r+0x1090>
8000928a:	41 09       	lddsp	r9,sp[0x40]
8000928c:	59 f8       	cp.w	r8,31
8000928e:	e0 89 00 10 	brgt	800092ae <_vfprintf_r+0x108a>
80009292:	f2 ca ff fc 	sub	r10,r9,-4
80009296:	51 0a       	stdsp	sp[0x40],r10
80009298:	72 06       	ld.w	r6,r9[0x0]
8000929a:	fa ce f9 44 	sub	lr,sp,-1724
8000929e:	fc 08 00 39 	add	r9,lr,r8<<0x3
800092a2:	f3 46 fd 88 	st.w	r9[-632],r6
800092a6:	2f f8       	sub	r8,-1
800092a8:	fb 48 06 b4 	st.w	sp[1716],r8
800092ac:	c0 48       	rjmp	800092b4 <_vfprintf_r+0x1090>
800092ae:	72 06       	ld.w	r6,r9[0x0]
800092b0:	2f c9       	sub	r9,-4
800092b2:	51 09       	stdsp	sp[0x40],r9
800092b4:	40 2c       	lddsp	r12,sp[0x8]
800092b6:	58 0c       	cp.w	r12,0
800092b8:	c1 05       	brlt	800092d8 <_vfprintf_r+0x10b4>
800092ba:	18 9a       	mov	r10,r12
800092bc:	30 0b       	mov	r11,0
800092be:	0c 9c       	mov	r12,r6
800092c0:	e0 a0 12 38 	rcall	8000b730 <memchr>
800092c4:	e0 80 02 df 	breq	80009882 <_vfprintf_r+0x165e>
800092c8:	f8 06 01 02 	sub	r2,r12,r6
800092cc:	40 2b       	lddsp	r11,sp[0x8]
800092ce:	16 32       	cp.w	r2,r11
800092d0:	e0 89 02 d9 	brgt	80009882 <_vfprintf_r+0x165e>
800092d4:	e0 8f 02 d4 	bral	8000987c <_vfprintf_r+0x1658>
800092d8:	30 0a       	mov	r10,0
800092da:	0c 9c       	mov	r12,r6
800092dc:	50 2a       	stdsp	sp[0x8],r10
800092de:	e0 a0 15 99 	rcall	8000be10 <strlen>
800092e2:	18 92       	mov	r2,r12
800092e4:	e0 8f 02 d2 	bral	80009888 <_vfprintf_r+0x1664>
800092e8:	50 a7       	stdsp	sp[0x28],r7
800092ea:	50 80       	stdsp	sp[0x20],r0
800092ec:	0c 97       	mov	r7,r6
800092ee:	04 94       	mov	r4,r2
800092f0:	06 96       	mov	r6,r3
800092f2:	02 92       	mov	r2,r1
800092f4:	40 93       	lddsp	r3,sp[0x24]
800092f6:	10 90       	mov	r0,r8
800092f8:	40 41       	lddsp	r1,sp[0x10]
800092fa:	a5 a5       	sbr	r5,0x4
800092fc:	c0 a8       	rjmp	80009310 <_vfprintf_r+0x10ec>
800092fe:	50 a7       	stdsp	sp[0x28],r7
80009300:	50 80       	stdsp	sp[0x20],r0
80009302:	0c 97       	mov	r7,r6
80009304:	04 94       	mov	r4,r2
80009306:	06 96       	mov	r6,r3
80009308:	02 92       	mov	r2,r1
8000930a:	40 93       	lddsp	r3,sp[0x24]
8000930c:	10 90       	mov	r0,r8
8000930e:	40 41       	lddsp	r1,sp[0x10]
80009310:	ed b5 00 05 	bld	r5,0x5
80009314:	c5 61       	brne	800093c0 <_vfprintf_r+0x119c>
80009316:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000931a:	40 39       	lddsp	r9,sp[0xc]
8000931c:	58 09       	cp.w	r9,0
8000931e:	c2 10       	breq	80009360 <_vfprintf_r+0x113c>
80009320:	10 36       	cp.w	r6,r8
80009322:	c0 74       	brge	80009330 <_vfprintf_r+0x110c>
80009324:	fa c8 f9 44 	sub	r8,sp,-1724
80009328:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000932c:	c2 38       	rjmp	80009372 <_vfprintf_r+0x114e>
8000932e:	d7 03       	nop
80009330:	fa c8 f9 50 	sub	r8,sp,-1712
80009334:	1a d8       	st.w	--sp,r8
80009336:	fa c8 fa b8 	sub	r8,sp,-1352
8000933a:	1a d8       	st.w	--sp,r8
8000933c:	fa c8 fb b4 	sub	r8,sp,-1100
80009340:	1a d8       	st.w	--sp,r8
80009342:	fa c8 f9 40 	sub	r8,sp,-1728
80009346:	fa c9 ff b4 	sub	r9,sp,-76
8000934a:	04 9a       	mov	r10,r2
8000934c:	0c 9b       	mov	r11,r6
8000934e:	08 9c       	mov	r12,r4
80009350:	fe b0 f5 d2 	rcall	80007ef4 <get_arg>
80009354:	2f dd       	sub	sp,-12
80009356:	f8 e8 00 00 	ld.d	r8,r12[0]
8000935a:	fa e9 00 00 	st.d	sp[0],r8
8000935e:	c2 e8       	rjmp	800093ba <_vfprintf_r+0x1196>
80009360:	ee ca ff ff 	sub	r10,r7,-1
80009364:	10 37       	cp.w	r7,r8
80009366:	c0 b4       	brge	8000937c <_vfprintf_r+0x1158>
80009368:	fa c8 f9 44 	sub	r8,sp,-1724
8000936c:	14 97       	mov	r7,r10
8000936e:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009372:	ec ea fd 88 	ld.d	r10,r6[-632]
80009376:	fa eb 00 00 	st.d	sp[0],r10
8000937a:	c2 08       	rjmp	800093ba <_vfprintf_r+0x1196>
8000937c:	41 09       	lddsp	r9,sp[0x40]
8000937e:	59 f8       	cp.w	r8,31
80009380:	e0 89 00 16 	brgt	800093ac <_vfprintf_r+0x1188>
80009384:	f2 e6 00 00 	ld.d	r6,r9[0]
80009388:	f2 cb ff f8 	sub	r11,r9,-8
8000938c:	fa e7 00 00 	st.d	sp[0],r6
80009390:	51 0b       	stdsp	sp[0x40],r11
80009392:	fa c6 f9 44 	sub	r6,sp,-1724
80009396:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000939a:	fa e6 00 00 	ld.d	r6,sp[0]
8000939e:	f2 e7 fd 88 	st.d	r9[-632],r6
800093a2:	2f f8       	sub	r8,-1
800093a4:	14 97       	mov	r7,r10
800093a6:	fb 48 06 b4 	st.w	sp[1716],r8
800093aa:	c0 88       	rjmp	800093ba <_vfprintf_r+0x1196>
800093ac:	f2 e6 00 00 	ld.d	r6,r9[0]
800093b0:	2f 89       	sub	r9,-8
800093b2:	fa e7 00 00 	st.d	sp[0],r6
800093b6:	51 09       	stdsp	sp[0x40],r9
800093b8:	14 97       	mov	r7,r10
800093ba:	30 18       	mov	r8,1
800093bc:	e0 8f 01 d0 	bral	8000975c <_vfprintf_r+0x1538>
800093c0:	ed b5 00 04 	bld	r5,0x4
800093c4:	c1 61       	brne	800093f0 <_vfprintf_r+0x11cc>
800093c6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093ca:	40 3e       	lddsp	lr,sp[0xc]
800093cc:	58 0e       	cp.w	lr,0
800093ce:	c0 80       	breq	800093de <_vfprintf_r+0x11ba>
800093d0:	10 36       	cp.w	r6,r8
800093d2:	c6 74       	brge	800094a0 <_vfprintf_r+0x127c>
800093d4:	fa cc f9 44 	sub	r12,sp,-1724
800093d8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800093dc:	c8 08       	rjmp	800094dc <_vfprintf_r+0x12b8>
800093de:	ee ca ff ff 	sub	r10,r7,-1
800093e2:	10 37       	cp.w	r7,r8
800093e4:	c7 f4       	brge	800094e2 <_vfprintf_r+0x12be>
800093e6:	fa cb f9 44 	sub	r11,sp,-1724
800093ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
800093ee:	c7 68       	rjmp	800094da <_vfprintf_r+0x12b6>
800093f0:	ed b5 00 06 	bld	r5,0x6
800093f4:	c4 a1       	brne	80009488 <_vfprintf_r+0x1264>
800093f6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093fa:	40 3c       	lddsp	r12,sp[0xc]
800093fc:	58 0c       	cp.w	r12,0
800093fe:	c1 d0       	breq	80009438 <_vfprintf_r+0x1214>
80009400:	10 36       	cp.w	r6,r8
80009402:	c0 64       	brge	8000940e <_vfprintf_r+0x11ea>
80009404:	fa cb f9 44 	sub	r11,sp,-1724
80009408:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000940c:	c1 f8       	rjmp	8000944a <_vfprintf_r+0x1226>
8000940e:	fa c8 f9 50 	sub	r8,sp,-1712
80009412:	1a d8       	st.w	--sp,r8
80009414:	fa c8 fa b8 	sub	r8,sp,-1352
80009418:	1a d8       	st.w	--sp,r8
8000941a:	fa c8 fb b4 	sub	r8,sp,-1100
8000941e:	1a d8       	st.w	--sp,r8
80009420:	fa c8 f9 40 	sub	r8,sp,-1728
80009424:	fa c9 ff b4 	sub	r9,sp,-76
80009428:	04 9a       	mov	r10,r2
8000942a:	0c 9b       	mov	r11,r6
8000942c:	08 9c       	mov	r12,r4
8000942e:	fe b0 f5 63 	rcall	80007ef4 <get_arg>
80009432:	2f dd       	sub	sp,-12
80009434:	98 18       	ld.sh	r8,r12[0x2]
80009436:	c2 68       	rjmp	80009482 <_vfprintf_r+0x125e>
80009438:	ee ca ff ff 	sub	r10,r7,-1
8000943c:	10 37       	cp.w	r7,r8
8000943e:	c0 94       	brge	80009450 <_vfprintf_r+0x122c>
80009440:	fa c9 f9 44 	sub	r9,sp,-1724
80009444:	14 97       	mov	r7,r10
80009446:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000944a:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000944e:	c1 a8       	rjmp	80009482 <_vfprintf_r+0x125e>
80009450:	41 09       	lddsp	r9,sp[0x40]
80009452:	59 f8       	cp.w	r8,31
80009454:	e0 89 00 13 	brgt	8000947a <_vfprintf_r+0x1256>
80009458:	f2 cb ff fc 	sub	r11,r9,-4
8000945c:	51 0b       	stdsp	sp[0x40],r11
8000945e:	72 09       	ld.w	r9,r9[0x0]
80009460:	fa c6 f9 44 	sub	r6,sp,-1724
80009464:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009468:	2f f8       	sub	r8,-1
8000946a:	f7 49 fd 88 	st.w	r11[-632],r9
8000946e:	fb 48 06 b4 	st.w	sp[1716],r8
80009472:	14 97       	mov	r7,r10
80009474:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009478:	c0 58       	rjmp	80009482 <_vfprintf_r+0x125e>
8000947a:	92 18       	ld.sh	r8,r9[0x2]
8000947c:	14 97       	mov	r7,r10
8000947e:	2f c9       	sub	r9,-4
80009480:	51 09       	stdsp	sp[0x40],r9
80009482:	5c 78       	castu.h	r8
80009484:	50 18       	stdsp	sp[0x4],r8
80009486:	c4 68       	rjmp	80009512 <_vfprintf_r+0x12ee>
80009488:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000948c:	40 3c       	lddsp	r12,sp[0xc]
8000948e:	58 0c       	cp.w	r12,0
80009490:	c1 d0       	breq	800094ca <_vfprintf_r+0x12a6>
80009492:	10 36       	cp.w	r6,r8
80009494:	c0 64       	brge	800094a0 <_vfprintf_r+0x127c>
80009496:	fa cb f9 44 	sub	r11,sp,-1724
8000949a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000949e:	c1 f8       	rjmp	800094dc <_vfprintf_r+0x12b8>
800094a0:	fa c8 f9 50 	sub	r8,sp,-1712
800094a4:	1a d8       	st.w	--sp,r8
800094a6:	fa c8 fa b8 	sub	r8,sp,-1352
800094aa:	0c 9b       	mov	r11,r6
800094ac:	1a d8       	st.w	--sp,r8
800094ae:	fa c8 fb b4 	sub	r8,sp,-1100
800094b2:	04 9a       	mov	r10,r2
800094b4:	1a d8       	st.w	--sp,r8
800094b6:	08 9c       	mov	r12,r4
800094b8:	fa c8 f9 40 	sub	r8,sp,-1728
800094bc:	fa c9 ff b4 	sub	r9,sp,-76
800094c0:	fe b0 f5 1a 	rcall	80007ef4 <get_arg>
800094c4:	2f dd       	sub	sp,-12
800094c6:	78 0b       	ld.w	r11,r12[0x0]
800094c8:	c2 48       	rjmp	80009510 <_vfprintf_r+0x12ec>
800094ca:	ee ca ff ff 	sub	r10,r7,-1
800094ce:	10 37       	cp.w	r7,r8
800094d0:	c0 94       	brge	800094e2 <_vfprintf_r+0x12be>
800094d2:	fa c9 f9 44 	sub	r9,sp,-1724
800094d6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800094da:	14 97       	mov	r7,r10
800094dc:	ec fb fd 88 	ld.w	r11,r6[-632]
800094e0:	c1 88       	rjmp	80009510 <_vfprintf_r+0x12ec>
800094e2:	41 09       	lddsp	r9,sp[0x40]
800094e4:	59 f8       	cp.w	r8,31
800094e6:	e0 89 00 11 	brgt	80009508 <_vfprintf_r+0x12e4>
800094ea:	f2 cb ff fc 	sub	r11,r9,-4
800094ee:	51 0b       	stdsp	sp[0x40],r11
800094f0:	fa c6 f9 44 	sub	r6,sp,-1724
800094f4:	72 0b       	ld.w	r11,r9[0x0]
800094f6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800094fa:	f3 4b fd 88 	st.w	r9[-632],r11
800094fe:	2f f8       	sub	r8,-1
80009500:	14 97       	mov	r7,r10
80009502:	fb 48 06 b4 	st.w	sp[1716],r8
80009506:	c0 58       	rjmp	80009510 <_vfprintf_r+0x12ec>
80009508:	72 0b       	ld.w	r11,r9[0x0]
8000950a:	14 97       	mov	r7,r10
8000950c:	2f c9       	sub	r9,-4
8000950e:	51 09       	stdsp	sp[0x40],r9
80009510:	50 1b       	stdsp	sp[0x4],r11
80009512:	30 0e       	mov	lr,0
80009514:	30 18       	mov	r8,1
80009516:	50 0e       	stdsp	sp[0x0],lr
80009518:	c2 29       	rjmp	8000975c <_vfprintf_r+0x1538>
8000951a:	50 a7       	stdsp	sp[0x28],r7
8000951c:	50 80       	stdsp	sp[0x20],r0
8000951e:	0c 97       	mov	r7,r6
80009520:	04 94       	mov	r4,r2
80009522:	06 96       	mov	r6,r3
80009524:	02 92       	mov	r2,r1
80009526:	fe cc b3 2e 	sub	r12,pc,-19666
8000952a:	40 93       	lddsp	r3,sp[0x24]
8000952c:	10 90       	mov	r0,r8
8000952e:	40 41       	lddsp	r1,sp[0x10]
80009530:	50 dc       	stdsp	sp[0x34],r12
80009532:	ed b5 00 05 	bld	r5,0x5
80009536:	c5 51       	brne	800095e0 <_vfprintf_r+0x13bc>
80009538:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000953c:	40 3b       	lddsp	r11,sp[0xc]
8000953e:	58 0b       	cp.w	r11,0
80009540:	c2 20       	breq	80009584 <_vfprintf_r+0x1360>
80009542:	10 36       	cp.w	r6,r8
80009544:	c0 a4       	brge	80009558 <_vfprintf_r+0x1334>
80009546:	fa ca f9 44 	sub	r10,sp,-1724
8000954a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000954e:	ec e8 fd 88 	ld.d	r8,r6[-632]
80009552:	fa e9 00 00 	st.d	sp[0],r8
80009556:	cf 28       	rjmp	8000973a <_vfprintf_r+0x1516>
80009558:	fa c8 f9 50 	sub	r8,sp,-1712
8000955c:	1a d8       	st.w	--sp,r8
8000955e:	fa c8 fa b8 	sub	r8,sp,-1352
80009562:	04 9a       	mov	r10,r2
80009564:	1a d8       	st.w	--sp,r8
80009566:	0c 9b       	mov	r11,r6
80009568:	fa c8 fb b4 	sub	r8,sp,-1100
8000956c:	08 9c       	mov	r12,r4
8000956e:	1a d8       	st.w	--sp,r8
80009570:	fa c8 f9 40 	sub	r8,sp,-1728
80009574:	fa c9 ff b4 	sub	r9,sp,-76
80009578:	fe b0 f4 be 	rcall	80007ef4 <get_arg>
8000957c:	2f dd       	sub	sp,-12
8000957e:	f8 ea 00 00 	ld.d	r10,r12[0]
80009582:	c0 c8       	rjmp	8000959a <_vfprintf_r+0x1376>
80009584:	ee ca ff ff 	sub	r10,r7,-1
80009588:	10 37       	cp.w	r7,r8
8000958a:	c0 b4       	brge	800095a0 <_vfprintf_r+0x137c>
8000958c:	fa c9 f9 44 	sub	r9,sp,-1724
80009590:	14 97       	mov	r7,r10
80009592:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009596:	ec ea fd 88 	ld.d	r10,r6[-632]
8000959a:	fa eb 00 00 	st.d	sp[0],r10
8000959e:	cc e8       	rjmp	8000973a <_vfprintf_r+0x1516>
800095a0:	41 09       	lddsp	r9,sp[0x40]
800095a2:	59 f8       	cp.w	r8,31
800095a4:	e0 89 00 16 	brgt	800095d0 <_vfprintf_r+0x13ac>
800095a8:	f2 e6 00 00 	ld.d	r6,r9[0]
800095ac:	f2 cb ff f8 	sub	r11,r9,-8
800095b0:	fa e7 00 00 	st.d	sp[0],r6
800095b4:	51 0b       	stdsp	sp[0x40],r11
800095b6:	fa c6 f9 44 	sub	r6,sp,-1724
800095ba:	ec 08 00 39 	add	r9,r6,r8<<0x3
800095be:	fa e6 00 00 	ld.d	r6,sp[0]
800095c2:	f2 e7 fd 88 	st.d	r9[-632],r6
800095c6:	2f f8       	sub	r8,-1
800095c8:	14 97       	mov	r7,r10
800095ca:	fb 48 06 b4 	st.w	sp[1716],r8
800095ce:	cb 68       	rjmp	8000973a <_vfprintf_r+0x1516>
800095d0:	f2 e6 00 00 	ld.d	r6,r9[0]
800095d4:	2f 89       	sub	r9,-8
800095d6:	fa e7 00 00 	st.d	sp[0],r6
800095da:	51 09       	stdsp	sp[0x40],r9
800095dc:	14 97       	mov	r7,r10
800095de:	ca e8       	rjmp	8000973a <_vfprintf_r+0x1516>
800095e0:	ed b5 00 04 	bld	r5,0x4
800095e4:	c1 71       	brne	80009612 <_vfprintf_r+0x13ee>
800095e6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800095ea:	40 3e       	lddsp	lr,sp[0xc]
800095ec:	58 0e       	cp.w	lr,0
800095ee:	c0 80       	breq	800095fe <_vfprintf_r+0x13da>
800095f0:	10 36       	cp.w	r6,r8
800095f2:	c6 94       	brge	800096c4 <_vfprintf_r+0x14a0>
800095f4:	fa cc f9 44 	sub	r12,sp,-1724
800095f8:	f8 06 00 36 	add	r6,r12,r6<<0x3
800095fc:	c8 28       	rjmp	80009700 <_vfprintf_r+0x14dc>
800095fe:	ee ca ff ff 	sub	r10,r7,-1
80009602:	10 37       	cp.w	r7,r8
80009604:	e0 84 00 81 	brge	80009706 <_vfprintf_r+0x14e2>
80009608:	fa cb f9 44 	sub	r11,sp,-1724
8000960c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009610:	c7 78       	rjmp	800096fe <_vfprintf_r+0x14da>
80009612:	ed b5 00 06 	bld	r5,0x6
80009616:	c4 b1       	brne	800096ac <_vfprintf_r+0x1488>
80009618:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000961c:	40 3c       	lddsp	r12,sp[0xc]
8000961e:	58 0c       	cp.w	r12,0
80009620:	c1 d0       	breq	8000965a <_vfprintf_r+0x1436>
80009622:	10 36       	cp.w	r6,r8
80009624:	c0 64       	brge	80009630 <_vfprintf_r+0x140c>
80009626:	fa cb f9 44 	sub	r11,sp,-1724
8000962a:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000962e:	c1 f8       	rjmp	8000966c <_vfprintf_r+0x1448>
80009630:	fa c8 f9 50 	sub	r8,sp,-1712
80009634:	1a d8       	st.w	--sp,r8
80009636:	fa c8 fa b8 	sub	r8,sp,-1352
8000963a:	1a d8       	st.w	--sp,r8
8000963c:	fa c8 fb b4 	sub	r8,sp,-1100
80009640:	1a d8       	st.w	--sp,r8
80009642:	fa c8 f9 40 	sub	r8,sp,-1728
80009646:	fa c9 ff b4 	sub	r9,sp,-76
8000964a:	04 9a       	mov	r10,r2
8000964c:	0c 9b       	mov	r11,r6
8000964e:	08 9c       	mov	r12,r4
80009650:	fe b0 f4 52 	rcall	80007ef4 <get_arg>
80009654:	2f dd       	sub	sp,-12
80009656:	98 18       	ld.sh	r8,r12[0x2]
80009658:	c2 78       	rjmp	800096a6 <_vfprintf_r+0x1482>
8000965a:	ee ca ff ff 	sub	r10,r7,-1
8000965e:	10 37       	cp.w	r7,r8
80009660:	c0 a4       	brge	80009674 <_vfprintf_r+0x1450>
80009662:	fa c9 f9 44 	sub	r9,sp,-1724
80009666:	14 97       	mov	r7,r10
80009668:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000966c:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009670:	c1 b8       	rjmp	800096a6 <_vfprintf_r+0x1482>
80009672:	d7 03       	nop
80009674:	41 09       	lddsp	r9,sp[0x40]
80009676:	59 f8       	cp.w	r8,31
80009678:	e0 89 00 13 	brgt	8000969e <_vfprintf_r+0x147a>
8000967c:	f2 cb ff fc 	sub	r11,r9,-4
80009680:	51 0b       	stdsp	sp[0x40],r11
80009682:	72 09       	ld.w	r9,r9[0x0]
80009684:	fa c6 f9 44 	sub	r6,sp,-1724
80009688:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000968c:	2f f8       	sub	r8,-1
8000968e:	f7 49 fd 88 	st.w	r11[-632],r9
80009692:	fb 48 06 b4 	st.w	sp[1716],r8
80009696:	14 97       	mov	r7,r10
80009698:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000969c:	c0 58       	rjmp	800096a6 <_vfprintf_r+0x1482>
8000969e:	92 18       	ld.sh	r8,r9[0x2]
800096a0:	14 97       	mov	r7,r10
800096a2:	2f c9       	sub	r9,-4
800096a4:	51 09       	stdsp	sp[0x40],r9
800096a6:	5c 78       	castu.h	r8
800096a8:	50 18       	stdsp	sp[0x4],r8
800096aa:	c4 68       	rjmp	80009736 <_vfprintf_r+0x1512>
800096ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096b0:	40 3c       	lddsp	r12,sp[0xc]
800096b2:	58 0c       	cp.w	r12,0
800096b4:	c1 d0       	breq	800096ee <_vfprintf_r+0x14ca>
800096b6:	10 36       	cp.w	r6,r8
800096b8:	c0 64       	brge	800096c4 <_vfprintf_r+0x14a0>
800096ba:	fa cb f9 44 	sub	r11,sp,-1724
800096be:	f6 06 00 36 	add	r6,r11,r6<<0x3
800096c2:	c1 f8       	rjmp	80009700 <_vfprintf_r+0x14dc>
800096c4:	fa c8 f9 50 	sub	r8,sp,-1712
800096c8:	1a d8       	st.w	--sp,r8
800096ca:	fa c8 fa b8 	sub	r8,sp,-1352
800096ce:	0c 9b       	mov	r11,r6
800096d0:	1a d8       	st.w	--sp,r8
800096d2:	fa c8 fb b4 	sub	r8,sp,-1100
800096d6:	04 9a       	mov	r10,r2
800096d8:	1a d8       	st.w	--sp,r8
800096da:	08 9c       	mov	r12,r4
800096dc:	fa c8 f9 40 	sub	r8,sp,-1728
800096e0:	fa c9 ff b4 	sub	r9,sp,-76
800096e4:	fe b0 f4 08 	rcall	80007ef4 <get_arg>
800096e8:	2f dd       	sub	sp,-12
800096ea:	78 0b       	ld.w	r11,r12[0x0]
800096ec:	c2 48       	rjmp	80009734 <_vfprintf_r+0x1510>
800096ee:	ee ca ff ff 	sub	r10,r7,-1
800096f2:	10 37       	cp.w	r7,r8
800096f4:	c0 94       	brge	80009706 <_vfprintf_r+0x14e2>
800096f6:	fa c9 f9 44 	sub	r9,sp,-1724
800096fa:	f2 06 00 36 	add	r6,r9,r6<<0x3
800096fe:	14 97       	mov	r7,r10
80009700:	ec fb fd 88 	ld.w	r11,r6[-632]
80009704:	c1 88       	rjmp	80009734 <_vfprintf_r+0x1510>
80009706:	41 09       	lddsp	r9,sp[0x40]
80009708:	59 f8       	cp.w	r8,31
8000970a:	e0 89 00 11 	brgt	8000972c <_vfprintf_r+0x1508>
8000970e:	f2 cb ff fc 	sub	r11,r9,-4
80009712:	51 0b       	stdsp	sp[0x40],r11
80009714:	fa c6 f9 44 	sub	r6,sp,-1724
80009718:	72 0b       	ld.w	r11,r9[0x0]
8000971a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000971e:	f3 4b fd 88 	st.w	r9[-632],r11
80009722:	2f f8       	sub	r8,-1
80009724:	14 97       	mov	r7,r10
80009726:	fb 48 06 b4 	st.w	sp[1716],r8
8000972a:	c0 58       	rjmp	80009734 <_vfprintf_r+0x1510>
8000972c:	72 0b       	ld.w	r11,r9[0x0]
8000972e:	14 97       	mov	r7,r10
80009730:	2f c9       	sub	r9,-4
80009732:	51 09       	stdsp	sp[0x40],r9
80009734:	50 1b       	stdsp	sp[0x4],r11
80009736:	30 0e       	mov	lr,0
80009738:	50 0e       	stdsp	sp[0x0],lr
8000973a:	40 08       	lddsp	r8,sp[0x0]
8000973c:	40 1c       	lddsp	r12,sp[0x4]
8000973e:	18 48       	or	r8,r12
80009740:	5f 19       	srne	r9
80009742:	0a 98       	mov	r8,r5
80009744:	eb e9 00 09 	and	r9,r5,r9
80009748:	a1 b8       	sbr	r8,0x1
8000974a:	58 09       	cp.w	r9,0
8000974c:	c0 70       	breq	8000975a <_vfprintf_r+0x1536>
8000974e:	10 95       	mov	r5,r8
80009750:	fb 60 06 b9 	st.b	sp[1721],r0
80009754:	33 08       	mov	r8,48
80009756:	fb 68 06 b8 	st.b	sp[1720],r8
8000975a:	30 28       	mov	r8,2
8000975c:	30 09       	mov	r9,0
8000975e:	fb 69 06 bb 	st.b	sp[1723],r9
80009762:	0a 99       	mov	r9,r5
80009764:	a7 d9       	cbr	r9,0x7
80009766:	40 2b       	lddsp	r11,sp[0x8]
80009768:	40 16       	lddsp	r6,sp[0x4]
8000976a:	58 0b       	cp.w	r11,0
8000976c:	5f 1a       	srne	r10
8000976e:	f2 05 17 40 	movge	r5,r9
80009772:	fa c2 f9 78 	sub	r2,sp,-1672
80009776:	40 09       	lddsp	r9,sp[0x0]
80009778:	0c 49       	or	r9,r6
8000977a:	5f 19       	srne	r9
8000977c:	f5 e9 10 09 	or	r9,r10,r9
80009780:	c5 c0       	breq	80009838 <_vfprintf_r+0x1614>
80009782:	30 19       	mov	r9,1
80009784:	f2 08 18 00 	cp.b	r8,r9
80009788:	c0 60       	breq	80009794 <_vfprintf_r+0x1570>
8000978a:	30 29       	mov	r9,2
8000978c:	f2 08 18 00 	cp.b	r8,r9
80009790:	c0 41       	brne	80009798 <_vfprintf_r+0x1574>
80009792:	c3 c8       	rjmp	8000980a <_vfprintf_r+0x15e6>
80009794:	04 96       	mov	r6,r2
80009796:	c3 08       	rjmp	800097f6 <_vfprintf_r+0x15d2>
80009798:	04 96       	mov	r6,r2
8000979a:	fa e8 00 00 	ld.d	r8,sp[0]
8000979e:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
800097a2:	2d 0a       	sub	r10,-48
800097a4:	0c fa       	st.b	--r6,r10
800097a6:	f0 0b 16 03 	lsr	r11,r8,0x3
800097aa:	f2 0c 16 03 	lsr	r12,r9,0x3
800097ae:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800097b2:	18 99       	mov	r9,r12
800097b4:	16 98       	mov	r8,r11
800097b6:	58 08       	cp.w	r8,0
800097b8:	5c 29       	cpc	r9
800097ba:	cf 21       	brne	8000979e <_vfprintf_r+0x157a>
800097bc:	fa e9 00 00 	st.d	sp[0],r8
800097c0:	ed b5 00 00 	bld	r5,0x0
800097c4:	c4 51       	brne	8000984e <_vfprintf_r+0x162a>
800097c6:	33 09       	mov	r9,48
800097c8:	f2 0a 18 00 	cp.b	r10,r9
800097cc:	c4 10       	breq	8000984e <_vfprintf_r+0x162a>
800097ce:	0c f9       	st.b	--r6,r9
800097d0:	c3 f8       	rjmp	8000984e <_vfprintf_r+0x162a>
800097d2:	fa ea 00 00 	ld.d	r10,sp[0]
800097d6:	30 a8       	mov	r8,10
800097d8:	30 09       	mov	r9,0
800097da:	e0 a0 1a 19 	rcall	8000cc0c <__avr32_umod64>
800097de:	30 a8       	mov	r8,10
800097e0:	2d 0a       	sub	r10,-48
800097e2:	30 09       	mov	r9,0
800097e4:	ac 8a       	st.b	r6[0x0],r10
800097e6:	fa ea 00 00 	ld.d	r10,sp[0]
800097ea:	e0 a0 18 df 	rcall	8000c9a8 <__avr32_udiv64>
800097ee:	16 99       	mov	r9,r11
800097f0:	14 98       	mov	r8,r10
800097f2:	fa e9 00 00 	st.d	sp[0],r8
800097f6:	20 16       	sub	r6,1
800097f8:	fa ea 00 00 	ld.d	r10,sp[0]
800097fc:	58 9a       	cp.w	r10,9
800097fe:	5c 2b       	cpc	r11
80009800:	fe 9b ff e9 	brhi	800097d2 <_vfprintf_r+0x15ae>
80009804:	1b f8       	ld.ub	r8,sp[0x7]
80009806:	2d 08       	sub	r8,-48
80009808:	c2 08       	rjmp	80009848 <_vfprintf_r+0x1624>
8000980a:	04 96       	mov	r6,r2
8000980c:	fa e8 00 00 	ld.d	r8,sp[0]
80009810:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80009814:	40 de       	lddsp	lr,sp[0x34]
80009816:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000981a:	0c fa       	st.b	--r6,r10
8000981c:	f2 0b 16 04 	lsr	r11,r9,0x4
80009820:	f0 0a 16 04 	lsr	r10,r8,0x4
80009824:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80009828:	16 99       	mov	r9,r11
8000982a:	14 98       	mov	r8,r10
8000982c:	58 08       	cp.w	r8,0
8000982e:	5c 29       	cpc	r9
80009830:	cf 01       	brne	80009810 <_vfprintf_r+0x15ec>
80009832:	fa e9 00 00 	st.d	sp[0],r8
80009836:	c0 c8       	rjmp	8000984e <_vfprintf_r+0x162a>
80009838:	58 08       	cp.w	r8,0
8000983a:	c0 91       	brne	8000984c <_vfprintf_r+0x1628>
8000983c:	ed b5 00 00 	bld	r5,0x0
80009840:	c0 61       	brne	8000984c <_vfprintf_r+0x1628>
80009842:	fa c6 f9 79 	sub	r6,sp,-1671
80009846:	33 08       	mov	r8,48
80009848:	ac 88       	st.b	r6[0x0],r8
8000984a:	c0 28       	rjmp	8000984e <_vfprintf_r+0x162a>
8000984c:	04 96       	mov	r6,r2
8000984e:	0c 12       	sub	r2,r6
80009850:	c1 c8       	rjmp	80009888 <_vfprintf_r+0x1664>
80009852:	50 a7       	stdsp	sp[0x28],r7
80009854:	50 80       	stdsp	sp[0x20],r0
80009856:	40 93       	lddsp	r3,sp[0x24]
80009858:	0c 97       	mov	r7,r6
8000985a:	10 90       	mov	r0,r8
8000985c:	04 94       	mov	r4,r2
8000985e:	40 41       	lddsp	r1,sp[0x10]
80009860:	58 08       	cp.w	r8,0
80009862:	e0 80 04 4f 	breq	8000a100 <_vfprintf_r+0x1edc>
80009866:	fb 68 06 60 	st.b	sp[1632],r8
8000986a:	30 0c       	mov	r12,0
8000986c:	30 08       	mov	r8,0
8000986e:	30 12       	mov	r2,1
80009870:	fb 68 06 bb 	st.b	sp[1723],r8
80009874:	50 2c       	stdsp	sp[0x8],r12
80009876:	fa c6 f9 a0 	sub	r6,sp,-1632
8000987a:	c0 78       	rjmp	80009888 <_vfprintf_r+0x1664>
8000987c:	30 0b       	mov	r11,0
8000987e:	50 2b       	stdsp	sp[0x8],r11
80009880:	c0 48       	rjmp	80009888 <_vfprintf_r+0x1664>
80009882:	40 22       	lddsp	r2,sp[0x8]
80009884:	30 0a       	mov	r10,0
80009886:	50 2a       	stdsp	sp[0x8],r10
80009888:	40 29       	lddsp	r9,sp[0x8]
8000988a:	e4 09 0c 49 	max	r9,r2,r9
8000988e:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009892:	50 39       	stdsp	sp[0xc],r9
80009894:	0a 9e       	mov	lr,r5
80009896:	30 09       	mov	r9,0
80009898:	e2 1e 00 02 	andl	lr,0x2,COH
8000989c:	f2 08 18 00 	cp.b	r8,r9
800098a0:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800098a4:	f7 b8 01 ff 	subne	r8,-1
800098a8:	fb f8 1a 03 	st.wne	sp[0xc],r8
800098ac:	0a 9b       	mov	r11,r5
800098ae:	58 0e       	cp.w	lr,0
800098b0:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800098b4:	f7 bc 01 fe 	subne	r12,-2
800098b8:	fb fc 1a 03 	st.wne	sp[0xc],r12
800098bc:	e2 1b 00 84 	andl	r11,0x84,COH
800098c0:	50 fe       	stdsp	sp[0x3c],lr
800098c2:	50 9b       	stdsp	sp[0x24],r11
800098c4:	c4 71       	brne	80009952 <_vfprintf_r+0x172e>
800098c6:	40 8a       	lddsp	r10,sp[0x20]
800098c8:	40 39       	lddsp	r9,sp[0xc]
800098ca:	12 1a       	sub	r10,r9
800098cc:	50 4a       	stdsp	sp[0x10],r10
800098ce:	58 0a       	cp.w	r10,0
800098d0:	e0 89 00 20 	brgt	80009910 <_vfprintf_r+0x16ec>
800098d4:	c3 f8       	rjmp	80009952 <_vfprintf_r+0x172e>
800098d6:	2f 09       	sub	r9,-16
800098d8:	2f f8       	sub	r8,-1
800098da:	fe ce b6 ca 	sub	lr,pc,-18742
800098de:	31 0c       	mov	r12,16
800098e0:	fb 49 06 90 	st.w	sp[1680],r9
800098e4:	87 0e       	st.w	r3[0x0],lr
800098e6:	87 1c       	st.w	r3[0x4],r12
800098e8:	fb 48 06 8c 	st.w	sp[1676],r8
800098ec:	58 78       	cp.w	r8,7
800098ee:	e0 89 00 04 	brgt	800098f6 <_vfprintf_r+0x16d2>
800098f2:	2f 83       	sub	r3,-8
800098f4:	c0 b8       	rjmp	8000990a <_vfprintf_r+0x16e6>
800098f6:	fa ca f9 78 	sub	r10,sp,-1672
800098fa:	02 9b       	mov	r11,r1
800098fc:	08 9c       	mov	r12,r4
800098fe:	fe b0 f4 85 	rcall	80008208 <__sprint_r>
80009902:	e0 81 04 10 	brne	8000a122 <_vfprintf_r+0x1efe>
80009906:	fa c3 f9 e0 	sub	r3,sp,-1568
8000990a:	40 4b       	lddsp	r11,sp[0x10]
8000990c:	21 0b       	sub	r11,16
8000990e:	50 4b       	stdsp	sp[0x10],r11
80009910:	fa f9 06 90 	ld.w	r9,sp[1680]
80009914:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009918:	fe ca b7 08 	sub	r10,pc,-18680
8000991c:	40 4e       	lddsp	lr,sp[0x10]
8000991e:	59 0e       	cp.w	lr,16
80009920:	fe 99 ff db 	brgt	800098d6 <_vfprintf_r+0x16b2>
80009924:	1c 09       	add	r9,lr
80009926:	2f f8       	sub	r8,-1
80009928:	87 0a       	st.w	r3[0x0],r10
8000992a:	fb 49 06 90 	st.w	sp[1680],r9
8000992e:	87 1e       	st.w	r3[0x4],lr
80009930:	fb 48 06 8c 	st.w	sp[1676],r8
80009934:	58 78       	cp.w	r8,7
80009936:	e0 89 00 04 	brgt	8000993e <_vfprintf_r+0x171a>
8000993a:	2f 83       	sub	r3,-8
8000993c:	c0 b8       	rjmp	80009952 <_vfprintf_r+0x172e>
8000993e:	fa ca f9 78 	sub	r10,sp,-1672
80009942:	02 9b       	mov	r11,r1
80009944:	08 9c       	mov	r12,r4
80009946:	fe b0 f4 61 	rcall	80008208 <__sprint_r>
8000994a:	e0 81 03 ec 	brne	8000a122 <_vfprintf_r+0x1efe>
8000994e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009952:	30 09       	mov	r9,0
80009954:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009958:	f2 08 18 00 	cp.b	r8,r9
8000995c:	c1 f0       	breq	8000999a <_vfprintf_r+0x1776>
8000995e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009962:	fa c9 f9 45 	sub	r9,sp,-1723
80009966:	2f f8       	sub	r8,-1
80009968:	87 09       	st.w	r3[0x0],r9
8000996a:	fb 48 06 90 	st.w	sp[1680],r8
8000996e:	30 19       	mov	r9,1
80009970:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009974:	87 19       	st.w	r3[0x4],r9
80009976:	2f f8       	sub	r8,-1
80009978:	fb 48 06 8c 	st.w	sp[1676],r8
8000997c:	58 78       	cp.w	r8,7
8000997e:	e0 89 00 04 	brgt	80009986 <_vfprintf_r+0x1762>
80009982:	2f 83       	sub	r3,-8
80009984:	c0 b8       	rjmp	8000999a <_vfprintf_r+0x1776>
80009986:	fa ca f9 78 	sub	r10,sp,-1672
8000998a:	02 9b       	mov	r11,r1
8000998c:	08 9c       	mov	r12,r4
8000998e:	fe b0 f4 3d 	rcall	80008208 <__sprint_r>
80009992:	e0 81 03 c8 	brne	8000a122 <_vfprintf_r+0x1efe>
80009996:	fa c3 f9 e0 	sub	r3,sp,-1568
8000999a:	40 fc       	lddsp	r12,sp[0x3c]
8000999c:	58 0c       	cp.w	r12,0
8000999e:	c1 f0       	breq	800099dc <_vfprintf_r+0x17b8>
800099a0:	fa f8 06 90 	ld.w	r8,sp[1680]
800099a4:	fa c9 f9 48 	sub	r9,sp,-1720
800099a8:	2f e8       	sub	r8,-2
800099aa:	87 09       	st.w	r3[0x0],r9
800099ac:	fb 48 06 90 	st.w	sp[1680],r8
800099b0:	30 29       	mov	r9,2
800099b2:	fa f8 06 8c 	ld.w	r8,sp[1676]
800099b6:	87 19       	st.w	r3[0x4],r9
800099b8:	2f f8       	sub	r8,-1
800099ba:	fb 48 06 8c 	st.w	sp[1676],r8
800099be:	58 78       	cp.w	r8,7
800099c0:	e0 89 00 04 	brgt	800099c8 <_vfprintf_r+0x17a4>
800099c4:	2f 83       	sub	r3,-8
800099c6:	c0 b8       	rjmp	800099dc <_vfprintf_r+0x17b8>
800099c8:	fa ca f9 78 	sub	r10,sp,-1672
800099cc:	02 9b       	mov	r11,r1
800099ce:	08 9c       	mov	r12,r4
800099d0:	fe b0 f4 1c 	rcall	80008208 <__sprint_r>
800099d4:	e0 81 03 a7 	brne	8000a122 <_vfprintf_r+0x1efe>
800099d8:	fa c3 f9 e0 	sub	r3,sp,-1568
800099dc:	40 9b       	lddsp	r11,sp[0x24]
800099de:	e0 4b 00 80 	cp.w	r11,128
800099e2:	c4 71       	brne	80009a70 <_vfprintf_r+0x184c>
800099e4:	40 8a       	lddsp	r10,sp[0x20]
800099e6:	40 39       	lddsp	r9,sp[0xc]
800099e8:	12 1a       	sub	r10,r9
800099ea:	50 4a       	stdsp	sp[0x10],r10
800099ec:	58 0a       	cp.w	r10,0
800099ee:	e0 89 00 20 	brgt	80009a2e <_vfprintf_r+0x180a>
800099f2:	c3 f8       	rjmp	80009a70 <_vfprintf_r+0x184c>
800099f4:	2f 09       	sub	r9,-16
800099f6:	2f f8       	sub	r8,-1
800099f8:	fe ce b7 d8 	sub	lr,pc,-18472
800099fc:	31 0c       	mov	r12,16
800099fe:	fb 49 06 90 	st.w	sp[1680],r9
80009a02:	87 0e       	st.w	r3[0x0],lr
80009a04:	87 1c       	st.w	r3[0x4],r12
80009a06:	fb 48 06 8c 	st.w	sp[1676],r8
80009a0a:	58 78       	cp.w	r8,7
80009a0c:	e0 89 00 04 	brgt	80009a14 <_vfprintf_r+0x17f0>
80009a10:	2f 83       	sub	r3,-8
80009a12:	c0 b8       	rjmp	80009a28 <_vfprintf_r+0x1804>
80009a14:	fa ca f9 78 	sub	r10,sp,-1672
80009a18:	02 9b       	mov	r11,r1
80009a1a:	08 9c       	mov	r12,r4
80009a1c:	fe b0 f3 f6 	rcall	80008208 <__sprint_r>
80009a20:	e0 81 03 81 	brne	8000a122 <_vfprintf_r+0x1efe>
80009a24:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a28:	40 4b       	lddsp	r11,sp[0x10]
80009a2a:	21 0b       	sub	r11,16
80009a2c:	50 4b       	stdsp	sp[0x10],r11
80009a2e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009a32:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009a36:	fe ca b8 16 	sub	r10,pc,-18410
80009a3a:	40 4e       	lddsp	lr,sp[0x10]
80009a3c:	59 0e       	cp.w	lr,16
80009a3e:	fe 99 ff db 	brgt	800099f4 <_vfprintf_r+0x17d0>
80009a42:	1c 09       	add	r9,lr
80009a44:	2f f8       	sub	r8,-1
80009a46:	87 0a       	st.w	r3[0x0],r10
80009a48:	fb 49 06 90 	st.w	sp[1680],r9
80009a4c:	87 1e       	st.w	r3[0x4],lr
80009a4e:	fb 48 06 8c 	st.w	sp[1676],r8
80009a52:	58 78       	cp.w	r8,7
80009a54:	e0 89 00 04 	brgt	80009a5c <_vfprintf_r+0x1838>
80009a58:	2f 83       	sub	r3,-8
80009a5a:	c0 b8       	rjmp	80009a70 <_vfprintf_r+0x184c>
80009a5c:	fa ca f9 78 	sub	r10,sp,-1672
80009a60:	02 9b       	mov	r11,r1
80009a62:	08 9c       	mov	r12,r4
80009a64:	fe b0 f3 d2 	rcall	80008208 <__sprint_r>
80009a68:	e0 81 03 5d 	brne	8000a122 <_vfprintf_r+0x1efe>
80009a6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a70:	40 2c       	lddsp	r12,sp[0x8]
80009a72:	04 1c       	sub	r12,r2
80009a74:	50 2c       	stdsp	sp[0x8],r12
80009a76:	58 0c       	cp.w	r12,0
80009a78:	e0 89 00 20 	brgt	80009ab8 <_vfprintf_r+0x1894>
80009a7c:	c3 f8       	rjmp	80009afa <_vfprintf_r+0x18d6>
80009a7e:	2f 09       	sub	r9,-16
80009a80:	2f f8       	sub	r8,-1
80009a82:	fe cb b8 62 	sub	r11,pc,-18334
80009a86:	31 0a       	mov	r10,16
80009a88:	fb 49 06 90 	st.w	sp[1680],r9
80009a8c:	87 0b       	st.w	r3[0x0],r11
80009a8e:	87 1a       	st.w	r3[0x4],r10
80009a90:	fb 48 06 8c 	st.w	sp[1676],r8
80009a94:	58 78       	cp.w	r8,7
80009a96:	e0 89 00 04 	brgt	80009a9e <_vfprintf_r+0x187a>
80009a9a:	2f 83       	sub	r3,-8
80009a9c:	c0 b8       	rjmp	80009ab2 <_vfprintf_r+0x188e>
80009a9e:	fa ca f9 78 	sub	r10,sp,-1672
80009aa2:	02 9b       	mov	r11,r1
80009aa4:	08 9c       	mov	r12,r4
80009aa6:	fe b0 f3 b1 	rcall	80008208 <__sprint_r>
80009aaa:	e0 81 03 3c 	brne	8000a122 <_vfprintf_r+0x1efe>
80009aae:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ab2:	40 29       	lddsp	r9,sp[0x8]
80009ab4:	21 09       	sub	r9,16
80009ab6:	50 29       	stdsp	sp[0x8],r9
80009ab8:	fa f9 06 90 	ld.w	r9,sp[1680]
80009abc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ac0:	fe ca b8 a0 	sub	r10,pc,-18272
80009ac4:	40 2e       	lddsp	lr,sp[0x8]
80009ac6:	59 0e       	cp.w	lr,16
80009ac8:	fe 99 ff db 	brgt	80009a7e <_vfprintf_r+0x185a>
80009acc:	1c 09       	add	r9,lr
80009ace:	2f f8       	sub	r8,-1
80009ad0:	87 0a       	st.w	r3[0x0],r10
80009ad2:	fb 49 06 90 	st.w	sp[1680],r9
80009ad6:	87 1e       	st.w	r3[0x4],lr
80009ad8:	fb 48 06 8c 	st.w	sp[1676],r8
80009adc:	58 78       	cp.w	r8,7
80009ade:	e0 89 00 04 	brgt	80009ae6 <_vfprintf_r+0x18c2>
80009ae2:	2f 83       	sub	r3,-8
80009ae4:	c0 b8       	rjmp	80009afa <_vfprintf_r+0x18d6>
80009ae6:	fa ca f9 78 	sub	r10,sp,-1672
80009aea:	02 9b       	mov	r11,r1
80009aec:	08 9c       	mov	r12,r4
80009aee:	fe b0 f3 8d 	rcall	80008208 <__sprint_r>
80009af2:	e0 81 03 18 	brne	8000a122 <_vfprintf_r+0x1efe>
80009af6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009afa:	ed b5 00 08 	bld	r5,0x8
80009afe:	c0 b0       	breq	80009b14 <_vfprintf_r+0x18f0>
80009b00:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b04:	87 12       	st.w	r3[0x4],r2
80009b06:	87 06       	st.w	r3[0x0],r6
80009b08:	f0 02 00 02 	add	r2,r8,r2
80009b0c:	fb 42 06 90 	st.w	sp[1680],r2
80009b10:	e0 8f 01 d4 	bral	80009eb8 <_vfprintf_r+0x1c94>
80009b14:	e0 40 00 65 	cp.w	r0,101
80009b18:	e0 8a 01 d6 	brle	80009ec4 <_vfprintf_r+0x1ca0>
80009b1c:	30 08       	mov	r8,0
80009b1e:	30 09       	mov	r9,0
80009b20:	40 5b       	lddsp	r11,sp[0x14]
80009b22:	40 7a       	lddsp	r10,sp[0x1c]
80009b24:	e0 a0 15 3b 	rcall	8000c59a <__avr32_f64_cmp_eq>
80009b28:	c7 90       	breq	80009c1a <_vfprintf_r+0x19f6>
80009b2a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b2e:	fe c9 b9 22 	sub	r9,pc,-18142
80009b32:	2f f8       	sub	r8,-1
80009b34:	87 09       	st.w	r3[0x0],r9
80009b36:	fb 48 06 90 	st.w	sp[1680],r8
80009b3a:	30 19       	mov	r9,1
80009b3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b40:	87 19       	st.w	r3[0x4],r9
80009b42:	2f f8       	sub	r8,-1
80009b44:	fb 48 06 8c 	st.w	sp[1676],r8
80009b48:	58 78       	cp.w	r8,7
80009b4a:	e0 89 00 05 	brgt	80009b54 <_vfprintf_r+0x1930>
80009b4e:	2f 83       	sub	r3,-8
80009b50:	c0 c8       	rjmp	80009b68 <_vfprintf_r+0x1944>
80009b52:	d7 03       	nop
80009b54:	fa ca f9 78 	sub	r10,sp,-1672
80009b58:	02 9b       	mov	r11,r1
80009b5a:	08 9c       	mov	r12,r4
80009b5c:	fe b0 f3 56 	rcall	80008208 <__sprint_r>
80009b60:	e0 81 02 e1 	brne	8000a122 <_vfprintf_r+0x1efe>
80009b64:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b68:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009b6c:	40 6c       	lddsp	r12,sp[0x18]
80009b6e:	18 38       	cp.w	r8,r12
80009b70:	c0 55       	brlt	80009b7a <_vfprintf_r+0x1956>
80009b72:	ed b5 00 00 	bld	r5,0x0
80009b76:	e0 81 02 6b 	brne	8000a04c <_vfprintf_r+0x1e28>
80009b7a:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b7e:	2f f8       	sub	r8,-1
80009b80:	40 cb       	lddsp	r11,sp[0x30]
80009b82:	fb 48 06 90 	st.w	sp[1680],r8
80009b86:	30 19       	mov	r9,1
80009b88:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b8c:	87 0b       	st.w	r3[0x0],r11
80009b8e:	2f f8       	sub	r8,-1
80009b90:	87 19       	st.w	r3[0x4],r9
80009b92:	fb 48 06 8c 	st.w	sp[1676],r8
80009b96:	58 78       	cp.w	r8,7
80009b98:	e0 89 00 04 	brgt	80009ba0 <_vfprintf_r+0x197c>
80009b9c:	2f 83       	sub	r3,-8
80009b9e:	c0 b8       	rjmp	80009bb4 <_vfprintf_r+0x1990>
80009ba0:	fa ca f9 78 	sub	r10,sp,-1672
80009ba4:	02 9b       	mov	r11,r1
80009ba6:	08 9c       	mov	r12,r4
80009ba8:	fe b0 f3 30 	rcall	80008208 <__sprint_r>
80009bac:	e0 81 02 bb 	brne	8000a122 <_vfprintf_r+0x1efe>
80009bb0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bb4:	40 66       	lddsp	r6,sp[0x18]
80009bb6:	20 16       	sub	r6,1
80009bb8:	58 06       	cp.w	r6,0
80009bba:	e0 89 00 1d 	brgt	80009bf4 <_vfprintf_r+0x19d0>
80009bbe:	e0 8f 02 47 	bral	8000a04c <_vfprintf_r+0x1e28>
80009bc2:	2f 09       	sub	r9,-16
80009bc4:	2f f8       	sub	r8,-1
80009bc6:	fb 49 06 90 	st.w	sp[1680],r9
80009bca:	87 02       	st.w	r3[0x0],r2
80009bcc:	87 10       	st.w	r3[0x4],r0
80009bce:	fb 48 06 8c 	st.w	sp[1676],r8
80009bd2:	58 78       	cp.w	r8,7
80009bd4:	e0 89 00 04 	brgt	80009bdc <_vfprintf_r+0x19b8>
80009bd8:	2f 83       	sub	r3,-8
80009bda:	c0 b8       	rjmp	80009bf0 <_vfprintf_r+0x19cc>
80009bdc:	fa ca f9 78 	sub	r10,sp,-1672
80009be0:	02 9b       	mov	r11,r1
80009be2:	08 9c       	mov	r12,r4
80009be4:	fe b0 f3 12 	rcall	80008208 <__sprint_r>
80009be8:	e0 81 02 9d 	brne	8000a122 <_vfprintf_r+0x1efe>
80009bec:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bf0:	21 06       	sub	r6,16
80009bf2:	c0 48       	rjmp	80009bfa <_vfprintf_r+0x19d6>
80009bf4:	fe c2 b9 d4 	sub	r2,pc,-17964
80009bf8:	31 00       	mov	r0,16
80009bfa:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bfe:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c02:	fe ca b9 e2 	sub	r10,pc,-17950
80009c06:	59 06       	cp.w	r6,16
80009c08:	fe 99 ff dd 	brgt	80009bc2 <_vfprintf_r+0x199e>
80009c0c:	0c 09       	add	r9,r6
80009c0e:	87 0a       	st.w	r3[0x0],r10
80009c10:	fb 49 06 90 	st.w	sp[1680],r9
80009c14:	2f f8       	sub	r8,-1
80009c16:	87 16       	st.w	r3[0x4],r6
80009c18:	c5 39       	rjmp	80009ebe <_vfprintf_r+0x1c9a>
80009c1a:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009c1e:	58 0a       	cp.w	r10,0
80009c20:	e0 89 00 92 	brgt	80009d44 <_vfprintf_r+0x1b20>
80009c24:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c28:	fe c9 ba 1c 	sub	r9,pc,-17892
80009c2c:	2f f8       	sub	r8,-1
80009c2e:	87 09       	st.w	r3[0x0],r9
80009c30:	fb 48 06 90 	st.w	sp[1680],r8
80009c34:	30 19       	mov	r9,1
80009c36:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c3a:	87 19       	st.w	r3[0x4],r9
80009c3c:	2f f8       	sub	r8,-1
80009c3e:	fb 48 06 8c 	st.w	sp[1676],r8
80009c42:	58 78       	cp.w	r8,7
80009c44:	e0 89 00 04 	brgt	80009c4c <_vfprintf_r+0x1a28>
80009c48:	2f 83       	sub	r3,-8
80009c4a:	c0 b8       	rjmp	80009c60 <_vfprintf_r+0x1a3c>
80009c4c:	fa ca f9 78 	sub	r10,sp,-1672
80009c50:	02 9b       	mov	r11,r1
80009c52:	08 9c       	mov	r12,r4
80009c54:	fe b0 f2 da 	rcall	80008208 <__sprint_r>
80009c58:	e0 81 02 65 	brne	8000a122 <_vfprintf_r+0x1efe>
80009c5c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c60:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009c64:	58 08       	cp.w	r8,0
80009c66:	c0 81       	brne	80009c76 <_vfprintf_r+0x1a52>
80009c68:	40 6a       	lddsp	r10,sp[0x18]
80009c6a:	58 0a       	cp.w	r10,0
80009c6c:	c0 51       	brne	80009c76 <_vfprintf_r+0x1a52>
80009c6e:	ed b5 00 00 	bld	r5,0x0
80009c72:	e0 81 01 ed 	brne	8000a04c <_vfprintf_r+0x1e28>
80009c76:	40 c9       	lddsp	r9,sp[0x30]
80009c78:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c7c:	2f f8       	sub	r8,-1
80009c7e:	87 09       	st.w	r3[0x0],r9
80009c80:	fb 48 06 90 	st.w	sp[1680],r8
80009c84:	30 19       	mov	r9,1
80009c86:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c8a:	87 19       	st.w	r3[0x4],r9
80009c8c:	2f f8       	sub	r8,-1
80009c8e:	fb 48 06 8c 	st.w	sp[1676],r8
80009c92:	58 78       	cp.w	r8,7
80009c94:	e0 89 00 04 	brgt	80009c9c <_vfprintf_r+0x1a78>
80009c98:	2f 83       	sub	r3,-8
80009c9a:	c0 b8       	rjmp	80009cb0 <_vfprintf_r+0x1a8c>
80009c9c:	fa ca f9 78 	sub	r10,sp,-1672
80009ca0:	02 9b       	mov	r11,r1
80009ca2:	08 9c       	mov	r12,r4
80009ca4:	fe b0 f2 b2 	rcall	80008208 <__sprint_r>
80009ca8:	e0 81 02 3d 	brne	8000a122 <_vfprintf_r+0x1efe>
80009cac:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cb0:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009cb4:	5c 32       	neg	r2
80009cb6:	58 02       	cp.w	r2,0
80009cb8:	e0 89 00 1d 	brgt	80009cf2 <_vfprintf_r+0x1ace>
80009cbc:	c3 d8       	rjmp	80009d36 <_vfprintf_r+0x1b12>
80009cbe:	2f 09       	sub	r9,-16
80009cc0:	2f f8       	sub	r8,-1
80009cc2:	31 0e       	mov	lr,16
80009cc4:	fb 49 06 90 	st.w	sp[1680],r9
80009cc8:	87 00       	st.w	r3[0x0],r0
80009cca:	87 1e       	st.w	r3[0x4],lr
80009ccc:	fb 48 06 8c 	st.w	sp[1676],r8
80009cd0:	58 78       	cp.w	r8,7
80009cd2:	e0 89 00 04 	brgt	80009cda <_vfprintf_r+0x1ab6>
80009cd6:	2f 83       	sub	r3,-8
80009cd8:	c0 b8       	rjmp	80009cee <_vfprintf_r+0x1aca>
80009cda:	fa ca f9 78 	sub	r10,sp,-1672
80009cde:	02 9b       	mov	r11,r1
80009ce0:	08 9c       	mov	r12,r4
80009ce2:	fe b0 f2 93 	rcall	80008208 <__sprint_r>
80009ce6:	e0 81 02 1e 	brne	8000a122 <_vfprintf_r+0x1efe>
80009cea:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cee:	21 02       	sub	r2,16
80009cf0:	c0 38       	rjmp	80009cf6 <_vfprintf_r+0x1ad2>
80009cf2:	fe c0 ba d2 	sub	r0,pc,-17710
80009cf6:	fa f9 06 90 	ld.w	r9,sp[1680]
80009cfa:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cfe:	fe ca ba de 	sub	r10,pc,-17698
80009d02:	59 02       	cp.w	r2,16
80009d04:	fe 99 ff dd 	brgt	80009cbe <_vfprintf_r+0x1a9a>
80009d08:	04 09       	add	r9,r2
80009d0a:	2f f8       	sub	r8,-1
80009d0c:	87 0a       	st.w	r3[0x0],r10
80009d0e:	fb 49 06 90 	st.w	sp[1680],r9
80009d12:	87 12       	st.w	r3[0x4],r2
80009d14:	fb 48 06 8c 	st.w	sp[1676],r8
80009d18:	58 78       	cp.w	r8,7
80009d1a:	e0 89 00 04 	brgt	80009d22 <_vfprintf_r+0x1afe>
80009d1e:	2f 83       	sub	r3,-8
80009d20:	c0 b8       	rjmp	80009d36 <_vfprintf_r+0x1b12>
80009d22:	fa ca f9 78 	sub	r10,sp,-1672
80009d26:	02 9b       	mov	r11,r1
80009d28:	08 9c       	mov	r12,r4
80009d2a:	fe b0 f2 6f 	rcall	80008208 <__sprint_r>
80009d2e:	e0 81 01 fa 	brne	8000a122 <_vfprintf_r+0x1efe>
80009d32:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d36:	40 6c       	lddsp	r12,sp[0x18]
80009d38:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d3c:	87 06       	st.w	r3[0x0],r6
80009d3e:	87 1c       	st.w	r3[0x4],r12
80009d40:	18 08       	add	r8,r12
80009d42:	cb 98       	rjmp	80009eb4 <_vfprintf_r+0x1c90>
80009d44:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d48:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d4c:	40 6b       	lddsp	r11,sp[0x18]
80009d4e:	16 3a       	cp.w	r10,r11
80009d50:	c6 f5       	brlt	80009e2e <_vfprintf_r+0x1c0a>
80009d52:	16 09       	add	r9,r11
80009d54:	2f f8       	sub	r8,-1
80009d56:	87 06       	st.w	r3[0x0],r6
80009d58:	fb 49 06 90 	st.w	sp[1680],r9
80009d5c:	87 1b       	st.w	r3[0x4],r11
80009d5e:	fb 48 06 8c 	st.w	sp[1676],r8
80009d62:	58 78       	cp.w	r8,7
80009d64:	e0 89 00 04 	brgt	80009d6c <_vfprintf_r+0x1b48>
80009d68:	2f 83       	sub	r3,-8
80009d6a:	c0 b8       	rjmp	80009d80 <_vfprintf_r+0x1b5c>
80009d6c:	fa ca f9 78 	sub	r10,sp,-1672
80009d70:	02 9b       	mov	r11,r1
80009d72:	08 9c       	mov	r12,r4
80009d74:	fe b0 f2 4a 	rcall	80008208 <__sprint_r>
80009d78:	e0 81 01 d5 	brne	8000a122 <_vfprintf_r+0x1efe>
80009d7c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d80:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009d84:	40 6a       	lddsp	r10,sp[0x18]
80009d86:	14 16       	sub	r6,r10
80009d88:	58 06       	cp.w	r6,0
80009d8a:	e0 89 00 1c 	brgt	80009dc2 <_vfprintf_r+0x1b9e>
80009d8e:	c3 d8       	rjmp	80009e08 <_vfprintf_r+0x1be4>
80009d90:	2f 09       	sub	r9,-16
80009d92:	2f f8       	sub	r8,-1
80009d94:	fb 49 06 90 	st.w	sp[1680],r9
80009d98:	87 02       	st.w	r3[0x0],r2
80009d9a:	87 10       	st.w	r3[0x4],r0
80009d9c:	fb 48 06 8c 	st.w	sp[1676],r8
80009da0:	58 78       	cp.w	r8,7
80009da2:	e0 89 00 04 	brgt	80009daa <_vfprintf_r+0x1b86>
80009da6:	2f 83       	sub	r3,-8
80009da8:	c0 b8       	rjmp	80009dbe <_vfprintf_r+0x1b9a>
80009daa:	fa ca f9 78 	sub	r10,sp,-1672
80009dae:	02 9b       	mov	r11,r1
80009db0:	08 9c       	mov	r12,r4
80009db2:	fe b0 f2 2b 	rcall	80008208 <__sprint_r>
80009db6:	e0 81 01 b6 	brne	8000a122 <_vfprintf_r+0x1efe>
80009dba:	fa c3 f9 e0 	sub	r3,sp,-1568
80009dbe:	21 06       	sub	r6,16
80009dc0:	c0 48       	rjmp	80009dc8 <_vfprintf_r+0x1ba4>
80009dc2:	fe c2 bb a2 	sub	r2,pc,-17502
80009dc6:	31 00       	mov	r0,16
80009dc8:	fa f9 06 90 	ld.w	r9,sp[1680]
80009dcc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dd0:	fe ca bb b0 	sub	r10,pc,-17488
80009dd4:	59 06       	cp.w	r6,16
80009dd6:	fe 99 ff dd 	brgt	80009d90 <_vfprintf_r+0x1b6c>
80009dda:	0c 09       	add	r9,r6
80009ddc:	2f f8       	sub	r8,-1
80009dde:	87 0a       	st.w	r3[0x0],r10
80009de0:	fb 49 06 90 	st.w	sp[1680],r9
80009de4:	87 16       	st.w	r3[0x4],r6
80009de6:	fb 48 06 8c 	st.w	sp[1676],r8
80009dea:	58 78       	cp.w	r8,7
80009dec:	e0 89 00 04 	brgt	80009df4 <_vfprintf_r+0x1bd0>
80009df0:	2f 83       	sub	r3,-8
80009df2:	c0 b8       	rjmp	80009e08 <_vfprintf_r+0x1be4>
80009df4:	fa ca f9 78 	sub	r10,sp,-1672
80009df8:	02 9b       	mov	r11,r1
80009dfa:	08 9c       	mov	r12,r4
80009dfc:	fe b0 f2 06 	rcall	80008208 <__sprint_r>
80009e00:	e0 81 01 91 	brne	8000a122 <_vfprintf_r+0x1efe>
80009e04:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e08:	ed b5 00 00 	bld	r5,0x0
80009e0c:	e0 81 01 20 	brne	8000a04c <_vfprintf_r+0x1e28>
80009e10:	40 c9       	lddsp	r9,sp[0x30]
80009e12:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e16:	2f f8       	sub	r8,-1
80009e18:	87 09       	st.w	r3[0x0],r9
80009e1a:	fb 48 06 90 	st.w	sp[1680],r8
80009e1e:	30 19       	mov	r9,1
80009e20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e24:	87 19       	st.w	r3[0x4],r9
80009e26:	2f f8       	sub	r8,-1
80009e28:	fb 48 06 8c 	st.w	sp[1676],r8
80009e2c:	c0 29       	rjmp	8000a030 <_vfprintf_r+0x1e0c>
80009e2e:	14 09       	add	r9,r10
80009e30:	2f f8       	sub	r8,-1
80009e32:	fb 49 06 90 	st.w	sp[1680],r9
80009e36:	87 06       	st.w	r3[0x0],r6
80009e38:	87 1a       	st.w	r3[0x4],r10
80009e3a:	fb 48 06 8c 	st.w	sp[1676],r8
80009e3e:	58 78       	cp.w	r8,7
80009e40:	e0 89 00 04 	brgt	80009e48 <_vfprintf_r+0x1c24>
80009e44:	2f 83       	sub	r3,-8
80009e46:	c0 b8       	rjmp	80009e5c <_vfprintf_r+0x1c38>
80009e48:	fa ca f9 78 	sub	r10,sp,-1672
80009e4c:	02 9b       	mov	r11,r1
80009e4e:	08 9c       	mov	r12,r4
80009e50:	fe b0 f1 dc 	rcall	80008208 <__sprint_r>
80009e54:	e0 81 01 67 	brne	8000a122 <_vfprintf_r+0x1efe>
80009e58:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e5c:	40 c8       	lddsp	r8,sp[0x30]
80009e5e:	87 08       	st.w	r3[0x0],r8
80009e60:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e64:	2f f8       	sub	r8,-1
80009e66:	30 19       	mov	r9,1
80009e68:	fb 48 06 90 	st.w	sp[1680],r8
80009e6c:	87 19       	st.w	r3[0x4],r9
80009e6e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e72:	2f f8       	sub	r8,-1
80009e74:	fb 48 06 8c 	st.w	sp[1676],r8
80009e78:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009e7c:	58 78       	cp.w	r8,7
80009e7e:	e0 89 00 04 	brgt	80009e86 <_vfprintf_r+0x1c62>
80009e82:	2f 83       	sub	r3,-8
80009e84:	c0 b8       	rjmp	80009e9a <_vfprintf_r+0x1c76>
80009e86:	fa ca f9 78 	sub	r10,sp,-1672
80009e8a:	02 9b       	mov	r11,r1
80009e8c:	08 9c       	mov	r12,r4
80009e8e:	fe b0 f1 bd 	rcall	80008208 <__sprint_r>
80009e92:	e0 81 01 48 	brne	8000a122 <_vfprintf_r+0x1efe>
80009e96:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e9a:	04 06       	add	r6,r2
80009e9c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009ea0:	87 06       	st.w	r3[0x0],r6
80009ea2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009ea6:	40 66       	lddsp	r6,sp[0x18]
80009ea8:	40 6e       	lddsp	lr,sp[0x18]
80009eaa:	10 16       	sub	r6,r8
80009eac:	f2 08 01 08 	sub	r8,r9,r8
80009eb0:	87 16       	st.w	r3[0x4],r6
80009eb2:	1c 08       	add	r8,lr
80009eb4:	fb 48 06 90 	st.w	sp[1680],r8
80009eb8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ebc:	2f f8       	sub	r8,-1
80009ebe:	fb 48 06 8c 	st.w	sp[1676],r8
80009ec2:	cb 78       	rjmp	8000a030 <_vfprintf_r+0x1e0c>
80009ec4:	40 6c       	lddsp	r12,sp[0x18]
80009ec6:	58 1c       	cp.w	r12,1
80009ec8:	e0 89 00 06 	brgt	80009ed4 <_vfprintf_r+0x1cb0>
80009ecc:	ed b5 00 00 	bld	r5,0x0
80009ed0:	e0 81 00 85 	brne	80009fda <_vfprintf_r+0x1db6>
80009ed4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ed8:	2f f8       	sub	r8,-1
80009eda:	30 19       	mov	r9,1
80009edc:	fb 48 06 90 	st.w	sp[1680],r8
80009ee0:	87 06       	st.w	r3[0x0],r6
80009ee2:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ee6:	87 19       	st.w	r3[0x4],r9
80009ee8:	2f f8       	sub	r8,-1
80009eea:	fb 48 06 8c 	st.w	sp[1676],r8
80009eee:	58 78       	cp.w	r8,7
80009ef0:	e0 89 00 04 	brgt	80009ef8 <_vfprintf_r+0x1cd4>
80009ef4:	2f 83       	sub	r3,-8
80009ef6:	c0 b8       	rjmp	80009f0c <_vfprintf_r+0x1ce8>
80009ef8:	fa ca f9 78 	sub	r10,sp,-1672
80009efc:	02 9b       	mov	r11,r1
80009efe:	08 9c       	mov	r12,r4
80009f00:	fe b0 f1 84 	rcall	80008208 <__sprint_r>
80009f04:	e0 81 01 0f 	brne	8000a122 <_vfprintf_r+0x1efe>
80009f08:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f0c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009f10:	2f f8       	sub	r8,-1
80009f12:	40 cb       	lddsp	r11,sp[0x30]
80009f14:	fb 48 06 90 	st.w	sp[1680],r8
80009f18:	30 19       	mov	r9,1
80009f1a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f1e:	87 0b       	st.w	r3[0x0],r11
80009f20:	2f f8       	sub	r8,-1
80009f22:	87 19       	st.w	r3[0x4],r9
80009f24:	fb 48 06 8c 	st.w	sp[1676],r8
80009f28:	58 78       	cp.w	r8,7
80009f2a:	e0 89 00 05 	brgt	80009f34 <_vfprintf_r+0x1d10>
80009f2e:	2f 83       	sub	r3,-8
80009f30:	c0 c8       	rjmp	80009f48 <_vfprintf_r+0x1d24>
80009f32:	d7 03       	nop
80009f34:	fa ca f9 78 	sub	r10,sp,-1672
80009f38:	02 9b       	mov	r11,r1
80009f3a:	08 9c       	mov	r12,r4
80009f3c:	fe b0 f1 66 	rcall	80008208 <__sprint_r>
80009f40:	e0 81 00 f1 	brne	8000a122 <_vfprintf_r+0x1efe>
80009f44:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f48:	30 08       	mov	r8,0
80009f4a:	30 09       	mov	r9,0
80009f4c:	40 5b       	lddsp	r11,sp[0x14]
80009f4e:	40 7a       	lddsp	r10,sp[0x1c]
80009f50:	e0 a0 13 25 	rcall	8000c59a <__avr32_f64_cmp_eq>
80009f54:	40 68       	lddsp	r8,sp[0x18]
80009f56:	20 18       	sub	r8,1
80009f58:	58 0c       	cp.w	r12,0
80009f5a:	c0 d1       	brne	80009f74 <_vfprintf_r+0x1d50>
80009f5c:	2f f6       	sub	r6,-1
80009f5e:	87 18       	st.w	r3[0x4],r8
80009f60:	87 06       	st.w	r3[0x0],r6
80009f62:	fa f6 06 90 	ld.w	r6,sp[1680]
80009f66:	10 06       	add	r6,r8
80009f68:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f6c:	fb 46 06 90 	st.w	sp[1680],r6
80009f70:	2f f8       	sub	r8,-1
80009f72:	c3 18       	rjmp	80009fd4 <_vfprintf_r+0x1db0>
80009f74:	10 96       	mov	r6,r8
80009f76:	58 08       	cp.w	r8,0
80009f78:	e0 89 00 1c 	brgt	80009fb0 <_vfprintf_r+0x1d8c>
80009f7c:	c4 b8       	rjmp	8000a012 <_vfprintf_r+0x1dee>
80009f7e:	2f 09       	sub	r9,-16
80009f80:	2f f8       	sub	r8,-1
80009f82:	fb 49 06 90 	st.w	sp[1680],r9
80009f86:	87 02       	st.w	r3[0x0],r2
80009f88:	87 10       	st.w	r3[0x4],r0
80009f8a:	fb 48 06 8c 	st.w	sp[1676],r8
80009f8e:	58 78       	cp.w	r8,7
80009f90:	e0 89 00 04 	brgt	80009f98 <_vfprintf_r+0x1d74>
80009f94:	2f 83       	sub	r3,-8
80009f96:	c0 b8       	rjmp	80009fac <_vfprintf_r+0x1d88>
80009f98:	fa ca f9 78 	sub	r10,sp,-1672
80009f9c:	02 9b       	mov	r11,r1
80009f9e:	08 9c       	mov	r12,r4
80009fa0:	fe b0 f1 34 	rcall	80008208 <__sprint_r>
80009fa4:	e0 81 00 bf 	brne	8000a122 <_vfprintf_r+0x1efe>
80009fa8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009fac:	21 06       	sub	r6,16
80009fae:	c0 48       	rjmp	80009fb6 <_vfprintf_r+0x1d92>
80009fb0:	fe c2 bd 90 	sub	r2,pc,-17008
80009fb4:	31 00       	mov	r0,16
80009fb6:	fa f9 06 90 	ld.w	r9,sp[1680]
80009fba:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fbe:	fe ca bd 9e 	sub	r10,pc,-16994
80009fc2:	59 06       	cp.w	r6,16
80009fc4:	fe 99 ff dd 	brgt	80009f7e <_vfprintf_r+0x1d5a>
80009fc8:	0c 09       	add	r9,r6
80009fca:	87 0a       	st.w	r3[0x0],r10
80009fcc:	fb 49 06 90 	st.w	sp[1680],r9
80009fd0:	2f f8       	sub	r8,-1
80009fd2:	87 16       	st.w	r3[0x4],r6
80009fd4:	fb 48 06 8c 	st.w	sp[1676],r8
80009fd8:	c0 e8       	rjmp	80009ff4 <_vfprintf_r+0x1dd0>
80009fda:	fa f8 06 90 	ld.w	r8,sp[1680]
80009fde:	2f f8       	sub	r8,-1
80009fe0:	30 19       	mov	r9,1
80009fe2:	fb 48 06 90 	st.w	sp[1680],r8
80009fe6:	87 06       	st.w	r3[0x0],r6
80009fe8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fec:	87 19       	st.w	r3[0x4],r9
80009fee:	2f f8       	sub	r8,-1
80009ff0:	fb 48 06 8c 	st.w	sp[1676],r8
80009ff4:	58 78       	cp.w	r8,7
80009ff6:	e0 89 00 04 	brgt	80009ffe <_vfprintf_r+0x1dda>
80009ffa:	2f 83       	sub	r3,-8
80009ffc:	c0 b8       	rjmp	8000a012 <_vfprintf_r+0x1dee>
80009ffe:	fa ca f9 78 	sub	r10,sp,-1672
8000a002:	02 9b       	mov	r11,r1
8000a004:	08 9c       	mov	r12,r4
8000a006:	fe b0 f1 01 	rcall	80008208 <__sprint_r>
8000a00a:	e0 81 00 8c 	brne	8000a122 <_vfprintf_r+0x1efe>
8000a00e:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a012:	40 ea       	lddsp	r10,sp[0x38]
8000a014:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a018:	14 08       	add	r8,r10
8000a01a:	fa c9 f9 64 	sub	r9,sp,-1692
8000a01e:	fb 48 06 90 	st.w	sp[1680],r8
8000a022:	87 1a       	st.w	r3[0x4],r10
8000a024:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a028:	87 09       	st.w	r3[0x0],r9
8000a02a:	2f f8       	sub	r8,-1
8000a02c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a030:	58 78       	cp.w	r8,7
8000a032:	e0 89 00 04 	brgt	8000a03a <_vfprintf_r+0x1e16>
8000a036:	2f 83       	sub	r3,-8
8000a038:	c0 a8       	rjmp	8000a04c <_vfprintf_r+0x1e28>
8000a03a:	fa ca f9 78 	sub	r10,sp,-1672
8000a03e:	02 9b       	mov	r11,r1
8000a040:	08 9c       	mov	r12,r4
8000a042:	fe b0 f0 e3 	rcall	80008208 <__sprint_r>
8000a046:	c6 e1       	brne	8000a122 <_vfprintf_r+0x1efe>
8000a048:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a04c:	e2 15 00 04 	andl	r5,0x4,COH
8000a050:	c3 f0       	breq	8000a0ce <_vfprintf_r+0x1eaa>
8000a052:	40 86       	lddsp	r6,sp[0x20]
8000a054:	40 39       	lddsp	r9,sp[0xc]
8000a056:	12 16       	sub	r6,r9
8000a058:	58 06       	cp.w	r6,0
8000a05a:	e0 89 00 1a 	brgt	8000a08e <_vfprintf_r+0x1e6a>
8000a05e:	c3 88       	rjmp	8000a0ce <_vfprintf_r+0x1eaa>
8000a060:	2f 09       	sub	r9,-16
8000a062:	2f f8       	sub	r8,-1
8000a064:	fb 49 06 90 	st.w	sp[1680],r9
8000a068:	87 05       	st.w	r3[0x0],r5
8000a06a:	87 12       	st.w	r3[0x4],r2
8000a06c:	fb 48 06 8c 	st.w	sp[1676],r8
8000a070:	58 78       	cp.w	r8,7
8000a072:	e0 89 00 04 	brgt	8000a07a <_vfprintf_r+0x1e56>
8000a076:	2f 83       	sub	r3,-8
8000a078:	c0 98       	rjmp	8000a08a <_vfprintf_r+0x1e66>
8000a07a:	00 9a       	mov	r10,r0
8000a07c:	02 9b       	mov	r11,r1
8000a07e:	08 9c       	mov	r12,r4
8000a080:	fe b0 f0 c4 	rcall	80008208 <__sprint_r>
8000a084:	c4 f1       	brne	8000a122 <_vfprintf_r+0x1efe>
8000a086:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a08a:	21 06       	sub	r6,16
8000a08c:	c0 68       	rjmp	8000a098 <_vfprintf_r+0x1e74>
8000a08e:	fe c5 be 7e 	sub	r5,pc,-16770
8000a092:	31 02       	mov	r2,16
8000a094:	fa c0 f9 78 	sub	r0,sp,-1672
8000a098:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a09c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a0a0:	fe ca be 90 	sub	r10,pc,-16752
8000a0a4:	59 06       	cp.w	r6,16
8000a0a6:	fe 99 ff dd 	brgt	8000a060 <_vfprintf_r+0x1e3c>
8000a0aa:	0c 09       	add	r9,r6
8000a0ac:	2f f8       	sub	r8,-1
8000a0ae:	87 0a       	st.w	r3[0x0],r10
8000a0b0:	87 16       	st.w	r3[0x4],r6
8000a0b2:	fb 49 06 90 	st.w	sp[1680],r9
8000a0b6:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0ba:	58 78       	cp.w	r8,7
8000a0bc:	e0 8a 00 09 	brle	8000a0ce <_vfprintf_r+0x1eaa>
8000a0c0:	fa ca f9 78 	sub	r10,sp,-1672
8000a0c4:	02 9b       	mov	r11,r1
8000a0c6:	08 9c       	mov	r12,r4
8000a0c8:	fe b0 f0 a0 	rcall	80008208 <__sprint_r>
8000a0cc:	c2 b1       	brne	8000a122 <_vfprintf_r+0x1efe>
8000a0ce:	40 bc       	lddsp	r12,sp[0x2c]
8000a0d0:	40 36       	lddsp	r6,sp[0xc]
8000a0d2:	40 8e       	lddsp	lr,sp[0x20]
8000a0d4:	ec 0e 0c 48 	max	r8,r6,lr
8000a0d8:	10 0c       	add	r12,r8
8000a0da:	50 bc       	stdsp	sp[0x2c],r12
8000a0dc:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a0e0:	58 08       	cp.w	r8,0
8000a0e2:	c0 80       	breq	8000a0f2 <_vfprintf_r+0x1ece>
8000a0e4:	fa ca f9 78 	sub	r10,sp,-1672
8000a0e8:	02 9b       	mov	r11,r1
8000a0ea:	08 9c       	mov	r12,r4
8000a0ec:	fe b0 f0 8e 	rcall	80008208 <__sprint_r>
8000a0f0:	c1 91       	brne	8000a122 <_vfprintf_r+0x1efe>
8000a0f2:	30 0b       	mov	r11,0
8000a0f4:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0f8:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a0fc:	fe 9f f1 22 	bral	80008340 <_vfprintf_r+0x11c>
8000a100:	08 95       	mov	r5,r4
8000a102:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a106:	58 08       	cp.w	r8,0
8000a108:	c0 80       	breq	8000a118 <_vfprintf_r+0x1ef4>
8000a10a:	08 9c       	mov	r12,r4
8000a10c:	fa ca f9 78 	sub	r10,sp,-1672
8000a110:	02 9b       	mov	r11,r1
8000a112:	fe b0 f0 7b 	rcall	80008208 <__sprint_r>
8000a116:	c0 61       	brne	8000a122 <_vfprintf_r+0x1efe>
8000a118:	30 08       	mov	r8,0
8000a11a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a11e:	c0 28       	rjmp	8000a122 <_vfprintf_r+0x1efe>
8000a120:	40 41       	lddsp	r1,sp[0x10]
8000a122:	82 68       	ld.sh	r8,r1[0xc]
8000a124:	ed b8 00 06 	bld	r8,0x6
8000a128:	c0 31       	brne	8000a12e <_vfprintf_r+0x1f0a>
8000a12a:	3f fa       	mov	r10,-1
8000a12c:	50 ba       	stdsp	sp[0x2c],r10
8000a12e:	40 bc       	lddsp	r12,sp[0x2c]
8000a130:	fe 3d f9 44 	sub	sp,-1724
8000a134:	d8 32       	popm	r0-r7,pc
8000a136:	d7 03       	nop

8000a138 <__swsetup_r>:
8000a138:	d4 21       	pushm	r4-r7,lr
8000a13a:	e0 68 0a 40 	mov	r8,2624
8000a13e:	18 96       	mov	r6,r12
8000a140:	16 97       	mov	r7,r11
8000a142:	70 0c       	ld.w	r12,r8[0x0]
8000a144:	58 0c       	cp.w	r12,0
8000a146:	c0 60       	breq	8000a152 <__swsetup_r+0x1a>
8000a148:	78 68       	ld.w	r8,r12[0x18]
8000a14a:	58 08       	cp.w	r8,0
8000a14c:	c0 31       	brne	8000a152 <__swsetup_r+0x1a>
8000a14e:	e0 a0 07 bf 	rcall	8000b0cc <__sinit>
8000a152:	fe c8 be 12 	sub	r8,pc,-16878
8000a156:	10 37       	cp.w	r7,r8
8000a158:	c0 61       	brne	8000a164 <__swsetup_r+0x2c>
8000a15a:	e0 68 0a 40 	mov	r8,2624
8000a15e:	70 08       	ld.w	r8,r8[0x0]
8000a160:	70 07       	ld.w	r7,r8[0x0]
8000a162:	c1 28       	rjmp	8000a186 <__swsetup_r+0x4e>
8000a164:	fe c8 be 04 	sub	r8,pc,-16892
8000a168:	10 37       	cp.w	r7,r8
8000a16a:	c0 61       	brne	8000a176 <__swsetup_r+0x3e>
8000a16c:	e0 68 0a 40 	mov	r8,2624
8000a170:	70 08       	ld.w	r8,r8[0x0]
8000a172:	70 17       	ld.w	r7,r8[0x4]
8000a174:	c0 98       	rjmp	8000a186 <__swsetup_r+0x4e>
8000a176:	fe c8 bd f6 	sub	r8,pc,-16906
8000a17a:	10 37       	cp.w	r7,r8
8000a17c:	c0 51       	brne	8000a186 <__swsetup_r+0x4e>
8000a17e:	e0 68 0a 40 	mov	r8,2624
8000a182:	70 08       	ld.w	r8,r8[0x0]
8000a184:	70 27       	ld.w	r7,r8[0x8]
8000a186:	8e 68       	ld.sh	r8,r7[0xc]
8000a188:	ed b8 00 03 	bld	r8,0x3
8000a18c:	c1 e0       	breq	8000a1c8 <__swsetup_r+0x90>
8000a18e:	ed b8 00 04 	bld	r8,0x4
8000a192:	c3 e1       	brne	8000a20e <__swsetup_r+0xd6>
8000a194:	ed b8 00 02 	bld	r8,0x2
8000a198:	c1 51       	brne	8000a1c2 <__swsetup_r+0x8a>
8000a19a:	6e db       	ld.w	r11,r7[0x34]
8000a19c:	58 0b       	cp.w	r11,0
8000a19e:	c0 a0       	breq	8000a1b2 <__swsetup_r+0x7a>
8000a1a0:	ee c8 ff bc 	sub	r8,r7,-68
8000a1a4:	10 3b       	cp.w	r11,r8
8000a1a6:	c0 40       	breq	8000a1ae <__swsetup_r+0x76>
8000a1a8:	0c 9c       	mov	r12,r6
8000a1aa:	e0 a0 08 2b 	rcall	8000b200 <_free_r>
8000a1ae:	30 08       	mov	r8,0
8000a1b0:	8f d8       	st.w	r7[0x34],r8
8000a1b2:	8e 68       	ld.sh	r8,r7[0xc]
8000a1b4:	e0 18 ff db 	andl	r8,0xffdb
8000a1b8:	ae 68       	st.h	r7[0xc],r8
8000a1ba:	30 08       	mov	r8,0
8000a1bc:	8f 18       	st.w	r7[0x4],r8
8000a1be:	6e 48       	ld.w	r8,r7[0x10]
8000a1c0:	8f 08       	st.w	r7[0x0],r8
8000a1c2:	8e 68       	ld.sh	r8,r7[0xc]
8000a1c4:	a3 b8       	sbr	r8,0x3
8000a1c6:	ae 68       	st.h	r7[0xc],r8
8000a1c8:	6e 48       	ld.w	r8,r7[0x10]
8000a1ca:	58 08       	cp.w	r8,0
8000a1cc:	c0 b1       	brne	8000a1e2 <__swsetup_r+0xaa>
8000a1ce:	8e 68       	ld.sh	r8,r7[0xc]
8000a1d0:	e2 18 02 80 	andl	r8,0x280,COH
8000a1d4:	e0 48 02 00 	cp.w	r8,512
8000a1d8:	c0 50       	breq	8000a1e2 <__swsetup_r+0xaa>
8000a1da:	0c 9c       	mov	r12,r6
8000a1dc:	0e 9b       	mov	r11,r7
8000a1de:	e0 a0 0a 4b 	rcall	8000b674 <__smakebuf_r>
8000a1e2:	8e 69       	ld.sh	r9,r7[0xc]
8000a1e4:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a1e8:	c0 70       	breq	8000a1f6 <__swsetup_r+0xbe>
8000a1ea:	30 08       	mov	r8,0
8000a1ec:	8f 28       	st.w	r7[0x8],r8
8000a1ee:	6e 58       	ld.w	r8,r7[0x14]
8000a1f0:	5c 38       	neg	r8
8000a1f2:	8f 68       	st.w	r7[0x18],r8
8000a1f4:	c0 68       	rjmp	8000a200 <__swsetup_r+0xc8>
8000a1f6:	ed b9 00 01 	bld	r9,0x1
8000a1fa:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a1fe:	8f 28       	st.w	r7[0x8],r8
8000a200:	6e 48       	ld.w	r8,r7[0x10]
8000a202:	58 08       	cp.w	r8,0
8000a204:	c0 61       	brne	8000a210 <__swsetup_r+0xd8>
8000a206:	8e 68       	ld.sh	r8,r7[0xc]
8000a208:	ed b8 00 07 	bld	r8,0x7
8000a20c:	c0 21       	brne	8000a210 <__swsetup_r+0xd8>
8000a20e:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a210:	d8 2a       	popm	r4-r7,pc,r12=0
8000a212:	d7 03       	nop

8000a214 <quorem>:
8000a214:	d4 31       	pushm	r0-r7,lr
8000a216:	20 2d       	sub	sp,8
8000a218:	18 97       	mov	r7,r12
8000a21a:	78 48       	ld.w	r8,r12[0x10]
8000a21c:	76 46       	ld.w	r6,r11[0x10]
8000a21e:	0c 38       	cp.w	r8,r6
8000a220:	c0 34       	brge	8000a226 <quorem+0x12>
8000a222:	30 0c       	mov	r12,0
8000a224:	c8 58       	rjmp	8000a32e <quorem+0x11a>
8000a226:	ec c2 ff fc 	sub	r2,r6,-4
8000a22a:	f6 c3 ff ec 	sub	r3,r11,-20
8000a22e:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a232:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a236:	2f f9       	sub	r9,-1
8000a238:	20 16       	sub	r6,1
8000a23a:	f8 09 0d 08 	divu	r8,r12,r9
8000a23e:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a242:	ee c4 ff ec 	sub	r4,r7,-20
8000a246:	10 95       	mov	r5,r8
8000a248:	58 08       	cp.w	r8,0
8000a24a:	c4 10       	breq	8000a2cc <quorem+0xb8>
8000a24c:	30 09       	mov	r9,0
8000a24e:	06 9a       	mov	r10,r3
8000a250:	08 98       	mov	r8,r4
8000a252:	12 91       	mov	r1,r9
8000a254:	50 0b       	stdsp	sp[0x0],r11
8000a256:	70 0e       	ld.w	lr,r8[0x0]
8000a258:	b1 8e       	lsr	lr,0x10
8000a25a:	50 1e       	stdsp	sp[0x4],lr
8000a25c:	15 0e       	ld.w	lr,r10++
8000a25e:	fc 00 16 10 	lsr	r0,lr,0x10
8000a262:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a266:	ea 0e 03 41 	mac	r1,r5,lr
8000a26a:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a26e:	b1 81       	lsr	r1,0x10
8000a270:	40 1b       	lddsp	r11,sp[0x4]
8000a272:	ea 00 02 40 	mul	r0,r5,r0
8000a276:	e2 00 00 00 	add	r0,r1,r0
8000a27a:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a27e:	02 1b       	sub	r11,r1
8000a280:	50 1b       	stdsp	sp[0x4],r11
8000a282:	70 0b       	ld.w	r11,r8[0x0]
8000a284:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a288:	02 09       	add	r9,r1
8000a28a:	f2 0e 01 0e 	sub	lr,r9,lr
8000a28e:	b0 1e       	st.h	r8[0x2],lr
8000a290:	fc 09 14 10 	asr	r9,lr,0x10
8000a294:	40 1e       	lddsp	lr,sp[0x4]
8000a296:	fc 09 00 09 	add	r9,lr,r9
8000a29a:	b0 09       	st.h	r8[0x0],r9
8000a29c:	e0 01 16 10 	lsr	r1,r0,0x10
8000a2a0:	2f c8       	sub	r8,-4
8000a2a2:	b1 49       	asr	r9,0x10
8000a2a4:	04 3a       	cp.w	r10,r2
8000a2a6:	fe 98 ff d8 	brls	8000a256 <quorem+0x42>
8000a2aa:	40 0b       	lddsp	r11,sp[0x0]
8000a2ac:	58 0c       	cp.w	r12,0
8000a2ae:	c0 f1       	brne	8000a2cc <quorem+0xb8>
8000a2b0:	ec c8 ff fb 	sub	r8,r6,-5
8000a2b4:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a2b8:	c0 28       	rjmp	8000a2bc <quorem+0xa8>
8000a2ba:	20 16       	sub	r6,1
8000a2bc:	20 48       	sub	r8,4
8000a2be:	08 38       	cp.w	r8,r4
8000a2c0:	e0 88 00 05 	brls	8000a2ca <quorem+0xb6>
8000a2c4:	70 09       	ld.w	r9,r8[0x0]
8000a2c6:	58 09       	cp.w	r9,0
8000a2c8:	cf 90       	breq	8000a2ba <quorem+0xa6>
8000a2ca:	8f 46       	st.w	r7[0x10],r6
8000a2cc:	0e 9c       	mov	r12,r7
8000a2ce:	e0 a0 0a d2 	rcall	8000b872 <__mcmp>
8000a2d2:	c2 d5       	brlt	8000a32c <quorem+0x118>
8000a2d4:	2f f5       	sub	r5,-1
8000a2d6:	08 98       	mov	r8,r4
8000a2d8:	30 09       	mov	r9,0
8000a2da:	07 0b       	ld.w	r11,r3++
8000a2dc:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a2e0:	70 0c       	ld.w	r12,r8[0x0]
8000a2e2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a2e6:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a2ea:	14 1e       	sub	lr,r10
8000a2ec:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a2f0:	16 1a       	sub	r10,r11
8000a2f2:	12 0a       	add	r10,r9
8000a2f4:	b0 1a       	st.h	r8[0x2],r10
8000a2f6:	b1 4a       	asr	r10,0x10
8000a2f8:	fc 0a 00 09 	add	r9,lr,r10
8000a2fc:	b0 09       	st.h	r8[0x0],r9
8000a2fe:	2f c8       	sub	r8,-4
8000a300:	b1 49       	asr	r9,0x10
8000a302:	04 33       	cp.w	r3,r2
8000a304:	fe 98 ff eb 	brls	8000a2da <quorem+0xc6>
8000a308:	ec c8 ff fb 	sub	r8,r6,-5
8000a30c:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a310:	58 09       	cp.w	r9,0
8000a312:	c0 d1       	brne	8000a32c <quorem+0x118>
8000a314:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a318:	c0 28       	rjmp	8000a31c <quorem+0x108>
8000a31a:	20 16       	sub	r6,1
8000a31c:	20 48       	sub	r8,4
8000a31e:	08 38       	cp.w	r8,r4
8000a320:	e0 88 00 05 	brls	8000a32a <quorem+0x116>
8000a324:	70 09       	ld.w	r9,r8[0x0]
8000a326:	58 09       	cp.w	r9,0
8000a328:	cf 90       	breq	8000a31a <quorem+0x106>
8000a32a:	8f 46       	st.w	r7[0x10],r6
8000a32c:	0a 9c       	mov	r12,r5
8000a32e:	2f ed       	sub	sp,-8
8000a330:	d8 32       	popm	r0-r7,pc
8000a332:	d7 03       	nop

8000a334 <_dtoa_r>:
8000a334:	d4 31       	pushm	r0-r7,lr
8000a336:	21 ad       	sub	sp,104
8000a338:	fa c4 ff 74 	sub	r4,sp,-140
8000a33c:	18 97       	mov	r7,r12
8000a33e:	16 95       	mov	r5,r11
8000a340:	68 2c       	ld.w	r12,r4[0x8]
8000a342:	50 c9       	stdsp	sp[0x30],r9
8000a344:	68 16       	ld.w	r6,r4[0x4]
8000a346:	68 09       	ld.w	r9,r4[0x0]
8000a348:	50 e8       	stdsp	sp[0x38],r8
8000a34a:	14 94       	mov	r4,r10
8000a34c:	51 2c       	stdsp	sp[0x48],r12
8000a34e:	fa e5 00 08 	st.d	sp[8],r4
8000a352:	51 59       	stdsp	sp[0x54],r9
8000a354:	6e 95       	ld.w	r5,r7[0x24]
8000a356:	58 05       	cp.w	r5,0
8000a358:	c0 91       	brne	8000a36a <_dtoa_r+0x36>
8000a35a:	31 0c       	mov	r12,16
8000a35c:	fe b0 e8 f4 	rcall	80007544 <malloc>
8000a360:	99 35       	st.w	r12[0xc],r5
8000a362:	8f 9c       	st.w	r7[0x24],r12
8000a364:	99 15       	st.w	r12[0x4],r5
8000a366:	99 25       	st.w	r12[0x8],r5
8000a368:	99 05       	st.w	r12[0x0],r5
8000a36a:	6e 99       	ld.w	r9,r7[0x24]
8000a36c:	72 08       	ld.w	r8,r9[0x0]
8000a36e:	58 08       	cp.w	r8,0
8000a370:	c0 f0       	breq	8000a38e <_dtoa_r+0x5a>
8000a372:	72 1a       	ld.w	r10,r9[0x4]
8000a374:	91 1a       	st.w	r8[0x4],r10
8000a376:	30 1a       	mov	r10,1
8000a378:	72 19       	ld.w	r9,r9[0x4]
8000a37a:	f4 09 09 49 	lsl	r9,r10,r9
8000a37e:	10 9b       	mov	r11,r8
8000a380:	91 29       	st.w	r8[0x8],r9
8000a382:	0e 9c       	mov	r12,r7
8000a384:	e0 a0 0a 90 	rcall	8000b8a4 <_Bfree>
8000a388:	6e 98       	ld.w	r8,r7[0x24]
8000a38a:	30 09       	mov	r9,0
8000a38c:	91 09       	st.w	r8[0x0],r9
8000a38e:	40 28       	lddsp	r8,sp[0x8]
8000a390:	10 94       	mov	r4,r8
8000a392:	58 08       	cp.w	r8,0
8000a394:	c0 64       	brge	8000a3a0 <_dtoa_r+0x6c>
8000a396:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a39a:	50 28       	stdsp	sp[0x8],r8
8000a39c:	30 18       	mov	r8,1
8000a39e:	c0 28       	rjmp	8000a3a2 <_dtoa_r+0x6e>
8000a3a0:	30 08       	mov	r8,0
8000a3a2:	8d 08       	st.w	r6[0x0],r8
8000a3a4:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a3a8:	40 26       	lddsp	r6,sp[0x8]
8000a3aa:	0c 98       	mov	r8,r6
8000a3ac:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a3b0:	18 38       	cp.w	r8,r12
8000a3b2:	c2 01       	brne	8000a3f2 <_dtoa_r+0xbe>
8000a3b4:	e0 68 27 0f 	mov	r8,9999
8000a3b8:	41 5b       	lddsp	r11,sp[0x54]
8000a3ba:	97 08       	st.w	r11[0x0],r8
8000a3bc:	40 3a       	lddsp	r10,sp[0xc]
8000a3be:	58 0a       	cp.w	r10,0
8000a3c0:	c0 71       	brne	8000a3ce <_dtoa_r+0x9a>
8000a3c2:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a3c6:	c0 41       	brne	8000a3ce <_dtoa_r+0x9a>
8000a3c8:	fe cc c0 98 	sub	r12,pc,-16232
8000a3cc:	c0 38       	rjmp	8000a3d2 <_dtoa_r+0x9e>
8000a3ce:	fe cc c0 92 	sub	r12,pc,-16238
8000a3d2:	41 29       	lddsp	r9,sp[0x48]
8000a3d4:	58 09       	cp.w	r9,0
8000a3d6:	e0 80 05 9a 	breq	8000af0a <_dtoa_r+0xbd6>
8000a3da:	f8 c8 ff fd 	sub	r8,r12,-3
8000a3de:	f8 c9 ff f8 	sub	r9,r12,-8
8000a3e2:	11 8b       	ld.ub	r11,r8[0x0]
8000a3e4:	30 0a       	mov	r10,0
8000a3e6:	41 25       	lddsp	r5,sp[0x48]
8000a3e8:	f4 0b 18 00 	cp.b	r11,r10
8000a3ec:	f2 08 17 10 	movne	r8,r9
8000a3f0:	c1 68       	rjmp	8000a41c <_dtoa_r+0xe8>
8000a3f2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a3f6:	30 08       	mov	r8,0
8000a3f8:	fa eb 00 3c 	st.d	sp[60],r10
8000a3fc:	30 09       	mov	r9,0
8000a3fe:	e0 a0 10 ce 	rcall	8000c59a <__avr32_f64_cmp_eq>
8000a402:	c1 00       	breq	8000a422 <_dtoa_r+0xee>
8000a404:	30 18       	mov	r8,1
8000a406:	41 5a       	lddsp	r10,sp[0x54]
8000a408:	95 08       	st.w	r10[0x0],r8
8000a40a:	fe cc c1 fe 	sub	r12,pc,-15874
8000a40e:	41 29       	lddsp	r9,sp[0x48]
8000a410:	f8 08 00 08 	add	r8,r12,r8
8000a414:	58 09       	cp.w	r9,0
8000a416:	e0 80 05 7a 	breq	8000af0a <_dtoa_r+0xbd6>
8000a41a:	12 95       	mov	r5,r9
8000a41c:	8b 08       	st.w	r5[0x0],r8
8000a41e:	e0 8f 05 76 	bral	8000af0a <_dtoa_r+0xbd6>
8000a422:	fa c8 ff 9c 	sub	r8,sp,-100
8000a426:	fa c9 ff a0 	sub	r9,sp,-96
8000a42a:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a42e:	0e 9c       	mov	r12,r7
8000a430:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a434:	e0 a0 0a 8a 	rcall	8000b948 <__d2b>
8000a438:	18 93       	mov	r3,r12
8000a43a:	58 05       	cp.w	r5,0
8000a43c:	c0 d0       	breq	8000a456 <_dtoa_r+0x122>
8000a43e:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a442:	30 04       	mov	r4,0
8000a444:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a448:	ea c5 03 ff 	sub	r5,r5,1023
8000a44c:	10 9b       	mov	r11,r8
8000a44e:	51 74       	stdsp	sp[0x5c],r4
8000a450:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a454:	c2 58       	rjmp	8000a49e <_dtoa_r+0x16a>
8000a456:	41 88       	lddsp	r8,sp[0x60]
8000a458:	41 9c       	lddsp	r12,sp[0x64]
8000a45a:	10 0c       	add	r12,r8
8000a45c:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a460:	e0 45 00 20 	cp.w	r5,32
8000a464:	e0 8a 00 0e 	brle	8000a480 <_dtoa_r+0x14c>
8000a468:	f8 cc fb ee 	sub	r12,r12,-1042
8000a46c:	40 3b       	lddsp	r11,sp[0xc]
8000a46e:	ea 08 11 40 	rsub	r8,r5,64
8000a472:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a476:	ec 08 09 46 	lsl	r6,r6,r8
8000a47a:	0c 4c       	or	r12,r6
8000a47c:	c0 78       	rjmp	8000a48a <_dtoa_r+0x156>
8000a47e:	d7 03       	nop
8000a480:	ea 0c 11 20 	rsub	r12,r5,32
8000a484:	40 3a       	lddsp	r10,sp[0xc]
8000a486:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a48a:	e0 a0 10 14 	rcall	8000c4b2 <__avr32_u32_to_f64>
8000a48e:	fc 18 fe 10 	movh	r8,0xfe10
8000a492:	30 19       	mov	r9,1
8000a494:	ea c5 04 33 	sub	r5,r5,1075
8000a498:	f0 0b 00 0b 	add	r11,r8,r11
8000a49c:	51 79       	stdsp	sp[0x5c],r9
8000a49e:	30 08       	mov	r8,0
8000a4a0:	fc 19 3f f8 	movh	r9,0x3ff8
8000a4a4:	e0 a0 0e 9c 	rcall	8000c1dc <__avr32_f64_sub>
8000a4a8:	e0 68 43 61 	mov	r8,17249
8000a4ac:	ea 18 63 6f 	orh	r8,0x636f
8000a4b0:	e0 69 87 a7 	mov	r9,34727
8000a4b4:	ea 19 3f d2 	orh	r9,0x3fd2
8000a4b8:	e0 a0 0d a6 	rcall	8000c004 <__avr32_f64_mul>
8000a4bc:	e0 68 c8 b3 	mov	r8,51379
8000a4c0:	ea 18 8b 60 	orh	r8,0x8b60
8000a4c4:	e0 69 8a 28 	mov	r9,35368
8000a4c8:	ea 19 3f c6 	orh	r9,0x3fc6
8000a4cc:	e0 a0 0f 56 	rcall	8000c378 <__avr32_f64_add>
8000a4d0:	0a 9c       	mov	r12,r5
8000a4d2:	14 90       	mov	r0,r10
8000a4d4:	16 91       	mov	r1,r11
8000a4d6:	e0 a0 0f f2 	rcall	8000c4ba <__avr32_s32_to_f64>
8000a4da:	e0 68 79 fb 	mov	r8,31227
8000a4de:	ea 18 50 9f 	orh	r8,0x509f
8000a4e2:	e0 69 44 13 	mov	r9,17427
8000a4e6:	ea 19 3f d3 	orh	r9,0x3fd3
8000a4ea:	e0 a0 0d 8d 	rcall	8000c004 <__avr32_f64_mul>
8000a4ee:	14 98       	mov	r8,r10
8000a4f0:	16 99       	mov	r9,r11
8000a4f2:	00 9a       	mov	r10,r0
8000a4f4:	02 9b       	mov	r11,r1
8000a4f6:	e0 a0 0f 41 	rcall	8000c378 <__avr32_f64_add>
8000a4fa:	14 90       	mov	r0,r10
8000a4fc:	16 91       	mov	r1,r11
8000a4fe:	e0 a0 0f c7 	rcall	8000c48c <__avr32_f64_to_s32>
8000a502:	30 08       	mov	r8,0
8000a504:	18 96       	mov	r6,r12
8000a506:	30 09       	mov	r9,0
8000a508:	00 9a       	mov	r10,r0
8000a50a:	02 9b       	mov	r11,r1
8000a50c:	e0 a0 10 8e 	rcall	8000c628 <__avr32_f64_cmp_lt>
8000a510:	c0 c0       	breq	8000a528 <_dtoa_r+0x1f4>
8000a512:	0c 9c       	mov	r12,r6
8000a514:	e0 a0 0f d3 	rcall	8000c4ba <__avr32_s32_to_f64>
8000a518:	14 98       	mov	r8,r10
8000a51a:	16 99       	mov	r9,r11
8000a51c:	00 9a       	mov	r10,r0
8000a51e:	02 9b       	mov	r11,r1
8000a520:	e0 a0 10 3d 	rcall	8000c59a <__avr32_f64_cmp_eq>
8000a524:	f7 b6 00 01 	subeq	r6,1
8000a528:	59 66       	cp.w	r6,22
8000a52a:	e0 88 00 05 	brls	8000a534 <_dtoa_r+0x200>
8000a52e:	30 18       	mov	r8,1
8000a530:	51 48       	stdsp	sp[0x50],r8
8000a532:	c1 38       	rjmp	8000a558 <_dtoa_r+0x224>
8000a534:	fe c8 c1 44 	sub	r8,pc,-16060
8000a538:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a53c:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a540:	e0 a0 10 74 	rcall	8000c628 <__avr32_f64_cmp_lt>
8000a544:	f9 b4 00 00 	moveq	r4,0
8000a548:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a54c:	f7 b6 01 01 	subne	r6,1
8000a550:	f9 bc 01 00 	movne	r12,0
8000a554:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a558:	41 90       	lddsp	r0,sp[0x64]
8000a55a:	20 10       	sub	r0,1
8000a55c:	0a 10       	sub	r0,r5
8000a55e:	c0 46       	brmi	8000a566 <_dtoa_r+0x232>
8000a560:	50 40       	stdsp	sp[0x10],r0
8000a562:	30 00       	mov	r0,0
8000a564:	c0 48       	rjmp	8000a56c <_dtoa_r+0x238>
8000a566:	30 0b       	mov	r11,0
8000a568:	5c 30       	neg	r0
8000a56a:	50 4b       	stdsp	sp[0x10],r11
8000a56c:	ec 02 11 00 	rsub	r2,r6,0
8000a570:	58 06       	cp.w	r6,0
8000a572:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a576:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a57a:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a57e:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a582:	f9 b2 04 00 	movge	r2,0
8000a586:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a58a:	f9 b9 05 00 	movlt	r9,0
8000a58e:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a592:	40 c8       	lddsp	r8,sp[0x30]
8000a594:	58 98       	cp.w	r8,9
8000a596:	e0 8b 00 20 	brhi	8000a5d6 <_dtoa_r+0x2a2>
8000a59a:	58 58       	cp.w	r8,5
8000a59c:	f9 b4 0a 01 	movle	r4,1
8000a5a0:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a5a4:	f7 b5 09 04 	subgt	r5,4
8000a5a8:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a5ac:	f9 b4 09 00 	movgt	r4,0
8000a5b0:	40 cc       	lddsp	r12,sp[0x30]
8000a5b2:	58 3c       	cp.w	r12,3
8000a5b4:	c2 d0       	breq	8000a60e <_dtoa_r+0x2da>
8000a5b6:	e0 89 00 05 	brgt	8000a5c0 <_dtoa_r+0x28c>
8000a5ba:	58 2c       	cp.w	r12,2
8000a5bc:	c1 01       	brne	8000a5dc <_dtoa_r+0x2a8>
8000a5be:	c1 88       	rjmp	8000a5ee <_dtoa_r+0x2ba>
8000a5c0:	40 cb       	lddsp	r11,sp[0x30]
8000a5c2:	58 4b       	cp.w	r11,4
8000a5c4:	c0 60       	breq	8000a5d0 <_dtoa_r+0x29c>
8000a5c6:	58 5b       	cp.w	r11,5
8000a5c8:	c0 a1       	brne	8000a5dc <_dtoa_r+0x2a8>
8000a5ca:	30 1a       	mov	r10,1
8000a5cc:	50 da       	stdsp	sp[0x34],r10
8000a5ce:	c2 28       	rjmp	8000a612 <_dtoa_r+0x2de>
8000a5d0:	30 19       	mov	r9,1
8000a5d2:	50 d9       	stdsp	sp[0x34],r9
8000a5d4:	c0 f8       	rjmp	8000a5f2 <_dtoa_r+0x2be>
8000a5d6:	30 08       	mov	r8,0
8000a5d8:	30 14       	mov	r4,1
8000a5da:	50 c8       	stdsp	sp[0x30],r8
8000a5dc:	3f f5       	mov	r5,-1
8000a5de:	30 1c       	mov	r12,1
8000a5e0:	30 0b       	mov	r11,0
8000a5e2:	50 95       	stdsp	sp[0x24],r5
8000a5e4:	50 dc       	stdsp	sp[0x34],r12
8000a5e6:	0a 91       	mov	r1,r5
8000a5e8:	31 28       	mov	r8,18
8000a5ea:	50 eb       	stdsp	sp[0x38],r11
8000a5ec:	c2 08       	rjmp	8000a62c <_dtoa_r+0x2f8>
8000a5ee:	30 0a       	mov	r10,0
8000a5f0:	50 da       	stdsp	sp[0x34],r10
8000a5f2:	40 e9       	lddsp	r9,sp[0x38]
8000a5f4:	58 09       	cp.w	r9,0
8000a5f6:	e0 89 00 07 	brgt	8000a604 <_dtoa_r+0x2d0>
8000a5fa:	30 18       	mov	r8,1
8000a5fc:	50 98       	stdsp	sp[0x24],r8
8000a5fe:	10 91       	mov	r1,r8
8000a600:	50 e8       	stdsp	sp[0x38],r8
8000a602:	c1 58       	rjmp	8000a62c <_dtoa_r+0x2f8>
8000a604:	40 e5       	lddsp	r5,sp[0x38]
8000a606:	50 95       	stdsp	sp[0x24],r5
8000a608:	0a 91       	mov	r1,r5
8000a60a:	0a 98       	mov	r8,r5
8000a60c:	c1 08       	rjmp	8000a62c <_dtoa_r+0x2f8>
8000a60e:	30 0c       	mov	r12,0
8000a610:	50 dc       	stdsp	sp[0x34],r12
8000a612:	40 eb       	lddsp	r11,sp[0x38]
8000a614:	ec 0b 00 0b 	add	r11,r6,r11
8000a618:	50 9b       	stdsp	sp[0x24],r11
8000a61a:	16 98       	mov	r8,r11
8000a61c:	2f f8       	sub	r8,-1
8000a61e:	58 08       	cp.w	r8,0
8000a620:	e0 89 00 05 	brgt	8000a62a <_dtoa_r+0x2f6>
8000a624:	10 91       	mov	r1,r8
8000a626:	30 18       	mov	r8,1
8000a628:	c0 28       	rjmp	8000a62c <_dtoa_r+0x2f8>
8000a62a:	10 91       	mov	r1,r8
8000a62c:	30 09       	mov	r9,0
8000a62e:	6e 9a       	ld.w	r10,r7[0x24]
8000a630:	95 19       	st.w	r10[0x4],r9
8000a632:	30 49       	mov	r9,4
8000a634:	c0 68       	rjmp	8000a640 <_dtoa_r+0x30c>
8000a636:	d7 03       	nop
8000a638:	6a 1a       	ld.w	r10,r5[0x4]
8000a63a:	a1 79       	lsl	r9,0x1
8000a63c:	2f fa       	sub	r10,-1
8000a63e:	8b 1a       	st.w	r5[0x4],r10
8000a640:	6e 95       	ld.w	r5,r7[0x24]
8000a642:	f2 ca ff ec 	sub	r10,r9,-20
8000a646:	10 3a       	cp.w	r10,r8
8000a648:	fe 98 ff f8 	brls	8000a638 <_dtoa_r+0x304>
8000a64c:	6a 1b       	ld.w	r11,r5[0x4]
8000a64e:	0e 9c       	mov	r12,r7
8000a650:	e0 a0 09 44 	rcall	8000b8d8 <_Balloc>
8000a654:	58 e1       	cp.w	r1,14
8000a656:	5f 88       	srls	r8
8000a658:	8b 0c       	st.w	r5[0x0],r12
8000a65a:	f1 e4 00 04 	and	r4,r8,r4
8000a65e:	6e 98       	ld.w	r8,r7[0x24]
8000a660:	70 08       	ld.w	r8,r8[0x0]
8000a662:	50 88       	stdsp	sp[0x20],r8
8000a664:	e0 80 01 82 	breq	8000a968 <_dtoa_r+0x634>
8000a668:	58 06       	cp.w	r6,0
8000a66a:	e0 8a 00 43 	brle	8000a6f0 <_dtoa_r+0x3bc>
8000a66e:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a672:	fe c8 c2 82 	sub	r8,pc,-15742
8000a676:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a67a:	fa e5 00 18 	st.d	sp[24],r4
8000a67e:	ec 04 14 04 	asr	r4,r6,0x4
8000a682:	ed b4 00 04 	bld	r4,0x4
8000a686:	c0 30       	breq	8000a68c <_dtoa_r+0x358>
8000a688:	30 25       	mov	r5,2
8000a68a:	c1 08       	rjmp	8000a6aa <_dtoa_r+0x376>
8000a68c:	fe c8 c1 d4 	sub	r8,pc,-15916
8000a690:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a694:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a698:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a69c:	e0 a0 0f fa 	rcall	8000c690 <__avr32_f64_div>
8000a6a0:	30 35       	mov	r5,3
8000a6a2:	14 98       	mov	r8,r10
8000a6a4:	16 99       	mov	r9,r11
8000a6a6:	fa e9 00 08 	st.d	sp[8],r8
8000a6aa:	fe cc c1 f2 	sub	r12,pc,-15886
8000a6ae:	50 a3       	stdsp	sp[0x28],r3
8000a6b0:	0c 93       	mov	r3,r6
8000a6b2:	18 96       	mov	r6,r12
8000a6b4:	c0 f8       	rjmp	8000a6d2 <_dtoa_r+0x39e>
8000a6b6:	fa ea 00 18 	ld.d	r10,sp[24]
8000a6ba:	ed b4 00 00 	bld	r4,0x0
8000a6be:	c0 81       	brne	8000a6ce <_dtoa_r+0x39a>
8000a6c0:	ec e8 00 00 	ld.d	r8,r6[0]
8000a6c4:	2f f5       	sub	r5,-1
8000a6c6:	e0 a0 0c 9f 	rcall	8000c004 <__avr32_f64_mul>
8000a6ca:	fa eb 00 18 	st.d	sp[24],r10
8000a6ce:	a1 54       	asr	r4,0x1
8000a6d0:	2f 86       	sub	r6,-8
8000a6d2:	58 04       	cp.w	r4,0
8000a6d4:	cf 11       	brne	8000a6b6 <_dtoa_r+0x382>
8000a6d6:	fa e8 00 18 	ld.d	r8,sp[24]
8000a6da:	fa ea 00 08 	ld.d	r10,sp[8]
8000a6de:	06 96       	mov	r6,r3
8000a6e0:	e0 a0 0f d8 	rcall	8000c690 <__avr32_f64_div>
8000a6e4:	40 a3       	lddsp	r3,sp[0x28]
8000a6e6:	14 98       	mov	r8,r10
8000a6e8:	16 99       	mov	r9,r11
8000a6ea:	fa e9 00 08 	st.d	sp[8],r8
8000a6ee:	c2 f8       	rjmp	8000a74c <_dtoa_r+0x418>
8000a6f0:	ec 08 11 00 	rsub	r8,r6,0
8000a6f4:	c0 31       	brne	8000a6fa <_dtoa_r+0x3c6>
8000a6f6:	30 25       	mov	r5,2
8000a6f8:	c2 a8       	rjmp	8000a74c <_dtoa_r+0x418>
8000a6fa:	fe cc c2 42 	sub	r12,pc,-15806
8000a6fe:	f0 04 14 04 	asr	r4,r8,0x4
8000a702:	50 1c       	stdsp	sp[0x4],r12
8000a704:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a708:	fe c9 c3 18 	sub	r9,pc,-15592
8000a70c:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a710:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a714:	e0 a0 0c 78 	rcall	8000c004 <__avr32_f64_mul>
8000a718:	40 1c       	lddsp	r12,sp[0x4]
8000a71a:	50 63       	stdsp	sp[0x18],r3
8000a71c:	30 25       	mov	r5,2
8000a71e:	0c 93       	mov	r3,r6
8000a720:	fa eb 00 08 	st.d	sp[8],r10
8000a724:	18 96       	mov	r6,r12
8000a726:	c0 f8       	rjmp	8000a744 <_dtoa_r+0x410>
8000a728:	fa ea 00 08 	ld.d	r10,sp[8]
8000a72c:	ed b4 00 00 	bld	r4,0x0
8000a730:	c0 81       	brne	8000a740 <_dtoa_r+0x40c>
8000a732:	ec e8 00 00 	ld.d	r8,r6[0]
8000a736:	2f f5       	sub	r5,-1
8000a738:	e0 a0 0c 66 	rcall	8000c004 <__avr32_f64_mul>
8000a73c:	fa eb 00 08 	st.d	sp[8],r10
8000a740:	a1 54       	asr	r4,0x1
8000a742:	2f 86       	sub	r6,-8
8000a744:	58 04       	cp.w	r4,0
8000a746:	cf 11       	brne	8000a728 <_dtoa_r+0x3f4>
8000a748:	06 96       	mov	r6,r3
8000a74a:	40 63       	lddsp	r3,sp[0x18]
8000a74c:	41 4a       	lddsp	r10,sp[0x50]
8000a74e:	58 0a       	cp.w	r10,0
8000a750:	c2 a0       	breq	8000a7a4 <_dtoa_r+0x470>
8000a752:	fa e8 00 08 	ld.d	r8,sp[8]
8000a756:	58 01       	cp.w	r1,0
8000a758:	5f 94       	srgt	r4
8000a75a:	fa e9 00 18 	st.d	sp[24],r8
8000a75e:	30 08       	mov	r8,0
8000a760:	fc 19 3f f0 	movh	r9,0x3ff0
8000a764:	fa ea 00 18 	ld.d	r10,sp[24]
8000a768:	e0 a0 0f 60 	rcall	8000c628 <__avr32_f64_cmp_lt>
8000a76c:	f9 bc 00 00 	moveq	r12,0
8000a770:	f9 bc 01 01 	movne	r12,1
8000a774:	e9 ec 00 0c 	and	r12,r4,r12
8000a778:	c1 60       	breq	8000a7a4 <_dtoa_r+0x470>
8000a77a:	40 98       	lddsp	r8,sp[0x24]
8000a77c:	58 08       	cp.w	r8,0
8000a77e:	e0 8a 00 f1 	brle	8000a960 <_dtoa_r+0x62c>
8000a782:	30 08       	mov	r8,0
8000a784:	fc 19 40 24 	movh	r9,0x4024
8000a788:	ec c4 00 01 	sub	r4,r6,1
8000a78c:	fa ea 00 18 	ld.d	r10,sp[24]
8000a790:	2f f5       	sub	r5,-1
8000a792:	50 64       	stdsp	sp[0x18],r4
8000a794:	e0 a0 0c 38 	rcall	8000c004 <__avr32_f64_mul>
8000a798:	40 94       	lddsp	r4,sp[0x24]
8000a79a:	14 98       	mov	r8,r10
8000a79c:	16 99       	mov	r9,r11
8000a79e:	fa e9 00 08 	st.d	sp[8],r8
8000a7a2:	c0 38       	rjmp	8000a7a8 <_dtoa_r+0x474>
8000a7a4:	50 66       	stdsp	sp[0x18],r6
8000a7a6:	02 94       	mov	r4,r1
8000a7a8:	0a 9c       	mov	r12,r5
8000a7aa:	e0 a0 0e 88 	rcall	8000c4ba <__avr32_s32_to_f64>
8000a7ae:	fa e8 00 08 	ld.d	r8,sp[8]
8000a7b2:	e0 a0 0c 29 	rcall	8000c004 <__avr32_f64_mul>
8000a7b6:	30 08       	mov	r8,0
8000a7b8:	fc 19 40 1c 	movh	r9,0x401c
8000a7bc:	e0 a0 0d de 	rcall	8000c378 <__avr32_f64_add>
8000a7c0:	14 98       	mov	r8,r10
8000a7c2:	16 99       	mov	r9,r11
8000a7c4:	fa e9 00 28 	st.d	sp[40],r8
8000a7c8:	fc 18 fc c0 	movh	r8,0xfcc0
8000a7cc:	40 a5       	lddsp	r5,sp[0x28]
8000a7ce:	10 05       	add	r5,r8
8000a7d0:	50 a5       	stdsp	sp[0x28],r5
8000a7d2:	58 04       	cp.w	r4,0
8000a7d4:	c2 11       	brne	8000a816 <_dtoa_r+0x4e2>
8000a7d6:	fa ea 00 08 	ld.d	r10,sp[8]
8000a7da:	30 08       	mov	r8,0
8000a7dc:	fc 19 40 14 	movh	r9,0x4014
8000a7e0:	e0 a0 0c fe 	rcall	8000c1dc <__avr32_f64_sub>
8000a7e4:	40 bc       	lddsp	r12,sp[0x2c]
8000a7e6:	fa eb 00 08 	st.d	sp[8],r10
8000a7ea:	14 98       	mov	r8,r10
8000a7ec:	16 99       	mov	r9,r11
8000a7ee:	18 9a       	mov	r10,r12
8000a7f0:	0a 9b       	mov	r11,r5
8000a7f2:	e0 a0 0f 1b 	rcall	8000c628 <__avr32_f64_cmp_lt>
8000a7f6:	e0 81 02 54 	brne	8000ac9e <_dtoa_r+0x96a>
8000a7fa:	0a 98       	mov	r8,r5
8000a7fc:	40 b9       	lddsp	r9,sp[0x2c]
8000a7fe:	ee 18 80 00 	eorh	r8,0x8000
8000a802:	fa ea 00 08 	ld.d	r10,sp[8]
8000a806:	10 95       	mov	r5,r8
8000a808:	12 98       	mov	r8,r9
8000a80a:	0a 99       	mov	r9,r5
8000a80c:	e0 a0 0f 0e 	rcall	8000c628 <__avr32_f64_cmp_lt>
8000a810:	e0 81 02 3e 	brne	8000ac8c <_dtoa_r+0x958>
8000a814:	ca 68       	rjmp	8000a960 <_dtoa_r+0x62c>
8000a816:	fe c9 c4 26 	sub	r9,pc,-15322
8000a81a:	e8 c8 00 01 	sub	r8,r4,1
8000a81e:	40 d5       	lddsp	r5,sp[0x34]
8000a820:	58 05       	cp.w	r5,0
8000a822:	c4 f0       	breq	8000a8c0 <_dtoa_r+0x58c>
8000a824:	30 0c       	mov	r12,0
8000a826:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a82a:	51 3c       	stdsp	sp[0x4c],r12
8000a82c:	30 0a       	mov	r10,0
8000a82e:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a832:	e0 a0 0f 2f 	rcall	8000c690 <__avr32_f64_div>
8000a836:	fa e8 00 28 	ld.d	r8,sp[40]
8000a83a:	40 85       	lddsp	r5,sp[0x20]
8000a83c:	e0 a0 0c d0 	rcall	8000c1dc <__avr32_f64_sub>
8000a840:	fa eb 00 28 	st.d	sp[40],r10
8000a844:	fa ea 00 08 	ld.d	r10,sp[8]
8000a848:	e0 a0 0e 22 	rcall	8000c48c <__avr32_f64_to_s32>
8000a84c:	51 6c       	stdsp	sp[0x58],r12
8000a84e:	e0 a0 0e 36 	rcall	8000c4ba <__avr32_s32_to_f64>
8000a852:	14 98       	mov	r8,r10
8000a854:	16 99       	mov	r9,r11
8000a856:	fa ea 00 08 	ld.d	r10,sp[8]
8000a85a:	e0 a0 0c c1 	rcall	8000c1dc <__avr32_f64_sub>
8000a85e:	fa eb 00 08 	st.d	sp[8],r10
8000a862:	41 68       	lddsp	r8,sp[0x58]
8000a864:	2d 08       	sub	r8,-48
8000a866:	0a c8       	st.b	r5++,r8
8000a868:	41 39       	lddsp	r9,sp[0x4c]
8000a86a:	2f f9       	sub	r9,-1
8000a86c:	51 39       	stdsp	sp[0x4c],r9
8000a86e:	fa e8 00 28 	ld.d	r8,sp[40]
8000a872:	e0 a0 0e db 	rcall	8000c628 <__avr32_f64_cmp_lt>
8000a876:	e0 81 03 39 	brne	8000aee8 <_dtoa_r+0xbb4>
8000a87a:	fa e8 00 08 	ld.d	r8,sp[8]
8000a87e:	30 0a       	mov	r10,0
8000a880:	fc 1b 3f f0 	movh	r11,0x3ff0
8000a884:	e0 a0 0c ac 	rcall	8000c1dc <__avr32_f64_sub>
8000a888:	fa e8 00 28 	ld.d	r8,sp[40]
8000a88c:	e0 a0 0e ce 	rcall	8000c628 <__avr32_f64_cmp_lt>
8000a890:	fa ea 00 28 	ld.d	r10,sp[40]
8000a894:	30 08       	mov	r8,0
8000a896:	fc 19 40 24 	movh	r9,0x4024
8000a89a:	e0 81 00 da 	brne	8000aa4e <_dtoa_r+0x71a>
8000a89e:	41 3c       	lddsp	r12,sp[0x4c]
8000a8a0:	08 3c       	cp.w	r12,r4
8000a8a2:	c5 f4       	brge	8000a960 <_dtoa_r+0x62c>
8000a8a4:	e0 a0 0b b0 	rcall	8000c004 <__avr32_f64_mul>
8000a8a8:	30 08       	mov	r8,0
8000a8aa:	fa eb 00 28 	st.d	sp[40],r10
8000a8ae:	fc 19 40 24 	movh	r9,0x4024
8000a8b2:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8b6:	e0 a0 0b a7 	rcall	8000c004 <__avr32_f64_mul>
8000a8ba:	fa eb 00 08 	st.d	sp[8],r10
8000a8be:	cc 3b       	rjmp	8000a844 <_dtoa_r+0x510>
8000a8c0:	40 85       	lddsp	r5,sp[0x20]
8000a8c2:	08 05       	add	r5,r4
8000a8c4:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000a8c8:	51 35       	stdsp	sp[0x4c],r5
8000a8ca:	fa e8 00 28 	ld.d	r8,sp[40]
8000a8ce:	40 85       	lddsp	r5,sp[0x20]
8000a8d0:	e0 a0 0b 9a 	rcall	8000c004 <__avr32_f64_mul>
8000a8d4:	fa eb 00 28 	st.d	sp[40],r10
8000a8d8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8dc:	e0 a0 0d d8 	rcall	8000c48c <__avr32_f64_to_s32>
8000a8e0:	51 6c       	stdsp	sp[0x58],r12
8000a8e2:	e0 a0 0d ec 	rcall	8000c4ba <__avr32_s32_to_f64>
8000a8e6:	14 98       	mov	r8,r10
8000a8e8:	16 99       	mov	r9,r11
8000a8ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8ee:	e0 a0 0c 77 	rcall	8000c1dc <__avr32_f64_sub>
8000a8f2:	fa eb 00 08 	st.d	sp[8],r10
8000a8f6:	41 68       	lddsp	r8,sp[0x58]
8000a8f8:	2d 08       	sub	r8,-48
8000a8fa:	0a c8       	st.b	r5++,r8
8000a8fc:	41 3c       	lddsp	r12,sp[0x4c]
8000a8fe:	18 35       	cp.w	r5,r12
8000a900:	c2 81       	brne	8000a950 <_dtoa_r+0x61c>
8000a902:	30 08       	mov	r8,0
8000a904:	fc 19 3f e0 	movh	r9,0x3fe0
8000a908:	fa ea 00 28 	ld.d	r10,sp[40]
8000a90c:	e0 a0 0d 36 	rcall	8000c378 <__avr32_f64_add>
8000a910:	40 85       	lddsp	r5,sp[0x20]
8000a912:	fa e8 00 08 	ld.d	r8,sp[8]
8000a916:	08 05       	add	r5,r4
8000a918:	e0 a0 0e 88 	rcall	8000c628 <__avr32_f64_cmp_lt>
8000a91c:	e0 81 00 99 	brne	8000aa4e <_dtoa_r+0x71a>
8000a920:	fa e8 00 28 	ld.d	r8,sp[40]
8000a924:	30 0a       	mov	r10,0
8000a926:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a92a:	e0 a0 0c 59 	rcall	8000c1dc <__avr32_f64_sub>
8000a92e:	14 98       	mov	r8,r10
8000a930:	16 99       	mov	r9,r11
8000a932:	fa ea 00 08 	ld.d	r10,sp[8]
8000a936:	e0 a0 0e 79 	rcall	8000c628 <__avr32_f64_cmp_lt>
8000a93a:	c1 30       	breq	8000a960 <_dtoa_r+0x62c>
8000a93c:	33 09       	mov	r9,48
8000a93e:	0a 98       	mov	r8,r5
8000a940:	11 7a       	ld.ub	r10,--r8
8000a942:	f2 0a 18 00 	cp.b	r10,r9
8000a946:	e0 81 02 d1 	brne	8000aee8 <_dtoa_r+0xbb4>
8000a94a:	10 95       	mov	r5,r8
8000a94c:	cf 9b       	rjmp	8000a93e <_dtoa_r+0x60a>
8000a94e:	d7 03       	nop
8000a950:	30 08       	mov	r8,0
8000a952:	fc 19 40 24 	movh	r9,0x4024
8000a956:	e0 a0 0b 57 	rcall	8000c004 <__avr32_f64_mul>
8000a95a:	fa eb 00 08 	st.d	sp[8],r10
8000a95e:	cb db       	rjmp	8000a8d8 <_dtoa_r+0x5a4>
8000a960:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a964:	fa eb 00 08 	st.d	sp[8],r10
8000a968:	58 e6       	cp.w	r6,14
8000a96a:	5f ab       	srle	r11
8000a96c:	41 8a       	lddsp	r10,sp[0x60]
8000a96e:	30 08       	mov	r8,0
8000a970:	f4 09 11 ff 	rsub	r9,r10,-1
8000a974:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000a978:	f0 09 18 00 	cp.b	r9,r8
8000a97c:	e0 80 00 82 	breq	8000aa80 <_dtoa_r+0x74c>
8000a980:	40 ea       	lddsp	r10,sp[0x38]
8000a982:	58 01       	cp.w	r1,0
8000a984:	5f a9       	srle	r9
8000a986:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000a98a:	fe ca c5 9a 	sub	r10,pc,-14950
8000a98e:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000a992:	fa e5 00 10 	st.d	sp[16],r4
8000a996:	f0 09 18 00 	cp.b	r9,r8
8000a99a:	c1 40       	breq	8000a9c2 <_dtoa_r+0x68e>
8000a99c:	58 01       	cp.w	r1,0
8000a99e:	e0 81 01 77 	brne	8000ac8c <_dtoa_r+0x958>
8000a9a2:	30 08       	mov	r8,0
8000a9a4:	fc 19 40 14 	movh	r9,0x4014
8000a9a8:	08 9a       	mov	r10,r4
8000a9aa:	0a 9b       	mov	r11,r5
8000a9ac:	e0 a0 0b 2c 	rcall	8000c004 <__avr32_f64_mul>
8000a9b0:	fa e8 00 08 	ld.d	r8,sp[8]
8000a9b4:	e0 a0 0e 06 	rcall	8000c5c0 <__avr32_f64_cmp_ge>
8000a9b8:	e0 81 01 6a 	brne	8000ac8c <_dtoa_r+0x958>
8000a9bc:	02 92       	mov	r2,r1
8000a9be:	e0 8f 01 72 	bral	8000aca2 <_dtoa_r+0x96e>
8000a9c2:	40 85       	lddsp	r5,sp[0x20]
8000a9c4:	30 14       	mov	r4,1
8000a9c6:	fa e8 00 10 	ld.d	r8,sp[16]
8000a9ca:	fa ea 00 08 	ld.d	r10,sp[8]
8000a9ce:	e0 a0 0e 61 	rcall	8000c690 <__avr32_f64_div>
8000a9d2:	e0 a0 0d 5d 	rcall	8000c48c <__avr32_f64_to_s32>
8000a9d6:	18 92       	mov	r2,r12
8000a9d8:	e0 a0 0d 71 	rcall	8000c4ba <__avr32_s32_to_f64>
8000a9dc:	fa e8 00 10 	ld.d	r8,sp[16]
8000a9e0:	e0 a0 0b 12 	rcall	8000c004 <__avr32_f64_mul>
8000a9e4:	14 98       	mov	r8,r10
8000a9e6:	16 99       	mov	r9,r11
8000a9e8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a9ec:	e0 a0 0b f8 	rcall	8000c1dc <__avr32_f64_sub>
8000a9f0:	fa eb 00 08 	st.d	sp[8],r10
8000a9f4:	e4 c8 ff d0 	sub	r8,r2,-48
8000a9f8:	0a c8       	st.b	r5++,r8
8000a9fa:	fc 19 40 24 	movh	r9,0x4024
8000a9fe:	30 08       	mov	r8,0
8000aa00:	02 34       	cp.w	r4,r1
8000aa02:	c3 31       	brne	8000aa68 <_dtoa_r+0x734>
8000aa04:	fa e8 00 08 	ld.d	r8,sp[8]
8000aa08:	e0 a0 0c b8 	rcall	8000c378 <__avr32_f64_add>
8000aa0c:	16 91       	mov	r1,r11
8000aa0e:	14 90       	mov	r0,r10
8000aa10:	14 98       	mov	r8,r10
8000aa12:	02 99       	mov	r9,r1
8000aa14:	fa ea 00 10 	ld.d	r10,sp[16]
8000aa18:	e0 a0 0e 08 	rcall	8000c628 <__avr32_f64_cmp_lt>
8000aa1c:	c1 a1       	brne	8000aa50 <_dtoa_r+0x71c>
8000aa1e:	fa e8 00 10 	ld.d	r8,sp[16]
8000aa22:	00 9a       	mov	r10,r0
8000aa24:	02 9b       	mov	r11,r1
8000aa26:	e0 a0 0d ba 	rcall	8000c59a <__avr32_f64_cmp_eq>
8000aa2a:	e0 80 02 5e 	breq	8000aee6 <_dtoa_r+0xbb2>
8000aa2e:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000aa32:	c0 f1       	brne	8000aa50 <_dtoa_r+0x71c>
8000aa34:	e0 8f 02 59 	bral	8000aee6 <_dtoa_r+0xbb2>
8000aa38:	40 8a       	lddsp	r10,sp[0x20]
8000aa3a:	14 38       	cp.w	r8,r10
8000aa3c:	c0 30       	breq	8000aa42 <_dtoa_r+0x70e>
8000aa3e:	10 95       	mov	r5,r8
8000aa40:	c0 98       	rjmp	8000aa52 <_dtoa_r+0x71e>
8000aa42:	33 08       	mov	r8,48
8000aa44:	40 89       	lddsp	r9,sp[0x20]
8000aa46:	2f f6       	sub	r6,-1
8000aa48:	b2 88       	st.b	r9[0x0],r8
8000aa4a:	40 88       	lddsp	r8,sp[0x20]
8000aa4c:	c0 88       	rjmp	8000aa5c <_dtoa_r+0x728>
8000aa4e:	40 66       	lddsp	r6,sp[0x18]
8000aa50:	33 99       	mov	r9,57
8000aa52:	0a 98       	mov	r8,r5
8000aa54:	11 7a       	ld.ub	r10,--r8
8000aa56:	f2 0a 18 00 	cp.b	r10,r9
8000aa5a:	ce f0       	breq	8000aa38 <_dtoa_r+0x704>
8000aa5c:	50 66       	stdsp	sp[0x18],r6
8000aa5e:	11 89       	ld.ub	r9,r8[0x0]
8000aa60:	2f f9       	sub	r9,-1
8000aa62:	b0 89       	st.b	r8[0x0],r9
8000aa64:	e0 8f 02 42 	bral	8000aee8 <_dtoa_r+0xbb4>
8000aa68:	e0 a0 0a ce 	rcall	8000c004 <__avr32_f64_mul>
8000aa6c:	2f f4       	sub	r4,-1
8000aa6e:	fa eb 00 08 	st.d	sp[8],r10
8000aa72:	30 08       	mov	r8,0
8000aa74:	30 09       	mov	r9,0
8000aa76:	e0 a0 0d 92 	rcall	8000c59a <__avr32_f64_cmp_eq>
8000aa7a:	ca 60       	breq	8000a9c6 <_dtoa_r+0x692>
8000aa7c:	e0 8f 02 35 	bral	8000aee6 <_dtoa_r+0xbb2>
8000aa80:	40 d8       	lddsp	r8,sp[0x34]
8000aa82:	58 08       	cp.w	r8,0
8000aa84:	c0 51       	brne	8000aa8e <_dtoa_r+0x75a>
8000aa86:	04 98       	mov	r8,r2
8000aa88:	00 95       	mov	r5,r0
8000aa8a:	40 d4       	lddsp	r4,sp[0x34]
8000aa8c:	c3 78       	rjmp	8000aafa <_dtoa_r+0x7c6>
8000aa8e:	40 c5       	lddsp	r5,sp[0x30]
8000aa90:	58 15       	cp.w	r5,1
8000aa92:	e0 89 00 0f 	brgt	8000aab0 <_dtoa_r+0x77c>
8000aa96:	41 74       	lddsp	r4,sp[0x5c]
8000aa98:	58 04       	cp.w	r4,0
8000aa9a:	c0 40       	breq	8000aaa2 <_dtoa_r+0x76e>
8000aa9c:	f4 c9 fb cd 	sub	r9,r10,-1075
8000aaa0:	c0 48       	rjmp	8000aaa8 <_dtoa_r+0x774>
8000aaa2:	41 99       	lddsp	r9,sp[0x64]
8000aaa4:	f2 09 11 36 	rsub	r9,r9,54
8000aaa8:	04 98       	mov	r8,r2
8000aaaa:	00 95       	mov	r5,r0
8000aaac:	c1 c8       	rjmp	8000aae4 <_dtoa_r+0x7b0>
8000aaae:	d7 03       	nop
8000aab0:	e2 c8 00 01 	sub	r8,r1,1
8000aab4:	58 01       	cp.w	r1,0
8000aab6:	e0 05 17 40 	movge	r5,r0
8000aaba:	e2 09 17 40 	movge	r9,r1
8000aabe:	e1 d1 e5 15 	sublt	r5,r0,r1
8000aac2:	f9 b9 05 00 	movlt	r9,0
8000aac6:	10 32       	cp.w	r2,r8
8000aac8:	e5 d8 e4 18 	subge	r8,r2,r8
8000aacc:	f1 d2 e5 18 	sublt	r8,r8,r2
8000aad0:	e5 d8 e5 02 	addlt	r2,r2,r8
8000aad4:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000aad8:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000aadc:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000aae0:	f9 b8 05 00 	movlt	r8,0
8000aae4:	40 4b       	lddsp	r11,sp[0x10]
8000aae6:	12 0b       	add	r11,r9
8000aae8:	50 08       	stdsp	sp[0x0],r8
8000aaea:	50 4b       	stdsp	sp[0x10],r11
8000aaec:	12 00       	add	r0,r9
8000aaee:	30 1b       	mov	r11,1
8000aaf0:	0e 9c       	mov	r12,r7
8000aaf2:	e0 a0 08 a7 	rcall	8000bc40 <__i2b>
8000aaf6:	40 08       	lddsp	r8,sp[0x0]
8000aaf8:	18 94       	mov	r4,r12
8000aafa:	40 4a       	lddsp	r10,sp[0x10]
8000aafc:	58 05       	cp.w	r5,0
8000aafe:	5f 99       	srgt	r9
8000ab00:	58 0a       	cp.w	r10,0
8000ab02:	5f 9a       	srgt	r10
8000ab04:	f5 e9 00 09 	and	r9,r10,r9
8000ab08:	c0 80       	breq	8000ab18 <_dtoa_r+0x7e4>
8000ab0a:	40 4c       	lddsp	r12,sp[0x10]
8000ab0c:	f8 05 0d 49 	min	r9,r12,r5
8000ab10:	12 1c       	sub	r12,r9
8000ab12:	12 10       	sub	r0,r9
8000ab14:	50 4c       	stdsp	sp[0x10],r12
8000ab16:	12 15       	sub	r5,r9
8000ab18:	58 02       	cp.w	r2,0
8000ab1a:	e0 8a 00 27 	brle	8000ab68 <_dtoa_r+0x834>
8000ab1e:	40 db       	lddsp	r11,sp[0x34]
8000ab20:	58 0b       	cp.w	r11,0
8000ab22:	c1 d0       	breq	8000ab5c <_dtoa_r+0x828>
8000ab24:	58 08       	cp.w	r8,0
8000ab26:	e0 8a 00 17 	brle	8000ab54 <_dtoa_r+0x820>
8000ab2a:	10 9a       	mov	r10,r8
8000ab2c:	50 08       	stdsp	sp[0x0],r8
8000ab2e:	08 9b       	mov	r11,r4
8000ab30:	0e 9c       	mov	r12,r7
8000ab32:	e0 a0 08 cd 	rcall	8000bccc <__pow5mult>
8000ab36:	06 9a       	mov	r10,r3
8000ab38:	18 9b       	mov	r11,r12
8000ab3a:	18 94       	mov	r4,r12
8000ab3c:	0e 9c       	mov	r12,r7
8000ab3e:	e0 a0 08 01 	rcall	8000bb40 <__multiply>
8000ab42:	18 99       	mov	r9,r12
8000ab44:	06 9b       	mov	r11,r3
8000ab46:	50 19       	stdsp	sp[0x4],r9
8000ab48:	0e 9c       	mov	r12,r7
8000ab4a:	e0 a0 06 ad 	rcall	8000b8a4 <_Bfree>
8000ab4e:	40 19       	lddsp	r9,sp[0x4]
8000ab50:	40 08       	lddsp	r8,sp[0x0]
8000ab52:	12 93       	mov	r3,r9
8000ab54:	e4 08 01 0a 	sub	r10,r2,r8
8000ab58:	c0 80       	breq	8000ab68 <_dtoa_r+0x834>
8000ab5a:	c0 28       	rjmp	8000ab5e <_dtoa_r+0x82a>
8000ab5c:	04 9a       	mov	r10,r2
8000ab5e:	06 9b       	mov	r11,r3
8000ab60:	0e 9c       	mov	r12,r7
8000ab62:	e0 a0 08 b5 	rcall	8000bccc <__pow5mult>
8000ab66:	18 93       	mov	r3,r12
8000ab68:	30 1b       	mov	r11,1
8000ab6a:	0e 9c       	mov	r12,r7
8000ab6c:	e0 a0 08 6a 	rcall	8000bc40 <__i2b>
8000ab70:	41 1a       	lddsp	r10,sp[0x44]
8000ab72:	18 92       	mov	r2,r12
8000ab74:	58 0a       	cp.w	r10,0
8000ab76:	e0 8a 00 07 	brle	8000ab84 <_dtoa_r+0x850>
8000ab7a:	18 9b       	mov	r11,r12
8000ab7c:	0e 9c       	mov	r12,r7
8000ab7e:	e0 a0 08 a7 	rcall	8000bccc <__pow5mult>
8000ab82:	18 92       	mov	r2,r12
8000ab84:	40 c9       	lddsp	r9,sp[0x30]
8000ab86:	58 19       	cp.w	r9,1
8000ab88:	e0 89 00 14 	brgt	8000abb0 <_dtoa_r+0x87c>
8000ab8c:	40 38       	lddsp	r8,sp[0xc]
8000ab8e:	58 08       	cp.w	r8,0
8000ab90:	c1 01       	brne	8000abb0 <_dtoa_r+0x87c>
8000ab92:	40 29       	lddsp	r9,sp[0x8]
8000ab94:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000ab98:	c0 c1       	brne	8000abb0 <_dtoa_r+0x87c>
8000ab9a:	12 98       	mov	r8,r9
8000ab9c:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000aba0:	c0 80       	breq	8000abb0 <_dtoa_r+0x87c>
8000aba2:	40 4c       	lddsp	r12,sp[0x10]
8000aba4:	30 1b       	mov	r11,1
8000aba6:	2f fc       	sub	r12,-1
8000aba8:	2f f0       	sub	r0,-1
8000abaa:	50 4c       	stdsp	sp[0x10],r12
8000abac:	50 6b       	stdsp	sp[0x18],r11
8000abae:	c0 38       	rjmp	8000abb4 <_dtoa_r+0x880>
8000abb0:	30 0a       	mov	r10,0
8000abb2:	50 6a       	stdsp	sp[0x18],r10
8000abb4:	41 19       	lddsp	r9,sp[0x44]
8000abb6:	58 09       	cp.w	r9,0
8000abb8:	c0 31       	brne	8000abbe <_dtoa_r+0x88a>
8000abba:	30 1c       	mov	r12,1
8000abbc:	c0 98       	rjmp	8000abce <_dtoa_r+0x89a>
8000abbe:	64 48       	ld.w	r8,r2[0x10]
8000abc0:	2f c8       	sub	r8,-4
8000abc2:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000abc6:	e0 a0 05 df 	rcall	8000b784 <__hi0bits>
8000abca:	f8 0c 11 20 	rsub	r12,r12,32
8000abce:	40 4b       	lddsp	r11,sp[0x10]
8000abd0:	f8 0b 00 08 	add	r8,r12,r11
8000abd4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000abd8:	c0 c0       	breq	8000abf0 <_dtoa_r+0x8bc>
8000abda:	f0 08 11 20 	rsub	r8,r8,32
8000abde:	58 48       	cp.w	r8,4
8000abe0:	e0 8a 00 06 	brle	8000abec <_dtoa_r+0x8b8>
8000abe4:	20 48       	sub	r8,4
8000abe6:	10 0b       	add	r11,r8
8000abe8:	50 4b       	stdsp	sp[0x10],r11
8000abea:	c0 78       	rjmp	8000abf8 <_dtoa_r+0x8c4>
8000abec:	58 48       	cp.w	r8,4
8000abee:	c0 70       	breq	8000abfc <_dtoa_r+0x8c8>
8000abf0:	40 4a       	lddsp	r10,sp[0x10]
8000abf2:	2e 48       	sub	r8,-28
8000abf4:	10 0a       	add	r10,r8
8000abf6:	50 4a       	stdsp	sp[0x10],r10
8000abf8:	10 00       	add	r0,r8
8000abfa:	10 05       	add	r5,r8
8000abfc:	58 00       	cp.w	r0,0
8000abfe:	e0 8a 00 08 	brle	8000ac0e <_dtoa_r+0x8da>
8000ac02:	06 9b       	mov	r11,r3
8000ac04:	00 9a       	mov	r10,r0
8000ac06:	0e 9c       	mov	r12,r7
8000ac08:	e0 a0 07 58 	rcall	8000bab8 <__lshift>
8000ac0c:	18 93       	mov	r3,r12
8000ac0e:	40 49       	lddsp	r9,sp[0x10]
8000ac10:	58 09       	cp.w	r9,0
8000ac12:	e0 8a 00 08 	brle	8000ac22 <_dtoa_r+0x8ee>
8000ac16:	04 9b       	mov	r11,r2
8000ac18:	12 9a       	mov	r10,r9
8000ac1a:	0e 9c       	mov	r12,r7
8000ac1c:	e0 a0 07 4e 	rcall	8000bab8 <__lshift>
8000ac20:	18 92       	mov	r2,r12
8000ac22:	41 48       	lddsp	r8,sp[0x50]
8000ac24:	58 08       	cp.w	r8,0
8000ac26:	c1 b0       	breq	8000ac5c <_dtoa_r+0x928>
8000ac28:	04 9b       	mov	r11,r2
8000ac2a:	06 9c       	mov	r12,r3
8000ac2c:	e0 a0 06 23 	rcall	8000b872 <__mcmp>
8000ac30:	c1 64       	brge	8000ac5c <_dtoa_r+0x928>
8000ac32:	06 9b       	mov	r11,r3
8000ac34:	30 09       	mov	r9,0
8000ac36:	30 aa       	mov	r10,10
8000ac38:	0e 9c       	mov	r12,r7
8000ac3a:	e0 a0 08 0b 	rcall	8000bc50 <__multadd>
8000ac3e:	20 16       	sub	r6,1
8000ac40:	18 93       	mov	r3,r12
8000ac42:	40 dc       	lddsp	r12,sp[0x34]
8000ac44:	58 0c       	cp.w	r12,0
8000ac46:	c0 31       	brne	8000ac4c <_dtoa_r+0x918>
8000ac48:	40 91       	lddsp	r1,sp[0x24]
8000ac4a:	c0 98       	rjmp	8000ac5c <_dtoa_r+0x928>
8000ac4c:	08 9b       	mov	r11,r4
8000ac4e:	40 91       	lddsp	r1,sp[0x24]
8000ac50:	30 09       	mov	r9,0
8000ac52:	30 aa       	mov	r10,10
8000ac54:	0e 9c       	mov	r12,r7
8000ac56:	e0 a0 07 fd 	rcall	8000bc50 <__multadd>
8000ac5a:	18 94       	mov	r4,r12
8000ac5c:	58 01       	cp.w	r1,0
8000ac5e:	5f a9       	srle	r9
8000ac60:	40 cb       	lddsp	r11,sp[0x30]
8000ac62:	58 2b       	cp.w	r11,2
8000ac64:	5f 98       	srgt	r8
8000ac66:	f3 e8 00 08 	and	r8,r9,r8
8000ac6a:	c2 50       	breq	8000acb4 <_dtoa_r+0x980>
8000ac6c:	58 01       	cp.w	r1,0
8000ac6e:	c1 11       	brne	8000ac90 <_dtoa_r+0x95c>
8000ac70:	04 9b       	mov	r11,r2
8000ac72:	02 99       	mov	r9,r1
8000ac74:	30 5a       	mov	r10,5
8000ac76:	0e 9c       	mov	r12,r7
8000ac78:	e0 a0 07 ec 	rcall	8000bc50 <__multadd>
8000ac7c:	18 92       	mov	r2,r12
8000ac7e:	18 9b       	mov	r11,r12
8000ac80:	06 9c       	mov	r12,r3
8000ac82:	e0 a0 05 f8 	rcall	8000b872 <__mcmp>
8000ac86:	e0 89 00 0f 	brgt	8000aca4 <_dtoa_r+0x970>
8000ac8a:	c0 38       	rjmp	8000ac90 <_dtoa_r+0x95c>
8000ac8c:	30 02       	mov	r2,0
8000ac8e:	04 94       	mov	r4,r2
8000ac90:	40 ea       	lddsp	r10,sp[0x38]
8000ac92:	30 09       	mov	r9,0
8000ac94:	5c da       	com	r10
8000ac96:	40 85       	lddsp	r5,sp[0x20]
8000ac98:	50 6a       	stdsp	sp[0x18],r10
8000ac9a:	50 49       	stdsp	sp[0x10],r9
8000ac9c:	c0 f9       	rjmp	8000aeba <_dtoa_r+0xb86>
8000ac9e:	08 92       	mov	r2,r4
8000aca0:	40 66       	lddsp	r6,sp[0x18]
8000aca2:	04 94       	mov	r4,r2
8000aca4:	2f f6       	sub	r6,-1
8000aca6:	50 66       	stdsp	sp[0x18],r6
8000aca8:	33 18       	mov	r8,49
8000acaa:	40 85       	lddsp	r5,sp[0x20]
8000acac:	0a c8       	st.b	r5++,r8
8000acae:	30 08       	mov	r8,0
8000acb0:	50 48       	stdsp	sp[0x10],r8
8000acb2:	c0 49       	rjmp	8000aeba <_dtoa_r+0xb86>
8000acb4:	40 dc       	lddsp	r12,sp[0x34]
8000acb6:	58 0c       	cp.w	r12,0
8000acb8:	e0 80 00 b5 	breq	8000ae22 <_dtoa_r+0xaee>
8000acbc:	58 05       	cp.w	r5,0
8000acbe:	e0 8a 00 08 	brle	8000acce <_dtoa_r+0x99a>
8000acc2:	08 9b       	mov	r11,r4
8000acc4:	0a 9a       	mov	r10,r5
8000acc6:	0e 9c       	mov	r12,r7
8000acc8:	e0 a0 06 f8 	rcall	8000bab8 <__lshift>
8000accc:	18 94       	mov	r4,r12
8000acce:	40 6b       	lddsp	r11,sp[0x18]
8000acd0:	58 0b       	cp.w	r11,0
8000acd2:	c0 31       	brne	8000acd8 <_dtoa_r+0x9a4>
8000acd4:	08 9c       	mov	r12,r4
8000acd6:	c1 38       	rjmp	8000acfc <_dtoa_r+0x9c8>
8000acd8:	68 1b       	ld.w	r11,r4[0x4]
8000acda:	0e 9c       	mov	r12,r7
8000acdc:	e0 a0 05 fe 	rcall	8000b8d8 <_Balloc>
8000ace0:	68 4a       	ld.w	r10,r4[0x10]
8000ace2:	18 95       	mov	r5,r12
8000ace4:	e8 cb ff f4 	sub	r11,r4,-12
8000ace8:	2f ea       	sub	r10,-2
8000acea:	2f 4c       	sub	r12,-12
8000acec:	a3 6a       	lsl	r10,0x2
8000acee:	fe b0 e6 4f 	rcall	8000798c <memcpy>
8000acf2:	0a 9b       	mov	r11,r5
8000acf4:	30 1a       	mov	r10,1
8000acf6:	0e 9c       	mov	r12,r7
8000acf8:	e0 a0 06 e0 	rcall	8000bab8 <__lshift>
8000acfc:	50 44       	stdsp	sp[0x10],r4
8000acfe:	40 3a       	lddsp	r10,sp[0xc]
8000ad00:	30 19       	mov	r9,1
8000ad02:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ad06:	18 94       	mov	r4,r12
8000ad08:	50 da       	stdsp	sp[0x34],r10
8000ad0a:	40 85       	lddsp	r5,sp[0x20]
8000ad0c:	50 99       	stdsp	sp[0x24],r9
8000ad0e:	50 26       	stdsp	sp[0x8],r6
8000ad10:	50 e1       	stdsp	sp[0x38],r1
8000ad12:	04 9b       	mov	r11,r2
8000ad14:	06 9c       	mov	r12,r3
8000ad16:	fe b0 fa 7f 	rcall	8000a214 <quorem>
8000ad1a:	40 4b       	lddsp	r11,sp[0x10]
8000ad1c:	f8 c0 ff d0 	sub	r0,r12,-48
8000ad20:	06 9c       	mov	r12,r3
8000ad22:	e0 a0 05 a8 	rcall	8000b872 <__mcmp>
8000ad26:	08 9a       	mov	r10,r4
8000ad28:	50 6c       	stdsp	sp[0x18],r12
8000ad2a:	04 9b       	mov	r11,r2
8000ad2c:	0e 9c       	mov	r12,r7
8000ad2e:	e0 a0 06 5d 	rcall	8000b9e8 <__mdiff>
8000ad32:	18 91       	mov	r1,r12
8000ad34:	78 38       	ld.w	r8,r12[0xc]
8000ad36:	58 08       	cp.w	r8,0
8000ad38:	c0 30       	breq	8000ad3e <_dtoa_r+0xa0a>
8000ad3a:	30 16       	mov	r6,1
8000ad3c:	c0 68       	rjmp	8000ad48 <_dtoa_r+0xa14>
8000ad3e:	18 9b       	mov	r11,r12
8000ad40:	06 9c       	mov	r12,r3
8000ad42:	e0 a0 05 98 	rcall	8000b872 <__mcmp>
8000ad46:	18 96       	mov	r6,r12
8000ad48:	0e 9c       	mov	r12,r7
8000ad4a:	02 9b       	mov	r11,r1
8000ad4c:	e0 a0 05 ac 	rcall	8000b8a4 <_Bfree>
8000ad50:	40 cc       	lddsp	r12,sp[0x30]
8000ad52:	ed ec 10 08 	or	r8,r6,r12
8000ad56:	c0 d1       	brne	8000ad70 <_dtoa_r+0xa3c>
8000ad58:	40 db       	lddsp	r11,sp[0x34]
8000ad5a:	58 0b       	cp.w	r11,0
8000ad5c:	c0 a1       	brne	8000ad70 <_dtoa_r+0xa3c>
8000ad5e:	40 26       	lddsp	r6,sp[0x8]
8000ad60:	e0 40 00 39 	cp.w	r0,57
8000ad64:	c3 00       	breq	8000adc4 <_dtoa_r+0xa90>
8000ad66:	40 6a       	lddsp	r10,sp[0x18]
8000ad68:	58 0a       	cp.w	r10,0
8000ad6a:	e0 89 00 24 	brgt	8000adb2 <_dtoa_r+0xa7e>
8000ad6e:	c2 f8       	rjmp	8000adcc <_dtoa_r+0xa98>
8000ad70:	40 69       	lddsp	r9,sp[0x18]
8000ad72:	58 09       	cp.w	r9,0
8000ad74:	c0 85       	brlt	8000ad84 <_dtoa_r+0xa50>
8000ad76:	12 98       	mov	r8,r9
8000ad78:	40 cc       	lddsp	r12,sp[0x30]
8000ad7a:	18 48       	or	r8,r12
8000ad7c:	c1 d1       	brne	8000adb6 <_dtoa_r+0xa82>
8000ad7e:	40 db       	lddsp	r11,sp[0x34]
8000ad80:	58 0b       	cp.w	r11,0
8000ad82:	c1 a1       	brne	8000adb6 <_dtoa_r+0xa82>
8000ad84:	0c 99       	mov	r9,r6
8000ad86:	40 26       	lddsp	r6,sp[0x8]
8000ad88:	58 09       	cp.w	r9,0
8000ad8a:	e0 8a 00 21 	brle	8000adcc <_dtoa_r+0xa98>
8000ad8e:	06 9b       	mov	r11,r3
8000ad90:	30 1a       	mov	r10,1
8000ad92:	0e 9c       	mov	r12,r7
8000ad94:	e0 a0 06 92 	rcall	8000bab8 <__lshift>
8000ad98:	04 9b       	mov	r11,r2
8000ad9a:	18 93       	mov	r3,r12
8000ad9c:	e0 a0 05 6b 	rcall	8000b872 <__mcmp>
8000ada0:	e0 89 00 06 	brgt	8000adac <_dtoa_r+0xa78>
8000ada4:	c1 41       	brne	8000adcc <_dtoa_r+0xa98>
8000ada6:	ed b0 00 00 	bld	r0,0x0
8000adaa:	c1 11       	brne	8000adcc <_dtoa_r+0xa98>
8000adac:	e0 40 00 39 	cp.w	r0,57
8000adb0:	c0 a0       	breq	8000adc4 <_dtoa_r+0xa90>
8000adb2:	2f f0       	sub	r0,-1
8000adb4:	c0 c8       	rjmp	8000adcc <_dtoa_r+0xa98>
8000adb6:	58 06       	cp.w	r6,0
8000adb8:	e0 8a 00 0c 	brle	8000add0 <_dtoa_r+0xa9c>
8000adbc:	40 26       	lddsp	r6,sp[0x8]
8000adbe:	e0 40 00 39 	cp.w	r0,57
8000adc2:	c0 41       	brne	8000adca <_dtoa_r+0xa96>
8000adc4:	33 98       	mov	r8,57
8000adc6:	0a c8       	st.b	r5++,r8
8000adc8:	c6 78       	rjmp	8000ae96 <_dtoa_r+0xb62>
8000adca:	2f f0       	sub	r0,-1
8000adcc:	0a c0       	st.b	r5++,r0
8000adce:	c7 58       	rjmp	8000aeb8 <_dtoa_r+0xb84>
8000add0:	0a c0       	st.b	r5++,r0
8000add2:	40 9a       	lddsp	r10,sp[0x24]
8000add4:	40 e9       	lddsp	r9,sp[0x38]
8000add6:	12 3a       	cp.w	r10,r9
8000add8:	c4 30       	breq	8000ae5e <_dtoa_r+0xb2a>
8000adda:	06 9b       	mov	r11,r3
8000addc:	30 09       	mov	r9,0
8000adde:	30 aa       	mov	r10,10
8000ade0:	0e 9c       	mov	r12,r7
8000ade2:	e0 a0 07 37 	rcall	8000bc50 <__multadd>
8000ade6:	40 48       	lddsp	r8,sp[0x10]
8000ade8:	18 93       	mov	r3,r12
8000adea:	08 38       	cp.w	r8,r4
8000adec:	c0 91       	brne	8000adfe <_dtoa_r+0xaca>
8000adee:	10 9b       	mov	r11,r8
8000adf0:	30 09       	mov	r9,0
8000adf2:	30 aa       	mov	r10,10
8000adf4:	0e 9c       	mov	r12,r7
8000adf6:	e0 a0 07 2d 	rcall	8000bc50 <__multadd>
8000adfa:	50 4c       	stdsp	sp[0x10],r12
8000adfc:	c0 e8       	rjmp	8000ae18 <_dtoa_r+0xae4>
8000adfe:	40 4b       	lddsp	r11,sp[0x10]
8000ae00:	30 09       	mov	r9,0
8000ae02:	30 aa       	mov	r10,10
8000ae04:	0e 9c       	mov	r12,r7
8000ae06:	e0 a0 07 25 	rcall	8000bc50 <__multadd>
8000ae0a:	08 9b       	mov	r11,r4
8000ae0c:	50 4c       	stdsp	sp[0x10],r12
8000ae0e:	30 09       	mov	r9,0
8000ae10:	30 aa       	mov	r10,10
8000ae12:	0e 9c       	mov	r12,r7
8000ae14:	e0 a0 07 1e 	rcall	8000bc50 <__multadd>
8000ae18:	18 94       	mov	r4,r12
8000ae1a:	40 9c       	lddsp	r12,sp[0x24]
8000ae1c:	2f fc       	sub	r12,-1
8000ae1e:	50 9c       	stdsp	sp[0x24],r12
8000ae20:	c7 9b       	rjmp	8000ad12 <_dtoa_r+0x9de>
8000ae22:	30 18       	mov	r8,1
8000ae24:	06 90       	mov	r0,r3
8000ae26:	40 85       	lddsp	r5,sp[0x20]
8000ae28:	08 93       	mov	r3,r4
8000ae2a:	0c 94       	mov	r4,r6
8000ae2c:	10 96       	mov	r6,r8
8000ae2e:	04 9b       	mov	r11,r2
8000ae30:	00 9c       	mov	r12,r0
8000ae32:	fe b0 f9 f1 	rcall	8000a214 <quorem>
8000ae36:	2d 0c       	sub	r12,-48
8000ae38:	0a cc       	st.b	r5++,r12
8000ae3a:	02 36       	cp.w	r6,r1
8000ae3c:	c0 a4       	brge	8000ae50 <_dtoa_r+0xb1c>
8000ae3e:	00 9b       	mov	r11,r0
8000ae40:	30 09       	mov	r9,0
8000ae42:	30 aa       	mov	r10,10
8000ae44:	0e 9c       	mov	r12,r7
8000ae46:	2f f6       	sub	r6,-1
8000ae48:	e0 a0 07 04 	rcall	8000bc50 <__multadd>
8000ae4c:	18 90       	mov	r0,r12
8000ae4e:	cf 0b       	rjmp	8000ae2e <_dtoa_r+0xafa>
8000ae50:	08 96       	mov	r6,r4
8000ae52:	30 0b       	mov	r11,0
8000ae54:	06 94       	mov	r4,r3
8000ae56:	50 4b       	stdsp	sp[0x10],r11
8000ae58:	00 93       	mov	r3,r0
8000ae5a:	18 90       	mov	r0,r12
8000ae5c:	c0 28       	rjmp	8000ae60 <_dtoa_r+0xb2c>
8000ae5e:	40 26       	lddsp	r6,sp[0x8]
8000ae60:	06 9b       	mov	r11,r3
8000ae62:	30 1a       	mov	r10,1
8000ae64:	0e 9c       	mov	r12,r7
8000ae66:	e0 a0 06 29 	rcall	8000bab8 <__lshift>
8000ae6a:	04 9b       	mov	r11,r2
8000ae6c:	18 93       	mov	r3,r12
8000ae6e:	e0 a0 05 02 	rcall	8000b872 <__mcmp>
8000ae72:	e0 89 00 12 	brgt	8000ae96 <_dtoa_r+0xb62>
8000ae76:	c1 b1       	brne	8000aeac <_dtoa_r+0xb78>
8000ae78:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000ae7c:	c0 d1       	brne	8000ae96 <_dtoa_r+0xb62>
8000ae7e:	c1 78       	rjmp	8000aeac <_dtoa_r+0xb78>
8000ae80:	40 89       	lddsp	r9,sp[0x20]
8000ae82:	12 38       	cp.w	r8,r9
8000ae84:	c0 30       	breq	8000ae8a <_dtoa_r+0xb56>
8000ae86:	10 95       	mov	r5,r8
8000ae88:	c0 88       	rjmp	8000ae98 <_dtoa_r+0xb64>
8000ae8a:	2f f6       	sub	r6,-1
8000ae8c:	50 66       	stdsp	sp[0x18],r6
8000ae8e:	33 18       	mov	r8,49
8000ae90:	40 8c       	lddsp	r12,sp[0x20]
8000ae92:	b8 88       	st.b	r12[0x0],r8
8000ae94:	c1 38       	rjmp	8000aeba <_dtoa_r+0xb86>
8000ae96:	33 9a       	mov	r10,57
8000ae98:	0a 98       	mov	r8,r5
8000ae9a:	11 79       	ld.ub	r9,--r8
8000ae9c:	f4 09 18 00 	cp.b	r9,r10
8000aea0:	cf 00       	breq	8000ae80 <_dtoa_r+0xb4c>
8000aea2:	2f f9       	sub	r9,-1
8000aea4:	b0 89       	st.b	r8[0x0],r9
8000aea6:	c0 98       	rjmp	8000aeb8 <_dtoa_r+0xb84>
8000aea8:	10 95       	mov	r5,r8
8000aeaa:	c0 28       	rjmp	8000aeae <_dtoa_r+0xb7a>
8000aeac:	33 09       	mov	r9,48
8000aeae:	0a 98       	mov	r8,r5
8000aeb0:	11 7a       	ld.ub	r10,--r8
8000aeb2:	f2 0a 18 00 	cp.b	r10,r9
8000aeb6:	cf 90       	breq	8000aea8 <_dtoa_r+0xb74>
8000aeb8:	50 66       	stdsp	sp[0x18],r6
8000aeba:	04 9b       	mov	r11,r2
8000aebc:	0e 9c       	mov	r12,r7
8000aebe:	e0 a0 04 f3 	rcall	8000b8a4 <_Bfree>
8000aec2:	58 04       	cp.w	r4,0
8000aec4:	c1 20       	breq	8000aee8 <_dtoa_r+0xbb4>
8000aec6:	40 4b       	lddsp	r11,sp[0x10]
8000aec8:	08 3b       	cp.w	r11,r4
8000aeca:	5f 19       	srne	r9
8000aecc:	58 0b       	cp.w	r11,0
8000aece:	5f 18       	srne	r8
8000aed0:	f3 e8 00 08 	and	r8,r9,r8
8000aed4:	c0 40       	breq	8000aedc <_dtoa_r+0xba8>
8000aed6:	0e 9c       	mov	r12,r7
8000aed8:	e0 a0 04 e6 	rcall	8000b8a4 <_Bfree>
8000aedc:	08 9b       	mov	r11,r4
8000aede:	0e 9c       	mov	r12,r7
8000aee0:	e0 a0 04 e2 	rcall	8000b8a4 <_Bfree>
8000aee4:	c0 28       	rjmp	8000aee8 <_dtoa_r+0xbb4>
8000aee6:	50 66       	stdsp	sp[0x18],r6
8000aee8:	0e 9c       	mov	r12,r7
8000aeea:	06 9b       	mov	r11,r3
8000aeec:	e0 a0 04 dc 	rcall	8000b8a4 <_Bfree>
8000aef0:	30 08       	mov	r8,0
8000aef2:	aa 88       	st.b	r5[0x0],r8
8000aef4:	40 68       	lddsp	r8,sp[0x18]
8000aef6:	41 5a       	lddsp	r10,sp[0x54]
8000aef8:	2f f8       	sub	r8,-1
8000aefa:	41 29       	lddsp	r9,sp[0x48]
8000aefc:	95 08       	st.w	r10[0x0],r8
8000aefe:	40 8c       	lddsp	r12,sp[0x20]
8000af00:	58 09       	cp.w	r9,0
8000af02:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000af06:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000af0a:	2e 6d       	sub	sp,-104
8000af0c:	d8 32       	popm	r0-r7,pc
8000af0e:	d7 03       	nop

8000af10 <__errno>:
8000af10:	e0 68 0a 40 	mov	r8,2624
8000af14:	70 0c       	ld.w	r12,r8[0x0]
8000af16:	2f 4c       	sub	r12,-12
8000af18:	5e fc       	retal	r12
8000af1a:	d7 03       	nop

8000af1c <_fflush_r>:
8000af1c:	d4 21       	pushm	r4-r7,lr
8000af1e:	16 97       	mov	r7,r11
8000af20:	18 96       	mov	r6,r12
8000af22:	76 48       	ld.w	r8,r11[0x10]
8000af24:	58 08       	cp.w	r8,0
8000af26:	c7 f0       	breq	8000b024 <_fflush_r+0x108>
8000af28:	58 0c       	cp.w	r12,0
8000af2a:	c0 50       	breq	8000af34 <_fflush_r+0x18>
8000af2c:	78 68       	ld.w	r8,r12[0x18]
8000af2e:	58 08       	cp.w	r8,0
8000af30:	c0 21       	brne	8000af34 <_fflush_r+0x18>
8000af32:	cc dc       	rcall	8000b0cc <__sinit>
8000af34:	fe c8 cb f4 	sub	r8,pc,-13324
8000af38:	10 37       	cp.w	r7,r8
8000af3a:	c0 31       	brne	8000af40 <_fflush_r+0x24>
8000af3c:	6c 07       	ld.w	r7,r6[0x0]
8000af3e:	c0 c8       	rjmp	8000af56 <_fflush_r+0x3a>
8000af40:	fe c8 cb e0 	sub	r8,pc,-13344
8000af44:	10 37       	cp.w	r7,r8
8000af46:	c0 31       	brne	8000af4c <_fflush_r+0x30>
8000af48:	6c 17       	ld.w	r7,r6[0x4]
8000af4a:	c0 68       	rjmp	8000af56 <_fflush_r+0x3a>
8000af4c:	fe c8 cb cc 	sub	r8,pc,-13364
8000af50:	10 37       	cp.w	r7,r8
8000af52:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000af56:	8e 6a       	ld.sh	r10,r7[0xc]
8000af58:	14 98       	mov	r8,r10
8000af5a:	ed ba 00 03 	bld	r10,0x3
8000af5e:	c4 20       	breq	8000afe2 <_fflush_r+0xc6>
8000af60:	ab ba       	sbr	r10,0xb
8000af62:	ae 6a       	st.h	r7[0xc],r10
8000af64:	6e 18       	ld.w	r8,r7[0x4]
8000af66:	58 08       	cp.w	r8,0
8000af68:	e0 89 00 06 	brgt	8000af74 <_fflush_r+0x58>
8000af6c:	6f 08       	ld.w	r8,r7[0x40]
8000af6e:	58 08       	cp.w	r8,0
8000af70:	e0 8a 00 5a 	brle	8000b024 <_fflush_r+0x108>
8000af74:	6e b8       	ld.w	r8,r7[0x2c]
8000af76:	58 08       	cp.w	r8,0
8000af78:	c5 60       	breq	8000b024 <_fflush_r+0x108>
8000af7a:	e2 1a 10 00 	andl	r10,0x1000,COH
8000af7e:	c0 30       	breq	8000af84 <_fflush_r+0x68>
8000af80:	6f 55       	ld.w	r5,r7[0x54]
8000af82:	c0 f8       	rjmp	8000afa0 <_fflush_r+0x84>
8000af84:	30 19       	mov	r9,1
8000af86:	6e 8b       	ld.w	r11,r7[0x20]
8000af88:	0c 9c       	mov	r12,r6
8000af8a:	5d 18       	icall	r8
8000af8c:	18 95       	mov	r5,r12
8000af8e:	5b fc       	cp.w	r12,-1
8000af90:	c0 81       	brne	8000afa0 <_fflush_r+0x84>
8000af92:	6c 38       	ld.w	r8,r6[0xc]
8000af94:	59 d8       	cp.w	r8,29
8000af96:	c4 70       	breq	8000b024 <_fflush_r+0x108>
8000af98:	8e 68       	ld.sh	r8,r7[0xc]
8000af9a:	a7 a8       	sbr	r8,0x6
8000af9c:	ae 68       	st.h	r7[0xc],r8
8000af9e:	d8 22       	popm	r4-r7,pc
8000afa0:	8e 68       	ld.sh	r8,r7[0xc]
8000afa2:	ed b8 00 02 	bld	r8,0x2
8000afa6:	c0 91       	brne	8000afb8 <_fflush_r+0x9c>
8000afa8:	6e 18       	ld.w	r8,r7[0x4]
8000afaa:	10 15       	sub	r5,r8
8000afac:	6e d8       	ld.w	r8,r7[0x34]
8000afae:	58 08       	cp.w	r8,0
8000afb0:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000afb4:	eb d8 e1 15 	subne	r5,r5,r8
8000afb8:	6e b8       	ld.w	r8,r7[0x2c]
8000afba:	0c 9c       	mov	r12,r6
8000afbc:	30 09       	mov	r9,0
8000afbe:	0a 9a       	mov	r10,r5
8000afc0:	6e 8b       	ld.w	r11,r7[0x20]
8000afc2:	5d 18       	icall	r8
8000afc4:	8e 68       	ld.sh	r8,r7[0xc]
8000afc6:	0a 3c       	cp.w	r12,r5
8000afc8:	c2 61       	brne	8000b014 <_fflush_r+0xf8>
8000afca:	ab d8       	cbr	r8,0xb
8000afcc:	30 0c       	mov	r12,0
8000afce:	6e 49       	ld.w	r9,r7[0x10]
8000afd0:	ae 68       	st.h	r7[0xc],r8
8000afd2:	8f 1c       	st.w	r7[0x4],r12
8000afd4:	8f 09       	st.w	r7[0x0],r9
8000afd6:	ed b8 00 0c 	bld	r8,0xc
8000afda:	c2 51       	brne	8000b024 <_fflush_r+0x108>
8000afdc:	ef 45 00 54 	st.w	r7[84],r5
8000afe0:	d8 22       	popm	r4-r7,pc
8000afe2:	6e 45       	ld.w	r5,r7[0x10]
8000afe4:	58 05       	cp.w	r5,0
8000afe6:	c1 f0       	breq	8000b024 <_fflush_r+0x108>
8000afe8:	6e 04       	ld.w	r4,r7[0x0]
8000afea:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000afee:	8f 05       	st.w	r7[0x0],r5
8000aff0:	f9 b8 01 00 	movne	r8,0
8000aff4:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000aff8:	0a 14       	sub	r4,r5
8000affa:	8f 28       	st.w	r7[0x8],r8
8000affc:	c1 18       	rjmp	8000b01e <_fflush_r+0x102>
8000affe:	08 99       	mov	r9,r4
8000b000:	0a 9a       	mov	r10,r5
8000b002:	6e a8       	ld.w	r8,r7[0x28]
8000b004:	6e 8b       	ld.w	r11,r7[0x20]
8000b006:	0c 9c       	mov	r12,r6
8000b008:	5d 18       	icall	r8
8000b00a:	18 14       	sub	r4,r12
8000b00c:	58 0c       	cp.w	r12,0
8000b00e:	e0 89 00 07 	brgt	8000b01c <_fflush_r+0x100>
8000b012:	8e 68       	ld.sh	r8,r7[0xc]
8000b014:	a7 a8       	sbr	r8,0x6
8000b016:	3f fc       	mov	r12,-1
8000b018:	ae 68       	st.h	r7[0xc],r8
8000b01a:	d8 22       	popm	r4-r7,pc
8000b01c:	18 05       	add	r5,r12
8000b01e:	58 04       	cp.w	r4,0
8000b020:	fe 99 ff ef 	brgt	8000affe <_fflush_r+0xe2>
8000b024:	d8 2a       	popm	r4-r7,pc,r12=0
8000b026:	d7 03       	nop

8000b028 <__sfp_lock_acquire>:
8000b028:	5e fc       	retal	r12

8000b02a <__sfp_lock_release>:
8000b02a:	5e fc       	retal	r12

8000b02c <_cleanup_r>:
8000b02c:	d4 01       	pushm	lr
8000b02e:	fe cb f0 ae 	sub	r11,pc,-3922
8000b032:	e0 a0 02 f7 	rcall	8000b620 <_fwalk>
8000b036:	d8 02       	popm	pc

8000b038 <__sfmoreglue>:
8000b038:	d4 21       	pushm	r4-r7,lr
8000b03a:	16 95       	mov	r5,r11
8000b03c:	f6 06 10 5c 	mul	r6,r11,92
8000b040:	ec cb ff f4 	sub	r11,r6,-12
8000b044:	fe b0 e2 88 	rcall	80007554 <_malloc_r>
8000b048:	18 97       	mov	r7,r12
8000b04a:	c0 90       	breq	8000b05c <__sfmoreglue+0x24>
8000b04c:	99 15       	st.w	r12[0x4],r5
8000b04e:	30 0b       	mov	r11,0
8000b050:	2f 4c       	sub	r12,-12
8000b052:	0c 9a       	mov	r10,r6
8000b054:	8f 2c       	st.w	r7[0x8],r12
8000b056:	8f 0b       	st.w	r7[0x0],r11
8000b058:	fe b0 e5 3e 	rcall	80007ad4 <memset>
8000b05c:	0e 9c       	mov	r12,r7
8000b05e:	d8 22       	popm	r4-r7,pc

8000b060 <__sfp>:
8000b060:	d4 21       	pushm	r4-r7,lr
8000b062:	fe c8 cc be 	sub	r8,pc,-13122
8000b066:	18 96       	mov	r6,r12
8000b068:	70 07       	ld.w	r7,r8[0x0]
8000b06a:	6e 68       	ld.w	r8,r7[0x18]
8000b06c:	58 08       	cp.w	r8,0
8000b06e:	c0 31       	brne	8000b074 <__sfp+0x14>
8000b070:	0e 9c       	mov	r12,r7
8000b072:	c2 dc       	rcall	8000b0cc <__sinit>
8000b074:	ee c7 ff 28 	sub	r7,r7,-216
8000b078:	30 05       	mov	r5,0
8000b07a:	6e 2c       	ld.w	r12,r7[0x8]
8000b07c:	6e 18       	ld.w	r8,r7[0x4]
8000b07e:	c0 68       	rjmp	8000b08a <__sfp+0x2a>
8000b080:	98 69       	ld.sh	r9,r12[0xc]
8000b082:	ea 09 19 00 	cp.h	r9,r5
8000b086:	c1 10       	breq	8000b0a8 <__sfp+0x48>
8000b088:	2a 4c       	sub	r12,-92
8000b08a:	20 18       	sub	r8,1
8000b08c:	cf a7       	brpl	8000b080 <__sfp+0x20>
8000b08e:	6e 08       	ld.w	r8,r7[0x0]
8000b090:	58 08       	cp.w	r8,0
8000b092:	c0 61       	brne	8000b09e <__sfp+0x3e>
8000b094:	30 4b       	mov	r11,4
8000b096:	0c 9c       	mov	r12,r6
8000b098:	cd 0f       	rcall	8000b038 <__sfmoreglue>
8000b09a:	8f 0c       	st.w	r7[0x0],r12
8000b09c:	c0 30       	breq	8000b0a2 <__sfp+0x42>
8000b09e:	6e 07       	ld.w	r7,r7[0x0]
8000b0a0:	ce db       	rjmp	8000b07a <__sfp+0x1a>
8000b0a2:	30 c8       	mov	r8,12
8000b0a4:	8d 38       	st.w	r6[0xc],r8
8000b0a6:	d8 22       	popm	r4-r7,pc
8000b0a8:	30 08       	mov	r8,0
8000b0aa:	f9 48 00 4c 	st.w	r12[76],r8
8000b0ae:	99 08       	st.w	r12[0x0],r8
8000b0b0:	99 28       	st.w	r12[0x8],r8
8000b0b2:	99 18       	st.w	r12[0x4],r8
8000b0b4:	99 48       	st.w	r12[0x10],r8
8000b0b6:	99 58       	st.w	r12[0x14],r8
8000b0b8:	99 68       	st.w	r12[0x18],r8
8000b0ba:	99 d8       	st.w	r12[0x34],r8
8000b0bc:	99 e8       	st.w	r12[0x38],r8
8000b0be:	f9 48 00 48 	st.w	r12[72],r8
8000b0c2:	3f f8       	mov	r8,-1
8000b0c4:	b8 78       	st.h	r12[0xe],r8
8000b0c6:	30 18       	mov	r8,1
8000b0c8:	b8 68       	st.h	r12[0xc],r8
8000b0ca:	d8 22       	popm	r4-r7,pc

8000b0cc <__sinit>:
8000b0cc:	d4 21       	pushm	r4-r7,lr
8000b0ce:	18 96       	mov	r6,r12
8000b0d0:	78 67       	ld.w	r7,r12[0x18]
8000b0d2:	58 07       	cp.w	r7,0
8000b0d4:	c4 91       	brne	8000b166 <__sinit+0x9a>
8000b0d6:	fe c8 00 aa 	sub	r8,pc,170
8000b0da:	30 15       	mov	r5,1
8000b0dc:	99 a8       	st.w	r12[0x28],r8
8000b0de:	f9 47 00 d8 	st.w	r12[216],r7
8000b0e2:	f9 47 00 dc 	st.w	r12[220],r7
8000b0e6:	f9 47 00 e0 	st.w	r12[224],r7
8000b0ea:	99 65       	st.w	r12[0x18],r5
8000b0ec:	cb af       	rcall	8000b060 <__sfp>
8000b0ee:	8d 0c       	st.w	r6[0x0],r12
8000b0f0:	0c 9c       	mov	r12,r6
8000b0f2:	cb 7f       	rcall	8000b060 <__sfp>
8000b0f4:	8d 1c       	st.w	r6[0x4],r12
8000b0f6:	0c 9c       	mov	r12,r6
8000b0f8:	cb 4f       	rcall	8000b060 <__sfp>
8000b0fa:	6c 09       	ld.w	r9,r6[0x0]
8000b0fc:	30 48       	mov	r8,4
8000b0fe:	93 07       	st.w	r9[0x0],r7
8000b100:	b2 68       	st.h	r9[0xc],r8
8000b102:	93 17       	st.w	r9[0x4],r7
8000b104:	93 27       	st.w	r9[0x8],r7
8000b106:	6c 18       	ld.w	r8,r6[0x4]
8000b108:	b2 77       	st.h	r9[0xe],r7
8000b10a:	93 47       	st.w	r9[0x10],r7
8000b10c:	93 57       	st.w	r9[0x14],r7
8000b10e:	93 67       	st.w	r9[0x18],r7
8000b110:	93 89       	st.w	r9[0x20],r9
8000b112:	91 07       	st.w	r8[0x0],r7
8000b114:	91 17       	st.w	r8[0x4],r7
8000b116:	91 27       	st.w	r8[0x8],r7
8000b118:	fe ce f3 24 	sub	lr,pc,-3292
8000b11c:	fe cb f3 54 	sub	r11,pc,-3244
8000b120:	93 9e       	st.w	r9[0x24],lr
8000b122:	93 ab       	st.w	r9[0x28],r11
8000b124:	fe ca f3 7c 	sub	r10,pc,-3204
8000b128:	fe c4 f3 88 	sub	r4,pc,-3192
8000b12c:	93 ba       	st.w	r9[0x2c],r10
8000b12e:	93 c4       	st.w	r9[0x30],r4
8000b130:	30 99       	mov	r9,9
8000b132:	b0 69       	st.h	r8[0xc],r9
8000b134:	b0 75       	st.h	r8[0xe],r5
8000b136:	91 c4       	st.w	r8[0x30],r4
8000b138:	91 47       	st.w	r8[0x10],r7
8000b13a:	91 57       	st.w	r8[0x14],r7
8000b13c:	91 67       	st.w	r8[0x18],r7
8000b13e:	91 88       	st.w	r8[0x20],r8
8000b140:	91 9e       	st.w	r8[0x24],lr
8000b142:	91 ab       	st.w	r8[0x28],r11
8000b144:	91 ba       	st.w	r8[0x2c],r10
8000b146:	8d 2c       	st.w	r6[0x8],r12
8000b148:	31 28       	mov	r8,18
8000b14a:	99 07       	st.w	r12[0x0],r7
8000b14c:	b8 68       	st.h	r12[0xc],r8
8000b14e:	99 17       	st.w	r12[0x4],r7
8000b150:	99 27       	st.w	r12[0x8],r7
8000b152:	30 28       	mov	r8,2
8000b154:	b8 78       	st.h	r12[0xe],r8
8000b156:	99 c4       	st.w	r12[0x30],r4
8000b158:	99 67       	st.w	r12[0x18],r7
8000b15a:	99 9e       	st.w	r12[0x24],lr
8000b15c:	99 ab       	st.w	r12[0x28],r11
8000b15e:	99 ba       	st.w	r12[0x2c],r10
8000b160:	99 47       	st.w	r12[0x10],r7
8000b162:	99 57       	st.w	r12[0x14],r7
8000b164:	99 8c       	st.w	r12[0x20],r12
8000b166:	d8 22       	popm	r4-r7,pc

8000b168 <_malloc_trim_r>:
8000b168:	d4 21       	pushm	r4-r7,lr
8000b16a:	16 95       	mov	r5,r11
8000b16c:	18 97       	mov	r7,r12
8000b16e:	fe b0 d7 ad 	rcall	800060c8 <__malloc_lock>
8000b172:	e0 64 05 40 	mov	r4,1344
8000b176:	68 28       	ld.w	r8,r4[0x8]
8000b178:	70 16       	ld.w	r6,r8[0x4]
8000b17a:	e0 16 ff fc 	andl	r6,0xfffc
8000b17e:	ec c8 ff 91 	sub	r8,r6,-111
8000b182:	f0 05 01 05 	sub	r5,r8,r5
8000b186:	e0 15 ff 80 	andl	r5,0xff80
8000b18a:	ea c5 00 80 	sub	r5,r5,128
8000b18e:	e0 45 00 7f 	cp.w	r5,127
8000b192:	e0 8a 00 25 	brle	8000b1dc <_malloc_trim_r+0x74>
8000b196:	30 0b       	mov	r11,0
8000b198:	0e 9c       	mov	r12,r7
8000b19a:	fe b0 e6 05 	rcall	80007da4 <_sbrk_r>
8000b19e:	68 28       	ld.w	r8,r4[0x8]
8000b1a0:	0c 08       	add	r8,r6
8000b1a2:	10 3c       	cp.w	r12,r8
8000b1a4:	c1 c1       	brne	8000b1dc <_malloc_trim_r+0x74>
8000b1a6:	ea 0b 11 00 	rsub	r11,r5,0
8000b1aa:	0e 9c       	mov	r12,r7
8000b1ac:	fe b0 e5 fc 	rcall	80007da4 <_sbrk_r>
8000b1b0:	5b fc       	cp.w	r12,-1
8000b1b2:	c1 91       	brne	8000b1e4 <_malloc_trim_r+0x7c>
8000b1b4:	30 0b       	mov	r11,0
8000b1b6:	0e 9c       	mov	r12,r7
8000b1b8:	fe b0 e5 f6 	rcall	80007da4 <_sbrk_r>
8000b1bc:	68 28       	ld.w	r8,r4[0x8]
8000b1be:	f8 08 01 09 	sub	r9,r12,r8
8000b1c2:	58 f9       	cp.w	r9,15
8000b1c4:	e0 8a 00 0c 	brle	8000b1dc <_malloc_trim_r+0x74>
8000b1c8:	a1 a9       	sbr	r9,0x0
8000b1ca:	91 19       	st.w	r8[0x4],r9
8000b1cc:	e0 68 09 4c 	mov	r8,2380
8000b1d0:	70 09       	ld.w	r9,r8[0x0]
8000b1d2:	e0 68 0d 6c 	mov	r8,3436
8000b1d6:	f8 09 01 09 	sub	r9,r12,r9
8000b1da:	91 09       	st.w	r8[0x0],r9
8000b1dc:	0e 9c       	mov	r12,r7
8000b1de:	fe b0 d7 7b 	rcall	800060d4 <__malloc_unlock>
8000b1e2:	d8 2a       	popm	r4-r7,pc,r12=0
8000b1e4:	68 28       	ld.w	r8,r4[0x8]
8000b1e6:	0a 16       	sub	r6,r5
8000b1e8:	a1 a6       	sbr	r6,0x0
8000b1ea:	91 16       	st.w	r8[0x4],r6
8000b1ec:	e0 68 0d 6c 	mov	r8,3436
8000b1f0:	70 09       	ld.w	r9,r8[0x0]
8000b1f2:	0a 19       	sub	r9,r5
8000b1f4:	0e 9c       	mov	r12,r7
8000b1f6:	91 09       	st.w	r8[0x0],r9
8000b1f8:	fe b0 d7 6e 	rcall	800060d4 <__malloc_unlock>
8000b1fc:	da 2a       	popm	r4-r7,pc,r12=1
8000b1fe:	d7 03       	nop

8000b200 <_free_r>:
8000b200:	d4 21       	pushm	r4-r7,lr
8000b202:	16 96       	mov	r6,r11
8000b204:	18 97       	mov	r7,r12
8000b206:	58 0b       	cp.w	r11,0
8000b208:	e0 80 00 c0 	breq	8000b388 <_free_r+0x188>
8000b20c:	fe b0 d7 5e 	rcall	800060c8 <__malloc_lock>
8000b210:	20 86       	sub	r6,8
8000b212:	e0 6a 05 40 	mov	r10,1344
8000b216:	6c 18       	ld.w	r8,r6[0x4]
8000b218:	74 2e       	ld.w	lr,r10[0x8]
8000b21a:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b21e:	a1 c8       	cbr	r8,0x0
8000b220:	ec 08 00 09 	add	r9,r6,r8
8000b224:	72 1b       	ld.w	r11,r9[0x4]
8000b226:	e0 1b ff fc 	andl	r11,0xfffc
8000b22a:	1c 39       	cp.w	r9,lr
8000b22c:	c1 e1       	brne	8000b268 <_free_r+0x68>
8000b22e:	f6 08 00 08 	add	r8,r11,r8
8000b232:	58 0c       	cp.w	r12,0
8000b234:	c0 81       	brne	8000b244 <_free_r+0x44>
8000b236:	6c 09       	ld.w	r9,r6[0x0]
8000b238:	12 16       	sub	r6,r9
8000b23a:	12 08       	add	r8,r9
8000b23c:	6c 3b       	ld.w	r11,r6[0xc]
8000b23e:	6c 29       	ld.w	r9,r6[0x8]
8000b240:	97 29       	st.w	r11[0x8],r9
8000b242:	93 3b       	st.w	r9[0xc],r11
8000b244:	10 99       	mov	r9,r8
8000b246:	95 26       	st.w	r10[0x8],r6
8000b248:	a1 a9       	sbr	r9,0x0
8000b24a:	8d 19       	st.w	r6[0x4],r9
8000b24c:	e0 69 09 48 	mov	r9,2376
8000b250:	72 09       	ld.w	r9,r9[0x0]
8000b252:	12 38       	cp.w	r8,r9
8000b254:	c0 63       	brcs	8000b260 <_free_r+0x60>
8000b256:	e0 68 0d 68 	mov	r8,3432
8000b25a:	0e 9c       	mov	r12,r7
8000b25c:	70 0b       	ld.w	r11,r8[0x0]
8000b25e:	c8 5f       	rcall	8000b168 <_malloc_trim_r>
8000b260:	0e 9c       	mov	r12,r7
8000b262:	fe b0 d7 39 	rcall	800060d4 <__malloc_unlock>
8000b266:	d8 22       	popm	r4-r7,pc
8000b268:	93 1b       	st.w	r9[0x4],r11
8000b26a:	58 0c       	cp.w	r12,0
8000b26c:	c0 30       	breq	8000b272 <_free_r+0x72>
8000b26e:	30 0c       	mov	r12,0
8000b270:	c1 08       	rjmp	8000b290 <_free_r+0x90>
8000b272:	6c 0e       	ld.w	lr,r6[0x0]
8000b274:	f4 c5 ff f8 	sub	r5,r10,-8
8000b278:	1c 16       	sub	r6,lr
8000b27a:	1c 08       	add	r8,lr
8000b27c:	6c 2e       	ld.w	lr,r6[0x8]
8000b27e:	0a 3e       	cp.w	lr,r5
8000b280:	f9 bc 00 01 	moveq	r12,1
8000b284:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b288:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b28c:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b290:	f2 0b 00 0e 	add	lr,r9,r11
8000b294:	7c 1e       	ld.w	lr,lr[0x4]
8000b296:	ed be 00 00 	bld	lr,0x0
8000b29a:	c1 40       	breq	8000b2c2 <_free_r+0xc2>
8000b29c:	16 08       	add	r8,r11
8000b29e:	58 0c       	cp.w	r12,0
8000b2a0:	c0 d1       	brne	8000b2ba <_free_r+0xba>
8000b2a2:	e0 6e 05 40 	mov	lr,1344
8000b2a6:	72 2b       	ld.w	r11,r9[0x8]
8000b2a8:	2f 8e       	sub	lr,-8
8000b2aa:	1c 3b       	cp.w	r11,lr
8000b2ac:	c0 71       	brne	8000b2ba <_free_r+0xba>
8000b2ae:	97 36       	st.w	r11[0xc],r6
8000b2b0:	97 26       	st.w	r11[0x8],r6
8000b2b2:	8d 2b       	st.w	r6[0x8],r11
8000b2b4:	8d 3b       	st.w	r6[0xc],r11
8000b2b6:	30 1c       	mov	r12,1
8000b2b8:	c0 58       	rjmp	8000b2c2 <_free_r+0xc2>
8000b2ba:	72 2b       	ld.w	r11,r9[0x8]
8000b2bc:	72 39       	ld.w	r9,r9[0xc]
8000b2be:	93 2b       	st.w	r9[0x8],r11
8000b2c0:	97 39       	st.w	r11[0xc],r9
8000b2c2:	10 99       	mov	r9,r8
8000b2c4:	ec 08 09 08 	st.w	r6[r8],r8
8000b2c8:	a1 a9       	sbr	r9,0x0
8000b2ca:	8d 19       	st.w	r6[0x4],r9
8000b2cc:	58 0c       	cp.w	r12,0
8000b2ce:	c5 a1       	brne	8000b382 <_free_r+0x182>
8000b2d0:	e0 48 01 ff 	cp.w	r8,511
8000b2d4:	e0 8b 00 13 	brhi	8000b2fa <_free_r+0xfa>
8000b2d8:	a3 98       	lsr	r8,0x3
8000b2da:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b2de:	72 2b       	ld.w	r11,r9[0x8]
8000b2e0:	8d 39       	st.w	r6[0xc],r9
8000b2e2:	8d 2b       	st.w	r6[0x8],r11
8000b2e4:	97 36       	st.w	r11[0xc],r6
8000b2e6:	93 26       	st.w	r9[0x8],r6
8000b2e8:	a3 48       	asr	r8,0x2
8000b2ea:	74 19       	ld.w	r9,r10[0x4]
8000b2ec:	30 1b       	mov	r11,1
8000b2ee:	f6 08 09 48 	lsl	r8,r11,r8
8000b2f2:	f3 e8 10 08 	or	r8,r9,r8
8000b2f6:	95 18       	st.w	r10[0x4],r8
8000b2f8:	c4 58       	rjmp	8000b382 <_free_r+0x182>
8000b2fa:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b2fe:	58 4b       	cp.w	r11,4
8000b300:	e0 8b 00 06 	brhi	8000b30c <_free_r+0x10c>
8000b304:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b308:	2c 8b       	sub	r11,-56
8000b30a:	c2 08       	rjmp	8000b34a <_free_r+0x14a>
8000b30c:	59 4b       	cp.w	r11,20
8000b30e:	e0 8b 00 04 	brhi	8000b316 <_free_r+0x116>
8000b312:	2a 5b       	sub	r11,-91
8000b314:	c1 b8       	rjmp	8000b34a <_free_r+0x14a>
8000b316:	e0 4b 00 54 	cp.w	r11,84
8000b31a:	e0 8b 00 06 	brhi	8000b326 <_free_r+0x126>
8000b31e:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b322:	29 2b       	sub	r11,-110
8000b324:	c1 38       	rjmp	8000b34a <_free_r+0x14a>
8000b326:	e0 4b 01 54 	cp.w	r11,340
8000b32a:	e0 8b 00 06 	brhi	8000b336 <_free_r+0x136>
8000b32e:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b332:	28 9b       	sub	r11,-119
8000b334:	c0 b8       	rjmp	8000b34a <_free_r+0x14a>
8000b336:	e0 4b 05 54 	cp.w	r11,1364
8000b33a:	e0 88 00 05 	brls	8000b344 <_free_r+0x144>
8000b33e:	37 eb       	mov	r11,126
8000b340:	c0 58       	rjmp	8000b34a <_free_r+0x14a>
8000b342:	d7 03       	nop
8000b344:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b348:	28 4b       	sub	r11,-124
8000b34a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b34e:	78 29       	ld.w	r9,r12[0x8]
8000b350:	18 39       	cp.w	r9,r12
8000b352:	c0 e1       	brne	8000b36e <_free_r+0x16e>
8000b354:	74 18       	ld.w	r8,r10[0x4]
8000b356:	a3 4b       	asr	r11,0x2
8000b358:	30 1c       	mov	r12,1
8000b35a:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b35e:	f1 eb 10 0b 	or	r11,r8,r11
8000b362:	12 98       	mov	r8,r9
8000b364:	95 1b       	st.w	r10[0x4],r11
8000b366:	c0 a8       	rjmp	8000b37a <_free_r+0x17a>
8000b368:	72 29       	ld.w	r9,r9[0x8]
8000b36a:	18 39       	cp.w	r9,r12
8000b36c:	c0 60       	breq	8000b378 <_free_r+0x178>
8000b36e:	72 1a       	ld.w	r10,r9[0x4]
8000b370:	e0 1a ff fc 	andl	r10,0xfffc
8000b374:	14 38       	cp.w	r8,r10
8000b376:	cf 93       	brcs	8000b368 <_free_r+0x168>
8000b378:	72 38       	ld.w	r8,r9[0xc]
8000b37a:	8d 38       	st.w	r6[0xc],r8
8000b37c:	8d 29       	st.w	r6[0x8],r9
8000b37e:	93 36       	st.w	r9[0xc],r6
8000b380:	91 26       	st.w	r8[0x8],r6
8000b382:	0e 9c       	mov	r12,r7
8000b384:	fe b0 d6 a8 	rcall	800060d4 <__malloc_unlock>
8000b388:	d8 22       	popm	r4-r7,pc
8000b38a:	d7 03       	nop

8000b38c <__sfvwrite_r>:
8000b38c:	d4 31       	pushm	r0-r7,lr
8000b38e:	20 3d       	sub	sp,12
8000b390:	14 94       	mov	r4,r10
8000b392:	18 95       	mov	r5,r12
8000b394:	16 97       	mov	r7,r11
8000b396:	74 28       	ld.w	r8,r10[0x8]
8000b398:	58 08       	cp.w	r8,0
8000b39a:	e0 80 01 40 	breq	8000b61a <__sfvwrite_r+0x28e>
8000b39e:	96 68       	ld.sh	r8,r11[0xc]
8000b3a0:	ed b8 00 03 	bld	r8,0x3
8000b3a4:	c0 41       	brne	8000b3ac <__sfvwrite_r+0x20>
8000b3a6:	76 48       	ld.w	r8,r11[0x10]
8000b3a8:	58 08       	cp.w	r8,0
8000b3aa:	c0 c1       	brne	8000b3c2 <__sfvwrite_r+0x36>
8000b3ac:	0e 9b       	mov	r11,r7
8000b3ae:	0a 9c       	mov	r12,r5
8000b3b0:	fe b0 f6 c4 	rcall	8000a138 <__swsetup_r>
8000b3b4:	c0 70       	breq	8000b3c2 <__sfvwrite_r+0x36>
8000b3b6:	8e 68       	ld.sh	r8,r7[0xc]
8000b3b8:	a7 a8       	sbr	r8,0x6
8000b3ba:	ae 68       	st.h	r7[0xc],r8
8000b3bc:	30 98       	mov	r8,9
8000b3be:	8b 38       	st.w	r5[0xc],r8
8000b3c0:	c2 b9       	rjmp	8000b616 <__sfvwrite_r+0x28a>
8000b3c2:	8e 63       	ld.sh	r3,r7[0xc]
8000b3c4:	68 00       	ld.w	r0,r4[0x0]
8000b3c6:	06 96       	mov	r6,r3
8000b3c8:	e2 16 00 02 	andl	r6,0x2,COH
8000b3cc:	c2 10       	breq	8000b40e <__sfvwrite_r+0x82>
8000b3ce:	30 03       	mov	r3,0
8000b3d0:	e0 62 04 00 	mov	r2,1024
8000b3d4:	06 96       	mov	r6,r3
8000b3d6:	c0 48       	rjmp	8000b3de <__sfvwrite_r+0x52>
8000b3d8:	60 03       	ld.w	r3,r0[0x0]
8000b3da:	60 16       	ld.w	r6,r0[0x4]
8000b3dc:	2f 80       	sub	r0,-8
8000b3de:	58 06       	cp.w	r6,0
8000b3e0:	cf c0       	breq	8000b3d8 <__sfvwrite_r+0x4c>
8000b3e2:	e0 46 04 00 	cp.w	r6,1024
8000b3e6:	ec 09 17 80 	movls	r9,r6
8000b3ea:	e4 09 17 b0 	movhi	r9,r2
8000b3ee:	06 9a       	mov	r10,r3
8000b3f0:	6e a8       	ld.w	r8,r7[0x28]
8000b3f2:	6e 8b       	ld.w	r11,r7[0x20]
8000b3f4:	0a 9c       	mov	r12,r5
8000b3f6:	5d 18       	icall	r8
8000b3f8:	18 16       	sub	r6,r12
8000b3fa:	58 0c       	cp.w	r12,0
8000b3fc:	e0 8a 01 0a 	brle	8000b610 <__sfvwrite_r+0x284>
8000b400:	68 28       	ld.w	r8,r4[0x8]
8000b402:	18 18       	sub	r8,r12
8000b404:	89 28       	st.w	r4[0x8],r8
8000b406:	e0 80 01 0a 	breq	8000b61a <__sfvwrite_r+0x28e>
8000b40a:	18 03       	add	r3,r12
8000b40c:	ce 9b       	rjmp	8000b3de <__sfvwrite_r+0x52>
8000b40e:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b412:	c0 70       	breq	8000b420 <__sfvwrite_r+0x94>
8000b414:	50 06       	stdsp	sp[0x0],r6
8000b416:	0c 93       	mov	r3,r6
8000b418:	0c 91       	mov	r1,r6
8000b41a:	50 15       	stdsp	sp[0x4],r5
8000b41c:	08 92       	mov	r2,r4
8000b41e:	c9 c8       	rjmp	8000b556 <__sfvwrite_r+0x1ca>
8000b420:	06 96       	mov	r6,r3
8000b422:	08 91       	mov	r1,r4
8000b424:	c0 48       	rjmp	8000b42c <__sfvwrite_r+0xa0>
8000b426:	60 03       	ld.w	r3,r0[0x0]
8000b428:	60 16       	ld.w	r6,r0[0x4]
8000b42a:	2f 80       	sub	r0,-8
8000b42c:	58 06       	cp.w	r6,0
8000b42e:	cf c0       	breq	8000b426 <__sfvwrite_r+0x9a>
8000b430:	8e 68       	ld.sh	r8,r7[0xc]
8000b432:	6e 24       	ld.w	r4,r7[0x8]
8000b434:	10 99       	mov	r9,r8
8000b436:	e2 19 02 00 	andl	r9,0x200,COH
8000b43a:	c5 50       	breq	8000b4e4 <__sfvwrite_r+0x158>
8000b43c:	08 36       	cp.w	r6,r4
8000b43e:	c4 43       	brcs	8000b4c6 <__sfvwrite_r+0x13a>
8000b440:	10 99       	mov	r9,r8
8000b442:	e2 19 04 80 	andl	r9,0x480,COH
8000b446:	c4 00       	breq	8000b4c6 <__sfvwrite_r+0x13a>
8000b448:	6e 4b       	ld.w	r11,r7[0x10]
8000b44a:	6e 09       	ld.w	r9,r7[0x0]
8000b44c:	16 19       	sub	r9,r11
8000b44e:	50 09       	stdsp	sp[0x0],r9
8000b450:	6e 59       	ld.w	r9,r7[0x14]
8000b452:	10 9c       	mov	r12,r8
8000b454:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b458:	30 28       	mov	r8,2
8000b45a:	f4 08 0c 08 	divs	r8,r10,r8
8000b45e:	fa e9 00 04 	st.d	sp[4],r8
8000b462:	10 94       	mov	r4,r8
8000b464:	40 09       	lddsp	r9,sp[0x0]
8000b466:	e2 1c 04 00 	andl	r12,0x400,COH
8000b46a:	2f f9       	sub	r9,-1
8000b46c:	0c 09       	add	r9,r6
8000b46e:	12 38       	cp.w	r8,r9
8000b470:	f2 04 17 30 	movlo	r4,r9
8000b474:	58 0c       	cp.w	r12,0
8000b476:	c1 10       	breq	8000b498 <__sfvwrite_r+0x10c>
8000b478:	08 9b       	mov	r11,r4
8000b47a:	0a 9c       	mov	r12,r5
8000b47c:	fe b0 e0 6c 	rcall	80007554 <_malloc_r>
8000b480:	18 92       	mov	r2,r12
8000b482:	c1 40       	breq	8000b4aa <__sfvwrite_r+0x11e>
8000b484:	40 0a       	lddsp	r10,sp[0x0]
8000b486:	6e 4b       	ld.w	r11,r7[0x10]
8000b488:	fe b0 e2 82 	rcall	8000798c <memcpy>
8000b48c:	8e 68       	ld.sh	r8,r7[0xc]
8000b48e:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b492:	a7 b8       	sbr	r8,0x7
8000b494:	ae 68       	st.h	r7[0xc],r8
8000b496:	c0 d8       	rjmp	8000b4b0 <__sfvwrite_r+0x124>
8000b498:	08 9a       	mov	r10,r4
8000b49a:	0a 9c       	mov	r12,r5
8000b49c:	fe b0 e3 24 	rcall	80007ae4 <_realloc_r>
8000b4a0:	18 92       	mov	r2,r12
8000b4a2:	c0 71       	brne	8000b4b0 <__sfvwrite_r+0x124>
8000b4a4:	6e 4b       	ld.w	r11,r7[0x10]
8000b4a6:	0a 9c       	mov	r12,r5
8000b4a8:	ca ce       	rcall	8000b200 <_free_r>
8000b4aa:	30 c8       	mov	r8,12
8000b4ac:	8b 38       	st.w	r5[0xc],r8
8000b4ae:	cb 18       	rjmp	8000b610 <__sfvwrite_r+0x284>
8000b4b0:	40 0a       	lddsp	r10,sp[0x0]
8000b4b2:	40 09       	lddsp	r9,sp[0x0]
8000b4b4:	e8 0a 01 0a 	sub	r10,r4,r10
8000b4b8:	e4 09 00 08 	add	r8,r2,r9
8000b4bc:	8f 54       	st.w	r7[0x14],r4
8000b4be:	8f 2a       	st.w	r7[0x8],r10
8000b4c0:	8f 08       	st.w	r7[0x0],r8
8000b4c2:	8f 42       	st.w	r7[0x10],r2
8000b4c4:	0c 94       	mov	r4,r6
8000b4c6:	08 36       	cp.w	r6,r4
8000b4c8:	ec 04 17 30 	movlo	r4,r6
8000b4cc:	06 9b       	mov	r11,r3
8000b4ce:	08 9a       	mov	r10,r4
8000b4d0:	6e 0c       	ld.w	r12,r7[0x0]
8000b4d2:	c3 ad       	rcall	8000b746 <memmove>
8000b4d4:	6e 08       	ld.w	r8,r7[0x0]
8000b4d6:	08 08       	add	r8,r4
8000b4d8:	8f 08       	st.w	r7[0x0],r8
8000b4da:	6e 28       	ld.w	r8,r7[0x8]
8000b4dc:	08 18       	sub	r8,r4
8000b4de:	0c 94       	mov	r4,r6
8000b4e0:	8f 28       	st.w	r7[0x8],r8
8000b4e2:	c2 e8       	rjmp	8000b53e <__sfvwrite_r+0x1b2>
8000b4e4:	08 36       	cp.w	r6,r4
8000b4e6:	5f ba       	srhi	r10
8000b4e8:	6e 0c       	ld.w	r12,r7[0x0]
8000b4ea:	6e 48       	ld.w	r8,r7[0x10]
8000b4ec:	10 3c       	cp.w	r12,r8
8000b4ee:	5f b8       	srhi	r8
8000b4f0:	f5 e8 00 08 	and	r8,r10,r8
8000b4f4:	f2 08 18 00 	cp.b	r8,r9
8000b4f8:	c0 d0       	breq	8000b512 <__sfvwrite_r+0x186>
8000b4fa:	06 9b       	mov	r11,r3
8000b4fc:	08 9a       	mov	r10,r4
8000b4fe:	c2 4d       	rcall	8000b746 <memmove>
8000b500:	6e 08       	ld.w	r8,r7[0x0]
8000b502:	08 08       	add	r8,r4
8000b504:	0e 9b       	mov	r11,r7
8000b506:	8f 08       	st.w	r7[0x0],r8
8000b508:	0a 9c       	mov	r12,r5
8000b50a:	fe b0 fd 09 	rcall	8000af1c <_fflush_r>
8000b50e:	c1 80       	breq	8000b53e <__sfvwrite_r+0x1b2>
8000b510:	c8 08       	rjmp	8000b610 <__sfvwrite_r+0x284>
8000b512:	6e 59       	ld.w	r9,r7[0x14]
8000b514:	12 36       	cp.w	r6,r9
8000b516:	c0 a3       	brcs	8000b52a <__sfvwrite_r+0x19e>
8000b518:	6e a8       	ld.w	r8,r7[0x28]
8000b51a:	06 9a       	mov	r10,r3
8000b51c:	6e 8b       	ld.w	r11,r7[0x20]
8000b51e:	0a 9c       	mov	r12,r5
8000b520:	5d 18       	icall	r8
8000b522:	18 94       	mov	r4,r12
8000b524:	e0 89 00 0d 	brgt	8000b53e <__sfvwrite_r+0x1b2>
8000b528:	c7 48       	rjmp	8000b610 <__sfvwrite_r+0x284>
8000b52a:	0c 9a       	mov	r10,r6
8000b52c:	06 9b       	mov	r11,r3
8000b52e:	c0 cd       	rcall	8000b746 <memmove>
8000b530:	6e 08       	ld.w	r8,r7[0x0]
8000b532:	0c 08       	add	r8,r6
8000b534:	0c 94       	mov	r4,r6
8000b536:	8f 08       	st.w	r7[0x0],r8
8000b538:	6e 28       	ld.w	r8,r7[0x8]
8000b53a:	0c 18       	sub	r8,r6
8000b53c:	8f 28       	st.w	r7[0x8],r8
8000b53e:	62 28       	ld.w	r8,r1[0x8]
8000b540:	08 18       	sub	r8,r4
8000b542:	83 28       	st.w	r1[0x8],r8
8000b544:	c6 b0       	breq	8000b61a <__sfvwrite_r+0x28e>
8000b546:	08 16       	sub	r6,r4
8000b548:	08 03       	add	r3,r4
8000b54a:	c7 1b       	rjmp	8000b42c <__sfvwrite_r+0xa0>
8000b54c:	60 03       	ld.w	r3,r0[0x0]
8000b54e:	60 11       	ld.w	r1,r0[0x4]
8000b550:	30 08       	mov	r8,0
8000b552:	2f 80       	sub	r0,-8
8000b554:	50 08       	stdsp	sp[0x0],r8
8000b556:	58 01       	cp.w	r1,0
8000b558:	cf a0       	breq	8000b54c <__sfvwrite_r+0x1c0>
8000b55a:	40 0a       	lddsp	r10,sp[0x0]
8000b55c:	58 0a       	cp.w	r10,0
8000b55e:	c1 41       	brne	8000b586 <__sfvwrite_r+0x1fa>
8000b560:	e2 c6 ff ff 	sub	r6,r1,-1
8000b564:	02 9a       	mov	r10,r1
8000b566:	30 ab       	mov	r11,10
8000b568:	06 9c       	mov	r12,r3
8000b56a:	ce 3c       	rcall	8000b730 <memchr>
8000b56c:	f8 c8 ff ff 	sub	r8,r12,-1
8000b570:	58 0c       	cp.w	r12,0
8000b572:	f1 d3 e1 16 	subne	r6,r8,r3
8000b576:	f9 b9 01 01 	movne	r9,1
8000b57a:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b57e:	f9 b8 00 01 	moveq	r8,1
8000b582:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b586:	02 36       	cp.w	r6,r1
8000b588:	ec 04 17 80 	movls	r4,r6
8000b58c:	e2 04 17 b0 	movhi	r4,r1
8000b590:	6e 59       	ld.w	r9,r7[0x14]
8000b592:	6e 25       	ld.w	r5,r7[0x8]
8000b594:	f2 05 00 05 	add	r5,r9,r5
8000b598:	0a 34       	cp.w	r4,r5
8000b59a:	5f 9a       	srgt	r10
8000b59c:	6e 0c       	ld.w	r12,r7[0x0]
8000b59e:	6e 48       	ld.w	r8,r7[0x10]
8000b5a0:	10 3c       	cp.w	r12,r8
8000b5a2:	5f b8       	srhi	r8
8000b5a4:	f5 e8 00 08 	and	r8,r10,r8
8000b5a8:	30 0a       	mov	r10,0
8000b5aa:	f4 08 18 00 	cp.b	r8,r10
8000b5ae:	c0 d0       	breq	8000b5c8 <__sfvwrite_r+0x23c>
8000b5b0:	06 9b       	mov	r11,r3
8000b5b2:	0a 9a       	mov	r10,r5
8000b5b4:	cc 9c       	rcall	8000b746 <memmove>
8000b5b6:	6e 08       	ld.w	r8,r7[0x0]
8000b5b8:	0a 08       	add	r8,r5
8000b5ba:	0e 9b       	mov	r11,r7
8000b5bc:	8f 08       	st.w	r7[0x0],r8
8000b5be:	40 1c       	lddsp	r12,sp[0x4]
8000b5c0:	fe b0 fc ae 	rcall	8000af1c <_fflush_r>
8000b5c4:	c1 70       	breq	8000b5f2 <__sfvwrite_r+0x266>
8000b5c6:	c2 58       	rjmp	8000b610 <__sfvwrite_r+0x284>
8000b5c8:	12 34       	cp.w	r4,r9
8000b5ca:	c0 a5       	brlt	8000b5de <__sfvwrite_r+0x252>
8000b5cc:	6e a8       	ld.w	r8,r7[0x28]
8000b5ce:	06 9a       	mov	r10,r3
8000b5d0:	6e 8b       	ld.w	r11,r7[0x20]
8000b5d2:	40 1c       	lddsp	r12,sp[0x4]
8000b5d4:	5d 18       	icall	r8
8000b5d6:	18 95       	mov	r5,r12
8000b5d8:	e0 89 00 0d 	brgt	8000b5f2 <__sfvwrite_r+0x266>
8000b5dc:	c1 a8       	rjmp	8000b610 <__sfvwrite_r+0x284>
8000b5de:	08 9a       	mov	r10,r4
8000b5e0:	06 9b       	mov	r11,r3
8000b5e2:	cb 2c       	rcall	8000b746 <memmove>
8000b5e4:	6e 08       	ld.w	r8,r7[0x0]
8000b5e6:	08 08       	add	r8,r4
8000b5e8:	08 95       	mov	r5,r4
8000b5ea:	8f 08       	st.w	r7[0x0],r8
8000b5ec:	6e 28       	ld.w	r8,r7[0x8]
8000b5ee:	08 18       	sub	r8,r4
8000b5f0:	8f 28       	st.w	r7[0x8],r8
8000b5f2:	0a 16       	sub	r6,r5
8000b5f4:	c0 71       	brne	8000b602 <__sfvwrite_r+0x276>
8000b5f6:	0e 9b       	mov	r11,r7
8000b5f8:	40 1c       	lddsp	r12,sp[0x4]
8000b5fa:	fe b0 fc 91 	rcall	8000af1c <_fflush_r>
8000b5fe:	c0 91       	brne	8000b610 <__sfvwrite_r+0x284>
8000b600:	50 06       	stdsp	sp[0x0],r6
8000b602:	64 28       	ld.w	r8,r2[0x8]
8000b604:	0a 18       	sub	r8,r5
8000b606:	85 28       	st.w	r2[0x8],r8
8000b608:	c0 90       	breq	8000b61a <__sfvwrite_r+0x28e>
8000b60a:	0a 11       	sub	r1,r5
8000b60c:	0a 03       	add	r3,r5
8000b60e:	ca 4b       	rjmp	8000b556 <__sfvwrite_r+0x1ca>
8000b610:	8e 68       	ld.sh	r8,r7[0xc]
8000b612:	a7 a8       	sbr	r8,0x6
8000b614:	ae 68       	st.h	r7[0xc],r8
8000b616:	3f fc       	mov	r12,-1
8000b618:	c0 28       	rjmp	8000b61c <__sfvwrite_r+0x290>
8000b61a:	30 0c       	mov	r12,0
8000b61c:	2f dd       	sub	sp,-12
8000b61e:	d8 32       	popm	r0-r7,pc

8000b620 <_fwalk>:
8000b620:	d4 31       	pushm	r0-r7,lr
8000b622:	30 05       	mov	r5,0
8000b624:	16 91       	mov	r1,r11
8000b626:	f8 c7 ff 28 	sub	r7,r12,-216
8000b62a:	0a 92       	mov	r2,r5
8000b62c:	fe b0 fc fe 	rcall	8000b028 <__sfp_lock_acquire>
8000b630:	3f f3       	mov	r3,-1
8000b632:	c1 68       	rjmp	8000b65e <_fwalk+0x3e>
8000b634:	6e 26       	ld.w	r6,r7[0x8]
8000b636:	6e 14       	ld.w	r4,r7[0x4]
8000b638:	2f 46       	sub	r6,-12
8000b63a:	c0 c8       	rjmp	8000b652 <_fwalk+0x32>
8000b63c:	8c 08       	ld.sh	r8,r6[0x0]
8000b63e:	e4 08 19 00 	cp.h	r8,r2
8000b642:	c0 70       	breq	8000b650 <_fwalk+0x30>
8000b644:	8c 18       	ld.sh	r8,r6[0x2]
8000b646:	e6 08 19 00 	cp.h	r8,r3
8000b64a:	c0 30       	breq	8000b650 <_fwalk+0x30>
8000b64c:	5d 11       	icall	r1
8000b64e:	18 45       	or	r5,r12
8000b650:	2a 46       	sub	r6,-92
8000b652:	20 14       	sub	r4,1
8000b654:	ec cc 00 0c 	sub	r12,r6,12
8000b658:	58 04       	cp.w	r4,0
8000b65a:	cf 14       	brge	8000b63c <_fwalk+0x1c>
8000b65c:	6e 07       	ld.w	r7,r7[0x0]
8000b65e:	58 07       	cp.w	r7,0
8000b660:	ce a1       	brne	8000b634 <_fwalk+0x14>
8000b662:	fe b0 fc e4 	rcall	8000b02a <__sfp_lock_release>
8000b666:	0a 9c       	mov	r12,r5
8000b668:	d8 32       	popm	r0-r7,pc
8000b66a:	d7 03       	nop

8000b66c <_localeconv_r>:
8000b66c:	fe cc d2 c4 	sub	r12,pc,-11580
8000b670:	5e fc       	retal	r12
8000b672:	d7 03       	nop

8000b674 <__smakebuf_r>:
8000b674:	d4 21       	pushm	r4-r7,lr
8000b676:	20 fd       	sub	sp,60
8000b678:	96 68       	ld.sh	r8,r11[0xc]
8000b67a:	16 97       	mov	r7,r11
8000b67c:	18 96       	mov	r6,r12
8000b67e:	e2 18 00 02 	andl	r8,0x2,COH
8000b682:	c3 d1       	brne	8000b6fc <__smakebuf_r+0x88>
8000b684:	96 7b       	ld.sh	r11,r11[0xe]
8000b686:	f0 0b 19 00 	cp.h	r11,r8
8000b68a:	c0 55       	brlt	8000b694 <__smakebuf_r+0x20>
8000b68c:	1a 9a       	mov	r10,sp
8000b68e:	e0 a0 04 81 	rcall	8000bf90 <_fstat_r>
8000b692:	c0 f4       	brge	8000b6b0 <__smakebuf_r+0x3c>
8000b694:	8e 65       	ld.sh	r5,r7[0xc]
8000b696:	0a 98       	mov	r8,r5
8000b698:	ab b8       	sbr	r8,0xb
8000b69a:	e2 15 00 80 	andl	r5,0x80,COH
8000b69e:	ae 68       	st.h	r7[0xc],r8
8000b6a0:	30 04       	mov	r4,0
8000b6a2:	e0 68 04 00 	mov	r8,1024
8000b6a6:	f9 b5 01 40 	movne	r5,64
8000b6aa:	f0 05 17 00 	moveq	r5,r8
8000b6ae:	c1 c8       	rjmp	8000b6e6 <__smakebuf_r+0x72>
8000b6b0:	40 18       	lddsp	r8,sp[0x4]
8000b6b2:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b6b6:	e0 48 20 00 	cp.w	r8,8192
8000b6ba:	5f 04       	sreq	r4
8000b6bc:	e0 48 80 00 	cp.w	r8,32768
8000b6c0:	c0 e1       	brne	8000b6dc <__smakebuf_r+0x68>
8000b6c2:	6e b9       	ld.w	r9,r7[0x2c]
8000b6c4:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b6c8:	10 39       	cp.w	r9,r8
8000b6ca:	c0 91       	brne	8000b6dc <__smakebuf_r+0x68>
8000b6cc:	8e 68       	ld.sh	r8,r7[0xc]
8000b6ce:	e0 65 04 00 	mov	r5,1024
8000b6d2:	ab a8       	sbr	r8,0xa
8000b6d4:	ef 45 00 50 	st.w	r7[80],r5
8000b6d8:	ae 68       	st.h	r7[0xc],r8
8000b6da:	c0 68       	rjmp	8000b6e6 <__smakebuf_r+0x72>
8000b6dc:	8e 68       	ld.sh	r8,r7[0xc]
8000b6de:	e0 65 04 00 	mov	r5,1024
8000b6e2:	ab b8       	sbr	r8,0xb
8000b6e4:	ae 68       	st.h	r7[0xc],r8
8000b6e6:	0a 9b       	mov	r11,r5
8000b6e8:	0c 9c       	mov	r12,r6
8000b6ea:	fe b0 df 35 	rcall	80007554 <_malloc_r>
8000b6ee:	8e 68       	ld.sh	r8,r7[0xc]
8000b6f0:	c0 d1       	brne	8000b70a <__smakebuf_r+0x96>
8000b6f2:	ed b8 00 09 	bld	r8,0x9
8000b6f6:	c1 b0       	breq	8000b72c <__smakebuf_r+0xb8>
8000b6f8:	a1 b8       	sbr	r8,0x1
8000b6fa:	ae 68       	st.h	r7[0xc],r8
8000b6fc:	ee c8 ff b9 	sub	r8,r7,-71
8000b700:	8f 48       	st.w	r7[0x10],r8
8000b702:	8f 08       	st.w	r7[0x0],r8
8000b704:	30 18       	mov	r8,1
8000b706:	8f 58       	st.w	r7[0x14],r8
8000b708:	c1 28       	rjmp	8000b72c <__smakebuf_r+0xb8>
8000b70a:	a7 b8       	sbr	r8,0x7
8000b70c:	8f 4c       	st.w	r7[0x10],r12
8000b70e:	ae 68       	st.h	r7[0xc],r8
8000b710:	8f 55       	st.w	r7[0x14],r5
8000b712:	fe c8 06 e6 	sub	r8,pc,1766
8000b716:	8f 0c       	st.w	r7[0x0],r12
8000b718:	8d a8       	st.w	r6[0x28],r8
8000b71a:	58 04       	cp.w	r4,0
8000b71c:	c0 80       	breq	8000b72c <__smakebuf_r+0xb8>
8000b71e:	8e 7c       	ld.sh	r12,r7[0xe]
8000b720:	fe b0 e3 94 	rcall	80007e48 <isatty>
8000b724:	c0 40       	breq	8000b72c <__smakebuf_r+0xb8>
8000b726:	8e 68       	ld.sh	r8,r7[0xc]
8000b728:	a1 a8       	sbr	r8,0x0
8000b72a:	ae 68       	st.h	r7[0xc],r8
8000b72c:	2f 1d       	sub	sp,-60
8000b72e:	d8 22       	popm	r4-r7,pc

8000b730 <memchr>:
8000b730:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b734:	c0 68       	rjmp	8000b740 <memchr+0x10>
8000b736:	20 1a       	sub	r10,1
8000b738:	19 88       	ld.ub	r8,r12[0x0]
8000b73a:	16 38       	cp.w	r8,r11
8000b73c:	5e 0c       	reteq	r12
8000b73e:	2f fc       	sub	r12,-1
8000b740:	58 0a       	cp.w	r10,0
8000b742:	cf a1       	brne	8000b736 <memchr+0x6>
8000b744:	5e fa       	retal	r10

8000b746 <memmove>:
8000b746:	d4 01       	pushm	lr
8000b748:	18 3b       	cp.w	r11,r12
8000b74a:	c1 92       	brcc	8000b77c <memmove+0x36>
8000b74c:	f6 0a 00 09 	add	r9,r11,r10
8000b750:	12 3c       	cp.w	r12,r9
8000b752:	c1 52       	brcc	8000b77c <memmove+0x36>
8000b754:	f8 0a 00 0b 	add	r11,r12,r10
8000b758:	30 08       	mov	r8,0
8000b75a:	c0 68       	rjmp	8000b766 <memmove+0x20>
8000b75c:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b760:	20 1a       	sub	r10,1
8000b762:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b766:	20 18       	sub	r8,1
8000b768:	58 0a       	cp.w	r10,0
8000b76a:	cf 91       	brne	8000b75c <memmove+0x16>
8000b76c:	d8 02       	popm	pc
8000b76e:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b772:	20 1a       	sub	r10,1
8000b774:	f8 08 0b 09 	st.b	r12[r8],r9
8000b778:	2f f8       	sub	r8,-1
8000b77a:	c0 28       	rjmp	8000b77e <memmove+0x38>
8000b77c:	30 08       	mov	r8,0
8000b77e:	58 0a       	cp.w	r10,0
8000b780:	cf 71       	brne	8000b76e <memmove+0x28>
8000b782:	d8 02       	popm	pc

8000b784 <__hi0bits>:
8000b784:	18 98       	mov	r8,r12
8000b786:	e0 1c 00 00 	andl	r12,0x0
8000b78a:	f0 09 15 10 	lsl	r9,r8,0x10
8000b78e:	58 0c       	cp.w	r12,0
8000b790:	f2 08 17 00 	moveq	r8,r9
8000b794:	f9 bc 00 10 	moveq	r12,16
8000b798:	f9 bc 01 00 	movne	r12,0
8000b79c:	10 9a       	mov	r10,r8
8000b79e:	f0 09 15 08 	lsl	r9,r8,0x8
8000b7a2:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b7a6:	f7 bc 00 f8 	subeq	r12,-8
8000b7aa:	f2 08 17 00 	moveq	r8,r9
8000b7ae:	10 9a       	mov	r10,r8
8000b7b0:	f0 09 15 04 	lsl	r9,r8,0x4
8000b7b4:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b7b8:	f7 bc 00 fc 	subeq	r12,-4
8000b7bc:	f2 08 17 00 	moveq	r8,r9
8000b7c0:	10 9a       	mov	r10,r8
8000b7c2:	f0 09 15 02 	lsl	r9,r8,0x2
8000b7c6:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b7ca:	f7 bc 00 fe 	subeq	r12,-2
8000b7ce:	f2 08 17 00 	moveq	r8,r9
8000b7d2:	58 08       	cp.w	r8,0
8000b7d4:	5e 5c       	retlt	r12
8000b7d6:	ed b8 00 1e 	bld	r8,0x1e
8000b7da:	f9 bc 01 20 	movne	r12,32
8000b7de:	f7 bc 00 ff 	subeq	r12,-1
8000b7e2:	5e fc       	retal	r12

8000b7e4 <__lo0bits>:
8000b7e4:	18 99       	mov	r9,r12
8000b7e6:	78 08       	ld.w	r8,r12[0x0]
8000b7e8:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b7ec:	c1 50       	breq	8000b816 <__lo0bits+0x32>
8000b7ee:	ed b8 00 00 	bld	r8,0x0
8000b7f2:	c0 21       	brne	8000b7f6 <__lo0bits+0x12>
8000b7f4:	5e fd       	retal	0
8000b7f6:	10 9b       	mov	r11,r8
8000b7f8:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b7fc:	e2 1b 00 02 	andl	r11,0x2,COH
8000b800:	a3 88       	lsr	r8,0x2
8000b802:	58 0b       	cp.w	r11,0
8000b804:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b808:	f9 bc 01 01 	movne	r12,1
8000b80c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b810:	f9 bc 00 02 	moveq	r12,2
8000b814:	5e fc       	retal	r12
8000b816:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b81a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b81e:	58 0a       	cp.w	r10,0
8000b820:	f6 08 17 00 	moveq	r8,r11
8000b824:	f9 bc 00 10 	moveq	r12,16
8000b828:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b82c:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b830:	58 0b       	cp.w	r11,0
8000b832:	f7 bc 00 f8 	subeq	r12,-8
8000b836:	f4 08 17 00 	moveq	r8,r10
8000b83a:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b83e:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b842:	58 0b       	cp.w	r11,0
8000b844:	f7 bc 00 fc 	subeq	r12,-4
8000b848:	f4 08 17 00 	moveq	r8,r10
8000b84c:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b850:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b854:	58 0b       	cp.w	r11,0
8000b856:	f7 bc 00 fe 	subeq	r12,-2
8000b85a:	f4 08 17 00 	moveq	r8,r10
8000b85e:	ed b8 00 00 	bld	r8,0x0
8000b862:	c0 60       	breq	8000b86e <__lo0bits+0x8a>
8000b864:	a1 98       	lsr	r8,0x1
8000b866:	c0 31       	brne	8000b86c <__lo0bits+0x88>
8000b868:	32 0c       	mov	r12,32
8000b86a:	5e fc       	retal	r12
8000b86c:	2f fc       	sub	r12,-1
8000b86e:	93 08       	st.w	r9[0x0],r8
8000b870:	5e fc       	retal	r12

8000b872 <__mcmp>:
8000b872:	d4 01       	pushm	lr
8000b874:	18 98       	mov	r8,r12
8000b876:	76 49       	ld.w	r9,r11[0x10]
8000b878:	78 4c       	ld.w	r12,r12[0x10]
8000b87a:	12 1c       	sub	r12,r9
8000b87c:	c1 31       	brne	8000b8a2 <__mcmp+0x30>
8000b87e:	2f b9       	sub	r9,-5
8000b880:	a3 69       	lsl	r9,0x2
8000b882:	12 0b       	add	r11,r9
8000b884:	f0 09 00 09 	add	r9,r8,r9
8000b888:	2e c8       	sub	r8,-20
8000b88a:	13 4e       	ld.w	lr,--r9
8000b88c:	17 4a       	ld.w	r10,--r11
8000b88e:	14 3e       	cp.w	lr,r10
8000b890:	c0 60       	breq	8000b89c <__mcmp+0x2a>
8000b892:	f9 bc 03 ff 	movlo	r12,-1
8000b896:	f9 bc 02 01 	movhs	r12,1
8000b89a:	d8 02       	popm	pc
8000b89c:	10 39       	cp.w	r9,r8
8000b89e:	fe 9b ff f6 	brhi	8000b88a <__mcmp+0x18>
8000b8a2:	d8 02       	popm	pc

8000b8a4 <_Bfree>:
8000b8a4:	d4 21       	pushm	r4-r7,lr
8000b8a6:	18 97       	mov	r7,r12
8000b8a8:	16 95       	mov	r5,r11
8000b8aa:	78 96       	ld.w	r6,r12[0x24]
8000b8ac:	58 06       	cp.w	r6,0
8000b8ae:	c0 91       	brne	8000b8c0 <_Bfree+0x1c>
8000b8b0:	31 0c       	mov	r12,16
8000b8b2:	fe b0 de 49 	rcall	80007544 <malloc>
8000b8b6:	99 36       	st.w	r12[0xc],r6
8000b8b8:	8f 9c       	st.w	r7[0x24],r12
8000b8ba:	99 16       	st.w	r12[0x4],r6
8000b8bc:	99 26       	st.w	r12[0x8],r6
8000b8be:	99 06       	st.w	r12[0x0],r6
8000b8c0:	58 05       	cp.w	r5,0
8000b8c2:	c0 90       	breq	8000b8d4 <_Bfree+0x30>
8000b8c4:	6a 19       	ld.w	r9,r5[0x4]
8000b8c6:	6e 98       	ld.w	r8,r7[0x24]
8000b8c8:	70 38       	ld.w	r8,r8[0xc]
8000b8ca:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000b8ce:	8b 0a       	st.w	r5[0x0],r10
8000b8d0:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000b8d4:	d8 22       	popm	r4-r7,pc
8000b8d6:	d7 03       	nop

8000b8d8 <_Balloc>:
8000b8d8:	d4 21       	pushm	r4-r7,lr
8000b8da:	18 97       	mov	r7,r12
8000b8dc:	16 96       	mov	r6,r11
8000b8de:	78 95       	ld.w	r5,r12[0x24]
8000b8e0:	58 05       	cp.w	r5,0
8000b8e2:	c0 91       	brne	8000b8f4 <_Balloc+0x1c>
8000b8e4:	31 0c       	mov	r12,16
8000b8e6:	fe b0 de 2f 	rcall	80007544 <malloc>
8000b8ea:	99 35       	st.w	r12[0xc],r5
8000b8ec:	8f 9c       	st.w	r7[0x24],r12
8000b8ee:	99 15       	st.w	r12[0x4],r5
8000b8f0:	99 25       	st.w	r12[0x8],r5
8000b8f2:	99 05       	st.w	r12[0x0],r5
8000b8f4:	6e 95       	ld.w	r5,r7[0x24]
8000b8f6:	6a 38       	ld.w	r8,r5[0xc]
8000b8f8:	58 08       	cp.w	r8,0
8000b8fa:	c0 b1       	brne	8000b910 <_Balloc+0x38>
8000b8fc:	31 0a       	mov	r10,16
8000b8fe:	30 4b       	mov	r11,4
8000b900:	0e 9c       	mov	r12,r7
8000b902:	e0 a0 02 a7 	rcall	8000be50 <_calloc_r>
8000b906:	8b 3c       	st.w	r5[0xc],r12
8000b908:	6e 98       	ld.w	r8,r7[0x24]
8000b90a:	70 3c       	ld.w	r12,r8[0xc]
8000b90c:	58 0c       	cp.w	r12,0
8000b90e:	c1 b0       	breq	8000b944 <_Balloc+0x6c>
8000b910:	6e 98       	ld.w	r8,r7[0x24]
8000b912:	70 38       	ld.w	r8,r8[0xc]
8000b914:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000b918:	70 0c       	ld.w	r12,r8[0x0]
8000b91a:	58 0c       	cp.w	r12,0
8000b91c:	c0 40       	breq	8000b924 <_Balloc+0x4c>
8000b91e:	78 09       	ld.w	r9,r12[0x0]
8000b920:	91 09       	st.w	r8[0x0],r9
8000b922:	c0 e8       	rjmp	8000b93e <_Balloc+0x66>
8000b924:	0e 9c       	mov	r12,r7
8000b926:	30 17       	mov	r7,1
8000b928:	0e 9b       	mov	r11,r7
8000b92a:	ee 06 09 47 	lsl	r7,r7,r6
8000b92e:	ee ca ff fb 	sub	r10,r7,-5
8000b932:	a3 6a       	lsl	r10,0x2
8000b934:	e0 a0 02 8e 	rcall	8000be50 <_calloc_r>
8000b938:	c0 60       	breq	8000b944 <_Balloc+0x6c>
8000b93a:	99 16       	st.w	r12[0x4],r6
8000b93c:	99 27       	st.w	r12[0x8],r7
8000b93e:	30 08       	mov	r8,0
8000b940:	99 38       	st.w	r12[0xc],r8
8000b942:	99 48       	st.w	r12[0x10],r8
8000b944:	d8 22       	popm	r4-r7,pc
8000b946:	d7 03       	nop

8000b948 <__d2b>:
8000b948:	d4 31       	pushm	r0-r7,lr
8000b94a:	20 2d       	sub	sp,8
8000b94c:	16 93       	mov	r3,r11
8000b94e:	12 96       	mov	r6,r9
8000b950:	10 95       	mov	r5,r8
8000b952:	14 92       	mov	r2,r10
8000b954:	30 1b       	mov	r11,1
8000b956:	cc 1f       	rcall	8000b8d8 <_Balloc>
8000b958:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000b95c:	50 09       	stdsp	sp[0x0],r9
8000b95e:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000b962:	b5 a9       	sbr	r9,0x14
8000b964:	f0 01 16 14 	lsr	r1,r8,0x14
8000b968:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b96c:	18 94       	mov	r4,r12
8000b96e:	58 02       	cp.w	r2,0
8000b970:	c1 d0       	breq	8000b9aa <__d2b+0x62>
8000b972:	fa cc ff f8 	sub	r12,sp,-8
8000b976:	18 d2       	st.w	--r12,r2
8000b978:	c3 6f       	rcall	8000b7e4 <__lo0bits>
8000b97a:	40 18       	lddsp	r8,sp[0x4]
8000b97c:	c0 d0       	breq	8000b996 <__d2b+0x4e>
8000b97e:	40 09       	lddsp	r9,sp[0x0]
8000b980:	f8 0a 11 20 	rsub	r10,r12,32
8000b984:	f2 0a 09 4a 	lsl	r10,r9,r10
8000b988:	f5 e8 10 08 	or	r8,r10,r8
8000b98c:	89 58       	st.w	r4[0x14],r8
8000b98e:	f2 0c 0a 49 	lsr	r9,r9,r12
8000b992:	50 09       	stdsp	sp[0x0],r9
8000b994:	c0 28       	rjmp	8000b998 <__d2b+0x50>
8000b996:	89 58       	st.w	r4[0x14],r8
8000b998:	40 08       	lddsp	r8,sp[0x0]
8000b99a:	58 08       	cp.w	r8,0
8000b99c:	f9 b3 01 02 	movne	r3,2
8000b9a0:	f9 b3 00 01 	moveq	r3,1
8000b9a4:	89 68       	st.w	r4[0x18],r8
8000b9a6:	89 43       	st.w	r4[0x10],r3
8000b9a8:	c0 88       	rjmp	8000b9b8 <__d2b+0x70>
8000b9aa:	1a 9c       	mov	r12,sp
8000b9ac:	c1 cf       	rcall	8000b7e4 <__lo0bits>
8000b9ae:	30 13       	mov	r3,1
8000b9b0:	40 08       	lddsp	r8,sp[0x0]
8000b9b2:	2e 0c       	sub	r12,-32
8000b9b4:	89 43       	st.w	r4[0x10],r3
8000b9b6:	89 58       	st.w	r4[0x14],r8
8000b9b8:	58 01       	cp.w	r1,0
8000b9ba:	c0 90       	breq	8000b9cc <__d2b+0x84>
8000b9bc:	e2 c1 04 33 	sub	r1,r1,1075
8000b9c0:	18 01       	add	r1,r12
8000b9c2:	8d 01       	st.w	r6[0x0],r1
8000b9c4:	f8 0c 11 35 	rsub	r12,r12,53
8000b9c8:	8b 0c       	st.w	r5[0x0],r12
8000b9ca:	c0 c8       	rjmp	8000b9e2 <__d2b+0x9a>
8000b9cc:	e6 c8 ff fc 	sub	r8,r3,-4
8000b9d0:	f8 cc 04 32 	sub	r12,r12,1074
8000b9d4:	a5 73       	lsl	r3,0x5
8000b9d6:	8d 0c       	st.w	r6[0x0],r12
8000b9d8:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000b9dc:	cd 4e       	rcall	8000b784 <__hi0bits>
8000b9de:	18 13       	sub	r3,r12
8000b9e0:	8b 03       	st.w	r5[0x0],r3
8000b9e2:	08 9c       	mov	r12,r4
8000b9e4:	2f ed       	sub	sp,-8
8000b9e6:	d8 32       	popm	r0-r7,pc

8000b9e8 <__mdiff>:
8000b9e8:	d4 31       	pushm	r0-r7,lr
8000b9ea:	74 48       	ld.w	r8,r10[0x10]
8000b9ec:	76 45       	ld.w	r5,r11[0x10]
8000b9ee:	16 97       	mov	r7,r11
8000b9f0:	14 96       	mov	r6,r10
8000b9f2:	10 15       	sub	r5,r8
8000b9f4:	c1 31       	brne	8000ba1a <__mdiff+0x32>
8000b9f6:	2f b8       	sub	r8,-5
8000b9f8:	ee ce ff ec 	sub	lr,r7,-20
8000b9fc:	a3 68       	lsl	r8,0x2
8000b9fe:	f4 08 00 0b 	add	r11,r10,r8
8000ba02:	ee 08 00 08 	add	r8,r7,r8
8000ba06:	11 4a       	ld.w	r10,--r8
8000ba08:	17 49       	ld.w	r9,--r11
8000ba0a:	12 3a       	cp.w	r10,r9
8000ba0c:	c0 30       	breq	8000ba12 <__mdiff+0x2a>
8000ba0e:	c0 e2       	brcc	8000ba2a <__mdiff+0x42>
8000ba10:	c0 78       	rjmp	8000ba1e <__mdiff+0x36>
8000ba12:	1c 38       	cp.w	r8,lr
8000ba14:	fe 9b ff f9 	brhi	8000ba06 <__mdiff+0x1e>
8000ba18:	c4 98       	rjmp	8000baaa <__mdiff+0xc2>
8000ba1a:	58 05       	cp.w	r5,0
8000ba1c:	c0 64       	brge	8000ba28 <__mdiff+0x40>
8000ba1e:	0e 98       	mov	r8,r7
8000ba20:	30 15       	mov	r5,1
8000ba22:	0c 97       	mov	r7,r6
8000ba24:	10 96       	mov	r6,r8
8000ba26:	c0 28       	rjmp	8000ba2a <__mdiff+0x42>
8000ba28:	30 05       	mov	r5,0
8000ba2a:	6e 1b       	ld.w	r11,r7[0x4]
8000ba2c:	c5 6f       	rcall	8000b8d8 <_Balloc>
8000ba2e:	6e 49       	ld.w	r9,r7[0x10]
8000ba30:	6c 44       	ld.w	r4,r6[0x10]
8000ba32:	99 35       	st.w	r12[0xc],r5
8000ba34:	2f b4       	sub	r4,-5
8000ba36:	f2 c5 ff fb 	sub	r5,r9,-5
8000ba3a:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000ba3e:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000ba42:	2e c6       	sub	r6,-20
8000ba44:	2e c7       	sub	r7,-20
8000ba46:	f8 c8 ff ec 	sub	r8,r12,-20
8000ba4a:	30 0a       	mov	r10,0
8000ba4c:	0f 0e       	ld.w	lr,r7++
8000ba4e:	0d 0b       	ld.w	r11,r6++
8000ba50:	fc 02 16 10 	lsr	r2,lr,0x10
8000ba54:	f6 03 16 10 	lsr	r3,r11,0x10
8000ba58:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ba5c:	e4 03 01 03 	sub	r3,r2,r3
8000ba60:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ba64:	fc 0b 01 0b 	sub	r11,lr,r11
8000ba68:	f6 0a 00 0a 	add	r10,r11,r10
8000ba6c:	b0 1a       	st.h	r8[0x2],r10
8000ba6e:	b1 4a       	asr	r10,0x10
8000ba70:	e6 0a 00 0a 	add	r10,r3,r10
8000ba74:	b0 0a       	st.h	r8[0x0],r10
8000ba76:	2f c8       	sub	r8,-4
8000ba78:	b1 4a       	asr	r10,0x10
8000ba7a:	08 36       	cp.w	r6,r4
8000ba7c:	ce 83       	brcs	8000ba4c <__mdiff+0x64>
8000ba7e:	c0 d8       	rjmp	8000ba98 <__mdiff+0xb0>
8000ba80:	0f 0b       	ld.w	r11,r7++
8000ba82:	f6 0e 16 10 	lsr	lr,r11,0x10
8000ba86:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000ba8a:	16 0a       	add	r10,r11
8000ba8c:	b0 1a       	st.h	r8[0x2],r10
8000ba8e:	b1 4a       	asr	r10,0x10
8000ba90:	1c 0a       	add	r10,lr
8000ba92:	b0 0a       	st.h	r8[0x0],r10
8000ba94:	2f c8       	sub	r8,-4
8000ba96:	b1 4a       	asr	r10,0x10
8000ba98:	0a 37       	cp.w	r7,r5
8000ba9a:	cf 33       	brcs	8000ba80 <__mdiff+0x98>
8000ba9c:	c0 28       	rjmp	8000baa0 <__mdiff+0xb8>
8000ba9e:	20 19       	sub	r9,1
8000baa0:	11 4a       	ld.w	r10,--r8
8000baa2:	58 0a       	cp.w	r10,0
8000baa4:	cf d0       	breq	8000ba9e <__mdiff+0xb6>
8000baa6:	99 49       	st.w	r12[0x10],r9
8000baa8:	d8 32       	popm	r0-r7,pc
8000baaa:	30 0b       	mov	r11,0
8000baac:	c1 6f       	rcall	8000b8d8 <_Balloc>
8000baae:	30 18       	mov	r8,1
8000bab0:	99 48       	st.w	r12[0x10],r8
8000bab2:	30 08       	mov	r8,0
8000bab4:	99 58       	st.w	r12[0x14],r8
8000bab6:	d8 32       	popm	r0-r7,pc

8000bab8 <__lshift>:
8000bab8:	d4 31       	pushm	r0-r7,lr
8000baba:	16 97       	mov	r7,r11
8000babc:	76 46       	ld.w	r6,r11[0x10]
8000babe:	f4 02 14 05 	asr	r2,r10,0x5
8000bac2:	2f f6       	sub	r6,-1
8000bac4:	14 93       	mov	r3,r10
8000bac6:	18 94       	mov	r4,r12
8000bac8:	04 06       	add	r6,r2
8000baca:	76 1b       	ld.w	r11,r11[0x4]
8000bacc:	6e 28       	ld.w	r8,r7[0x8]
8000bace:	c0 38       	rjmp	8000bad4 <__lshift+0x1c>
8000bad0:	2f fb       	sub	r11,-1
8000bad2:	a1 78       	lsl	r8,0x1
8000bad4:	10 36       	cp.w	r6,r8
8000bad6:	fe 99 ff fd 	brgt	8000bad0 <__lshift+0x18>
8000bada:	08 9c       	mov	r12,r4
8000badc:	cf ee       	rcall	8000b8d8 <_Balloc>
8000bade:	30 09       	mov	r9,0
8000bae0:	18 95       	mov	r5,r12
8000bae2:	f8 c8 ff ec 	sub	r8,r12,-20
8000bae6:	12 9a       	mov	r10,r9
8000bae8:	c0 38       	rjmp	8000baee <__lshift+0x36>
8000baea:	10 aa       	st.w	r8++,r10
8000baec:	2f f9       	sub	r9,-1
8000baee:	04 39       	cp.w	r9,r2
8000baf0:	cf d5       	brlt	8000baea <__lshift+0x32>
8000baf2:	6e 4b       	ld.w	r11,r7[0x10]
8000baf4:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000baf8:	2f bb       	sub	r11,-5
8000bafa:	ee c9 ff ec 	sub	r9,r7,-20
8000bafe:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000bb02:	58 03       	cp.w	r3,0
8000bb04:	c1 30       	breq	8000bb2a <__lshift+0x72>
8000bb06:	e6 0c 11 20 	rsub	r12,r3,32
8000bb0a:	30 0a       	mov	r10,0
8000bb0c:	72 02       	ld.w	r2,r9[0x0]
8000bb0e:	e4 03 09 42 	lsl	r2,r2,r3
8000bb12:	04 4a       	or	r10,r2
8000bb14:	10 aa       	st.w	r8++,r10
8000bb16:	13 0a       	ld.w	r10,r9++
8000bb18:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bb1c:	16 39       	cp.w	r9,r11
8000bb1e:	cf 73       	brcs	8000bb0c <__lshift+0x54>
8000bb20:	91 0a       	st.w	r8[0x0],r10
8000bb22:	58 0a       	cp.w	r10,0
8000bb24:	c0 70       	breq	8000bb32 <__lshift+0x7a>
8000bb26:	2f f6       	sub	r6,-1
8000bb28:	c0 58       	rjmp	8000bb32 <__lshift+0x7a>
8000bb2a:	13 0a       	ld.w	r10,r9++
8000bb2c:	10 aa       	st.w	r8++,r10
8000bb2e:	16 39       	cp.w	r9,r11
8000bb30:	cf d3       	brcs	8000bb2a <__lshift+0x72>
8000bb32:	08 9c       	mov	r12,r4
8000bb34:	20 16       	sub	r6,1
8000bb36:	0e 9b       	mov	r11,r7
8000bb38:	8b 46       	st.w	r5[0x10],r6
8000bb3a:	cb 5e       	rcall	8000b8a4 <_Bfree>
8000bb3c:	0a 9c       	mov	r12,r5
8000bb3e:	d8 32       	popm	r0-r7,pc

8000bb40 <__multiply>:
8000bb40:	d4 31       	pushm	r0-r7,lr
8000bb42:	20 2d       	sub	sp,8
8000bb44:	76 49       	ld.w	r9,r11[0x10]
8000bb46:	74 48       	ld.w	r8,r10[0x10]
8000bb48:	16 96       	mov	r6,r11
8000bb4a:	14 95       	mov	r5,r10
8000bb4c:	10 39       	cp.w	r9,r8
8000bb4e:	ec 08 17 50 	movlt	r8,r6
8000bb52:	ea 06 17 50 	movlt	r6,r5
8000bb56:	f0 05 17 50 	movlt	r5,r8
8000bb5a:	6c 28       	ld.w	r8,r6[0x8]
8000bb5c:	76 43       	ld.w	r3,r11[0x10]
8000bb5e:	74 42       	ld.w	r2,r10[0x10]
8000bb60:	76 1b       	ld.w	r11,r11[0x4]
8000bb62:	e4 03 00 07 	add	r7,r2,r3
8000bb66:	10 37       	cp.w	r7,r8
8000bb68:	f7 bb 09 ff 	subgt	r11,-1
8000bb6c:	cb 6e       	rcall	8000b8d8 <_Balloc>
8000bb6e:	ee c4 ff fb 	sub	r4,r7,-5
8000bb72:	f8 c9 ff ec 	sub	r9,r12,-20
8000bb76:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000bb7a:	30 0a       	mov	r10,0
8000bb7c:	12 98       	mov	r8,r9
8000bb7e:	c0 28       	rjmp	8000bb82 <__multiply+0x42>
8000bb80:	10 aa       	st.w	r8++,r10
8000bb82:	08 38       	cp.w	r8,r4
8000bb84:	cf e3       	brcs	8000bb80 <__multiply+0x40>
8000bb86:	2f b3       	sub	r3,-5
8000bb88:	2f b2       	sub	r2,-5
8000bb8a:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000bb8e:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000bb92:	ec cb ff ec 	sub	r11,r6,-20
8000bb96:	50 12       	stdsp	sp[0x4],r2
8000bb98:	ea ca ff ec 	sub	r10,r5,-20
8000bb9c:	c4 48       	rjmp	8000bc24 <__multiply+0xe4>
8000bb9e:	94 95       	ld.uh	r5,r10[0x2]
8000bba0:	58 05       	cp.w	r5,0
8000bba2:	c2 00       	breq	8000bbe2 <__multiply+0xa2>
8000bba4:	12 98       	mov	r8,r9
8000bba6:	16 96       	mov	r6,r11
8000bba8:	30 0e       	mov	lr,0
8000bbaa:	50 09       	stdsp	sp[0x0],r9
8000bbac:	0d 02       	ld.w	r2,r6++
8000bbae:	e4 00 16 10 	lsr	r0,r2,0x10
8000bbb2:	70 01       	ld.w	r1,r8[0x0]
8000bbb4:	70 09       	ld.w	r9,r8[0x0]
8000bbb6:	b1 81       	lsr	r1,0x10
8000bbb8:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000bbbc:	e0 05 03 41 	mac	r1,r0,r5
8000bbc0:	ab 32       	mul	r2,r5
8000bbc2:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000bbc6:	00 02       	add	r2,r0
8000bbc8:	e4 0e 00 0e 	add	lr,r2,lr
8000bbcc:	b0 1e       	st.h	r8[0x2],lr
8000bbce:	b1 8e       	lsr	lr,0x10
8000bbd0:	1c 01       	add	r1,lr
8000bbd2:	b0 01       	st.h	r8[0x0],r1
8000bbd4:	e2 0e 16 10 	lsr	lr,r1,0x10
8000bbd8:	2f c8       	sub	r8,-4
8000bbda:	06 36       	cp.w	r6,r3
8000bbdc:	ce 83       	brcs	8000bbac <__multiply+0x6c>
8000bbde:	40 09       	lddsp	r9,sp[0x0]
8000bbe0:	91 0e       	st.w	r8[0x0],lr
8000bbe2:	94 86       	ld.uh	r6,r10[0x0]
8000bbe4:	58 06       	cp.w	r6,0
8000bbe6:	c1 d0       	breq	8000bc20 <__multiply+0xe0>
8000bbe8:	72 02       	ld.w	r2,r9[0x0]
8000bbea:	12 98       	mov	r8,r9
8000bbec:	16 9e       	mov	lr,r11
8000bbee:	30 05       	mov	r5,0
8000bbf0:	b0 12       	st.h	r8[0x2],r2
8000bbf2:	1d 01       	ld.w	r1,lr++
8000bbf4:	90 82       	ld.uh	r2,r8[0x0]
8000bbf6:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bbfa:	ad 30       	mul	r0,r6
8000bbfc:	e0 02 00 02 	add	r2,r0,r2
8000bc00:	e4 05 00 05 	add	r5,r2,r5
8000bc04:	b0 05       	st.h	r8[0x0],r5
8000bc06:	b1 85       	lsr	r5,0x10
8000bc08:	b1 81       	lsr	r1,0x10
8000bc0a:	2f c8       	sub	r8,-4
8000bc0c:	ad 31       	mul	r1,r6
8000bc0e:	90 92       	ld.uh	r2,r8[0x2]
8000bc10:	e2 02 00 02 	add	r2,r1,r2
8000bc14:	0a 02       	add	r2,r5
8000bc16:	e4 05 16 10 	lsr	r5,r2,0x10
8000bc1a:	06 3e       	cp.w	lr,r3
8000bc1c:	ce a3       	brcs	8000bbf0 <__multiply+0xb0>
8000bc1e:	91 02       	st.w	r8[0x0],r2
8000bc20:	2f ca       	sub	r10,-4
8000bc22:	2f c9       	sub	r9,-4
8000bc24:	40 18       	lddsp	r8,sp[0x4]
8000bc26:	10 3a       	cp.w	r10,r8
8000bc28:	cb b3       	brcs	8000bb9e <__multiply+0x5e>
8000bc2a:	c0 28       	rjmp	8000bc2e <__multiply+0xee>
8000bc2c:	20 17       	sub	r7,1
8000bc2e:	58 07       	cp.w	r7,0
8000bc30:	e0 8a 00 05 	brle	8000bc3a <__multiply+0xfa>
8000bc34:	09 48       	ld.w	r8,--r4
8000bc36:	58 08       	cp.w	r8,0
8000bc38:	cf a0       	breq	8000bc2c <__multiply+0xec>
8000bc3a:	99 47       	st.w	r12[0x10],r7
8000bc3c:	2f ed       	sub	sp,-8
8000bc3e:	d8 32       	popm	r0-r7,pc

8000bc40 <__i2b>:
8000bc40:	d4 21       	pushm	r4-r7,lr
8000bc42:	16 97       	mov	r7,r11
8000bc44:	30 1b       	mov	r11,1
8000bc46:	c4 9e       	rcall	8000b8d8 <_Balloc>
8000bc48:	30 19       	mov	r9,1
8000bc4a:	99 57       	st.w	r12[0x14],r7
8000bc4c:	99 49       	st.w	r12[0x10],r9
8000bc4e:	d8 22       	popm	r4-r7,pc

8000bc50 <__multadd>:
8000bc50:	d4 31       	pushm	r0-r7,lr
8000bc52:	30 08       	mov	r8,0
8000bc54:	12 95       	mov	r5,r9
8000bc56:	16 97       	mov	r7,r11
8000bc58:	18 96       	mov	r6,r12
8000bc5a:	76 44       	ld.w	r4,r11[0x10]
8000bc5c:	f6 c9 ff ec 	sub	r9,r11,-20
8000bc60:	72 0b       	ld.w	r11,r9[0x0]
8000bc62:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bc66:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bc6a:	f4 0c 02 4c 	mul	r12,r10,r12
8000bc6e:	f4 0b 03 45 	mac	r5,r10,r11
8000bc72:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000bc76:	b1 85       	lsr	r5,0x10
8000bc78:	18 05       	add	r5,r12
8000bc7a:	ea 0c 15 10 	lsl	r12,r5,0x10
8000bc7e:	f8 0b 00 0b 	add	r11,r12,r11
8000bc82:	12 ab       	st.w	r9++,r11
8000bc84:	2f f8       	sub	r8,-1
8000bc86:	b1 85       	lsr	r5,0x10
8000bc88:	08 38       	cp.w	r8,r4
8000bc8a:	ce b5       	brlt	8000bc60 <__multadd+0x10>
8000bc8c:	58 05       	cp.w	r5,0
8000bc8e:	c1 c0       	breq	8000bcc6 <__multadd+0x76>
8000bc90:	6e 28       	ld.w	r8,r7[0x8]
8000bc92:	10 34       	cp.w	r4,r8
8000bc94:	c1 35       	brlt	8000bcba <__multadd+0x6a>
8000bc96:	6e 1b       	ld.w	r11,r7[0x4]
8000bc98:	0c 9c       	mov	r12,r6
8000bc9a:	2f fb       	sub	r11,-1
8000bc9c:	c1 ee       	rcall	8000b8d8 <_Balloc>
8000bc9e:	6e 4a       	ld.w	r10,r7[0x10]
8000bca0:	ee cb ff f4 	sub	r11,r7,-12
8000bca4:	18 93       	mov	r3,r12
8000bca6:	2f ea       	sub	r10,-2
8000bca8:	2f 4c       	sub	r12,-12
8000bcaa:	a3 6a       	lsl	r10,0x2
8000bcac:	fe b0 de 70 	rcall	8000798c <memcpy>
8000bcb0:	0e 9b       	mov	r11,r7
8000bcb2:	0c 9c       	mov	r12,r6
8000bcb4:	fe b0 fd f8 	rcall	8000b8a4 <_Bfree>
8000bcb8:	06 97       	mov	r7,r3
8000bcba:	e8 c8 ff ff 	sub	r8,r4,-1
8000bcbe:	2f b4       	sub	r4,-5
8000bcc0:	8f 48       	st.w	r7[0x10],r8
8000bcc2:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000bcc6:	0e 9c       	mov	r12,r7
8000bcc8:	d8 32       	popm	r0-r7,pc
8000bcca:	d7 03       	nop

8000bccc <__pow5mult>:
8000bccc:	d4 31       	pushm	r0-r7,lr
8000bcce:	14 96       	mov	r6,r10
8000bcd0:	18 97       	mov	r7,r12
8000bcd2:	16 94       	mov	r4,r11
8000bcd4:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000bcd8:	c0 90       	breq	8000bcea <__pow5mult+0x1e>
8000bcda:	20 18       	sub	r8,1
8000bcdc:	fe c9 d8 f8 	sub	r9,pc,-9992
8000bce0:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000bce4:	30 09       	mov	r9,0
8000bce6:	cb 5f       	rcall	8000bc50 <__multadd>
8000bce8:	18 94       	mov	r4,r12
8000bcea:	a3 46       	asr	r6,0x2
8000bcec:	c3 40       	breq	8000bd54 <__pow5mult+0x88>
8000bcee:	6e 95       	ld.w	r5,r7[0x24]
8000bcf0:	58 05       	cp.w	r5,0
8000bcf2:	c0 91       	brne	8000bd04 <__pow5mult+0x38>
8000bcf4:	31 0c       	mov	r12,16
8000bcf6:	fe b0 dc 27 	rcall	80007544 <malloc>
8000bcfa:	99 35       	st.w	r12[0xc],r5
8000bcfc:	8f 9c       	st.w	r7[0x24],r12
8000bcfe:	99 15       	st.w	r12[0x4],r5
8000bd00:	99 25       	st.w	r12[0x8],r5
8000bd02:	99 05       	st.w	r12[0x0],r5
8000bd04:	6e 93       	ld.w	r3,r7[0x24]
8000bd06:	66 25       	ld.w	r5,r3[0x8]
8000bd08:	58 05       	cp.w	r5,0
8000bd0a:	c0 c1       	brne	8000bd22 <__pow5mult+0x56>
8000bd0c:	e0 6b 02 71 	mov	r11,625
8000bd10:	0e 9c       	mov	r12,r7
8000bd12:	c9 7f       	rcall	8000bc40 <__i2b>
8000bd14:	87 2c       	st.w	r3[0x8],r12
8000bd16:	30 08       	mov	r8,0
8000bd18:	18 95       	mov	r5,r12
8000bd1a:	99 08       	st.w	r12[0x0],r8
8000bd1c:	c0 38       	rjmp	8000bd22 <__pow5mult+0x56>
8000bd1e:	06 9c       	mov	r12,r3
8000bd20:	18 95       	mov	r5,r12
8000bd22:	ed b6 00 00 	bld	r6,0x0
8000bd26:	c0 b1       	brne	8000bd3c <__pow5mult+0x70>
8000bd28:	08 9b       	mov	r11,r4
8000bd2a:	0a 9a       	mov	r10,r5
8000bd2c:	0e 9c       	mov	r12,r7
8000bd2e:	c0 9f       	rcall	8000bb40 <__multiply>
8000bd30:	08 9b       	mov	r11,r4
8000bd32:	18 93       	mov	r3,r12
8000bd34:	0e 9c       	mov	r12,r7
8000bd36:	06 94       	mov	r4,r3
8000bd38:	fe b0 fd b6 	rcall	8000b8a4 <_Bfree>
8000bd3c:	a1 56       	asr	r6,0x1
8000bd3e:	c0 b0       	breq	8000bd54 <__pow5mult+0x88>
8000bd40:	6a 03       	ld.w	r3,r5[0x0]
8000bd42:	58 03       	cp.w	r3,0
8000bd44:	ce d1       	brne	8000bd1e <__pow5mult+0x52>
8000bd46:	0a 9a       	mov	r10,r5
8000bd48:	0a 9b       	mov	r11,r5
8000bd4a:	0e 9c       	mov	r12,r7
8000bd4c:	cf ae       	rcall	8000bb40 <__multiply>
8000bd4e:	8b 0c       	st.w	r5[0x0],r12
8000bd50:	99 03       	st.w	r12[0x0],r3
8000bd52:	ce 7b       	rjmp	8000bd20 <__pow5mult+0x54>
8000bd54:	08 9c       	mov	r12,r4
8000bd56:	d8 32       	popm	r0-r7,pc

8000bd58 <__isinfd>:
8000bd58:	14 98       	mov	r8,r10
8000bd5a:	fc 19 7f f0 	movh	r9,0x7ff0
8000bd5e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bd62:	f0 0b 11 00 	rsub	r11,r8,0
8000bd66:	f7 e8 10 08 	or	r8,r11,r8
8000bd6a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bd6e:	f2 08 01 08 	sub	r8,r9,r8
8000bd72:	f0 0c 11 00 	rsub	r12,r8,0
8000bd76:	f9 e8 10 08 	or	r8,r12,r8
8000bd7a:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bd7e:	2f fc       	sub	r12,-1
8000bd80:	5e fc       	retal	r12

8000bd82 <__isnand>:
8000bd82:	14 98       	mov	r8,r10
8000bd84:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bd88:	f0 0c 11 00 	rsub	r12,r8,0
8000bd8c:	10 4c       	or	r12,r8
8000bd8e:	fc 18 7f f0 	movh	r8,0x7ff0
8000bd92:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bd96:	f0 0c 01 0c 	sub	r12,r8,r12
8000bd9a:	bf 9c       	lsr	r12,0x1f
8000bd9c:	5e fc       	retal	r12
8000bd9e:	d7 03       	nop

8000bda0 <__sclose>:
8000bda0:	d4 01       	pushm	lr
8000bda2:	96 7b       	ld.sh	r11,r11[0xe]
8000bda4:	c8 2c       	rcall	8000bea8 <_close_r>
8000bda6:	d8 02       	popm	pc

8000bda8 <__sseek>:
8000bda8:	d4 21       	pushm	r4-r7,lr
8000bdaa:	16 97       	mov	r7,r11
8000bdac:	96 7b       	ld.sh	r11,r11[0xe]
8000bdae:	c0 3d       	rcall	8000bfb4 <_lseek_r>
8000bdb0:	8e 68       	ld.sh	r8,r7[0xc]
8000bdb2:	10 99       	mov	r9,r8
8000bdb4:	ad c8       	cbr	r8,0xc
8000bdb6:	ad a9       	sbr	r9,0xc
8000bdb8:	5b fc       	cp.w	r12,-1
8000bdba:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bdbe:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bdc2:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bdc6:	d8 22       	popm	r4-r7,pc

8000bdc8 <__swrite>:
8000bdc8:	d4 21       	pushm	r4-r7,lr
8000bdca:	96 68       	ld.sh	r8,r11[0xc]
8000bdcc:	16 97       	mov	r7,r11
8000bdce:	14 95       	mov	r5,r10
8000bdd0:	12 94       	mov	r4,r9
8000bdd2:	e2 18 01 00 	andl	r8,0x100,COH
8000bdd6:	18 96       	mov	r6,r12
8000bdd8:	c0 50       	breq	8000bde2 <__swrite+0x1a>
8000bdda:	30 29       	mov	r9,2
8000bddc:	30 0a       	mov	r10,0
8000bdde:	96 7b       	ld.sh	r11,r11[0xe]
8000bde0:	ce ac       	rcall	8000bfb4 <_lseek_r>
8000bde2:	8e 68       	ld.sh	r8,r7[0xc]
8000bde4:	ad c8       	cbr	r8,0xc
8000bde6:	08 99       	mov	r9,r4
8000bde8:	0a 9a       	mov	r10,r5
8000bdea:	8e 7b       	ld.sh	r11,r7[0xe]
8000bdec:	0c 9c       	mov	r12,r6
8000bdee:	ae 68       	st.h	r7[0xc],r8
8000bdf0:	c1 cc       	rcall	8000be28 <_write_r>
8000bdf2:	d8 22       	popm	r4-r7,pc

8000bdf4 <__sread>:
8000bdf4:	d4 21       	pushm	r4-r7,lr
8000bdf6:	16 97       	mov	r7,r11
8000bdf8:	96 7b       	ld.sh	r11,r11[0xe]
8000bdfa:	cf 1c       	rcall	8000bfdc <_read_r>
8000bdfc:	c0 65       	brlt	8000be08 <__sread+0x14>
8000bdfe:	6f 58       	ld.w	r8,r7[0x54]
8000be00:	18 08       	add	r8,r12
8000be02:	ef 48 00 54 	st.w	r7[84],r8
8000be06:	d8 22       	popm	r4-r7,pc
8000be08:	8e 68       	ld.sh	r8,r7[0xc]
8000be0a:	ad c8       	cbr	r8,0xc
8000be0c:	ae 68       	st.h	r7[0xc],r8
8000be0e:	d8 22       	popm	r4-r7,pc

8000be10 <strlen>:
8000be10:	30 09       	mov	r9,0
8000be12:	18 98       	mov	r8,r12
8000be14:	c0 28       	rjmp	8000be18 <strlen+0x8>
8000be16:	2f f8       	sub	r8,-1
8000be18:	11 8a       	ld.ub	r10,r8[0x0]
8000be1a:	f2 0a 18 00 	cp.b	r10,r9
8000be1e:	cf c1       	brne	8000be16 <strlen+0x6>
8000be20:	f0 0c 01 0c 	sub	r12,r8,r12
8000be24:	5e fc       	retal	r12
8000be26:	d7 03       	nop

8000be28 <_write_r>:
8000be28:	d4 21       	pushm	r4-r7,lr
8000be2a:	16 98       	mov	r8,r11
8000be2c:	18 97       	mov	r7,r12
8000be2e:	10 9c       	mov	r12,r8
8000be30:	30 08       	mov	r8,0
8000be32:	14 9b       	mov	r11,r10
8000be34:	e0 66 53 c8 	mov	r6,21448
8000be38:	12 9a       	mov	r10,r9
8000be3a:	8d 08       	st.w	r6[0x0],r8
8000be3c:	fe b0 d1 72 	rcall	80006120 <_write>
8000be40:	5b fc       	cp.w	r12,-1
8000be42:	c0 51       	brne	8000be4c <_write_r+0x24>
8000be44:	6c 08       	ld.w	r8,r6[0x0]
8000be46:	58 08       	cp.w	r8,0
8000be48:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000be4c:	d8 22       	popm	r4-r7,pc
8000be4e:	d7 03       	nop

8000be50 <_calloc_r>:
8000be50:	d4 21       	pushm	r4-r7,lr
8000be52:	f4 0b 02 4b 	mul	r11,r10,r11
8000be56:	fe b0 db 7f 	rcall	80007554 <_malloc_r>
8000be5a:	18 97       	mov	r7,r12
8000be5c:	c2 30       	breq	8000bea2 <_calloc_r+0x52>
8000be5e:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000be62:	e0 1a ff fc 	andl	r10,0xfffc
8000be66:	20 4a       	sub	r10,4
8000be68:	e0 4a 00 24 	cp.w	r10,36
8000be6c:	e0 8b 00 18 	brhi	8000be9c <_calloc_r+0x4c>
8000be70:	18 98       	mov	r8,r12
8000be72:	59 3a       	cp.w	r10,19
8000be74:	e0 88 00 0f 	brls	8000be92 <_calloc_r+0x42>
8000be78:	30 09       	mov	r9,0
8000be7a:	10 a9       	st.w	r8++,r9
8000be7c:	10 a9       	st.w	r8++,r9
8000be7e:	59 ba       	cp.w	r10,27
8000be80:	e0 88 00 09 	brls	8000be92 <_calloc_r+0x42>
8000be84:	10 a9       	st.w	r8++,r9
8000be86:	10 a9       	st.w	r8++,r9
8000be88:	e0 4a 00 24 	cp.w	r10,36
8000be8c:	c0 31       	brne	8000be92 <_calloc_r+0x42>
8000be8e:	10 a9       	st.w	r8++,r9
8000be90:	10 a9       	st.w	r8++,r9
8000be92:	30 09       	mov	r9,0
8000be94:	10 a9       	st.w	r8++,r9
8000be96:	91 19       	st.w	r8[0x4],r9
8000be98:	91 09       	st.w	r8[0x0],r9
8000be9a:	c0 48       	rjmp	8000bea2 <_calloc_r+0x52>
8000be9c:	30 0b       	mov	r11,0
8000be9e:	fe b0 de 1b 	rcall	80007ad4 <memset>
8000bea2:	0e 9c       	mov	r12,r7
8000bea4:	d8 22       	popm	r4-r7,pc
8000bea6:	d7 03       	nop

8000bea8 <_close_r>:
8000bea8:	d4 21       	pushm	r4-r7,lr
8000beaa:	30 08       	mov	r8,0
8000beac:	18 97       	mov	r7,r12
8000beae:	e0 66 53 c8 	mov	r6,21448
8000beb2:	16 9c       	mov	r12,r11
8000beb4:	8d 08       	st.w	r6[0x0],r8
8000beb6:	fe b0 df b5 	rcall	80007e20 <_close>
8000beba:	5b fc       	cp.w	r12,-1
8000bebc:	c0 51       	brne	8000bec6 <_close_r+0x1e>
8000bebe:	6c 08       	ld.w	r8,r6[0x0]
8000bec0:	58 08       	cp.w	r8,0
8000bec2:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bec6:	d8 22       	popm	r4-r7,pc

8000bec8 <_fclose_r>:
8000bec8:	d4 21       	pushm	r4-r7,lr
8000beca:	18 96       	mov	r6,r12
8000becc:	16 97       	mov	r7,r11
8000bece:	58 0b       	cp.w	r11,0
8000bed0:	c0 31       	brne	8000bed6 <_fclose_r+0xe>
8000bed2:	16 95       	mov	r5,r11
8000bed4:	c5 38       	rjmp	8000bf7a <_fclose_r+0xb2>
8000bed6:	fe b0 f8 a9 	rcall	8000b028 <__sfp_lock_acquire>
8000beda:	58 06       	cp.w	r6,0
8000bedc:	c0 70       	breq	8000beea <_fclose_r+0x22>
8000bede:	6c 68       	ld.w	r8,r6[0x18]
8000bee0:	58 08       	cp.w	r8,0
8000bee2:	c0 41       	brne	8000beea <_fclose_r+0x22>
8000bee4:	0c 9c       	mov	r12,r6
8000bee6:	fe b0 f8 f3 	rcall	8000b0cc <__sinit>
8000beea:	fe c8 db aa 	sub	r8,pc,-9302
8000beee:	10 37       	cp.w	r7,r8
8000bef0:	c0 31       	brne	8000bef6 <_fclose_r+0x2e>
8000bef2:	6c 07       	ld.w	r7,r6[0x0]
8000bef4:	c0 c8       	rjmp	8000bf0c <_fclose_r+0x44>
8000bef6:	fe c8 db 96 	sub	r8,pc,-9322
8000befa:	10 37       	cp.w	r7,r8
8000befc:	c0 31       	brne	8000bf02 <_fclose_r+0x3a>
8000befe:	6c 17       	ld.w	r7,r6[0x4]
8000bf00:	c0 68       	rjmp	8000bf0c <_fclose_r+0x44>
8000bf02:	fe c8 db 82 	sub	r8,pc,-9342
8000bf06:	10 37       	cp.w	r7,r8
8000bf08:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000bf0c:	8e 69       	ld.sh	r9,r7[0xc]
8000bf0e:	30 08       	mov	r8,0
8000bf10:	f0 09 19 00 	cp.h	r9,r8
8000bf14:	c0 51       	brne	8000bf1e <_fclose_r+0x56>
8000bf16:	fe b0 f8 8a 	rcall	8000b02a <__sfp_lock_release>
8000bf1a:	30 05       	mov	r5,0
8000bf1c:	c2 f8       	rjmp	8000bf7a <_fclose_r+0xb2>
8000bf1e:	0e 9b       	mov	r11,r7
8000bf20:	0c 9c       	mov	r12,r6
8000bf22:	fe b0 f7 fd 	rcall	8000af1c <_fflush_r>
8000bf26:	6e c8       	ld.w	r8,r7[0x30]
8000bf28:	18 95       	mov	r5,r12
8000bf2a:	58 08       	cp.w	r8,0
8000bf2c:	c0 60       	breq	8000bf38 <_fclose_r+0x70>
8000bf2e:	6e 8b       	ld.w	r11,r7[0x20]
8000bf30:	0c 9c       	mov	r12,r6
8000bf32:	5d 18       	icall	r8
8000bf34:	f9 b5 05 ff 	movlt	r5,-1
8000bf38:	8e 68       	ld.sh	r8,r7[0xc]
8000bf3a:	ed b8 00 07 	bld	r8,0x7
8000bf3e:	c0 51       	brne	8000bf48 <_fclose_r+0x80>
8000bf40:	6e 4b       	ld.w	r11,r7[0x10]
8000bf42:	0c 9c       	mov	r12,r6
8000bf44:	fe b0 f9 5e 	rcall	8000b200 <_free_r>
8000bf48:	6e db       	ld.w	r11,r7[0x34]
8000bf4a:	58 0b       	cp.w	r11,0
8000bf4c:	c0 a0       	breq	8000bf60 <_fclose_r+0x98>
8000bf4e:	ee c8 ff bc 	sub	r8,r7,-68
8000bf52:	10 3b       	cp.w	r11,r8
8000bf54:	c0 40       	breq	8000bf5c <_fclose_r+0x94>
8000bf56:	0c 9c       	mov	r12,r6
8000bf58:	fe b0 f9 54 	rcall	8000b200 <_free_r>
8000bf5c:	30 08       	mov	r8,0
8000bf5e:	8f d8       	st.w	r7[0x34],r8
8000bf60:	6f 2b       	ld.w	r11,r7[0x48]
8000bf62:	58 0b       	cp.w	r11,0
8000bf64:	c0 70       	breq	8000bf72 <_fclose_r+0xaa>
8000bf66:	0c 9c       	mov	r12,r6
8000bf68:	fe b0 f9 4c 	rcall	8000b200 <_free_r>
8000bf6c:	30 08       	mov	r8,0
8000bf6e:	ef 48 00 48 	st.w	r7[72],r8
8000bf72:	30 08       	mov	r8,0
8000bf74:	ae 68       	st.h	r7[0xc],r8
8000bf76:	fe b0 f8 5a 	rcall	8000b02a <__sfp_lock_release>
8000bf7a:	0a 9c       	mov	r12,r5
8000bf7c:	d8 22       	popm	r4-r7,pc
8000bf7e:	d7 03       	nop

8000bf80 <fclose>:
8000bf80:	d4 01       	pushm	lr
8000bf82:	e0 68 0a 40 	mov	r8,2624
8000bf86:	18 9b       	mov	r11,r12
8000bf88:	70 0c       	ld.w	r12,r8[0x0]
8000bf8a:	c9 ff       	rcall	8000bec8 <_fclose_r>
8000bf8c:	d8 02       	popm	pc
8000bf8e:	d7 03       	nop

8000bf90 <_fstat_r>:
8000bf90:	d4 21       	pushm	r4-r7,lr
8000bf92:	16 98       	mov	r8,r11
8000bf94:	18 97       	mov	r7,r12
8000bf96:	10 9c       	mov	r12,r8
8000bf98:	30 08       	mov	r8,0
8000bf9a:	e0 66 53 c8 	mov	r6,21448
8000bf9e:	14 9b       	mov	r11,r10
8000bfa0:	8d 08       	st.w	r6[0x0],r8
8000bfa2:	fe b0 df 67 	rcall	80007e70 <_fstat>
8000bfa6:	5b fc       	cp.w	r12,-1
8000bfa8:	c0 51       	brne	8000bfb2 <_fstat_r+0x22>
8000bfaa:	6c 08       	ld.w	r8,r6[0x0]
8000bfac:	58 08       	cp.w	r8,0
8000bfae:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bfb2:	d8 22       	popm	r4-r7,pc

8000bfb4 <_lseek_r>:
8000bfb4:	d4 21       	pushm	r4-r7,lr
8000bfb6:	16 98       	mov	r8,r11
8000bfb8:	18 97       	mov	r7,r12
8000bfba:	10 9c       	mov	r12,r8
8000bfbc:	30 08       	mov	r8,0
8000bfbe:	14 9b       	mov	r11,r10
8000bfc0:	e0 66 53 c8 	mov	r6,21448
8000bfc4:	12 9a       	mov	r10,r9
8000bfc6:	8d 08       	st.w	r6[0x0],r8
8000bfc8:	fe b0 df 36 	rcall	80007e34 <_lseek>
8000bfcc:	5b fc       	cp.w	r12,-1
8000bfce:	c0 51       	brne	8000bfd8 <_lseek_r+0x24>
8000bfd0:	6c 08       	ld.w	r8,r6[0x0]
8000bfd2:	58 08       	cp.w	r8,0
8000bfd4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bfd8:	d8 22       	popm	r4-r7,pc
8000bfda:	d7 03       	nop

8000bfdc <_read_r>:
8000bfdc:	d4 21       	pushm	r4-r7,lr
8000bfde:	16 98       	mov	r8,r11
8000bfe0:	18 97       	mov	r7,r12
8000bfe2:	10 9c       	mov	r12,r8
8000bfe4:	30 08       	mov	r8,0
8000bfe6:	14 9b       	mov	r11,r10
8000bfe8:	e0 66 53 c8 	mov	r6,21448
8000bfec:	12 9a       	mov	r10,r9
8000bfee:	8d 08       	st.w	r6[0x0],r8
8000bff0:	fe b0 d0 78 	rcall	800060e0 <_read>
8000bff4:	5b fc       	cp.w	r12,-1
8000bff6:	c0 51       	brne	8000c000 <_read_r+0x24>
8000bff8:	6c 08       	ld.w	r8,r6[0x0]
8000bffa:	58 08       	cp.w	r8,0
8000bffc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c000:	d8 22       	popm	r4-r7,pc
8000c002:	d7 03       	nop

8000c004 <__avr32_f64_mul>:
8000c004:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000c008:	e0 80 00 dc 	breq	8000c1c0 <__avr32_f64_mul_op1_zero>
8000c00c:	d4 21       	pushm	r4-r7,lr
8000c00e:	f7 e9 20 0e 	eor	lr,r11,r9
8000c012:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c016:	30 15       	mov	r5,1
8000c018:	c4 30       	breq	8000c09e <__avr32_f64_mul_op1_subnormal>
8000c01a:	ab 6b       	lsl	r11,0xa
8000c01c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000c020:	ab 6a       	lsl	r10,0xa
8000c022:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000c026:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c02a:	c5 c0       	breq	8000c0e2 <__avr32_f64_mul_op2_subnormal>
8000c02c:	a1 78       	lsl	r8,0x1
8000c02e:	5c f9       	rol	r9
8000c030:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000c034:	e0 47 07 ff 	cp.w	r7,2047
8000c038:	c7 70       	breq	8000c126 <__avr32_f64_mul_op_nan_or_inf>
8000c03a:	e0 46 07 ff 	cp.w	r6,2047
8000c03e:	c7 40       	breq	8000c126 <__avr32_f64_mul_op_nan_or_inf>
8000c040:	ee 06 00 0c 	add	r12,r7,r6
8000c044:	e0 2c 03 fe 	sub	r12,1022
8000c048:	f6 08 06 44 	mulu.d	r4,r11,r8
8000c04c:	f4 09 07 44 	macu.d	r4,r10,r9
8000c050:	f4 08 06 46 	mulu.d	r6,r10,r8
8000c054:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000c058:	08 07       	add	r7,r4
8000c05a:	f4 05 00 4a 	adc	r10,r10,r5
8000c05e:	5c 0b       	acr	r11
8000c060:	ed bb 00 14 	bld	r11,0x14
8000c064:	c0 50       	breq	8000c06e <__avr32_f64_mul+0x6a>
8000c066:	a1 77       	lsl	r7,0x1
8000c068:	5c fa       	rol	r10
8000c06a:	5c fb       	rol	r11
8000c06c:	20 1c       	sub	r12,1
8000c06e:	58 0c       	cp.w	r12,0
8000c070:	e0 8a 00 6f 	brle	8000c14e <__avr32_f64_mul_res_subnormal>
8000c074:	e0 4c 07 ff 	cp.w	r12,2047
8000c078:	e0 84 00 9c 	brge	8000c1b0 <__avr32_f64_mul_res_inf>
8000c07c:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000c080:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000c084:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000c088:	ee 17 80 00 	eorh	r7,0x8000
8000c08c:	f1 b7 04 20 	satu	r7,0x1
8000c090:	0e 0a       	add	r10,r7
8000c092:	5c 0b       	acr	r11
8000c094:	ed be 00 1f 	bld	lr,0x1f
8000c098:	ef bb 00 1f 	bst	r11,0x1f
8000c09c:	d8 22       	popm	r4-r7,pc

8000c09e <__avr32_f64_mul_op1_subnormal>:
8000c09e:	e4 1b 00 0f 	andh	r11,0xf
8000c0a2:	f4 0c 12 00 	clz	r12,r10
8000c0a6:	f6 06 12 00 	clz	r6,r11
8000c0aa:	f7 bc 03 e1 	sublo	r12,-31
8000c0ae:	f8 06 17 30 	movlo	r6,r12
8000c0b2:	f7 b6 02 01 	subhs	r6,1
8000c0b6:	e0 46 00 20 	cp.w	r6,32
8000c0ba:	c0 d4       	brge	8000c0d4 <__avr32_f64_mul_op1_subnormal+0x36>
8000c0bc:	ec 0c 11 20 	rsub	r12,r6,32
8000c0c0:	f6 06 09 4b 	lsl	r11,r11,r6
8000c0c4:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c0c8:	18 4b       	or	r11,r12
8000c0ca:	f4 06 09 4a 	lsl	r10,r10,r6
8000c0ce:	20 b6       	sub	r6,11
8000c0d0:	0c 17       	sub	r7,r6
8000c0d2:	ca ab       	rjmp	8000c026 <__avr32_f64_mul+0x22>
8000c0d4:	f4 06 09 4b 	lsl	r11,r10,r6
8000c0d8:	c6 40       	breq	8000c1a0 <__avr32_f64_mul_res_zero>
8000c0da:	30 0a       	mov	r10,0
8000c0dc:	20 b6       	sub	r6,11
8000c0de:	0c 17       	sub	r7,r6
8000c0e0:	ca 3b       	rjmp	8000c026 <__avr32_f64_mul+0x22>

8000c0e2 <__avr32_f64_mul_op2_subnormal>:
8000c0e2:	e4 19 00 0f 	andh	r9,0xf
8000c0e6:	f0 0c 12 00 	clz	r12,r8
8000c0ea:	f2 05 12 00 	clz	r5,r9
8000c0ee:	f7 bc 03 ea 	sublo	r12,-22
8000c0f2:	f8 05 17 30 	movlo	r5,r12
8000c0f6:	f7 b5 02 0a 	subhs	r5,10
8000c0fa:	e0 45 00 20 	cp.w	r5,32
8000c0fe:	c0 d4       	brge	8000c118 <__avr32_f64_mul_op2_subnormal+0x36>
8000c100:	ea 0c 11 20 	rsub	r12,r5,32
8000c104:	f2 05 09 49 	lsl	r9,r9,r5
8000c108:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c10c:	18 49       	or	r9,r12
8000c10e:	f0 05 09 48 	lsl	r8,r8,r5
8000c112:	20 25       	sub	r5,2
8000c114:	0a 16       	sub	r6,r5
8000c116:	c8 fb       	rjmp	8000c034 <__avr32_f64_mul+0x30>
8000c118:	f0 05 09 49 	lsl	r9,r8,r5
8000c11c:	c4 20       	breq	8000c1a0 <__avr32_f64_mul_res_zero>
8000c11e:	30 08       	mov	r8,0
8000c120:	20 25       	sub	r5,2
8000c122:	0a 16       	sub	r6,r5
8000c124:	c8 8b       	rjmp	8000c034 <__avr32_f64_mul+0x30>

8000c126 <__avr32_f64_mul_op_nan_or_inf>:
8000c126:	e4 19 00 0f 	andh	r9,0xf
8000c12a:	e4 1b 00 0f 	andh	r11,0xf
8000c12e:	14 4b       	or	r11,r10
8000c130:	10 49       	or	r9,r8
8000c132:	e0 47 07 ff 	cp.w	r7,2047
8000c136:	c0 91       	brne	8000c148 <__avr32_f64_mul_op1_not_naninf>
8000c138:	58 0b       	cp.w	r11,0
8000c13a:	c3 81       	brne	8000c1aa <__avr32_f64_mul_res_nan>
8000c13c:	e0 46 07 ff 	cp.w	r6,2047
8000c140:	c3 81       	brne	8000c1b0 <__avr32_f64_mul_res_inf>
8000c142:	58 09       	cp.w	r9,0
8000c144:	c3 60       	breq	8000c1b0 <__avr32_f64_mul_res_inf>
8000c146:	c3 28       	rjmp	8000c1aa <__avr32_f64_mul_res_nan>

8000c148 <__avr32_f64_mul_op1_not_naninf>:
8000c148:	58 09       	cp.w	r9,0
8000c14a:	c3 30       	breq	8000c1b0 <__avr32_f64_mul_res_inf>
8000c14c:	c2 f8       	rjmp	8000c1aa <__avr32_f64_mul_res_nan>

8000c14e <__avr32_f64_mul_res_subnormal>:
8000c14e:	5c 3c       	neg	r12
8000c150:	2f fc       	sub	r12,-1
8000c152:	f1 bc 04 c0 	satu	r12,0x6
8000c156:	e0 4c 00 20 	cp.w	r12,32
8000c15a:	c1 14       	brge	8000c17c <__avr32_f64_mul_res_subnormal+0x2e>
8000c15c:	f8 08 11 20 	rsub	r8,r12,32
8000c160:	0e 46       	or	r6,r7
8000c162:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c166:	f4 08 09 49 	lsl	r9,r10,r8
8000c16a:	12 47       	or	r7,r9
8000c16c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c170:	f6 08 09 49 	lsl	r9,r11,r8
8000c174:	12 4a       	or	r10,r9
8000c176:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c17a:	c8 3b       	rjmp	8000c080 <__avr32_f64_mul+0x7c>
8000c17c:	f8 08 11 20 	rsub	r8,r12,32
8000c180:	f9 b9 00 00 	moveq	r9,0
8000c184:	c0 30       	breq	8000c18a <__avr32_f64_mul_res_subnormal+0x3c>
8000c186:	f6 08 09 49 	lsl	r9,r11,r8
8000c18a:	0e 46       	or	r6,r7
8000c18c:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c190:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c194:	f3 ea 10 07 	or	r7,r9,r10
8000c198:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c19c:	30 0b       	mov	r11,0
8000c19e:	c7 1b       	rjmp	8000c080 <__avr32_f64_mul+0x7c>

8000c1a0 <__avr32_f64_mul_res_zero>:
8000c1a0:	1c 9b       	mov	r11,lr
8000c1a2:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c1a6:	30 0a       	mov	r10,0
8000c1a8:	d8 22       	popm	r4-r7,pc

8000c1aa <__avr32_f64_mul_res_nan>:
8000c1aa:	3f fb       	mov	r11,-1
8000c1ac:	3f fa       	mov	r10,-1
8000c1ae:	d8 22       	popm	r4-r7,pc

8000c1b0 <__avr32_f64_mul_res_inf>:
8000c1b0:	f0 6b 00 00 	mov	r11,-1048576
8000c1b4:	ed be 00 1f 	bld	lr,0x1f
8000c1b8:	ef bb 00 1f 	bst	r11,0x1f
8000c1bc:	30 0a       	mov	r10,0
8000c1be:	d8 22       	popm	r4-r7,pc

8000c1c0 <__avr32_f64_mul_op1_zero>:
8000c1c0:	f7 e9 20 0b 	eor	r11,r11,r9
8000c1c4:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c1c8:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c1cc:	e0 4c 07 ff 	cp.w	r12,2047
8000c1d0:	5e 1c       	retne	r12
8000c1d2:	3f fa       	mov	r10,-1
8000c1d4:	3f fb       	mov	r11,-1
8000c1d6:	5e fc       	retal	r12

8000c1d8 <__avr32_f64_sub_from_add>:
8000c1d8:	ee 19 80 00 	eorh	r9,0x8000

8000c1dc <__avr32_f64_sub>:
8000c1dc:	f7 e9 20 0c 	eor	r12,r11,r9
8000c1e0:	e0 86 00 ca 	brmi	8000c374 <__avr32_f64_add_from_sub>
8000c1e4:	eb cd 40 e0 	pushm	r5-r7,lr
8000c1e8:	16 9c       	mov	r12,r11
8000c1ea:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c1ee:	bf db       	cbr	r11,0x1f
8000c1f0:	bf d9       	cbr	r9,0x1f
8000c1f2:	10 3a       	cp.w	r10,r8
8000c1f4:	f2 0b 13 00 	cpc	r11,r9
8000c1f8:	c0 92       	brcc	8000c20a <__avr32_f64_sub+0x2e>
8000c1fa:	16 97       	mov	r7,r11
8000c1fc:	12 9b       	mov	r11,r9
8000c1fe:	0e 99       	mov	r9,r7
8000c200:	14 97       	mov	r7,r10
8000c202:	10 9a       	mov	r10,r8
8000c204:	0e 98       	mov	r8,r7
8000c206:	ee 1c 80 00 	eorh	r12,0x8000
8000c20a:	f6 07 16 14 	lsr	r7,r11,0x14
8000c20e:	ab 7b       	lsl	r11,0xb
8000c210:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c214:	ab 7a       	lsl	r10,0xb
8000c216:	bf bb       	sbr	r11,0x1f
8000c218:	f2 06 16 14 	lsr	r6,r9,0x14
8000c21c:	c4 40       	breq	8000c2a4 <__avr32_f64_sub_opL_subnormal>
8000c21e:	ab 79       	lsl	r9,0xb
8000c220:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c224:	ab 78       	lsl	r8,0xb
8000c226:	bf b9       	sbr	r9,0x1f

8000c228 <__avr32_f64_sub_opL_subnormal_done>:
8000c228:	e0 47 07 ff 	cp.w	r7,2047
8000c22c:	c4 f0       	breq	8000c2ca <__avr32_f64_sub_opH_nan_or_inf>
8000c22e:	0e 26       	rsub	r6,r7
8000c230:	c1 20       	breq	8000c254 <__avr32_f64_sub_shift_done>
8000c232:	ec 05 11 20 	rsub	r5,r6,32
8000c236:	e0 46 00 20 	cp.w	r6,32
8000c23a:	c7 c2       	brcc	8000c332 <__avr32_f64_sub_longshift>
8000c23c:	f0 05 09 4e 	lsl	lr,r8,r5
8000c240:	f2 05 09 45 	lsl	r5,r9,r5
8000c244:	f0 06 0a 48 	lsr	r8,r8,r6
8000c248:	f2 06 0a 49 	lsr	r9,r9,r6
8000c24c:	0a 48       	or	r8,r5
8000c24e:	58 0e       	cp.w	lr,0
8000c250:	5f 1e       	srne	lr
8000c252:	1c 48       	or	r8,lr

8000c254 <__avr32_f64_sub_shift_done>:
8000c254:	10 1a       	sub	r10,r8
8000c256:	f6 09 01 4b 	sbc	r11,r11,r9
8000c25a:	f6 06 12 00 	clz	r6,r11
8000c25e:	c0 e0       	breq	8000c27a <__avr32_f64_sub_longnormalize_done>
8000c260:	c7 83       	brcs	8000c350 <__avr32_f64_sub_longnormalize>
8000c262:	ec 0e 11 20 	rsub	lr,r6,32
8000c266:	f6 06 09 4b 	lsl	r11,r11,r6
8000c26a:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c26e:	1c 4b       	or	r11,lr
8000c270:	f4 06 09 4a 	lsl	r10,r10,r6
8000c274:	0c 17       	sub	r7,r6
8000c276:	e0 8a 00 39 	brle	8000c2e8 <__avr32_f64_sub_subnormal_result>

8000c27a <__avr32_f64_sub_longnormalize_done>:
8000c27a:	f4 09 15 15 	lsl	r9,r10,0x15
8000c27e:	ab 9a       	lsr	r10,0xb
8000c280:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c284:	ab 9b       	lsr	r11,0xb
8000c286:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c28a:	18 4b       	or	r11,r12

8000c28c <__avr32_f64_sub_round>:
8000c28c:	fc 17 80 00 	movh	r7,0x8000
8000c290:	ed ba 00 00 	bld	r10,0x0
8000c294:	f7 b7 01 ff 	subne	r7,-1
8000c298:	0e 39       	cp.w	r9,r7
8000c29a:	5f 29       	srhs	r9
8000c29c:	12 0a       	add	r10,r9
8000c29e:	5c 0b       	acr	r11
8000c2a0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2a4 <__avr32_f64_sub_opL_subnormal>:
8000c2a4:	ab 79       	lsl	r9,0xb
8000c2a6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c2aa:	ab 78       	lsl	r8,0xb
8000c2ac:	f3 e8 10 0e 	or	lr,r9,r8
8000c2b0:	f9 b6 01 01 	movne	r6,1
8000c2b4:	ee 0e 11 00 	rsub	lr,r7,0
8000c2b8:	f9 b7 00 01 	moveq	r7,1
8000c2bc:	ef bb 00 1f 	bst	r11,0x1f
8000c2c0:	f7 ea 10 0e 	or	lr,r11,r10
8000c2c4:	f9 b7 00 00 	moveq	r7,0
8000c2c8:	cb 0b       	rjmp	8000c228 <__avr32_f64_sub_opL_subnormal_done>

8000c2ca <__avr32_f64_sub_opH_nan_or_inf>:
8000c2ca:	bf db       	cbr	r11,0x1f
8000c2cc:	f7 ea 10 0e 	or	lr,r11,r10
8000c2d0:	c0 81       	brne	8000c2e0 <__avr32_f64_sub_return_nan>
8000c2d2:	e0 46 07 ff 	cp.w	r6,2047
8000c2d6:	c0 50       	breq	8000c2e0 <__avr32_f64_sub_return_nan>
8000c2d8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c2dc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2e0 <__avr32_f64_sub_return_nan>:
8000c2e0:	3f fa       	mov	r10,-1
8000c2e2:	3f fb       	mov	r11,-1
8000c2e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c2e8 <__avr32_f64_sub_subnormal_result>:
8000c2e8:	5c 37       	neg	r7
8000c2ea:	2f f7       	sub	r7,-1
8000c2ec:	f1 b7 04 c0 	satu	r7,0x6
8000c2f0:	e0 47 00 20 	cp.w	r7,32
8000c2f4:	c1 14       	brge	8000c316 <__avr32_f64_sub_subnormal_result+0x2e>
8000c2f6:	ee 08 11 20 	rsub	r8,r7,32
8000c2fa:	f4 08 09 49 	lsl	r9,r10,r8
8000c2fe:	5f 16       	srne	r6
8000c300:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c304:	0c 4a       	or	r10,r6
8000c306:	f6 08 09 49 	lsl	r9,r11,r8
8000c30a:	f5 e9 10 0a 	or	r10,r10,r9
8000c30e:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c312:	30 07       	mov	r7,0
8000c314:	cb 3b       	rjmp	8000c27a <__avr32_f64_sub_longnormalize_done>
8000c316:	ee 08 11 40 	rsub	r8,r7,64
8000c31a:	f6 08 09 49 	lsl	r9,r11,r8
8000c31e:	14 49       	or	r9,r10
8000c320:	5f 16       	srne	r6
8000c322:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c326:	0c 4a       	or	r10,r6
8000c328:	30 0b       	mov	r11,0
8000c32a:	30 07       	mov	r7,0
8000c32c:	ca 7b       	rjmp	8000c27a <__avr32_f64_sub_longnormalize_done>
8000c32e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c332 <__avr32_f64_sub_longshift>:
8000c332:	f1 b6 04 c0 	satu	r6,0x6
8000c336:	f0 0e 17 00 	moveq	lr,r8
8000c33a:	c0 40       	breq	8000c342 <__avr32_f64_sub_longshift+0x10>
8000c33c:	f2 05 09 4e 	lsl	lr,r9,r5
8000c340:	10 4e       	or	lr,r8
8000c342:	f2 06 0a 48 	lsr	r8,r9,r6
8000c346:	30 09       	mov	r9,0
8000c348:	58 0e       	cp.w	lr,0
8000c34a:	5f 1e       	srne	lr
8000c34c:	1c 48       	or	r8,lr
8000c34e:	c8 3b       	rjmp	8000c254 <__avr32_f64_sub_shift_done>

8000c350 <__avr32_f64_sub_longnormalize>:
8000c350:	f4 06 12 00 	clz	r6,r10
8000c354:	f9 b7 03 00 	movlo	r7,0
8000c358:	f9 b6 03 00 	movlo	r6,0
8000c35c:	f9 bc 03 00 	movlo	r12,0
8000c360:	f7 b6 02 e0 	subhs	r6,-32
8000c364:	f4 06 09 4b 	lsl	r11,r10,r6
8000c368:	30 0a       	mov	r10,0
8000c36a:	0c 17       	sub	r7,r6
8000c36c:	fe 9a ff be 	brle	8000c2e8 <__avr32_f64_sub_subnormal_result>
8000c370:	c8 5b       	rjmp	8000c27a <__avr32_f64_sub_longnormalize_done>
8000c372:	d7 03       	nop

8000c374 <__avr32_f64_add_from_sub>:
8000c374:	ee 19 80 00 	eorh	r9,0x8000

8000c378 <__avr32_f64_add>:
8000c378:	f7 e9 20 0c 	eor	r12,r11,r9
8000c37c:	fe 96 ff 2e 	brmi	8000c1d8 <__avr32_f64_sub_from_add>
8000c380:	eb cd 40 e0 	pushm	r5-r7,lr
8000c384:	16 9c       	mov	r12,r11
8000c386:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c38a:	bf db       	cbr	r11,0x1f
8000c38c:	bf d9       	cbr	r9,0x1f
8000c38e:	12 3b       	cp.w	r11,r9
8000c390:	c0 72       	brcc	8000c39e <__avr32_f64_add+0x26>
8000c392:	16 97       	mov	r7,r11
8000c394:	12 9b       	mov	r11,r9
8000c396:	0e 99       	mov	r9,r7
8000c398:	14 97       	mov	r7,r10
8000c39a:	10 9a       	mov	r10,r8
8000c39c:	0e 98       	mov	r8,r7
8000c39e:	30 0e       	mov	lr,0
8000c3a0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c3a4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c3a8:	b5 ab       	sbr	r11,0x14
8000c3aa:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c3ae:	c6 20       	breq	8000c472 <__avr32_f64_add_op2_subnormal>
8000c3b0:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c3b4:	b5 a9       	sbr	r9,0x14
8000c3b6:	e0 47 07 ff 	cp.w	r7,2047
8000c3ba:	c2 80       	breq	8000c40a <__avr32_f64_add_opH_nan_or_inf>
8000c3bc:	0e 26       	rsub	r6,r7
8000c3be:	c1 20       	breq	8000c3e2 <__avr32_f64_add_shift_done>
8000c3c0:	e0 46 00 36 	cp.w	r6,54
8000c3c4:	c1 52       	brcc	8000c3ee <__avr32_f64_add_res_of_done>
8000c3c6:	ec 05 11 20 	rsub	r5,r6,32
8000c3ca:	e0 46 00 20 	cp.w	r6,32
8000c3ce:	c3 52       	brcc	8000c438 <__avr32_f64_add_longshift>
8000c3d0:	f0 05 09 4e 	lsl	lr,r8,r5
8000c3d4:	f2 05 09 45 	lsl	r5,r9,r5
8000c3d8:	f0 06 0a 48 	lsr	r8,r8,r6
8000c3dc:	f2 06 0a 49 	lsr	r9,r9,r6
8000c3e0:	0a 48       	or	r8,r5

8000c3e2 <__avr32_f64_add_shift_done>:
8000c3e2:	10 0a       	add	r10,r8
8000c3e4:	f6 09 00 4b 	adc	r11,r11,r9
8000c3e8:	ed bb 00 15 	bld	r11,0x15
8000c3ec:	c3 40       	breq	8000c454 <__avr32_f64_add_res_of>

8000c3ee <__avr32_f64_add_res_of_done>:
8000c3ee:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c3f2:	18 4b       	or	r11,r12

8000c3f4 <__avr32_f64_add_round>:
8000c3f4:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c3f8:	18 4e       	or	lr,r12
8000c3fa:	ee 1e 80 00 	eorh	lr,0x8000
8000c3fe:	f1 be 04 20 	satu	lr,0x1
8000c402:	1c 0a       	add	r10,lr
8000c404:	5c 0b       	acr	r11
8000c406:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c40a <__avr32_f64_add_opH_nan_or_inf>:
8000c40a:	b5 cb       	cbr	r11,0x14
8000c40c:	f7 ea 10 0e 	or	lr,r11,r10
8000c410:	c1 01       	brne	8000c430 <__avr32_f64_add_return_nan>
8000c412:	e0 46 07 ff 	cp.w	r6,2047
8000c416:	c0 30       	breq	8000c41c <__avr32_f64_add_opL_nan_or_inf>
8000c418:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c41c <__avr32_f64_add_opL_nan_or_inf>:
8000c41c:	b5 c9       	cbr	r9,0x14
8000c41e:	f3 e8 10 0e 	or	lr,r9,r8
8000c422:	c0 71       	brne	8000c430 <__avr32_f64_add_return_nan>
8000c424:	30 0a       	mov	r10,0
8000c426:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c42a:	18 4b       	or	r11,r12
8000c42c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c430 <__avr32_f64_add_return_nan>:
8000c430:	3f fa       	mov	r10,-1
8000c432:	3f fb       	mov	r11,-1
8000c434:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c438 <__avr32_f64_add_longshift>:
8000c438:	f1 b6 04 c0 	satu	r6,0x6
8000c43c:	f0 0e 17 00 	moveq	lr,r8
8000c440:	c0 60       	breq	8000c44c <__avr32_f64_add_longshift+0x14>
8000c442:	f2 05 09 4e 	lsl	lr,r9,r5
8000c446:	58 08       	cp.w	r8,0
8000c448:	5f 18       	srne	r8
8000c44a:	10 4e       	or	lr,r8
8000c44c:	f2 06 0a 48 	lsr	r8,r9,r6
8000c450:	30 09       	mov	r9,0
8000c452:	cc 8b       	rjmp	8000c3e2 <__avr32_f64_add_shift_done>

8000c454 <__avr32_f64_add_res_of>:
8000c454:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c458:	a1 9b       	lsr	r11,0x1
8000c45a:	5d 0a       	ror	r10
8000c45c:	5d 0e       	ror	lr
8000c45e:	2f f7       	sub	r7,-1
8000c460:	e0 47 07 ff 	cp.w	r7,2047
8000c464:	f9 ba 00 00 	moveq	r10,0
8000c468:	f9 bb 00 00 	moveq	r11,0
8000c46c:	f9 be 00 00 	moveq	lr,0
8000c470:	cb fb       	rjmp	8000c3ee <__avr32_f64_add_res_of_done>

8000c472 <__avr32_f64_add_op2_subnormal>:
8000c472:	30 16       	mov	r6,1
8000c474:	58 07       	cp.w	r7,0
8000c476:	ca 01       	brne	8000c3b6 <__avr32_f64_add+0x3e>
8000c478:	b5 cb       	cbr	r11,0x14
8000c47a:	10 0a       	add	r10,r8
8000c47c:	f6 09 00 4b 	adc	r11,r11,r9
8000c480:	18 4b       	or	r11,r12
8000c482:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c486:	d7 03       	nop

8000c488 <__avr32_f64_to_u32>:
8000c488:	58 0b       	cp.w	r11,0
8000c48a:	5e 6d       	retmi	0

8000c48c <__avr32_f64_to_s32>:
8000c48c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c490:	b5 9c       	lsr	r12,0x15
8000c492:	e0 2c 03 ff 	sub	r12,1023
8000c496:	5e 3d       	retlo	0
8000c498:	f8 0c 11 1f 	rsub	r12,r12,31
8000c49c:	16 99       	mov	r9,r11
8000c49e:	ab 7b       	lsl	r11,0xb
8000c4a0:	bf bb       	sbr	r11,0x1f
8000c4a2:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c4a6:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c4aa:	a1 79       	lsl	r9,0x1
8000c4ac:	5e 2b       	reths	r11
8000c4ae:	5c 3b       	neg	r11
8000c4b0:	5e fb       	retal	r11

8000c4b2 <__avr32_u32_to_f64>:
8000c4b2:	f8 cb 00 00 	sub	r11,r12,0
8000c4b6:	30 0c       	mov	r12,0
8000c4b8:	c0 38       	rjmp	8000c4be <__avr32_s32_to_f64+0x4>

8000c4ba <__avr32_s32_to_f64>:
8000c4ba:	18 9b       	mov	r11,r12
8000c4bc:	5c 4b       	abs	r11
8000c4be:	30 0a       	mov	r10,0
8000c4c0:	5e 0b       	reteq	r11
8000c4c2:	d4 01       	pushm	lr
8000c4c4:	e0 69 04 1e 	mov	r9,1054
8000c4c8:	f6 08 12 00 	clz	r8,r11
8000c4cc:	c1 70       	breq	8000c4fa <__avr32_s32_to_f64+0x40>
8000c4ce:	c0 c3       	brcs	8000c4e6 <__avr32_s32_to_f64+0x2c>
8000c4d0:	f0 0e 11 20 	rsub	lr,r8,32
8000c4d4:	f6 08 09 4b 	lsl	r11,r11,r8
8000c4d8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c4dc:	1c 4b       	or	r11,lr
8000c4de:	f4 08 09 4a 	lsl	r10,r10,r8
8000c4e2:	10 19       	sub	r9,r8
8000c4e4:	c0 b8       	rjmp	8000c4fa <__avr32_s32_to_f64+0x40>
8000c4e6:	f4 08 12 00 	clz	r8,r10
8000c4ea:	f9 b8 03 00 	movlo	r8,0
8000c4ee:	f7 b8 02 e0 	subhs	r8,-32
8000c4f2:	f4 08 09 4b 	lsl	r11,r10,r8
8000c4f6:	30 0a       	mov	r10,0
8000c4f8:	10 19       	sub	r9,r8
8000c4fa:	58 09       	cp.w	r9,0
8000c4fc:	e0 89 00 30 	brgt	8000c55c <__avr32_s32_to_f64+0xa2>
8000c500:	5c 39       	neg	r9
8000c502:	2f f9       	sub	r9,-1
8000c504:	e0 49 00 36 	cp.w	r9,54
8000c508:	c0 43       	brcs	8000c510 <__avr32_s32_to_f64+0x56>
8000c50a:	30 0b       	mov	r11,0
8000c50c:	30 0a       	mov	r10,0
8000c50e:	c2 68       	rjmp	8000c55a <__avr32_s32_to_f64+0xa0>
8000c510:	2f 69       	sub	r9,-10
8000c512:	f2 08 11 20 	rsub	r8,r9,32
8000c516:	e0 49 00 20 	cp.w	r9,32
8000c51a:	c0 b2       	brcc	8000c530 <__avr32_s32_to_f64+0x76>
8000c51c:	f4 08 09 4e 	lsl	lr,r10,r8
8000c520:	f6 08 09 48 	lsl	r8,r11,r8
8000c524:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c528:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c52c:	10 4b       	or	r11,r8
8000c52e:	c0 88       	rjmp	8000c53e <__avr32_s32_to_f64+0x84>
8000c530:	f6 08 09 4e 	lsl	lr,r11,r8
8000c534:	14 4e       	or	lr,r10
8000c536:	16 9a       	mov	r10,r11
8000c538:	30 0b       	mov	r11,0
8000c53a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c53e:	ed ba 00 00 	bld	r10,0x0
8000c542:	c0 92       	brcc	8000c554 <__avr32_s32_to_f64+0x9a>
8000c544:	1c 7e       	tst	lr,lr
8000c546:	c0 41       	brne	8000c54e <__avr32_s32_to_f64+0x94>
8000c548:	ed ba 00 01 	bld	r10,0x1
8000c54c:	c0 42       	brcc	8000c554 <__avr32_s32_to_f64+0x9a>
8000c54e:	2f fa       	sub	r10,-1
8000c550:	f7 bb 02 ff 	subhs	r11,-1
8000c554:	5c fc       	rol	r12
8000c556:	5d 0b       	ror	r11
8000c558:	5d 0a       	ror	r10
8000c55a:	d8 02       	popm	pc
8000c55c:	e0 68 03 ff 	mov	r8,1023
8000c560:	ed ba 00 0b 	bld	r10,0xb
8000c564:	f7 b8 00 ff 	subeq	r8,-1
8000c568:	10 0a       	add	r10,r8
8000c56a:	5c 0b       	acr	r11
8000c56c:	f7 b9 03 fe 	sublo	r9,-2
8000c570:	e0 49 07 ff 	cp.w	r9,2047
8000c574:	c0 55       	brlt	8000c57e <__avr32_s32_to_f64+0xc4>
8000c576:	30 0a       	mov	r10,0
8000c578:	fc 1b ff e0 	movh	r11,0xffe0
8000c57c:	c0 c8       	rjmp	8000c594 <__floatsidf_return_op1>
8000c57e:	ed bb 00 1f 	bld	r11,0x1f
8000c582:	f7 b9 01 01 	subne	r9,1
8000c586:	ab 9a       	lsr	r10,0xb
8000c588:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c58c:	a1 7b       	lsl	r11,0x1
8000c58e:	ab 9b       	lsr	r11,0xb
8000c590:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c594 <__floatsidf_return_op1>:
8000c594:	a1 7c       	lsl	r12,0x1
8000c596:	5d 0b       	ror	r11
8000c598:	d8 02       	popm	pc

8000c59a <__avr32_f64_cmp_eq>:
8000c59a:	10 3a       	cp.w	r10,r8
8000c59c:	f2 0b 13 00 	cpc	r11,r9
8000c5a0:	c0 80       	breq	8000c5b0 <__avr32_f64_cmp_eq+0x16>
8000c5a2:	a1 7b       	lsl	r11,0x1
8000c5a4:	a1 79       	lsl	r9,0x1
8000c5a6:	14 4b       	or	r11,r10
8000c5a8:	12 4b       	or	r11,r9
8000c5aa:	10 4b       	or	r11,r8
8000c5ac:	5e 0f       	reteq	1
8000c5ae:	5e fd       	retal	0
8000c5b0:	a1 7b       	lsl	r11,0x1
8000c5b2:	fc 1c ff e0 	movh	r12,0xffe0
8000c5b6:	58 0a       	cp.w	r10,0
8000c5b8:	f8 0b 13 00 	cpc	r11,r12
8000c5bc:	5e 8f       	retls	1
8000c5be:	5e fd       	retal	0

8000c5c0 <__avr32_f64_cmp_ge>:
8000c5c0:	1a de       	st.w	--sp,lr
8000c5c2:	1a d7       	st.w	--sp,r7
8000c5c4:	a1 7b       	lsl	r11,0x1
8000c5c6:	5f 3c       	srlo	r12
8000c5c8:	a1 79       	lsl	r9,0x1
8000c5ca:	5f 37       	srlo	r7
8000c5cc:	5c fc       	rol	r12
8000c5ce:	fc 1e ff e0 	movh	lr,0xffe0
8000c5d2:	58 0a       	cp.w	r10,0
8000c5d4:	fc 0b 13 00 	cpc	r11,lr
8000c5d8:	e0 8b 00 1d 	brhi	8000c612 <__avr32_f64_cmp_ge+0x52>
8000c5dc:	58 08       	cp.w	r8,0
8000c5de:	fc 09 13 00 	cpc	r9,lr
8000c5e2:	e0 8b 00 18 	brhi	8000c612 <__avr32_f64_cmp_ge+0x52>
8000c5e6:	58 0b       	cp.w	r11,0
8000c5e8:	f5 ba 00 00 	subfeq	r10,0
8000c5ec:	c1 50       	breq	8000c616 <__avr32_f64_cmp_ge+0x56>
8000c5ee:	1b 07       	ld.w	r7,sp++
8000c5f0:	1b 0e       	ld.w	lr,sp++
8000c5f2:	58 3c       	cp.w	r12,3
8000c5f4:	c0 a0       	breq	8000c608 <__avr32_f64_cmp_ge+0x48>
8000c5f6:	58 1c       	cp.w	r12,1
8000c5f8:	c0 33       	brcs	8000c5fe <__avr32_f64_cmp_ge+0x3e>
8000c5fa:	5e 0f       	reteq	1
8000c5fc:	5e 1d       	retne	0
8000c5fe:	10 3a       	cp.w	r10,r8
8000c600:	f2 0b 13 00 	cpc	r11,r9
8000c604:	5e 2f       	reths	1
8000c606:	5e 3d       	retlo	0
8000c608:	14 38       	cp.w	r8,r10
8000c60a:	f6 09 13 00 	cpc	r9,r11
8000c60e:	5e 2f       	reths	1
8000c610:	5e 3d       	retlo	0
8000c612:	1b 07       	ld.w	r7,sp++
8000c614:	d8 0a       	popm	pc,r12=0
8000c616:	58 17       	cp.w	r7,1
8000c618:	5f 0c       	sreq	r12
8000c61a:	58 09       	cp.w	r9,0
8000c61c:	f5 b8 00 00 	subfeq	r8,0
8000c620:	1b 07       	ld.w	r7,sp++
8000c622:	1b 0e       	ld.w	lr,sp++
8000c624:	5e 0f       	reteq	1
8000c626:	5e fc       	retal	r12

8000c628 <__avr32_f64_cmp_lt>:
8000c628:	1a de       	st.w	--sp,lr
8000c62a:	1a d7       	st.w	--sp,r7
8000c62c:	a1 7b       	lsl	r11,0x1
8000c62e:	5f 3c       	srlo	r12
8000c630:	a1 79       	lsl	r9,0x1
8000c632:	5f 37       	srlo	r7
8000c634:	5c fc       	rol	r12
8000c636:	fc 1e ff e0 	movh	lr,0xffe0
8000c63a:	58 0a       	cp.w	r10,0
8000c63c:	fc 0b 13 00 	cpc	r11,lr
8000c640:	e0 8b 00 1d 	brhi	8000c67a <__avr32_f64_cmp_lt+0x52>
8000c644:	58 08       	cp.w	r8,0
8000c646:	fc 09 13 00 	cpc	r9,lr
8000c64a:	e0 8b 00 18 	brhi	8000c67a <__avr32_f64_cmp_lt+0x52>
8000c64e:	58 0b       	cp.w	r11,0
8000c650:	f5 ba 00 00 	subfeq	r10,0
8000c654:	c1 50       	breq	8000c67e <__avr32_f64_cmp_lt+0x56>
8000c656:	1b 07       	ld.w	r7,sp++
8000c658:	1b 0e       	ld.w	lr,sp++
8000c65a:	58 3c       	cp.w	r12,3
8000c65c:	c0 a0       	breq	8000c670 <__avr32_f64_cmp_lt+0x48>
8000c65e:	58 1c       	cp.w	r12,1
8000c660:	c0 33       	brcs	8000c666 <__avr32_f64_cmp_lt+0x3e>
8000c662:	5e 0d       	reteq	0
8000c664:	5e 1f       	retne	1
8000c666:	10 3a       	cp.w	r10,r8
8000c668:	f2 0b 13 00 	cpc	r11,r9
8000c66c:	5e 2d       	reths	0
8000c66e:	5e 3f       	retlo	1
8000c670:	14 38       	cp.w	r8,r10
8000c672:	f6 09 13 00 	cpc	r9,r11
8000c676:	5e 2d       	reths	0
8000c678:	5e 3f       	retlo	1
8000c67a:	1b 07       	ld.w	r7,sp++
8000c67c:	d8 0a       	popm	pc,r12=0
8000c67e:	58 17       	cp.w	r7,1
8000c680:	5f 1c       	srne	r12
8000c682:	58 09       	cp.w	r9,0
8000c684:	f5 b8 00 00 	subfeq	r8,0
8000c688:	1b 07       	ld.w	r7,sp++
8000c68a:	1b 0e       	ld.w	lr,sp++
8000c68c:	5e 0d       	reteq	0
8000c68e:	5e fc       	retal	r12

8000c690 <__avr32_f64_div>:
8000c690:	eb cd 40 ff 	pushm	r0-r7,lr
8000c694:	f7 e9 20 0e 	eor	lr,r11,r9
8000c698:	f6 07 16 14 	lsr	r7,r11,0x14
8000c69c:	a9 7b       	lsl	r11,0x9
8000c69e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c6a2:	a9 7a       	lsl	r10,0x9
8000c6a4:	bd bb       	sbr	r11,0x1d
8000c6a6:	e4 1b 3f ff 	andh	r11,0x3fff
8000c6aa:	ab d7       	cbr	r7,0xb
8000c6ac:	e0 80 00 cc 	breq	8000c844 <__avr32_f64_div_round_subnormal+0x54>
8000c6b0:	e0 47 07 ff 	cp.w	r7,2047
8000c6b4:	e0 84 00 b5 	brge	8000c81e <__avr32_f64_div_round_subnormal+0x2e>
8000c6b8:	f2 06 16 14 	lsr	r6,r9,0x14
8000c6bc:	a9 79       	lsl	r9,0x9
8000c6be:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c6c2:	a9 78       	lsl	r8,0x9
8000c6c4:	bd b9       	sbr	r9,0x1d
8000c6c6:	e4 19 3f ff 	andh	r9,0x3fff
8000c6ca:	ab d6       	cbr	r6,0xb
8000c6cc:	e0 80 00 e2 	breq	8000c890 <__avr32_f64_div_round_subnormal+0xa0>
8000c6d0:	e0 46 07 ff 	cp.w	r6,2047
8000c6d4:	e0 84 00 b2 	brge	8000c838 <__avr32_f64_div_round_subnormal+0x48>
8000c6d8:	0c 17       	sub	r7,r6
8000c6da:	fe 37 fc 01 	sub	r7,-1023
8000c6de:	fc 1c 80 00 	movh	r12,0x8000
8000c6e2:	f8 03 16 01 	lsr	r3,r12,0x1
8000c6e6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c6ea:	5c d4       	com	r4
8000c6ec:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c6f0:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c6f4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c6f8:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c6fc:	ea 03 15 02 	lsl	r3,r5,0x2
8000c700:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c704:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c708:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c70c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c710:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c714:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c718:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c71c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c720:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c724:	e4 09 07 40 	macu.d	r0,r2,r9
8000c728:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c72c:	02 04       	add	r4,r1
8000c72e:	5c 05       	acr	r5
8000c730:	a3 65       	lsl	r5,0x2
8000c732:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c736:	a3 64       	lsl	r4,0x2
8000c738:	5c 34       	neg	r4
8000c73a:	f8 05 01 45 	sbc	r5,r12,r5
8000c73e:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c742:	e4 05 07 40 	macu.d	r0,r2,r5
8000c746:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c74a:	02 04       	add	r4,r1
8000c74c:	5c 05       	acr	r5
8000c74e:	ea 03 15 02 	lsl	r3,r5,0x2
8000c752:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c756:	e8 02 15 02 	lsl	r2,r4,0x2
8000c75a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c75e:	e4 09 07 40 	macu.d	r0,r2,r9
8000c762:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c766:	02 04       	add	r4,r1
8000c768:	5c 05       	acr	r5
8000c76a:	a3 65       	lsl	r5,0x2
8000c76c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c770:	a3 64       	lsl	r4,0x2
8000c772:	5c 34       	neg	r4
8000c774:	f8 05 01 45 	sbc	r5,r12,r5
8000c778:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c77c:	e4 05 07 40 	macu.d	r0,r2,r5
8000c780:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c784:	02 04       	add	r4,r1
8000c786:	5c 05       	acr	r5
8000c788:	ea 03 15 02 	lsl	r3,r5,0x2
8000c78c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c790:	e8 02 15 02 	lsl	r2,r4,0x2
8000c794:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c798:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c79c:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c7a0:	02 02       	add	r2,r1
8000c7a2:	5c 03       	acr	r3
8000c7a4:	ed b3 00 1c 	bld	r3,0x1c
8000c7a8:	c0 90       	breq	8000c7ba <__avr32_f64_div+0x12a>
8000c7aa:	a1 72       	lsl	r2,0x1
8000c7ac:	5c f3       	rol	r3
8000c7ae:	20 17       	sub	r7,1
8000c7b0:	a3 9a       	lsr	r10,0x3
8000c7b2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c7b6:	a3 9b       	lsr	r11,0x3
8000c7b8:	c0 58       	rjmp	8000c7c2 <__avr32_f64_div+0x132>
8000c7ba:	a5 8a       	lsr	r10,0x4
8000c7bc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c7c0:	a5 8b       	lsr	r11,0x4
8000c7c2:	58 07       	cp.w	r7,0
8000c7c4:	e0 8a 00 8b 	brle	8000c8da <__avr32_f64_div_res_subnormal>
8000c7c8:	e0 12 ff 00 	andl	r2,0xff00
8000c7cc:	e8 12 00 80 	orl	r2,0x80
8000c7d0:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c7d4:	e4 09 07 40 	macu.d	r0,r2,r9
8000c7d8:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c7dc:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c7e0:	00 05       	add	r5,r0
8000c7e2:	f0 01 00 48 	adc	r8,r8,r1
8000c7e6:	5c 09       	acr	r9
8000c7e8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c7ec:	58 04       	cp.w	r4,0
8000c7ee:	5c 25       	cpc	r5

8000c7f0 <__avr32_f64_div_round_subnormal>:
8000c7f0:	f4 08 13 00 	cpc	r8,r10
8000c7f4:	f6 09 13 00 	cpc	r9,r11
8000c7f8:	5f 36       	srlo	r6
8000c7fa:	f8 06 17 00 	moveq	r6,r12
8000c7fe:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c802:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c806:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c80a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c80e:	ed be 00 1f 	bld	lr,0x1f
8000c812:	ef bb 00 1f 	bst	r11,0x1f
8000c816:	0c 0a       	add	r10,r6
8000c818:	5c 0b       	acr	r11
8000c81a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c81e:	e4 1b 00 0f 	andh	r11,0xf
8000c822:	14 4b       	or	r11,r10
8000c824:	e0 81 00 a7 	brne	8000c972 <__avr32_f64_div_res_subnormal+0x98>
8000c828:	f2 06 16 14 	lsr	r6,r9,0x14
8000c82c:	ab d6       	cbr	r6,0xb
8000c82e:	e0 46 07 ff 	cp.w	r6,2047
8000c832:	e0 81 00 a4 	brne	8000c97a <__avr32_f64_div_res_subnormal+0xa0>
8000c836:	c9 e8       	rjmp	8000c972 <__avr32_f64_div_res_subnormal+0x98>
8000c838:	e4 19 00 0f 	andh	r9,0xf
8000c83c:	10 49       	or	r9,r8
8000c83e:	e0 81 00 9a 	brne	8000c972 <__avr32_f64_div_res_subnormal+0x98>
8000c842:	c9 28       	rjmp	8000c966 <__avr32_f64_div_res_subnormal+0x8c>
8000c844:	a3 7b       	lsl	r11,0x3
8000c846:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c84a:	a3 7a       	lsl	r10,0x3
8000c84c:	f5 eb 10 04 	or	r4,r10,r11
8000c850:	e0 80 00 a0 	breq	8000c990 <__avr32_f64_div_op1_zero>
8000c854:	f6 04 12 00 	clz	r4,r11
8000c858:	c1 70       	breq	8000c886 <__avr32_f64_div_round_subnormal+0x96>
8000c85a:	c0 c3       	brcs	8000c872 <__avr32_f64_div_round_subnormal+0x82>
8000c85c:	e8 05 11 20 	rsub	r5,r4,32
8000c860:	f6 04 09 4b 	lsl	r11,r11,r4
8000c864:	f4 05 0a 45 	lsr	r5,r10,r5
8000c868:	0a 4b       	or	r11,r5
8000c86a:	f4 04 09 4a 	lsl	r10,r10,r4
8000c86e:	08 17       	sub	r7,r4
8000c870:	c0 b8       	rjmp	8000c886 <__avr32_f64_div_round_subnormal+0x96>
8000c872:	f4 04 12 00 	clz	r4,r10
8000c876:	f9 b4 03 00 	movlo	r4,0
8000c87a:	f7 b4 02 e0 	subhs	r4,-32
8000c87e:	f4 04 09 4b 	lsl	r11,r10,r4
8000c882:	30 0a       	mov	r10,0
8000c884:	08 17       	sub	r7,r4
8000c886:	a3 8a       	lsr	r10,0x2
8000c888:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000c88c:	a3 8b       	lsr	r11,0x2
8000c88e:	c1 1b       	rjmp	8000c6b0 <__avr32_f64_div+0x20>
8000c890:	a3 79       	lsl	r9,0x3
8000c892:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000c896:	a3 78       	lsl	r8,0x3
8000c898:	f3 e8 10 04 	or	r4,r9,r8
8000c89c:	c6 f0       	breq	8000c97a <__avr32_f64_div_res_subnormal+0xa0>
8000c89e:	f2 04 12 00 	clz	r4,r9
8000c8a2:	c1 70       	breq	8000c8d0 <__avr32_f64_div_round_subnormal+0xe0>
8000c8a4:	c0 c3       	brcs	8000c8bc <__avr32_f64_div_round_subnormal+0xcc>
8000c8a6:	e8 05 11 20 	rsub	r5,r4,32
8000c8aa:	f2 04 09 49 	lsl	r9,r9,r4
8000c8ae:	f0 05 0a 45 	lsr	r5,r8,r5
8000c8b2:	0a 49       	or	r9,r5
8000c8b4:	f0 04 09 48 	lsl	r8,r8,r4
8000c8b8:	08 16       	sub	r6,r4
8000c8ba:	c0 b8       	rjmp	8000c8d0 <__avr32_f64_div_round_subnormal+0xe0>
8000c8bc:	f0 04 12 00 	clz	r4,r8
8000c8c0:	f9 b4 03 00 	movlo	r4,0
8000c8c4:	f7 b4 02 e0 	subhs	r4,-32
8000c8c8:	f0 04 09 49 	lsl	r9,r8,r4
8000c8cc:	30 08       	mov	r8,0
8000c8ce:	08 16       	sub	r6,r4
8000c8d0:	a3 88       	lsr	r8,0x2
8000c8d2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000c8d6:	a3 89       	lsr	r9,0x2
8000c8d8:	cf ca       	rjmp	8000c6d0 <__avr32_f64_div+0x40>

8000c8da <__avr32_f64_div_res_subnormal>:
8000c8da:	5c 37       	neg	r7
8000c8dc:	2f f7       	sub	r7,-1
8000c8de:	f1 b7 04 c0 	satu	r7,0x6
8000c8e2:	e0 47 00 20 	cp.w	r7,32
8000c8e6:	c1 54       	brge	8000c910 <__avr32_f64_div_res_subnormal+0x36>
8000c8e8:	ee 06 11 20 	rsub	r6,r7,32
8000c8ec:	e4 07 0a 42 	lsr	r2,r2,r7
8000c8f0:	e6 06 09 4c 	lsl	r12,r3,r6
8000c8f4:	18 42       	or	r2,r12
8000c8f6:	e6 07 0a 43 	lsr	r3,r3,r7
8000c8fa:	f4 06 09 41 	lsl	r1,r10,r6
8000c8fe:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c902:	f6 06 09 4c 	lsl	r12,r11,r6
8000c906:	18 4a       	or	r10,r12
8000c908:	f6 07 0a 4b 	lsr	r11,r11,r7
8000c90c:	30 00       	mov	r0,0
8000c90e:	c1 58       	rjmp	8000c938 <__avr32_f64_div_res_subnormal+0x5e>
8000c910:	ee 06 11 20 	rsub	r6,r7,32
8000c914:	f9 b0 00 00 	moveq	r0,0
8000c918:	f9 bc 00 00 	moveq	r12,0
8000c91c:	c0 50       	breq	8000c926 <__avr32_f64_div_res_subnormal+0x4c>
8000c91e:	f4 06 09 40 	lsl	r0,r10,r6
8000c922:	f6 06 09 4c 	lsl	r12,r11,r6
8000c926:	e6 07 0a 42 	lsr	r2,r3,r7
8000c92a:	30 03       	mov	r3,0
8000c92c:	f4 07 0a 41 	lsr	r1,r10,r7
8000c930:	18 41       	or	r1,r12
8000c932:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c936:	30 0b       	mov	r11,0
8000c938:	e0 12 ff 00 	andl	r2,0xff00
8000c93c:	e8 12 00 80 	orl	r2,0x80
8000c940:	e6 08 06 46 	mulu.d	r6,r3,r8
8000c944:	e4 09 07 46 	macu.d	r6,r2,r9
8000c948:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c94c:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c950:	0c 05       	add	r5,r6
8000c952:	f0 07 00 48 	adc	r8,r8,r7
8000c956:	5c 09       	acr	r9
8000c958:	30 07       	mov	r7,0
8000c95a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c95e:	00 34       	cp.w	r4,r0
8000c960:	e2 05 13 00 	cpc	r5,r1
8000c964:	c4 6b       	rjmp	8000c7f0 <__avr32_f64_div_round_subnormal>
8000c966:	1c 9b       	mov	r11,lr
8000c968:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c96c:	30 0a       	mov	r10,0
8000c96e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c972:	3f fb       	mov	r11,-1
8000c974:	30 0a       	mov	r10,0
8000c976:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c97a:	f5 eb 10 04 	or	r4,r10,r11
8000c97e:	c0 90       	breq	8000c990 <__avr32_f64_div_op1_zero>
8000c980:	1c 9b       	mov	r11,lr
8000c982:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c986:	ea 1b 7f f0 	orh	r11,0x7ff0
8000c98a:	30 0a       	mov	r10,0
8000c98c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000c990 <__avr32_f64_div_op1_zero>:
8000c990:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000c994:	ce f0       	breq	8000c972 <__avr32_f64_div_res_subnormal+0x98>
8000c996:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000c99a:	e0 44 07 ff 	cp.w	r4,2047
8000c99e:	ce 41       	brne	8000c966 <__avr32_f64_div_res_subnormal+0x8c>
8000c9a0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000c9a4:	ce 10       	breq	8000c966 <__avr32_f64_div_res_subnormal+0x8c>
8000c9a6:	ce 6b       	rjmp	8000c972 <__avr32_f64_div_res_subnormal+0x98>

8000c9a8 <__avr32_udiv64>:
8000c9a8:	d4 31       	pushm	r0-r7,lr
8000c9aa:	1a 97       	mov	r7,sp
8000c9ac:	20 3d       	sub	sp,12
8000c9ae:	10 9c       	mov	r12,r8
8000c9b0:	12 9e       	mov	lr,r9
8000c9b2:	14 93       	mov	r3,r10
8000c9b4:	58 09       	cp.w	r9,0
8000c9b6:	e0 81 00 bd 	brne	8000cb30 <__avr32_udiv64+0x188>
8000c9ba:	16 38       	cp.w	r8,r11
8000c9bc:	e0 88 00 40 	brls	8000ca3c <__avr32_udiv64+0x94>
8000c9c0:	f0 08 12 00 	clz	r8,r8
8000c9c4:	c0 d0       	breq	8000c9de <__avr32_udiv64+0x36>
8000c9c6:	f6 08 09 4b 	lsl	r11,r11,r8
8000c9ca:	f0 09 11 20 	rsub	r9,r8,32
8000c9ce:	f8 08 09 4c 	lsl	r12,r12,r8
8000c9d2:	f4 09 0a 49 	lsr	r9,r10,r9
8000c9d6:	f4 08 09 43 	lsl	r3,r10,r8
8000c9da:	f3 eb 10 0b 	or	r11,r9,r11
8000c9de:	f8 0e 16 10 	lsr	lr,r12,0x10
8000c9e2:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000c9e6:	f6 0e 0d 00 	divu	r0,r11,lr
8000c9ea:	e6 0b 16 10 	lsr	r11,r3,0x10
8000c9ee:	00 99       	mov	r9,r0
8000c9f0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000c9f4:	e0 0a 02 48 	mul	r8,r0,r10
8000c9f8:	10 3b       	cp.w	r11,r8
8000c9fa:	c0 a2       	brcc	8000ca0e <__avr32_udiv64+0x66>
8000c9fc:	20 19       	sub	r9,1
8000c9fe:	18 0b       	add	r11,r12
8000ca00:	18 3b       	cp.w	r11,r12
8000ca02:	c0 63       	brcs	8000ca0e <__avr32_udiv64+0x66>
8000ca04:	10 3b       	cp.w	r11,r8
8000ca06:	f7 b9 03 01 	sublo	r9,1
8000ca0a:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca0e:	f6 08 01 01 	sub	r1,r11,r8
8000ca12:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000ca16:	e2 0e 0d 00 	divu	r0,r1,lr
8000ca1a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000ca1e:	00 98       	mov	r8,r0
8000ca20:	e0 0a 02 4a 	mul	r10,r0,r10
8000ca24:	14 33       	cp.w	r3,r10
8000ca26:	c0 82       	brcc	8000ca36 <__avr32_udiv64+0x8e>
8000ca28:	20 18       	sub	r8,1
8000ca2a:	18 03       	add	r3,r12
8000ca2c:	18 33       	cp.w	r3,r12
8000ca2e:	c0 43       	brcs	8000ca36 <__avr32_udiv64+0x8e>
8000ca30:	14 33       	cp.w	r3,r10
8000ca32:	f7 b8 03 01 	sublo	r8,1
8000ca36:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000ca3a:	cd f8       	rjmp	8000cbf8 <__avr32_udiv64+0x250>
8000ca3c:	58 08       	cp.w	r8,0
8000ca3e:	c0 51       	brne	8000ca48 <__avr32_udiv64+0xa0>
8000ca40:	30 19       	mov	r9,1
8000ca42:	f2 08 0d 08 	divu	r8,r9,r8
8000ca46:	10 9c       	mov	r12,r8
8000ca48:	f8 06 12 00 	clz	r6,r12
8000ca4c:	c0 41       	brne	8000ca54 <__avr32_udiv64+0xac>
8000ca4e:	18 1b       	sub	r11,r12
8000ca50:	30 19       	mov	r9,1
8000ca52:	c4 08       	rjmp	8000cad2 <__avr32_udiv64+0x12a>
8000ca54:	ec 01 11 20 	rsub	r1,r6,32
8000ca58:	f4 01 0a 49 	lsr	r9,r10,r1
8000ca5c:	f8 06 09 4c 	lsl	r12,r12,r6
8000ca60:	f6 06 09 48 	lsl	r8,r11,r6
8000ca64:	f6 01 0a 41 	lsr	r1,r11,r1
8000ca68:	f3 e8 10 08 	or	r8,r9,r8
8000ca6c:	f8 03 16 10 	lsr	r3,r12,0x10
8000ca70:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ca74:	e2 03 0d 00 	divu	r0,r1,r3
8000ca78:	f0 0b 16 10 	lsr	r11,r8,0x10
8000ca7c:	00 9e       	mov	lr,r0
8000ca7e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000ca82:	e0 05 02 49 	mul	r9,r0,r5
8000ca86:	12 3b       	cp.w	r11,r9
8000ca88:	c0 a2       	brcc	8000ca9c <__avr32_udiv64+0xf4>
8000ca8a:	20 1e       	sub	lr,1
8000ca8c:	18 0b       	add	r11,r12
8000ca8e:	18 3b       	cp.w	r11,r12
8000ca90:	c0 63       	brcs	8000ca9c <__avr32_udiv64+0xf4>
8000ca92:	12 3b       	cp.w	r11,r9
8000ca94:	f7 be 03 01 	sublo	lr,1
8000ca98:	f7 dc e3 0b 	addcs	r11,r11,r12
8000ca9c:	12 1b       	sub	r11,r9
8000ca9e:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000caa2:	f6 03 0d 02 	divu	r2,r11,r3
8000caa6:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000caaa:	04 99       	mov	r9,r2
8000caac:	e4 05 02 4b 	mul	r11,r2,r5
8000cab0:	16 38       	cp.w	r8,r11
8000cab2:	c0 a2       	brcc	8000cac6 <__avr32_udiv64+0x11e>
8000cab4:	20 19       	sub	r9,1
8000cab6:	18 08       	add	r8,r12
8000cab8:	18 38       	cp.w	r8,r12
8000caba:	c0 63       	brcs	8000cac6 <__avr32_udiv64+0x11e>
8000cabc:	16 38       	cp.w	r8,r11
8000cabe:	f7 b9 03 01 	sublo	r9,1
8000cac2:	f1 dc e3 08 	addcs	r8,r8,r12
8000cac6:	f4 06 09 43 	lsl	r3,r10,r6
8000caca:	f0 0b 01 0b 	sub	r11,r8,r11
8000cace:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000cad2:	f8 06 16 10 	lsr	r6,r12,0x10
8000cad6:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000cada:	f6 06 0d 00 	divu	r0,r11,r6
8000cade:	e6 0b 16 10 	lsr	r11,r3,0x10
8000cae2:	00 9a       	mov	r10,r0
8000cae4:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cae8:	e0 0e 02 48 	mul	r8,r0,lr
8000caec:	10 3b       	cp.w	r11,r8
8000caee:	c0 a2       	brcc	8000cb02 <__avr32_udiv64+0x15a>
8000caf0:	20 1a       	sub	r10,1
8000caf2:	18 0b       	add	r11,r12
8000caf4:	18 3b       	cp.w	r11,r12
8000caf6:	c0 63       	brcs	8000cb02 <__avr32_udiv64+0x15a>
8000caf8:	10 3b       	cp.w	r11,r8
8000cafa:	f7 ba 03 01 	sublo	r10,1
8000cafe:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cb02:	f6 08 01 01 	sub	r1,r11,r8
8000cb06:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000cb0a:	e2 06 0d 00 	divu	r0,r1,r6
8000cb0e:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000cb12:	00 98       	mov	r8,r0
8000cb14:	e0 0e 02 4b 	mul	r11,r0,lr
8000cb18:	16 33       	cp.w	r3,r11
8000cb1a:	c0 82       	brcc	8000cb2a <__avr32_udiv64+0x182>
8000cb1c:	20 18       	sub	r8,1
8000cb1e:	18 03       	add	r3,r12
8000cb20:	18 33       	cp.w	r3,r12
8000cb22:	c0 43       	brcs	8000cb2a <__avr32_udiv64+0x182>
8000cb24:	16 33       	cp.w	r3,r11
8000cb26:	f7 b8 03 01 	sublo	r8,1
8000cb2a:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000cb2e:	c6 98       	rjmp	8000cc00 <__avr32_udiv64+0x258>
8000cb30:	16 39       	cp.w	r9,r11
8000cb32:	e0 8b 00 65 	brhi	8000cbfc <__avr32_udiv64+0x254>
8000cb36:	f2 09 12 00 	clz	r9,r9
8000cb3a:	c0 b1       	brne	8000cb50 <__avr32_udiv64+0x1a8>
8000cb3c:	10 3a       	cp.w	r10,r8
8000cb3e:	5f 2a       	srhs	r10
8000cb40:	1c 3b       	cp.w	r11,lr
8000cb42:	5f b8       	srhi	r8
8000cb44:	10 4a       	or	r10,r8
8000cb46:	f2 0a 18 00 	cp.b	r10,r9
8000cb4a:	c5 90       	breq	8000cbfc <__avr32_udiv64+0x254>
8000cb4c:	30 18       	mov	r8,1
8000cb4e:	c5 98       	rjmp	8000cc00 <__avr32_udiv64+0x258>
8000cb50:	f0 09 09 46 	lsl	r6,r8,r9
8000cb54:	f2 03 11 20 	rsub	r3,r9,32
8000cb58:	fc 09 09 4e 	lsl	lr,lr,r9
8000cb5c:	f0 03 0a 48 	lsr	r8,r8,r3
8000cb60:	f6 09 09 4c 	lsl	r12,r11,r9
8000cb64:	f4 03 0a 42 	lsr	r2,r10,r3
8000cb68:	ef 46 ff f4 	st.w	r7[-12],r6
8000cb6c:	f6 03 0a 43 	lsr	r3,r11,r3
8000cb70:	18 42       	or	r2,r12
8000cb72:	f1 ee 10 0c 	or	r12,r8,lr
8000cb76:	f8 01 16 10 	lsr	r1,r12,0x10
8000cb7a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cb7e:	e6 01 0d 04 	divu	r4,r3,r1
8000cb82:	e4 03 16 10 	lsr	r3,r2,0x10
8000cb86:	08 9e       	mov	lr,r4
8000cb88:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000cb8c:	e8 06 02 48 	mul	r8,r4,r6
8000cb90:	10 33       	cp.w	r3,r8
8000cb92:	c0 a2       	brcc	8000cba6 <__avr32_udiv64+0x1fe>
8000cb94:	20 1e       	sub	lr,1
8000cb96:	18 03       	add	r3,r12
8000cb98:	18 33       	cp.w	r3,r12
8000cb9a:	c0 63       	brcs	8000cba6 <__avr32_udiv64+0x1fe>
8000cb9c:	10 33       	cp.w	r3,r8
8000cb9e:	f7 be 03 01 	sublo	lr,1
8000cba2:	e7 dc e3 03 	addcs	r3,r3,r12
8000cba6:	10 13       	sub	r3,r8
8000cba8:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000cbac:	e6 01 0d 00 	divu	r0,r3,r1
8000cbb0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cbb4:	00 98       	mov	r8,r0
8000cbb6:	e0 06 02 46 	mul	r6,r0,r6
8000cbba:	0c 3b       	cp.w	r11,r6
8000cbbc:	c0 a2       	brcc	8000cbd0 <__avr32_udiv64+0x228>
8000cbbe:	20 18       	sub	r8,1
8000cbc0:	18 0b       	add	r11,r12
8000cbc2:	18 3b       	cp.w	r11,r12
8000cbc4:	c0 63       	brcs	8000cbd0 <__avr32_udiv64+0x228>
8000cbc6:	0c 3b       	cp.w	r11,r6
8000cbc8:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cbcc:	f7 b8 03 01 	sublo	r8,1
8000cbd0:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cbd4:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cbd8:	0c 1b       	sub	r11,r6
8000cbda:	f0 04 06 42 	mulu.d	r2,r8,r4
8000cbde:	06 95       	mov	r5,r3
8000cbe0:	16 35       	cp.w	r5,r11
8000cbe2:	e0 8b 00 0a 	brhi	8000cbf6 <__avr32_udiv64+0x24e>
8000cbe6:	5f 0b       	sreq	r11
8000cbe8:	f4 09 09 49 	lsl	r9,r10,r9
8000cbec:	12 32       	cp.w	r2,r9
8000cbee:	5f b9       	srhi	r9
8000cbf0:	f7 e9 00 09 	and	r9,r11,r9
8000cbf4:	c0 60       	breq	8000cc00 <__avr32_udiv64+0x258>
8000cbf6:	20 18       	sub	r8,1
8000cbf8:	30 09       	mov	r9,0
8000cbfa:	c0 38       	rjmp	8000cc00 <__avr32_udiv64+0x258>
8000cbfc:	30 09       	mov	r9,0
8000cbfe:	12 98       	mov	r8,r9
8000cc00:	10 9a       	mov	r10,r8
8000cc02:	12 93       	mov	r3,r9
8000cc04:	10 92       	mov	r2,r8
8000cc06:	12 9b       	mov	r11,r9
8000cc08:	2f dd       	sub	sp,-12
8000cc0a:	d8 32       	popm	r0-r7,pc

8000cc0c <__avr32_umod64>:
8000cc0c:	d4 31       	pushm	r0-r7,lr
8000cc0e:	1a 97       	mov	r7,sp
8000cc10:	20 3d       	sub	sp,12
8000cc12:	10 9c       	mov	r12,r8
8000cc14:	12 95       	mov	r5,r9
8000cc16:	14 9e       	mov	lr,r10
8000cc18:	16 91       	mov	r1,r11
8000cc1a:	16 96       	mov	r6,r11
8000cc1c:	58 09       	cp.w	r9,0
8000cc1e:	e0 81 00 81 	brne	8000cd20 <__avr32_umod64+0x114>
8000cc22:	16 38       	cp.w	r8,r11
8000cc24:	e0 88 00 12 	brls	8000cc48 <__avr32_umod64+0x3c>
8000cc28:	f0 08 12 00 	clz	r8,r8
8000cc2c:	c4 e0       	breq	8000ccc8 <__avr32_umod64+0xbc>
8000cc2e:	f6 08 09 46 	lsl	r6,r11,r8
8000cc32:	f8 08 09 4c 	lsl	r12,r12,r8
8000cc36:	f0 0b 11 20 	rsub	r11,r8,32
8000cc3a:	f4 08 09 4e 	lsl	lr,r10,r8
8000cc3e:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cc42:	f7 e6 10 06 	or	r6,r11,r6
8000cc46:	c4 18       	rjmp	8000ccc8 <__avr32_umod64+0xbc>
8000cc48:	58 08       	cp.w	r8,0
8000cc4a:	c0 51       	brne	8000cc54 <__avr32_umod64+0x48>
8000cc4c:	30 19       	mov	r9,1
8000cc4e:	f2 08 0d 08 	divu	r8,r9,r8
8000cc52:	10 9c       	mov	r12,r8
8000cc54:	f8 08 12 00 	clz	r8,r12
8000cc58:	c0 31       	brne	8000cc5e <__avr32_umod64+0x52>
8000cc5a:	18 16       	sub	r6,r12
8000cc5c:	c3 68       	rjmp	8000ccc8 <__avr32_umod64+0xbc>
8000cc5e:	f0 03 11 20 	rsub	r3,r8,32
8000cc62:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cc66:	f8 08 09 4c 	lsl	r12,r12,r8
8000cc6a:	ec 08 09 49 	lsl	r9,r6,r8
8000cc6e:	ec 03 0a 43 	lsr	r3,r6,r3
8000cc72:	f7 e9 10 09 	or	r9,r11,r9
8000cc76:	f8 05 16 10 	lsr	r5,r12,0x10
8000cc7a:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cc7e:	e6 05 0d 02 	divu	r2,r3,r5
8000cc82:	f2 0e 16 10 	lsr	lr,r9,0x10
8000cc86:	ec 02 02 4b 	mul	r11,r6,r2
8000cc8a:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000cc8e:	16 3e       	cp.w	lr,r11
8000cc90:	c0 72       	brcc	8000cc9e <__avr32_umod64+0x92>
8000cc92:	18 0e       	add	lr,r12
8000cc94:	18 3e       	cp.w	lr,r12
8000cc96:	c0 43       	brcs	8000cc9e <__avr32_umod64+0x92>
8000cc98:	16 3e       	cp.w	lr,r11
8000cc9a:	fd dc e3 0e 	addcs	lr,lr,r12
8000cc9e:	fc 0b 01 03 	sub	r3,lr,r11
8000cca2:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000cca6:	e6 05 0d 02 	divu	r2,r3,r5
8000ccaa:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ccae:	a5 36       	mul	r6,r2
8000ccb0:	0c 39       	cp.w	r9,r6
8000ccb2:	c0 72       	brcc	8000ccc0 <__avr32_umod64+0xb4>
8000ccb4:	18 09       	add	r9,r12
8000ccb6:	18 39       	cp.w	r9,r12
8000ccb8:	c0 43       	brcs	8000ccc0 <__avr32_umod64+0xb4>
8000ccba:	0c 39       	cp.w	r9,r6
8000ccbc:	f3 dc e3 09 	addcs	r9,r9,r12
8000ccc0:	f2 06 01 06 	sub	r6,r9,r6
8000ccc4:	f4 08 09 4e 	lsl	lr,r10,r8
8000ccc8:	f8 0a 16 10 	lsr	r10,r12,0x10
8000cccc:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ccd0:	ec 0a 0d 02 	divu	r2,r6,r10
8000ccd4:	fc 09 16 10 	lsr	r9,lr,0x10
8000ccd8:	ea 02 02 4b 	mul	r11,r5,r2
8000ccdc:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000cce0:	16 39       	cp.w	r9,r11
8000cce2:	c0 72       	brcc	8000ccf0 <__avr32_umod64+0xe4>
8000cce4:	18 09       	add	r9,r12
8000cce6:	18 39       	cp.w	r9,r12
8000cce8:	c0 43       	brcs	8000ccf0 <__avr32_umod64+0xe4>
8000ccea:	16 39       	cp.w	r9,r11
8000ccec:	f3 dc e3 09 	addcs	r9,r9,r12
8000ccf0:	f2 0b 01 0b 	sub	r11,r9,r11
8000ccf4:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ccf8:	f6 0a 0d 0a 	divu	r10,r11,r10
8000ccfc:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000cd00:	ea 0a 02 4a 	mul	r10,r5,r10
8000cd04:	14 3e       	cp.w	lr,r10
8000cd06:	c0 72       	brcc	8000cd14 <__avr32_umod64+0x108>
8000cd08:	18 0e       	add	lr,r12
8000cd0a:	18 3e       	cp.w	lr,r12
8000cd0c:	c0 43       	brcs	8000cd14 <__avr32_umod64+0x108>
8000cd0e:	14 3e       	cp.w	lr,r10
8000cd10:	fd dc e3 0e 	addcs	lr,lr,r12
8000cd14:	fc 0a 01 0a 	sub	r10,lr,r10
8000cd18:	30 0b       	mov	r11,0
8000cd1a:	f4 08 0a 4a 	lsr	r10,r10,r8
8000cd1e:	c7 b8       	rjmp	8000ce14 <__avr32_umod64+0x208>
8000cd20:	16 39       	cp.w	r9,r11
8000cd22:	e0 8b 00 79 	brhi	8000ce14 <__avr32_umod64+0x208>
8000cd26:	f2 09 12 00 	clz	r9,r9
8000cd2a:	c1 21       	brne	8000cd4e <__avr32_umod64+0x142>
8000cd2c:	10 3a       	cp.w	r10,r8
8000cd2e:	5f 2b       	srhs	r11
8000cd30:	0a 31       	cp.w	r1,r5
8000cd32:	5f ba       	srhi	r10
8000cd34:	f7 ea 10 0a 	or	r10,r11,r10
8000cd38:	f2 0a 18 00 	cp.b	r10,r9
8000cd3c:	c0 60       	breq	8000cd48 <__avr32_umod64+0x13c>
8000cd3e:	fc 08 01 0c 	sub	r12,lr,r8
8000cd42:	e2 05 01 46 	sbc	r6,r1,r5
8000cd46:	18 9e       	mov	lr,r12
8000cd48:	0c 9b       	mov	r11,r6
8000cd4a:	1c 9a       	mov	r10,lr
8000cd4c:	c6 48       	rjmp	8000ce14 <__avr32_umod64+0x208>
8000cd4e:	ea 09 09 4c 	lsl	r12,r5,r9
8000cd52:	f2 06 11 20 	rsub	r6,r9,32
8000cd56:	f6 09 09 4b 	lsl	r11,r11,r9
8000cd5a:	f0 09 09 42 	lsl	r2,r8,r9
8000cd5e:	ef 46 ff f4 	st.w	r7[-12],r6
8000cd62:	f0 06 0a 48 	lsr	r8,r8,r6
8000cd66:	18 48       	or	r8,r12
8000cd68:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cd6c:	f4 09 09 43 	lsl	r3,r10,r9
8000cd70:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cd74:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cd78:	16 4a       	or	r10,r11
8000cd7a:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cd7e:	f8 0b 0d 04 	divu	r4,r12,r11
8000cd82:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cd86:	08 91       	mov	r1,r4
8000cd88:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cd8c:	e8 0e 02 46 	mul	r6,r4,lr
8000cd90:	0c 3c       	cp.w	r12,r6
8000cd92:	c0 a2       	brcc	8000cda6 <__avr32_umod64+0x19a>
8000cd94:	20 11       	sub	r1,1
8000cd96:	10 0c       	add	r12,r8
8000cd98:	10 3c       	cp.w	r12,r8
8000cd9a:	c0 63       	brcs	8000cda6 <__avr32_umod64+0x19a>
8000cd9c:	0c 3c       	cp.w	r12,r6
8000cd9e:	f7 b1 03 01 	sublo	r1,1
8000cda2:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cda6:	0c 1c       	sub	r12,r6
8000cda8:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cdac:	f8 0b 0d 04 	divu	r4,r12,r11
8000cdb0:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cdb4:	08 96       	mov	r6,r4
8000cdb6:	e8 0e 02 4e 	mul	lr,r4,lr
8000cdba:	1c 3b       	cp.w	r11,lr
8000cdbc:	c0 a2       	brcc	8000cdd0 <__avr32_umod64+0x1c4>
8000cdbe:	20 16       	sub	r6,1
8000cdc0:	10 0b       	add	r11,r8
8000cdc2:	10 3b       	cp.w	r11,r8
8000cdc4:	c0 63       	brcs	8000cdd0 <__avr32_umod64+0x1c4>
8000cdc6:	1c 3b       	cp.w	r11,lr
8000cdc8:	f7 b6 03 01 	sublo	r6,1
8000cdcc:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cdd0:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cdd4:	1c 1b       	sub	r11,lr
8000cdd6:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cdda:	00 9e       	mov	lr,r0
8000cddc:	02 9c       	mov	r12,r1
8000cdde:	16 3c       	cp.w	r12,r11
8000cde0:	e0 8b 00 08 	brhi	8000cdf0 <__avr32_umod64+0x1e4>
8000cde4:	5f 06       	sreq	r6
8000cde6:	06 30       	cp.w	r0,r3
8000cde8:	5f ba       	srhi	r10
8000cdea:	ed ea 00 0a 	and	r10,r6,r10
8000cdee:	c0 60       	breq	8000cdfa <__avr32_umod64+0x1ee>
8000cdf0:	fc 02 01 04 	sub	r4,lr,r2
8000cdf4:	f8 08 01 4c 	sbc	r12,r12,r8
8000cdf8:	08 9e       	mov	lr,r4
8000cdfa:	e6 0e 01 0a 	sub	r10,r3,lr
8000cdfe:	f6 0c 01 4c 	sbc	r12,r11,r12
8000ce02:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000ce06:	f8 09 0a 4b 	lsr	r11,r12,r9
8000ce0a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000ce0e:	f8 01 09 4c 	lsl	r12,r12,r1
8000ce12:	18 4a       	or	r10,r12
8000ce14:	2f dd       	sub	sp,-12
8000ce16:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000d000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000d000:	c0 08       	rjmp	8000d000 <_evba>
	...

8000d004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000d004:	c0 08       	rjmp	8000d004 <_handle_TLB_Multiple_Hit>
	...

8000d008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000d008:	c0 08       	rjmp	8000d008 <_handle_Bus_Error_Data_Fetch>
	...

8000d00c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000d00c:	c0 08       	rjmp	8000d00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000d010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000d010:	c0 08       	rjmp	8000d010 <_handle_NMI>
	...

8000d014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000d014:	c0 08       	rjmp	8000d014 <_handle_Instruction_Address>
	...

8000d018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000d018:	c0 08       	rjmp	8000d018 <_handle_ITLB_Protection>
	...

8000d01c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000d01c:	c0 08       	rjmp	8000d01c <_handle_Breakpoint>
	...

8000d020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000d020:	c0 08       	rjmp	8000d020 <_handle_Illegal_Opcode>
	...

8000d024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000d024:	c0 08       	rjmp	8000d024 <_handle_Unimplemented_Instruction>
	...

8000d028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000d028:	c0 08       	rjmp	8000d028 <_handle_Privilege_Violation>
	...

8000d02c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000d02c:	c0 08       	rjmp	8000d02c <_handle_Floating_Point>
	...

8000d030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000d030:	c0 08       	rjmp	8000d030 <_handle_Coprocessor_Absent>
	...

8000d034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000d034:	c0 08       	rjmp	8000d034 <_handle_Data_Address_Read>
	...

8000d038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000d038:	c0 08       	rjmp	8000d038 <_handle_Data_Address_Write>
	...

8000d03c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000d03c:	c0 08       	rjmp	8000d03c <_handle_DTLB_Protection_Read>
	...

8000d040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000d040:	c0 08       	rjmp	8000d040 <_handle_DTLB_Protection_Write>
	...

8000d044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000d044:	c0 08       	rjmp	8000d044 <_handle_DTLB_Modified>
	...

8000d050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000d050:	c0 08       	rjmp	8000d050 <_handle_ITLB_Miss>
	...

8000d060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000d060:	c0 08       	rjmp	8000d060 <_handle_DTLB_Miss_Read>
	...

8000d070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000d070:	c0 08       	rjmp	8000d070 <_handle_DTLB_Miss_Write>
	...

8000d100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000d100:	fe cf 71 80 	sub	pc,pc,29056

8000d104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000d104:	30 0c       	mov	r12,0
8000d106:	fe b0 c2 a3 	rcall	8000564c <_get_interrupt_handler>
8000d10a:	58 0c       	cp.w	r12,0
8000d10c:	f8 0f 17 10 	movne	pc,r12
8000d110:	d6 03       	rete

8000d112 <_int1>:
8000d112:	30 1c       	mov	r12,1
8000d114:	fe b0 c2 9c 	rcall	8000564c <_get_interrupt_handler>
8000d118:	58 0c       	cp.w	r12,0
8000d11a:	f8 0f 17 10 	movne	pc,r12
8000d11e:	d6 03       	rete

8000d120 <_int2>:
8000d120:	30 2c       	mov	r12,2
8000d122:	fe b0 c2 95 	rcall	8000564c <_get_interrupt_handler>
8000d126:	58 0c       	cp.w	r12,0
8000d128:	f8 0f 17 10 	movne	pc,r12
8000d12c:	d6 03       	rete

8000d12e <_int3>:
8000d12e:	30 3c       	mov	r12,3
8000d130:	fe b0 c2 8e 	rcall	8000564c <_get_interrupt_handler>
8000d134:	58 0c       	cp.w	r12,0
8000d136:	f8 0f 17 10 	movne	pc,r12
8000d13a:	d6 03       	rete

8000d13c <ipr_val>:
8000d13c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000d14c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d15c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d16c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d17c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d18c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d19c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1fc:	d7 03 d7 03                                         ....
