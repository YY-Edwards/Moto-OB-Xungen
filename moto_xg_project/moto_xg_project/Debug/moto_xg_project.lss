
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000afa8  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000d000  8000d000  0000d400  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       0000133c  8000d200  8000d200  0000d600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  8000e53c  8000e53c  0000e93c  2**0
                  ALLOC
  6 .data         00000a48  00000004  8000e540  0000ec04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  00000a4c  8000ef88  0000f64c  2**0
                  ALLOC
  8 .bss          000049d8  00000a50  8000ef88  0000f650  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  0000f64c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000014c0  00000000  00000000  0000f680  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 00003109  00000000  00000000  00010b40  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   0002b525  00000000  00000000  00013c49  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00007084  00000000  00000000  0003f16e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000d034  00000000  00000000  000461f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  000038b8  00000000  00000000  00053228  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00007bf4  00000000  00000000  00056ae0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    0000ec2d  00000000  00000000  0005e6d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 19 .debug_ranges 00001588  00000000  00000000  0006d308  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf c1 14 	sub	pc,pc,-16108

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0d f8       	ld.ub	r8,r6[0x7]

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 70       	tst	r0,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 04       	add	r4,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	3d 2c       	mov	r12,-46
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	29 e4       	sub	r4,-98
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	d2 00       	acall	0x20
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 0c       	sub	r12,112
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	6e bc       	ld.w	r12,r7[0x2c]
8000208c:	00 00       	add	r0,r0
8000208e:	0a 68       	and	r8,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	d2 08       	*unknown*
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	72 80       	ld.w	r0,r9[0x20]

800020a4 <app_payload_rx_proc>:
	}
}


static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 6c       	and	r12,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	d2 0c       	*unknown*
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	72 80       	ld.w	r0,r9[0x20]
800020d4:	00 00       	add	r0,r0
800020d6:	0a 53       	eor	r3,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	d2 18       	*unknown*
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	72 80       	ld.w	r0,r9[0x20]

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	d2 38       	*unknown*
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	72 80       	ld.w	r0,r9[0x20]

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	d2 54       	*unknown*
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	72 80       	ld.w	r0,r9[0x20]

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	d2 70       	acall	0x27
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	72 80       	ld.w	r0,r9[0x20]

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	d2 88       	*unknown*
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	72 80       	ld.w	r0,r9[0x20]
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	d2 a0       	acall	0x2a
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	d2 b4       	*unknown*
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	d2 cc       	*unknown*
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	d2 e8       	*unknown*

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	d4 01       	pushm	lr
	if (xcmp->u8[0] == 0x11)
8000219a:	19 a9       	ld.ub	r9,r12[0x2]
8000219c:	31 18       	mov	r8,17
8000219e:	f0 09 18 00 	cp.b	r9,r8
800021a2:	c0 41       	brne	800021aa <SingleDetection_brdcst_func+0x12>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a4:	48 2c       	lddpc	r12,800021ac <SingleDetection_brdcst_func+0x14>
800021a6:	f0 1f 00 03 	mcall	800021b0 <SingleDetection_brdcst_func+0x18>
800021aa:	d8 02       	popm	pc
800021ac:	80 00       	ld.sh	r0,r0[0x0]
800021ae:	d3 00       	acall	0x30
800021b0:	80 00       	ld.sh	r0,r0[0x0]
800021b2:	72 80       	ld.w	r0,r9[0x20]

800021b4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021b4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021b6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ba:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021bc:	4a bc       	lddpc	r12,80002268 <ButtonConfig_brdcst_func+0xb4>
800021be:	f0 1f 00 2c 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021c2:	0f 88       	ld.ub	r8,r7[0x0]
800021c4:	1a d8       	st.w	--sp,r8
800021c6:	4a bc       	lddpc	r12,80002270 <ButtonConfig_brdcst_func+0xbc>
800021c8:	f0 1f 00 29 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021cc:	1a d5       	st.w	--sp,r5
800021ce:	4a ac       	lddpc	r12,80002274 <ButtonConfig_brdcst_func+0xc0>
800021d0:	f0 1f 00 27 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
800021d4:	0f a8       	ld.ub	r8,r7[0x2]
800021d6:	1a d8       	st.w	--sp,r8
800021d8:	4a 8c       	lddpc	r12,80002278 <ButtonConfig_brdcst_func+0xc4>
800021da:	f0 1f 00 25 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
800021de:	2f dd       	sub	sp,-12
800021e0:	58 05       	cp.w	r5,0
800021e2:	c4 10       	breq	80002264 <ButtonConfig_brdcst_func+0xb0>
800021e4:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021e6:	4a 64       	lddpc	r4,8000227c <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
800021e8:	4a 63       	lddpc	r3,80002280 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
800021ea:	4a 72       	lddpc	r2,80002284 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
800021ec:	4a 71       	lddpc	r1,80002288 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
800021ee:	4a 80       	lddpc	r0,8000228c <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
800021f0:	0f b9       	ld.ub	r9,r7[0x3]
800021f2:	0f c8       	ld.ub	r8,r7[0x4]
800021f4:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800021f8:	1a d8       	st.w	--sp,r8
800021fa:	1a d6       	st.w	--sp,r6
800021fc:	08 9c       	mov	r12,r4
800021fe:	f0 1f 00 1c 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002202:	0f d9       	ld.ub	r9,r7[0x5]
80002204:	0f e8       	ld.ub	r8,r7[0x6]
80002206:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000220a:	1a d8       	st.w	--sp,r8
8000220c:	1a d6       	st.w	--sp,r6
8000220e:	06 9c       	mov	r12,r3
80002210:	f0 1f 00 17 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002214:	0f f9       	ld.ub	r9,r7[0x7]
80002216:	ef 38 00 08 	ld.ub	r8,r7[8]
8000221a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000221e:	1a d8       	st.w	--sp,r8
80002220:	1a d6       	st.w	--sp,r6
80002222:	04 9c       	mov	r12,r2
80002224:	f0 1f 00 12 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002228:	ef 39 00 09 	ld.ub	r9,r7[9]
8000222c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002230:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002234:	1a d8       	st.w	--sp,r8
80002236:	1a d6       	st.w	--sp,r6
80002238:	02 9c       	mov	r12,r1
8000223a:	f0 1f 00 0d 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000223e:	2f 8d       	sub	sp,-32
80002240:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002244:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002248:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224c:	1a d8       	st.w	--sp,r8
8000224e:	1a d6       	st.w	--sp,r6
80002250:	00 9c       	mov	r12,r0
80002252:	f0 1f 00 07 	mcall	8000226c <ButtonConfig_brdcst_func+0xb8>
80002256:	2f f6       	sub	r6,-1
80002258:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000225a:	2f ed       	sub	sp,-8
8000225c:	ec 05 18 00 	cp.b	r5,r6
80002260:	fe 9b ff c8 	brhi	800021f0 <ButtonConfig_brdcst_func+0x3c>
80002264:	d8 32       	popm	r0-r7,pc
80002266:	00 00       	add	r0,r0
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	d3 14       	*unknown*
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	72 80       	ld.w	r0,r9[0x20]
80002270:	80 00       	ld.sh	r0,r0[0x0]
80002272:	d3 34       	*unknown*
80002274:	80 00       	ld.sh	r0,r0[0x0]
80002276:	d3 48       	*unknown*
80002278:	80 00       	ld.sh	r0,r0[0x0]
8000227a:	d3 60       	acall	0x36
8000227c:	80 00       	ld.sh	r0,r0[0x0]
8000227e:	d3 80       	acall	0x38
80002280:	80 00       	ld.sh	r0,r0[0x0]
80002282:	d3 a8       	*unknown*
80002284:	80 00       	ld.sh	r0,r0[0x0]
80002286:	d3 d0       	acall	0x3d
80002288:	80 00       	ld.sh	r0,r0[0x0]
8000228a:	d3 f4       	*unknown*
8000228c:	80 00       	ld.sh	r0,r0[0x0]
8000228e:	d4 1c       	*unknown*

80002290 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
80002290:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
80002294:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
80002298:	0f 89       	ld.ub	r9,r7[0x0]
8000229a:	30 08       	mov	r8,0
8000229c:	f0 09 18 00 	cp.b	r9,r8
800022a0:	c0 c1       	brne	800022b8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022a2:	48 9c       	lddpc	r12,800022c4 <ButtonConfig_reply_func+0x34>
800022a4:	f0 1f 00 09 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022a8:	0f 98       	ld.ub	r8,r7[0x1]
800022aa:	1a d8       	st.w	--sp,r8
800022ac:	48 8c       	lddpc	r12,800022cc <ButtonConfig_reply_func+0x3c>
800022ae:	f0 1f 00 07 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
800022b2:	2f fd       	sub	sp,-4
800022b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022b8:	48 6c       	lddpc	r12,800022d0 <ButtonConfig_reply_func+0x40>
800022ba:	f0 1f 00 04 	mcall	800022c8 <ButtonConfig_reply_func+0x38>
800022be:	e3 cd 80 80 	ldm	sp++,r7,pc
800022c2:	00 00       	add	r0,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	d4 40       	acall	0x44
800022c8:	80 00       	ld.sh	r0,r0[0x0]
800022ca:	72 80       	ld.w	r0,r9[0x20]
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	d3 34       	*unknown*
800022d0:	80 00       	ld.sh	r0,r0[0x0]
800022d2:	d4 58       	*unknown*

800022d4 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
800022d4:	eb cd 40 80 	pushm	r7,lr
800022d8:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800022da:	19 a9       	ld.ub	r9,r12[0x2]
800022dc:	30 08       	mov	r8,0
800022de:	f0 09 18 00 	cp.b	r9,r8
800022e2:	c1 11       	brne	80002304 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
800022e4:	49 3c       	lddpc	r12,80002330 <DataSession_reply_func+0x5c>
800022e6:	f0 1f 00 14 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
800022ea:	0f b8       	ld.ub	r8,r7[0x3]
800022ec:	1a d8       	st.w	--sp,r8
800022ee:	49 3c       	lddpc	r12,80002338 <DataSession_reply_func+0x64>
800022f0:	f0 1f 00 11 	mcall	80002334 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
800022f4:	0f c8       	ld.ub	r8,r7[0x4]
800022f6:	1a d8       	st.w	--sp,r8
800022f8:	49 1c       	lddpc	r12,8000233c <DataSession_reply_func+0x68>
800022fa:	f0 1f 00 0f 	mcall	80002334 <DataSession_reply_func+0x60>
800022fe:	2f ed       	sub	sp,-8
80002300:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002304:	48 fc       	lddpc	r12,80002340 <DataSession_reply_func+0x6c>
80002306:	f0 1f 00 0c 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000230a:	0f a8       	ld.ub	r8,r7[0x2]
8000230c:	1a d8       	st.w	--sp,r8
8000230e:	48 ec       	lddpc	r12,80002344 <DataSession_reply_func+0x70>
80002310:	f0 1f 00 09 	mcall	80002334 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002314:	0f b8       	ld.ub	r8,r7[0x3]
80002316:	1a d8       	st.w	--sp,r8
80002318:	48 cc       	lddpc	r12,80002348 <DataSession_reply_func+0x74>
8000231a:	f0 1f 00 07 	mcall	80002334 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000231e:	0f c8       	ld.ub	r8,r7[0x4]
80002320:	1a d8       	st.w	--sp,r8
80002322:	48 bc       	lddpc	r12,8000234c <DataSession_reply_func+0x78>
80002324:	f0 1f 00 04 	mcall	80002334 <DataSession_reply_func+0x60>
80002328:	2f dd       	sub	sp,-12
8000232a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000232e:	00 00       	add	r0,r0
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	d4 74       	*unknown*
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	72 80       	ld.w	r0,r9[0x20]
80002338:	80 00       	ld.sh	r0,r0[0x0]
8000233a:	d4 84       	*unknown*
8000233c:	80 00       	ld.sh	r0,r0[0x0]
8000233e:	d4 90       	acall	0x49
80002340:	80 00       	ld.sh	r0,r0[0x0]
80002342:	d4 9c       	*unknown*
80002344:	80 00       	ld.sh	r0,r0[0x0]
80002346:	d4 ac       	*unknown*
80002348:	80 00       	ld.sh	r0,r0[0x0]
8000234a:	d4 bc       	*unknown*
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	d4 c8       	*unknown*

80002350 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002350:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002354:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002358:	0f 98       	ld.ub	r8,r7[0x1]
8000235a:	1a d8       	st.w	--sp,r8
8000235c:	48 bc       	lddpc	r12,80002388 <CallControl_brdcst_func+0x38>
8000235e:	f0 1f 00 0c 	mcall	8000238c <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002362:	2f fd       	sub	sp,-4
80002364:	0f 99       	ld.ub	r9,r7[0x1]
80002366:	30 38       	mov	r8,3
80002368:	f0 09 18 00 	cp.b	r9,r8
8000236c:	c0 41       	brne	80002374 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000236e:	30 09       	mov	r9,0
80002370:	48 88       	lddpc	r8,80002390 <CallControl_brdcst_func+0x40>
80002372:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
80002374:	0f 99       	ld.ub	r9,r7[0x1]
80002376:	30 48       	mov	r8,4
80002378:	f0 09 18 00 	cp.b	r9,r8
8000237c:	c0 41       	brne	80002384 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
8000237e:	30 19       	mov	r9,1
80002380:	48 48       	lddpc	r8,80002390 <CallControl_brdcst_func+0x40>
80002382:	b0 89       	st.b	r8[0x0],r9
80002384:	e3 cd 80 80 	ldm	sp++,r7,pc
80002388:	80 00       	ld.sh	r0,r0[0x0]
8000238a:	d4 d4       	*unknown*
8000238c:	80 00       	ld.sh	r0,r0[0x0]
8000238e:	72 80       	ld.w	r0,r9[0x20]
80002390:	00 00       	add	r0,r0
80002392:	0a 55       	eor	r5,r5

80002394 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002394:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
80002398:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
8000239c:	0f 99       	ld.ub	r9,r7[0x1]
8000239e:	30 08       	mov	r8,0
800023a0:	f0 09 18 00 	cp.b	r9,r8
800023a4:	c0 71       	brne	800023b2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023a6:	48 ac       	lddpc	r12,800023cc <TransmitControl_brdcst_func+0x38>
800023a8:	f0 1f 00 0a 	mcall	800023d0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023ac:	30 09       	mov	r9,0
800023ae:	48 a8       	lddpc	r8,800023d4 <TransmitControl_brdcst_func+0x40>
800023b0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023b2:	0f 99       	ld.ub	r9,r7[0x1]
800023b4:	30 18       	mov	r8,1
800023b6:	f0 09 18 00 	cp.b	r9,r8
800023ba:	c0 71       	brne	800023c8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023bc:	48 7c       	lddpc	r12,800023d8 <TransmitControl_brdcst_func+0x44>
800023be:	f0 1f 00 05 	mcall	800023d0 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023c2:	30 19       	mov	r9,1
800023c4:	48 48       	lddpc	r8,800023d4 <TransmitControl_brdcst_func+0x40>
800023c6:	b0 89       	st.b	r8[0x0],r9
800023c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023cc:	80 00       	ld.sh	r0,r0[0x0]
800023ce:	d4 ec       	*unknown*
800023d0:	80 00       	ld.sh	r0,r0[0x0]
800023d2:	72 80       	ld.w	r0,r9[0x20]
800023d4:	00 00       	add	r0,r0
800023d6:	0a 54       	eor	r4,r5
800023d8:	80 00       	ld.sh	r0,r0[0x0]
800023da:	d5 04       	*unknown*

800023dc <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
800023dc:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
800023e0:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
800023e4:	0f 89       	ld.ub	r9,r7[0x0]
800023e6:	30 08       	mov	r8,0
800023e8:	f0 09 18 00 	cp.b	r9,r8
800023ec:	c1 61       	brne	80002418 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
800023ee:	48 ec       	lddpc	r12,80002424 <TransmitControl_reply_func+0x48>
800023f0:	f0 1f 00 0e 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
800023f4:	0f 98       	ld.ub	r8,r7[0x1]
800023f6:	1a d8       	st.w	--sp,r8
800023f8:	48 dc       	lddpc	r12,8000242c <TransmitControl_reply_func+0x50>
800023fa:	f0 1f 00 0c 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
800023fe:	0f a8       	ld.ub	r8,r7[0x2]
80002400:	1a d8       	st.w	--sp,r8
80002402:	48 cc       	lddpc	r12,80002430 <TransmitControl_reply_func+0x54>
80002404:	f0 1f 00 09 	mcall	80002428 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002408:	0f b8       	ld.ub	r8,r7[0x3]
8000240a:	1a d8       	st.w	--sp,r8
8000240c:	48 ac       	lddpc	r12,80002434 <TransmitControl_reply_func+0x58>
8000240e:	f0 1f 00 07 	mcall	80002428 <TransmitControl_reply_func+0x4c>
80002412:	2f dd       	sub	sp,-12
80002414:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002418:	48 8c       	lddpc	r12,80002438 <TransmitControl_reply_func+0x5c>
8000241a:	f0 1f 00 04 	mcall	80002428 <TransmitControl_reply_func+0x4c>
8000241e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002422:	00 00       	add	r0,r0
80002424:	80 00       	ld.sh	r0,r0[0x0]
80002426:	d5 18       	*unknown*
80002428:	80 00       	ld.sh	r0,r0[0x0]
8000242a:	72 80       	ld.w	r0,r9[0x20]
8000242c:	80 00       	ld.sh	r0,r0[0x0]
8000242e:	d5 34       	*unknown*
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	d5 48       	*unknown*
80002434:	80 00       	ld.sh	r0,r0[0x0]
80002436:	d5 64       	*unknown*
80002438:	80 00       	ld.sh	r0,r0[0x0]
8000243a:	d5 74       	*unknown*

8000243c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000243c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000243e:	19 a9       	ld.ub	r9,r12[0x2]
80002440:	30 08       	mov	r8,0
80002442:	f0 09 18 00 	cp.b	r9,r8
80002446:	c0 51       	brne	80002450 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002448:	48 4c       	lddpc	r12,80002458 <AudioRoutingControl_reply_func+0x1c>
8000244a:	f0 1f 00 05 	mcall	8000245c <AudioRoutingControl_reply_func+0x20>
8000244e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002450:	48 4c       	lddpc	r12,80002460 <AudioRoutingControl_reply_func+0x24>
80002452:	f0 1f 00 03 	mcall	8000245c <AudioRoutingControl_reply_func+0x20>
80002456:	d8 02       	popm	pc
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	d5 8c       	*unknown*
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	72 80       	ld.w	r0,r9[0x20]
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	d5 9c       	*unknown*

80002464 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002464:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002468:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000246c:	0f 89       	ld.ub	r9,r7[0x0]
8000246e:	30 08       	mov	r8,0
80002470:	f0 09 18 00 	cp.b	r9,r8
80002474:	c1 b1       	brne	800024aa <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
80002476:	0f b8       	ld.ub	r8,r7[0x3]
80002478:	31 09       	mov	r9,16
8000247a:	f2 08 18 00 	cp.b	r8,r9
8000247e:	c0 f1       	brne	8000249c <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
80002480:	48 dc       	lddpc	r12,800024b4 <Volume_reply_func+0x50>
80002482:	f0 1f 00 0e 	mcall	800024b8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
80002486:	0f 99       	ld.ub	r9,r7[0x1]
80002488:	0f a8       	ld.ub	r8,r7[0x2]
8000248a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000248e:	1a d8       	st.w	--sp,r8
80002490:	48 bc       	lddpc	r12,800024bc <Volume_reply_func+0x58>
80002492:	f0 1f 00 0a 	mcall	800024b8 <Volume_reply_func+0x54>
80002496:	2f fd       	sub	sp,-4
80002498:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
8000249c:	1a d8       	st.w	--sp,r8
8000249e:	48 9c       	lddpc	r12,800024c0 <Volume_reply_func+0x5c>
800024a0:	f0 1f 00 06 	mcall	800024b8 <Volume_reply_func+0x54>
800024a4:	2f fd       	sub	sp,-4
800024a6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024aa:	48 7c       	lddpc	r12,800024c4 <Volume_reply_func+0x60>
800024ac:	f0 1f 00 03 	mcall	800024b8 <Volume_reply_func+0x54>
800024b0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024b4:	80 00       	ld.sh	r0,r0[0x0]
800024b6:	d5 b0       	acall	0x5b
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	72 80       	ld.w	r0,r9[0x20]
800024bc:	80 00       	ld.sh	r0,r0[0x0]
800024be:	d5 c4       	*unknown*
800024c0:	80 00       	ld.sh	r0,r0[0x0]
800024c2:	d5 e0       	acall	0x5e
800024c4:	80 00       	ld.sh	r0,r0[0x0]
800024c6:	d5 f8       	*unknown*

800024c8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024c8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024ca:	19 d9       	ld.ub	r9,r12[0x5]
800024cc:	30 08       	mov	r8,0
800024ce:	f0 09 18 00 	cp.b	r9,r8
800024d2:	c0 81       	brne	800024e2 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
800024d4:	10 99       	mov	r9,r8
800024d6:	48 78       	lddpc	r8,800024f0 <spk_brdcst_func+0x28>
800024d8:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
800024da:	48 7c       	lddpc	r12,800024f4 <spk_brdcst_func+0x2c>
800024dc:	f0 1f 00 07 	mcall	800024f8 <spk_brdcst_func+0x30>
800024e0:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
800024e2:	30 19       	mov	r9,1
800024e4:	48 38       	lddpc	r8,800024f0 <spk_brdcst_func+0x28>
800024e6:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
800024e8:	48 5c       	lddpc	r12,800024fc <spk_brdcst_func+0x34>
800024ea:	f0 1f 00 04 	mcall	800024f8 <spk_brdcst_func+0x30>
800024ee:	d8 02       	popm	pc
800024f0:	00 00       	add	r0,r0
800024f2:	0a 50       	eor	r0,r5
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	d6 10       	acall	0x61
800024f8:	80 00       	ld.sh	r0,r0[0x0]
800024fa:	72 80       	ld.w	r0,r9[0x20]
800024fc:	80 00       	ld.sh	r0,r0[0x0]
800024fe:	d6 20       	acall	0x62

80002500 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002500:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002502:	19 a9       	ld.ub	r9,r12[0x2]
80002504:	30 08       	mov	r8,0
80002506:	f0 09 18 00 	cp.b	r9,r8
8000250a:	c0 f1       	brne	80002528 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000250c:	19 e9       	ld.ub	r9,r12[0x6]
8000250e:	f0 09 18 00 	cp.b	r9,r8
80002512:	c0 40       	breq	8000251a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002514:	30 19       	mov	r9,1
80002516:	48 98       	lddpc	r8,80002538 <spk_reply_func+0x38>
80002518:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000251a:	19 e8       	ld.ub	r8,r12[0x6]
8000251c:	1a d8       	st.w	--sp,r8
8000251e:	48 8c       	lddpc	r12,8000253c <spk_reply_func+0x3c>
80002520:	f0 1f 00 08 	mcall	80002540 <spk_reply_func+0x40>
80002524:	2f fd       	sub	sp,-4
80002526:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002528:	30 09       	mov	r9,0
8000252a:	48 48       	lddpc	r8,80002538 <spk_reply_func+0x38>
8000252c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000252e:	48 6c       	lddpc	r12,80002544 <spk_reply_func+0x44>
80002530:	f0 1f 00 04 	mcall	80002540 <spk_reply_func+0x40>
80002534:	d8 02       	popm	pc
80002536:	00 00       	add	r0,r0
80002538:	00 00       	add	r0,r0
8000253a:	0a 50       	eor	r0,r5
8000253c:	80 00       	ld.sh	r0,r0[0x0]
8000253e:	d6 2c       	*unknown*
80002540:	80 00       	ld.sh	r0,r0[0x0]
80002542:	72 80       	ld.w	r0,r9[0x20]
80002544:	80 00       	ld.sh	r0,r0[0x0]
80002546:	d6 3c       	*unknown*

80002548 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002548:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000254c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002550:	0f a9       	ld.ub	r9,r7[0x2]
80002552:	30 08       	mov	r8,0
80002554:	f0 09 18 00 	cp.b	r9,r8
80002558:	c0 71       	brne	80002566 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000255a:	48 dc       	lddpc	r12,8000258c <mic_brdcst_func+0x44>
8000255c:	f0 1f 00 0d 	mcall	80002590 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002560:	30 09       	mov	r9,0
80002562:	48 d8       	lddpc	r8,80002594 <mic_brdcst_func+0x4c>
80002564:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002566:	0f a9       	ld.ub	r9,r7[0x2]
80002568:	31 18       	mov	r8,17
8000256a:	f0 09 18 00 	cp.b	r9,r8
8000256e:	c0 d1       	brne	80002588 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
80002570:	48 ac       	lddpc	r12,80002598 <mic_brdcst_func+0x50>
80002572:	f0 1f 00 08 	mcall	80002590 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
80002576:	48 89       	lddpc	r9,80002594 <mic_brdcst_func+0x4c>
80002578:	30 18       	mov	r8,1
8000257a:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
8000257c:	13 89       	ld.ub	r9,r9[0x0]
8000257e:	f0 09 18 00 	cp.b	r9,r8
80002582:	c0 31       	brne	80002588 <mic_brdcst_func+0x40>
80002584:	48 68       	lddpc	r8,8000259c <mic_brdcst_func+0x54>
80002586:	11 88       	ld.ub	r8,r8[0x0]
80002588:	e3 cd 80 80 	ldm	sp++,r7,pc
8000258c:	80 00       	ld.sh	r0,r0[0x0]
8000258e:	d6 48       	*unknown*
80002590:	80 00       	ld.sh	r0,r0[0x0]
80002592:	72 80       	ld.w	r0,r9[0x20]
80002594:	00 00       	add	r0,r0
80002596:	0a 65       	and	r5,r5
80002598:	80 00       	ld.sh	r0,r0[0x0]
8000259a:	d6 5c       	*unknown*
8000259c:	00 00       	add	r0,r0
8000259e:	0a 55       	eor	r5,r5

800025a0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025a0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025a4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025a8:	49 ac       	lddpc	r12,80002610 <mic_reply_func+0x70>
800025aa:	f0 1f 00 1b 	mcall	80002614 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025ae:	0f 89       	ld.ub	r9,r7[0x0]
800025b0:	30 08       	mov	r8,0
800025b2:	f0 09 18 00 	cp.b	r9,r8
800025b6:	c2 71       	brne	80002604 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025b8:	0f 98       	ld.ub	r8,r7[0x1]
800025ba:	30 29       	mov	r9,2
800025bc:	f2 08 18 00 	cp.b	r8,r9
800025c0:	c1 b1       	brne	800025f6 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025c2:	49 6c       	lddpc	r12,80002618 <mic_reply_func+0x78>
800025c4:	f0 1f 00 14 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025c8:	0f a8       	ld.ub	r8,r7[0x2]
800025ca:	1a d8       	st.w	--sp,r8
800025cc:	49 4c       	lddpc	r12,8000261c <mic_reply_func+0x7c>
800025ce:	f0 1f 00 12 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
800025d2:	0f b8       	ld.ub	r8,r7[0x3]
800025d4:	1a d8       	st.w	--sp,r8
800025d6:	49 3c       	lddpc	r12,80002620 <mic_reply_func+0x80>
800025d8:	f0 1f 00 0f 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
800025dc:	0f c8       	ld.ub	r8,r7[0x4]
800025de:	1a d8       	st.w	--sp,r8
800025e0:	49 1c       	lddpc	r12,80002624 <mic_reply_func+0x84>
800025e2:	f0 1f 00 0d 	mcall	80002614 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
800025e6:	0f d8       	ld.ub	r8,r7[0x5]
800025e8:	1a d8       	st.w	--sp,r8
800025ea:	49 0c       	lddpc	r12,80002628 <mic_reply_func+0x88>
800025ec:	f0 1f 00 0a 	mcall	80002614 <mic_reply_func+0x74>
800025f0:	2f cd       	sub	sp,-16
800025f2:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
800025f6:	1a d8       	st.w	--sp,r8
800025f8:	48 dc       	lddpc	r12,8000262c <mic_reply_func+0x8c>
800025fa:	f0 1f 00 07 	mcall	80002614 <mic_reply_func+0x74>
800025fe:	2f fd       	sub	sp,-4
80002600:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002604:	48 bc       	lddpc	r12,80002630 <mic_reply_func+0x90>
80002606:	f0 1f 00 04 	mcall	80002614 <mic_reply_func+0x74>
8000260a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000260e:	00 00       	add	r0,r0
80002610:	80 00       	ld.sh	r0,r0[0x0]
80002612:	d6 70       	acall	0x67
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	72 80       	ld.w	r0,r9[0x20]
80002618:	80 00       	ld.sh	r0,r0[0x0]
8000261a:	d6 80       	acall	0x68
8000261c:	80 00       	ld.sh	r0,r0[0x0]
8000261e:	d6 94       	*unknown*
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	d6 a8       	*unknown*
80002624:	80 00       	ld.sh	r0,r0[0x0]
80002626:	d6 c4       	*unknown*
80002628:	80 00       	ld.sh	r0,r0[0x0]
8000262a:	d6 dc       	*unknown*
8000262c:	80 00       	ld.sh	r0,r0[0x0]
8000262e:	d6 f4       	*unknown*
80002630:	80 00       	ld.sh	r0,r0[0x0]
80002632:	d7 0c       	*unknown*

80002634 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002634:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002638:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000263c:	48 bc       	lddpc	r12,80002668 <dcm_brdcst_func+0x34>
8000263e:	f0 1f 00 0c 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002642:	0f 88       	ld.ub	r8,r7[0x0]
80002644:	1a d8       	st.w	--sp,r8
80002646:	48 bc       	lddpc	r12,80002670 <dcm_brdcst_func+0x3c>
80002648:	f0 1f 00 09 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000264c:	0f a8       	ld.ub	r8,r7[0x2]
8000264e:	1a d8       	st.w	--sp,r8
80002650:	48 9c       	lddpc	r12,80002674 <dcm_brdcst_func+0x40>
80002652:	f0 1f 00 07 	mcall	8000266c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002656:	0f 98       	ld.ub	r8,r7[0x1]
80002658:	1a d8       	st.w	--sp,r8
8000265a:	48 8c       	lddpc	r12,80002678 <dcm_brdcst_func+0x44>
8000265c:	f0 1f 00 04 	mcall	8000266c <dcm_brdcst_func+0x38>
80002660:	2f dd       	sub	sp,-12
	
	
}
80002662:	e3 cd 80 80 	ldm	sp++,r7,pc
80002666:	00 00       	add	r0,r0
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	d7 1c       	*unknown*
8000266c:	80 00       	ld.sh	r0,r0[0x0]
8000266e:	72 80       	ld.w	r0,r9[0x20]
80002670:	80 00       	ld.sh	r0,r0[0x0]
80002672:	d7 30       	acall	0x73
80002674:	80 00       	ld.sh	r0,r0[0x0]
80002676:	d7 44       	*unknown*
80002678:	80 00       	ld.sh	r0,r0[0x0]
8000267a:	d7 5c       	*unknown*

8000267c <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
8000267c:	eb cd 40 80 	pushm	r7,lr
80002680:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
80002682:	19 a9       	ld.ub	r9,r12[0x2]
80002684:	30 08       	mov	r8,0
80002686:	f0 09 18 00 	cp.b	r9,r8
8000268a:	c1 b1       	brne	800026c0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
8000268c:	19 b8       	ld.ub	r8,r12[0x3]
8000268e:	30 19       	mov	r9,1
80002690:	f2 08 18 00 	cp.b	r8,r9
80002694:	c0 51       	brne	8000269e <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
80002696:	48 ec       	lddpc	r12,800026cc <dcm_reply_func+0x50>
80002698:	f0 1f 00 0e 	mcall	800026d0 <dcm_reply_func+0x54>
8000269c:	c0 a8       	rjmp	800026b0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
8000269e:	58 08       	cp.w	r8,0
800026a0:	c0 51       	brne	800026aa <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026a2:	48 dc       	lddpc	r12,800026d4 <dcm_reply_func+0x58>
800026a4:	f0 1f 00 0b 	mcall	800026d0 <dcm_reply_func+0x54>
800026a8:	c0 48       	rjmp	800026b0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026aa:	48 cc       	lddpc	r12,800026d8 <dcm_reply_func+0x5c>
800026ac:	f0 1f 00 09 	mcall	800026d0 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026b0:	0f d8       	ld.ub	r8,r7[0x5]
800026b2:	1a d8       	st.w	--sp,r8
800026b4:	48 ac       	lddpc	r12,800026dc <dcm_reply_func+0x60>
800026b6:	f0 1f 00 07 	mcall	800026d0 <dcm_reply_func+0x54>
800026ba:	2f fd       	sub	sp,-4
800026bc:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026c0:	48 8c       	lddpc	r12,800026e0 <dcm_reply_func+0x64>
800026c2:	f0 1f 00 04 	mcall	800026d0 <dcm_reply_func+0x54>
800026c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026ca:	00 00       	add	r0,r0
800026cc:	80 00       	ld.sh	r0,r0[0x0]
800026ce:	d7 78       	*unknown*
800026d0:	80 00       	ld.sh	r0,r0[0x0]
800026d2:	72 80       	ld.w	r0,r9[0x20]
800026d4:	80 00       	ld.sh	r0,r0[0x0]
800026d6:	d7 8c       	*unknown*
800026d8:	80 00       	ld.sh	r0,r0[0x0]
800026da:	d7 a0       	acall	0x7a
800026dc:	80 00       	ld.sh	r0,r0[0x0]
800026de:	d7 b4       	*unknown*
800026e0:	80 00       	ld.sh	r0,r0[0x0]
800026e2:	d7 c0       	acall	0x7c

800026e4 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
800026e4:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
800026e6:	19 a9       	ld.ub	r9,r12[0x2]
800026e8:	30 08       	mov	r8,0
800026ea:	f0 09 18 00 	cp.b	r9,r8
800026ee:	c0 51       	brne	800026f8 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
800026f0:	48 4c       	lddpc	r12,80002700 <ToneControl_reply_func+0x1c>
800026f2:	f0 1f 00 05 	mcall	80002704 <ToneControl_reply_func+0x20>
800026f6:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
800026f8:	48 4c       	lddpc	r12,80002708 <ToneControl_reply_func+0x24>
800026fa:	f0 1f 00 03 	mcall	80002704 <ToneControl_reply_func+0x20>
800026fe:	d8 02       	popm	pc
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	d7 cc       	*unknown*
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	72 80       	ld.w	r0,r9[0x20]
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	d7 d8       	*unknown*

8000270c <app_cfg>:
extern volatile DateTime_t Current_time;
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000270c:	d4 31       	pushm	r0-r7,lr
8000270e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	
	 xLastWakeTime = xTaskGetTickCount();
80002710:	f0 1f 00 23 	mcall	8000279c <app_cfg+0x90>
80002714:	4a 38       	lddpc	r8,800027a0 <app_cfg+0x94>
80002716:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002718:	4a 36       	lddpc	r6,800027a4 <app_cfg+0x98>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
8000271a:	4a 45       	lddpc	r5,800027a8 <app_cfg+0x9c>
		else
		{
			nop();
			nop();
			nop();
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000271c:	30 62       	mov	r2,6
8000271e:	30 14       	mov	r4,1
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
		{
				if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002720:	4a 31       	lddpc	r1,800027ac <app_cfg+0xa0>
80002722:	30 03       	mov	r3,0
80002724:	e0 67 0f a0 	mov	r7,4000
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002728:	6c 08       	ld.w	r8,r6[0x0]
8000272a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000272e:	58 38       	cp.w	r8,3
80002730:	c0 b1       	brne	80002746 <app_cfg+0x3a>
80002732:	0b 88       	ld.ub	r8,r5[0x0]
80002734:	58 08       	cp.w	r8,0
80002736:	c0 81       	brne	80002746 <app_cfg+0x3a>
		{	
			connect_flag=1;	
80002738:	30 18       	mov	r8,1
8000273a:	aa 88       	st.b	r5[0x0],r8
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000273c:	30 cb       	mov	r11,12
8000273e:	08 9c       	mov	r12,r4
80002740:	f0 1f 00 1c 	mcall	800027b0 <app_cfg+0xa4>
	
	 xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002744:	c2 78       	rjmp	80002792 <app_cfg+0x86>
		{	
			connect_flag=1;	
			xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!

		}
		else if(connect_flag)
80002746:	0b 88       	ld.ub	r8,r5[0x0]
80002748:	58 08       	cp.w	r8,0
8000274a:	c1 d0       	breq	80002784 <app_cfg+0x78>
		{
				if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
8000274c:	62 0c       	ld.w	r12,r1[0x0]
8000274e:	06 99       	mov	r9,r3
80002750:	0e 9a       	mov	r10,r7
80002752:	1a 9b       	mov	r11,sp
80002754:	f0 1f 00 18 	mcall	800027b4 <app_cfg+0xa8>
80002758:	58 1c       	cp.w	r12,1
8000275a:	c1 31       	brne	80002780 <app_cfg+0x74>
				{
					
					//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
					//flashc_memcpy((void *)0x80061234, (void *)test_data, 7,  true);
					set_message_store(data_ptr);
8000275c:	49 78       	lddpc	r8,800027b8 <app_cfg+0xac>
8000275e:	70 0c       	ld.w	r12,r8[0x0]
80002760:	40 0b       	lddsp	r11,sp[0x0]
80002762:	f0 1f 00 17 	mcall	800027bc <app_cfg+0xb0>
					log("receive okay!\n");	
80002766:	49 7c       	lddpc	r12,800027c0 <app_cfg+0xb4>
80002768:	f0 1f 00 17 	mcall	800027c4 <app_cfg+0xb8>
					water_value = uxTaskGetStackHighWaterMark(NULL);
8000276c:	06 9c       	mov	r12,r3
8000276e:	f0 1f 00 17 	mcall	800027c8 <app_cfg+0xbc>
80002772:	49 78       	lddpc	r8,800027cc <app_cfg+0xc0>
80002774:	91 0c       	st.w	r8[0x0],r12
					log("water_value: %d\n", water_value);		
80002776:	1a dc       	st.w	--sp,r12
80002778:	49 6c       	lddpc	r12,800027d0 <app_cfg+0xc4>
8000277a:	f0 1f 00 13 	mcall	800027c4 <app_cfg+0xb8>
8000277e:	2f fd       	sub	sp,-4
				//}
				//else
				//{
					//log("no find card...\n");
				//}
				nop();
80002780:	d7 03       	nop
80002782:	c0 88       	rjmp	80002792 <app_cfg+0x86>
				//Current_time.Hour, Current_time.Minute, Current_time.Second);
				
		}
		else
		{
			nop();
80002784:	d7 03       	nop
			nop();
80002786:	d7 03       	nop
			nop();
80002788:	d7 03       	nop
			xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
8000278a:	04 9b       	mov	r11,r2
8000278c:	08 9c       	mov	r12,r4
8000278e:	f0 1f 00 09 	mcall	800027b0 <app_cfg+0xa4>
			
		//}
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002792:	0e 9b       	mov	r11,r7
80002794:	48 3c       	lddpc	r12,800027a0 <app_cfg+0x94>
80002796:	f0 1f 00 10 	mcall	800027d4 <app_cfg+0xc8>
	}
8000279a:	cc 7b       	rjmp	80002728 <app_cfg+0x1c>
8000279c:	80 00       	ld.sh	r0,r0[0x0]
8000279e:	6b ac       	ld.w	r12,r5[0x68]
800027a0:	00 00       	add	r0,r0
800027a2:	0a 60       	and	r0,r5
800027a4:	00 00       	add	r0,r0
800027a6:	0d f8       	ld.ub	r8,r6[0x7]
800027a8:	00 00       	add	r0,r0
800027aa:	0a 64       	and	r4,r5
800027ac:	00 00       	add	r0,r0
800027ae:	0b 6c       	ld.uh	r12,--r5
800027b0:	80 00       	ld.sh	r0,r0[0x0]
800027b2:	3e b8       	mov	r8,-21
800027b4:	80 00       	ld.sh	r0,r0[0x0]
800027b6:	64 04       	ld.w	r4,r2[0x0]
800027b8:	00 00       	add	r0,r0
800027ba:	0b 78       	ld.ub	r8,--r5
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	2a 64       	sub	r4,-90
800027c0:	80 00       	ld.sh	r0,r0[0x0]
800027c2:	d7 e4       	*unknown*
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	72 80       	ld.w	r0,r9[0x20]
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	68 8c       	ld.w	r12,r4[0x20]
800027cc:	00 00       	add	r0,r0
800027ce:	0a 58       	eor	r8,r5
800027d0:	80 00       	ld.sh	r0,r0[0x0]
800027d2:	d7 f4       	*unknown*
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	6d 5c       	ld.w	r12,r6[0x54]

800027d8 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
800027d8:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
800027dc:	19 c7       	ld.ub	r7,r12[0x4]
800027de:	19 d8       	ld.ub	r8,r12[0x5]
800027e0:	f1 e7 10 87 	or	r7,r8,r7<<0x8
800027e4:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
800027e6:	48 dc       	lddpc	r12,80002818 <Phyuserinput_brdcst_func+0x40>
800027e8:	f0 1f 00 0d 	mcall	8000281c <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
800027ec:	36 08       	mov	r8,96
800027ee:	f0 07 19 00 	cp.h	r7,r8
800027f2:	c1 11       	brne	80002814 <Phyuserinput_brdcst_func+0x3c>
800027f4:	48 b8       	lddpc	r8,80002820 <Phyuserinput_brdcst_func+0x48>
800027f6:	11 89       	ld.ub	r9,r8[0x0]
800027f8:	30 18       	mov	r8,1
800027fa:	f0 09 18 00 	cp.b	r9,r8
800027fe:	c0 b1       	brne	80002814 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
80002800:	31 4b       	mov	r11,20
80002802:	30 1c       	mov	r12,1
80002804:	f0 1f 00 08 	mcall	80002824 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
80002808:	e0 6c 03 20 	mov	r12,800
8000280c:	f0 1f 00 07 	mcall	80002828 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
80002810:	f0 1f 00 07 	mcall	8000282c <Phyuserinput_brdcst_func+0x54>
80002814:	e3 cd 80 80 	ldm	sp++,r7,pc
80002818:	80 00       	ld.sh	r0,r0[0x0]
8000281a:	d8 08       	*unknown*
8000281c:	80 00       	ld.sh	r0,r0[0x0]
8000281e:	72 80       	ld.w	r0,r9[0x20]
80002820:	00 00       	add	r0,r0
80002822:	0a 64       	and	r4,r5
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	3e b8       	mov	r8,-21
80002828:	80 00       	ld.sh	r0,r0[0x0]
8000282a:	6d 14       	ld.w	r4,r6[0x44]
8000282c:	80 00       	ld.sh	r0,r0[0x0]
8000282e:	4e 8c       	lddpc	r12,800029cc <CalculateBurst+0x4>

80002830 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
80002830:	d4 31       	pushm	r0-r7,lr
80002832:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
80002834:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
80002838:	0d 88       	ld.ub	r8,r6[0x0]
8000283a:	32 49       	mov	r9,36
8000283c:	f2 08 18 00 	cp.b	r8,r9
80002840:	c2 91       	brne	80002892 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
80002842:	4c 4c       	lddpc	r12,80002950 <DataSession_brdcst_func+0x120>
80002844:	f0 1f 00 44 	mcall	80002954 <DataSession_brdcst_func+0x124>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002848:	0d a5       	ld.ub	r5,r6[0x2]
8000284a:	0d b8       	ld.ub	r8,r6[0x3]
8000284c:	f1 e5 10 85 	or	r5,r8,r5<<0x8
80002850:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
80002852:	0d 98       	ld.ub	r8,r6[0x1]
80002854:	1a d8       	st.w	--sp,r8
80002856:	4c 1c       	lddpc	r12,80002958 <DataSession_brdcst_func+0x128>
80002858:	f0 1f 00 3f 	mcall	80002954 <DataSession_brdcst_func+0x124>
		log("\n\r paylaod_length: %d \n\r",data_length );
8000285c:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002860:	1a d8       	st.w	--sp,r8
80002862:	4b fc       	lddpc	r12,8000295c <DataSession_brdcst_func+0x12c>
80002864:	f0 1f 00 3c 	mcall	80002954 <DataSession_brdcst_func+0x124>
		for(i=0; i<data_length; i++)
80002868:	2f ed       	sub	sp,-8
8000286a:	58 05       	cp.w	r5,0
8000286c:	c7 00       	breq	8000294c <DataSession_brdcst_func+0x11c>
8000286e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002870:	4b c4       	lddpc	r4,80002960 <DataSession_brdcst_func+0x130>
80002872:	ec 07 00 08 	add	r8,r6,r7
80002876:	11 c8       	ld.ub	r8,r8[0x4]
80002878:	1a d8       	st.w	--sp,r8
8000287a:	1a d7       	st.w	--sp,r7
8000287c:	08 9c       	mov	r12,r4
8000287e:	f0 1f 00 36 	mcall	80002954 <DataSession_brdcst_func+0x124>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002882:	2f f7       	sub	r7,-1
80002884:	5c 57       	castu.b	r7
80002886:	2f ed       	sub	sp,-8
80002888:	ee 05 19 00 	cp.h	r5,r7
8000288c:	fe 9b ff f3 	brhi	80002872 <DataSession_brdcst_func+0x42>
80002890:	c5 e8       	rjmp	8000294c <DataSession_brdcst_func+0x11c>
	}
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
80002892:	0d a7       	ld.ub	r7,r6[0x2]
80002894:	0d b5       	ld.ub	r5,r6[0x3]
		log("State: %X \n", ptr->State);
80002896:	1a d8       	st.w	--sp,r8
80002898:	4b 3c       	lddpc	r12,80002964 <DataSession_brdcst_func+0x134>
8000289a:	f0 1f 00 2f 	mcall	80002954 <DataSession_brdcst_func+0x124>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000289e:	0d 88       	ld.ub	r8,r6[0x0]
800028a0:	2f fd       	sub	sp,-4
800028a2:	30 39       	mov	r9,3
800028a4:	f2 08 18 00 	cp.b	r8,r9
800028a8:	c0 51       	brne	800028b2 <DataSession_brdcst_func+0x82>
		{
			log("data transmit success\n");
800028aa:	4b 0c       	lddpc	r12,80002968 <DataSession_brdcst_func+0x138>
800028ac:	f0 1f 00 2a 	mcall	80002954 <DataSession_brdcst_func+0x124>
800028b0:	c4 78       	rjmp	8000293e <DataSession_brdcst_func+0x10e>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
800028b2:	30 49       	mov	r9,4
800028b4:	f2 08 18 00 	cp.b	r8,r9
800028b8:	c4 31       	brne	8000293e <DataSession_brdcst_func+0x10e>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
800028ba:	32 0a       	mov	r10,32
800028bc:	ec cb ff fc 	sub	r11,r6,-4
800028c0:	1a 9c       	mov	r12,sp
800028c2:	f0 1f 00 2b 	mcall	8000296c <DataSession_brdcst_func+0x13c>
800028c6:	fb 36 00 1f 	ld.ub	r6,sp[31]
800028ca:	fb 34 00 1e 	ld.ub	r4,sp[30]
800028ce:	fb 33 00 1d 	ld.ub	r3,sp[29]
800028d2:	fb 32 00 1c 	ld.ub	r2,sp[28]
800028d6:	fb 31 00 1b 	ld.ub	r1,sp[27]
800028da:	fb 30 00 1a 	ld.ub	r0,sp[26]
			log("data transmit failure\n");
800028de:	4a 5c       	lddpc	r12,80002970 <DataSession_brdcst_func+0x140>
800028e0:	f0 1f 00 1d 	mcall	80002954 <DataSession_brdcst_func+0x124>
			log("xgmessage.XG_Time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800028e4:	1a d6       	st.w	--sp,r6
800028e6:	1a d4       	st.w	--sp,r4
800028e8:	1a d3       	st.w	--sp,r3
800028ea:	1a d2       	st.w	--sp,r2
800028ec:	1a d1       	st.w	--sp,r1
800028ee:	1a d0       	st.w	--sp,r0
800028f0:	4a 1c       	lddpc	r12,80002974 <DataSession_brdcst_func+0x144>
800028f2:	f0 1f 00 19 	mcall	80002954 <DataSession_brdcst_func+0x124>
			xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
800028f6:	4a 18       	lddpc	r8,80002978 <DataSession_brdcst_func+0x148>
800028f8:	70 0c       	ld.w	r12,r8[0x0]
800028fa:	f0 1f 00 21 	mcall	8000297c <DataSession_brdcst_func+0x14c>
800028fe:	50 ec       	stdsp	sp[0x38],r12
			if(NULL != myptr)
80002900:	2f ad       	sub	sp,-24
80002902:	58 0c       	cp.w	r12,0
80002904:	c1 a0       	breq	80002938 <DataSession_brdcst_func+0x108>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
80002906:	fb 66 00 1f 	st.b	sp[31],r6
8000290a:	fb 64 00 1e 	st.b	sp[30],r4
8000290e:	fb 63 00 1d 	st.b	sp[29],r3
80002912:	fb 62 00 1c 	st.b	sp[28],r2
80002916:	fb 61 00 1b 	st.b	sp[27],r1
8000291a:	fb 60 00 1a 	st.b	sp[26],r0
8000291e:	32 0a       	mov	r10,32
80002920:	1a 9b       	mov	r11,sp
80002922:	f0 1f 00 13 	mcall	8000296c <DataSession_brdcst_func+0x13c>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002926:	49 78       	lddpc	r8,80002980 <DataSession_brdcst_func+0x150>
80002928:	70 0c       	ld.w	r12,r8[0x0]
8000292a:	30 09       	mov	r9,0
8000292c:	12 9a       	mov	r10,r9
8000292e:	fa cb ff e0 	sub	r11,sp,-32
80002932:	f0 1f 00 15 	mcall	80002984 <DataSession_brdcst_func+0x154>
80002936:	c0 48       	rjmp	8000293e <DataSession_brdcst_func+0x10e>
			}
			else
			{
				log("myptr: err\n\r" );
80002938:	49 4c       	lddpc	r12,80002988 <DataSession_brdcst_func+0x158>
8000293a:	f0 1f 00 07 	mcall	80002954 <DataSession_brdcst_func+0x124>
			}
			//xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate send-failure!!!
		}
		//log("Session_ID: %x \n\r",Session_number );
		log("paylaod_length: %d \n\r",data_length );
8000293e:	eb e7 10 87 	or	r7,r5,r7<<0x8
80002942:	1a d7       	st.w	--sp,r7
80002944:	49 2c       	lddpc	r12,8000298c <DataSession_brdcst_func+0x15c>
80002946:	f0 1f 00 04 	mcall	80002954 <DataSession_brdcst_func+0x124>
8000294a:	2f fd       	sub	sp,-4
				//
		//}
		
	}
	
}
8000294c:	2f 7d       	sub	sp,-36
8000294e:	d8 32       	popm	r0-r7,pc
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	d8 28       	*unknown*
80002954:	80 00       	ld.sh	r0,r0[0x0]
80002956:	72 80       	ld.w	r0,r9[0x20]
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	d8 3c       	*unknown*
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	d8 54       	*unknown*
80002960:	80 00       	ld.sh	r0,r0[0x0]
80002962:	d8 70       	acall	0x87
80002964:	80 00       	ld.sh	r0,r0[0x0]
80002966:	d8 88       	*unknown*
80002968:	80 00       	ld.sh	r0,r0[0x0]
8000296a:	d8 94       	*unknown*
8000296c:	80 00       	ld.sh	r0,r0[0x0]
8000296e:	7b 22       	ld.w	r2,sp[0x48]
80002970:	80 00       	ld.sh	r0,r0[0x0]
80002972:	d8 ac       	*unknown*
80002974:	80 00       	ld.sh	r0,r0[0x0]
80002976:	d8 c4       	*unknown*
80002978:	00 00       	add	r0,r0
8000297a:	0b 78       	ld.ub	r8,--r5
8000297c:	80 00       	ld.sh	r0,r0[0x0]
8000297e:	2c 10       	sub	r0,-63
80002980:	00 00       	add	r0,r0
80002982:	0b 6c       	ld.uh	r12,--r5
80002984:	80 00       	ld.sh	r0,r0[0x0]
80002986:	66 10       	ld.w	r0,r3[0x4]
80002988:	80 00       	ld.sh	r0,r0[0x0]
8000298a:	d8 f8       	*unknown*
8000298c:	80 00       	ld.sh	r0,r0[0x0]
8000298e:	d9 08       	*unknown*

80002990 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
80002990:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
80002992:	19 e8       	ld.ub	r8,r12[0x6]
80002994:	30 19       	mov	r9,1
80002996:	f2 08 18 00 	cp.b	r8,r9
8000299a:	c0 61       	brne	800029a6 <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
8000299c:	48 98       	lddpc	r8,800029c0 <DeviceInitializationStatus_brdcst_func+0x30>
8000299e:	70 09       	ld.w	r9,r8[0x0]
800029a0:	a1 a9       	sbr	r9,0x0
800029a2:	91 09       	st.w	r8[0x0],r9
800029a4:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029a6:	30 29       	mov	r9,2
800029a8:	f2 08 18 00 	cp.b	r8,r9
800029ac:	c0 80       	breq	800029bc <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029ae:	48 58       	lddpc	r8,800029c0 <DeviceInitializationStatus_brdcst_func+0x30>
800029b0:	70 09       	ld.w	r9,r8[0x0]
800029b2:	e0 19 ff fc 	andl	r9,0xfffc
800029b6:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029b8:	f0 1f 00 03 	mcall	800029c4 <DeviceInitializationStatus_brdcst_func+0x34>
800029bc:	d8 02       	popm	pc
800029be:	00 00       	add	r0,r0
800029c0:	00 00       	add	r0,r0
800029c2:	0d f8       	ld.ub	r8,r6[0x7]
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	3e 0c       	mov	r12,-32

800029c8 <CalculateBurst>:
Calls:
Called By: phy_payload_rx
*/

volatile RxAMBEBurstType CalculateBurst(U8 vf_sn)
{
800029c8:	20 1c       	sub	r12,1
800029ca:	5c 5c       	castu.b	r12
800029cc:	31 18       	mov	r8,17
800029ce:	f0 0c 18 00 	cp.b	r12,r8
800029d2:	e0 88 00 03 	brls	800029d8 <CalculateBurst+0x10>
800029d6:	5e fd       	retal	0
800029d8:	48 28       	lddpc	r8,800029e0 <CalculateBurst+0x18>
800029da:	f0 0c 03 2c 	ld.w	r12,r8[r12<<0x2]
			Burst_ID = 0x00;
			return VOICE_WATING;
		
	}
	
}
800029de:	5e fc       	retal	r12
800029e0:	80 00       	ld.sh	r0,r0[0x0]
800029e2:	d9 20       	acall	0x92

800029e4 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
800029e4:	48 38       	lddpc	r8,800029f0 <payload_init+0xc>
800029e6:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800029e8:	48 38       	lddpc	r8,800029f4 <payload_init+0x10>
800029ea:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
800029ec:	5e fc       	retal	r12
800029ee:	00 00       	add	r0,r0
800029f0:	00 00       	add	r0,r0
800029f2:	0a 74       	tst	r4,r5
800029f4:	00 00       	add	r0,r0
800029f6:	0a 78       	tst	r8,r5

800029f8 <set_idle_store_isr>:
{
	xQueueSend(store, &ptr, 0);
}

void set_idle_store_isr(xQueueHandle store, void * ptr)
{
800029f8:	d4 01       	pushm	lr
800029fa:	20 2d       	sub	sp,8
800029fc:	50 0b       	stdsp	sp[0x0],r11
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
800029fe:	30 09       	mov	r9,0
80002a00:	fa ca ff f8 	sub	r10,sp,-8
80002a04:	14 d9       	st.w	--r10,r9
	xQueueSendFromISR(store, &ptr, &xHigherPriorityTaskWoken);
80002a06:	1a 9b       	mov	r11,sp
80002a08:	f0 1f 00 02 	mcall	80002a10 <set_idle_store_isr+0x18>
}
80002a0c:	2f ed       	sub	sp,-8
80002a0e:	d8 02       	popm	pc
80002a10:	80 00       	ld.sh	r0,r0[0x0]
80002a12:	65 c0       	ld.w	r0,r2[0x70]

80002a14 <payload_rx>:
		//logFromISR("ss");
	}
}

static void payload_rx(void * payload)
{
80002a14:	d4 01       	pushm	lr
    set_payload_idle_isr(payload);
80002a16:	48 48       	lddpc	r8,80002a24 <payload_rx+0x10>
80002a18:	70 08       	ld.w	r8,r8[0x0]
80002a1a:	18 9b       	mov	r11,r12
80002a1c:	10 9c       	mov	r12,r8
80002a1e:	f0 1f 00 03 	mcall	80002a28 <payload_rx+0x14>
	else
	{
		//logFromISR("ss");
	}
	#endif
}
80002a22:	d8 02       	popm	pc
80002a24:	00 00       	add	r0,r0
80002a26:	0a b0       	st.h	r5++,r0
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	29 f8       	sub	r8,-97

80002a2c <phy_rx>:
	xQueueSendFromISR -- freertos
Called By: phy_xnl_rx
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
80002a2c:	d4 01       	pushm	lr
80002a2e:	20 2d       	sub	sp,8
80002a30:	50 0c       	stdsp	sp[0x0],r12
	//memcpy(xx, phy_ptr, sizeof(phy_fragment_t));
	//set_phy_idle_isr(&phy_ptr, &xHigherPriorityTaskWoken);
	
	Bool res = FALSE;
	
	if(NULL == phy_ptr)
80002a32:	58 0c       	cp.w	r12,0
80002a34:	c1 10       	breq	80002a56 <phy_rx+0x2a>
    phy_payload_rx
*/
void phy_rx(phy_fragment_t * phy_ptr)
{
    /*variables are used to store the push result in interrupt*/
    portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002a36:	30 08       	mov	r8,0
80002a38:	50 18       	stdsp	sp[0x4],r8
	if(NULL == phy_ptr)
	{
		return;
	}
	
    U16 phy_ctrl = phy_ptr->xnl_fragment.phy_header.phy_control;
80002a3a:	98 88       	ld.uh	r8,r12[0x0]
80002a3c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a40:	e0 48 40 00 	cp.w	r8,16384
80002a44:	c0 91       	brne	80002a56 <phy_rx+0x2a>

    if (XCMPXNL_DATA == (phy_ctrl & 0xF000))
    {
        /*push the xnl packet to queue*/
        if( pdTRUE == xQueueSendFromISR(
80002a46:	48 68       	lddpc	r8,80002a5c <phy_rx+0x30>
80002a48:	70 0c       	ld.w	r12,r8[0x0]
80002a4a:	30 09       	mov	r9,0
80002a4c:	fa ca ff fc 	sub	r10,sp,-4
80002a50:	1a 9b       	mov	r11,sp
80002a52:	f0 1f 00 04 	mcall	80002a60 <phy_rx+0x34>
		}	

    }
		
 
}
80002a56:	2f ed       	sub	sp,-8
80002a58:	d8 02       	popm	pc
80002a5a:	00 00       	add	r0,r0
80002a5c:	00 00       	add	r0,r0
80002a5e:	0a bc       	st.h	r5++,r12
80002a60:	80 00       	ld.sh	r0,r0[0x0]
80002a62:	65 c0       	ld.w	r0,r2[0x70]

80002a64 <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
80002a64:	eb cd 40 80 	pushm	r7,lr
80002a68:	20 1d       	sub	sp,4
80002a6a:	fa c7 ff fc 	sub	r7,sp,-4
80002a6e:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
80002a70:	30 09       	mov	r9,0
80002a72:	12 9a       	mov	r10,r9
80002a74:	1a 9b       	mov	r11,sp
80002a76:	f0 1f 00 03 	mcall	80002a80 <set_idle_store+0x1c>
}
80002a7a:	2f fd       	sub	sp,-4
80002a7c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	66 10       	ld.w	r0,r3[0x4]

80002a84 <phy_tx>:
Calls:   
	xQueueSend -- freertos
Called By: xnl_tx -- xnl.c
*/
void phy_tx(phy_fragment_t * phy)
{	
80002a84:	d4 01       	pushm	lr
80002a86:	20 1d       	sub	sp,4
80002a88:	50 0c       	stdsp	sp[0x0],r12
	
	//phy_fragment_t * phy_ptr = malloc(sizeof(phy_fragment_t));
	//memcpy(phy_ptr, phy, sizeof(phy_fragment_t));
	//log("\n\r T_xcmp:%4x \n\r", phy->xnl_fragment.xnl_payload.xnl_content_data_msg.xcmp_opcode);
	//log("T_xnl-opcode:%4x", xnl->xnl_header.opcode);//log:R_xnl指令	
	if(XCMPXNL_DATA == (phy_ctrl & 0xF000))
80002a8a:	98 88       	ld.uh	r8,r12[0x0]
80002a8c:	e2 18 f0 00 	andl	r8,0xf000,COH
80002a90:	e0 48 40 00 	cp.w	r8,16384
80002a94:	c0 d1       	brne	80002aae <phy_tx+0x2a>
	{
		/*push the xnl packet to queue to send */
		if(NULL != phy_xnl_frame_tx)
80002a96:	49 08       	lddpc	r8,80002ad4 <phy_tx+0x50>
80002a98:	70 08       	ld.w	r8,r8[0x0]
80002a9a:	58 08       	cp.w	r8,0
80002a9c:	c1 a0       	breq	80002ad0 <phy_tx+0x4c>
		{
			if( pdTRUE == xQueueSend(phy_xnl_frame_tx, &phy, 0))
80002a9e:	48 e8       	lddpc	r8,80002ad4 <phy_tx+0x50>
80002aa0:	70 0c       	ld.w	r12,r8[0x0]
80002aa2:	30 09       	mov	r9,0
80002aa4:	12 9a       	mov	r10,r9
80002aa6:	1a 9b       	mov	r11,sp
80002aa8:	f0 1f 00 0c 	mcall	80002ad8 <phy_tx+0x54>
80002aac:	c1 28       	rjmp	80002ad0 <phy_tx+0x4c>
		}
	}
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE		
	else if((SPEAKER_DATA == (phy_ctrl & 0xF000))
80002aae:	e0 48 10 00 	cp.w	r8,4096
80002ab2:	5f 0a       	sreq	r10
80002ab4:	e0 48 20 00 	cp.w	r8,8192
80002ab8:	5f 09       	sreq	r9
80002aba:	f5 e9 10 09 	or	r9,r10,r9
80002abe:	c0 71       	brne	80002acc <phy_tx+0x48>
80002ac0:	e0 48 50 00 	cp.w	r8,20480
80002ac4:	c0 40       	breq	80002acc <phy_tx+0x48>
80002ac6:	e0 48 60 00 	cp.w	r8,24576
80002aca:	c0 31       	brne	80002ad0 <phy_tx+0x4c>
	    || (MIC_DATA  == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_RX == (phy_ctrl & 0xF000))
	    || (PAYLOAD_DATA_TX == (phy_ctrl & 0xF000))
	)
	{		
		if(NULL == phy_payload_frame_tx)
80002acc:	48 48       	lddpc	r8,80002adc <phy_tx+0x58>
80002ace:	70 08       	ld.w	r8,r8[0x0]
	
	if(res != TRUE)
	{
		//vPortFree(phy_ptr);
	}
}
80002ad0:	2f fd       	sub	sp,-4
80002ad2:	d8 02       	popm	pc
80002ad4:	00 00       	add	r0,r0
80002ad6:	0a dc       	st.w	--r5,r12
80002ad8:	80 00       	ld.sh	r0,r0[0x0]
80002ada:	66 10       	ld.w	r0,r3[0x4]
80002adc:	00 00       	add	r0,r0
80002ade:	0a d0       	st.w	--r5,r0

80002ae0 <get_idle_store_isr>:
		return NULL;
	}
}

void * get_idle_store_isr(xQueueHandle store)
{
80002ae0:	d4 01       	pushm	lr
80002ae2:	20 2d       	sub	sp,8
	void * ptr = NULL;
80002ae4:	30 08       	mov	r8,0
80002ae6:	50 18       	stdsp	sp[0x4],r8
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002ae8:	50 08       	stdsp	sp[0x0],r8
	
	if(pdTRUE == xQueueReceiveFromISR(store, &ptr, &xHigherPriorityTaskWoken))
80002aea:	1a 9a       	mov	r10,sp
80002aec:	fa cb ff fc 	sub	r11,sp,-4
80002af0:	f0 1f 00 05 	mcall	80002b04 <get_idle_store_isr+0x24>
80002af4:	58 1c       	cp.w	r12,1
80002af6:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002afa:	fb fc 00 01 	ld.weq	r12,sp[0x4]
	}
	else
	{
		return NULL;
	}
}
80002afe:	2f ed       	sub	sp,-8
80002b00:	d8 02       	popm	pc
80002b02:	00 00       	add	r0,r0
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	63 14       	ld.w	r4,r1[0x44]

80002b08 <phy_tx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_tx_func( void * ssc)
{
80002b08:	eb cd 40 c0 	pushm	r6-r7,lr
80002b0c:	20 1d       	sub	sp,4
80002b0e:	18 97       	mov	r7,r12
    if(NULL != phy_xnl_frame_tx)
80002b10:	4b a8       	lddpc	r8,80002bf8 <phy_tx_func+0xf0>
80002b12:	70 08       	ld.w	r8,r8[0x0]
80002b14:	58 08       	cp.w	r8,0
80002b16:	c6 60       	breq	80002be2 <phy_tx_func+0xda>
    {
  	  	/*send ssc data in xnl frame*/
  	  	phy_xnl_tx(&(((ssc_fragment_t * )ssc)->xnl_channel));		
80002b18:	18 96       	mov	r6,r12
Called By:phy_tx_func
*/
static void phy_xnl_tx(xnl_channel_t * xnl_tx_channel)
{
	/*variables are used to store the push result in interrupt*/
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80002b1a:	30 08       	mov	r8,0
80002b1c:	50 08       	stdsp	sp[0x0],r8
	
	static S16 phy_tx_expexted_length = 0;
	static U8 phy_tx_index = 0;
	
	/*his is the code for handling any outgoing XNL Phy message*/
	switch(phy_tx_state)
80002b1e:	4b 88       	lddpc	r8,80002bfc <phy_tx_func+0xf4>
80002b20:	70 08       	ld.w	r8,r8[0x0]
80002b22:	58 18       	cp.w	r8,1
80002b24:	c2 60       	breq	80002b70 <phy_tx_func+0x68>
80002b26:	c0 43       	brcs	80002b2e <phy_tx_func+0x26>
80002b28:	58 28       	cp.w	r8,2
80002b2a:	c5 c1       	brne	80002be2 <phy_tx_func+0xda>
80002b2c:	c5 58       	rjmp	80002bd6 <phy_tx_func+0xce>
	{
		/*Waiting for the send xnl packet*/
		case WAITING_FOR_PHY_TX:			
			if( pdTRUE == xQueueReceiveFromISR(
80002b2e:	4b 38       	lddpc	r8,80002bf8 <phy_tx_func+0xf0>
80002b30:	70 0c       	ld.w	r12,r8[0x0]
80002b32:	1a 9a       	mov	r10,sp
80002b34:	4b 3b       	lddpc	r11,80002c00 <phy_tx_func+0xf8>
80002b36:	f0 1f 00 34 	mcall	80002c04 <phy_tx_func+0xfc>
80002b3a:	58 1c       	cp.w	r12,1
80002b3c:	c1 41       	brne	80002b64 <phy_tx_func+0x5c>
				  phy_xnl_frame_tx
				, &phy_ptr
				, &xHigherPriorityTaskWoken 
			))
			{								
				phy_tx_expexted_length = 
80002b3e:	4b 18       	lddpc	r8,80002c00 <phy_tx_func+0xf8>
80002b40:	70 08       	ld.w	r8,r8[0x0]
80002b42:	90 08       	ld.sh	r8,r8[0x0]
80002b44:	10 9a       	mov	r10,r8
80002b46:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80002b4a:	4b 09       	lddpc	r9,80002c08 <phy_tx_func+0x100>
80002b4c:	b2 0a       	st.h	r9[0x0],r10
				*/
				xnl_tx_channel->dword = 
				                   phy_ptr->xnl_fragment.phy_header.phy_control;
				
				/*Transmit 0xABCD0000 | Type/Length.*/
				xnl_tx_channel->dword |= PHYHEADER32;
80002b4e:	5c 78       	castu.h	r8
80002b50:	ea 18 ab cd 	orh	r8,0xabcd
80002b54:	8f 18       	st.w	r7[0x4],r8
				
				phy_tx_index = 1;
80002b56:	30 19       	mov	r9,1
80002b58:	4a d8       	lddpc	r8,80002c0c <phy_tx_func+0x104>
80002b5a:	b0 89       	st.b	r8[0x0],r9
				phy_tx_state = WRITE_NEXT_DWORD;	
80002b5c:	30 19       	mov	r9,1
80002b5e:	4a 88       	lddpc	r8,80002bfc <phy_tx_func+0xf4>
80002b60:	91 09       	st.w	r8[0x0],r9
80002b62:	c4 08       	rjmp	80002be2 <phy_tx_func+0xda>
				/*The new transmission has started.*/
			}
			else
			{
				/*Nothing new to transmit, send an idle frame*/
				xnl_tx_channel->dword = XNL_IDLE;
80002b64:	e0 68 5a 5a 	mov	r8,23130
80002b68:	ea 18 ab cd 	orh	r8,0xabcd
80002b6c:	8f 18       	st.w	r7[0x4],r8
80002b6e:	c3 a8       	rjmp	80002be2 <phy_tx_func+0xda>
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b70:	4a 7a       	lddpc	r10,80002c0c <phy_tx_func+0x104>
80002b72:	15 88       	ld.ub	r8,r10[0x0]
				xnl_tx_channel->dword = XNL_IDLE;
			}			
			break;
		
		case WRITE_NEXT_DWORD:
			xnl_tx_channel->dword = 
80002b74:	4a 39       	lddpc	r9,80002c00 <phy_tx_func+0xf8>
80002b76:	72 09       	ld.w	r9,r9[0x0]
80002b78:	f2 08 05 19 	ld.uh	r9,r9[r8<<0x1]
80002b7c:	b1 69       	lsl	r9,0x10
80002b7e:	99 19       	st.w	r12[0x4],r9
							    phy_ptr->fragment_element[phy_tx_index++] << 16;
80002b80:	2f f8       	sub	r8,-1
80002b82:	5c 58       	castu.b	r8
80002b84:	b4 88       	st.b	r10[0x0],r8

			phy_tx_expexted_length -= 2;
80002b86:	4a 1b       	lddpc	r11,80002c08 <phy_tx_func+0x100>
80002b88:	96 0c       	ld.sh	r12,r11[0x0]
80002b8a:	20 2c       	sub	r12,2
80002b8c:	5c 8c       	casts.h	r12
80002b8e:	f5 dc b0 10 	bfexts	r10,r12,0x0,0x10
80002b92:	b6 0a       	st.h	r11[0x0],r10
			
			/*have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002b94:	30 0b       	mov	r11,0
80002b96:	f6 0a 19 00 	cp.h	r10,r11
80002b9a:	e0 89 00 09 	brgt	80002bac <phy_tx_func+0xa4>
			{
				/*Must immediately send 0x00BA in Slot 4.*/
				xnl_tx_channel->dword |= PHYTERMRIGHT;
80002b9e:	e8 19 00 ba 	orl	r9,0xba
80002ba2:	8f 19       	st.w	r7[0x4],r9
				
				/*Go back to waiting.*/
				phy_tx_state = WAITING_FOR_PHY_TX;
80002ba4:	30 09       	mov	r9,0
80002ba6:	49 68       	lddpc	r8,80002bfc <phy_tx_func+0xf4>
80002ba8:	91 09       	st.w	r8[0x0],r9
80002baa:	c1 c8       	rjmp	80002be2 <phy_tx_func+0xda>
				break;
			}

			/*Have not broken. Transmit 2nd hWord.*/
			xnl_tx_channel->dword |=  phy_ptr->fragment_element[phy_tx_index++];
80002bac:	49 5a       	lddpc	r10,80002c00 <phy_tx_func+0xf8>
80002bae:	74 0a       	ld.w	r10,r10[0x0]
80002bb0:	f4 08 05 1a 	ld.uh	r10,r10[r8<<0x1]
80002bb4:	14 49       	or	r9,r10
80002bb6:	8f 19       	st.w	r7[0x4],r9
80002bb8:	2f f8       	sub	r8,-1
80002bba:	49 59       	lddpc	r9,80002c0c <phy_tx_func+0x104>
80002bbc:	b2 88       	st.b	r9[0x0],r8

			phy_tx_expexted_length -= 2;
80002bbe:	20 2c       	sub	r12,2
80002bc0:	49 28       	lddpc	r8,80002c08 <phy_tx_func+0x100>
80002bc2:	b0 0c       	st.h	r8[0x0],r12
			
			/*Have written all the bytes (including 16-bit pad)*/
			if (phy_tx_expexted_length <= 0)
80002bc4:	30 08       	mov	r8,0
80002bc6:	f0 0c 19 00 	cp.h	r12,r8
80002bca:	e0 89 00 0c 	brgt	80002be2 <phy_tx_func+0xda>
			{
				/*Must send 0x00BA0000 next interrupt in Slot 3&4*/
				phy_tx_state = SEND_TAILED;
80002bce:	30 29       	mov	r9,2
80002bd0:	48 b8       	lddpc	r8,80002bfc <phy_tx_func+0xf4>
80002bd2:	91 09       	st.w	r8[0x0],r9
80002bd4:	c0 78       	rjmp	80002be2 <phy_tx_func+0xda>
			}
			break;

		case SEND_TAILED:
			/*send 0x00BA0000*/
			xnl_tx_channel->dword = PHYTERMLEFT;
80002bd6:	fc 18 00 ba 	movh	r8,0xba
80002bda:	99 18       	st.w	r12[0x4],r8
			
			/*Go back to waiting.*/		
			phy_tx_state = WAITING_FOR_PHY_TX;		
80002bdc:	30 09       	mov	r9,0
80002bde:	48 88       	lddpc	r8,80002bfc <phy_tx_func+0xf4>
80002be0:	91 09       	st.w	r8[0x0],r9
	//#else
	///*send idle frame*/	
	//((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
	//((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
	//#endif /*end if*/
	((ssc_fragment_t * )ssc)->payload_channel.dword[0] = PAYLOADIDLE0;
80002be2:	e0 68 5a 5a 	mov	r8,23130
80002be6:	ea 18 ab cd 	orh	r8,0xabcd
80002bea:	8f 28       	st.w	r7[0x8],r8
	((ssc_fragment_t * )ssc)->payload_channel.dword[1] = PAYLOADIDLE1;
80002bec:	30 08       	mov	r8,0
80002bee:	8f 38       	st.w	r7[0xc],r8
}
80002bf0:	2f fd       	sub	sp,-4
80002bf2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002bf6:	00 00       	add	r0,r0
80002bf8:	00 00       	add	r0,r0
80002bfa:	0a dc       	st.w	--r5,r12
80002bfc:	00 00       	add	r0,r0
80002bfe:	0a 9c       	mov	r12,r5
80002c00:	00 00       	add	r0,r0
80002c02:	0a a8       	st.w	r5++,r8
80002c04:	80 00       	ld.sh	r0,r0[0x0]
80002c06:	63 14       	ld.w	r4,r1[0x44]
80002c08:	00 00       	add	r0,r0
80002c0a:	0a c4       	st.b	r5++,r4
80002c0c:	00 00       	add	r0,r0
80002c0e:	0a 7c       	tst	r12,r5

80002c10 <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
80002c10:	d4 01       	pushm	lr
80002c12:	20 1d       	sub	sp,4
	void * ptr = NULL;
80002c14:	30 0a       	mov	r10,0
80002c16:	fa cb ff fc 	sub	r11,sp,-4
80002c1a:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
80002c1c:	14 99       	mov	r9,r10
80002c1e:	1a 9b       	mov	r11,sp
80002c20:	f0 1f 00 05 	mcall	80002c34 <get_idle_store+0x24>
80002c24:	58 1c       	cp.w	r12,1
80002c26:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
80002c2a:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
80002c2e:	2f fd       	sub	sp,-4
80002c30:	d8 02       	popm	pc
80002c32:	00 00       	add	r0,r0
80002c34:	80 00       	ld.sh	r0,r0[0x0]
80002c36:	64 04       	ld.w	r4,r2[0x0]

80002c38 <phy_init>:
    register_rx_tx_func -- ssc.c
	xQueueCreate -- freertos
Called By: xnl_init -- xnl.c
*/
void phy_init( void )
{
80002c38:	d4 01       	pushm	lr
    /*register the func to send/receive ssc packet*/
    register_rx_tx_func(phy_rx_func, phy_tx_func);	
80002c3a:	48 5b       	lddpc	r11,80002c4c <phy_init+0x14>
80002c3c:	48 5c       	lddpc	r12,80002c50 <phy_init+0x18>
80002c3e:	f0 1f 00 06 	mcall	80002c54 <phy_init+0x1c>
	
	/*initialize the SSC*/
	ssc_init();
80002c42:	f0 1f 00 06 	mcall	80002c58 <phy_init+0x20>
	
	/*send device_master_query to connect radio*/
	xnl_send_device_master_query();
80002c46:	f0 1f 00 06 	mcall	80002c5c <phy_init+0x24>
	
}
80002c4a:	d8 02       	popm	pc
80002c4c:	80 00       	ld.sh	r0,r0[0x0]
80002c4e:	2b 08       	sub	r8,-80
80002c50:	80 00       	ld.sh	r0,r0[0x0]
80002c52:	2c 60       	sub	r0,-58
80002c54:	80 00       	ld.sh	r0,r0[0x0]
80002c56:	3c a8       	mov	r8,-54
80002c58:	80 00       	ld.sh	r0,r0[0x0]
80002c5a:	3c bc       	mov	r12,-53
80002c5c:	80 00       	ld.sh	r0,r0[0x0]
80002c5e:	46 64       	lddsp	r4,sp[0x198]

80002c60 <phy_rx_func>:
    phy_payload_tx
Called By: phy_xnl_rx
    phy_init(register_rx_tx_func)
*/
static void phy_rx_func( void * ssc)
{    
80002c60:	eb cd 40 e0 	pushm	r5-r7,lr
80002c64:	18 97       	mov	r7,r12
		
	if(NULL != phy_xnl_frame_rx)
80002c66:	fe f8 0e 7a 	ld.w	r8,pc[3706]
80002c6a:	70 08       	ld.w	r8,r8[0x0]
80002c6c:	58 08       	cp.w	r8,0
80002c6e:	e0 80 01 08 	breq	80002e7e <phy_rx_func+0x21e>
	static U16 phy_check_sum = 0;

	static phy_rx_state_t  phy_rx_state = WAITING_FOR_HEADER;
	static U32 phy_rx_count = 0;

	U32 phy_dword = xnl_rx_channel->dword;	
80002c72:	78 16       	ld.w	r6,r12[0x4]

	phy_rx_count++;
80002c74:	fe f8 0e 70 	ld.w	r8,pc[3696]
80002c78:	70 09       	ld.w	r9,r8[0x0]
80002c7a:	2f f9       	sub	r9,-1
80002c7c:	91 09       	st.w	r8[0x0],r9
	
	/*This is the code for parsing the incoming physical message.*/
	switch (phy_rx_state)
80002c7e:	fe f8 0e 6a 	ld.w	r8,pc[3690]
80002c82:	70 08       	ld.w	r8,r8[0x0]
80002c84:	58 18       	cp.w	r8,1
80002c86:	e0 80 00 85 	breq	80002d90 <phy_rx_func+0x130>
80002c8a:	c0 73       	brcs	80002c98 <phy_rx_func+0x38>
80002c8c:	58 28       	cp.w	r8,2
80002c8e:	c5 c0       	breq	80002d46 <phy_rx_func+0xe6>
80002c90:	58 38       	cp.w	r8,3
80002c92:	e0 81 00 f6 	brne	80002e7e <phy_rx_func+0x21e>
80002c96:	cd 58       	rjmp	80002e40 <phy_rx_func+0x1e0>

        /*Waiting for something. Most frequent visit.*/		
		case WAITING_FOR_HEADER:
		
			/*Ignore Idles.*/
			if (0xABCD5A5A == phy_dword)
80002c98:	e0 6a 5a 5a 	mov	r10,23130
80002c9c:	ea 1a ab cd 	orh	r10,0xabcd
80002ca0:	14 36       	cp.w	r6,r10
80002ca2:	e0 80 00 ee 	breq	80002e7e <phy_rx_func+0x21e>
			{
				break;
			}	

			/*Skip until Header.*/		
			if (0xABCD != (phy_dword >> 16))
80002ca6:	ec 08 16 10 	lsr	r8,r6,0x10
80002caa:	e0 48 ab cd 	cp.w	r8,43981
80002cae:	e0 81 00 e8 	brne	80002e7e <phy_rx_func+0x21e>
			{			
				break;
			}
		
			/*Length excluding CSUM.*/
			phy_rx_expexted_length = (phy_dword & 0x000000FF) - 2;
80002cb2:	eb d6 b0 10 	bfexts	r5,r6,0x0,0x10
80002cb6:	f1 d5 c0 08 	bfextu	r8,r5,0x0,0x8
80002cba:	20 28       	sub	r8,2
80002cbc:	fe f9 0e 30 	ld.w	r9,pc[3632]
80002cc0:	b2 08       	st.h	r9[0x0],r8
			
			/*Discard degenerate message.*/
			if (phy_rx_expexted_length <= 0)
80002cc2:	30 09       	mov	r9,0
80002cc4:	f2 08 19 00 	cp.h	r8,r9
80002cc8:	e0 8a 00 db 	brle	80002e7e <phy_rx_func+0x21e>
			{
				break;
			}
		
			phy_rx_length = 0;
80002ccc:	fe f8 0e 24 	ld.w	r8,pc[3620]
80002cd0:	b0 09       	st.h	r8[0x0],r9

			phy_frame_ptr = get_xnl_idle_isr();
80002cd2:	fe f8 0e 22 	ld.w	r8,pc[3618]
80002cd6:	70 0c       	ld.w	r12,r8[0x0]
80002cd8:	f0 1f 03 88 	mcall	80003af8 <phy_rx_func+0xe98>
80002cdc:	fe f8 0e 20 	ld.w	r8,pc[3616]
80002ce0:	91 0c       	st.w	r8[0x0],r12
			if(NULL == phy_frame_ptr)
80002ce2:	58 0c       	cp.w	r12,0
80002ce4:	e0 80 00 cd 	breq	80002e7e <phy_rx_func+0x21e>
			{
				break;
			}
					
			phy_frame_ptr->fragment_element[phy_rx_length++] = phy_dword;
80002ce8:	fe f8 0e 08 	ld.w	r8,pc[3592]
80002cec:	90 09       	ld.sh	r9,r8[0x0]
80002cee:	f8 09 0a 15 	st.h	r12[r9<<0x1],r5
80002cf2:	2f f9       	sub	r9,-1
80002cf4:	5c 89       	casts.h	r9
			
			/*time stamp*/
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002cf6:	fe fa 0e 06 	ld.w	r10,pc[3590]
80002cfa:	74 0a       	ld.w	r10,r10[0x0]
80002cfc:	fe fb 0d e8 	ld.w	r11,pc[3560]
80002d00:	76 0b       	ld.w	r11,r11[0x0]
80002d02:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
80002d06:	2f f9       	sub	r9,-1
80002d08:	b0 09       	st.h	r8[0x0],r9
													(phy_rx_count) & 0x0000FFFF;
			
			/*This switch tests the fragment type, and adjusts receiver state
			accordingly.*/
			/*Check frag type*/
			switch (phy_dword & 0x00000F00)
80002d0a:	e2 16 0f 00 	andl	r6,0xf00,COH
80002d0e:	e0 46 01 00 	cp.w	r6,256
80002d12:	c0 c0       	breq	80002d2a <phy_rx_func+0xca>
80002d14:	e0 8b 00 05 	brhi	80002d1e <phy_rx_func+0xbe>
80002d18:	58 06       	cp.w	r6,0
80002d1a:	c0 80       	breq	80002d2a <phy_rx_func+0xca>
80002d1c:	c0 c8       	rjmp	80002d34 <phy_rx_func+0xd4>
80002d1e:	e0 46 02 00 	cp.w	r6,512
80002d22:	c0 40       	breq	80002d2a <phy_rx_func+0xca>
80002d24:	e0 46 03 00 	cp.w	r6,768
80002d28:	c0 61       	brne	80002d34 <phy_rx_func+0xd4>
			{
				case SINGLE_FRAGMENT:  //Only Fragment.
				case FIRST_FRAGMENT:   //First of Multi-fragment.
				case MIDDLE_FRAGMENT:  //Continuing Multi-fragment.
				case LAST_FRAGMENT:    //Last Multi-fragment.
					phy_rx_state = WAITING_CHECK_SUM;
80002d2a:	30 29       	mov	r9,2
80002d2c:	fe f8 0d bc 	ld.w	r8,pc[3516]
80002d30:	91 09       	st.w	r8[0x0],r9
80002d32:	ca 68       	rjmp	80002e7e <phy_rx_func+0x21e>
				break;
				default:
					set_xnl_idle_isr(phy_frame_ptr);			
80002d34:	fe f8 0d c0 	ld.w	r8,pc[3520]
80002d38:	70 0c       	ld.w	r12,r8[0x0]
80002d3a:	fe f8 0d c2 	ld.w	r8,pc[3522]
80002d3e:	70 0b       	ld.w	r11,r8[0x0]
80002d40:	f0 1f 03 70 	mcall	80003b00 <phy_rx_func+0xea0>
80002d44:	c9 d8       	rjmp	80002e7e <phy_rx_func+0x21e>
		
			/*Stores CSUM*/
			phy_check_sum  = (phy_dword & 0xFFFF0000) >> 16;
			
			/*sums in first hWord*/
			phy_check_sum += (phy_dword & 0x0000FFFF);		
80002d46:	f5 d6 b0 10 	bfexts	r10,r6,0x0,0x10
80002d4a:	b1 86       	lsr	r6,0x10
80002d4c:	14 06       	add	r6,r10
80002d4e:	fe f8 0d b6 	ld.w	r8,pc[3510]
80002d52:	b0 06       	st.h	r8[0x0],r6
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002d54:	fe f8 0d 9c 	ld.w	r8,pc[3484]
80002d58:	90 09       	ld.sh	r9,r8[0x0]
80002d5a:	fe fb 0d a2 	ld.w	r11,pc[3490]
80002d5e:	76 0b       	ld.w	r11,r11[0x0]
80002d60:	f6 09 0a 1a 	st.h	r11[r9<<0x1],r10
80002d64:	2f f9       	sub	r9,-1
80002d66:	b0 09       	st.h	r8[0x0],r9
														 phy_dword & 0x0000FFFF;
					
			phy_rx_expexted_length -= 2;
80002d68:	fe f9 0d 84 	ld.w	r9,pc[3460]
80002d6c:	92 08       	ld.sh	r8,r9[0x0]
80002d6e:	20 28       	sub	r8,2
80002d70:	b2 08       	st.h	r9[0x0],r8
			
			/*Normal case for greater than one byte payloads.*/
			if (phy_rx_expexted_length > 0)
80002d72:	30 09       	mov	r9,0
80002d74:	f2 08 19 00 	cp.h	r8,r9
80002d78:	e0 8a 00 07 	brle	80002d86 <phy_rx_func+0x126>
			{					  
				phy_rx_state = READING_FRAGMENT;
80002d7c:	30 19       	mov	r9,1
80002d7e:	fe f8 0d 6a 	ld.w	r8,pc[3434]
80002d82:	91 09       	st.w	r8[0x0],r9
80002d84:	c7 d8       	rjmp	80002e7e <phy_rx_func+0x21e>
	    		Note that all segments must align with a 32-bit boundary and
				beginning of each XCMP/XNL payload frame must start on slot 3
				Thus, segments of odd length must append a 0x0000 at the end
				(slot 4) to ensure alignment. [9.1.3]
				*/
				phy_rx_state = WAITING_LAST_TERM;
80002d86:	30 39       	mov	r9,3
80002d88:	fe f8 0d 60 	ld.w	r8,pc[3424]
80002d8c:	91 09       	st.w	r8[0x0],r9
80002d8e:	c7 88       	rjmp	80002e7e <phy_rx_func+0x21e>
			}			
		
			break;

		case READING_FRAGMENT:
			phy_check_sum += (phy_dword & 0xFFFF0000) >> 16;
80002d90:	ec 0a 14 10 	asr	r10,r6,0x10
80002d94:	fe f8 0d 70 	ld.w	r8,pc[3440]
80002d98:	90 09       	ld.sh	r9,r8[0x0]
80002d9a:	14 09       	add	r9,r10
80002d9c:	b0 09       	st.h	r8[0x0],r9
	
			phy_frame_ptr->fragment_element[phy_rx_length++] = 
80002d9e:	fe f9 0d 52 	ld.w	r9,pc[3410]
80002da2:	92 08       	ld.sh	r8,r9[0x0]
80002da4:	fe fb 0d 58 	ld.w	r11,pc[3416]
80002da8:	76 0b       	ld.w	r11,r11[0x0]
80002daa:	f6 08 0a 1a 	st.h	r11[r8<<0x1],r10
80002dae:	2f f8       	sub	r8,-1
80002db0:	5c 88       	casts.h	r8
80002db2:	b2 08       	st.h	r9[0x0],r8
												 (phy_dword & 0xFFFF0000) >> 16;
	
			phy_rx_expexted_length -= 2;
80002db4:	fe fa 0d 38 	ld.w	r10,pc[3384]
80002db8:	94 09       	ld.sh	r9,r10[0x0]
80002dba:	20 29       	sub	r9,2
80002dbc:	b4 09       	st.h	r10[0x0],r9
			if (phy_rx_expexted_length <= 0)
80002dbe:	30 0a       	mov	r10,0
80002dc0:	f4 09 19 00 	cp.h	r9,r10
80002dc4:	e0 89 00 20 	brgt	80002e04 <phy_rx_func+0x1a4>
				Terminator should be in 2nd hWord.
				Shaoqun says useful bits not used. The packet will always end
				with $00BA. [9.1.2.8]	
				*/
				
				if ((0x000000BA == (phy_dword  & 0x0000FFFF)) 
80002dc8:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
80002dcc:	e0 46 00 ba 	cp.w	r6,186
80002dd0:	c0 d1       	brne	80002dea <phy_rx_func+0x18a>
80002dd2:	fe f8 0d 32 	ld.w	r8,pc[3378]
80002dd6:	90 09       	ld.sh	r9,r8[0x0]
80002dd8:	f4 09 19 00 	cp.h	r9,r10
80002ddc:	c0 71       	brne	80002dea <phy_rx_func+0x18a>
					&& (phy_check_sum == 0))
				{
					phy_rx(phy_frame_ptr);
80002dde:	fe f8 0d 1e 	ld.w	r8,pc[3358]
80002de2:	70 0c       	ld.w	r12,r8[0x0]
80002de4:	f0 1f 03 49 	mcall	80003b08 <phy_rx_func+0xea8>
80002de8:	c0 98       	rjmp	80002dfa <phy_rx_func+0x19a>
				}
				else
				{
					set_xnl_idle_isr(phy_frame_ptr);
80002dea:	fe f8 0d 0a 	ld.w	r8,pc[3338]
80002dee:	70 0c       	ld.w	r12,r8[0x0]
80002df0:	fe f8 0d 0c 	ld.w	r8,pc[3340]
80002df4:	70 0b       	ld.w	r11,r8[0x0]
80002df6:	f0 1f 03 43 	mcall	80003b00 <phy_rx_func+0xea0>
				}

				phy_rx_state = WAITING_FOR_HEADER;
80002dfa:	30 09       	mov	r9,0
80002dfc:	fe f8 0c ec 	ld.w	r8,pc[3308]
80002e00:	91 09       	st.w	r8[0x0],r9
80002e02:	c3 e8       	rjmp	80002e7e <phy_rx_func+0x21e>
				break;
			}
		
			/*Have not broken. 2nd hWord contains payload.*/
			phy_check_sum += (phy_dword & 0x0000FFFF);
80002e04:	5c 86       	casts.h	r6
80002e06:	fe f9 0c fe 	ld.w	r9,pc[3326]
80002e0a:	92 0a       	ld.sh	r10,r9[0x0]
80002e0c:	0c 0a       	add	r10,r6
80002e0e:	b2 0a       	st.h	r9[0x0],r10
		
			phy_frame_ptr->fragment_element[phy_rx_length++] =  
80002e10:	fe f9 0c ec 	ld.w	r9,pc[3308]
80002e14:	72 09       	ld.w	r9,r9[0x0]
80002e16:	f2 08 0a 16 	st.h	r9[r8<<0x1],r6
80002e1a:	2f f8       	sub	r8,-1
80002e1c:	fe f9 0c d4 	ld.w	r9,pc[3284]
80002e20:	b2 08       	st.h	r9[0x0],r8
													   (phy_dword & 0x0000FFFF);
		
			phy_rx_expexted_length -= 2;
80002e22:	fe f9 0c ca 	ld.w	r9,pc[3274]
80002e26:	92 08       	ld.sh	r8,r9[0x0]
80002e28:	20 28       	sub	r8,2
80002e2a:	b2 08       	st.h	r9[0x0],r8
			if (phy_rx_expexted_length <= 0)
80002e2c:	30 09       	mov	r9,0
80002e2e:	f2 08 19 00 	cp.h	r8,r9
80002e32:	e0 89 00 26 	brgt	80002e7e <phy_rx_func+0x21e>
			{
				/*All read in. Next Word should be 0x00BA0000.*/
				phy_rx_state = WAITING_LAST_TERM;
80002e36:	30 39       	mov	r9,3
80002e38:	fe f8 0c b0 	ld.w	r8,pc[3248]
80002e3c:	91 09       	st.w	r8[0x0],r9
80002e3e:	c2 08       	rjmp	80002e7e <phy_rx_func+0x21e>
			}/*else, next Word contains more payload.*/
			break;

		/*Expecting last terminator 0x00BA0000.*/	
		case WAITING_LAST_TERM:			
			if ((0x00BA0000 == (phy_dword  & 0x00FF0000)) /*Expected found.*/
80002e40:	e6 16 00 ff 	andh	r6,0xff,COH
80002e44:	fc 19 00 ba 	movh	r9,0xba
80002e48:	12 36       	cp.w	r6,r9
80002e4a:	c0 e1       	brne	80002e66 <phy_rx_func+0x206>
80002e4c:	fe f8 0c b8 	ld.w	r8,pc[3256]
80002e50:	90 09       	ld.sh	r9,r8[0x0]
80002e52:	30 08       	mov	r8,0
80002e54:	f0 09 19 00 	cp.h	r9,r8
80002e58:	c0 71       	brne	80002e66 <phy_rx_func+0x206>
				&& (phy_check_sum == 0))/*Good checksum*/
			{
				phy_rx(phy_frame_ptr);
80002e5a:	fe f8 0c a2 	ld.w	r8,pc[3234]
80002e5e:	70 0c       	ld.w	r12,r8[0x0]
80002e60:	f0 1f 03 2a 	mcall	80003b08 <phy_rx_func+0xea8>
80002e64:	c0 98       	rjmp	80002e76 <phy_rx_func+0x216>

			}
			else
			{
				set_xnl_idle_isr(phy_frame_ptr);
80002e66:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e6a:	70 0c       	ld.w	r12,r8[0x0]
80002e6c:	fe f8 0c 90 	ld.w	r8,pc[3216]
80002e70:	70 0b       	ld.w	r11,r8[0x0]
80002e72:	f0 1f 03 24 	mcall	80003b00 <phy_rx_func+0xea0>
			}
				
			phy_rx_state = WAITING_FOR_HEADER;
80002e76:	30 09       	mov	r9,0
80002e78:	fe f8 0c 70 	ld.w	r8,pc[3184]
80002e7c:	91 09       	st.w	r8[0x0],r9
	static U8 _flag = 1;//0xABCDC014时，_flag为0；
						//0xABCDC010时，_flag为1；
			
	//payload_ptr_t *AMBE_payload_ptr;		
	
	if(is_first == FALSE)
80002e7e:	fe f8 0c 8e 	ld.w	r8,pc[3214]
80002e82:	11 89       	ld.ub	r9,r8[0x0]
80002e84:	30 08       	mov	r8,0
80002e86:	f0 09 18 00 	cp.b	r9,r8
80002e8a:	c1 31       	brne	80002eb0 <phy_rx_func+0x250>
	{
		payload_ptr = get_payload_idle_isr();
80002e8c:	fe f6 0c 84 	ld.w	r6,pc[3204]
80002e90:	6c 0c       	ld.w	r12,r6[0x0]
80002e92:	f0 1f 03 1a 	mcall	80003af8 <phy_rx_func+0xe98>
80002e96:	fe f8 0c 7e 	ld.w	r8,pc[3198]
80002e9a:	91 0c       	st.w	r8[0x0],r12
		AMBE_payload_ptr = get_payload_idle_isr();
80002e9c:	6c 0c       	ld.w	r12,r6[0x0]
80002e9e:	f0 1f 03 17 	mcall	80003af8 <phy_rx_func+0xe98>
80002ea2:	fe f8 0c 76 	ld.w	r8,pc[3190]
80002ea6:	91 0c       	st.w	r8[0x0],r12
		is_first = TRUE;
80002ea8:	30 19       	mov	r9,1
80002eaa:	fe f8 0c 62 	ld.w	r8,pc[3170]
80002eae:	b0 89       	st.b	r8[0x0],r9
	}	
	
	//This is the RxMedia Phy Handler.
	switch (RxMediaState)
80002eb0:	fe f8 0c 6c 	ld.w	r8,pc[3180]
80002eb4:	70 08       	ld.w	r8,r8[0x0]
80002eb6:	58 28       	cp.w	r8,2
80002eb8:	e0 80 01 98 	breq	800031e8 <phy_rx_func+0x588>
80002ebc:	e0 8b 00 06 	brhi	80002ec8 <phy_rx_func+0x268>
80002ec0:	58 08       	cp.w	r8,0
80002ec2:	c0 b0       	breq	80002ed8 <phy_rx_func+0x278>
80002ec4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002ec8:	58 38       	cp.w	r8,3
80002eca:	e0 80 05 c5 	breq	80003a54 <phy_rx_func+0xdf4>
80002ece:	58 48       	cp.w	r8,4
80002ed0:	e0 81 06 05 	brne	80003ada <phy_rx_func+0xe7a>
80002ed4:	e0 8f 02 4b 	bral	8000336a <phy_rx_func+0x70a>
	{
		case WAITINGABAB:

			
			if (payload_rx_channel->dword[0] == 0xABCD5A5A)//Ignore Idles.
80002ed8:	6e 28       	ld.w	r8,r7[0x8]
80002eda:	e0 6a 5a 5a 	mov	r10,23130
80002ede:	ea 1a ab cd 	orh	r10,0xabcd
80002ee2:	14 38       	cp.w	r8,r10
80002ee4:	c0 71       	brne	80002ef2 <phy_rx_func+0x292>
			{
				m_RxBurstType = VOICE_WATING;
80002ee6:	30 09       	mov	r9,0
80002ee8:	fe f8 0c 38 	ld.w	r8,pc[3128]
80002eec:	91 09       	st.w	r8[0x0],r9
80002eee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				//Upon receiving the idle frame, the m Rx Burst Type into an idle state in order to transmit the synchronization wait
				 break; 
			}
            
			if ((payload_rx_channel->dword[0]  & 0xFFFF0000) != 0xABCD0000)break; //Skip until Header. 
80002ef2:	10 99       	mov	r9,r8
80002ef4:	e0 19 00 00 	andl	r9,0x0
80002ef8:	fc 1a ab cd 	movh	r10,0xabcd
80002efc:	14 39       	cp.w	r9,r10
80002efe:	e0 81 05 ee 	brne	80003ada <phy_rx_func+0xe7a>
			}
			//logFromISR("\n\r P: %X \n\r", payload_rx_channel->word[1]);//测试收到的数据
			
#endif
			
			RxBytesWaiting = payload_rx_channel->dword[0] & 0x000000FF;
80002f02:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80002f06:	fe f9 0c 1e 	ld.w	r9,pc[3102]
80002f0a:	93 08       	st.w	r9[0x0],r8
			/****Note AMBE stream protocol frame structure and the PCM frame structure is different*****/
					
			if ((payload_rx_channel->dword[0] & 0x0000F000 ) == PAYLOAD_DATA_ENH )//PAYLOAD_DATA_ENH (0x0c))
80002f0c:	6e 29       	ld.w	r9,r7[0x8]
80002f0e:	e2 19 f0 00 	andl	r9,0xf000,COH
80002f12:	e0 49 c0 00 	cp.w	r9,49152
80002f16:	e0 81 00 ce 	brne	800030b2 <phy_rx_func+0x452>
			{
				AMBE_Media = 1;	
80002f1a:	30 1a       	mov	r10,1
80002f1c:	fe f9 0c 0c 	ld.w	r9,pc[3084]
80002f20:	b2 8a       	st.b	r9[0x0],r10
				
				if (NULL== AMBE_payload_ptr){
80002f22:	fe f9 0b f6 	ld.w	r9,pc[3062]
80002f26:	72 09       	ld.w	r9,r9[0x0]
80002f28:	58 09       	cp.w	r9,0
80002f2a:	c0 71       	brne	80002f38 <phy_rx_func+0x2d8>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
80002f2c:	fe fc 0c 00 	ld.w	r12,pc[3072]
80002f30:	f0 1f 03 00 	mcall	80003b30 <phy_rx_func+0xed0>
80002f34:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
																	
				Item_ID = payload_rx_channel->byte[5];
80002f38:	ef 3a 00 0d 	ld.ub	r10,r7[13]
80002f3c:	fe f9 0b f8 	ld.w	r9,pc[3064]
80002f40:	b2 8a       	st.b	r9[0x0],r10
				
				Item_Length = (payload_rx_channel->byte[4] & 0x7F);//7bits
80002f42:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80002f46:	f7 db c0 07 	bfextu	r11,r11,0x0,0x7
80002f4a:	fe fa 0b ee 	ld.w	r10,pc[3054]
80002f4e:	95 0b       	st.w	r10[0x0],r11
								
				switch(Item_ID)
80002f50:	13 89       	ld.ub	r9,r9[0x0]
80002f52:	37 fa       	mov	r10,127
80002f54:	f4 09 18 00 	cp.b	r9,r10
80002f58:	c6 d0       	breq	80003032 <phy_rx_func+0x3d2>
80002f5a:	e0 8b 00 0c 	brhi	80002f72 <phy_rx_func+0x312>
80002f5e:	31 2a       	mov	r10,18
80002f60:	f4 09 18 00 	cp.b	r9,r10
80002f64:	c4 20       	breq	80002fe8 <phy_rx_func+0x388>
80002f66:	31 3a       	mov	r10,19
80002f68:	f4 09 18 00 	cp.b	r9,r10
80002f6c:	e0 81 00 83 	brne	80003072 <phy_rx_func+0x412>
80002f70:	c5 b8       	rjmp	80003026 <phy_rx_func+0x3c6>
80002f72:	2f 09       	sub	r9,-16
80002f74:	30 1a       	mov	r10,1
80002f76:	f4 09 18 00 	cp.b	r9,r10
80002f7a:	e0 8b 00 7c 	brhi	80003072 <phy_rx_func+0x412>
					//The OB know the Call begin and discard the Voice Header
					//The OB know the Call end and discard the Voice  Terminator
					case Raw_Tx_Data_HT://0xF0
					case Raw_Rx_Data_HT://0xF1
					
							if ((payload_rx_channel->byte[6] & 0xF0 )== 0x10)//header
80002f7e:	ef 38 00 0e 	ld.ub	r8,r7[14]
80002f82:	e2 18 00 f0 	andl	r8,0xf0,COH
80002f86:	59 08       	cp.w	r8,16
80002f88:	c0 71       	brne	80002f96 <phy_rx_func+0x336>
							{
								m_RxBurstType = VOICEHEADER;
80002f8a:	30 19       	mov	r9,1
80002f8c:	fe f8 0b 94 	ld.w	r8,pc[2964]
80002f90:	91 09       	st.w	r8[0x0],r9
80002f92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

							}
							else if ((payload_rx_channel->byte[6] & 0xF0) == 0x20)//Terminator
80002f96:	e0 48 00 20 	cp.w	r8,32
80002f9a:	c2 11       	brne	80002fdc <phy_rx_func+0x37c>
							{
								m_RxBurstType = VOICETERMINATOR;
80002f9c:	30 a9       	mov	r9,10
80002f9e:	fe f8 0b 82 	ld.w	r8,pc[2946]
80002fa2:	91 09       	st.w	r8[0x0],r9
								//AMBE-data and PCM-data is not the same. AMBE is compressed data,
								//if there was a missing portion, a clear voice is difficult to extract the data.
								//It must ensure that all the data received AMBE.
								
								//注意！！！考虑是否需要把剩余的空间置0。
								memset((AMBE_payload_ptr+ (RxAMBE_IsFillingNext8 +1)), 0x00, (512-(RxAMBE_IsFillingNext8 + 1)));
80002fa4:	fe f6 0b 98 	ld.w	r6,pc[2968]
80002fa8:	6c 08       	ld.w	r8,r6[0x0]
80002faa:	f0 0a 11 ff 	rsub	r10,r8,-1
80002fae:	fe f7 0b 6a 	ld.w	r7,pc[2922]
80002fb2:	2f f8       	sub	r8,-1
80002fb4:	6e 0c       	ld.w	r12,r7[0x0]
80002fb6:	f4 ca fe 00 	sub	r10,r10,-512
80002fba:	30 0b       	mov	r11,0
80002fbc:	10 0c       	add	r12,r8
80002fbe:	f0 1f 02 e1 	mcall	80003b40 <phy_rx_func+0xee0>
								
								RxAMBE_IsFillingNext8 = 0;
80002fc2:	30 08       	mov	r8,0
80002fc4:	8d 08       	st.w	r6[0x0],r8
								payload_rx(AMBE_payload_ptr);
80002fc6:	6e 0c       	ld.w	r12,r7[0x0]
80002fc8:	f0 1f 02 df 	mcall	80003b44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80002fcc:	fe f8 0b 44 	ld.w	r8,pc[2884]
80002fd0:	70 0c       	ld.w	r12,r8[0x0]
80002fd2:	f0 1f 02 ca 	mcall	80003af8 <phy_rx_func+0xe98>
80002fd6:	8f 0c       	st.w	r7[0x0],r12
80002fd8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								//logFromISR("\n\r QQ1 \n\r");
								
							}
							else//error voice
							{
								m_RxBurstType = VOICE_WATING;
80002fdc:	30 09       	mov	r9,0
80002fde:	fe f8 0b 42 	ld.w	r8,pc[2882]
80002fe2:	91 09       	st.w	r8[0x0],r9
80002fe4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;//WAITINGABAB.
					
		
					case Vocoder_Bit_Stream_Parameter://0x12
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80002fe8:	20 48       	sub	r8,4
80002fea:	fe f9 0b 3a 	ld.w	r9,pc[2874]
80002fee:	93 08       	st.w	r9[0x0],r8
80002ff0:	58 08       	cp.w	r8,0
80002ff2:	e0 80 05 74 	breq	80003ada <phy_rx_func+0xe7a>
					
							//Vocoder Bits Stream Parameter
							VF_SN = (payload_rx_channel->byte[7] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80002ff6:	ef 3c 00 0f 	ld.ub	r12,r7[15]
80002ffa:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80002ffe:	fe f8 0b 4a 	ld.w	r8,pc[2890]
80003002:	b0 8c       	st.b	r8[0x0],r12
							
							VBSP_data[0] = payload_rx_channel->word[2];
80003004:	8e 69       	ld.sh	r9,r7[0xc]
80003006:	fe f8 0b 46 	ld.w	r8,pc[2886]
8000300a:	b0 09       	st.h	r8[0x0],r9
							VBSP_data[1] = payload_rx_channel->word[3];
8000300c:	8e 79       	ld.sh	r9,r7[0xe]
8000300e:	b0 19       	st.h	r8[0x2],r9
							
							m_RxBurstType = CalculateBurst(VF_SN);
80003010:	f0 1f 02 d0 	mcall	80003b50 <phy_rx_func+0xef0>
80003014:	fe f8 0b 0c 	ld.w	r8,pc[2828]
80003018:	91 0c       	st.w	r8[0x0],r12
							
							RxMediaState = READING_AMBE_MEDIA;//Jump
8000301a:	30 49       	mov	r9,4
8000301c:	fe f8 0b 00 	ld.w	r8,pc[2816]
80003020:	91 09       	st.w	r8[0x0],r9
80003022:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							
					//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
					// or discard it to reduce payload size.	
					//This shouldn't happen, but must check.	
					case Soft_Decision_Value://0x13
						m_RxBurstType = VOICE_WATING;
80003026:	30 09       	mov	r9,0
80003028:	fe f8 0a f8 	ld.w	r8,pc[2808]
8000302c:	91 09       	st.w	r8[0x0],r9
8000302e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
					case Radio_Internal_Parameter://0x7F
							
							//logFromISR("\n\r Item_Length:%d\n\r", Item_Length);
							
							if ((RxBytesWaiting -= 4) <= 0) break;
80003032:	20 48       	sub	r8,4
80003034:	fe f9 0a f0 	ld.w	r9,pc[2800]
80003038:	93 08       	st.w	r9[0x0],r8
8000303a:	58 08       	cp.w	r8,0
8000303c:	e0 80 05 4f 	breq	80003ada <phy_rx_func+0xe7a>
							//Radio Internal Parameter
							Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[3];
80003040:	fe f8 0b 14 	ld.w	r8,pc[2836]
80003044:	70 09       	ld.w	r9,r8[0x0]
80003046:	8e 7b       	ld.sh	r11,r7[0xe]
80003048:	fe fa 0b 10 	ld.w	r10,pc[2832]
8000304c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
							RxData_IsFillingNext16 += 1; 
80003050:	2f f9       	sub	r9,-1
80003052:	91 09       	st.w	r8[0x0],r9
							Item_Length -= 2 ;
80003054:	fe f8 0a e4 	ld.w	r8,pc[2788]
80003058:	70 09       	ld.w	r9,r8[0x0]
8000305a:	20 29       	sub	r9,2
8000305c:	91 09       	st.w	r8[0x0],r9
							//....................................................
							m_RxBurstType = RADIOINTERNAL;
8000305e:	30 29       	mov	r9,2
80003060:	fe f8 0a c0 	ld.w	r8,pc[2752]
80003064:	91 09       	st.w	r8[0x0],r9

							RxMediaState = READING_AMBE_AUX;//Jump
80003066:	30 39       	mov	r9,3
80003068:	fe f8 0a b4 	ld.w	r8,pc[2740]
8000306c:	91 09       	st.w	r8[0x0],r9
8000306e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									
					default://0x03,0x04
						
						//((Item_ID == 0x04) || (Item_ID == 0x03) )//Unknown type data directly back hair
							//break;
							m_RxBurstType = UNSUREDATA;
80003072:	30 3a       	mov	r10,3
80003074:	fe f9 0a ac 	ld.w	r9,pc[2732]
80003078:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[0] = payload_rx_channel->dword[0];
8000307a:	6e 2a       	ld.w	r10,r7[0x8]
8000307c:	fe f9 0a e0 	ld.w	r9,pc[2784]
80003080:	93 0a       	st.w	r9[0x0],r10
							AMBE_HT[1] = payload_rx_channel->dword[1];
80003082:	6e 3a       	ld.w	r10,r7[0xc]
80003084:	93 1a       	st.w	r9[0x4],r10
							
							if (RxBytesWaiting == 0x00000014)
80003086:	59 48       	cp.w	r8,20
80003088:	c0 61       	brne	80003094 <phy_rx_func+0x434>
							{
								RxBytesWaiting = 0x18;//24 Reassigned
8000308a:	31 89       	mov	r9,24
8000308c:	fe f8 0a 98 	ld.w	r8,pc[2712]
80003090:	91 09       	st.w	r8[0x0],r9
80003092:	c0 a8       	rjmp	800030a6 <phy_rx_func+0x446>
								//_flag =0;
								
							}
							if (RxBytesWaiting == 0x00000010)
80003094:	fe f8 0a 90 	ld.w	r8,pc[2704]
80003098:	70 08       	ld.w	r8,r8[0x0]
8000309a:	59 08       	cp.w	r8,16
8000309c:	c0 51       	brne	800030a6 <phy_rx_func+0x446>
							{
								RxBytesWaiting = 0x10;//16 Reassigned
8000309e:	31 09       	mov	r9,16
800030a0:	fe f8 0a 84 	ld.w	r8,pc[2692]
800030a4:	91 09       	st.w	r8[0x0],r9
								//_flag =1;
							}
					
							RxMediaState = READING_AMBE_MEDIA;//Jump
800030a6:	30 49       	mov	r9,4
800030a8:	fe f8 0a 74 	ld.w	r8,pc[2676]
800030ac:	91 09       	st.w	r8[0x0],r9
800030ae:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
//#if 0
			else//PCM-media-data
			{	
				//logFromISR("\n\r RX:%x \n\r", payload_rx_channel->dword[0]);
				//SPEAKER_DATA or  //MIC_DATA
				if (((payload_rx_channel->dword[0] & 0x0000F000 ) != SPEAKER_DATA ) 
800030b2:	e0 49 10 00 	cp.w	r9,4096
800030b6:	5f 1a       	srne	r10
800030b8:	e0 49 20 00 	cp.w	r9,8192
800030bc:	5f 19       	srne	r9
800030be:	f5 e9 00 09 	and	r9,r10,r9
800030c2:	e0 81 05 0c 	brne	80003ada <phy_rx_func+0xe7a>
					&& ((payload_rx_channel->dword[0] & 0x0000F000 ) != MIC_DATA ))break;
				
				AMBE_tx_flag = 0;
800030c6:	fe fa 0a 9a 	ld.w	r10,pc[2714]
800030ca:	b4 89       	st.b	r10[0x0],r9
				AMBE_rx_flag = 0;
800030cc:	fe fa 0a 98 	ld.w	r10,pc[2712]
800030d0:	b4 89       	st.b	r10[0x0],r9
				
				Item_ID = 0;//To make sure your save PCM data.
800030d2:	fe fa 0a 62 	ld.w	r10,pc[2658]
800030d6:	b4 89       	st.b	r10[0x0],r9
			
				if (NULL== payload_ptr){
800030d8:	fe f9 0a 3c 	ld.w	r9,pc[2620]
800030dc:	72 09       	ld.w	r9,r9[0x0]
800030de:	58 09       	cp.w	r9,0
800030e0:	c0 71       	brne	800030ee <phy_rx_func+0x48e>
					logFromISR("\n\r xxxxx_QQ_xxxxx \n\r");//测试是否有这种情况出现
800030e2:	fe fc 0a 4a 	ld.w	r12,pc[2634]
800030e6:	f0 1f 02 93 	mcall	80003b30 <phy_rx_func+0xed0>
800030ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
800030ee:	6e 2a       	ld.w	r10,r7[0x8]
800030f0:	e2 1a 0f 00 	andl	r10,0xf00,COH
800030f4:	58 1a       	cp.w	r10,1
800030f6:	e0 8b 00 4d 	brhi	80003190 <phy_rx_func+0x530>
				
				if ((payload_rx_channel->dword[0]  & 0x00000F00) <= 1){  //Flag type must process Array Descriptor.
				//The first word of the media access payload must be the Array descriptor length. And the
				//unit of the length is in word (16-bit). The length field itself does not count into the length.
				//When there is no array descriptor, the length must be set to zero.[9.1.4.1]
					if ((RxBytesWaiting -= 4) <= 0) break;          //Nothing beyond this Phy buffer. Keep looking for Header
800030fa:	20 48       	sub	r8,4
800030fc:	fe f9 0a 28 	ld.w	r9,pc[2600]
80003100:	93 08       	st.w	r9[0x0],r8
80003102:	58 08       	cp.w	r8,0
80003104:	e0 80 04 eb 	breq	80003ada <phy_rx_func+0xe7a>
					ArrayDiscLength = payload_rx_channel->word[2];
80003108:	8e 68       	ld.sh	r8,r7[0xc]
8000310a:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000310e:	fe f9 0a 5a 	ld.w	r9,pc[2650]
80003112:	93 0a       	st.w	r9[0x0],r10
					switch (ArrayDiscLength){
80003114:	30 09       	mov	r9,0
80003116:	f2 08 19 00 	cp.h	r8,r9
8000311a:	c0 70       	breq	80003128 <phy_rx_func+0x4c8>
8000311c:	30 19       	mov	r9,1
8000311e:	f2 08 19 00 	cp.h	r8,r9
80003122:	e0 81 04 dc 	brne	80003ada <phy_rx_func+0xe7a>
80003126:	c2 68       	rjmp	80003172 <phy_rx_func+0x512>
						case 0:          //The usual case. Remaining word in Phy buffer is Audio.
								
							payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003128:	fe f8 0a 44 	ld.w	r8,pc[2628]
8000312c:	70 0a       	ld.w	r10,r8[0x0]
8000312e:	fe f9 09 e6 	ld.w	r9,pc[2534]
80003132:	72 09       	ld.w	r9,r9[0x0]
80003134:	8e 7b       	ld.sh	r11,r7[0xe]
80003136:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
							RxMedia_IsFillingNext16 += 1;
8000313a:	70 09       	ld.w	r9,r8[0x0]
8000313c:	2f f9       	sub	r9,-1
8000313e:	91 09       	st.w	r8[0x0],r9
							if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003140:	e0 49 00 ff 	cp.w	r9,255
80003144:	e0 88 00 11 	brls	80003166 <phy_rx_func+0x506>
							{
								RxMedia_IsFillingNext16 = 0;	
80003148:	30 09       	mov	r9,0
8000314a:	91 09       	st.w	r8[0x0],r9
								payload_rx(payload_ptr);	
8000314c:	fe f7 09 c8 	ld.w	r7,pc[2504]
80003150:	6e 0c       	ld.w	r12,r7[0x0]
80003152:	f0 1f 02 7d 	mcall	80003b44 <phy_rx_func+0xee4>
								payload_ptr = get_payload_idle_isr();
80003156:	fe f8 09 ba 	ld.w	r8,pc[2490]
8000315a:	70 0c       	ld.w	r12,r8[0x0]
8000315c:	f0 1f 02 67 	mcall	80003af8 <phy_rx_func+0xe98>
80003160:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == payload_ptr){
80003162:	e0 80 04 bc 	breq	80003ada <phy_rx_func+0xe7a>
									break;
								}				
							}
							RxMediaState = READINGMEDIA;
80003166:	30 29       	mov	r9,2
80003168:	fe f8 09 b4 	ld.w	r8,pc[2484]
8000316c:	91 09       	st.w	r8[0x0],r9
8000316e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003172:	8e 79       	ld.sh	r9,r7[0xe]
80003174:	30 38       	mov	r8,3
80003176:	f0 09 19 00 	cp.h	r9,r8
8000317a:	c0 51       	brne	80003184 <phy_rx_func+0x524>
				
						case 1: //The next usual case.
								//In general case, add code to process single word Array descriptor.
								if (payload_rx_channel->word[3] == 0x0003)//Stream Terminator
								{
									Terminator_Flag = 1;
8000317c:	30 19       	mov	r9,1
8000317e:	fe f8 09 f2 	ld.w	r8,pc[2546]
80003182:	b0 89       	st.b	r8[0x0],r9
								else
								{
									//Terminator_Flag = 0;
								}
								
								RxMediaState = READINGMEDIA;
80003184:	30 29       	mov	r9,2
80003186:	fe f8 09 96 	ld.w	r8,pc[2454]
8000318a:	91 09       	st.w	r8[0x0],r9
8000318c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
				break;
			}
		
				//Code gets here on Middle or last Fragment. No Array descriptor.
				if (RxBytesWaiting < 2) break;//This shouldn't happen, but must check.
80003190:	58 18       	cp.w	r8,1
80003192:	e0 88 04 a4 	brls	80003ada <phy_rx_func+0xe7a>
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->dword[1] & 0x0000FFFF;
80003196:	fe f8 09 d6 	ld.w	r8,pc[2518]
8000319a:	70 0a       	ld.w	r10,r8[0x0]
8000319c:	6e 3b       	ld.w	r11,r7[0xc]
8000319e:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800031a2:	70 09       	ld.w	r9,r8[0x0]
800031a4:	2f f9       	sub	r9,-1
800031a6:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800031a8:	e0 49 00 ff 	cp.w	r9,255
800031ac:	e0 88 00 11 	brls	800031ce <phy_rx_func+0x56e>
				{
					RxMedia_IsFillingNext16 = 0;
800031b0:	30 09       	mov	r9,0
800031b2:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800031b4:	fe f7 09 60 	ld.w	r7,pc[2400]
800031b8:	6e 0c       	ld.w	r12,r7[0x0]
800031ba:	f0 1f 02 63 	mcall	80003b44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800031be:	fe f8 09 52 	ld.w	r8,pc[2386]
800031c2:	70 0c       	ld.w	r12,r8[0x0]
800031c4:	f0 1f 02 4d 	mcall	80003af8 <phy_rx_func+0xe98>
800031c8:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
800031ca:	e0 80 04 88 	breq	80003ada <phy_rx_func+0xe7a>
					{
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0) break;  //This shouldn't happen, but must check;
800031ce:	fe f9 09 56 	ld.w	r9,pc[2390]
800031d2:	72 08       	ld.w	r8,r9[0x0]
800031d4:	20 28       	sub	r8,2
800031d6:	93 08       	st.w	r9[0x0],r8
800031d8:	e0 80 04 81 	breq	80003ada <phy_rx_func+0xe7a>
				RxMediaState = READINGMEDIA;
800031dc:	30 29       	mov	r9,2
800031de:	fe f8 09 3e 	ld.w	r8,pc[2366]
800031e2:	91 09       	st.w	r8[0x0],r9
800031e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
		case READINGMEDIA:
				
			/***PCM-media-data ****/
			{
				
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[0];
800031e8:	fe f8 09 84 	ld.w	r8,pc[2436]
800031ec:	70 0a       	ld.w	r10,r8[0x0]
800031ee:	fe f9 09 26 	ld.w	r9,pc[2342]
800031f2:	72 09       	ld.w	r9,r9[0x0]
800031f4:	8e 4b       	ld.sh	r11,r7[0x8]
800031f6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;	
800031fa:	70 09       	ld.w	r9,r8[0x0]
800031fc:	2f f9       	sub	r9,-1
800031fe:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003200:	e0 49 00 ff 	cp.w	r9,255
80003204:	e0 88 00 16 	brls	80003230 <phy_rx_func+0x5d0>
				{
					RxMedia_IsFillingNext16 = 0;
80003208:	30 09       	mov	r9,0
8000320a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000320c:	fe f6 09 08 	ld.w	r6,pc[2312]
80003210:	6c 0c       	ld.w	r12,r6[0x0]
80003212:	f0 1f 02 4d 	mcall	80003b44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003216:	fe f8 08 fa 	ld.w	r8,pc[2298]
8000321a:	70 0c       	ld.w	r12,r8[0x0]
8000321c:	f0 1f 02 37 	mcall	80003af8 <phy_rx_func+0xe98>
80003220:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003222:	c0 71       	brne	80003230 <phy_rx_func+0x5d0>
					{
						RxMediaState = WAITINGABAB;
80003224:	30 09       	mov	r9,0
80003226:	fe f8 08 f6 	ld.w	r8,pc[2294]
8000322a:	91 09       	st.w	r8[0x0],r9
8000322c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0)
80003230:	fe f9 08 f4 	ld.w	r9,pc[2292]
80003234:	72 08       	ld.w	r8,r9[0x0]
80003236:	20 28       	sub	r8,2
80003238:	93 08       	st.w	r9[0x0],r8
8000323a:	c0 71       	brne	80003248 <phy_rx_func+0x5e8>
				{
					RxMediaState = WAITINGABAB;
8000323c:	30 09       	mov	r9,0
8000323e:	fe f8 08 de 	ld.w	r8,pc[2270]
80003242:	91 09       	st.w	r8[0x0],r9
80003244:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[1];
80003248:	fe f8 09 24 	ld.w	r8,pc[2340]
8000324c:	70 0a       	ld.w	r10,r8[0x0]
8000324e:	fe f9 08 c6 	ld.w	r9,pc[2246]
80003252:	72 09       	ld.w	r9,r9[0x0]
80003254:	8e 5b       	ld.sh	r11,r7[0xa]
80003256:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000325a:	70 09       	ld.w	r9,r8[0x0]
8000325c:	2f f9       	sub	r9,-1
8000325e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003260:	e0 49 00 ff 	cp.w	r9,255
80003264:	e0 88 00 16 	brls	80003290 <phy_rx_func+0x630>
				{
					RxMedia_IsFillingNext16 = 0;
80003268:	30 09       	mov	r9,0
8000326a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000326c:	fe f6 08 a8 	ld.w	r6,pc[2216]
80003270:	6c 0c       	ld.w	r12,r6[0x0]
80003272:	f0 1f 02 35 	mcall	80003b44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003276:	fe f8 08 9a 	ld.w	r8,pc[2202]
8000327a:	70 0c       	ld.w	r12,r8[0x0]
8000327c:	f0 1f 02 1f 	mcall	80003af8 <phy_rx_func+0xe98>
80003280:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
80003282:	c0 71       	brne	80003290 <phy_rx_func+0x630>
					{
						RxMediaState = WAITINGABAB;
80003284:	30 09       	mov	r9,0
80003286:	fe f8 08 96 	ld.w	r8,pc[2198]
8000328a:	91 09       	st.w	r8[0x0],r9
8000328c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003290:	fe f9 08 94 	ld.w	r9,pc[2196]
80003294:	72 08       	ld.w	r8,r9[0x0]
80003296:	20 28       	sub	r8,2
80003298:	93 08       	st.w	r9[0x0],r8
8000329a:	c0 71       	brne	800032a8 <phy_rx_func+0x648>
					RxMediaState = WAITINGABAB;
8000329c:	30 09       	mov	r9,0
8000329e:	fe f8 08 7e 	ld.w	r8,pc[2174]
800032a2:	91 09       	st.w	r8[0x0],r9
800032a4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}

				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[2];
800032a8:	fe f8 08 c4 	ld.w	r8,pc[2244]
800032ac:	70 0a       	ld.w	r10,r8[0x0]
800032ae:	fe f9 08 66 	ld.w	r9,pc[2150]
800032b2:	72 09       	ld.w	r9,r9[0x0]
800032b4:	8e 6b       	ld.sh	r11,r7[0xc]
800032b6:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
800032ba:	70 09       	ld.w	r9,r8[0x0]
800032bc:	2f f9       	sub	r9,-1
800032be:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
800032c0:	e0 49 00 ff 	cp.w	r9,255
800032c4:	e0 88 00 16 	brls	800032f0 <phy_rx_func+0x690>
				{
					RxMedia_IsFillingNext16 = 0;
800032c8:	30 09       	mov	r9,0
800032ca:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
800032cc:	fe f6 08 48 	ld.w	r6,pc[2120]
800032d0:	6c 0c       	ld.w	r12,r6[0x0]
800032d2:	f0 1f 02 1d 	mcall	80003b44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
800032d6:	fe f8 08 3a 	ld.w	r8,pc[2106]
800032da:	70 0c       	ld.w	r12,r8[0x0]
800032dc:	f0 1f 02 07 	mcall	80003af8 <phy_rx_func+0xe98>
800032e0:	8d 0c       	st.w	r6[0x0],r12
					if(NULL == payload_ptr)
800032e2:	c0 71       	brne	800032f0 <phy_rx_func+0x690>
					{
						RxMediaState = WAITINGABAB;
800032e4:	30 09       	mov	r9,0
800032e6:	fe f8 08 36 	ld.w	r8,pc[2102]
800032ea:	91 09       	st.w	r8[0x0],r9
800032ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
800032f0:	fe f9 08 34 	ld.w	r9,pc[2100]
800032f4:	72 08       	ld.w	r8,r9[0x0]
800032f6:	20 28       	sub	r8,2
800032f8:	93 08       	st.w	r9[0x0],r8
800032fa:	c0 71       	brne	80003308 <phy_rx_func+0x6a8>
					RxMediaState = WAITINGABAB;
800032fc:	30 09       	mov	r9,0
800032fe:	fe f8 08 1e 	ld.w	r8,pc[2078]
80003302:	91 09       	st.w	r8[0x0],r9
80003304:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					break;
				}
		
				payload_ptr[RxMedia_IsFillingNext16] = payload_rx_channel->word[3];
80003308:	fe f8 08 64 	ld.w	r8,pc[2148]
8000330c:	70 0a       	ld.w	r10,r8[0x0]
8000330e:	fe f9 08 06 	ld.w	r9,pc[2054]
80003312:	72 09       	ld.w	r9,r9[0x0]
80003314:	8e 7b       	ld.sh	r11,r7[0xe]
80003316:	f2 0a 0a 1b 	st.h	r9[r10<<0x1],r11
				RxMedia_IsFillingNext16 += 1;
8000331a:	70 09       	ld.w	r9,r8[0x0]
8000331c:	2f f9       	sub	r9,-1
8000331e:	91 09       	st.w	r8[0x0],r9
				if (RxMedia_IsFillingNext16 >= MAX_PAYLOAD_BUFF_SIZE)
80003320:	e0 49 00 ff 	cp.w	r9,255
80003324:	e0 88 00 16 	brls	80003350 <phy_rx_func+0x6f0>
				{
					RxMedia_IsFillingNext16 = 0;
80003328:	30 09       	mov	r9,0
8000332a:	91 09       	st.w	r8[0x0],r9
					payload_rx(payload_ptr);
8000332c:	fe f7 07 e8 	ld.w	r7,pc[2024]
80003330:	6e 0c       	ld.w	r12,r7[0x0]
80003332:	f0 1f 02 05 	mcall	80003b44 <phy_rx_func+0xee4>
					payload_ptr = get_payload_idle_isr();
80003336:	fe f8 07 da 	ld.w	r8,pc[2010]
8000333a:	70 0c       	ld.w	r12,r8[0x0]
8000333c:	f0 1f 01 ef 	mcall	80003af8 <phy_rx_func+0xe98>
80003340:	8f 0c       	st.w	r7[0x0],r12
					if(NULL == payload_ptr)
80003342:	c0 71       	brne	80003350 <phy_rx_func+0x6f0>
					{
						RxMediaState = WAITINGABAB;
80003344:	30 09       	mov	r9,0
80003346:	fe f8 07 d6 	ld.w	r8,pc[2006]
8000334a:	91 09       	st.w	r8[0x0],r9
8000334c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
						break;
					}
				}
				if ((RxBytesWaiting -= 2) <= 0){
80003350:	fe f9 07 d4 	ld.w	r9,pc[2004]
80003354:	72 08       	ld.w	r8,r9[0x0]
80003356:	20 28       	sub	r8,2
80003358:	93 08       	st.w	r9[0x0],r8
8000335a:	e0 81 03 c0 	brne	80003ada <phy_rx_func+0xe7a>
					RxMediaState = WAITINGABAB;
8000335e:	30 09       	mov	r9,0
80003360:	fe f8 07 bc 	ld.w	r8,pc[1980]
80003364:	91 09       	st.w	r8[0x0],r9
80003366:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

		case READING_AMBE_MEDIA:
		
			/****AMBE-media-data ****/
		
					if ((Item_ID == Vocoder_Bit_Stream_Parameter))//PAYLOAD_DATA_ENH (0x0c))
8000336a:	fe f8 07 ca 	ld.w	r8,pc[1994]
8000336e:	11 89       	ld.ub	r9,r8[0x0]
80003370:	31 28       	mov	r8,18
80003372:	f0 09 18 00 	cp.b	r9,r8
80003376:	e0 81 01 4c 	brne	8000360e <phy_rx_func+0x9ae>
					{
						Item_ID = payload_rx_channel->byte[1];
8000337a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000337e:	fe f8 07 b6 	ld.w	r8,pc[1974]
80003382:	b0 89       	st.b	r8[0x0],r9
						if (Item_ID == Post_Voice_Encoder_Data)//发送方的压缩类型数据
80003384:	11 89       	ld.ub	r9,r8[0x0]
80003386:	3f 28       	mov	r8,-14
80003388:	f0 09 18 00 	cp.b	r9,r8
8000338c:	e0 81 01 3b 	brne	80003602 <phy_rx_func+0x9a2>
						{
							AMBE_tx_flag = 1;
80003390:	30 19       	mov	r9,1
80003392:	fe f8 07 ce 	ld.w	r8,pc[1998]
80003396:	b0 89       	st.b	r8[0x0],r9
							
							RxBytesWaiting = ((payload_rx_channel->dword[0] & 0x7F000000) >>24);//Test calculations are correct; 8
80003398:	6e 29       	ld.w	r9,r7[0x8]
8000339a:	f3 d9 c3 07 	bfextu	r9,r9,0x18,0x7
8000339e:	fe f8 07 86 	ld.w	r8,pc[1926]
800033a2:	91 09       	st.w	r8[0x0],r9
							
							//For looping back to Radio
							AMBEBurst_rawdata[0] = payload_rx_channel->word[1];
800033a4:	8e 59       	ld.sh	r9,r7[0xa]
800033a6:	fe f8 07 ce 	ld.w	r8,pc[1998]
800033aa:	b0 09       	st.h	r8[0x0],r9
							AMBEBurst_rawdata[1] = payload_rx_channel->word[2];
800033ac:	8e 69       	ld.sh	r9,r7[0xc]
800033ae:	b0 19       	st.h	r8[0x2],r9
							AMBEBurst_rawdata[2] = payload_rx_channel->word[3];
800033b0:	8e 79       	ld.sh	r9,r7[0xe]
800033b2:	b0 29       	st.h	r8[0x4],r9
							
							//To be tested. Also locally stored RAW-AMBER-DATA
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//1
800033b4:	fe f8 07 88 	ld.w	r8,pc[1928]
800033b8:	fe f9 07 60 	ld.w	r9,pc[1888]
800033bc:	72 0a       	ld.w	r10,r9[0x0]
800033be:	70 09       	ld.w	r9,r8[0x0]
800033c0:	ef 3b 00 0a 	ld.ub	r11,r7[10]
800033c4:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800033c8:	70 09       	ld.w	r9,r8[0x0]
800033ca:	2f f9       	sub	r9,-1
800033cc:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800033ce:	e0 49 01 ff 	cp.w	r9,511
800033d2:	e0 88 00 16 	brls	800033fe <phy_rx_func+0x79e>
							{
								RxAMBE_IsFillingNext8 = 0;
800033d6:	30 09       	mov	r9,0
800033d8:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800033da:	fe f6 07 3e 	ld.w	r6,pc[1854]
800033de:	6c 0c       	ld.w	r12,r6[0x0]
800033e0:	f0 1f 01 d9 	mcall	80003b44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800033e4:	fe f8 07 2c 	ld.w	r8,pc[1836]
800033e8:	70 0c       	ld.w	r12,r8[0x0]
800033ea:	f0 1f 01 c4 	mcall	80003af8 <phy_rx_func+0xe98>
800033ee:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800033f0:	c0 71       	brne	800033fe <phy_rx_func+0x79e>
								{
									RxMediaState = WAITINGABAB;
800033f2:	30 09       	mov	r9,0
800033f4:	fe f8 07 28 	ld.w	r8,pc[1832]
800033f8:	91 09       	st.w	r8[0x0],r9
800033fa:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800033fe:	fe f9 07 26 	ld.w	r9,pc[1830]
80003402:	72 08       	ld.w	r8,r9[0x0]
80003404:	20 18       	sub	r8,1
80003406:	93 08       	st.w	r9[0x0],r8
80003408:	c0 71       	brne	80003416 <phy_rx_func+0x7b6>
								RxMediaState = WAITINGABAB;
8000340a:	30 09       	mov	r9,0
8000340c:	fe f8 07 10 	ld.w	r8,pc[1808]
80003410:	91 09       	st.w	r8[0x0],r9
80003412:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}			
							
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//2
80003416:	fe f8 07 26 	ld.w	r8,pc[1830]
8000341a:	fe f9 06 fe 	ld.w	r9,pc[1790]
8000341e:	72 0a       	ld.w	r10,r9[0x0]
80003420:	70 09       	ld.w	r9,r8[0x0]
80003422:	ef 3b 00 0b 	ld.ub	r11,r7[11]
80003426:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000342a:	70 09       	ld.w	r9,r8[0x0]
8000342c:	2f f9       	sub	r9,-1
8000342e:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003430:	e0 49 01 ff 	cp.w	r9,511
80003434:	e0 88 00 16 	brls	80003460 <phy_rx_func+0x800>
							{
								RxAMBE_IsFillingNext8 = 0;
80003438:	30 09       	mov	r9,0
8000343a:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000343c:	fe f6 06 dc 	ld.w	r6,pc[1756]
80003440:	6c 0c       	ld.w	r12,r6[0x0]
80003442:	f0 1f 01 c1 	mcall	80003b44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
80003446:	fe f8 06 ca 	ld.w	r8,pc[1738]
8000344a:	70 0c       	ld.w	r12,r8[0x0]
8000344c:	f0 1f 01 ab 	mcall	80003af8 <phy_rx_func+0xe98>
80003450:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003452:	c0 71       	brne	80003460 <phy_rx_func+0x800>
								{
									RxMediaState = WAITINGABAB;
80003454:	30 09       	mov	r9,0
80003456:	fe f8 06 c6 	ld.w	r8,pc[1734]
8000345a:	91 09       	st.w	r8[0x0],r9
8000345c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003460:	fe f9 06 c4 	ld.w	r9,pc[1732]
80003464:	72 08       	ld.w	r8,r9[0x0]
80003466:	20 18       	sub	r8,1
80003468:	93 08       	st.w	r9[0x0],r8
8000346a:	c0 71       	brne	80003478 <phy_rx_func+0x818>
								RxMediaState = WAITINGABAB;
8000346c:	30 09       	mov	r9,0
8000346e:	fe f8 06 ae 	ld.w	r8,pc[1710]
80003472:	91 09       	st.w	r8[0x0],r9
80003474:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}		
						
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//3
80003478:	fe f8 06 c4 	ld.w	r8,pc[1732]
8000347c:	fe f9 06 9c 	ld.w	r9,pc[1692]
80003480:	72 0a       	ld.w	r10,r9[0x0]
80003482:	70 09       	ld.w	r9,r8[0x0]
80003484:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003488:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
8000348c:	70 09       	ld.w	r9,r8[0x0]
8000348e:	2f f9       	sub	r9,-1
80003490:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003492:	e0 49 01 ff 	cp.w	r9,511
80003496:	e0 88 00 16 	brls	800034c2 <phy_rx_func+0x862>
							{
								RxAMBE_IsFillingNext8 = 0;
8000349a:	30 09       	mov	r9,0
8000349c:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
8000349e:	fe f6 06 7a 	ld.w	r6,pc[1658]
800034a2:	6c 0c       	ld.w	r12,r6[0x0]
800034a4:	f0 1f 01 a8 	mcall	80003b44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800034a8:	fe f8 06 68 	ld.w	r8,pc[1640]
800034ac:	70 0c       	ld.w	r12,r8[0x0]
800034ae:	f0 1f 01 93 	mcall	80003af8 <phy_rx_func+0xe98>
800034b2:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
800034b4:	c0 71       	brne	800034c2 <phy_rx_func+0x862>
								{
									RxMediaState = WAITINGABAB;
800034b6:	30 09       	mov	r9,0
800034b8:	fe f8 06 64 	ld.w	r8,pc[1636]
800034bc:	91 09       	st.w	r8[0x0],r9
800034be:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800034c2:	fe f9 06 62 	ld.w	r9,pc[1634]
800034c6:	72 08       	ld.w	r8,r9[0x0]
800034c8:	20 18       	sub	r8,1
800034ca:	93 08       	st.w	r9[0x0],r8
800034cc:	c0 71       	brne	800034da <phy_rx_func+0x87a>
								RxMediaState = WAITINGABAB;
800034ce:	30 09       	mov	r9,0
800034d0:	fe f8 06 4c 	ld.w	r8,pc[1612]
800034d4:	91 09       	st.w	r8[0x0],r9
800034d6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[5];//4
800034da:	fe f8 06 62 	ld.w	r8,pc[1634]
800034de:	fe f9 06 3a 	ld.w	r9,pc[1594]
800034e2:	72 0a       	ld.w	r10,r9[0x0]
800034e4:	70 09       	ld.w	r9,r8[0x0]
800034e6:	ef 3b 00 0d 	ld.ub	r11,r7[13]
800034ea:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800034ee:	70 09       	ld.w	r9,r8[0x0]
800034f0:	2f f9       	sub	r9,-1
800034f2:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800034f4:	e0 49 01 ff 	cp.w	r9,511
800034f8:	e0 88 00 16 	brls	80003524 <phy_rx_func+0x8c4>
							{
								RxAMBE_IsFillingNext8 = 0;
800034fc:	30 09       	mov	r9,0
800034fe:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003500:	fe f6 06 18 	ld.w	r6,pc[1560]
80003504:	6c 0c       	ld.w	r12,r6[0x0]
80003506:	f0 1f 01 90 	mcall	80003b44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000350a:	fe f8 06 06 	ld.w	r8,pc[1542]
8000350e:	70 0c       	ld.w	r12,r8[0x0]
80003510:	f0 1f 01 7a 	mcall	80003af8 <phy_rx_func+0xe98>
80003514:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003516:	c0 71       	brne	80003524 <phy_rx_func+0x8c4>
								{
									RxMediaState = WAITINGABAB;
80003518:	30 09       	mov	r9,0
8000351a:	fe f8 06 02 	ld.w	r8,pc[1538]
8000351e:	91 09       	st.w	r8[0x0],r9
80003520:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003524:	fe f9 06 00 	ld.w	r9,pc[1536]
80003528:	72 08       	ld.w	r8,r9[0x0]
8000352a:	20 18       	sub	r8,1
8000352c:	93 08       	st.w	r9[0x0],r8
8000352e:	c0 71       	brne	8000353c <phy_rx_func+0x8dc>
								RxMediaState = WAITINGABAB;
80003530:	30 09       	mov	r9,0
80003532:	fe f8 05 ea 	ld.w	r8,pc[1514]
80003536:	91 09       	st.w	r8[0x0],r9
80003538:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//5
8000353c:	fe f8 06 00 	ld.w	r8,pc[1536]
80003540:	fe f9 05 d8 	ld.w	r9,pc[1496]
80003544:	72 0a       	ld.w	r10,r9[0x0]
80003546:	70 09       	ld.w	r9,r8[0x0]
80003548:	ef 3b 00 0e 	ld.ub	r11,r7[14]
8000354c:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
80003550:	70 09       	ld.w	r9,r8[0x0]
80003552:	2f f9       	sub	r9,-1
80003554:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003556:	e0 49 01 ff 	cp.w	r9,511
8000355a:	e0 88 00 16 	brls	80003586 <phy_rx_func+0x926>
							{
								RxAMBE_IsFillingNext8 = 0;
8000355e:	30 09       	mov	r9,0
80003560:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
80003562:	fe f6 05 b6 	ld.w	r6,pc[1462]
80003566:	6c 0c       	ld.w	r12,r6[0x0]
80003568:	f0 1f 01 77 	mcall	80003b44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
8000356c:	fe f8 05 a4 	ld.w	r8,pc[1444]
80003570:	70 0c       	ld.w	r12,r8[0x0]
80003572:	f0 1f 01 62 	mcall	80003af8 <phy_rx_func+0xe98>
80003576:	8d 0c       	st.w	r6[0x0],r12
								if(NULL == AMBE_payload_ptr)
80003578:	c0 71       	brne	80003586 <phy_rx_func+0x926>
								{
									RxMediaState = WAITINGABAB;
8000357a:	30 09       	mov	r9,0
8000357c:	fe f8 05 a0 	ld.w	r8,pc[1440]
80003580:	91 09       	st.w	r8[0x0],r9
80003582:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
80003586:	fe f9 05 9e 	ld.w	r9,pc[1438]
8000358a:	72 08       	ld.w	r8,r9[0x0]
8000358c:	20 18       	sub	r8,1
8000358e:	93 08       	st.w	r9[0x0],r8
80003590:	c0 71       	brne	8000359e <phy_rx_func+0x93e>
								RxMediaState = WAITINGABAB;
80003592:	30 09       	mov	r9,0
80003594:	fe f8 05 88 	ld.w	r8,pc[1416]
80003598:	91 09       	st.w	r8[0x0],r9
8000359a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
							
							AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//6
8000359e:	fe f8 05 9e 	ld.w	r8,pc[1438]
800035a2:	fe f9 05 76 	ld.w	r9,pc[1398]
800035a6:	72 0a       	ld.w	r10,r9[0x0]
800035a8:	70 09       	ld.w	r9,r8[0x0]
800035aa:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800035ae:	f4 09 0b 0b 	st.b	r10[r9],r11
							RxAMBE_IsFillingNext8 += 1;
800035b2:	70 09       	ld.w	r9,r8[0x0]
800035b4:	2f f9       	sub	r9,-1
800035b6:	91 09       	st.w	r8[0x0],r9
							
							if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800035b8:	e0 49 01 ff 	cp.w	r9,511
800035bc:	e0 88 00 16 	brls	800035e8 <phy_rx_func+0x988>
							{
								RxAMBE_IsFillingNext8 = 0;
800035c0:	30 09       	mov	r9,0
800035c2:	91 09       	st.w	r8[0x0],r9
								payload_rx(AMBE_payload_ptr);
800035c4:	fe f7 05 54 	ld.w	r7,pc[1364]
800035c8:	6e 0c       	ld.w	r12,r7[0x0]
800035ca:	f0 1f 01 5f 	mcall	80003b44 <phy_rx_func+0xee4>
								AMBE_payload_ptr = get_payload_idle_isr();
800035ce:	fe f8 05 42 	ld.w	r8,pc[1346]
800035d2:	70 0c       	ld.w	r12,r8[0x0]
800035d4:	f0 1f 01 49 	mcall	80003af8 <phy_rx_func+0xe98>
800035d8:	8f 0c       	st.w	r7[0x0],r12
								if(NULL == AMBE_payload_ptr)
800035da:	c0 71       	brne	800035e8 <phy_rx_func+0x988>
								{
									RxMediaState = WAITINGABAB;
800035dc:	30 09       	mov	r9,0
800035de:	fe f8 05 3e 	ld.w	r8,pc[1342]
800035e2:	91 09       	st.w	r8[0x0],r9
800035e4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
									break;
								}
							}
							if ((RxBytesWaiting -= 1) <= 0){
800035e8:	fe f9 05 3c 	ld.w	r9,pc[1340]
800035ec:	72 08       	ld.w	r8,r9[0x0]
800035ee:	20 18       	sub	r8,1
800035f0:	93 08       	st.w	r9[0x0],r8
800035f2:	e0 81 02 74 	brne	80003ada <phy_rx_func+0xe7a>
								RxMediaState = WAITINGABAB;
800035f6:	30 09       	mov	r9,0
800035f8:	fe f8 05 24 	ld.w	r8,pc[1316]
800035fc:	91 09       	st.w	r8[0x0],r9
800035fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							//}
							
						}
						else//error
						{
							RxMediaState = WAITINGABAB;
80003602:	30 09       	mov	r9,0
80003604:	fe f8 05 18 	ld.w	r8,pc[1304]
80003608:	91 09       	st.w	r8[0x0],r9
8000360a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
					}
					else if (Item_ID == Post_Voice_Encoder_Data)//(bit48~Pad-bits)
8000360e:	fe f8 05 26 	ld.w	r8,pc[1318]
80003612:	11 89       	ld.ub	r9,r8[0x0]
80003614:	3f 28       	mov	r8,-14
80003616:	f0 09 18 00 	cp.b	r9,r8
8000361a:	c4 31       	brne	800036a0 <phy_rx_func+0xa40>
					{
					
						AMBEBurst_rawdata[3] = payload_rx_channel->word[0];//(bit48~Pad-bits)
8000361c:	8e 49       	ld.sh	r9,r7[0x8]
8000361e:	fe f8 05 56 	ld.w	r8,pc[1366]
80003622:	b0 39       	st.h	r8[0x6],r9
						//AMBE_Per_Burst_Flag = 1;
						
						//根据MOTO.bit文件数据分布，建议测试pad-bits的最后一个字节不保存。
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//7
80003624:	fe f8 05 18 	ld.w	r8,pc[1304]
80003628:	fe f9 04 f0 	ld.w	r9,pc[1264]
8000362c:	72 0a       	ld.w	r10,r9[0x0]
8000362e:	70 09       	ld.w	r9,r8[0x0]
80003630:	ef 3b 00 08 	ld.ub	r11,r7[8]
80003634:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003638:	70 09       	ld.w	r9,r8[0x0]
8000363a:	2f f9       	sub	r9,-1
8000363c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000363e:	e0 49 01 ff 	cp.w	r9,511
80003642:	e0 88 00 16 	brls	8000366e <phy_rx_func+0xa0e>
						{
							RxAMBE_IsFillingNext8 = 0;
80003646:	30 09       	mov	r9,0
80003648:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000364a:	fe f7 04 ce 	ld.w	r7,pc[1230]
8000364e:	6e 0c       	ld.w	r12,r7[0x0]
80003650:	f0 1f 01 3d 	mcall	80003b44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003654:	fe f8 04 bc 	ld.w	r8,pc[1212]
80003658:	70 0c       	ld.w	r12,r8[0x0]
8000365a:	f0 1f 01 28 	mcall	80003af8 <phy_rx_func+0xe98>
8000365e:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003660:	c0 71       	brne	8000366e <phy_rx_func+0xa0e>
							{
								RxMediaState = WAITINGABAB;
80003662:	30 09       	mov	r9,0
80003664:	fe f8 04 b8 	ld.w	r8,pc[1208]
80003668:	91 09       	st.w	r8[0x0],r9
8000366a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000366e:	fe f9 04 b6 	ld.w	r9,pc[1206]
80003672:	72 08       	ld.w	r8,r9[0x0]
80003674:	20 18       	sub	r8,1
80003676:	93 08       	st.w	r9[0x0],r8
80003678:	c0 71       	brne	80003686 <phy_rx_func+0xa26>
							RxMediaState = WAITINGABAB;
8000367a:	30 09       	mov	r9,0
8000367c:	fe f8 04 a0 	ld.w	r8,pc[1184]
80003680:	91 09       	st.w	r8[0x0],r9
80003682:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
						if ((RxBytesWaiting -= 1) <= 0){//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
80003686:	20 18       	sub	r8,1
80003688:	fe f9 04 9c 	ld.w	r9,pc[1180]
8000368c:	93 08       	st.w	r9[0x0],r8
8000368e:	58 08       	cp.w	r8,0
80003690:	e0 81 02 25 	brne	80003ada <phy_rx_func+0xe7a>
							RxMediaState = WAITINGABAB;
80003694:	30 09       	mov	r9,0
80003696:	fe f8 04 86 	ld.w	r8,pc[1158]
8000369a:	91 09       	st.w	r8[0x0],r9
8000369c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
								
					}
					else if (Item_ID == Pre_Voice_Decoder_Data)//bit16~bit63
800036a0:	fe f8 04 94 	ld.w	r8,pc[1172]
800036a4:	11 89       	ld.ub	r9,r8[0x0]
800036a6:	3f 38       	mov	r8,-13
800036a8:	f0 09 18 00 	cp.b	r9,r8
800036ac:	e0 81 01 0c 	brne	800038c4 <phy_rx_func+0xc64>
					{
						//接收方的解压类型数据
						//For looping back to Radio
						AMBEBurst_rawdata[1] = payload_rx_channel->word[0];
800036b0:	8e 49       	ld.sh	r9,r7[0x8]
800036b2:	fe f8 04 c2 	ld.w	r8,pc[1218]
800036b6:	b0 19       	st.h	r8[0x2],r9
						AMBEBurst_rawdata[2] = payload_rx_channel->word[1];
800036b8:	8e 59       	ld.sh	r9,r7[0xa]
800036ba:	b0 29       	st.h	r8[0x4],r9
						AMBEBurst_rawdata[3] = payload_rx_channel->word[2];
800036bc:	8e 69       	ld.sh	r9,r7[0xc]
800036be:	b0 39       	st.h	r8[0x6],r9
						//if((m_RxBurstType == VOICEBURST_A) && (VF_SN == 1))
						//logFromISR("\n\r Pre_rx:%X\n\r", payload_rx_channel->word[2]);
						
						//To be tested. Also locally stored RAW-AMBER-DATA
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[0];//3
800036c0:	fe f8 04 7c 	ld.w	r8,pc[1148]
800036c4:	fe f9 04 54 	ld.w	r9,pc[1108]
800036c8:	72 0a       	ld.w	r10,r9[0x0]
800036ca:	70 09       	ld.w	r9,r8[0x0]
800036cc:	ef 3b 00 08 	ld.ub	r11,r7[8]
800036d0:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800036d4:	70 09       	ld.w	r9,r8[0x0]
800036d6:	2f f9       	sub	r9,-1
800036d8:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800036da:	e0 49 01 ff 	cp.w	r9,511
800036de:	e0 88 00 16 	brls	8000370a <phy_rx_func+0xaaa>
						{
							RxAMBE_IsFillingNext8 = 0;
800036e2:	30 09       	mov	r9,0
800036e4:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800036e6:	fe f6 04 32 	ld.w	r6,pc[1074]
800036ea:	6c 0c       	ld.w	r12,r6[0x0]
800036ec:	f0 1f 01 16 	mcall	80003b44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800036f0:	fe f8 04 20 	ld.w	r8,pc[1056]
800036f4:	70 0c       	ld.w	r12,r8[0x0]
800036f6:	f0 1f 01 01 	mcall	80003af8 <phy_rx_func+0xe98>
800036fa:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800036fc:	c0 71       	brne	8000370a <phy_rx_func+0xaaa>
							{
								RxMediaState = WAITINGABAB;
800036fe:	30 09       	mov	r9,0
80003700:	fe f8 04 1c 	ld.w	r8,pc[1052]
80003704:	91 09       	st.w	r8[0x0],r9
80003706:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000370a:	fe f9 04 1a 	ld.w	r9,pc[1050]
8000370e:	72 08       	ld.w	r8,r9[0x0]
80003710:	20 18       	sub	r8,1
80003712:	93 08       	st.w	r9[0x0],r8
80003714:	c0 71       	brne	80003722 <phy_rx_func+0xac2>
							RxMediaState = WAITINGABAB;
80003716:	30 09       	mov	r9,0
80003718:	fe f8 04 04 	ld.w	r8,pc[1028]
8000371c:	91 09       	st.w	r8[0x0],r9
8000371e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[1];//4
80003722:	fe f8 04 1a 	ld.w	r8,pc[1050]
80003726:	fe f9 03 f2 	ld.w	r9,pc[1010]
8000372a:	72 0a       	ld.w	r10,r9[0x0]
8000372c:	70 09       	ld.w	r9,r8[0x0]
8000372e:	ef 3b 00 09 	ld.ub	r11,r7[9]
80003732:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003736:	70 09       	ld.w	r9,r8[0x0]
80003738:	2f f9       	sub	r9,-1
8000373a:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000373c:	e0 49 01 ff 	cp.w	r9,511
80003740:	e0 88 00 16 	brls	8000376c <phy_rx_func+0xb0c>
						{
							RxAMBE_IsFillingNext8 = 0;
80003744:	30 09       	mov	r9,0
80003746:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
80003748:	fe f6 03 d0 	ld.w	r6,pc[976]
8000374c:	6c 0c       	ld.w	r12,r6[0x0]
8000374e:	f0 1f 00 fe 	mcall	80003b44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003752:	fe f8 03 be 	ld.w	r8,pc[958]
80003756:	70 0c       	ld.w	r12,r8[0x0]
80003758:	f0 1f 00 e8 	mcall	80003af8 <phy_rx_func+0xe98>
8000375c:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
8000375e:	c0 71       	brne	8000376c <phy_rx_func+0xb0c>
							{
								RxMediaState = WAITINGABAB;
80003760:	30 09       	mov	r9,0
80003762:	fe f8 03 ba 	ld.w	r8,pc[954]
80003766:	91 09       	st.w	r8[0x0],r9
80003768:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
8000376c:	fe f9 03 b8 	ld.w	r9,pc[952]
80003770:	72 08       	ld.w	r8,r9[0x0]
80003772:	20 18       	sub	r8,1
80003774:	93 08       	st.w	r9[0x0],r8
80003776:	c0 71       	brne	80003784 <phy_rx_func+0xb24>
							RxMediaState = WAITINGABAB;
80003778:	30 09       	mov	r9,0
8000377a:	fe f8 03 a2 	ld.w	r8,pc[930]
8000377e:	91 09       	st.w	r8[0x0],r9
80003780:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[2];//5
80003784:	fe f8 03 b8 	ld.w	r8,pc[952]
80003788:	fe f9 03 90 	ld.w	r9,pc[912]
8000378c:	72 0a       	ld.w	r10,r9[0x0]
8000378e:	70 09       	ld.w	r9,r8[0x0]
80003790:	ef 3b 00 0a 	ld.ub	r11,r7[10]
80003794:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
80003798:	70 09       	ld.w	r9,r8[0x0]
8000379a:	2f f9       	sub	r9,-1
8000379c:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000379e:	e0 49 01 ff 	cp.w	r9,511
800037a2:	e0 88 00 16 	brls	800037ce <phy_rx_func+0xb6e>
						{
							RxAMBE_IsFillingNext8 = 0;
800037a6:	30 09       	mov	r9,0
800037a8:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
800037aa:	fe f6 03 6e 	ld.w	r6,pc[878]
800037ae:	6c 0c       	ld.w	r12,r6[0x0]
800037b0:	f0 1f 00 e5 	mcall	80003b44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
800037b4:	fe f8 03 5c 	ld.w	r8,pc[860]
800037b8:	70 0c       	ld.w	r12,r8[0x0]
800037ba:	f0 1f 00 d0 	mcall	80003af8 <phy_rx_func+0xe98>
800037be:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
800037c0:	c0 71       	brne	800037ce <phy_rx_func+0xb6e>
							{
								RxMediaState = WAITINGABAB;
800037c2:	30 09       	mov	r9,0
800037c4:	fe f8 03 58 	ld.w	r8,pc[856]
800037c8:	91 09       	st.w	r8[0x0],r9
800037ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
800037ce:	fe f9 03 56 	ld.w	r9,pc[854]
800037d2:	72 08       	ld.w	r8,r9[0x0]
800037d4:	20 18       	sub	r8,1
800037d6:	93 08       	st.w	r9[0x0],r8
800037d8:	c0 71       	brne	800037e6 <phy_rx_func+0xb86>
							RxMediaState = WAITINGABAB;
800037da:	30 09       	mov	r9,0
800037dc:	fe f8 03 40 	ld.w	r8,pc[832]
800037e0:	91 09       	st.w	r8[0x0],r9
800037e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[3];//6
800037e6:	fe f8 03 56 	ld.w	r8,pc[854]
800037ea:	fe f9 03 2e 	ld.w	r9,pc[814]
800037ee:	72 0a       	ld.w	r10,r9[0x0]
800037f0:	70 09       	ld.w	r9,r8[0x0]
800037f2:	ef 3b 00 0b 	ld.ub	r11,r7[11]
800037f6:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
800037fa:	70 09       	ld.w	r9,r8[0x0]
800037fc:	2f f9       	sub	r9,-1
800037fe:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003800:	e0 49 01 ff 	cp.w	r9,511
80003804:	e0 88 00 16 	brls	80003830 <phy_rx_func+0xbd0>
						{
							RxAMBE_IsFillingNext8 = 0;
80003808:	30 09       	mov	r9,0
8000380a:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000380c:	fe f6 03 0c 	ld.w	r6,pc[780]
80003810:	6c 0c       	ld.w	r12,r6[0x0]
80003812:	f0 1f 00 cd 	mcall	80003b44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003816:	fe f8 02 fa 	ld.w	r8,pc[762]
8000381a:	70 0c       	ld.w	r12,r8[0x0]
8000381c:	f0 1f 00 b7 	mcall	80003af8 <phy_rx_func+0xe98>
80003820:	8d 0c       	st.w	r6[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003822:	c0 71       	brne	80003830 <phy_rx_func+0xbd0>
							{
								RxMediaState = WAITINGABAB;
80003824:	30 09       	mov	r9,0
80003826:	fe f8 02 f6 	ld.w	r8,pc[758]
8000382a:	91 09       	st.w	r8[0x0],r9
8000382c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003830:	fe f9 02 f4 	ld.w	r9,pc[756]
80003834:	72 08       	ld.w	r8,r9[0x0]
80003836:	20 18       	sub	r8,1
80003838:	93 08       	st.w	r9[0x0],r8
8000383a:	c0 71       	brne	80003848 <phy_rx_func+0xbe8>
							RxMediaState = WAITINGABAB;
8000383c:	30 09       	mov	r9,0
8000383e:	fe f8 02 de 	ld.w	r8,pc[734]
80003842:	91 09       	st.w	r8[0x0],r9
80003844:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[4];//7
80003848:	fe f8 02 f4 	ld.w	r8,pc[756]
8000384c:	fe f9 02 cc 	ld.w	r9,pc[716]
80003850:	72 0a       	ld.w	r10,r9[0x0]
80003852:	70 09       	ld.w	r9,r8[0x0]
80003854:	ef 3b 00 0c 	ld.ub	r11,r7[12]
80003858:	f4 09 0b 0b 	st.b	r10[r9],r11
						RxAMBE_IsFillingNext8 += 1;
8000385c:	70 09       	ld.w	r9,r8[0x0]
8000385e:	2f f9       	sub	r9,-1
80003860:	91 09       	st.w	r8[0x0],r9
						
						if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
80003862:	e0 49 01 ff 	cp.w	r9,511
80003866:	e0 88 00 16 	brls	80003892 <phy_rx_func+0xc32>
						{
							RxAMBE_IsFillingNext8 = 0;
8000386a:	30 09       	mov	r9,0
8000386c:	91 09       	st.w	r8[0x0],r9
							payload_rx(AMBE_payload_ptr);
8000386e:	fe f7 02 aa 	ld.w	r7,pc[682]
80003872:	6e 0c       	ld.w	r12,r7[0x0]
80003874:	f0 1f 00 b4 	mcall	80003b44 <phy_rx_func+0xee4>
							AMBE_payload_ptr = get_payload_idle_isr();
80003878:	fe f8 02 98 	ld.w	r8,pc[664]
8000387c:	70 0c       	ld.w	r12,r8[0x0]
8000387e:	f0 1f 00 9f 	mcall	80003af8 <phy_rx_func+0xe98>
80003882:	8f 0c       	st.w	r7[0x0],r12
							if(NULL == AMBE_payload_ptr)
80003884:	c0 71       	brne	80003892 <phy_rx_func+0xc32>
							{
								RxMediaState = WAITINGABAB;
80003886:	30 09       	mov	r9,0
80003888:	fe f8 02 94 	ld.w	r8,pc[660]
8000388c:	91 09       	st.w	r8[0x0],r9
8000388e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								break;
							}
						}
						if ((RxBytesWaiting -= 1) <= 0){
80003892:	fe f9 02 92 	ld.w	r9,pc[658]
80003896:	72 08       	ld.w	r8,r9[0x0]
80003898:	20 18       	sub	r8,1
8000389a:	93 08       	st.w	r9[0x0],r8
8000389c:	c0 71       	brne	800038aa <phy_rx_func+0xc4a>
							RxMediaState = WAITINGABAB;
8000389e:	30 09       	mov	r9,0
800038a0:	fe f8 02 7c 	ld.w	r8,pc[636]
800038a4:	91 09       	st.w	r8[0x0],r9
800038a6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}
						
						//此处丢弃AMBE Vocoder Bits Stream(bit59~63),不予保存
						if ((RxBytesWaiting -= 1) <= 0){
800038aa:	20 18       	sub	r8,1
800038ac:	fe f9 02 78 	ld.w	r9,pc[632]
800038b0:	93 08       	st.w	r9[0x0],r8
800038b2:	58 08       	cp.w	r8,0
800038b4:	e0 81 01 13 	brne	80003ada <phy_rx_func+0xe7a>
							
							//Soft decision bits are not require to route back to Radio, the OB can either route it back radio
							//or discard it to reduce payload size.
							
							RxMediaState = WAITINGABAB;
800038b8:	30 09       	mov	r9,0
800038ba:	fe f8 02 62 	ld.w	r8,pc[610]
800038be:	91 09       	st.w	r8[0x0],r9
800038c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
							break;
						}	
						
					}
					else if ((Item_ID == 0x04)  ||  (Item_ID == 0x03))//Unknown type data directly back hair
800038c4:	fe f8 02 70 	ld.w	r8,pc[624]
800038c8:	11 89       	ld.ub	r9,r8[0x0]
800038ca:	30 48       	mov	r8,4
800038cc:	f0 09 18 00 	cp.b	r9,r8
800038d0:	c0 80       	breq	800038e0 <phy_rx_func+0xc80>
800038d2:	fe f8 02 62 	ld.w	r8,pc[610]
800038d6:	11 89       	ld.ub	r9,r8[0x0]
800038d8:	30 38       	mov	r8,3
800038da:	f0 09 18 00 	cp.b	r9,r8
800038de:	c1 41       	brne	80003906 <phy_rx_func+0xca6>
					{
						AMBE_HT[0] = payload_rx_channel->dword[0];
800038e0:	6e 29       	ld.w	r9,r7[0x8]
800038e2:	fe f8 02 7a 	ld.w	r8,pc[634]
800038e6:	91 09       	st.w	r8[0x0],r9
						AMBE_HT[1] = payload_rx_channel->dword[1];				
800038e8:	6e 39       	ld.w	r9,r7[0xc]
800038ea:	91 19       	st.w	r8[0x4],r9
						
						if ((RxBytesWaiting -= 8) <= 0)//Consider two cases 0xABCDC014 and 0xABCDC010
800038ec:	fe f9 02 38 	ld.w	r9,pc[568]
800038f0:	72 08       	ld.w	r8,r9[0x0]
800038f2:	20 88       	sub	r8,8
800038f4:	93 08       	st.w	r9[0x0],r8
800038f6:	e0 81 00 f2 	brne	80003ada <phy_rx_func+0xe7a>
						{
					
							RxBytesWaiting = 0;
800038fa:	93 08       	st.w	r9[0x0],r8
							RxMediaState = WAITINGABAB;
800038fc:	fe f9 02 20 	ld.w	r9,pc[544]
80003900:	93 08       	st.w	r9[0x0],r8
80003902:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
						}
						break;

					}
					else if (Item_ID == Soft_Decision_Value)
80003906:	fe f8 02 2e 	ld.w	r8,pc[558]
8000390a:	11 89       	ld.ub	r9,r8[0x0]
8000390c:	31 38       	mov	r8,19
8000390e:	f0 09 18 00 	cp.b	r9,r8
80003912:	e0 81 00 9c 	brne	80003a4a <phy_rx_func+0xdea>
					{							
						if (SDV_Index == 12)
80003916:	fe f8 02 62 	ld.w	r8,pc[610]
8000391a:	11 88       	ld.ub	r8,r8[0x0]
8000391c:	30 c9       	mov	r9,12
8000391e:	f2 08 18 00 	cp.b	r8,r9
80003922:	e0 81 00 7b 	brne	80003a18 <phy_rx_func+0xdb8>
						{
							Soft_Decision_Data[SDV_Index]= payload_rx_channel->word[0];
80003926:	8e 49       	ld.sh	r9,r7[0x8]
80003928:	fe f8 02 54 	ld.w	r8,pc[596]
8000392c:	f1 59 00 18 	st.h	r8[24],r9
							
							SDV_Index = 0;
80003930:	30 09       	mov	r9,0
80003932:	fe f8 02 46 	ld.w	r8,pc[582]
80003936:	b0 89       	st.b	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003938:	ef 39 00 0d 	ld.ub	r9,r7[13]
8000393c:	3f 38       	mov	r8,-13
8000393e:	f0 09 18 00 	cp.b	r9,r8
80003942:	c6 61       	brne	80003a0e <phy_rx_func+0xdae>
							
							SDV_Index = 0;
								
							if (payload_rx_channel->byte[5] == Pre_Voice_Decoder_Data )//0xF3
							{
									Item_ID = Pre_Voice_Decoder_Data;
80003944:	10 99       	mov	r9,r8
80003946:	4f c8       	lddpc	r8,80003b34 <phy_rx_func+0xed4>
80003948:	b0 89       	st.b	r8[0x0],r9
									RxBytesWaiting = (payload_rx_channel->byte[4] & 0x7F);//Test calculations are correct; 8
8000394a:	ef 39 00 0c 	ld.ub	r9,r7[12]
8000394e:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003952:	4f 58       	lddpc	r8,80003b24 <phy_rx_func+0xec4>
80003954:	91 09       	st.w	r8[0x0],r9
									AMBE_rx_flag = 1;//本地作为AMBE数据的解密方
80003956:	30 19       	mov	r9,1
80003958:	fe f8 02 0c 	ld.w	r8,pc[524]
8000395c:	b0 89       	st.b	r8[0x0],r9
		
									AMBEBurst_rawdata[0] = payload_rx_channel->word[3];//用于解密的中间数据变量
8000395e:	8e 79       	ld.sh	r9,r7[0xe]
80003960:	fe f8 02 14 	ld.w	r8,pc[532]
80003964:	b0 09       	st.h	r8[0x0],r9
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[6];//1
80003966:	4f 68       	lddpc	r8,80003b3c <phy_rx_func+0xedc>
80003968:	4e c9       	lddpc	r9,80003b18 <phy_rx_func+0xeb8>
8000396a:	72 0a       	ld.w	r10,r9[0x0]
8000396c:	70 09       	ld.w	r9,r8[0x0]
8000396e:	ef 3b 00 0e 	ld.ub	r11,r7[14]
80003972:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
80003976:	70 09       	ld.w	r9,r8[0x0]
80003978:	2f f9       	sub	r9,-1
8000397a:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
8000397c:	e0 49 01 ff 	cp.w	r9,511
80003980:	e0 88 00 13 	brls	800039a6 <phy_rx_func+0xd46>
									{
										RxAMBE_IsFillingNext8 = 0;
80003984:	30 09       	mov	r9,0
80003986:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
80003988:	4e 46       	lddpc	r6,80003b18 <phy_rx_func+0xeb8>
8000398a:	6c 0c       	ld.w	r12,r6[0x0]
8000398c:	f0 1f 00 6e 	mcall	80003b44 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
80003990:	4e 08       	lddpc	r8,80003b10 <phy_rx_func+0xeb0>
80003992:	70 0c       	ld.w	r12,r8[0x0]
80003994:	f0 1f 00 59 	mcall	80003af8 <phy_rx_func+0xe98>
80003998:	8d 0c       	st.w	r6[0x0],r12
										if(NULL == AMBE_payload_ptr)
8000399a:	c0 61       	brne	800039a6 <phy_rx_func+0xd46>
										{
											RxMediaState = WAITINGABAB;
8000399c:	30 09       	mov	r9,0
8000399e:	4e 08       	lddpc	r8,80003b1c <phy_rx_func+0xebc>
800039a0:	91 09       	st.w	r8[0x0],r9
800039a2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800039a6:	4e 09       	lddpc	r9,80003b24 <phy_rx_func+0xec4>
800039a8:	72 08       	ld.w	r8,r9[0x0]
800039aa:	20 18       	sub	r8,1
800039ac:	93 08       	st.w	r9[0x0],r8
800039ae:	c0 61       	brne	800039ba <phy_rx_func+0xd5a>
										RxMediaState = WAITINGABAB;
800039b0:	30 09       	mov	r9,0
800039b2:	4d b8       	lddpc	r8,80003b1c <phy_rx_func+0xebc>
800039b4:	91 09       	st.w	r8[0x0],r9
800039b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
									AMBE_payload_ptr[RxAMBE_IsFillingNext8] = payload_rx_channel->byte[7];//2
800039ba:	4e 18       	lddpc	r8,80003b3c <phy_rx_func+0xedc>
800039bc:	4d 79       	lddpc	r9,80003b18 <phy_rx_func+0xeb8>
800039be:	72 0a       	ld.w	r10,r9[0x0]
800039c0:	70 09       	ld.w	r9,r8[0x0]
800039c2:	ef 3b 00 0f 	ld.ub	r11,r7[15]
800039c6:	f4 09 0b 0b 	st.b	r10[r9],r11
									RxAMBE_IsFillingNext8 += 1;
800039ca:	70 09       	ld.w	r9,r8[0x0]
800039cc:	2f f9       	sub	r9,-1
800039ce:	91 09       	st.w	r8[0x0],r9
									
									if (RxAMBE_IsFillingNext8 >= (2*MAX_PAYLOAD_BUFF_SIZE))
800039d0:	e0 49 01 ff 	cp.w	r9,511
800039d4:	e0 88 00 13 	brls	800039fa <phy_rx_func+0xd9a>
									{
										RxAMBE_IsFillingNext8 = 0;
800039d8:	30 09       	mov	r9,0
800039da:	91 09       	st.w	r8[0x0],r9
										payload_rx(AMBE_payload_ptr);
800039dc:	4c f7       	lddpc	r7,80003b18 <phy_rx_func+0xeb8>
800039de:	6e 0c       	ld.w	r12,r7[0x0]
800039e0:	f0 1f 00 59 	mcall	80003b44 <phy_rx_func+0xee4>
										AMBE_payload_ptr = get_payload_idle_isr();
800039e4:	4c b8       	lddpc	r8,80003b10 <phy_rx_func+0xeb0>
800039e6:	70 0c       	ld.w	r12,r8[0x0]
800039e8:	f0 1f 00 44 	mcall	80003af8 <phy_rx_func+0xe98>
800039ec:	8f 0c       	st.w	r7[0x0],r12
										if(NULL == AMBE_payload_ptr)
800039ee:	c0 61       	brne	800039fa <phy_rx_func+0xd9a>
										{
											RxMediaState = WAITINGABAB;
800039f0:	30 09       	mov	r9,0
800039f2:	4c b8       	lddpc	r8,80003b1c <phy_rx_func+0xebc>
800039f4:	91 09       	st.w	r8[0x0],r9
800039f6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
											break;
										}
									}
									if ((RxBytesWaiting -= 1) <= 0){
800039fa:	4c b9       	lddpc	r9,80003b24 <phy_rx_func+0xec4>
800039fc:	72 08       	ld.w	r8,r9[0x0]
800039fe:	20 18       	sub	r8,1
80003a00:	93 08       	st.w	r9[0x0],r8
80003a02:	c6 c1       	brne	80003ada <phy_rx_func+0xe7a>
										RxMediaState = WAITINGABAB;
80003a04:	30 09       	mov	r9,0
80003a06:	4c 68       	lddpc	r8,80003b1c <phy_rx_func+0xebc>
80003a08:	91 09       	st.w	r8[0x0],r9
80003a0a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
										break;
									}
									
							}
							else
							RxMediaState = WAITINGABAB;
80003a0e:	30 09       	mov	r9,0
80003a10:	4c 38       	lddpc	r8,80003b1c <phy_rx_func+0xebc>
80003a12:	91 09       	st.w	r8[0x0],r9
80003a14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
								
						}
						else
						{
									
							Soft_Decision_Data[SDV_Index]	  = payload_rx_channel->word[0];
80003a18:	8e 4a       	ld.sh	r10,r7[0x8]
80003a1a:	4d 99       	lddpc	r9,80003b7c <phy_rx_func+0xf1c>
80003a1c:	f2 08 0a 1a 	st.h	r9[r8<<0x1],r10
							Soft_Decision_Data[SDV_Index+1]	  = payload_rx_channel->word[1];
80003a20:	4d 6a       	lddpc	r10,80003b78 <phy_rx_func+0xf18>
80003a22:	15 88       	ld.ub	r8,r10[0x0]
80003a24:	f0 cb ff ff 	sub	r11,r8,-1
80003a28:	8e 5c       	ld.sh	r12,r7[0xa]
80003a2a:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+2]	  = payload_rx_channel->word[2];
80003a2e:	f0 cb ff fe 	sub	r11,r8,-2
80003a32:	8e 6c       	ld.sh	r12,r7[0xc]
80003a34:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							Soft_Decision_Data[SDV_Index+3]	  = payload_rx_channel->word[3];
80003a38:	f0 cb ff fd 	sub	r11,r8,-3
80003a3c:	8e 7c       	ld.sh	r12,r7[0xe]
80003a3e:	f2 0b 0a 1c 	st.h	r9[r11<<0x1],r12
							SDV_Index +=4;
80003a42:	2f c8       	sub	r8,-4
80003a44:	b4 88       	st.b	r10[0x0],r8
80003a46:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					
					else
					{
						
						RxMediaState  = WAITINGABAB;
80003a4a:	30 09       	mov	r9,0
80003a4c:	4b 48       	lddpc	r8,80003b1c <phy_rx_func+0xebc>
80003a4e:	91 09       	st.w	r8[0x0],r9
80003a50:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
			
		break;//End of READING_AMBE_MEDIA.

        case READING_AMBE_AUX:
			
				Radio_Internal_Data[RxData_IsFillingNext16] = payload_rx_channel->word[0];
80003a54:	4c 08       	lddpc	r8,80003b54 <phy_rx_func+0xef4>
80003a56:	70 09       	ld.w	r9,r8[0x0]
80003a58:	8e 4b       	ld.sh	r11,r7[0x8]
80003a5a:	4c 0a       	lddpc	r10,80003b58 <phy_rx_func+0xef8>
80003a5c:	f4 09 0a 1b 	st.h	r10[r9<<0x1],r11
				RxData_IsFillingNext16 += 1;
80003a60:	2f f9       	sub	r9,-1
80003a62:	91 09       	st.w	r8[0x0],r9
			
				if ((Item_Length -= 2) <= 0)
80003a64:	4b 58       	lddpc	r8,80003b38 <phy_rx_func+0xed8>
80003a66:	70 09       	ld.w	r9,r8[0x0]
80003a68:	20 29       	sub	r9,2
80003a6a:	91 09       	st.w	r8[0x0],r9
80003a6c:	70 08       	ld.w	r8,r8[0x0]
80003a6e:	58 08       	cp.w	r8,0
80003a70:	c2 f1       	brne	80003ace <phy_rx_func+0xe6e>
				{
					RxData_IsFillingNext16 = 0;
80003a72:	30 09       	mov	r9,0
80003a74:	4b 88       	lddpc	r8,80003b54 <phy_rx_func+0xef4>
80003a76:	91 09       	st.w	r8[0x0],r9
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003a78:	8e 59       	ld.sh	r9,r7[0xa]
80003a7a:	fe 78 82 12 	mov	r8,-32238
80003a7e:	f0 09 19 00 	cp.h	r9,r8
80003a82:	c2 11       	brne	80003ac4 <phy_rx_func+0xe64>
					{
						//Item_ID = Vocoder_Bit_Stream_Parameter;
						//Vocoder Bits Stream Parameter
						//Its value ranges from 1 to 18 for one voice superframe contains 6 voice bursts
						// and each burst contains 3 VFs.
						VF_SN = (payload_rx_channel->byte[5] & 0x1F);//This parameter is very important to the loop back Radio, as a reference.
80003a84:	ef 3c 00 0d 	ld.ub	r12,r7[13]
80003a88:	f9 dc c0 05 	bfextu	r12,r12,0x0,0x5
80003a8c:	4a f8       	lddpc	r8,80003b48 <phy_rx_func+0xee8>
80003a8e:	b0 8c       	st.b	r8[0x0],r12
							
						VBSP_data[0] = payload_rx_channel->word[1];
80003a90:	8e 59       	ld.sh	r9,r7[0xa]
80003a92:	4a f8       	lddpc	r8,80003b4c <phy_rx_func+0xeec>
80003a94:	b0 09       	st.h	r8[0x0],r9
						VBSP_data[1] = payload_rx_channel->word[2];
80003a96:	8e 69       	ld.sh	r9,r7[0xc]
80003a98:	b0 19       	st.h	r8[0x2],r9
							
						m_RxBurstType = CalculateBurst(VF_SN);
80003a9a:	f0 1f 00 2e 	mcall	80003b50 <phy_rx_func+0xef0>
80003a9e:	4a 18       	lddpc	r8,80003b20 <phy_rx_func+0xec0>
80003aa0:	91 0c       	st.w	r8[0x0],r12
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	//if(NULL != phy_payload_frame_rx)
	{
		/*receive ssc data in payload frame*/
		phy_payload_rx(&(((ssc_fragment_t * )ssc)->payload_channel));
80003aa2:	ef 39 00 0f 	ld.ub	r9,r7[15]
80003aa6:	31 38       	mov	r8,19
80003aa8:	f0 09 18 00 	cp.b	r9,r8
80003aac:	c0 71       	brne	80003aba <phy_rx_func+0xe5a>
							
						m_RxBurstType = CalculateBurst(VF_SN);
						
						if (payload_rx_channel->byte[7] == Soft_Decision_Value)//0x13
						{
							Item_ID = Soft_Decision_Value;	
80003aae:	10 99       	mov	r9,r8
80003ab0:	4a 18       	lddpc	r8,80003b34 <phy_rx_func+0xed4>
80003ab2:	b0 89       	st.b	r8[0x0],r9
							RxBytesWaiting = ((payload_rx_channel->dword[1] & 0x00007F00) >>24);//Test calculations are correct; 26
80003ab4:	30 09       	mov	r9,0
80003ab6:	49 c8       	lddpc	r8,80003b24 <phy_rx_func+0xec4>
80003ab8:	91 09       	st.w	r8[0x0],r9
						else
						{//error
								RxMediaState = WAITINGABAB;//Jump
						}
							
						RxMediaState = READING_AMBE_MEDIA;//Jump
80003aba:	30 49       	mov	r9,4
80003abc:	49 88       	lddpc	r8,80003b1c <phy_rx_func+0xebc>
80003abe:	91 09       	st.w	r8[0x0],r9
80003ac0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}
					else
					{
						RxMediaState = WAITINGABAB;//Jump
80003ac4:	30 09       	mov	r9,0
80003ac6:	49 68       	lddpc	r8,80003b1c <phy_rx_func+0xebc>
80003ac8:	91 09       	st.w	r8[0x0],r9
80003aca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
					}

				}
				else
				{//测试看看是几个字节数据
					logFromISR("\n\r Radio Internal parameter length error \n\r");
80003ace:	4a dc       	lddpc	r12,80003b80 <phy_rx_func+0xf20>
80003ad0:	f0 1f 00 18 	mcall	80003b30 <phy_rx_func+0xed0>
					RxMediaState = WAITINGABAB;//Jump
80003ad4:	30 09       	mov	r9,0
80003ad6:	49 28       	lddpc	r8,80003b1c <phy_rx_func+0xebc>
80003ad8:	91 09       	st.w	r8[0x0],r9
80003ada:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003ade:	00 00       	add	r0,r0
80003ae0:	00 00       	add	r0,r0
80003ae2:	0a bc       	st.h	r5++,r12
80003ae4:	00 00       	add	r0,r0
80003ae6:	0a d4       	st.w	--r5,r4
80003ae8:	00 00       	add	r0,r0
80003aea:	0a b4       	st.h	r5++,r4
80003aec:	00 00       	add	r0,r0
80003aee:	0a 96       	mov	r6,r5
80003af0:	00 00       	add	r0,r0
80003af2:	0a 84       	andn	r4,r5
80003af4:	00 00       	add	r0,r0
80003af6:	0a ac       	st.w	r5++,r12
80003af8:	80 00       	ld.sh	r0,r0[0x0]
80003afa:	2a e0       	sub	r0,-82
80003afc:	00 00       	add	r0,r0
80003afe:	0a a4       	st.w	r5++,r4
80003b00:	80 00       	ld.sh	r0,r0[0x0]
80003b02:	29 f8       	sub	r8,-97
80003b04:	00 00       	add	r0,r0
80003b06:	0a b8       	st.h	r5++,r8
80003b08:	80 00       	ld.sh	r0,r0[0x0]
80003b0a:	2a 2c       	sub	r12,-94
80003b0c:	00 00       	add	r0,r0
80003b0e:	0a 95       	mov	r5,r5
80003b10:	00 00       	add	r0,r0
80003b12:	0a b0       	st.h	r5++,r0
80003b14:	00 00       	add	r0,r0
80003b16:	0a c0       	st.b	r5++,r0
80003b18:	00 00       	add	r0,r0
80003b1a:	0a 98       	mov	r8,r5
80003b1c:	00 00       	add	r0,r0
80003b1e:	0a e0       	st.h	--r5,r0
80003b20:	00 00       	add	r0,r0
80003b22:	0a c8       	st.b	r5++,r8
80003b24:	00 00       	add	r0,r0
80003b26:	0a 80       	andn	r0,r5
80003b28:	00 00       	add	r0,r0
80003b2a:	0a 5c       	eor	r12,r5
80003b2c:	80 00       	ld.sh	r0,r0[0x0]
80003b2e:	d9 68       	*unknown*
80003b30:	80 00       	ld.sh	r0,r0[0x0]
80003b32:	74 0c       	ld.w	r12,r10[0x0]
80003b34:	00 00       	add	r0,r0
80003b36:	0a 94       	mov	r4,r5
80003b38:	00 00       	add	r0,r0
80003b3a:	0a ec       	st.h	--r5,r12
80003b3c:	00 00       	add	r0,r0
80003b3e:	0a cc       	st.b	r5++,r12
80003b40:	80 00       	ld.sh	r0,r0[0x0]
80003b42:	7c 6a       	ld.w	r10,lr[0x18]
80003b44:	80 00       	ld.sh	r0,r0[0x0]
80003b46:	2a 14       	sub	r4,-95
80003b48:	00 00       	add	r0,r0
80003b4a:	0a 52       	eor	r2,r5
80003b4c:	00 00       	add	r0,r0
80003b4e:	21 8c       	sub	r12,24
80003b50:	80 00       	ld.sh	r0,r0[0x0]
80003b52:	29 c8       	sub	r8,-100
80003b54:	00 00       	add	r0,r0
80003b56:	0a 88       	andn	r8,r5
80003b58:	00 00       	add	r0,r0
80003b5a:	20 90       	sub	r0,9
80003b5c:	00 00       	add	r0,r0
80003b5e:	0a 8c       	andn	r12,r5
80003b60:	00 00       	add	r0,r0
80003b62:	0a 53       	eor	r3,r5
80003b64:	00 00       	add	r0,r0
80003b66:	0a 51       	eor	r1,r5
80003b68:	00 00       	add	r0,r0
80003b6a:	0a e4       	st.h	--r5,r4
80003b6c:	00 00       	add	r0,r0
80003b6e:	0a a0       	st.w	r5++,r0
80003b70:	00 00       	add	r0,r0
80003b72:	0a 6d       	and	sp,r5
80003b74:	00 00       	add	r0,r0
80003b76:	20 88       	sub	r8,8
80003b78:	00 00       	add	r0,r0
80003b7a:	0a d8       	st.w	--r5,r8
80003b7c:	00 00       	add	r0,r0
80003b7e:	21 90       	sub	r0,25
80003b80:	80 00       	ld.sh	r0,r0[0x0]
80003b82:	d9 80       	acall	0x98

80003b84 <pdca_int_handler>:
    void (*phy_rx_exec)(void *)--callback function for receive SSC data 
Called By: interrupt
*/
__attribute__((__interrupt__))
static void pdca_int_handler(void)
{
80003b84:	d4 01       	pushm	lr
    
	//intStartCount = Get_system_register(AVR32_COUNT);
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
80003b86:	49 88       	lddpc	r8,80003be4 <pdca_int_handler+0x60>
80003b88:	11 89       	ld.ub	r9,r8[0x0]
80003b8a:	ec 19 00 01 	eorl	r9,0x1
80003b8e:	b0 89       	st.b	r8[0x0],r9
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);
80003b90:	11 89       	ld.ub	r9,r8[0x0]
80003b92:	a5 69       	lsl	r9,0x4
80003b94:	2f c9       	sub	r9,-4
80003b96:	49 5a       	lddpc	r10,80003be8 <pdca_int_handler+0x64>
80003b98:	14 09       	add	r9,r10
	
	/*Toggle Index*/
    BufferIndex ^= 0x01;
	
	/*Software reset PDCA */
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr 
80003b9a:	fe 7a 00 40 	mov	r10,-65472
80003b9e:	95 39       	st.w	r10[0xc],r9
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003ba0:	30 39       	mov	r9,3
80003ba2:	95 49       	st.w	r10[0x10],r9

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);
80003ba4:	11 8a       	ld.ub	r10,r8[0x0]
80003ba6:	a5 6a       	lsl	r10,0x4
80003ba8:	2f ca       	sub	r10,-4
80003baa:	49 18       	lddpc	r8,80003bec <pdca_int_handler+0x68>
80003bac:	10 0a       	add	r10,r8
                              = (U32)(&TxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr 
80003bae:	fe 78 00 00 	mov	r8,-65536
80003bb2:	91 3a       	st.w	r8[0xc],r10
                              = (U32)(&RxBuffer[BufferIndex].xnl_channel.dword);

    /*Three words xfered each DMA.*/
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003bb4:	91 49       	st.w	r8[0x10],r9
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr;
80003bb6:	70 b8       	ld.w	r8,r8[0x2c]
	
	/*receive SSC data*/
    if(phy_rx_exec != NULL)phy_rx_exec((void *)&RxBuffer[BufferIndex]);
80003bb8:	48 e8       	lddpc	r8,80003bf0 <pdca_int_handler+0x6c>
80003bba:	70 08       	ld.w	r8,r8[0x0]
80003bbc:	58 08       	cp.w	r8,0
80003bbe:	c0 70       	breq	80003bcc <pdca_int_handler+0x48>
80003bc0:	48 99       	lddpc	r9,80003be4 <pdca_int_handler+0x60>
80003bc2:	13 89       	ld.ub	r9,r9[0x0]
80003bc4:	a5 69       	lsl	r9,0x4
80003bc6:	48 ac       	lddpc	r12,80003bec <pdca_int_handler+0x68>
80003bc8:	12 0c       	add	r12,r9
80003bca:	5d 18       	icall	r8

    /*transmit SSC data*/

	if(phy_tx_exec != NULL)phy_tx_exec((void *)&TxBuffer[BufferIndex]);//phy_tx_func, phy_rx_func
80003bcc:	48 a8       	lddpc	r8,80003bf4 <pdca_int_handler+0x70>
80003bce:	70 08       	ld.w	r8,r8[0x0]
80003bd0:	58 08       	cp.w	r8,0
80003bd2:	c0 70       	breq	80003be0 <pdca_int_handler+0x5c>
80003bd4:	48 49       	lddpc	r9,80003be4 <pdca_int_handler+0x60>
80003bd6:	13 89       	ld.ub	r9,r9[0x0]
80003bd8:	a5 69       	lsl	r9,0x4
80003bda:	48 4c       	lddpc	r12,80003be8 <pdca_int_handler+0x64>
80003bdc:	12 0c       	add	r12,r9
80003bde:	5d 18       	icall	r8

	
	//intDuration = Get_system_register(AVR32_COUNT) - intStartCount;
	
	
}/*End of pdca_int_handler.*/
80003be0:	d4 02       	popm	lr
80003be2:	d6 03       	rete
80003be4:	00 00       	add	r0,r0
80003be6:	53 b0       	stdsp	sp[0xec],r0
80003be8:	00 00       	add	r0,r0
80003bea:	53 d8       	stdsp	sp[0xf4],r8
80003bec:	00 00       	add	r0,r0
80003bee:	53 b8       	stdsp	sp[0xec],r8
80003bf0:	00 00       	add	r0,r0
80003bf2:	0a f0       	st.b	--r5,r0
80003bf4:	00 00       	add	r0,r0
80003bf6:	0a f4       	st.b	--r5,r4

80003bf8 <local_start_SSC>:
void local_start_SSC(void)
{
    /*Assign GPIO to SSC.
    gpio_enable_module
    gpio_enable_module_pin*/
    AVR32_GPIO.port[1].pmr0c = 0x00000DC0;
80003bf8:	fe 78 10 00 	mov	r8,-61440
80003bfc:	e0 69 0d c0 	mov	r9,3520
80003c00:	f1 49 01 18 	st.w	r8[280],r9
    AVR32_GPIO.port[1].pmr1c = 0x00000DC0;
80003c04:	f1 49 01 28 	st.w	r8[296],r9
    AVR32_GPIO.port[1].gperc = 0x00000DC0;
80003c08:	f1 49 01 08 	st.w	r8[264],r9

    /*Software reset SSC*/
    (&AVR32_SSC)->cr = AVR32_SSC_CR_SWRST_MASK;
80003c0c:	fe 78 34 00 	mov	r8,-52224
80003c10:	e0 69 80 00 	mov	r9,32768
80003c14:	91 09       	st.w	r8[0x0],r9
    (&AVR32_SSC)->cmr 
80003c16:	30 09       	mov	r9,0
80003c18:	91 19       	st.w	r8[0x4],r9
                     = AVR32_SSC_CMR_DIV_NOT_ACTIVE << AVR32_SSC_CMR_DIV_OFFSET;

    /*For Slave*/
    (&AVR32_SSC)->tcmr =
80003c1a:	e0 69 04 21 	mov	r9,1057
80003c1e:	ea 19 3f 20 	orh	r9,0x3f20
80003c22:	91 69       	st.w	r8[0x18],r9
	      32								<< AVR32_SSC_TCMR_STTDLY_OFFSET	|
	      63								<< AVR32_SSC_TCMR_PERIOD_OFFSET;


    /*For Slave*/
    (&AVR32_SSC)->tfmr = 
80003c24:	e0 69 02 9f 	mov	r9,671
80003c28:	ea 19 01 00 	orh	r9,0x100
80003c2c:	91 79       	st.w	r8[0x1c],r9
	     0									<< AVR32_SSC_TFMR_FSDEN_OFFSET	|
	     1									<< AVR32_SSC_TFMR_FSEDGE_OFFSET;

	/*For Slave*/

	(&AVR32_SSC)->rcmr = 
80003c2e:	e0 6a 04 02 	mov	r10,1026
80003c32:	ea 1a 3f 20 	orh	r10,0x3f20
80003c36:	91 4a       	st.w	r8[0x10],r10
	     0									<< AVR32_SSC_RCMR_STOP_OFFSET	|
	     32									<< AVR32_SSC_RCMR_STTDLY_OFFSET	|
	     63									<< AVR32_SSC_RCMR_PERIOD_OFFSET;

	/*For Slave*/
	(&AVR32_SSC)->rfmr = 
80003c38:	91 59       	st.w	r8[0x14],r9
	    1									<< AVR32_SSC_RFMR_MSBF_OFFSET	|
	    2									<< AVR32_SSC_RFMR_DATNB_OFFSET	|
	    0									<< AVR32_SSC_RFMR_FSLEN_OFFSET	|
	    AVR32_SSC_RFMR_FSOS_INPUT_ONLY		<< AVR32_SSC_RFMR_FSOS_OFFSET	|
	    1									<< AVR32_SSC_RFMR_FSEDGE_OFFSET;
}/*End of local_start_SSC.*/
80003c3a:	5e fc       	retal	r12

80003c3c <local_start_PDC>:
Function: local_start_PDC
Description: none
Called By: void ssc_init(void) -- ssc.c
*/
void local_start_PDC(void)
{
80003c3c:	d4 01       	pushm	lr
    /*Toggle Index*/	
    BufferIndex = 1;
80003c3e:	30 19       	mov	r9,1
80003c40:	49 78       	lddpc	r8,80003c9c <local_start_PDC+0x60>
80003c42:	b0 89       	st.b	r8[0x0],r9
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
80003c44:	fe 78 00 00 	mov	r8,-65536
80003c48:	30 7b       	mov	r11,7
80003c4a:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
80003c4c:	70 b9       	ld.w	r9,r8[0x2c]
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
80003c4e:	49 59       	lddpc	r9,80003ca0 <local_start_PDC+0x64>
80003c50:	f2 ca ff fc 	sub	r10,r9,-4
    BufferIndex = 1;
	
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->isr; 
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
80003c54:	91 0a       	st.w	r8[0x0],r10
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
80003c56:	30 3a       	mov	r10,3
80003c58:	91 2a       	st.w	r8[0x8],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
80003c5a:	30 1c       	mov	r12,1
80003c5c:	91 1c       	st.w	r8[0x4],r12
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
80003c5e:	2e c9       	sub	r9,-20
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mar = 
                                          (U32)(&RxBuffer[0].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcr = 3;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->psr = 
                                                          AVR32_PDCA_PID_SSC_RX;
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->marr = 
80003c60:	91 39       	st.w	r8[0xc],r9
                                          (U32)(&RxBuffer[1].xnl_channel.dword);
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->tcrr = 3;
80003c62:	91 4a       	st.w	r8[0x10],r10
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c64:	30 2c       	mov	r12,2
80003c66:	91 6c       	st.w	r8[0x18],r12

	TxBuffer[0].xnl_channel.dword = XNL_IDLE;
80003c68:	48 f9       	lddpc	r9,80003ca4 <local_start_PDC+0x68>
80003c6a:	e0 68 5a 5a 	mov	r8,23130
80003c6e:	ea 18 ab cd 	orh	r8,0xabcd
80003c72:	93 18       	st.w	r9[0x4],r8
	TxBuffer[0].payload_channel.dword[0] = PAYLOADIDLE0;
80003c74:	93 28       	st.w	r9[0x8],r8
	TxBuffer[0].payload_channel.dword[1] = PAYLOADIDLE1;
80003c76:	30 0e       	mov	lr,0
80003c78:	93 3e       	st.w	r9[0xc],lr
	TxBuffer[1].xnl_channel.dword = XNL_IDLE;
80003c7a:	93 58       	st.w	r9[0x14],r8
	TxBuffer[1].payload_channel.dword[0] = PAYLOADIDLE0;
80003c7c:	93 68       	st.w	r9[0x18],r8
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;
80003c7e:	93 7e       	st.w	r9[0x1c],lr

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
80003c80:	fe 78 00 40 	mov	r8,-65472
80003c84:	91 9b       	st.w	r8[0x24],r11
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
80003c86:	70 be       	ld.w	lr,r8[0x2c]
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
80003c88:	f2 ce ff fc 	sub	lr,r9,-4
	TxBuffer[1].payload_channel.dword[1] = PAYLOADIDLE1;

	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->idr = 
               AVR32_PDCA_RCZ_MASK | AVR32_PDCA_TRC_MASK | AVR32_PDCA_TERR_MASK;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
80003c8c:	91 0e       	st.w	r8[0x0],lr
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
80003c8e:	91 2a       	st.w	r8[0x8],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
80003c90:	91 1b       	st.w	r8[0x4],r11
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
80003c92:	2e c9       	sub	r9,-20
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->isr;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mar = 
                                          (U32)(&TxBuffer[0].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcr = 3;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->psr = AVR32_PDCA_PID_SSC_TX;
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->marr = 
80003c94:	91 39       	st.w	r8[0xc],r9
                                             (U32)(&TxBuffer[1].xnl_channel.dword);
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->tcrr = 3;
80003c96:	91 4a       	st.w	r8[0x10],r10
	(&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->mr = AVR32_PDCA_WORD;
80003c98:	91 6c       	st.w	r8[0x18],r12
}/*End of local_start_PDC.*/
80003c9a:	d8 02       	popm	pc
80003c9c:	00 00       	add	r0,r0
80003c9e:	53 b0       	stdsp	sp[0xec],r0
80003ca0:	00 00       	add	r0,r0
80003ca2:	53 b8       	stdsp	sp[0xec],r8
80003ca4:	00 00       	add	r0,r0
80003ca6:	53 d8       	stdsp	sp[0xf4],r8

80003ca8 <register_rx_tx_func>:
Description: register the rx function(callback function)
Called By: phy_init -- physical.c
*/
void register_rx_tx_func(void (*rx_exec)(void *),  void ( *tx_exec)(void *))
{
	 phy_rx_exec = rx_exec;
80003ca8:	48 38       	lddpc	r8,80003cb4 <register_rx_tx_func+0xc>
80003caa:	91 0c       	st.w	r8[0x0],r12
	 phy_tx_exec = tx_exec;//phy_tx_func, phy_rx_func
80003cac:	48 38       	lddpc	r8,80003cb8 <register_rx_tx_func+0x10>
80003cae:	91 0b       	st.w	r8[0x0],r11
	 
}/*End of register_tx_rx_func.*/
80003cb0:	5e fc       	retal	r12
80003cb2:	00 00       	add	r0,r0
80003cb4:	00 00       	add	r0,r0
80003cb6:	0a f0       	st.b	--r5,r0
80003cb8:	00 00       	add	r0,r0
80003cba:	0a f4       	st.b	--r5,r4

80003cbc <ssc_init>:
    local_start_SSC -- ssc.c
    local_start_PDC -- ssc.c
Called By: phy_init -- physical.c
*/
void ssc_init(void)
{		
80003cbc:	d4 01       	pushm	lr
    /*Set up PB01 to watch FS.*/
    AVR32_GPIO.port[1].oderc = 0x00000002;
80003cbe:	fe 78 10 00 	mov	r8,-61440
80003cc2:	30 29       	mov	r9,2
80003cc4:	f1 49 01 48 	st.w	r8[328],r9
    AVR32_GPIO.port[1].gpers = 0x00000002;
80003cc8:	f1 49 01 04 	st.w	r8[260],r9
	
	INTC_register_interrupt (
80003ccc:	30 3a       	mov	r10,3
80003cce:	36 0b       	mov	r11,96
80003cd0:	49 3c       	lddpc	r12,80003d1c <ssc_init+0x60>
80003cd2:	f0 1f 00 14 	mcall	80003d20 <ssc_init+0x64>
	&pdca_int_handler
	, AVR32_PDCA_IRQ_0
	, AVR32_INTC_INT3
	);
	
	Enable_global_interrupt();
80003cd6:	d5 03       	csrf	0x10
	
    /*Waits for radio to start making FSYNC.*/
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) == 0); //Wait for FS High.
80003cd8:	fe 79 10 00 	mov	r9,-61440
80003cdc:	f2 f8 01 60 	ld.w	r8,r9[352]
80003ce0:	e2 18 00 02 	andl	r8,0x2,COH
80003ce4:	cf c0       	breq	80003cdc <ssc_init+0x20>
    while ((AVR32_GPIO.port[1].pvr & 0x00000002) != 0); //Wait for FS Low.
80003ce6:	fe 79 10 00 	mov	r9,-61440
80003cea:	f2 f8 01 60 	ld.w	r8,r9[352]
80003cee:	e2 18 00 02 	andl	r8,0x2,COH
80003cf2:	cf c1       	brne	80003cea <ssc_init+0x2e>
			
	Disable_global_interrupt(); // resume to before
80003cf4:	d3 03       	ssrf	0x10
				
    /*config the SSC*/
    local_start_SSC();
80003cf6:	f0 1f 00 0c 	mcall	80003d24 <ssc_init+0x68>

    /*config the PDCA*/
    local_start_PDC();
80003cfa:	f0 1f 00 0c 	mcall	80003d28 <ssc_init+0x6c>
		
    /*Start the SSC Physical Layer.*/

    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003cfe:	fe 79 00 00 	mov	r9,-65536
80003d02:	30 18       	mov	r8,1
80003d04:	93 58       	st.w	r9[0x14],r8
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCTX_EXAMPLE])->cr = AVR32_PDCA_TEN_MASK;
80003d06:	fe 7a 00 40 	mov	r10,-65472
80003d0a:	95 58       	st.w	r10[0x14],r8
    (&AVR32_SSC)->cr = AVR32_SSC_CR_RXEN_MASK | AVR32_SSC_CR_TXEN_MASK;
80003d0c:	e0 6b 01 01 	mov	r11,257
80003d10:	fe 7a 34 00 	mov	r10,-52224
80003d14:	95 0b       	st.w	r10[0x0],r11
    (&AVR32_PDCA.channel[PDCA_CHANNEL_SSCRX_EXAMPLE])->ier = AVR32_PDCA_RCZ_MASK;
80003d16:	93 88       	st.w	r9[0x20],r8
															
	Enable_global_interrupt();
80003d18:	d5 03       	csrf	0x10
															
}/*End of ssc_init.*/
80003d1a:	d8 02       	popm	pc
80003d1c:	80 00       	ld.sh	r0,r0[0x0]
80003d1e:	3b 84       	mov	r4,-72
80003d20:	80 00       	ld.sh	r0,r0[0x0]
80003d22:	59 70       	cp.w	r0,23
80003d24:	80 00       	ld.sh	r0,r0[0x0]
80003d26:	3b f8       	mov	r8,-65
80003d28:	80 00       	ld.sh	r0,r0[0x0]
80003d2a:	3c 3c       	mov	r12,-61

80003d2c <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003d2c:	48 28       	lddpc	r8,80003d34 <xcmp_register_app_list+0x8>
80003d2e:	91 0c       	st.w	r8[0x0],r12
}
80003d30:	5e fc       	retal	r12
80003d32:	00 00       	add	r0,r0
80003d34:	00 00       	add	r0,r0
80003d36:	53 f8       	stdsp	sp[0xfc],r8

80003d38 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003d38:	eb cd 40 80 	pushm	r7,lr
80003d3c:	fa cd 01 00 	sub	sp,sp,256
80003d40:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
80003d42:	16 98       	mov	r8,r11
80003d44:	2f 08       	sub	r8,-16
80003d46:	af a8       	sbr	r8,0xe
80003d48:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003d4a:	3f f8       	mov	r8,-1
80003d4c:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003d4e:	30 b9       	mov	r9,11
80003d50:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
80003d52:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
80003d54:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
80003d56:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003d58:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003d5a:	f6 ca ff fe 	sub	r10,r11,-2
80003d5e:	18 9b       	mov	r11,r12
80003d60:	fa cc ff f0 	sub	r12,sp,-16
80003d64:	f0 1f 00 05 	mcall	80003d78 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003d68:	2f e7       	sub	r7,-2
80003d6a:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003d6c:	1a 9c       	mov	r12,sp
80003d6e:	f0 1f 00 04 	mcall	80003d7c <xcmp_tx+0x44>
}
80003d72:	2c 0d       	sub	sp,-256
80003d74:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d78:	80 00       	ld.sh	r0,r0[0x0]
80003d7a:	7b 22       	ld.w	r2,sp[0x48]
80003d7c:	80 00       	ld.sh	r0,r0[0x0]
80003d7e:	43 44       	lddsp	r4,sp[0xd0]

80003d80 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003d80:	d4 21       	pushm	r4-r7,lr
80003d82:	fa cd 00 d0 	sub	sp,sp,208
80003d86:	18 94       	mov	r4,r12
80003d88:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003d8a:	e0 68 01 00 	mov	r8,256
80003d8e:	f0 0b 19 00 	cp.h	r11,r8
80003d92:	e0 8b 00 36 	brhi	80003dfe <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
80003d96:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003d9a:	e0 68 04 1d 	mov	r8,1053
80003d9e:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003da0:	30 18       	mov	r8,1
80003da2:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
80003da4:	32 08       	mov	r8,32
80003da6:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003da8:	30 28       	mov	r8,2
80003daa:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003dac:	30 48       	mov	r8,4
80003dae:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003db0:	ea 1a 0c 00 	orh	r10,0xc00
80003db4:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
80003db6:	30 4a       	mov	r10,4
80003db8:	1a 9b       	mov	r11,sp
80003dba:	fa cc ff f4 	sub	r12,sp,-12
80003dbe:	f0 1f 00 12 	mcall	80003e04 <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
80003dc2:	30 f8       	mov	r8,15
80003dc4:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
80003dc8:	3a 78       	mov	r8,-89
80003dca:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
80003dce:	30 08       	mov	r8,0
80003dd0:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
80003dd4:	0e 9a       	mov	r10,r7
80003dd6:	5c 7a       	castu.h	r10
80003dd8:	f4 08 16 08 	lsr	r8,r10,0x8
80003ddc:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
80003de0:	0e 96       	mov	r6,r7
80003de2:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
80003de6:	08 9b       	mov	r11,r4
80003de8:	fa cc ff eb 	sub	r12,sp,-21
80003dec:	f0 1f 00 06 	mcall	80003e04 <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
80003df0:	ee cb ff f3 	sub	r11,r7,-13
80003df4:	5c 5b       	castu.b	r11
80003df6:	fa cc ff fa 	sub	r12,sp,-6
80003dfa:	f0 1f 00 04 	mcall	80003e08 <xcmp_data_session_req+0x88>
}
80003dfe:	2c cd       	sub	sp,-208
80003e00:	d8 22       	popm	r4-r7,pc
80003e02:	00 00       	add	r0,r0
80003e04:	80 00       	ld.sh	r0,r0[0x0]
80003e06:	7b 22       	ld.w	r2,sp[0x48]
80003e08:	80 00       	ld.sh	r0,r0[0x0]
80003e0a:	3d 38       	mov	r8,-45

80003e0c <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
80003e0c:	d4 01       	pushm	lr
80003e0e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
80003e12:	fe 78 b4 00 	mov	r8,-19456
80003e16:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
80003e18:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
80003e1c:	30 89       	mov	r9,8
80003e1e:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
80003e20:	30 19       	mov	r9,1
80003e22:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
80003e24:	30 09       	mov	r9,0
80003e26:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003e28:	30 5a       	mov	r10,5
80003e2a:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003e2c:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003e2e:	30 7a       	mov	r10,7
80003e30:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
80003e32:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
80003e34:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
80003e36:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003e3a:	30 9b       	mov	r11,9
80003e3c:	fa cc ff fe 	sub	r12,sp,-2
80003e40:	f0 1f 00 02 	mcall	80003e48 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
80003e44:	2c dd       	sub	sp,-204
80003e46:	d8 02       	popm	pc
80003e48:	80 00       	ld.sh	r0,r0[0x0]
80003e4a:	3d 38       	mov	r8,-45

80003e4c <xcmp_opcode_not_supported>:
Description: register the app list
Calls: xcmp_tx
Called By:...
*/
void xcmp_opcode_not_supported( void )
{
80003e4c:	d4 01       	pushm	lr
80003e4e:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REPLY;
80003e52:	fe 78 80 00 	mov	r8,-32768
80003e56:	ba 18       	st.h	sp[0x2],r8
	
	/*The radio does not support this opcode.*/
	xcmp_farme.u8[0] = xcmp_Res_Opcode_Not_Supported;
80003e58:	30 38       	mov	r8,3
80003e5a:	ba c8       	st.b	sp[0x4],r8
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, 1);
80003e5c:	30 1b       	mov	r11,1
80003e5e:	fa cc ff fe 	sub	r12,sp,-2
80003e62:	f0 1f 00 03 	mcall	80003e6c <xcmp_opcode_not_supported+0x20>
}
80003e66:	2c dd       	sub	sp,-204
80003e68:	d8 02       	popm	pc
80003e6a:	00 00       	add	r0,r0
80003e6c:	80 00       	ld.sh	r0,r0[0x0]
80003e6e:	3d 38       	mov	r8,-45

80003e70 <xcmp_exec_func>:
Description: Perform XCMP corresponding functions
Calls:   
Called By: xcmp_rx_process--task
*/
static void xcmp_exec_func(app_exec_t * exec, xcmp_fragment_t * xcmp)
{
80003e70:	d4 01       	pushm	lr
	/*The message types*/
	switch(xcmp->xcmp_opcode & 0xF000)
80003e72:	96 88       	ld.uh	r8,r11[0x0]
80003e74:	e2 18 f0 00 	andl	r8,0xf000,COH
80003e78:	e0 48 80 00 	cp.w	r8,32768
80003e7c:	c0 f0       	breq	80003e9a <xcmp_exec_func+0x2a>
80003e7e:	e0 48 b0 00 	cp.w	r8,45056
80003e82:	c1 20       	breq	80003ea6 <xcmp_exec_func+0x36>
80003e84:	58 08       	cp.w	r8,0
80003e86:	c1 51       	brne	80003eb0 <xcmp_exec_func+0x40>
	{
		case XCMP_REQUEST:
			if(NULL != exec->xcmp_rx_req)
80003e88:	78 08       	ld.w	r8,r12[0x0]
80003e8a:	58 08       	cp.w	r8,0
80003e8c:	c0 40       	breq	80003e94 <xcmp_exec_func+0x24>
			{
				exec->xcmp_rx_req(xcmp);
80003e8e:	16 9c       	mov	r12,r11
80003e90:	5d 18       	icall	r8
80003e92:	d8 02       	popm	pc
			}
			else 
			{
				/*No function to register the request message*/
				/*send not supported opcode to raido */
				xcmp_opcode_not_supported();
80003e94:	f0 1f 00 08 	mcall	80003eb4 <xcmp_exec_func+0x44>
80003e98:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_REPLY:		
			if(NULL != exec->xcmp_rx_reply)
80003e9a:	78 18       	ld.w	r8,r12[0x4]
80003e9c:	58 08       	cp.w	r8,0
80003e9e:	c0 90       	breq	80003eb0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_reply(xcmp);
80003ea0:	16 9c       	mov	r12,r11
80003ea2:	5d 18       	icall	r8
80003ea4:	d8 02       	popm	pc
			}
			break;
			
		case XCMP_BRDCAST:	
			if(NULL != exec->xcmp_rx_brdcst)
80003ea6:	78 28       	ld.w	r8,r12[0x8]
80003ea8:	58 08       	cp.w	r8,0
80003eaa:	c0 30       	breq	80003eb0 <xcmp_exec_func+0x40>
			{
				exec->xcmp_rx_brdcst(xcmp);
80003eac:	16 9c       	mov	r12,r11
80003eae:	5d 18       	icall	r8
80003eb0:	d8 02       	popm	pc
80003eb2:	00 00       	add	r0,r0
80003eb4:	80 00       	ld.sh	r0,r0[0x0]
80003eb6:	3e 4c       	mov	r12,-28

80003eb8 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003eb8:	d4 01       	pushm	lr
80003eba:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
80003ebe:	e0 68 04 09 	mov	r8,1033
80003ec2:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003ec4:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003ec8:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003eca:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
80003ece:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
80003ed0:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
80003ed2:	30 09       	mov	r9,0
80003ed4:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003ed6:	fb 69 00 08 	st.b	sp[8],r9
80003eda:	fa c8 ff f7 	sub	r8,sp,-9
80003ede:	b0 89       	st.b	r8[0x0],r9
80003ee0:	fa c8 ff f6 	sub	r8,sp,-10
80003ee4:	b0 89       	st.b	r8[0x0],r9
80003ee6:	fa c8 ff f5 	sub	r8,sp,-11
80003eea:	b0 89       	st.b	r8[0x0],r9
80003eec:	fa c8 ff f4 	sub	r8,sp,-12
80003ef0:	b0 89       	st.b	r8[0x0],r9
80003ef2:	fa c8 ff f3 	sub	r8,sp,-13
80003ef6:	b0 89       	st.b	r8[0x0],r9
80003ef8:	fa c8 ff f2 	sub	r8,sp,-14
80003efc:	b0 89       	st.b	r8[0x0],r9
80003efe:	fa c8 ff f1 	sub	r8,sp,-15
80003f02:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003f04:	30 cb       	mov	r11,12
80003f06:	fa cc ff fe 	sub	r12,sp,-2
80003f0a:	f0 1f 00 03 	mcall	80003f14 <xcmp_IdleTestTone+0x5c>
}
80003f0e:	2c dd       	sub	sp,-204
80003f10:	d8 02       	popm	pc
80003f12:	00 00       	add	r0,r0
80003f14:	80 00       	ld.sh	r0,r0[0x0]
80003f16:	3d 38       	mov	r8,-45

80003f18 <xcmp_init>:
	xQueueCreate -- freertos
	xTaskCreate -- freertos
Called By: main -- main.c
*/
void xcmp_init(void)
{
80003f18:	d4 01       	pushm	lr
	/*register the xcmp function(callback function)*/
	xnl_register_xcmp_func( xcmp_rx );
80003f1a:	48 dc       	lddpc	r12,80003f4c <xcmp_init+0x34>
80003f1c:	f0 1f 00 0d 	mcall	80003f50 <xcmp_init+0x38>
	
	/*initialize the queue*/
	xcmp_frame_rx = xQueueCreate(20, sizeof(xcmp_fragment_t *));
80003f20:	30 4b       	mov	r11,4
80003f22:	31 4c       	mov	r12,20
80003f24:	f0 1f 00 0c 	mcall	80003f54 <xcmp_init+0x3c>
80003f28:	48 c8       	lddpc	r8,80003f58 <xcmp_init+0x40>
80003f2a:	91 0c       	st.w	r8[0x0],r12
	/*create task*/	
	/*this task is used to execute xcmp message*/
	xTaskCreate(
80003f2c:	30 09       	mov	r9,0
80003f2e:	1a d9       	st.w	--sp,r9
80003f30:	1a d9       	st.w	--sp,r9
80003f32:	1a d9       	st.w	--sp,r9
80003f34:	30 38       	mov	r8,3
80003f36:	e0 6a 02 ee 	mov	r10,750
80003f3a:	48 9b       	lddpc	r11,80003f5c <xcmp_init+0x44>
80003f3c:	48 9c       	lddpc	r12,80003f60 <xcmp_init+0x48>
80003f3e:	f0 1f 00 0a 	mcall	80003f64 <xcmp_init+0x4c>
	,  tskXCMP_PRIORITY
	,  NULL
	);
	
	/*initialize the xnl*/
	xnl_init();
80003f42:	f0 1f 00 0a 	mcall	80003f68 <xcmp_init+0x50>
80003f46:	2f dd       	sub	sp,-12
	
}
80003f48:	d8 02       	popm	pc
80003f4a:	00 00       	add	r0,r0
80003f4c:	80 00       	ld.sh	r0,r0[0x0]
80003f4e:	40 68       	lddsp	r8,sp[0x18]
80003f50:	80 00       	ld.sh	r0,r0[0x0]
80003f52:	40 b4       	lddsp	r4,sp[0x2c]
80003f54:	80 00       	ld.sh	r0,r0[0x0]
80003f56:	67 68       	ld.w	r8,r3[0x58]
80003f58:	00 00       	add	r0,r0
80003f5a:	0b 10       	ld.sh	r0,r5++
80003f5c:	80 00       	ld.sh	r0,r0[0x0]
80003f5e:	d9 ac       	*unknown*
80003f60:	80 00       	ld.sh	r0,r0[0x0]
80003f62:	3f 6c       	mov	r12,-10
80003f64:	80 00       	ld.sh	r0,r0[0x0]
80003f66:	6e bc       	ld.w	r12,r7[0x2c]
80003f68:	80 00       	ld.sh	r0,r0[0x0]
80003f6a:	40 ec       	lddsp	r12,sp[0x38]

80003f6c <xcmp_rx_process>:
Calls: xQueueReceive -- freerots
	xcmp_exec_func
Called By: task
*/
static void xcmp_rx_process(void * pvParameters)
{
80003f6c:	d4 31       	pushm	r0-r7,lr
80003f6e:	20 1d       	sub	sp,4
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f70:	4b 16       	lddpc	r6,80004034 <xcmp_rx_process+0xc8>
80003f72:	30 05       	mov	r5,0
80003f74:	31 44       	mov	r4,20
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80003f76:	4b 13       	lddpc	r3,80004038 <xcmp_rx_process+0xcc>
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
					break;
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003f78:	4b 12       	lddpc	r2,8000403c <xcmp_rx_process+0xd0>
						, ptr);
					break;
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003f7a:	4b 21       	lddpc	r1,80004040 <xcmp_rx_process+0xd4>
					break;
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003f7c:	4b 20       	lddpc	r0,80004044 <xcmp_rx_process+0xd8>
	xcmp_fragment_t * ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE  ==xQueueReceive( xcmp_frame_rx, &ptr,  (10*2) / portTICK_RATE_MS ))//测试启用10ms超时机制
80003f7e:	6c 0c       	ld.w	r12,r6[0x0]
80003f80:	0a 99       	mov	r9,r5
80003f82:	08 9a       	mov	r10,r4
80003f84:	1a 9b       	mov	r11,sp
80003f86:	f0 1f 00 31 	mcall	80004048 <xcmp_rx_process+0xdc>
80003f8a:	58 1c       	cp.w	r12,1
80003f8c:	cf 91       	brne	80003f7e <xcmp_rx_process+0x12>
		{									
			if(NULL == ptr)
80003f8e:	40 0b       	lddsp	r11,sp[0x0]
80003f90:	58 0b       	cp.w	r11,0
80003f92:	cf 60       	breq	80003f7e <xcmp_rx_process+0x12>
			
			//log("\n\r R_xcmp : %4x \n\r",ptr->xcmp_opcode);//log:R_xcmp指令	
			//static  portTickType water_value;
			//water_value = uxTaskGetStackHighWaterMark(NULL);
			//log("water_value: %d\n", water_value);			
			switch(ptr->xcmp_opcode & 0x0FFF)
80003f94:	96 0a       	ld.sh	r10,r11[0x0]
80003f96:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
80003f9a:	f1 d9 c0 0c 	bfextu	r8,r9,0x0,0xc
80003f9e:	59 c8       	cp.w	r8,28
80003fa0:	c1 e0       	breq	80003fdc <xcmp_rx_process+0x70>
80003fa2:	e0 89 00 07 	brgt	80003fb0 <xcmp_rx_process+0x44>
80003fa6:	58 e8       	cp.w	r8,14
80003fa8:	c0 e0       	breq	80003fc4 <xcmp_rx_process+0x58>
80003faa:	58 f8       	cp.w	r8,15
80003fac:	c2 41       	brne	80003ff4 <xcmp_rx_process+0x88>
80003fae:	c0 f8       	rjmp	80003fcc <xcmp_rx_process+0x60>
80003fb0:	e0 48 01 09 	cp.w	r8,265
80003fb4:	c1 80       	breq	80003fe4 <xcmp_rx_process+0x78>
80003fb6:	e0 48 01 0a 	cp.w	r8,266
80003fba:	c1 90       	breq	80003fec <xcmp_rx_process+0x80>
80003fbc:	e0 48 00 2c 	cp.w	r8,44
80003fc0:	c1 a1       	brne	80003ff4 <xcmp_rx_process+0x88>
80003fc2:	c0 98       	rjmp	80003fd4 <xcmp_rx_process+0x68>
			{
				case RADIO_STATUS:				
					xcmp_exec_func(&radio_status, ptr);
80003fc4:	4a 2c       	lddpc	r12,8000404c <xcmp_rx_process+0xe0>
80003fc6:	f0 1f 00 23 	mcall	80004050 <xcmp_rx_process+0xe4>
					break;
80003fca:	c2 f8       	rjmp	80004028 <xcmp_rx_process+0xbc>
					
				case VERSION_INFORMATION:
					xcmp_exec_func(&version_information, ptr);
80003fcc:	4a 2c       	lddpc	r12,80004054 <xcmp_rx_process+0xe8>
80003fce:	f0 1f 00 21 	mcall	80004050 <xcmp_rx_process+0xe4>
					break;
80003fd2:	c2 b8       	rjmp	80004028 <xcmp_rx_process+0xbc>
					
				case LANGUAGE_PACK_INFORMATION:
					xcmp_exec_func(&language_pack_information, ptr);			
80003fd4:	4a 1c       	lddpc	r12,80004058 <xcmp_rx_process+0xec>
80003fd6:	f0 1f 00 1f 	mcall	80004050 <xcmp_rx_process+0xe4>
					break;
80003fda:	c2 78       	rjmp	80004028 <xcmp_rx_process+0xbc>
					
				case AUTOMATIC_FREQUENCY_CORRECTION_CONTROL:
					xcmp_exec_func(&automatic_frequency_correction_control
80003fdc:	04 9c       	mov	r12,r2
80003fde:	f0 1f 00 1d 	mcall	80004050 <xcmp_rx_process+0xe4>
						, ptr);
					break;
80003fe2:	c2 38       	rjmp	80004028 <xcmp_rx_process+0xbc>
					
				case CLONE_WRITE:
					xcmp_exec_func(&clone_write, ptr);
80003fe4:	02 9c       	mov	r12,r1
80003fe6:	f0 1f 00 1b 	mcall	80004050 <xcmp_rx_process+0xe4>
					break;
80003fea:	c1 f8       	rjmp	80004028 <xcmp_rx_process+0xbc>
					
				case CLONE_READ:
					xcmp_exec_func(&clone_read, ptr);
80003fec:	00 9c       	mov	r12,r0
80003fee:	f0 1f 00 19 	mcall	80004050 <xcmp_rx_process+0xe4>
					break;
80003ff2:	c1 b8       	rjmp	80004028 <xcmp_rx_process+0xbc>
					
				default:
				
					/*the xcmp message not in order list*/
					/*over the length of the list*/
					if((0x0400 != (ptr->xcmp_opcode & 0x0400)) 
80003ff4:	12 98       	mov	r8,r9
80003ff6:	e2 18 04 00 	andl	r8,0x400,COH
80003ffa:	c0 70       	breq	80004008 <xcmp_rx_process+0x9c>
80003ffc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004000:	e0 48 00 68 	cp.w	r8,104
80004004:	e0 8a 00 08 	brle	80004014 <xcmp_rx_process+0xa8>
						|| (MAX_APP_FUNC <= (ptr->xcmp_opcode & 0x00FF))
					)
					{
						/*xcmp request*/
						if( XCMP_REQUEST == (ptr->xcmp_opcode & 0xF000))
80004008:	e2 19 f0 00 	andl	r9,0xf000,COH
8000400c:	c0 e1       	brne	80004028 <xcmp_rx_process+0xbc>
						{
							/*send not supported opcode to raido */
							xcmp_opcode_not_supported();
8000400e:	f0 1f 00 14 	mcall	8000405c <xcmp_rx_process+0xf0>
80004012:	c0 b8       	rjmp	80004028 <xcmp_rx_process+0xbc>
						}
					}
					else
					{					
						xcmp_exec_func( &app_list[ptr->xcmp_opcode & 0x00FF]
80004014:	f9 da c0 08 	bfextu	r12,r10,0x0,0x8
80004018:	f8 0c 00 1c 	add	r12,r12,r12<<0x1
8000401c:	49 19       	lddpc	r9,80004060 <xcmp_rx_process+0xf4>
8000401e:	72 08       	ld.w	r8,r9[0x0]
80004020:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80004024:	f0 1f 00 0b 	mcall	80004050 <xcmp_rx_process+0xe4>
							, ptr);
					}
					break;
			}
			//vPortFree(ptr);
			set_xnl_idle(ptr);
80004028:	66 0c       	ld.w	r12,r3[0x0]
8000402a:	40 0b       	lddsp	r11,sp[0x0]
8000402c:	f0 1f 00 0e 	mcall	80004064 <xcmp_rx_process+0xf8>
80004030:	ca 7b       	rjmp	80003f7e <xcmp_rx_process+0x12>
80004032:	00 00       	add	r0,r0
80004034:	00 00       	add	r0,r0
80004036:	0b 10       	ld.sh	r0,r5++
80004038:	00 00       	add	r0,r0
8000403a:	0a ac       	st.w	r5++,r12
8000403c:	00 00       	add	r0,r0
8000403e:	0b 20       	ld.uh	r0,r5++
80004040:	00 00       	add	r0,r0
80004042:	0b 14       	ld.sh	r4,r5++
80004044:	00 00       	add	r0,r0
80004046:	0b 04       	ld.w	r4,r5++
80004048:	80 00       	ld.sh	r0,r0[0x0]
8000404a:	64 04       	ld.w	r4,r2[0x0]
8000404c:	00 00       	add	r0,r0
8000404e:	0b 38       	ld.ub	r8,r5++
80004050:	80 00       	ld.sh	r0,r0[0x0]
80004052:	3e 70       	mov	r0,-25
80004054:	00 00       	add	r0,r0
80004056:	0a f8       	st.b	--r5,r8
80004058:	00 00       	add	r0,r0
8000405a:	0b 2c       	ld.uh	r12,r5++
8000405c:	80 00       	ld.sh	r0,r0[0x0]
8000405e:	3e 4c       	mov	r12,-28
80004060:	00 00       	add	r0,r0
80004062:	53 f8       	stdsp	sp[0xfc],r8
80004064:	80 00       	ld.sh	r0,r0[0x0]
80004066:	2a 64       	sub	r4,-90

80004068 <xcmp_rx>:
Calls:   
	xQueueSend -- xnl.c
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
80004068:	eb cd 40 90 	pushm	r4,r7,lr
8000406c:	20 1d       	sub	sp,4
8000406e:	fa c4 ff f0 	sub	r4,sp,-16
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
80004072:	48 c8       	lddpc	r8,800040a0 <xcmp_rx+0x38>
80004074:	70 0c       	ld.w	r12,r8[0x0]
80004076:	f0 1f 00 0c 	mcall	800040a4 <xcmp_rx+0x3c>
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
8000407a:	c1 00       	breq	8000409a <xcmp_rx+0x32>
Called By: xnl_rx--callback
*/
static void xcmp_rx(xcmp_fragment_t xcmp)
{							
	
	xcmp_fragment_t * xcmp_ptr = get_xnl_idle();// pvPortMalloc(sizeof(xcmp_fragment_t));
8000407c:	fa c7 ff fc 	sub	r7,sp,-4
80004080:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&xcmp_ptr);
	
	if(NULL != xcmp_ptr)
	{
		memcpy(xcmp_ptr, &xcmp, sizeof(xcmp_fragment_t));				
80004082:	e0 6a 00 ca 	mov	r10,202
80004086:	08 9b       	mov	r11,r4
80004088:	f0 1f 00 08 	mcall	800040a8 <xcmp_rx+0x40>
		xQueueSend(xcmp_frame_rx, &xcmp_ptr, 0);	
8000408c:	48 88       	lddpc	r8,800040ac <xcmp_rx+0x44>
8000408e:	70 0c       	ld.w	r12,r8[0x0]
80004090:	30 09       	mov	r9,0
80004092:	12 9a       	mov	r10,r9
80004094:	1a 9b       	mov	r11,sp
80004096:	f0 1f 00 07 	mcall	800040b0 <xcmp_rx+0x48>
	}	
}
8000409a:	2f fd       	sub	sp,-4
8000409c:	e3 cd 80 90 	ldm	sp++,r4,r7,pc
800040a0:	00 00       	add	r0,r0
800040a2:	0a ac       	st.w	r5++,r12
800040a4:	80 00       	ld.sh	r0,r0[0x0]
800040a6:	2c 10       	sub	r0,-63
800040a8:	80 00       	ld.sh	r0,r0[0x0]
800040aa:	7b 22       	ld.w	r2,sp[0x48]
800040ac:	00 00       	add	r0,r0
800040ae:	0b 10       	ld.sh	r0,r5++
800040b0:	80 00       	ld.sh	r0,r0[0x0]
800040b2:	66 10       	ld.w	r0,r3[0x4]

800040b4 <xnl_register_xcmp_func>:
Function: xnl_register_xcmp_func
Description: register the xcmp function(callback function)
*/
void xnl_register_xcmp_func( void ( *func)(xnl_content_data_msg_t))
{
	 xcmp_exec = func;
800040b4:	48 28       	lddpc	r8,800040bc <xnl_register_xcmp_func+0x8>
800040b6:	91 0c       	st.w	r8[0x0],r12
}
800040b8:	5e fc       	retal	r12
800040ba:	00 00       	add	r0,r0
800040bc:	00 00       	add	r0,r0
800040be:	0b 64       	ld.uh	r4,--r5

800040c0 <xnl_get_msg_ack_func>:
Description: process while receive msg ack.
Calls:xSemaphoreGive--freertos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
800040c0:	d4 01       	pushm	lr
	
	DestinationAddress = xnl->xnl_header.destination;
	/*No timeout*/		
	 //One relationship is controlled by a state machine, only the current MSG received the ACK, 
	//then the program will clear the current MSG sending address and out of standby and will jump to the sending state.
	if (DestinationAddress == xnl_information.device_address )
800040c2:	48 88       	lddpc	r8,800040e0 <xnl_get_msg_ack_func+0x20>
800040c4:	90 28       	ld.sh	r8,r8[0x4]
void xnl_get_msg_ack_func(xnl_fragment_t * xnl)
{
	U16 DestinationAddress;
	U16 TransactionID;
	
	DestinationAddress = xnl->xnl_header.destination;
800040c6:	98 49       	ld.sh	r9,r12[0x8]
800040c8:	f0 09 19 00 	cp.h	r9,r8
800040cc:	c0 81       	brne	800040dc <xnl_get_msg_ack_func+0x1c>
	if (DestinationAddress == xnl_information.device_address )
	{
		//The ack is for me.
		
		TransactionID = xnl->xnl_header.transaction_id;
		xSemaphoreGive(xnl_timeout_semphr);	
800040ce:	48 68       	lddpc	r8,800040e4 <xnl_get_msg_ack_func+0x24>
800040d0:	70 0c       	ld.w	r12,r8[0x0]
800040d2:	30 09       	mov	r9,0
800040d4:	12 9a       	mov	r10,r9
800040d6:	12 9b       	mov	r11,r9
800040d8:	f0 1f 00 04 	mcall	800040e8 <xnl_get_msg_ack_func+0x28>
800040dc:	d8 02       	popm	pc
800040de:	00 00       	add	r0,r0
800040e0:	00 00       	add	r0,r0
800040e2:	0b 4a       	ld.w	r10,--r5
800040e4:	00 00       	add	r0,r0
800040e6:	0b 44       	ld.w	r4,--r5
800040e8:	80 00       	ld.sh	r0,r0[0x0]
800040ea:	66 10       	ld.w	r0,r3[0x4]

800040ec <xnl_init>:
	xTaskCreate--freertos
	xnl_send_device_master_query
Called By:xcmp_init -- xcmp.c
*/
void xnl_init(void)
{
800040ec:	eb cd 40 e0 	pushm	r5-r7,lr
	
	xnl_information.is_connected = FALSE;
800040f0:	30 09       	mov	r9,0
800040f2:	4b 78       	lddpc	r8,800041cc <xnl_init+0xe0>
800040f4:	b0 89       	st.b	r8[0x0],r9

	/*initialize the semaphore and queue*/
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
800040f6:	30 0b       	mov	r11,0
800040f8:	30 1c       	mov	r12,1
800040fa:	f0 1f 00 36 	mcall	800041d0 <xnl_init+0xe4>
800040fe:	4b 68       	lddpc	r8,800041d4 <xnl_init+0xe8>
80004100:	91 0c       	st.w	r8[0x0],r12
80004102:	70 08       	ld.w	r8,r8[0x0]
80004104:	58 08       	cp.w	r8,0
80004106:	c0 80       	breq	80004116 <xnl_init+0x2a>
80004108:	4b 38       	lddpc	r8,800041d4 <xnl_init+0xe8>
8000410a:	70 0c       	ld.w	r12,r8[0x0]
8000410c:	30 09       	mov	r9,0
8000410e:	12 9a       	mov	r10,r9
80004110:	12 9b       	mov	r11,r9
80004112:	f0 1f 00 32 	mcall	800041d8 <xnl_init+0xec>
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
80004116:	30 4b       	mov	r11,4
80004118:	31 4c       	mov	r12,20
8000411a:	f0 1f 00 2e 	mcall	800041d0 <xnl_init+0xe4>
8000411e:	4b 08       	lddpc	r8,800041dc <xnl_init+0xf0>
80004120:	91 0c       	st.w	r8[0x0],r12
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
80004122:	30 4b       	mov	r11,4
80004124:	31 ec       	mov	r12,30
80004126:	f0 1f 00 2b 	mcall	800041d0 <xnl_init+0xe4>
8000412a:	4a e8       	lddpc	r8,800041e0 <xnl_init+0xf4>
8000412c:	91 0c       	st.w	r8[0x0],r12
8000412e:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_XNL_STORE; i++ )
	{
		set_xnl_idle(&xnl_store[i]);
80004130:	10 96       	mov	r6,r8
80004132:	4a d5       	lddpc	r5,800041e4 <xnl_init+0xf8>
80004134:	6c 0c       	ld.w	r12,r6[0x0]
80004136:	ea 07 00 0b 	add	r11,r5,r7
8000413a:	f0 1f 00 2c 	mcall	800041e8 <xnl_init+0xfc>
8000413e:	ee c7 ff 00 	sub	r7,r7,-256
	vSemaphoreCreateBinary(xnl_timeout_semphr);		
	
	xnl_frame_tx = xQueueCreate(20, sizeof(xnl_fragment_t *)); //扩大xnl_frame_tx的队列深度
		
	xnl_store_idle = xQueueCreate(MAX_XNL_STORE, sizeof(phy_fragment_t *));
	for(int i= 0; i < MAX_XNL_STORE; i++ )
80004142:	e0 47 1e 00 	cp.w	r7,7680
80004146:	cf 71       	brne	80004134 <xnl_init+0x48>
	{
		set_xnl_idle(&xnl_store[i]);
	}
	
	/*initialize the queue to send/receive xnl packet */
	phy_xnl_frame_tx = xQueueCreate(TX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004148:	30 4b       	mov	r11,4
8000414a:	31 4c       	mov	r12,20
8000414c:	f0 1f 00 21 	mcall	800041d0 <xnl_init+0xe4>
80004150:	4a 78       	lddpc	r8,800041ec <xnl_init+0x100>
80004152:	91 0c       	st.w	r8[0x0],r12
	phy_xnl_frame_rx = xQueueCreate(RX_XNL_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004154:	30 4b       	mov	r11,4
80004156:	30 ac       	mov	r12,10
80004158:	f0 1f 00 1e 	mcall	800041d0 <xnl_init+0xe4>
8000415c:	4a 58       	lddpc	r8,800041f0 <xnl_init+0x104>
8000415e:	91 0c       	st.w	r8[0x0],r12
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
80004160:	30 4b       	mov	r11,4
80004162:	30 ac       	mov	r12,10
80004164:	f0 1f 00 1b 	mcall	800041d0 <xnl_init+0xe4>
80004168:	4a 38       	lddpc	r8,800041f4 <xnl_init+0x108>
8000416a:	91 0c       	st.w	r8[0x0],r12
8000416c:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
	{
		set_payload_idle(payload_store[i]);
8000416e:	10 96       	mov	r6,r8
80004170:	4a 25       	lddpc	r5,800041f8 <xnl_init+0x10c>
80004172:	6c 0c       	ld.w	r12,r6[0x0]
80004174:	ea 07 00 0b 	add	r11,r5,r7
80004178:	f0 1f 00 1c 	mcall	800041e8 <xnl_init+0xfc>
8000417c:	ee c7 fe 00 	sub	r7,r7,-512
	
	
	/*if enable send/receive payload(media), defined in physical.h*/
	#if ENABLE == PAYLOAD_ENABLE
	payload_store_idle = xQueueCreate(MAX_PAYLOAD_STORE, sizeof(void *));
	for(int i= 0; i < MAX_PAYLOAD_STORE; i++ )
80004180:	e0 47 14 00 	cp.w	r7,5120
80004184:	cf 71       	brne	80004172 <xnl_init+0x86>
	
	/*initialize the queue to send/receive payload packet */
	//phy_payload_frame_tx =
	//xQueueCreate(TX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t));
	
	phy_payload_frame_rx = xQueueCreate(RX_PAYLOAD_QUEUE_DEEP, sizeof(phy_fragment_t *));
80004186:	30 4b       	mov	r11,4
80004188:	30 5c       	mov	r12,5
8000418a:	f0 1f 00 12 	mcall	800041d0 <xnl_init+0xe4>
8000418e:	49 c8       	lddpc	r8,800041fc <xnl_init+0x110>
80004190:	91 0c       	st.w	r8[0x0],r12
	
	#endif /*end if*/
		
	/*create task*/	
	/*this task is used to receive xnl message*/
	xTaskCreate(
80004192:	30 07       	mov	r7,0
80004194:	1a d7       	st.w	--sp,r7
80004196:	1a d7       	st.w	--sp,r7
80004198:	1a d7       	st.w	--sp,r7
8000419a:	30 38       	mov	r8,3
8000419c:	0e 99       	mov	r9,r7
8000419e:	e0 6a 00 dc 	mov	r10,220
800041a2:	49 8b       	lddpc	r11,80004200 <xnl_init+0x114>
800041a4:	49 8c       	lddpc	r12,80004204 <xnl_init+0x118>
800041a6:	f0 1f 00 19 	mcall	80004208 <xnl_init+0x11c>
	,  tskXNL_PRIORITY //+ 1
	,  NULL
	);
	
	/*this task is used to send xnl message*/
	xTaskCreate(
800041aa:	1a d7       	st.w	--sp,r7
800041ac:	1a d7       	st.w	--sp,r7
800041ae:	1a d7       	st.w	--sp,r7
800041b0:	30 38       	mov	r8,3
800041b2:	0e 99       	mov	r9,r7
800041b4:	e0 6a 00 82 	mov	r10,130
800041b8:	49 5b       	lddpc	r11,8000420c <xnl_init+0x120>
800041ba:	49 6c       	lddpc	r12,80004210 <xnl_init+0x124>
800041bc:	f0 1f 00 13 	mcall	80004208 <xnl_init+0x11c>
	,  tskXNL_PRIORITY//+1
	,  NULL
	);
	
	/*initialize the physical layer*/
	phy_init();
800041c0:	f0 1f 00 15 	mcall	80004214 <xnl_init+0x128>
800041c4:	2f ad       	sub	sp,-24
}
800041c6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800041ca:	00 00       	add	r0,r0
800041cc:	00 00       	add	r0,r0
800041ce:	0b 4a       	ld.w	r10,--r5
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	67 68       	ld.w	r8,r3[0x58]
800041d4:	00 00       	add	r0,r0
800041d6:	0b 44       	ld.w	r4,--r5
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	66 10       	ld.w	r0,r3[0x4]
800041dc:	00 00       	add	r0,r0
800041de:	0b 58       	ld.sh	r8,--r5
800041e0:	00 00       	add	r0,r0
800041e2:	0a ac       	st.w	r5++,r12
800041e4:	00 00       	add	r0,r0
800041e6:	35 aa       	mov	r10,90
800041e8:	80 00       	ld.sh	r0,r0[0x0]
800041ea:	2a 64       	sub	r4,-90
800041ec:	00 00       	add	r0,r0
800041ee:	0a dc       	st.w	--r5,r12
800041f0:	00 00       	add	r0,r0
800041f2:	0a bc       	st.h	r5++,r12
800041f4:	00 00       	add	r0,r0
800041f6:	0a b0       	st.h	r5++,r0
800041f8:	00 00       	add	r0,r0
800041fa:	21 aa       	sub	r10,26
800041fc:	00 00       	add	r0,r0
800041fe:	0a e8       	st.h	--r5,r8
80004200:	80 00       	ld.sh	r0,r0[0x0]
80004202:	d9 b4       	*unknown*
80004204:	80 00       	ld.sh	r0,r0[0x0]
80004206:	42 18       	lddsp	r8,sp[0x84]
80004208:	80 00       	ld.sh	r0,r0[0x0]
8000420a:	6e bc       	ld.w	r12,r7[0x2c]
8000420c:	80 00       	ld.sh	r0,r0[0x0]
8000420e:	d9 bc       	*unknown*
80004210:	80 00       	ld.sh	r0,r0[0x0]
80004212:	42 78       	lddsp	r8,sp[0x9c]
80004214:	80 00       	ld.sh	r0,r0[0x0]
80004216:	2c 38       	sub	r8,-61

80004218 <xnl_rx_process>:
Calls: 
Called By:task
*/
//portTickType water_value =0;
static void xnl_rx_process(void * pvParameters)
{
80004218:	eb cd 40 fe 	pushm	r1-r7,lr
8000421c:	20 1d       	sub	sp,4
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000421e:	49 26       	lddpc	r6,80004264 <xnl_rx_process+0x4c>
80004220:	30 05       	mov	r5,0
80004222:	3f f4       	mov	r4,-1
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004224:	30 c3       	mov	r3,12
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
80004226:	49 11       	lddpc	r1,80004268 <xnl_rx_process+0x50>
	if(xnl->xnl_header.opcode > 0x0C)	
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
80004228:	49 12       	lddpc	r2,8000426c <xnl_rx_process+0x54>
	xnl_fragment_t * xnl_ptr;
	//static  portTickType water_value;
		
	for(;;)
	{
		if(pdTRUE ==xQueueReceive( phy_xnl_frame_rx, &xnl_ptr
8000422a:	6c 0c       	ld.w	r12,r6[0x0]
8000422c:	0a 99       	mov	r9,r5
8000422e:	08 9a       	mov	r10,r4
80004230:	1a 9b       	mov	r11,sp
80004232:	f0 1f 00 10 	mcall	80004270 <xnl_rx_process+0x58>
80004236:	58 1c       	cp.w	r12,1
80004238:	cf 91       	brne	8000422a <xnl_rx_process+0x12>
		, portMAX_DELAY ))
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
8000423a:	40 0c       	lddsp	r12,sp[0x0]
8000423c:	58 0c       	cp.w	r12,0
8000423e:	cf 60       	breq	8000422a <xnl_rx_process+0x12>
Calls: 
Called By:xnl_rx_process
*/
static void xnl_rx(xnl_fragment_t * xnl)
{
	if(xnl->xnl_header.opcode > 0x0C)	
80004240:	98 28       	ld.sh	r8,r12[0x4]
80004242:	e6 08 19 00 	cp.h	r8,r3
80004246:	e0 8b 00 0a 	brhi	8000425a <xnl_rx_process+0x42>
	{
		return;
	}

	if(NULL != xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec)
8000424a:	5c 78       	castu.h	r8
8000424c:	e4 08 03 29 	ld.w	r9,r2[r8<<0x2]
80004250:	58 09       	cp.w	r9,0
80004252:	c0 40       	breq	8000425a <xnl_rx_process+0x42>
	{
		//log("\n\r R_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:R_xnl指令
		/*execute the function in list*/
		xnl_proc_list[xnl->xnl_header.opcode].xnl_rx_exec(xnl);
80004254:	e4 08 03 28 	ld.w	r8,r2[r8<<0x2]
80004258:	5d 18       	icall	r8
		{				
			/*Receive the XNL and perform the corresponding functions*/			
			if(NULL != xnl_ptr)
			{
				xnl_rx(xnl_ptr);
				set_xnl_idle(xnl_ptr);
8000425a:	62 0c       	ld.w	r12,r1[0x0]
8000425c:	40 0b       	lddsp	r11,sp[0x0]
8000425e:	f0 1f 00 06 	mcall	80004274 <xnl_rx_process+0x5c>
80004262:	ce 4b       	rjmp	8000422a <xnl_rx_process+0x12>
80004264:	00 00       	add	r0,r0
80004266:	0a bc       	st.h	r5++,r12
80004268:	00 00       	add	r0,r0
8000426a:	0a ac       	st.w	r5++,r12
8000426c:	00 00       	add	r0,r0
8000426e:	04 f0       	st.b	--r2,r0
80004270:	80 00       	ld.sh	r0,r0[0x0]
80004272:	64 04       	ld.w	r4,r2[0x0]
80004274:	80 00       	ld.sh	r0,r0[0x0]
80004276:	2a 64       	sub	r4,-90

80004278 <xnl_tx_process>:
	phy_tx -- physical.c
Called By: task
*/
//portTickType tx_water_value =0;
static void xnl_tx_process(void * pvParameters)
{
80004278:	d4 31       	pushm	r0-r7,lr
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000427a:	4a a6       	lddpc	r6,80004320 <xnl_tx_process+0xa8>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
8000427c:	4a a2       	lddpc	r2,80004324 <xnl_tx_process+0xac>
8000427e:	4a b4       	lddpc	r4,80004328 <xnl_tx_process+0xb0>
80004280:	30 07       	mov	r7,0
80004282:	3f f1       	mov	r1,-1
					if(NULL == ptr)
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
80004284:	30 00       	mov	r0,0
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
80004286:	4a a5       	lddpc	r5,8000432c <xnl_tx_process+0xb4>
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
80004288:	4a a3       	lddpc	r3,80004330 <xnl_tx_process+0xb8>
	
	
	for(;;)
	{		
		//tx_water_value = uxTaskGetStackHighWaterMark(NULL);
		switch(xnl_tx_state)
8000428a:	6c 08       	ld.w	r8,r6[0x0]
8000428c:	58 08       	cp.w	r8,0
8000428e:	c0 40       	breq	80004296 <xnl_tx_process+0x1e>
80004290:	58 18       	cp.w	r8,1
80004292:	cf d1       	brne	8000428c <xnl_tx_process+0x14>
80004294:	c2 48       	rjmp	800042dc <xnl_tx_process+0x64>
		{
			case WAITING_FOR_TX:
				if(pdTRUE == xQueueReceive( xnl_frame_tx, &ptr
80004296:	64 0c       	ld.w	r12,r2[0x0]
80004298:	0e 99       	mov	r9,r7
8000429a:	02 9a       	mov	r10,r1
8000429c:	08 9b       	mov	r11,r4
8000429e:	f0 1f 00 26 	mcall	80004334 <xnl_tx_process+0xbc>
800042a2:	58 1c       	cp.w	r12,1
800042a4:	cf 31       	brne	8000428a <xnl_tx_process+0x12>
					, portMAX_DELAY ))
				{				
					if(NULL == ptr)
800042a6:	68 0b       	ld.w	r11,r4[0x0]
800042a8:	58 0b       	cp.w	r11,0
800042aa:	cf 00       	breq	8000428a <xnl_tx_process+0x12>
					{
						break;
					}
					
					if(ptr->xnl_header.opcode == 0x0000)
800042ac:	96 28       	ld.sh	r8,r11[0x4]
800042ae:	e0 08 19 00 	cp.h	r8,r0
800042b2:	c0 71       	brne	800042c0 <xnl_tx_process+0x48>
					{
						/*invalid XNL opcode*/
						set_xnl_idle(ptr);
800042b4:	4a 18       	lddpc	r8,80004338 <xnl_tx_process+0xc0>
800042b6:	70 08       	ld.w	r8,r8[0x0]
800042b8:	10 9c       	mov	r12,r8
800042ba:	f0 1f 00 21 	mcall	8000433c <xnl_tx_process+0xc4>
						break;
800042be:	ce 6b       	rjmp	8000428a <xnl_tx_process+0x12>
					}
					
					
					/*send physical data*/
					phy_tx((phy_fragment_t *)ptr);
800042c0:	16 9c       	mov	r12,r11
800042c2:	f0 1f 00 20 	mcall	80004340 <xnl_tx_process+0xc8>
					//log("\n\r T_xcmp:%4x \n\r", ptr->xnl_payload.xnl_content_data_msg.xcmp_opcode);
					xnl_send_times = 1;				
800042c6:	30 18       	mov	r8,1
800042c8:	8b 08       	st.w	r5[0x0],r8
					/*clear timeout semaphore and wait XNL reply*/
					xSemaphoreTake( xnl_timeout_semphr, ( portTickType )0);			
800042ca:	66 0c       	ld.w	r12,r3[0x0]
800042cc:	0e 99       	mov	r9,r7
800042ce:	0e 9a       	mov	r10,r7
800042d0:	0e 9b       	mov	r11,r7
800042d2:	f0 1f 00 19 	mcall	80004334 <xnl_tx_process+0xbc>
					xnl_tx_state = WAITING_FOR_REPLY;
800042d6:	30 18       	mov	r8,1
800042d8:	8d 08       	st.w	r6[0x0],r8
800042da:	cd 8b       	rjmp	8000428a <xnl_tx_process+0x12>
				}
				break;
			
			/*wait XNL reply*/			
			case WAITING_FOR_REPLY://直到回答ACK才再发送下一条data/control
				if(pdTRUE == xSemaphoreTake( xnl_timeout_semphr
800042dc:	66 0c       	ld.w	r12,r3[0x0]
800042de:	0e 99       	mov	r9,r7
800042e0:	36 4a       	mov	r10,100
800042e2:	0e 9b       	mov	r11,r7
800042e4:	f0 1f 00 14 	mcall	80004334 <xnl_tx_process+0xbc>
800042e8:	58 1c       	cp.w	r12,1
800042ea:	c0 81       	brne	800042fa <xnl_tx_process+0x82>
					, ( portTickType )50*2/ portTICK_RATE_MS))//按ADK文档中提示500ms一次超时,但是实际情况下程序中启用freertos的任务延时不够精准。因此根据经验需要降低延时等待的时间
				{
					/*No timeout*/
					set_xnl_idle(ptr);			
800042ec:	49 38       	lddpc	r8,80004338 <xnl_tx_process+0xc0>
800042ee:	70 0c       	ld.w	r12,r8[0x0]
800042f0:	68 0b       	ld.w	r11,r4[0x0]
800042f2:	f0 1f 00 13 	mcall	8000433c <xnl_tx_process+0xc4>
					xnl_tx_state = WAITING_FOR_TX;
800042f6:	8d 07       	st.w	r6[0x0],r7
800042f8:	cc 9b       	rjmp	8000428a <xnl_tx_process+0x12>
				}
				else
				{
					/*time out*/
					if(xnl_send_times <= MIN_RESEND_TIMES)
800042fa:	6a 08       	ld.w	r8,r5[0x0]
800042fc:	58 38       	cp.w	r8,3
800042fe:	e0 89 00 09 	brgt	80004310 <xnl_tx_process+0x98>
					{
						/*If times smaller than A supermarket, then resend the 
						instructions*/
						phy_tx((phy_fragment_t *)ptr);
80004302:	68 0c       	ld.w	r12,r4[0x0]
80004304:	f0 1f 00 0f 	mcall	80004340 <xnl_tx_process+0xc8>
						xnl_send_times++;
80004308:	6a 08       	ld.w	r8,r5[0x0]
8000430a:	2f f8       	sub	r8,-1
8000430c:	8b 08       	st.w	r5[0x0],r8
8000430e:	cb eb       	rjmp	8000428a <xnl_tx_process+0x12>
					}
					else
					{
						//can not send data, disconnected						
						//vPortFree(ptr);	
						set_xnl_idle(ptr);									
80004310:	48 a8       	lddpc	r8,80004338 <xnl_tx_process+0xc0>
80004312:	70 0c       	ld.w	r12,r8[0x0]
80004314:	68 0b       	ld.w	r11,r4[0x0]
80004316:	f0 1f 00 0a 	mcall	8000433c <xnl_tx_process+0xc4>
						xnl_tx_state = WAITING_FOR_TX;
8000431a:	8d 07       	st.w	r6[0x0],r7
8000431c:	cb 7b       	rjmp	8000428a <xnl_tx_process+0x12>
8000431e:	00 00       	add	r0,r0
80004320:	00 00       	add	r0,r0
80004322:	0b 54       	ld.sh	r4,--r5
80004324:	00 00       	add	r0,r0
80004326:	0b 58       	ld.sh	r8,--r5
80004328:	00 00       	add	r0,r0
8000432a:	0b 60       	ld.uh	r0,--r5
8000432c:	00 00       	add	r0,r0
8000432e:	0b 5c       	ld.sh	r12,--r5
80004330:	00 00       	add	r0,r0
80004332:	0b 44       	ld.w	r4,--r5
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	64 04       	ld.w	r4,r2[0x0]
80004338:	00 00       	add	r0,r0
8000433a:	0a ac       	st.w	r5++,r12
8000433c:	80 00       	ld.sh	r0,r0[0x0]
8000433e:	2a 64       	sub	r4,-90
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	2a 84       	sub	r4,-88

80004344 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80004344:	eb cd 40 c0 	pushm	r6-r7,lr
80004348:	20 1d       	sub	sp,4
8000434a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000434c:	98 39       	ld.sh	r9,r12[0x6]
8000434e:	3f f8       	mov	r8,-1
80004350:	f0 09 19 00 	cp.h	r9,r8
80004354:	c0 a1       	brne	80004368 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80004356:	4a e9       	lddpc	r9,8000440c <xnl_tx+0xc8>
80004358:	13 88       	ld.ub	r8,r9[0x0]
8000435a:	2f f8       	sub	r8,-1
8000435c:	5c 58       	castu.b	r8
8000435e:	b2 88       	st.b	r9[0x0],r8
80004360:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80004364:	a9 a8       	sbr	r8,0x8
80004366:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
80004368:	8c 49       	ld.sh	r9,r6[0x8]
8000436a:	3f f8       	mov	r8,-1
8000436c:	f0 09 19 00 	cp.h	r9,r8
80004370:	c0 41       	brne	80004378 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
80004372:	4a 88       	lddpc	r8,80004410 <xnl_tx+0xcc>
80004374:	90 18       	ld.sh	r8,r8[0x2]
80004376:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
80004378:	8c 59       	ld.sh	r9,r6[0xa]
8000437a:	3f f8       	mov	r8,-1
8000437c:	f0 09 19 00 	cp.h	r9,r8
80004380:	c0 41       	brne	80004388 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
80004382:	4a 48       	lddpc	r8,80004410 <xnl_tx+0xcc>
80004384:	90 28       	ld.sh	r8,r8[0x4]
80004386:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
80004388:	8c 69       	ld.sh	r9,r6[0xc]
8000438a:	3f f8       	mov	r8,-1
8000438c:	f0 09 19 00 	cp.h	r9,r8
80004390:	c0 e1       	brne	800043ac <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
80004392:	4a 08       	lddpc	r8,80004410 <xnl_tx+0xcc>
80004394:	90 49       	ld.sh	r9,r8[0x8]
80004396:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
80004398:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
8000439a:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
8000439c:	90 49       	ld.sh	r9,r8[0x8]
8000439e:	e0 19 ff 00 	andl	r9,0xff00
800043a2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800043a6:	f3 e8 10 08 	or	r8,r9,r8
800043aa:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800043ac:	0d 98       	ld.ub	r8,r6[0x1]
800043ae:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800043b0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800043b4:	10 0c       	add	r12,r8
800043b6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043b8:	58 0c       	cp.w	r12,0
800043ba:	e0 89 00 04 	brgt	800043c2 <xnl_tx+0x7e>
800043be:	30 09       	mov	r9,0
800043c0:	c0 d8       	rjmp	800043da <xnl_tx+0x96>
800043c2:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
800043c6:	2f ec       	sub	r12,-2
800043c8:	30 09       	mov	r9,0
800043ca:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
800043cc:	15 1b       	ld.sh	r11,r10++
800043ce:	f6 09 00 09 	add	r9,r11,r9
800043d2:	5c 89       	casts.h	r9
		indextohWord     += 1;
800043d4:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800043d6:	18 38       	cp.w	r8,r12
800043d8:	cf a1       	brne	800043cc <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
800043da:	5c 39       	neg	r9
800043dc:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043de:	48 e8       	lddpc	r8,80004414 <xnl_tx+0xd0>
800043e0:	70 0c       	ld.w	r12,r8[0x0]
800043e2:	f0 1f 00 0e 	mcall	80004418 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
800043e6:	c1 00       	breq	80004406 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
800043e8:	fa c7 ff fc 	sub	r7,sp,-4
800043ec:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
800043ee:	e0 6a 01 00 	mov	r10,256
800043f2:	0c 9b       	mov	r11,r6
800043f4:	f0 1f 00 0a 	mcall	8000441c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
800043f8:	48 a8       	lddpc	r8,80004420 <xnl_tx+0xdc>
800043fa:	70 0c       	ld.w	r12,r8[0x0]
800043fc:	30 09       	mov	r9,0
800043fe:	12 9a       	mov	r10,r9
80004400:	1a 9b       	mov	r11,sp
80004402:	f0 1f 00 09 	mcall	80004424 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80004406:	2f fd       	sub	sp,-4
80004408:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000440c:	00 00       	add	r0,r0
8000440e:	0b 48       	ld.w	r8,--r5
80004410:	00 00       	add	r0,r0
80004412:	0b 4a       	ld.w	r10,--r5
80004414:	00 00       	add	r0,r0
80004416:	0a ac       	st.w	r5++,r12
80004418:	80 00       	ld.sh	r0,r0[0x0]
8000441a:	2c 10       	sub	r0,-63
8000441c:	80 00       	ld.sh	r0,r0[0x0]
8000441e:	7b 22       	ld.w	r2,sp[0x48]
80004420:	00 00       	add	r0,r0
80004422:	0b 58       	ld.sh	r8,--r5
80004424:	80 00       	ld.sh	r0,r0[0x0]
80004426:	66 10       	ld.w	r0,r3[0x4]

80004428 <xnl_data_msg_func>:
Description: process while receive data message.
Calls:xnl_send_msg_ack, xcmp_exec(function in xcmp)
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_data_msg_func(xnl_fragment_t * xnl)
{
80004428:	eb cd 40 80 	pushm	r7,lr
8000442c:	fa cd 01 00 	sub	sp,sp,256
80004430:	18 97       	mov	r7,r12
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
80004432:	e0 68 40 0e 	mov	r8,16398
80004436:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004438:	3f f8       	mov	r8,-1
8000443a:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG_ACK;
8000443c:	30 c8       	mov	r8,12
8000443e:	ba 28       	st.h	sp[0x4],r8
	
	/*Turn around Flags.*/	
	xnl_frame.xnl_header.flags = hdr->flags;
80004440:	98 38       	ld.sh	r8,r12[0x6]
80004442:	ba 38       	st.h	sp[0x6],r8
	
	/*ACK Destination Address is Source of XNL_Message.*/
	xnl_frame.xnl_header.destination = hdr->source;
80004444:	98 58       	ld.sh	r8,r12[0xa]
80004446:	ba 48       	st.h	sp[0x8],r8
	
	/*ACK Source Address is my address.*/
	xnl_frame.xnl_header.source = hdr->destination;
80004448:	98 48       	ld.sh	r8,r12[0x8]
8000444a:	ba 58       	st.h	sp[0xa],r8
	
	/*Turn around Transaction ID.*/
	xnl_frame.xnl_header.transaction_id = hdr->transaction_id;
8000444c:	98 68       	ld.sh	r8,r12[0xc]
8000444e:	ba 68       	st.h	sp[0xc],r8
	xnl_frame.xnl_header.payload_length = 0;
80004450:	30 08       	mov	r8,0
80004452:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004454:	1a 9c       	mov	r12,sp
80004456:	f0 1f 00 0a 	mcall	8000447c <xnl_data_msg_func+0x54>
	transmitter, but possibly is waiting in Queue with immediate timeout.
	 */
	xnl_send_msg_ack(&xnl->xnl_header);
	
	/*exec xcmp function*/
	xcmp_exec(xnl->xnl_payload.xnl_content_data_msg);//xcmp_rx
8000445a:	fa cd 00 cc 	sub	sp,sp,204
8000445e:	e0 6a 00 ca 	mov	r10,202
80004462:	ee cb ff f0 	sub	r11,r7,-16
80004466:	1a 9c       	mov	r12,sp
80004468:	f0 1f 00 06 	mcall	80004480 <xnl_data_msg_func+0x58>
8000446c:	48 68       	lddpc	r8,80004484 <xnl_data_msg_func+0x5c>
8000446e:	70 08       	ld.w	r8,r8[0x0]
80004470:	5d 18       	icall	r8
80004472:	fa cd ff 34 	sub	sp,sp,-204
}
80004476:	2c 0d       	sub	sp,-256
80004478:	e3 cd 80 80 	ldm	sp++,r7,pc
8000447c:	80 00       	ld.sh	r0,r0[0x0]
8000447e:	43 44       	lddsp	r4,sp[0xd0]
80004480:	80 00       	ld.sh	r0,r0[0x0]
80004482:	7b 22       	ld.w	r2,sp[0x48]
80004484:	00 00       	add	r0,r0
80004486:	0b 64       	ld.uh	r4,--r5

80004488 <xnl_device_auth_reply_func>:
Description: process while receive device auth reply.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_auth_reply_func(xnl_fragment_t * xnl)
{
80004488:	d4 21       	pushm	r4-r7,lr
8000448a:	fa cd 01 00 	sub	sp,sp,256
8000448e:	18 97       	mov	r7,r12
	the receiving device and will be used to authenticate the connection 
	request. 5.4.4
	*/
	//log("R_xnl-opcode:%4x", xnl->xnl_header.opcode);
	
	if(xnl_information.is_connected)
80004490:	4c 28       	lddpc	r8,80004598 <xnl_device_auth_reply_func+0x110>
80004492:	11 88       	ld.ub	r8,r8[0x0]
80004494:	58 08       	cp.w	r8,0
80004496:	e0 81 00 7f 	brne	80004594 <xnl_device_auth_reply_func+0x10c>
	{
		return;		
	}
	
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);
8000449a:	4c 18       	lddpc	r8,8000459c <xnl_device_auth_reply_func+0x114>
8000449c:	70 0c       	ld.w	r12,r8[0x0]
8000449e:	30 09       	mov	r9,0
800044a0:	12 9a       	mov	r10,r9
800044a2:	12 9b       	mov	r11,r9
800044a4:	f0 1f 00 3f 	mcall	800045a0 <xnl_device_auth_reply_func+0x118>

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
800044a8:	ef 09 00 10 	ld.sh	r9,r7[16]
	/*No timeout*/		
	xSemaphoreGive(xnl_timeout_semphr);

	
	/*Temporarily use temporary device address*/
	xnl_information.device_address = 
800044ac:	4b b8       	lddpc	r8,80004598 <xnl_device_auth_reply_func+0x110>
800044ae:	b0 29       	st.h	r8[0x4],r9
	    xnl->xnl_payload.xnl_content_device_auth_key_reply.temporary_xnl_address;
	
	/*Get Array of values to be encrypted into an aligned 2X32bits.*/
	v_vector[0] =
800044b0:	ef 39 00 12 	ld.ub	r9,r7[18]
800044b4:	ef 38 00 13 	ld.ub	r8,r7[19]
800044b8:	b1 68       	lsl	r8,0x10
800044ba:	f1 e9 11 89 	or	r9,r8,r9<<0x18
800044be:	ef 38 00 15 	ld.ub	r8,r7[21]
800044c2:	f3 e8 10 08 	or	r8,r9,r8
800044c6:	ef 39 00 14 	ld.ub	r9,r7[20]
800044ca:	f1 e9 10 89 	or	r9,r8,r9<<0x8
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[2])<<8	  
	| (xnl->xnl_payload.xnl_content_device_auth_key_reply
	  .unencrypted_authentication_value[3]);
	
	v_vector[1] =
800044ce:	ef 3a 00 16 	ld.ub	r10,r7[22]
800044d2:	ef 38 00 17 	ld.ub	r8,r7[23]
800044d6:	b1 68       	lsl	r8,0x10
800044d8:	f1 ea 11 8a 	or	r10,r8,r10<<0x18
800044dc:	ef 38 00 19 	ld.ub	r8,r7[25]
800044e0:	f5 e8 10 08 	or	r8,r10,r8
800044e4:	ef 3a 00 18 	ld.ub	r10,r7[24]
800044e8:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800044ec:	30 0a       	mov	r10,0
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
800044ee:	e0 64 79 b9 	mov	r4,31161
800044f2:	ea 14 9e 37 	orh	r4,0x9e37
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
800044f6:	e0 65 45 07 	mov	r5,17671
800044fa:	ea 15 8a bd 	orh	r5,0x8abd
800044fe:	e0 66 f9 3d 	mov	r6,63805
80004502:	ea 16 99 68 	orh	r6,0x9968
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004506:	e0 6e b8 cf 	mov	lr,47311
8000450a:	ea 1e 36 83 	orh	lr,0x3683
8000450e:	e0 67 aa 1c 	mov	r7,43548
80004512:	ea 17 9c 36 	orh	r7,0x9c36
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
	{
		sum += authDelta;		
80004516:	08 0a       	add	r10,r4
		y += ((z << 4)+a) ^ (z+sum) ^ ((z >> 5)+b);
80004518:	f4 08 00 0c 	add	r12,r10,r8
8000451c:	f0 0b 15 04 	lsl	r11,r8,0x4
80004520:	0a 0b       	add	r11,r5
80004522:	f9 eb 20 0b 	eor	r11,r12,r11
80004526:	f0 0c 16 05 	lsr	r12,r8,0x5
8000452a:	0c 0c       	add	r12,r6
8000452c:	18 5b       	eor	r11,r12
8000452e:	16 09       	add	r9,r11
		z += ((y << 4)+c) ^ (y+sum) ^ ((y >> 5)+d);
80004530:	f2 0c 15 04 	lsl	r12,r9,0x4
80004534:	1c 0c       	add	r12,lr
80004536:	f2 0b 16 05 	lsr	r11,r9,0x5
8000453a:	0e 0b       	add	r11,r7
8000453c:	f9 eb 20 0b 	eor	r11,r12,r11
80004540:	f2 0a 00 0c 	add	r12,r9,r10
80004544:	18 5b       	eor	r11,r12
80004546:	16 08       	add	r8,r11
{
	register U32 y=v[0], z=v[1], sum=0;
	register U32 a=k[0], b=k[1], c=k[2], d=k[3];
	register U32 n=32;

	while(n-->0)
80004548:	e0 6b 37 20 	mov	r11,14112
8000454c:	ea 1b c6 ef 	orh	r11,0xc6ef
80004550:	16 3a       	cp.w	r10,r11
80004552:	ce 21       	brne	80004516 <xnl_device_auth_reply_func+0x8e>
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :24 + 2(xnl length(24) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 24 + 2;
80004554:	e0 6a 40 1a 	mov	r10,16410
80004558:	ba 0a       	st.h	sp[0x0],r10
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
8000455a:	3f fa       	mov	r10,-1
8000455c:	ba 1a       	st.h	sp[0x2],r10
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_CONN_REQUEST;
8000455e:	30 6b       	mov	r11,6
80004560:	ba 2b       	st.h	sp[0x4],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
80004562:	ba 3a       	st.h	sp[0x6],r10
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
80004564:	48 db       	lddpc	r11,80004598 <xnl_device_auth_reply_func+0x110>
80004566:	96 1c       	ld.sh	r12,r11[0x2]
80004568:	ba 4c       	st.h	sp[0x8],r12
	message here, and all will receive the same DEVICE_CONN_REPLY. Not real 
	sure what's going to happen with multiple conrol heads, etc. One suspects 
	the Rocket Scientists will eventually figure this out, and demand a 
	transaction ID based on Device Type in the XNL_DEVICE_AUTH_KEY_REQUEST.
	*/
	xnl_frame.xnl_header.source = xnl_information.device_address;
8000456a:	96 2b       	ld.sh	r11,r11[0x4]
8000456c:	ba 5b       	st.h	sp[0xa],r11
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
8000456e:	ba 6a       	st.h	sp[0xc],r10
	
    /*his message contains 12 payload bytes*/	
	xnl_frame.xnl_header.payload_length = 0x000C;
80004570:	30 ca       	mov	r10,12
80004572:	ba 7a       	st.h	sp[0xe],r10
	
	/*No Preferred XNL Address*/
	xnl_frame.xnl_payload.xnl_content_device_conn_req.preferred_xnl_address = 
80004574:	30 0a       	mov	r10,0
80004576:	fb 5a 00 10 	st.h	sp[16],r10
	XCMP/XNL Development Specification Section 4.5.3.2.1.
	Same as in MOTOTRBO?XCMP/XNL Development Specification?
	evice_type--Option Board(0x07)
	authentication_index--Option Board(0x02)
	*/	
	xnl_frame.xnl_payload.xnl_content_device_conn_req.device_type = 0x07;
8000457a:	30 7a       	mov	r10,7
8000457c:	fb 6a 00 12 	st.b	sp[18],r10
	xnl_frame.xnl_payload.xnl_content_device_conn_req.authentication_index =
80004580:	30 2a       	mov	r10,2
80004582:	fb 6a 00 13 	st.b	sp[19],r10
	                                                                       0x02;
		
	//We know encrypted array happens to be aligned to 32-bit boundary.
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
80004586:	fa ca ff ec 	sub	r10,sp,-20
8000458a:	95 09       	st.w	r10[0x0],r9
	                         .encrypted_authentication_value[0])) = w_vector[0];
	*((U32 *)(&xnl_frame.xnl_payload.xnl_content_device_conn_req
8000458c:	95 18       	st.w	r10[0x4],r8
	                         .encrypted_authentication_value[4])) = w_vector[1];
	
	/*send XNL message*/
	xnl_tx(&xnl_frame);
8000458e:	1a 9c       	mov	r12,sp
80004590:	f0 1f 00 05 	mcall	800045a4 <xnl_device_auth_reply_func+0x11c>
}
80004594:	2c 0d       	sub	sp,-256
80004596:	d8 22       	popm	r4-r7,pc
80004598:	00 00       	add	r0,r0
8000459a:	0b 4a       	ld.w	r10,--r5
8000459c:	00 00       	add	r0,r0
8000459e:	0b 44       	ld.w	r4,--r5
800045a0:	80 00       	ld.sh	r0,r0[0x0]
800045a2:	66 10       	ld.w	r0,r3[0x4]
800045a4:	80 00       	ld.sh	r0,r0[0x0]
800045a6:	43 44       	lddsp	r4,sp[0xd0]

800045a8 <xnl_master_status_brdcst_func>:
Description: process while receive master status boardcast.
Calls:xSemaphoreGive--freestos,xnl_tx
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_master_status_brdcst_func(xnl_fragment_t * xnl)
{	
800045a8:	eb cd 40 80 	pushm	r7,lr
800045ac:	fa cd 01 00 	sub	sp,sp,256
800045b0:	18 97       	mov	r7,r12
	not an XNL_DATA_MSG has been sent out. This will indicate to a connecting 
	device that it has missed messages. The XNL header will contain the 
	master?XNL address. 5.4.1
	*/
	
	if(xnl_information.is_connected)
800045b2:	49 28       	lddpc	r8,800045f8 <xnl_master_status_brdcst_func+0x50>
800045b4:	11 88       	ld.ub	r8,r8[0x0]
800045b6:	58 08       	cp.w	r8,0
800045b8:	c1 c1       	brne	800045f0 <xnl_master_status_brdcst_func+0x48>
	{
		return;	
	}
		
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);	
800045ba:	49 18       	lddpc	r8,800045fc <xnl_master_status_brdcst_func+0x54>
800045bc:	70 0c       	ld.w	r12,r8[0x0]
800045be:	30 09       	mov	r9,0
800045c0:	12 9a       	mov	r10,r9
800045c2:	12 9b       	mov	r11,r9
800045c4:	f0 1f 00 0f 	mcall	80004600 <xnl_master_status_brdcst_func+0x58>

	//log("xnl-ma:%4x", xnl->xnl_header.source);
	/*get the master adderss from this message*/	
	xnl_information.master_address = xnl->xnl_header.source;	
800045c8:	8e 58       	ld.sh	r8,r7[0xa]
800045ca:	48 c9       	lddpc	r9,800045f8 <xnl_master_status_brdcst_func+0x50>
800045cc:	b2 18       	st.h	r9[0x2],r8
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
800045ce:	e0 68 40 0e 	mov	r8,16398
800045d2:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
800045d4:	3f f8       	mov	r8,-1
800045d6:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_AUTH_KEY_REQUEST;
800045d8:	30 4a       	mov	r10,4
800045da:	ba 2a       	st.h	sp[0x4],r10
		
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/	
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;
800045dc:	ba 38       	st.h	sp[0x6],r8
	
	/*Use actual Master address.*/
	xnl_frame.xnl_header.destination = xnl_information.master_address;
800045de:	92 19       	ld.sh	r9,r9[0x2]
800045e0:	ba 49       	st.h	sp[0x8],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.source = DEFAULT_VALUE;
800045e2:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
800045e4:	ba 68       	st.h	sp[0xc],r8
		
	xnl_frame.xnl_header.payload_length = 0;
800045e6:	30 08       	mov	r8,0
800045e8:	ba 78       	st.h	sp[0xe],r8
	
	/*send XNL message*/	
	xnl_tx(&xnl_frame);
800045ea:	1a 9c       	mov	r12,sp
800045ec:	f0 1f 00 06 	mcall	80004604 <xnl_master_status_brdcst_func+0x5c>
}
800045f0:	2c 0d       	sub	sp,-256
800045f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800045f6:	00 00       	add	r0,r0
800045f8:	00 00       	add	r0,r0
800045fa:	0b 4a       	ld.w	r10,--r5
800045fc:	00 00       	add	r0,r0
800045fe:	0b 44       	ld.w	r4,--r5
80004600:	80 00       	ld.sh	r0,r0[0x0]
80004602:	66 10       	ld.w	r0,r3[0x4]
80004604:	80 00       	ld.sh	r0,r0[0x0]
80004606:	43 44       	lddsp	r4,sp[0xd0]

80004608 <xnl_device_conn_reply_func>:
Description: process while receive device conn reply.
Calls:xSemaphoreGive--freestos
Register:xnl_proc_list exec in xnl_rx_process
*/
void xnl_device_conn_reply_func(xnl_fragment_t * xnl)
{
80004608:	eb cd 40 80 	pushm	r7,lr
8000460c:	18 97       	mov	r7,r12
	transaction ID and an 8-byte encrypted value that the device can use to 
	authenticate the master. XCMP/XNL Development Guide 5.4.6
	*/
	
	/*No timeout*/	
	xSemaphoreGive(xnl_timeout_semphr);
8000460e:	49 28       	lddpc	r8,80004654 <xnl_device_conn_reply_func+0x4c>
80004610:	70 0c       	ld.w	r12,r8[0x0]
80004612:	30 09       	mov	r9,0
80004614:	12 9a       	mov	r10,r9
80004616:	12 9b       	mov	r11,r9
80004618:	f0 1f 00 10 	mcall	80004658 <xnl_device_conn_reply_func+0x50>

	/*Test result code*/
	if((xnl->xnl_payload.xnl_content_device_conn_reply.result_base & 0x0000FF00)
8000461c:	ef 18 00 10 	ld.uh	r8,r7[16]
80004620:	10 99       	mov	r9,r8
80004622:	e2 19 ff 00 	andl	r9,0xff00,COH
80004626:	e0 49 01 00 	cp.w	r9,256
8000462a:	c0 60       	breq	80004636 <xnl_device_conn_reply_func+0x2e>
		/*
		Rejected. The device must retry the authentication process at this 
		point by sending out a new AUTH_KEY_REQUEST message. XCMP/XNL 
		Development Guide Section 5.2.3
		*/
		xnl_master_status_brdcst_func(xnl);			
8000462c:	0e 9c       	mov	r12,r7
8000462e:	f0 1f 00 0c 	mcall	8000465c <xnl_device_conn_reply_func+0x54>
80004632:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/*connection accepted*/		
		/*Record Transaction ID Base*/
		xnl_information.transaction_id =  
80004636:	a9 68       	lsl	r8,0x8
80004638:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000463c:	48 98       	lddpc	r8,80004660 <xnl_device_conn_reply_func+0x58>
8000463e:	b0 49       	st.h	r8[0x8],r9
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
80004640:	ef 09 00 14 	ld.sh	r9,r7[20]
		xnl_information.transaction_id =  
					(xnl->xnl_payload.xnl_content_device_conn_reply.result_base
					& 0x000000FF) << 8;
		
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
80004644:	b0 39       	st.h	r8[0x6],r9
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
80004646:	ef 09 00 12 	ld.sh	r9,r7[18]
		/*Record Device Logical Address*/
		xnl_information.logical_address = 
		          xnl->xnl_payload.xnl_content_device_conn_reply.logical_address;
		
		/*Record permanent device address*/
		xnl_information.device_address = 
8000464a:	b0 29       	st.h	r8[0x4],r9
				      xnl->xnl_payload.xnl_content_device_conn_reply.xnl_address;
		
		/*connect finish*/
		xnl_information.is_connected = TRUE;
8000464c:	30 19       	mov	r9,1
8000464e:	b0 89       	st.b	r8[0x0],r9
80004650:	e3 cd 80 80 	ldm	sp++,r7,pc
80004654:	00 00       	add	r0,r0
80004656:	0b 44       	ld.w	r4,--r5
80004658:	80 00       	ld.sh	r0,r0[0x0]
8000465a:	66 10       	ld.w	r0,r3[0x4]
8000465c:	80 00       	ld.sh	r0,r0[0x0]
8000465e:	45 a8       	lddsp	r8,sp[0x168]
80004660:	00 00       	add	r0,r0
80004662:	0b 4a       	ld.w	r10,--r5

80004664 <xnl_send_device_master_query>:
Description: send device_master_query to connect radio.
Calls:xnl_tx
Call By:xnl_init
*/
void xnl_send_device_master_query(void)
{
80004664:	d4 01       	pushm	lr
80004666:	fa cd 01 00 	sub	sp,sp,256
	/*
	Data Type 0x4000
	Fragment Type:0
	Length :12 + 2(xnl length(12) + checksum(2)) 
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | 12 + 2;
8000466a:	e0 68 40 0e 	mov	r8,16398
8000466e:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE;
80004670:	3f f8       	mov	r8,-1
80004672:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DEVICE_MASTER_QUERY;
80004674:	30 38       	mov	r8,3
80004676:	ba 28       	st.h	sp[0x4],r8
	
	/*The initial value*/
	xnl_frame.xnl_header.flags = 0;
80004678:	30 08       	mov	r8,0
8000467a:	ba 38       	st.h	sp[0x6],r8
	
	/*XNL address of the master device, if known;otherwise 0x0000*/
	xnl_frame.xnl_header.destination = 0;
8000467c:	ba 48       	st.h	sp[0x8],r8
	
	/*XNL address, if assigned; otherwise 0x0000*/
	xnl_frame.xnl_header.source = 0;
8000467e:	ba 58       	st.h	sp[0xa],r8
	
	/*No transaction ID required for this message*/
	xnl_frame.xnl_header.transaction_id = 0;
80004680:	ba 68       	st.h	sp[0xc],r8
	
	/*This message contains no payload*/
	xnl_frame.xnl_header.payload_length = 0;
80004682:	ba 78       	st.h	sp[0xe],r8

	/*send XNL message*/
	xnl_tx(&xnl_frame);
80004684:	1a 9c       	mov	r12,sp
80004686:	f0 1f 00 03 	mcall	80004690 <xnl_send_device_master_query+0x2c>
}
8000468a:	2c 0d       	sub	sp,-256
8000468c:	d8 02       	popm	pc
8000468e:	00 00       	add	r0,r0
80004690:	80 00       	ld.sh	r0,r0[0x0]
80004692:	43 44       	lddsp	r4,sp[0xd0]

80004694 <RC522_SPI_SetSpeed>:
	SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80004694:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
80004696:	48 78       	lddpc	r8,800046b0 <RC522_SPI_SetSpeed+0x1c>
80004698:	70 09       	ld.w	r9,r8[0x0]
8000469a:	72 ca       	ld.w	r10,r9[0x30]
8000469c:	5c 7c       	castu.h	r12
8000469e:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
800046a2:	f9 ea 10 0a 	or	r10,r12,r10
800046a6:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
800046a8:	70 0c       	ld.w	r12,r8[0x0]
800046aa:	f0 1f 00 03 	mcall	800046b4 <RC522_SPI_SetSpeed+0x20>
		
	
}
800046ae:	d8 02       	popm	pc
800046b0:	00 00       	add	r0,r0
800046b2:	20 84       	sub	r4,8
800046b4:	80 00       	ld.sh	r0,r0[0x0]
800046b6:	5b 00       	cp.w	r0,-16

800046b8 <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
800046b8:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
800046ba:	e0 6c 04 00 	mov	r12,1024
800046be:	f0 1f 00 02 	mcall	800046c4 <RC522_SPI_SetSpeedLow+0xc>
	
}
800046c2:	d8 02       	popm	pc
800046c4:	80 00       	ld.sh	r0,r0[0x0]
800046c6:	46 94       	lddsp	r4,sp[0x1a4]

800046c8 <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
800046c8:	eb cd 40 c0 	pushm	r6-r7,lr
	U16 *Data ;

	//蹇椤昏锋芥ｅ父璇诲
	spi_selectChip(spi, DF_SPI_PCS_0);
800046cc:	48 b7       	lddpc	r7,800046f8 <RC522_ReadByte+0x30>
800046ce:	30 0b       	mov	r11,0
800046d0:	6e 0c       	ld.w	r12,r7[0x0]
800046d2:	f0 1f 00 0b 	mcall	800046fc <RC522_ReadByte+0x34>
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800046d6:	e0 6b 00 ff 	mov	r11,255
800046da:	6e 0c       	ld.w	r12,r7[0x0]
800046dc:	f0 1f 00 09 	mcall	80004700 <RC522_ReadByte+0x38>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800046e0:	30 06       	mov	r6,0
800046e2:	0c 9b       	mov	r11,r6
800046e4:	6e 0c       	ld.w	r12,r7[0x0]
800046e6:	f0 1f 00 08 	mcall	80004704 <RC522_ReadByte+0x3c>

	/*!< Return the shifted data */
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800046ea:	0c 9b       	mov	r11,r6
800046ec:	6e 0c       	ld.w	r12,r7[0x0]
800046ee:	f0 1f 00 07 	mcall	80004708 <RC522_ReadByte+0x40>
	
	return (U8)(*Data);
	
}
800046f2:	0d 9c       	ld.ub	r12,r6[0x1]
800046f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800046f8:	00 00       	add	r0,r0
800046fa:	20 84       	sub	r4,8
800046fc:	80 00       	ld.sh	r0,r0[0x0]
800046fe:	5c 6c       	casts.b	r12
80004700:	80 00       	ld.sh	r0,r0[0x0]
80004702:	5b 06       	cp.w	r6,-16
80004704:	80 00       	ld.sh	r0,r0[0x0]
80004706:	5b 22       	cp.w	r2,-14
80004708:	80 00       	ld.sh	r0,r0[0x0]
8000470a:	5c 2c       	cpc	r12

8000470c <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
8000470c:	eb cd 40 c0 	pushm	r6-r7,lr
80004710:	20 1d       	sub	sp,4
80004712:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	spi_selectChip(spi, DF_SPI_PCS_0);
80004714:	48 c7       	lddpc	r7,80004744 <RC522_WriteByte+0x38>
80004716:	30 0b       	mov	r11,0
80004718:	6e 0c       	ld.w	r12,r7[0x0]
8000471a:	f0 1f 00 0c 	mcall	80004748 <RC522_WriteByte+0x3c>
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
8000471e:	1b 8b       	ld.ub	r11,sp[0x0]
80004720:	6e 0c       	ld.w	r12,r7[0x0]
80004722:	f0 1f 00 0b 	mcall	8000474c <RC522_WriteByte+0x40>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
80004726:	1a 9b       	mov	r11,sp
80004728:	6e 0c       	ld.w	r12,r7[0x0]
8000472a:	f0 1f 00 0a 	mcall	80004750 <RC522_WriteByte+0x44>
8000472e:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
80004730:	30 0b       	mov	r11,0
80004732:	6e 0c       	ld.w	r12,r7[0x0]
80004734:	f0 1f 00 08 	mcall	80004754 <RC522_WriteByte+0x48>
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
80004738:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
8000473c:	2f fd       	sub	sp,-4
8000473e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004742:	00 00       	add	r0,r0
80004744:	00 00       	add	r0,r0
80004746:	20 84       	sub	r4,8
80004748:	80 00       	ld.sh	r0,r0[0x0]
8000474a:	5c 6c       	casts.b	r12
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	5b 06       	cp.w	r6,-16
80004750:	80 00       	ld.sh	r0,r0[0x0]
80004752:	5b 22       	cp.w	r2,-14
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	5c 2c       	cpc	r12

80004758 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
80004758:	eb cd 40 c0 	pushm	r6-r7,lr
8000475c:	18 96       	mov	r6,r12
8000475e:	16 97       	mov	r7,r11
	U8   ucAddr;

	CLR_SPI_CS;	
80004760:	31 8c       	mov	r12,24
80004762:	f0 1f 00 09 	mcall	80004784 <WriteRawRC+0x2c>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
80004766:	ec 0c 15 01 	lsl	r12,r6,0x1
8000476a:	e2 1c 00 7e 	andl	r12,0x7e,COH
8000476e:	f0 1f 00 07 	mcall	80004788 <WriteRawRC+0x30>
	RC522_WriteByte(value);
80004772:	0e 9c       	mov	r12,r7
80004774:	f0 1f 00 05 	mcall	80004788 <WriteRawRC+0x30>
	
	SET_SPI_CS;
80004778:	31 8c       	mov	r12,24
8000477a:	f0 1f 00 05 	mcall	8000478c <WriteRawRC+0x34>

}
8000477e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004782:	00 00       	add	r0,r0
80004784:	80 00       	ld.sh	r0,r0[0x0]
80004786:	59 50       	cp.w	r0,21
80004788:	80 00       	ld.sh	r0,r0[0x0]
8000478a:	47 0c       	lddsp	r12,sp[0x1c0]
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	59 34       	cp.w	r4,19

80004790 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80004790:	d4 01       	pushm	lr

	SET_RC522RST;
80004792:	31 9c       	mov	r12,25
80004794:	f0 1f 00 1b 	mcall	80004800 <PcdReset+0x70>
	delay_ns(10);
80004798:	30 ac       	mov	r12,10
8000479a:	f0 1f 00 1b 	mcall	80004804 <PcdReset+0x74>

	CLR_RC522RST;
8000479e:	31 9c       	mov	r12,25
800047a0:	f0 1f 00 1a 	mcall	80004808 <PcdReset+0x78>
	delay_ns(10);
800047a4:	30 ac       	mov	r12,10
800047a6:	f0 1f 00 18 	mcall	80004804 <PcdReset+0x74>

	SET_RC522RST;
800047aa:	31 9c       	mov	r12,25
800047ac:	f0 1f 00 15 	mcall	80004800 <PcdReset+0x70>
	delay_ns(10);
800047b0:	30 ac       	mov	r12,10
800047b2:	f0 1f 00 15 	mcall	80004804 <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800047b6:	30 fb       	mov	r11,15
800047b8:	30 1c       	mov	r12,1
800047ba:	f0 1f 00 15 	mcall	8000480c <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
800047be:	30 fb       	mov	r11,15
800047c0:	30 1c       	mov	r12,1
800047c2:	f0 1f 00 13 	mcall	8000480c <PcdReset+0x7c>
	delay_ns(10);
800047c6:	30 ac       	mov	r12,10
800047c8:	f0 1f 00 0f 	mcall	80004804 <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
800047cc:	33 db       	mov	r11,61
800047ce:	31 1c       	mov	r12,17
800047d0:	f0 1f 00 0f 	mcall	8000480c <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
800047d4:	31 eb       	mov	r11,30
800047d6:	32 dc       	mov	r12,45
800047d8:	f0 1f 00 0d 	mcall	8000480c <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
800047dc:	30 0b       	mov	r11,0
800047de:	32 cc       	mov	r12,44
800047e0:	f0 1f 00 0b 	mcall	8000480c <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
800047e4:	e0 6b 00 8d 	mov	r11,141
800047e8:	32 ac       	mov	r12,42
800047ea:	f0 1f 00 09 	mcall	8000480c <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
800047ee:	33 eb       	mov	r11,62
800047f0:	32 bc       	mov	r12,43
800047f2:	f0 1f 00 07 	mcall	8000480c <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
800047f6:	34 0b       	mov	r11,64
800047f8:	31 5c       	mov	r12,21
800047fa:	f0 1f 00 05 	mcall	8000480c <PcdReset+0x7c>
	
	return MI_OK;
}
800047fe:	d8 0a       	popm	pc,r12=0
80004800:	80 00       	ld.sh	r0,r0[0x0]
80004802:	59 34       	cp.w	r4,19
80004804:	80 00       	ld.sh	r0,r0[0x0]
80004806:	50 58       	stdsp	sp[0x14],r8
80004808:	80 00       	ld.sh	r0,r0[0x0]
8000480a:	59 50       	cp.w	r0,21
8000480c:	80 00       	ld.sh	r0,r0[0x0]
8000480e:	47 58       	lddsp	r8,sp[0x1d4]

80004810 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
80004810:	eb cd 40 80 	pushm	r7,lr
80004814:	18 97       	mov	r7,r12
	U8   ucAddr;
	U8   ucResult=0;
	CLR_SPI_CS;	
80004816:	31 8c       	mov	r12,24
80004818:	f0 1f 00 0a 	mcall	80004840 <ReadRawRC+0x30>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
8000481c:	ee 08 15 01 	lsl	r8,r7,0x1
80004820:	10 9c       	mov	r12,r8
80004822:	e2 1c 00 7e 	andl	r12,0x7e,COH
80004826:	a7 bc       	sbr	r12,0x7
80004828:	f0 1f 00 07 	mcall	80004844 <ReadRawRC+0x34>
	ucResult = RC522_ReadByte();
8000482c:	f0 1f 00 07 	mcall	80004848 <ReadRawRC+0x38>
80004830:	18 97       	mov	r7,r12
	
	SET_SPI_CS;
80004832:	31 8c       	mov	r12,24
80004834:	f0 1f 00 06 	mcall	8000484c <ReadRawRC+0x3c>
	return ucResult;
}
80004838:	0e 9c       	mov	r12,r7
8000483a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000483e:	00 00       	add	r0,r0
80004840:	80 00       	ld.sh	r0,r0[0x0]
80004842:	59 50       	cp.w	r0,21
80004844:	80 00       	ld.sh	r0,r0[0x0]
80004846:	47 0c       	lddsp	r12,sp[0x1c0]
80004848:	80 00       	ld.sh	r0,r0[0x0]
8000484a:	46 c8       	lddsp	r8,sp[0x1b0]
8000484c:	80 00       	ld.sh	r0,r0[0x0]
8000484e:	59 34       	cp.w	r4,19

80004850 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80004850:	eb cd 40 c0 	pushm	r6-r7,lr
80004854:	18 97       	mov	r7,r12
80004856:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80004858:	f0 1f 00 05 	mcall	8000486c <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
8000485c:	f9 e6 10 0b 	or	r11,r12,r6
80004860:	5c 5b       	castu.b	r11
80004862:	0e 9c       	mov	r12,r7
80004864:	f0 1f 00 03 	mcall	80004870 <SetBitMask+0x20>
}
80004868:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000486c:	80 00       	ld.sh	r0,r0[0x0]
8000486e:	48 10       	lddpc	r0,80004870 <SetBitMask+0x20>
80004870:	80 00       	ld.sh	r0,r0[0x0]
80004872:	47 58       	lddsp	r8,sp[0x1d4]

80004874 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80004874:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80004876:	31 4c       	mov	r12,20
80004878:	f0 1f 00 05 	mcall	8000488c <PcdAntennaOn+0x18>
	if (!(i & 0x03))
8000487c:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80004880:	c0 51       	brne	8000488a <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80004882:	30 3b       	mov	r11,3
80004884:	31 4c       	mov	r12,20
80004886:	f0 1f 00 03 	mcall	80004890 <PcdAntennaOn+0x1c>
8000488a:	d8 02       	popm	pc
8000488c:	80 00       	ld.sh	r0,r0[0x0]
8000488e:	48 10       	lddpc	r0,80004890 <PcdAntennaOn+0x1c>
80004890:	80 00       	ld.sh	r0,r0[0x0]
80004892:	48 50       	lddpc	r0,800048a4 <ClearBitMask+0x10>

80004894 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80004894:	eb cd 40 c0 	pushm	r6-r7,lr
80004898:	18 97       	mov	r7,r12
8000489a:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
8000489c:	f0 1f 00 06 	mcall	800048b4 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
800048a0:	5c d6       	com	r6
800048a2:	f9 e6 00 06 	and	r6,r12,r6
800048a6:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
800048aa:	0e 9c       	mov	r12,r7
800048ac:	f0 1f 00 03 	mcall	800048b8 <ClearBitMask+0x24>
	
}
800048b0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800048b4:	80 00       	ld.sh	r0,r0[0x0]
800048b6:	48 10       	lddpc	r0,800048b8 <ClearBitMask+0x24>
800048b8:	80 00       	ld.sh	r0,r0[0x0]
800048ba:	47 58       	lddsp	r8,sp[0x1d4]

800048bc <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
800048bc:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
800048be:	30 3b       	mov	r11,3
800048c0:	31 4c       	mov	r12,20
800048c2:	f0 1f 00 02 	mcall	800048c8 <PcdAntennaOff+0xc>
}
800048c6:	d8 02       	popm	pc
800048c8:	80 00       	ld.sh	r0,r0[0x0]
800048ca:	48 94       	lddpc	r4,800048ec <M500PcdConfigISOType+0x20>

800048cc <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
800048cc:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
800048ce:	34 18       	mov	r8,65
800048d0:	f0 0c 18 00 	cp.b	r12,r8
800048d4:	c0 20       	breq	800048d8 <M500PcdConfigISOType+0xc>
800048d6:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
800048d8:	30 8b       	mov	r11,8
800048da:	16 9c       	mov	r12,r11
800048dc:	f0 1f 00 14 	mcall	8000492c <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
800048e0:	33 db       	mov	r11,61
800048e2:	31 1c       	mov	r12,17
800048e4:	f0 1f 00 13 	mcall	80004930 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
800048e8:	e0 6b 00 86 	mov	r11,134
800048ec:	31 7c       	mov	r12,23
800048ee:	f0 1f 00 11 	mcall	80004930 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800048f2:	37 fb       	mov	r11,127
800048f4:	32 6c       	mov	r12,38
800048f6:	f0 1f 00 0f 	mcall	80004930 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
800048fa:	31 eb       	mov	r11,30
800048fc:	32 dc       	mov	r12,45
800048fe:	f0 1f 00 0d 	mcall	80004930 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
80004902:	30 0b       	mov	r11,0
80004904:	32 cc       	mov	r12,44
80004906:	f0 1f 00 0b 	mcall	80004930 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
8000490a:	e0 6b 00 8d 	mov	r11,141
8000490e:	32 ac       	mov	r12,42
80004910:	f0 1f 00 08 	mcall	80004930 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
80004914:	33 eb       	mov	r11,62
80004916:	32 bc       	mov	r12,43
80004918:	f0 1f 00 06 	mcall	80004930 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
8000491c:	e0 6c 03 e8 	mov	r12,1000
80004920:	f0 1f 00 05 	mcall	80004934 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
80004924:	f0 1f 00 05 	mcall	80004938 <M500PcdConfigISOType+0x6c>
80004928:	d8 0a       	popm	pc,r12=0
8000492a:	00 00       	add	r0,r0
8000492c:	80 00       	ld.sh	r0,r0[0x0]
8000492e:	48 94       	lddpc	r4,80004950 <rc522_init+0x14>
80004930:	80 00       	ld.sh	r0,r0[0x0]
80004932:	47 58       	lddsp	r8,sp[0x1d4]
80004934:	80 00       	ld.sh	r0,r0[0x0]
80004936:	50 58       	stdsp	sp[0x14],r8
80004938:	80 00       	ld.sh	r0,r0[0x0]
8000493a:	48 74       	lddpc	r4,80004954 <rc522_init+0x18>

8000493c <rc522_init>:


//mfrc522 init

void rc522_init()
{
8000493c:	eb cd 40 c0 	pushm	r6-r7,lr
80004940:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004942:	4a 28       	lddpc	r8,800049c8 <rc522_init+0x8c>
80004944:	1a 96       	mov	r6,sp
80004946:	f0 ea 00 00 	ld.d	r10,r8[0]
8000494a:	fa eb 00 00 	st.d	sp[0],r10
8000494e:	f0 e8 00 08 	ld.d	r8,r8[8]
80004952:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80004956:	30 4b       	mov	r11,4
80004958:	49 dc       	lddpc	r12,800049cc <rc522_init+0x90>
8000495a:	f0 1f 00 1e 	mcall	800049d0 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
8000495e:	31 9c       	mov	r12,25
80004960:	f0 1f 00 1d 	mcall	800049d4 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80004964:	31 9c       	mov	r12,25
80004966:	f0 1f 00 1d 	mcall	800049d8 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
8000496a:	49 d7       	lddpc	r7,800049dc <rc522_init+0xa0>
8000496c:	fe 7c 24 00 	mov	r12,-56320
80004970:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80004972:	1a 9b       	mov	r11,sp
80004974:	f0 1f 00 1b 	mcall	800049e0 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80004978:	30 09       	mov	r9,0
8000497a:	12 9a       	mov	r10,r9
8000497c:	12 9b       	mov	r11,r9
8000497e:	6e 0c       	ld.w	r12,r7[0x0]
80004980:	f0 1f 00 19 	mcall	800049e4 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80004984:	6e 0c       	ld.w	r12,r7[0x0]
80004986:	f0 1f 00 19 	mcall	800049e8 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
8000498a:	e0 6a 36 00 	mov	r10,13824
8000498e:	ea 1a 01 6e 	orh	r10,0x16e
80004992:	1a 9b       	mov	r11,sp
80004994:	6e 0c       	ld.w	r12,r7[0x0]
80004996:	f0 1f 00 16 	mcall	800049ec <rc522_init+0xb0>
8000499a:	c0 50       	breq	800049a4 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
8000499c:	30 29       	mov	r9,2
8000499e:	49 58       	lddpc	r8,800049f0 <rc522_init+0xb4>
800049a0:	b0 89       	st.b	r8[0x0],r9
800049a2:	c0 38       	rjmp	800049a8 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
800049a4:	f0 1f 00 14 	mcall	800049f4 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
800049a8:	f0 1f 00 14 	mcall	800049f8 <rc522_init+0xbc>
	
	PcdAntennaOff();
800049ac:	f0 1f 00 14 	mcall	800049fc <rc522_init+0xc0>
	
	delay_ms(2); 
800049b0:	30 2c       	mov	r12,2
800049b2:	f0 1f 00 14 	mcall	80004a00 <rc522_init+0xc4>
	
	PcdAntennaOn();
800049b6:	f0 1f 00 14 	mcall	80004a04 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
800049ba:	34 1c       	mov	r12,65
800049bc:	f0 1f 00 13 	mcall	80004a08 <rc522_init+0xcc>
	

800049c0:	2f cd       	sub	sp,-16
800049c2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049c6:	00 00       	add	r0,r0
800049c8:	80 00       	ld.sh	r0,r0[0x0]
800049ca:	d9 ec       	*unknown*
800049cc:	80 00       	ld.sh	r0,r0[0x0]
800049ce:	d9 c4       	*unknown*
800049d0:	80 00       	ld.sh	r0,r0[0x0]
800049d2:	58 ec       	cp.w	r12,14
800049d4:	80 00       	ld.sh	r0,r0[0x0]
800049d6:	59 1c       	cp.w	r12,17
800049d8:	80 00       	ld.sh	r0,r0[0x0]
800049da:	59 34       	cp.w	r4,19
800049dc:	00 00       	add	r0,r0
800049de:	20 84       	sub	r4,8
800049e0:	80 00       	ld.sh	r0,r0[0x0]
800049e2:	5a 9c       	cp.w	r12,-23
800049e4:	80 00       	ld.sh	r0,r0[0x0]
800049e6:	5a d4       	cp.w	r4,-19
800049e8:	80 00       	ld.sh	r0,r0[0x0]
800049ea:	5b 00       	cp.w	r0,-16
800049ec:	80 00       	ld.sh	r0,r0[0x0]
800049ee:	5b 44       	cp.w	r4,-12
800049f0:	00 00       	add	r0,r0
800049f2:	0b 68       	ld.uh	r8,--r5
800049f4:	80 00       	ld.sh	r0,r0[0x0]
800049f6:	46 b8       	lddsp	r8,sp[0x1ac]
800049f8:	80 00       	ld.sh	r0,r0[0x0]
800049fa:	47 90       	lddsp	r0,sp[0x1e4]
800049fc:	80 00       	ld.sh	r0,r0[0x0]
800049fe:	48 bc       	lddpc	r12,80004a28 <PcdComMF522+0x1c>
80004a00:	80 00       	ld.sh	r0,r0[0x0]
80004a02:	50 98       	stdsp	sp[0x24],r8
80004a04:	80 00       	ld.sh	r0,r0[0x0]
80004a06:	48 74       	lddpc	r4,80004a20 <PcdComMF522+0x14>
80004a08:	80 00       	ld.sh	r0,r0[0x0]
80004a0a:	48 cc       	lddpc	r12,80004a38 <PcdComMF522+0x2c>

80004a0c <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
80004a0c:	d4 31       	pushm	r0-r7,lr
80004a0e:	20 1d       	sub	sp,4
80004a10:	18 92       	mov	r2,r12
80004a12:	16 95       	mov	r5,r11
80004a14:	14 96       	mov	r6,r10
80004a16:	50 09       	stdsp	sp[0x0],r9
80004a18:	10 90       	mov	r0,r8
80004a1a:	f8 c8 00 0c 	sub	r8,r12,12
80004a1e:	5c 58       	castu.b	r8
80004a20:	30 29       	mov	r9,2
80004a22:	f2 08 18 00 	cp.b	r8,r9
80004a26:	e0 88 00 05 	brls	80004a30 <PcdComMF522+0x24>
80004a2a:	30 03       	mov	r3,0
80004a2c:	06 91       	mov	r1,r3
80004a2e:	c0 78       	rjmp	80004a3c <PcdComMF522+0x30>
80004a30:	4c f9       	lddpc	r9,80004b6c <PcdComMF522+0x160>
80004a32:	f2 08 07 01 	ld.ub	r1,r9[r8]
80004a36:	4c f9       	lddpc	r9,80004b70 <PcdComMF522+0x164>
80004a38:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
80004a3c:	02 9b       	mov	r11,r1
80004a3e:	a7 bb       	sbr	r11,0x7
80004a40:	30 2c       	mov	r12,2
80004a42:	f0 1f 00 4d 	mcall	80004b74 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
80004a46:	e0 6b 00 80 	mov	r11,128
80004a4a:	30 4c       	mov	r12,4
80004a4c:	f0 1f 00 4b 	mcall	80004b78 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004a50:	30 0b       	mov	r11,0
80004a52:	30 1c       	mov	r12,1
80004a54:	f0 1f 00 48 	mcall	80004b74 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80004a58:	e0 6b 00 80 	mov	r11,128
80004a5c:	30 ac       	mov	r12,10
80004a5e:	f0 1f 00 48 	mcall	80004b7c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80004a62:	58 06       	cp.w	r6,0
80004a64:	c0 c0       	breq	80004a7c <PcdComMF522+0x70>
80004a66:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80004a68:	30 94       	mov	r4,9
80004a6a:	0f 3b       	ld.ub	r11,r7++
80004a6c:	08 9c       	mov	r12,r4
80004a6e:	f0 1f 00 42 	mcall	80004b74 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80004a72:	0e 98       	mov	r8,r7
80004a74:	0a 18       	sub	r8,r5
80004a76:	ec 08 19 00 	cp.h	r8,r6
80004a7a:	cf 83       	brcs	80004a6a <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
80004a7c:	04 9b       	mov	r11,r2
80004a7e:	30 1c       	mov	r12,1
80004a80:	f0 1f 00 3d 	mcall	80004b74 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80004a84:	30 c8       	mov	r8,12
80004a86:	f0 02 18 00 	cp.b	r2,r8
80004a8a:	c0 61       	brne	80004a96 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
80004a8c:	e0 6b 00 80 	mov	r11,128
80004a90:	30 dc       	mov	r12,13
80004a92:	f0 1f 00 3b 	mcall	80004b7c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004a96:	30 4c       	mov	r12,4
80004a98:	f0 1f 00 3a 	mcall	80004b80 <PcdComMF522+0x174>
80004a9c:	18 97       	mov	r7,r12
80004a9e:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004aa2:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80004aa4:	30 44       	mov	r4,4
80004aa6:	c0 88       	rjmp	80004ab6 <PcdComMF522+0xaa>
80004aa8:	08 9c       	mov	r12,r4
80004aaa:	f0 1f 00 36 	mcall	80004b80 <PcdComMF522+0x174>
80004aae:	18 97       	mov	r7,r12
		i--;
80004ab0:	20 16       	sub	r6,1
80004ab2:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80004ab4:	c0 a0       	breq	80004ac8 <PcdComMF522+0xbc>
80004ab6:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
80004aba:	c4 c1       	brne	80004b52 <PcdComMF522+0x146>
80004abc:	ef e3 00 08 	and	r8,r7,r3
80004ac0:	ea 08 18 00 	cp.b	r8,r5
80004ac4:	cf 20       	breq	80004aa8 <PcdComMF522+0x9c>
80004ac6:	c4 68       	rjmp	80004b52 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80004ac8:	e0 6b 00 80 	mov	r11,128
80004acc:	30 dc       	mov	r12,13
80004ace:	f0 1f 00 2b 	mcall	80004b78 <PcdComMF522+0x16c>
80004ad2:	30 27       	mov	r7,2
80004ad4:	c3 38       	rjmp	80004b3a <PcdComMF522+0x12e>
80004ad6:	02 67       	and	r7,r1
80004ad8:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
80004adc:	30 c8       	mov	r8,12
80004ade:	f0 02 18 00 	cp.b	r2,r8
80004ae2:	c2 c1       	brne	80004b3a <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80004ae4:	30 ac       	mov	r12,10
80004ae6:	f0 1f 00 27 	mcall	80004b80 <PcdComMF522+0x174>
80004aea:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
80004aec:	30 cc       	mov	r12,12
80004aee:	f0 1f 00 25 	mcall	80004b80 <PcdComMF522+0x174>
80004af2:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
80004af6:	c0 70       	breq	80004b04 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
80004af8:	08 98       	mov	r8,r4
80004afa:	20 18       	sub	r8,1
80004afc:	f8 08 00 3c 	add	r12,r12,r8<<0x3
80004b00:	a0 8c       	st.b	r0[0x0],r12
80004b02:	c0 48       	rjmp	80004b0a <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
80004b04:	e8 08 15 03 	lsl	r8,r4,0x3
80004b08:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
80004b0a:	58 04       	cp.w	r4,0
80004b0c:	c0 61       	brne	80004b18 <PcdComMF522+0x10c>
80004b0e:	30 14       	mov	r4,1
80004b10:	40 05       	lddsp	r5,sp[0x0]
80004b12:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004b14:	30 93       	mov	r3,9
80004b16:	c0 98       	rjmp	80004b28 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004b18:	31 28       	mov	r8,18
80004b1a:	f0 04 18 00 	cp.b	r4,r8
80004b1e:	f9 b4 0b 12 	movhi	r4,18
80004b22:	58 04       	cp.w	r4,0
80004b24:	cf 61       	brne	80004b10 <PcdComMF522+0x104>
80004b26:	c0 a8       	rjmp	80004b3a <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
80004b28:	06 9c       	mov	r12,r3
80004b2a:	f0 1f 00 16 	mcall	80004b80 <PcdComMF522+0x174>
80004b2e:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
80004b30:	ec 05 01 08 	sub	r8,r6,r5
80004b34:	e8 08 19 00 	cp.h	r8,r4
80004b38:	cf 83       	brcs	80004b28 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
80004b3a:	e0 6b 00 80 	mov	r11,128
80004b3e:	30 cc       	mov	r12,12
80004b40:	f0 1f 00 0f 	mcall	80004b7c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
80004b44:	30 0b       	mov	r11,0
80004b46:	30 1c       	mov	r12,1
80004b48:	f0 1f 00 0b 	mcall	80004b74 <PcdComMF522+0x168>
	return status;
}
80004b4c:	0e 9c       	mov	r12,r7
80004b4e:	2f fd       	sub	sp,-4
80004b50:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80004b52:	e0 6b 00 80 	mov	r11,128
80004b56:	30 dc       	mov	r12,13
80004b58:	f0 1f 00 08 	mcall	80004b78 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
80004b5c:	30 6c       	mov	r12,6
80004b5e:	f0 1f 00 09 	mcall	80004b80 <PcdComMF522+0x174>
80004b62:	e2 1c 00 1b 	andl	r12,0x1b,COH
80004b66:	cb 80       	breq	80004ad6 <PcdComMF522+0xca>
80004b68:	30 27       	mov	r7,2
80004b6a:	ce 8b       	rjmp	80004b3a <PcdComMF522+0x12e>
80004b6c:	80 00       	ld.sh	r0,r0[0x0]
80004b6e:	d9 e4       	*unknown*
80004b70:	80 00       	ld.sh	r0,r0[0x0]
80004b72:	d9 e8       	*unknown*
80004b74:	80 00       	ld.sh	r0,r0[0x0]
80004b76:	47 58       	lddsp	r8,sp[0x1d4]
80004b78:	80 00       	ld.sh	r0,r0[0x0]
80004b7a:	48 94       	lddpc	r4,80004b9c <PcdAnticoll+0x18>
80004b7c:	80 00       	ld.sh	r0,r0[0x0]
80004b7e:	48 50       	lddpc	r0,80004b90 <PcdAnticoll+0xc>
80004b80:	80 00       	ld.sh	r0,r0[0x0]
80004b82:	48 10       	lddpc	r0,80004b84 <PcdAnticoll>

80004b84 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80004b84:	eb cd 40 c0 	pushm	r6-r7,lr
80004b88:	20 5d       	sub	sp,20
80004b8a:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
80004b8c:	30 8b       	mov	r11,8
80004b8e:	16 9c       	mov	r12,r11
80004b90:	f0 1f 00 1a 	mcall	80004bf8 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80004b94:	30 0b       	mov	r11,0
80004b96:	30 dc       	mov	r12,13
80004b98:	f0 1f 00 19 	mcall	80004bfc <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
80004b9c:	e0 6b 00 80 	mov	r11,128
80004ba0:	30 ec       	mov	r12,14
80004ba2:	f0 1f 00 16 	mcall	80004bf8 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004ba6:	39 38       	mov	r8,-109
80004ba8:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
80004baa:	32 08       	mov	r8,32
80004bac:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
80004bae:	1a 9b       	mov	r11,sp
80004bb0:	fa c8 ff ed 	sub	r8,sp,-19
80004bb4:	1a 99       	mov	r9,sp
80004bb6:	30 2a       	mov	r10,2
80004bb8:	30 cc       	mov	r12,12
80004bba:	f0 1f 00 12 	mcall	80004c00 <PcdAnticoll+0x7c>
80004bbe:	18 97       	mov	r7,r12

	if (status == MI_OK)
80004bc0:	c1 21       	brne	80004be4 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004bc2:	1b 89       	ld.ub	r9,sp[0x0]
80004bc4:	ac 89       	st.b	r6[0x0],r9
80004bc6:	1b 98       	ld.ub	r8,sp[0x1]
80004bc8:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
80004bca:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004bcc:	1b a8       	ld.ub	r8,sp[0x2]
80004bce:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80004bd0:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80004bd4:	1b b9       	ld.ub	r9,sp[0x3]
80004bd6:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80004bd8:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
80004bda:	1b c9       	ld.ub	r9,sp[0x4]
80004bdc:	f0 09 18 00 	cp.b	r9,r8
80004be0:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80004be4:	e0 6b 00 80 	mov	r11,128
80004be8:	30 ec       	mov	r12,14
80004bea:	f0 1f 00 07 	mcall	80004c04 <PcdAnticoll+0x80>
	return status;
}
80004bee:	0e 9c       	mov	r12,r7
80004bf0:	2f bd       	sub	sp,-20
80004bf2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004bf6:	00 00       	add	r0,r0
80004bf8:	80 00       	ld.sh	r0,r0[0x0]
80004bfa:	48 94       	lddpc	r4,80004c1c <PcdRequest+0x14>
80004bfc:	80 00       	ld.sh	r0,r0[0x0]
80004bfe:	47 58       	lddsp	r8,sp[0x1d4]
80004c00:	80 00       	ld.sh	r0,r0[0x0]
80004c02:	4a 0c       	lddpc	r12,80004c80 <CalulateCRC+0x14>
80004c04:	80 00       	ld.sh	r0,r0[0x0]
80004c06:	48 50       	lddpc	r0,80004c18 <PcdRequest+0x10>

80004c08 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
80004c08:	eb cd 40 c0 	pushm	r6-r7,lr
80004c0c:	20 5d       	sub	sp,20
80004c0e:	18 97       	mov	r7,r12
80004c10:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
80004c12:	30 8b       	mov	r11,8
80004c14:	16 9c       	mov	r12,r11
80004c16:	f0 1f 00 12 	mcall	80004c5c <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
80004c1a:	30 7b       	mov	r11,7
80004c1c:	30 dc       	mov	r12,13
80004c1e:	f0 1f 00 11 	mcall	80004c60 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
80004c22:	30 3b       	mov	r11,3
80004c24:	31 4c       	mov	r12,20
80004c26:	f0 1f 00 10 	mcall	80004c64 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
80004c2a:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
80004c2c:	1a 9b       	mov	r11,sp
80004c2e:	fa c8 ff ed 	sub	r8,sp,-19
80004c32:	1a 99       	mov	r9,sp
80004c34:	30 1a       	mov	r10,1
80004c36:	30 cc       	mov	r12,12
80004c38:	f0 1f 00 0c 	mcall	80004c68 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
80004c3c:	c0 c1       	brne	80004c54 <PcdRequest+0x4c>
80004c3e:	31 08       	mov	r8,16
80004c40:	fb 39 00 13 	ld.ub	r9,sp[19]
80004c44:	f0 09 18 00 	cp.b	r9,r8
80004c48:	c0 61       	brne	80004c54 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
80004c4a:	1b 88       	ld.ub	r8,sp[0x0]
80004c4c:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
80004c4e:	1b 98       	ld.ub	r8,sp[0x1]
80004c50:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80004c52:	c0 28       	rjmp	80004c56 <PcdRequest+0x4e>
80004c54:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80004c56:	2f bd       	sub	sp,-20
80004c58:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004c5c:	80 00       	ld.sh	r0,r0[0x0]
80004c5e:	48 94       	lddpc	r4,80004c80 <CalulateCRC+0x14>
80004c60:	80 00       	ld.sh	r0,r0[0x0]
80004c62:	47 58       	lddsp	r8,sp[0x1d4]
80004c64:	80 00       	ld.sh	r0,r0[0x0]
80004c66:	48 50       	lddpc	r0,80004c78 <CalulateCRC+0xc>
80004c68:	80 00       	ld.sh	r0,r0[0x0]
80004c6a:	4a 0c       	lddpc	r12,80004ce8 <CalulateCRC+0x7c>

80004c6c <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80004c6c:	eb cd 40 f8 	pushm	r3-r7,lr
80004c70:	18 95       	mov	r5,r12
80004c72:	16 96       	mov	r6,r11
80004c74:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80004c76:	30 4b       	mov	r11,4
80004c78:	30 5c       	mov	r12,5
80004c7a:	f0 1f 00 1c 	mcall	80004ce8 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80004c7e:	30 0b       	mov	r11,0
80004c80:	30 1c       	mov	r12,1
80004c82:	f0 1f 00 1b 	mcall	80004cec <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80004c86:	e0 6b 00 80 	mov	r11,128
80004c8a:	30 ac       	mov	r12,10
80004c8c:	f0 1f 00 19 	mcall	80004cf0 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80004c90:	58 06       	cp.w	r6,0
80004c92:	c0 c0       	breq	80004caa <CalulateCRC+0x3e>
80004c94:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80004c96:	30 94       	mov	r4,9
80004c98:	0f 3b       	ld.ub	r11,r7++
80004c9a:	08 9c       	mov	r12,r4
80004c9c:	f0 1f 00 14 	mcall	80004cec <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80004ca0:	0e 98       	mov	r8,r7
80004ca2:	0a 18       	sub	r8,r5
80004ca4:	ec 08 18 00 	cp.b	r8,r6
80004ca8:	cf 83       	brcs	80004c98 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80004caa:	30 3b       	mov	r11,3
80004cac:	30 1c       	mov	r12,1
80004cae:	f0 1f 00 10 	mcall	80004cec <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80004cb2:	30 5c       	mov	r12,5
80004cb4:	f0 1f 00 10 	mcall	80004cf4 <CalulateCRC+0x88>
80004cb8:	e0 67 00 fe 	mov	r7,254
80004cbc:	30 56       	mov	r6,5
80004cbe:	c0 78       	rjmp	80004ccc <CalulateCRC+0x60>
80004cc0:	0c 9c       	mov	r12,r6
80004cc2:	f0 1f 00 0d 	mcall	80004cf4 <CalulateCRC+0x88>
		i--;
80004cc6:	20 17       	sub	r7,1
80004cc8:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80004cca:	c0 40       	breq	80004cd2 <CalulateCRC+0x66>
80004ccc:	e2 1c 00 04 	andl	r12,0x4,COH
80004cd0:	cf 80       	breq	80004cc0 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80004cd2:	32 2c       	mov	r12,34
80004cd4:	f0 1f 00 08 	mcall	80004cf4 <CalulateCRC+0x88>
80004cd8:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80004cda:	32 1c       	mov	r12,33
80004cdc:	f0 1f 00 06 	mcall	80004cf4 <CalulateCRC+0x88>
80004ce0:	a6 9c       	st.b	r3[0x1],r12
}
80004ce2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80004ce6:	00 00       	add	r0,r0
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	48 94       	lddpc	r4,80004d0c <PcdSelect+0x14>
80004cec:	80 00       	ld.sh	r0,r0[0x0]
80004cee:	47 58       	lddsp	r8,sp[0x1d4]
80004cf0:	80 00       	ld.sh	r0,r0[0x0]
80004cf2:	48 50       	lddpc	r0,80004d04 <PcdSelect+0xc>
80004cf4:	80 00       	ld.sh	r0,r0[0x0]
80004cf6:	48 10       	lddpc	r0,80004cf8 <PcdSelect>

80004cf8 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80004cf8:	eb cd 40 80 	pushm	r7,lr
80004cfc:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80004cfe:	39 38       	mov	r8,-109
80004d00:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80004d02:	37 08       	mov	r8,112
80004d04:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80004d06:	30 08       	mov	r8,0
80004d08:	ba e8       	st.b	sp[0x6],r8
80004d0a:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80004d0e:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80004d12:	19 89       	ld.ub	r9,r12[0x0]
80004d14:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80004d16:	19 3a       	ld.ub	r10,r12++
80004d18:	1b e9       	ld.ub	r9,sp[0x6]
80004d1a:	f5 e9 20 09 	eor	r9,r10,r9
80004d1e:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80004d20:	16 38       	cp.w	r8,r11
80004d22:	cf 81       	brne	80004d12 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80004d24:	1a 97       	mov	r7,sp
80004d26:	fa ca ff f9 	sub	r10,sp,-7
80004d2a:	30 7b       	mov	r11,7
80004d2c:	1a 9c       	mov	r12,sp
80004d2e:	f0 1f 00 0d 	mcall	80004d60 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80004d32:	30 8b       	mov	r11,8
80004d34:	16 9c       	mov	r12,r11
80004d36:	f0 1f 00 0c 	mcall	80004d64 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80004d3a:	fa c8 ff ed 	sub	r8,sp,-19
80004d3e:	1a 99       	mov	r9,sp
80004d40:	30 9a       	mov	r10,9
80004d42:	1a 9b       	mov	r11,sp
80004d44:	30 cc       	mov	r12,12
80004d46:	f0 1f 00 09 	mcall	80004d68 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80004d4a:	c0 71       	brne	80004d58 <PcdSelect+0x60>
80004d4c:	31 88       	mov	r8,24
80004d4e:	fb 39 00 13 	ld.ub	r9,sp[19]
80004d52:	f0 09 18 00 	cp.b	r9,r8
80004d56:	c0 20       	breq	80004d5a <PcdSelect+0x62>
80004d58:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80004d5a:	2f bd       	sub	sp,-20
80004d5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d60:	80 00       	ld.sh	r0,r0[0x0]
80004d62:	4c 6c       	lddpc	r12,80004e78 <rfid_auto_reader+0x10c>
80004d64:	80 00       	ld.sh	r0,r0[0x0]
80004d66:	48 94       	lddpc	r4,80004d88 <rfid_auto_reader+0x1c>
80004d68:	80 00       	ld.sh	r0,r0[0x0]
80004d6a:	4a 0c       	lddpc	r12,80004de8 <rfid_auto_reader+0x7c>

80004d6c <rfid_auto_reader>:
		
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80004d6c:	eb cd 40 c0 	pushm	r6-r7,lr
80004d70:	18 96       	mov	r6,r12
	U8 status = MI_ERR;
	
	PcdReset();
80004d72:	f0 1f 00 37 	mcall	80004e4c <rfid_auto_reader+0xe0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80004d76:	4b 7b       	lddpc	r11,80004e50 <rfid_auto_reader+0xe4>
80004d78:	35 2c       	mov	r12,82
80004d7a:	f0 1f 00 37 	mcall	80004e54 <rfid_auto_reader+0xe8>
80004d7e:	18 97       	mov	r7,r12
	if(status!=MI_OK) return status;
80004d80:	c6 31       	brne	80004e46 <rfid_auto_reader+0xda>
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004d82:	4b 48       	lddpc	r8,80004e50 <rfid_auto_reader+0xe4>
80004d84:	11 88       	ld.ub	r8,r8[0x0]
80004d86:	30 49       	mov	r9,4
80004d88:	f2 08 18 00 	cp.b	r8,r9
80004d8c:	c0 b1       	brne	80004da2 <rfid_auto_reader+0x36>
80004d8e:	4b 19       	lddpc	r9,80004e50 <rfid_auto_reader+0xe4>
80004d90:	13 9a       	ld.ub	r10,r9[0x1]
80004d92:	30 09       	mov	r9,0
80004d94:	f2 0a 18 00 	cp.b	r10,r9
80004d98:	c0 51       	brne	80004da2 <rfid_auto_reader+0x36>
		log("MFOne-S50\n");
80004d9a:	4b 0c       	lddpc	r12,80004e58 <rfid_auto_reader+0xec>
80004d9c:	f0 1f 00 30 	mcall	80004e5c <rfid_auto_reader+0xf0>
//while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80004da0:	c3 c8       	rjmp	80004e18 <rfid_auto_reader+0xac>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004da2:	30 29       	mov	r9,2
80004da4:	f2 08 18 00 	cp.b	r8,r9
80004da8:	c0 b1       	brne	80004dbe <rfid_auto_reader+0x52>
80004daa:	4a a9       	lddpc	r9,80004e50 <rfid_auto_reader+0xe4>
80004dac:	13 9a       	ld.ub	r10,r9[0x1]
80004dae:	30 09       	mov	r9,0
80004db0:	f2 0a 18 00 	cp.b	r10,r9
80004db4:	c0 51       	brne	80004dbe <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80004db6:	4a bc       	lddpc	r12,80004e60 <rfid_auto_reader+0xf4>
80004db8:	f0 1f 00 29 	mcall	80004e5c <rfid_auto_reader+0xf0>
	if(status!=MI_OK) return status;
	//continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80004dbc:	c2 e8       	rjmp	80004e18 <rfid_auto_reader+0xac>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004dbe:	34 49       	mov	r9,68
80004dc0:	f2 08 18 00 	cp.b	r8,r9
80004dc4:	c0 b1       	brne	80004dda <rfid_auto_reader+0x6e>
80004dc6:	4a 39       	lddpc	r9,80004e50 <rfid_auto_reader+0xe4>
80004dc8:	13 9a       	ld.ub	r10,r9[0x1]
80004dca:	30 09       	mov	r9,0
80004dcc:	f2 0a 18 00 	cp.b	r10,r9
80004dd0:	c0 51       	brne	80004dda <rfid_auto_reader+0x6e>
		log("MF-UltraLight\n");
80004dd2:	4a 5c       	lddpc	r12,80004e64 <rfid_auto_reader+0xf8>
80004dd4:	f0 1f 00 22 	mcall	80004e5c <rfid_auto_reader+0xf0>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80004dd8:	c2 08       	rjmp	80004e18 <rfid_auto_reader+0xac>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004dda:	30 89       	mov	r9,8
80004ddc:	f2 08 18 00 	cp.b	r8,r9
80004de0:	c0 b1       	brne	80004df6 <rfid_auto_reader+0x8a>
80004de2:	49 c9       	lddpc	r9,80004e50 <rfid_auto_reader+0xe4>
80004de4:	13 9a       	ld.ub	r10,r9[0x1]
80004de6:	30 09       	mov	r9,0
80004de8:	f2 0a 18 00 	cp.b	r10,r9
80004dec:	c0 51       	brne	80004df6 <rfid_auto_reader+0x8a>
		log("MF-Pro\n");
80004dee:	49 fc       	lddpc	r12,80004e68 <rfid_auto_reader+0xfc>
80004df0:	f0 1f 00 1b 	mcall	80004e5c <rfid_auto_reader+0xf0>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80004df4:	c1 28       	rjmp	80004e18 <rfid_auto_reader+0xac>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004df6:	34 49       	mov	r9,68
80004df8:	f2 08 18 00 	cp.b	r8,r9
80004dfc:	c0 b1       	brne	80004e12 <rfid_auto_reader+0xa6>
80004dfe:	49 58       	lddpc	r8,80004e50 <rfid_auto_reader+0xe4>
80004e00:	11 99       	ld.ub	r9,r8[0x1]
80004e02:	30 38       	mov	r8,3
80004e04:	f0 09 18 00 	cp.b	r9,r8
80004e08:	c0 51       	brne	80004e12 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
80004e0a:	49 9c       	lddpc	r12,80004e6c <rfid_auto_reader+0x100>
80004e0c:	f0 1f 00 14 	mcall	80004e5c <rfid_auto_reader+0xf0>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80004e10:	c0 48       	rjmp	80004e18 <rfid_auto_reader+0xac>
		log("MF Desire\n");
	else
		log("Unknown\n");
80004e12:	49 8c       	lddpc	r12,80004e70 <rfid_auto_reader+0x104>
80004e14:	f0 1f 00 12 	mcall	80004e5c <rfid_auto_reader+0xf0>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80004e18:	49 7c       	lddpc	r12,80004e74 <rfid_auto_reader+0x108>
80004e1a:	f0 1f 00 18 	mcall	80004e78 <rfid_auto_reader+0x10c>
80004e1e:	18 97       	mov	r7,r12
	if(status!=MI_OK)
80004e20:	c0 60       	breq	80004e2c <rfid_auto_reader+0xc0>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80004e22:	37 8b       	mov	r11,120
80004e24:	30 1c       	mov	r12,1
80004e26:	f0 1f 00 16 	mcall	80004e7c <rfid_auto_reader+0x110>
		return status;
80004e2a:	c0 e8       	rjmp	80004e46 <rfid_auto_reader+0xda>
	}
	//continue;
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80004e2c:	49 2c       	lddpc	r12,80004e74 <rfid_auto_reader+0x108>
80004e2e:	f0 1f 00 15 	mcall	80004e80 <rfid_auto_reader+0x114>
80004e32:	18 97       	mov	r7,r12
	if(status!=MI_OK)return status;
80004e34:	c0 91       	brne	80004e46 <rfid_auto_reader+0xda>
	//continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80004e36:	30 4a       	mov	r10,4
80004e38:	48 fb       	lddpc	r11,80004e74 <rfid_auto_reader+0x108>
80004e3a:	0c 9c       	mov	r12,r6
80004e3c:	f0 1f 00 12 	mcall	80004e84 <rfid_auto_reader+0x118>
		log("select okay\n");
80004e40:	49 2c       	lddpc	r12,80004e88 <rfid_auto_reader+0x11c>
80004e42:	f0 1f 00 07 	mcall	80004e5c <rfid_auto_reader+0xf0>
		return status;	
	}
	
//}
	
}
80004e46:	0e 9c       	mov	r12,r7
80004e48:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004e4c:	80 00       	ld.sh	r0,r0[0x0]
80004e4e:	47 90       	lddsp	r0,sp[0x1e4]
80004e50:	00 00       	add	r0,r0
80004e52:	54 0c       	stdsp	sp[0x100],r12
80004e54:	80 00       	ld.sh	r0,r0[0x0]
80004e56:	4c 08       	lddpc	r8,80004f54 <rfid_sendID_message+0xc8>
80004e58:	80 00       	ld.sh	r0,r0[0x0]
80004e5a:	d9 fc       	*unknown*
80004e5c:	80 00       	ld.sh	r0,r0[0x0]
80004e5e:	72 80       	ld.w	r0,r9[0x20]
80004e60:	80 00       	ld.sh	r0,r0[0x0]
80004e62:	da 08       	*unknown*
80004e64:	80 00       	ld.sh	r0,r0[0x0]
80004e66:	da 14       	*unknown*
80004e68:	80 00       	ld.sh	r0,r0[0x0]
80004e6a:	da 24       	*unknown*
80004e6c:	80 00       	ld.sh	r0,r0[0x0]
80004e6e:	da 2c       	*unknown*
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	da 38       	*unknown*
80004e74:	00 00       	add	r0,r0
80004e76:	54 10       	stdsp	sp[0x104],r0
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	4b 84       	lddpc	r4,80004f58 <rfid_sendID_message+0xcc>
80004e7c:	80 00       	ld.sh	r0,r0[0x0]
80004e7e:	3e b8       	mov	r8,-21
80004e80:	80 00       	ld.sh	r0,r0[0x0]
80004e82:	4c f8       	lddpc	r8,80004fbc <rfid_sendID_message+0x130>
80004e84:	80 00       	ld.sh	r0,r0[0x0]
80004e86:	7b 22       	ld.w	r2,sp[0x48]
80004e88:	80 00       	ld.sh	r0,r0[0x0]
80004e8a:	da 44       	*unknown*

80004e8c <rfid_sendID_message>:

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
80004e8c:	eb cd 40 e0 	pushm	r5-r7,lr
80004e90:	21 fd       	sub	sp,124
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80004e92:	fa cc ff 90 	sub	r12,sp,-112
80004e96:	30 08       	mov	r8,0
80004e98:	30 09       	mov	r9,0
80004e9a:	f8 e9 00 00 	st.d	r12[0],r8
80004e9e:	30 0a       	mov	r10,0
80004ea0:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80004ea2:	fa e9 00 20 	st.d	sp[32],r8
80004ea6:	fa e9 00 28 	st.d	sp[40],r8
80004eaa:	fa e9 00 30 	st.d	sp[48],r8
80004eae:	fa e9 00 38 	st.d	sp[56],r8
80004eb2:	fa e9 00 40 	st.d	sp[64],r8
80004eb6:	fa e9 00 48 	st.d	sp[72],r8
80004eba:	fa e9 00 50 	st.d	sp[80],r8
80004ebe:	fa e9 00 58 	st.d	sp[88],r8
80004ec2:	fa e9 00 60 	st.d	sp[96],r8
80004ec6:	fa e9 00 68 	st.d	sp[104],r8

	return_err = rfid_auto_reader(SN);
80004eca:	f0 1f 00 43 	mcall	80004fd4 <rfid_sendID_message+0x148>
80004ece:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80004ed0:	c7 61       	brne	80004fbc <rfid_sendID_message+0x130>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80004ed2:	fb 38 00 73 	ld.ub	r8,sp[115]
80004ed6:	1a d8       	st.w	--sp,r8
80004ed8:	fb 38 00 76 	ld.ub	r8,sp[118]
80004edc:	1a d8       	st.w	--sp,r8
80004ede:	fb 38 00 79 	ld.ub	r8,sp[121]
80004ee2:	1a d8       	st.w	--sp,r8
80004ee4:	fb 38 00 7c 	ld.ub	r8,sp[124]
80004ee8:	1a d8       	st.w	--sp,r8
80004eea:	4b cc       	lddpc	r12,80004fd8 <rfid_sendID_message+0x14c>
80004eec:	f0 1f 00 3c 	mcall	80004fdc <rfid_sendID_message+0x150>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80004ef0:	37 7b       	mov	r11,119
80004ef2:	30 1c       	mov	r12,1
80004ef4:	f0 1f 00 3b 	mcall	80004fe0 <rfid_sendID_message+0x154>
80004ef8:	fa c9 ff 80 	sub	r9,sp,-128
80004efc:	fa c8 ff f0 	sub	r8,sp,-16
80004f00:	fa ca ff ee 	sub	r10,sp,-18
//}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
80004f04:	fa c5 ff 7c 	sub	r5,sp,-132
80004f08:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80004f0a:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80004f0c:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80004f0e:	13 8b       	ld.ub	r11,r9[0x0]
80004f10:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80004f14:	fc 0c 18 00 	cp.b	r12,lr
80004f18:	f7 bc 08 d0 	subls	r12,-48
80004f1c:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80004f20:	f7 bc 0b a9 	subhi	r12,-87
80004f24:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80004f28:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80004f2a:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80004f2e:	fc 0b 18 00 	cp.b	r11,lr
80004f32:	f7 bb 08 d0 	subls	r11,-48
80004f36:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80004f3a:	f7 bb 0b a9 	subhi	r11,-87
80004f3e:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80004f42:	b0 b6       	st.b	r8[0x3],r6
80004f44:	2f f9       	sub	r9,-1
80004f46:	2f c8       	sub	r8,-4
80004f48:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80004f4a:	0a 39       	cp.w	r9,r5
80004f4c:	ce 11       	brne	80004f0e <rfid_sendID_message+0x82>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80004f4e:	30 6a       	mov	r10,6
80004f50:	4a 5b       	lddpc	r11,80004fe4 <rfid_sendID_message+0x158>
80004f52:	fa cc ff f0 	sub	r12,sp,-16
80004f56:	f0 1f 00 25 	mcall	80004fe8 <rfid_sendID_message+0x15c>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
80004f5a:	4a 58       	lddpc	r8,80004fec <rfid_sendID_message+0x160>
80004f5c:	11 89       	ld.ub	r9,r8[0x0]
80004f5e:	39 f8       	mov	r8,-97
80004f60:	f0 09 18 00 	cp.b	r9,r8
80004f64:	e0 88 00 05 	brls	80004f6e <rfid_sendID_message+0xe2>
80004f68:	38 09       	mov	r9,-128
80004f6a:	4a 18       	lddpc	r8,80004fec <rfid_sendID_message+0x160>
80004f6c:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80004f6e:	4a 08       	lddpc	r8,80004fec <rfid_sendID_message+0x160>
80004f70:	11 86       	ld.ub	r6,r8[0x0]
80004f72:	2f f6       	sub	r6,-1
80004f74:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80004f76:	30 5a       	mov	r10,5
80004f78:	49 eb       	lddpc	r11,80004ff0 <rfid_sendID_message+0x164>
80004f7a:	fa cc ff e5 	sub	r12,sp,-27
80004f7e:	f0 1f 00 1b 	mcall	80004fe8 <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80004f82:	31 e8       	mov	r8,30
80004f84:	fb 58 00 16 	st.h	sp[22],r8
80004f88:	fb 66 00 1a 	st.b	sp[26],r6
80004f8c:	fe 78 e0 00 	mov	r8,-8192
80004f90:	fb 58 00 18 	st.h	sp[24],r8
80004f94:	fa c6 ff e0 	sub	r6,sp,-32
80004f98:	30 aa       	mov	r10,10
80004f9a:	fa cb ff ea 	sub	r11,sp,-22
80004f9e:	0c 9c       	mov	r12,r6
80004fa0:	f0 1f 00 12 	mcall	80004fe8 <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80004fa4:	31 6a       	mov	r10,22
80004fa6:	1a 9b       	mov	r11,sp
80004fa8:	fa cc ff d6 	sub	r12,sp,-42
80004fac:	f0 1f 00 0f 	mcall	80004fe8 <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
80004fb0:	30 9a       	mov	r10,9
80004fb2:	32 0b       	mov	r11,32
80004fb4:	0c 9c       	mov	r12,r6
80004fb6:	f0 1f 00 10 	mcall	80004ff4 <rfid_sendID_message+0x168>
80004fba:	c0 88       	rjmp	80004fca <rfid_sendID_message+0x13e>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80004fbc:	37 8b       	mov	r11,120
80004fbe:	30 1c       	mov	r12,1
80004fc0:	f0 1f 00 08 	mcall	80004fe0 <rfid_sendID_message+0x154>
		log("no card find...\n");
80004fc4:	48 dc       	lddpc	r12,80004ff8 <rfid_sendID_message+0x16c>
80004fc6:	f0 1f 00 06 	mcall	80004fdc <rfid_sendID_message+0x150>
	}
	
	return return_err;
	
}
80004fca:	0e 9c       	mov	r12,r7
80004fcc:	2e 1d       	sub	sp,-124
80004fce:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80004fd2:	00 00       	add	r0,r0
80004fd4:	80 00       	ld.sh	r0,r0[0x0]
80004fd6:	4d 6c       	lddpc	r12,8000512c <xg_flashc_init+0x40>
80004fd8:	80 00       	ld.sh	r0,r0[0x0]
80004fda:	da 54       	*unknown*
80004fdc:	80 00       	ld.sh	r0,r0[0x0]
80004fde:	72 80       	ld.w	r0,r9[0x20]
80004fe0:	80 00       	ld.sh	r0,r0[0x0]
80004fe2:	3e b8       	mov	r8,-21
80004fe4:	00 00       	add	r0,r0
80004fe6:	0d fc       	ld.ub	r12,r6[0x7]
80004fe8:	80 00       	ld.sh	r0,r0[0x0]
80004fea:	7b 22       	ld.w	r2,sp[0x48]
80004fec:	00 00       	add	r0,r0
80004fee:	05 2c       	ld.uh	r12,r2++
80004ff0:	00 00       	add	r0,r0
80004ff2:	05 24       	ld.uh	r4,r2++
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	3d 80       	mov	r0,-40
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	da 70       	acall	0xa7

80004ffc <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80004ffc:	d4 01       	pushm	lr
	char card_id[4]={0};
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80004ffe:	f0 1f 00 02 	mcall	80005004 <rfid_init+0x8>
	
	//if(rfid_auto_reader(card_id) == 0){
		//log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
	//}
		
}
80005002:	d8 02       	popm	pc
80005004:	80 00       	ld.sh	r0,r0[0x0]
80005006:	49 3c       	lddpc	r12,80005050 <local_start_pll0+0x48>

80005008 <local_start_pll0>:
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
80005008:	fe 78 0c 00 	mov	r8,-62464
8000500c:	e0 69 03 07 	mov	r9,775
80005010:	91 a9       	st.w	r8[0x28],r9
	(&AVR32_PM)->mcctrl   = 0x00000004;
80005012:	30 49       	mov	r9,4
80005014:	91 09       	st.w	r8[0x0],r9
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80005016:	71 59       	ld.w	r9,r8[0x54]
80005018:	e2 19 00 80 	andl	r9,0x80,COH
8000501c:	cf d0       	breq	80005016 <local_start_pll0+0xe>
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;
8000501e:	fe 78 0c 00 	mov	r8,-62464
80005022:	30 59       	mov	r9,5
80005024:	91 09       	st.w	r8[0x0],r9
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;
80005026:	e0 69 01 0d 	mov	r9,269
8000502a:	ea 19 10 07 	orh	r9,0x1007
8000502e:	91 89       	st.w	r8[0x20],r9


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80005030:	71 59       	ld.w	r9,r8[0x54]
80005032:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80005036:	cf d0       	breq	80005030 <local_start_pll0+0x28>
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;
80005038:	fe 78 0c 00 	mov	r8,-62464
8000503c:	fc 19 00 80 	movh	r9,0x80
80005040:	91 19       	st.w	r8[0x4],r9

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;
80005042:	34 0a       	mov	r10,64
80005044:	fe 69 14 00 	mov	r9,-125952
80005048:	93 0a       	st.w	r9[0x0],r10

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;
8000504a:	30 69       	mov	r9,6
8000504c:	91 09       	st.w	r8[0x0],r9


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
8000504e:	30 19       	mov	r9,1
80005050:	fe 68 10 00 	mov	r8,-126976
80005054:	91 19       	st.w	r8[0x4],r9
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
****/
}
80005056:	5e fc       	retal	r12

80005058 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005058:	58 0c       	cp.w	r12,0
8000505a:	5e 0c       	reteq	r12
8000505c:	30 08       	mov	r8,0
	{
		nop();
8000505e:	d7 03       	nop
		nop();
80005060:	d7 03       	nop
		nop();
80005062:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80005064:	2f f8       	sub	r8,-1
80005066:	10 3c       	cp.w	r12,r8
80005068:	fe 9b ff fb 	brhi	8000505e <delay_ns+0x6>
8000506c:	5e fc       	retal	r12
8000506e:	d7 03       	nop

80005070 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80005070:	eb cd 40 e0 	pushm	r5-r7,lr
80005074:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80005076:	58 0c       	cp.w	r12,0
80005078:	c0 b0       	breq	8000508e <delay_us+0x1e>
8000507a:	30 07       	mov	r7,0
		delay_ns(1000);
8000507c:	e0 65 03 e8 	mov	r5,1000
80005080:	0a 9c       	mov	r12,r5
80005082:	f0 1f 00 05 	mcall	80005094 <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80005086:	2f f7       	sub	r7,-1
80005088:	0e 36       	cp.w	r6,r7
8000508a:	fe 9b ff fb 	brhi	80005080 <delay_us+0x10>
8000508e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005092:	00 00       	add	r0,r0
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	50 58       	stdsp	sp[0x14],r8

80005098 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80005098:	eb cd 40 e0 	pushm	r5-r7,lr
8000509c:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
8000509e:	58 0c       	cp.w	r12,0
800050a0:	c0 b0       	breq	800050b6 <delay_ms+0x1e>
800050a2:	30 07       	mov	r7,0
		delay_us(1000);
800050a4:	e0 65 03 e8 	mov	r5,1000
800050a8:	0a 9c       	mov	r12,r5
800050aa:	f0 1f 00 05 	mcall	800050bc <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
800050ae:	2f f7       	sub	r7,-1
800050b0:	0e 36       	cp.w	r6,r7
800050b2:	fe 9b ff fb 	brhi	800050a8 <delay_ms+0x10>
800050b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800050ba:	00 00       	add	r0,r0
800050bc:	80 00       	ld.sh	r0,r0[0x0]
800050be:	50 70       	stdsp	sp[0x1c],r0

800050c0 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
800050c0:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
800050c2:	30 3b       	mov	r11,3
800050c4:	48 8c       	lddpc	r12,800050e4 <local_start_timer+0x24>
800050c6:	f0 1f 00 09 	mcall	800050e8 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
800050ca:	fe 78 38 00 	mov	r8,-51200
800050ce:	e0 69 91 0d 	mov	r9,37133
800050d2:	ea 19 00 52 	orh	r9,0x52
800050d6:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
800050d8:	32 09       	mov	r9,32
800050da:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800050dc:	30 59       	mov	r9,5
800050de:	91 09       	st.w	r8[0x0],r9
}
800050e0:	d8 02       	popm	pc
800050e2:	00 00       	add	r0,r0
800050e4:	80 00       	ld.sh	r0,r0[0x0]
800050e6:	da 84       	*unknown*
800050e8:	80 00       	ld.sh	r0,r0[0x0]
800050ea:	58 ec       	cp.w	r12,14

800050ec <xg_flashc_init>:
		
}

//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
800050ec:	d4 31       	pushm	r0-r7,lr
800050ee:	20 2d       	sub	sp,8
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
800050f0:	f0 1f 00 9d 	mcall	80005364 <xg_flashc_init+0x278>
800050f4:	fe f8 02 74 	ld.w	r8,pc[628]
800050f8:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
800050fa:	70 08       	ld.w	r8,r8[0x0]
800050fc:	58 08       	cp.w	r8,0
800050fe:	c0 51       	brne	80005108 <xg_flashc_init+0x1c>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80005100:	fe fc 02 6c 	ld.w	r12,pc[620]
80005104:	f0 1f 00 9b 	mcall	80005370 <xg_flashc_init+0x284>
	}
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
80005108:	30 4b       	mov	r11,4
8000510a:	31 4c       	mov	r12,20
8000510c:	f0 1f 00 9a 	mcall	80005374 <xg_flashc_init+0x288>
80005110:	fe f8 02 68 	ld.w	r8,pc[616]
80005114:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80005116:	30 4b       	mov	r11,4
80005118:	31 4c       	mov	r12,20
8000511a:	f0 1f 00 97 	mcall	80005374 <xg_flashc_init+0x288>
8000511e:	fe f8 02 5e 	ld.w	r8,pc[606]
80005122:	91 0c       	st.w	r8[0x0],r12
80005124:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80005126:	10 96       	mov	r6,r8
80005128:	fe f5 02 58 	ld.w	r5,pc[600]
8000512c:	6c 0c       	ld.w	r12,r6[0x0]
8000512e:	ea 07 00 0b 	add	r11,r5,r7
80005132:	f0 1f 00 95 	mcall	80005384 <xg_flashc_init+0x298>
80005136:	2e 07       	sub	r7,-32
	}
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80005138:	e0 47 02 80 	cp.w	r7,640
8000513c:	cf 81       	brne	8000512c <xg_flashc_init+0x40>
	
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
8000513e:	30 0a       	mov	r10,0
80005140:	30 0b       	mov	r11,0
80005142:	fe f8 02 46 	ld.w	r8,pc[582]
80005146:	b1 2a       	st.d	r8++,r10
80005148:	b1 2a       	st.d	r8++,r10
8000514a:	b1 2a       	st.d	r8++,r10
8000514c:	b1 2a       	st.d	r8++,r10
8000514e:	b1 2a       	st.d	r8++,r10
80005150:	b1 2a       	st.d	r8++,r10
80005152:	b1 2a       	st.d	r8++,r10
80005154:	b1 2a       	st.d	r8++,r10
80005156:	b1 2a       	st.d	r8++,r10
80005158:	f0 eb 00 00 	st.d	r8[0],r10
	
start:
	
	 //bytes remained less than one page 
	flashc_memcpy((void *)str, (void *)LABEL_ADDRESS, LABEL_LENGTH,  true);
8000515c:	fe f7 02 2c 	ld.w	r7,pc[556]
			}
			else
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					memset(str, 0x00, sizeof(str));	
80005160:	ee c5 ff f8 	sub	r5,r7,-8
80005164:	ea c4 ff f8 	sub	r4,r5,-8
80005168:	e8 c3 ff f8 	sub	r3,r4,-8
8000516c:	e6 c2 ff f8 	sub	r2,r3,-8
80005170:	e4 c1 ff f8 	sub	r1,r2,-8
80005174:	e2 c0 ff f8 	sub	r0,r1,-8
80005178:	e0 ca ff f8 	sub	r10,r0,-8
8000517c:	50 0a       	stdsp	sp[0x0],r10
8000517e:	2f 8a       	sub	r10,-8
80005180:	50 1a       	stdsp	sp[0x4],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	flashc_memcpy((void *)str, (void *)LABEL_ADDRESS, LABEL_LENGTH,  true);
80005182:	30 19       	mov	r9,1
80005184:	30 7a       	mov	r10,7
80005186:	e0 6b b0 00 	mov	r11,45056
8000518a:	ea 1b 80 04 	orh	r11,0x8004
8000518e:	0e 9c       	mov	r12,r7
80005190:	f0 1f 00 7f 	mcall	8000538c <xg_flashc_init+0x2a0>
	flashc_memcpy((void *)LABEL_ADDRESS, (void *)LABEL_ADDRESS, LABEL_LENGTH,  false);//为了获取当前页号码
80005194:	30 09       	mov	r9,0
80005196:	30 7a       	mov	r10,7
80005198:	e0 6b b0 00 	mov	r11,45056
8000519c:	ea 1b 80 04 	orh	r11,0x8004
800051a0:	16 9c       	mov	r12,r11
800051a2:	f0 1f 00 7b 	mcall	8000538c <xg_flashc_init+0x2a0>
	current_page_number = flashc_get_page_number();
800051a6:	f0 1f 00 7b 	mcall	80005390 <xg_flashc_init+0x2a4>
800051aa:	4f b8       	lddpc	r8,80005394 <xg_flashc_init+0x2a8>
800051ac:	91 0c       	st.w	r8[0x0],r12
	if (flashc_is_lock_error() || flashc_is_programming_error())
800051ae:	f0 1f 00 7b 	mcall	80005398 <xg_flashc_init+0x2ac>
800051b2:	e0 81 00 d6 	brne	8000535e <xg_flashc_init+0x272>
800051b6:	f0 1f 00 7a 	mcall	8000539c <xg_flashc_init+0x2b0>
800051ba:	e0 81 00 d2 	brne	8000535e <xg_flashc_init+0x272>
	{
		return XG_FLASH_ACTION_FAIL;
	}
	else
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
800051be:	30 7a       	mov	r10,7
800051c0:	0e 9b       	mov	r11,r7
800051c2:	4f 8c       	lddpc	r12,800053a0 <xg_flashc_init+0x2b4>
800051c4:	f0 1f 00 78 	mcall	800053a4 <xg_flashc_init+0x2b8>
800051c8:	c3 b0       	breq	8000523e <xg_flashc_init+0x152>
800051ca:	cc 08       	rjmp	8000534a <xg_flashc_init+0x25e>
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
			{
				current_page_number+=i;
800051cc:	6c 0c       	ld.w	r12,r6[0x0]
800051ce:	ee 0c 00 0c 	add	r12,r7,r12
800051d2:	8d 0c       	st.w	r6[0x0],r12
				flashc_erase_page(current_page_number, true);
800051d4:	0a 9b       	mov	r11,r5
800051d6:	f0 1f 00 75 	mcall	800053a8 <xg_flashc_init+0x2bc>
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
		{
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
800051da:	2f f7       	sub	r7,-1
800051dc:	59 97       	cp.w	r7,25
800051de:	cf 71       	brne	800051cc <xg_flashc_init+0xe0>
			{
				current_page_number+=i;
				flashc_erase_page(current_page_number, true);
			}
			//set label
			flashc_memcpy((void *)LABEL_ADDRESS, (void *)XGFlashLabel, LABEL_LENGTH,  true);
800051e0:	30 19       	mov	r9,1
800051e2:	30 7a       	mov	r10,7
800051e4:	4e fb       	lddpc	r11,800053a0 <xg_flashc_init+0x2b4>
800051e6:	e0 6c b0 00 	mov	r12,45056
800051ea:	ea 1c 80 04 	orh	r12,0x8004
800051ee:	f0 1f 00 68 	mcall	8000538c <xg_flashc_init+0x2a0>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
800051f2:	4e 6b       	lddpc	r11,80005388 <xg_flashc_init+0x29c>
800051f4:	30 06       	mov	r6,0
800051f6:	30 07       	mov	r7,0
800051f8:	16 98       	mov	r8,r11
800051fa:	b1 26       	st.d	r8++,r6
800051fc:	b1 26       	st.d	r8++,r6
800051fe:	b1 26       	st.d	r8++,r6
80005200:	b1 26       	st.d	r8++,r6
80005202:	b1 26       	st.d	r8++,r6
80005204:	b1 26       	st.d	r8++,r6
80005206:	b1 26       	st.d	r8++,r6
80005208:	b1 26       	st.d	r8++,r6
8000520a:	b1 26       	st.d	r8++,r6
8000520c:	f0 e7 00 00 	st.d	r8[0],r6
			
			flashc_memcpy((void *)MESSAGE_NUMBERS_ADD, (void *)str, MESSAGE_NUMBERS_LENGTH,  true);
80005210:	30 19       	mov	r9,1
80005212:	30 2a       	mov	r10,2
80005214:	e0 6c b0 07 	mov	r12,45063
80005218:	ea 1c 80 04 	orh	r12,0x8004
8000521c:	f0 1f 00 5c 	mcall	8000538c <xg_flashc_init+0x2a0>
			if (flashc_is_lock_error() || flashc_is_programming_error())
80005220:	f0 1f 00 5e 	mcall	80005398 <xg_flashc_init+0x2ac>
80005224:	e0 81 00 9d 	brne	8000535e <xg_flashc_init+0x272>
80005228:	f0 1f 00 5d 	mcall	8000539c <xg_flashc_init+0x2b0>
8000522c:	e0 81 00 99 	brne	8000535e <xg_flashc_init+0x272>
			{
				return XG_FLASH_ACTION_FAIL;
			}
			current_message_index = 0;
80005230:	30 09       	mov	r9,0
80005232:	4d f8       	lddpc	r8,800053ac <xg_flashc_init+0x2c0>
80005234:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
80005236:	4d fc       	lddpc	r12,800053b0 <xg_flashc_init+0x2c4>
80005238:	f0 1f 00 4e 	mcall	80005370 <xg_flashc_init+0x284>
8000523c:	c8 e8       	rjmp	80005358 <xg_flashc_init+0x26c>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
8000523e:	1a d7       	st.w	--sp,r7
80005240:	4d dc       	lddpc	r12,800053b4 <xg_flashc_init+0x2c8>
80005242:	f0 1f 00 4c 	mcall	80005370 <xg_flashc_init+0x284>
			//Get the current voice index		
			flashc_memcpy((void *)&current_message_index, (void *)MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH,  false);
80005246:	30 09       	mov	r9,0
80005248:	30 2a       	mov	r10,2
8000524a:	e0 6b b0 07 	mov	r11,45063
8000524e:	ea 1b 80 04 	orh	r11,0x8004
80005252:	4d 7c       	lddpc	r12,800053ac <xg_flashc_init+0x2c0>
80005254:	f0 1f 00 4e 	mcall	8000538c <xg_flashc_init+0x2a0>
			if (flashc_is_lock_error() || flashc_is_programming_error())
80005258:	f0 1f 00 50 	mcall	80005398 <xg_flashc_init+0x2ac>
8000525c:	2f fd       	sub	sp,-4
8000525e:	58 0c       	cp.w	r12,0
80005260:	e0 81 00 7f 	brne	8000535e <xg_flashc_init+0x272>
80005264:	f0 1f 00 4e 	mcall	8000539c <xg_flashc_init+0x2b0>
80005268:	e0 81 00 7b 	brne	8000535e <xg_flashc_init+0x272>
				return XG_FLASH_ACTION_FAIL;
			}
			else
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
8000526c:	4d 08       	lddpc	r8,800053ac <xg_flashc_init+0x2c0>
8000526e:	90 09       	ld.sh	r9,r8[0x0]
80005270:	30 08       	mov	r8,0
80005272:	f0 09 19 00 	cp.h	r9,r8
80005276:	c6 e0       	breq	80005352 <xg_flashc_init+0x266>
					memset(str, 0x00, sizeof(str));	
80005278:	30 08       	mov	r8,0
8000527a:	30 09       	mov	r9,0
8000527c:	ee e9 00 00 	st.d	r7[0],r8
80005280:	ea e9 00 00 	st.d	r5[0],r8
80005284:	e8 e9 00 00 	st.d	r4[0],r8
80005288:	e6 e9 00 00 	st.d	r3[0],r8
8000528c:	e4 e9 00 00 	st.d	r2[0],r8
80005290:	e2 e9 00 00 	st.d	r1[0],r8
80005294:	e0 e9 00 00 	st.d	r0[0],r8
80005298:	40 0a       	lddsp	r10,sp[0x0]
8000529a:	f4 e9 00 00 	st.d	r10[0],r8
8000529e:	40 1a       	lddsp	r10,sp[0x4]
800052a0:	b5 28       	st.d	r10++,r8
800052a2:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
					flashc_memcpy((void *)str, (void *)address, XG_MESSAGE_INFO_HEADER_LENGTH,  false);
800052a6:	4c 28       	lddpc	r8,800053ac <xg_flashc_init+0x2c0>
800052a8:	90 8b       	ld.uh	r11,r8[0x0]
800052aa:	20 1b       	sub	r11,1
800052ac:	30 09       	mov	r9,0
800052ae:	30 8a       	mov	r10,8
800052b0:	e0 68 b0 09 	mov	r8,45065
800052b4:	ea 18 80 04 	orh	r8,0x8004
800052b8:	f0 0b 00 3b 	add	r11,r8,r11<<0x3
800052bc:	0e 9c       	mov	r12,r7
800052be:	f0 1f 00 34 	mcall	8000538c <xg_flashc_init+0x2a0>
					if (flashc_is_lock_error() || flashc_is_programming_error())
800052c2:	f0 1f 00 36 	mcall	80005398 <xg_flashc_init+0x2ac>
800052c6:	c0 41       	brne	800052ce <xg_flashc_init+0x1e2>
800052c8:	f0 1f 00 35 	mcall	8000539c <xg_flashc_init+0x2b0>
800052cc:	c0 50       	breq	800052d6 <xg_flashc_init+0x1ea>
					{
						log("\r\n----message storage is err!!!----\r\n");
800052ce:	4b bc       	lddpc	r12,800053b8 <xg_flashc_init+0x2cc>
800052d0:	f0 1f 00 28 	mcall	80005370 <xg_flashc_init+0x284>
800052d4:	c3 b8       	rjmp	8000534a <xg_flashc_init+0x25e>
						goto ERASE;
					}
					else
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
800052d6:	0f 89       	ld.ub	r9,r7[0x0]
800052d8:	0f 98       	ld.ub	r8,r7[0x1]
800052da:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800052de:	4b 49       	lddpc	r9,800053ac <xg_flashc_init+0x2c0>
800052e0:	92 09       	ld.sh	r9,r9[0x0]
800052e2:	f0 09 19 00 	cp.h	r9,r8
800052e6:	c2 f1       	brne	80005344 <xg_flashc_init+0x258>
						{
							current_save_message_offset = ptr->address + ptr->offset;
800052e8:	0f e9       	ld.ub	r9,r7[0x6]
800052ea:	0f f8       	ld.ub	r8,r7[0x7]
800052ec:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800052f0:	0f aa       	ld.ub	r10,r7[0x2]
800052f2:	0f b8       	ld.ub	r8,r7[0x3]
800052f4:	b1 68       	lsl	r8,0x10
800052f6:	f1 ea 11 88 	or	r8,r8,r10<<0x18
800052fa:	0f ca       	ld.ub	r10,r7[0x4]
800052fc:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80005300:	0f da       	ld.ub	r10,r7[0x5]
80005302:	f5 e8 10 08 	or	r8,r10,r8
80005306:	f2 08 00 08 	add	r8,r9,r8
8000530a:	4a d6       	lddpc	r6,800053bc <xg_flashc_init+0x2d0>
8000530c:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
8000530e:	1a d8       	st.w	--sp,r8
80005310:	4a cc       	lddpc	r12,800053c0 <xg_flashc_init+0x2d4>
80005312:	f0 1f 00 18 	mcall	80005370 <xg_flashc_init+0x284>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
80005316:	2f fd       	sub	sp,-4
80005318:	6c 08       	ld.w	r8,r6[0x0]
8000531a:	e0 69 f0 00 	mov	r9,61440
8000531e:	ea 19 80 05 	orh	r9,0x8005
80005322:	12 38       	cp.w	r8,r9
80005324:	e0 88 00 17 	brls	80005352 <xg_flashc_init+0x266>
										
								log("\r\n----message storage is full!!!----\r\n");
80005328:	4a 7c       	lddpc	r12,800053c4 <xg_flashc_init+0x2d8>
8000532a:	f0 1f 00 12 	mcall	80005370 <xg_flashc_init+0x284>
								//xgflash erase
								
								flashc_memset64((void *)LABEL_ADDRESS, (void *)0x00, LABEL_LENGTH,  true);
8000532e:	30 18       	mov	r8,1
80005330:	30 79       	mov	r9,7
80005332:	30 0a       	mov	r10,0
80005334:	30 0b       	mov	r11,0
80005336:	e0 6c b0 00 	mov	r12,45056
8000533a:	ea 1c 80 04 	orh	r12,0x8004
8000533e:	f0 1f 00 23 	mcall	800053c8 <xg_flashc_init+0x2dc>
80005342:	c2 0b       	rjmp	80005182 <xg_flashc_init+0x96>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
80005344:	49 dc       	lddpc	r12,800053b8 <xg_flashc_init+0x2cc>
80005346:	f0 1f 00 0b 	mcall	80005370 <xg_flashc_init+0x284>
8000534a:	30 07       	mov	r7,0
			ERASE:
			//erase:160pages		
			//for(i=0; i < ((XG_MESSAGE_DATA_BOUNDARY_ADD - XG_MESSAGE_LISTINFO_START_ADD)/(PageSize)); i++)//80k
			for(i=0; i <25; i++)//擦除太多页程序运行不正常。
			{
				current_page_number+=i;
8000534c:	49 26       	lddpc	r6,80005394 <xg_flashc_init+0x2a8>
				flashc_erase_page(current_page_number, true);
8000534e:	30 15       	mov	r5,1
80005350:	c3 eb       	rjmp	800051cc <xg_flashc_init+0xe0>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
80005352:	49 fc       	lddpc	r12,800053cc <xg_flashc_init+0x2e0>
80005354:	f0 1f 00 07 	mcall	80005370 <xg_flashc_init+0x284>
			}
		}
				
		//memcpy(xg_message_count_ptr, &current_message_index, sizeof(current_message_index));
		list_init_success_flag = 1;
80005358:	30 19       	mov	r9,1
8000535a:	49 e8       	lddpc	r8,800053d0 <xg_flashc_init+0x2e4>
8000535c:	b0 89       	st.b	r8[0x0],r9
	////flash_rw_example(ch, flash_nvram_data);
	////flash_rw_example(ch, &temp_data);
	
	#endif
	
}
8000535e:	2f ed       	sub	sp,-8
80005360:	d8 32       	popm	r0-r7,pc
80005362:	00 00       	add	r0,r0
80005364:	80 00       	ld.sh	r0,r0[0x0]
80005366:	67 10       	ld.w	r0,r3[0x44]
80005368:	00 00       	add	r0,r0
8000536a:	0b 74       	ld.ub	r4,--r5
8000536c:	80 00       	ld.sh	r0,r0[0x0]
8000536e:	da 9c       	*unknown*
80005370:	80 00       	ld.sh	r0,r0[0x0]
80005372:	72 80       	ld.w	r0,r9[0x20]
80005374:	80 00       	ld.sh	r0,r0[0x0]
80005376:	67 68       	ld.w	r8,r3[0x58]
80005378:	00 00       	add	r0,r0
8000537a:	0b 6c       	ld.uh	r12,--r5
8000537c:	00 00       	add	r0,r0
8000537e:	0b 78       	ld.ub	r8,--r5
80005380:	00 00       	add	r0,r0
80005382:	0e 02       	add	r2,r7
80005384:	80 00       	ld.sh	r0,r0[0x0]
80005386:	2a 64       	sub	r4,-90
80005388:	00 00       	add	r0,r0
8000538a:	0b 84       	ld.ub	r4,r5[0x0]
8000538c:	80 00       	ld.sh	r0,r0[0x0]
8000538e:	57 9c       	stdsp	sp[0x1e4],r12
80005390:	80 00       	ld.sh	r0,r0[0x0]
80005392:	54 44       	stdsp	sp[0x110],r4
80005394:	00 00       	add	r0,r0
80005396:	0b 7c       	ld.ub	r12,--r5
80005398:	80 00       	ld.sh	r0,r0[0x0]
8000539a:	54 24       	stdsp	sp[0x108],r4
8000539c:	80 00       	ld.sh	r0,r0[0x0]
8000539e:	54 34       	stdsp	sp[0x10c],r4
800053a0:	00 00       	add	r0,r0
800053a2:	05 30       	ld.ub	r0,r2++
800053a4:	80 00       	ld.sh	r0,r0[0x0]
800053a6:	7a fc       	ld.w	r12,sp[0x3c]
800053a8:	80 00       	ld.sh	r0,r0[0x0]
800053aa:	54 cc       	stdsp	sp[0x130],r12
800053ac:	00 00       	add	r0,r0
800053ae:	0b 80       	ld.ub	r0,r5[0x0]
800053b0:	80 00       	ld.sh	r0,r0[0x0]
800053b2:	da c8       	*unknown*
800053b4:	80 00       	ld.sh	r0,r0[0x0]
800053b6:	da f4       	*unknown*
800053b8:	80 00       	ld.sh	r0,r0[0x0]
800053ba:	db 00       	acall	0xb0
800053bc:	00 00       	add	r0,r0
800053be:	05 38       	ld.ub	r8,r2++
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	db 28       	*unknown*
800053c4:	80 00       	ld.sh	r0,r0[0x0]
800053c6:	db 4c       	*unknown*
800053c8:	80 00       	ld.sh	r0,r0[0x0]
800053ca:	55 64       	stdsp	sp[0x158],r4
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	db 74       	*unknown*
800053d0:	00 00       	add	r0,r0
800053d2:	0b 70       	ld.ub	r0,--r5

800053d4 <flashc_get_flash_size>:
 */
//! @{


unsigned int flashc_get_flash_size(void)
{
800053d4:	d4 01       	pushm	lr
800053d6:	20 4d       	sub	sp,16
		256,
		384,
		512,
		768,
		1024,
	};
800053d8:	31 0a       	mov	r10,16
800053da:	48 ab       	lddpc	r11,80005400 <flashc_get_flash_size+0x2c>
800053dc:	1a 9c       	mov	r12,sp
800053de:	f0 1f 00 0a 	mcall	80005404 <flashc_get_flash_size+0x30>
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
800053e2:	fe 68 14 00 	mov	r8,-125952
800053e6:	70 28       	ld.w	r8,r8[0x8]
800053e8:	f1 d8 c1 a3 	bfextu	r8,r8,0xd,0x3
800053ec:	fa c9 ff f0 	sub	r9,sp,-16
800053f0:	f2 08 00 18 	add	r8,r9,r8<<0x1
800053f4:	f1 1c ff f0 	ld.uh	r12,r8[-16]
			>> AVR32_FLASHC_FSR_FSZ_OFFSET]) << 10;
#endif
}
800053f8:	ab 6c       	lsl	r12,0xa
800053fa:	2f cd       	sub	sp,-16
800053fc:	d8 02       	popm	pc
800053fe:	00 00       	add	r0,r0
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	db fa       	popm	r0-r11,pc,r12=1
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	7b 22       	ld.w	r2,sp[0x48]

80005408 <flashc_is_ready>:
//! @{


bool flashc_is_ready(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
80005408:	fe 68 14 00 	mov	r8,-125952
8000540c:	70 2c       	ld.w	r12,r8[0x8]
}
8000540e:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80005412:	5e fc       	retal	r12

80005414 <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
80005414:	d4 01       	pushm	lr
	while (!flashc_is_ready());
80005416:	f0 1f 00 03 	mcall	80005420 <flashc_default_wait_until_ready+0xc>
8000541a:	cf e0       	breq	80005416 <flashc_default_wait_until_ready+0x2>
}
8000541c:	d8 02       	popm	pc
8000541e:	00 00       	add	r0,r0
80005420:	80 00       	ld.sh	r0,r0[0x0]
80005422:	54 08       	stdsp	sp[0x100],r8

80005424 <flashc_is_lock_error>:
//! by a function.
static unsigned int flashc_error_status = 0;


bool flashc_is_lock_error(void)
{
80005424:	48 38       	lddpc	r8,80005430 <flashc_is_lock_error+0xc>
80005426:	70 0c       	ld.w	r12,r8[0x0]
	return ((flashc_error_status & AVR32_FLASHC_FSR_LOCKE_MASK) != 0);
}
80005428:	f9 dc c0 41 	bfextu	r12,r12,0x2,0x1
8000542c:	5e fc       	retal	r12
8000542e:	00 00       	add	r0,r0
80005430:	00 00       	add	r0,r0
80005432:	0b d4       	ld.ub	r4,r5[0x5]

80005434 <flashc_is_programming_error>:


bool flashc_is_programming_error(void)
{
80005434:	48 38       	lddpc	r8,80005440 <flashc_is_programming_error+0xc>
80005436:	70 0c       	ld.w	r12,r8[0x0]
	return ((flashc_error_status & AVR32_FLASHC_FSR_PROGE_MASK) != 0);
}
80005438:	f9 dc c0 61 	bfextu	r12,r12,0x3,0x1
8000543c:	5e fc       	retal	r12
8000543e:	00 00       	add	r0,r0
80005440:	00 00       	add	r0,r0
80005442:	0b d4       	ld.ub	r4,r5[0x5]

80005444 <flashc_get_page_number>:
}


unsigned int flashc_get_page_number(void)
{
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
80005444:	fe 68 14 00 	mov	r8,-125952
80005448:	70 1c       	ld.w	r12,r8[0x4]
}
8000544a:	f9 dc c1 10 	bfextu	r12,r12,0x8,0x10
8000544e:	5e fc       	retal	r12

80005450 <flashc_issue_command>:


void flashc_issue_command(unsigned int command, int page_number)
{
80005450:	eb cd 40 c0 	pushm	r6-r7,lr
80005454:	18 96       	mov	r6,r12
80005456:	16 97       	mov	r7,r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80005458:	48 e8       	lddpc	r8,80005490 <flashc_issue_command+0x40>
8000545a:	70 08       	ld.w	r8,r8[0x0]
8000545c:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8000545e:	fe 68 14 00 	mov	r8,-125952
80005462:	70 18       	ld.w	r8,r8[0x4]
	u_avr32_flashc_fcmd.FCMD.cmd = command;
80005464:	f1 d6 d0 06 	bfins	r8,r6,0x0,0x6
	if (page_number >= 0) {
80005468:	58 07       	cp.w	r7,0
8000546a:	c0 35       	brlt	80005470 <flashc_issue_command+0x20>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
8000546c:	f1 d7 d1 10 	bfins	r8,r7,0x8,0x10
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
80005470:	3a 59       	mov	r9,-91
80005472:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
80005476:	fe 69 14 00 	mov	r9,-125952
8000547a:	93 18       	st.w	r9[0x4],r8
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
8000547c:	72 29       	ld.w	r9,r9[0x8]
	if (page_number >= 0) {
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
	flashc_error_status = flashc_get_error_status();
8000547e:	e2 19 00 0c 	andl	r9,0xc,COH
80005482:	48 58       	lddpc	r8,80005494 <flashc_issue_command+0x44>
80005484:	91 09       	st.w	r8[0x0],r9
	flashc_wait_until_ready();
80005486:	48 38       	lddpc	r8,80005490 <flashc_issue_command+0x40>
80005488:	70 08       	ld.w	r8,r8[0x0]
8000548a:	5d 18       	icall	r8
}
8000548c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005490:	00 00       	add	r0,r0
80005492:	05 3c       	ld.ub	r12,r2++
80005494:	00 00       	add	r0,r0
80005496:	0b d4       	ld.ub	r4,r5[0x5]

80005498 <flashc_clear_page_buffer>:
 */
//! @{


void flashc_clear_page_buffer(void)
{
80005498:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
8000549a:	3f fb       	mov	r11,-1
8000549c:	30 3c       	mov	r12,3
8000549e:	f0 1f 00 02 	mcall	800054a4 <flashc_clear_page_buffer+0xc>
}
800054a2:	d8 02       	popm	pc
800054a4:	80 00       	ld.sh	r0,r0[0x0]
800054a6:	54 50       	stdsp	sp[0x114],r0

800054a8 <flashc_is_page_erased>:


bool flashc_is_page_erased(void)
{
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
800054a8:	fe 68 14 00 	mov	r8,-125952
800054ac:	70 2c       	ld.w	r12,r8[0x8]
}
800054ae:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
800054b2:	5e fc       	retal	r12

800054b4 <flashc_quick_page_read>:


bool flashc_quick_page_read(int page_number)
{
800054b4:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
800054b6:	18 9b       	mov	r11,r12
800054b8:	30 cc       	mov	r12,12
800054ba:	f0 1f 00 03 	mcall	800054c4 <flashc_quick_page_read+0x10>
	return flashc_is_page_erased();
800054be:	f0 1f 00 03 	mcall	800054c8 <flashc_quick_page_read+0x14>
}
800054c2:	d8 02       	popm	pc
800054c4:	80 00       	ld.sh	r0,r0[0x0]
800054c6:	54 50       	stdsp	sp[0x114],r0
800054c8:	80 00       	ld.sh	r0,r0[0x0]
800054ca:	54 a8       	stdsp	sp[0x128],r8

800054cc <flashc_erase_page>:


bool flashc_erase_page(int page_number, bool check)
{
800054cc:	eb cd 40 c0 	pushm	r6-r7,lr
800054d0:	16 97       	mov	r7,r11
	bool page_erased = true;

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
800054d2:	18 9b       	mov	r11,r12
800054d4:	30 2c       	mov	r12,2
800054d6:	f0 1f 00 09 	mcall	800054f8 <flashc_erase_page+0x2c>
	if (check) {
800054da:	58 07       	cp.w	r7,0
800054dc:	c0 31       	brne	800054e2 <flashc_erase_page+0x16>
800054de:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
		unsigned int error_status = flashc_error_status;
800054e2:	48 77       	lddpc	r7,800054fc <flashc_erase_page+0x30>
800054e4:	6e 06       	ld.w	r6,r7[0x0]
		page_erased = flashc_quick_page_read(-1);
800054e6:	3f fc       	mov	r12,-1
800054e8:	f0 1f 00 06 	mcall	80005500 <flashc_erase_page+0x34>
		flashc_error_status |= error_status;
800054ec:	6e 08       	ld.w	r8,r7[0x0]
800054ee:	f1 e6 10 06 	or	r6,r8,r6
800054f2:	8f 06       	st.w	r7[0x0],r6
	}
	return page_erased;
}
800054f4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800054f8:	80 00       	ld.sh	r0,r0[0x0]
800054fa:	54 50       	stdsp	sp[0x114],r0
800054fc:	00 00       	add	r0,r0
800054fe:	0b d4       	ld.ub	r4,r5[0x5]
80005500:	80 00       	ld.sh	r0,r0[0x0]
80005502:	54 b4       	stdsp	sp[0x12c],r4

80005504 <flashc_write_page>:
	return all_pages_erased;
}


void flashc_write_page(int page_number)
{
80005504:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
80005506:	18 9b       	mov	r11,r12
80005508:	30 1c       	mov	r12,1
8000550a:	f0 1f 00 02 	mcall	80005510 <flashc_write_page+0xc>
}
8000550e:	d8 02       	popm	pc
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	54 50       	stdsp	sp[0x114],r0

80005514 <flashc_quick_user_page_read>:


bool flashc_quick_user_page_read(void)
{
80005514:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
80005516:	3f fb       	mov	r11,-1
80005518:	30 fc       	mov	r12,15
8000551a:	f0 1f 00 03 	mcall	80005524 <flashc_quick_user_page_read+0x10>
	return flashc_is_page_erased();
8000551e:	f0 1f 00 03 	mcall	80005528 <flashc_quick_user_page_read+0x14>
}
80005522:	d8 02       	popm	pc
80005524:	80 00       	ld.sh	r0,r0[0x0]
80005526:	54 50       	stdsp	sp[0x114],r0
80005528:	80 00       	ld.sh	r0,r0[0x0]
8000552a:	54 a8       	stdsp	sp[0x128],r8

8000552c <flashc_erase_user_page>:


bool flashc_erase_user_page(bool check)
{
8000552c:	eb cd 40 80 	pushm	r7,lr
80005530:	18 97       	mov	r7,r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
80005532:	3f fb       	mov	r11,-1
80005534:	30 ec       	mov	r12,14
80005536:	f0 1f 00 06 	mcall	8000554c <flashc_erase_user_page+0x20>
	return (check) ? flashc_quick_user_page_read() : true;
8000553a:	58 07       	cp.w	r7,0
8000553c:	c0 31       	brne	80005542 <flashc_erase_user_page+0x16>
8000553e:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80005542:	f0 1f 00 04 	mcall	80005550 <flashc_erase_user_page+0x24>
}
80005546:	e3 cd 80 80 	ldm	sp++,r7,pc
8000554a:	00 00       	add	r0,r0
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	54 50       	stdsp	sp[0x114],r0
80005550:	80 00       	ld.sh	r0,r0[0x0]
80005552:	55 14       	stdsp	sp[0x144],r4

80005554 <flashc_write_user_page>:


void flashc_write_user_page(void)
{
80005554:	d4 01       	pushm	lr
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
80005556:	3f fb       	mov	r11,-1
80005558:	30 dc       	mov	r12,13
8000555a:	f0 1f 00 02 	mcall	80005560 <flashc_write_user_page+0xc>
}
8000555e:	d8 02       	popm	pc
80005560:	80 00       	ld.sh	r0,r0[0x0]
80005562:	54 50       	stdsp	sp[0x114],r0

80005564 <flashc_memset64>:
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
80005564:	d4 31       	pushm	r0-r7,lr
80005566:	20 cd       	sub	sp,48
80005568:	50 6c       	stdsp	sp[0x18],r12
8000556a:	14 94       	mov	r4,r10
8000556c:	16 95       	mov	r5,r11
8000556e:	12 96       	mov	r6,r9
80005570:	50 38       	stdsp	sp[0xc],r8
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
80005572:	30 08       	mov	r8,0
80005574:	30 09       	mov	r9,0
80005576:	fa e9 00 28 	st.d	sp[40],r8
	UnionVPtr tmp;
	unsigned int error_status = 0;
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
8000557a:	f0 1f 00 82 	mcall	80005780 <flashc_memset64+0x21c>
8000557e:	fc 18 80 00 	movh	r8,0x8000
80005582:	f8 08 00 08 	add	r8,r12,r8
80005586:	50 28       	stdsp	sp[0x8],r8
	dest.u8ptr = dst;
80005588:	40 6b       	lddsp	r11,sp[0x18]
8000558a:	16 97       	mov	r7,r11
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
8000558c:	58 04       	cp.w	r4,0
8000558e:	5c 25       	cpc	r5
80005590:	c1 80       	breq	800055c0 <flashc_memset64+0x5c>
80005592:	f6 c8 ff f9 	sub	r8,r11,-7
80005596:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
8000559a:	fa c9 ff d0 	sub	r9,sp,-48
8000559e:	10 09       	add	r9,r8
800055a0:	f3 64 ff f8 	st.b	r9[-8],r4
		src >>= 8;
800055a4:	e8 0c 16 08 	lsr	r12,r4,0x8
800055a8:	ea 0a 16 08 	lsr	r10,r5,0x8
800055ac:	f9 e5 11 89 	or	r9,r12,r5<<0x18
800055b0:	14 95       	mov	r5,r10
800055b2:	12 94       	mov	r4,r9

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
800055b4:	20 18       	sub	r8,1
800055b6:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
800055ba:	58 04       	cp.w	r4,0
800055bc:	5c 25       	cpc	r5
800055be:	ce e1       	brne	8000559a <flashc_memset64+0x36>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
800055c0:	f6 06 00 06 	add	r6,r11,r6
800055c4:	50 06       	stdsp	sp[0x0],r6

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
800055c6:	e0 6a ff ff 	mov	r10,65535
800055ca:	ea 1a 7f ff 	orh	r10,0x7fff
800055ce:	14 3b       	cp.w	r11,r10
800055d0:	e0 8b 00 05 	brhi	800055da <flashc_memset64+0x76>
		dest.u8ptr = AVR32_FLASH;
800055d4:	fc 17 80 00 	movh	r7,0x8000
800055d8:	c0 e8       	rjmp	800055f4 <flashc_memset64+0x90>
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
800055da:	40 29       	lddsp	r9,sp[0x8]
800055dc:	16 39       	cp.w	r9,r11
800055de:	e0 8b 00 0b 	brhi	800055f4 <flashc_memset64+0x90>
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
800055e2:	fc 18 80 80 	movh	r8,0x8080
800055e6:	e0 6a ff ff 	mov	r10,65535
800055ea:	ea 1a 80 7f 	orh	r10,0x807f
800055ee:	14 3b       	cp.w	r11,r10
800055f0:	f0 07 17 80 	movls	r7,r8
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
800055f4:	40 09       	lddsp	r9,sp[0x0]
800055f6:	e0 68 02 00 	mov	r8,512
800055fa:	ea 18 80 80 	orh	r8,0x8080
800055fe:	10 39       	cp.w	r9,r8
80005600:	e0 88 00 04 	brls	80005608 <flashc_memset64+0xa4>
80005604:	50 08       	stdsp	sp[0x0],r8
80005606:	c0 c8       	rjmp	8000561e <flashc_memset64+0xba>
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
80005608:	40 0a       	lddsp	r10,sp[0x0]
8000560a:	fc 19 80 80 	movh	r9,0x8080
8000560e:	12 3a       	cp.w	r10,r9
80005610:	e0 8b 00 07 	brhi	8000561e <flashc_memset64+0xba>
80005614:	40 28       	lddsp	r8,sp[0x8]
80005616:	10 3a       	cp.w	r10,r8
80005618:	f0 0a 17 b0 	movhi	r10,r8
8000561c:	50 0a       	stdsp	sp[0x0],r10
		dest_end.u8ptr = flash_array_end.u8ptr;
	}

	// Align each end of destination pointer with its natural boundary.
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
8000561e:	40 08       	lddsp	r8,sp[0x0]
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));
80005620:	10 9b       	mov	r11,r8
80005622:	e0 1b ff f8 	andl	r11,0xfff8
80005626:	50 1b       	stdsp	sp[0x4],r11
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
80005628:	fa e4 00 28 	ld.d	r4,sp[40]
8000562c:	30 03       	mov	r3,0

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
8000562e:	4d 66       	lddpc	r6,80005784 <flashc_memset64+0x220>
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80005630:	10 9a       	mov	r10,r8
80005632:	e0 1a fe 00 	andl	r10,0xfe00
80005636:	50 4a       	stdsp	sp[0x10],r10
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
80005638:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000563c:	50 58       	stdsp	sp[0x14],r8
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000563e:	40 08       	lddsp	r8,sp[0x0]
80005640:	40 59       	lddsp	r9,sp[0x14]
80005642:	12 18       	sub	r8,r9
80005644:	2f 88       	sub	r8,-8
80005646:	50 78       	stdsp	sp[0x1c],r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
80005648:	c9 18       	rjmp	8000576a <flashc_memset64+0x206>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
8000564a:	f0 1f 00 50 	mcall	80005788 <flashc_memset64+0x224>
		error_status |= flashc_error_status;
8000564e:	6c 08       	ld.w	r8,r6[0x0]
80005650:	10 43       	or	r3,r8

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
80005652:	04 9c       	mov	r12,r2
80005654:	e0 1c fe 00 	andl	r12,0xfe00
80005658:	f8 ce fe 00 	sub	lr,r12,-512
8000565c:	40 18       	lddsp	r8,sp[0x4]
8000565e:	f0 0e 0d 4e 	min	lr,r8,lr
		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
80005662:	fa e5 00 20 	st.d	sp[32],r4

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
80005666:	f1 d2 c0 09 	bfextu	r8,r2,0x0,0x9
8000566a:	c2 f0       	breq	800056c8 <flashc_memset64+0x164>
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
8000566c:	18 98       	mov	r8,r12
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
8000566e:	18 90       	mov	r0,r12
80005670:	04 91       	mov	r1,r2
80005672:	e0 11 ff f8 	andl	r1,0xfff8
80005676:	02 99       	mov	r9,r1
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
80005678:	18 31       	cp.w	r1,r12
8000567a:	e0 88 00 10 	brls	8000569a <flashc_memset64+0x136>
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
8000567e:	f0 ea 00 00 	ld.d	r10,r8[0]
80005682:	b1 2a       	st.d	r8++,r10
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
80005684:	10 39       	cp.w	r9,r8
80005686:	fe 9b ff fc 	brhi	8000567e <flashc_memset64+0x11a>
8000568a:	e0 08 11 ff 	rsub	r8,r0,-1
8000568e:	02 08       	add	r8,r1
80005690:	e0 18 ff f8 	andl	r8,0xfff8
80005694:	2f 88       	sub	r8,-8
80005696:	e0 08 00 08 	add	r8,r0,r8
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
8000569a:	e5 d2 c0 03 	bfextu	r2,r2,0x0,0x3
8000569e:	c1 50       	breq	800056c8 <flashc_memset64+0x164>
800056a0:	30 0a       	mov	r10,0
800056a2:	f0 0a 00 0b 	add	r11,r8,r10
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
					flash_dword.u8[i] = *tmp.u8ptr++;
800056a6:	17 8b       	ld.ub	r11,r11[0x0]
800056a8:	fa c7 ff e0 	sub	r7,sp,-32
800056ac:	ee 0a 0b 0b 	st.b	r7[r10],r11
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
800056b0:	2f fa       	sub	r10,-1
800056b2:	04 3a       	cp.w	r10,r2
800056b4:	cf 71       	brne	800056a2 <flashc_memset64+0x13e>
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800056b6:	12 97       	mov	r7,r9

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
800056b8:	40 1b       	lddsp	r11,sp[0x4]
800056ba:	16 39       	cp.w	r9,r11
800056bc:	c0 62       	brcc	800056c8 <flashc_memset64+0x164>
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
800056be:	fa e8 00 20 	ld.d	r8,sp[32]
800056c2:	af 28       	st.d	r7++,r8
					flash_dword.u64 = source.u64;
800056c4:	fa e5 00 20 	st.d	sp[32],r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
800056c8:	0e 99       	mov	r9,r7
800056ca:	0e 1e       	sub	lr,r7
800056cc:	a3 5e       	asr	lr,0x3
800056ce:	c0 80       	breq	800056de <flashc_memset64+0x17a>
800056d0:	0e 9a       	mov	r10,r7
800056d2:	1c 98       	mov	r8,lr
			*dest.u64ptr++ = source.u64;
800056d4:	b5 24       	st.d	r10++,r4
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
800056d6:	20 18       	sub	r8,1
800056d8:	cf e1       	brne	800056d4 <flashc_memset64+0x170>
800056da:	f2 0e 00 37 	add	r7,r9,lr<<0x3
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
800056de:	40 4a       	lddsp	r10,sp[0x10]
800056e0:	14 3c       	cp.w	r12,r10
800056e2:	c1 d3       	brcs	8000571c <flashc_memset64+0x1b8>
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
800056e4:	40 08       	lddsp	r8,sp[0x0]

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
800056e6:	40 59       	lddsp	r9,sp[0x14]
800056e8:	58 09       	cp.w	r9,0
800056ea:	c1 00       	breq	8000570a <flashc_memset64+0x1a6>
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
800056ec:	10 99       	mov	r9,r8
800056ee:	fa c8 ff e0 	sub	r8,sp,-32
800056f2:	40 5b       	lddsp	r11,sp[0x14]
800056f4:	16 08       	add	r8,r11
{
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
800056f6:	fa cb ff d8 	sub	r11,sp,-40

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
						flash_dword.u8[i] = *tmp.u8ptr++;
800056fa:	13 3a       	ld.ub	r10,r9++
800056fc:	10 ca       	st.b	r8++,r10
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
800056fe:	16 38       	cp.w	r8,r11
80005700:	cf d1       	brne	800056fa <flashc_memset64+0x196>
80005702:	40 78       	lddsp	r8,sp[0x1c]
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
80005704:	fa ea 00 20 	ld.d	r10,sp[32]
80005708:	af 2a       	st.d	r7++,r10
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
8000570a:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000570e:	c0 70       	breq	8000571c <flashc_memset64+0x1b8>
					*tmp.u64ptr = *tmp.u64ptr;
80005710:	f0 ea 00 00 	ld.d	r10,r8[0]
80005714:	b1 2a       	st.d	r8++,r10
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80005716:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000571a:	cf b1       	brne	80005710 <flashc_memset64+0x1ac>
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
8000571c:	0e 92       	mov	r2,r7
8000571e:	fc 1a 80 80 	movh	r10,0x8080
80005722:	14 37       	cp.w	r7,r10
80005724:	e0 8b 00 17 	brhi	80005752 <flashc_memset64+0x1ee>
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
80005728:	40 39       	lddsp	r9,sp[0xc]
8000572a:	58 09       	cp.w	r9,0
8000572c:	c0 70       	breq	8000573a <flashc_memset64+0x1d6>
				flashc_erase_page(-1, false);
8000572e:	30 0b       	mov	r11,0
80005730:	3f fc       	mov	r12,-1
80005732:	f0 1f 00 17 	mcall	8000578c <flashc_memset64+0x228>
				error_status |= flashc_error_status;
80005736:	6c 08       	ld.w	r8,r6[0x0]
80005738:	10 43       	or	r3,r8
			}
			flashc_write_page(-1);
8000573a:	3f fc       	mov	r12,-1
8000573c:	f0 1f 00 15 	mcall	80005790 <flashc_memset64+0x22c>
			error_status |= flashc_error_status;
80005740:	6c 08       	ld.w	r8,r6[0x0]
80005742:	10 43       	or	r3,r8

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80005744:	fc 18 80 80 	movh	r8,0x8080
80005748:	40 2b       	lddsp	r11,sp[0x8]
8000574a:	04 3b       	cp.w	r11,r2
8000574c:	f0 07 17 80 	movls	r7,r8
80005750:	c0 d8       	rjmp	8000576a <flashc_memset64+0x206>
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
80005752:	40 3a       	lddsp	r10,sp[0xc]
80005754:	58 0a       	cp.w	r10,0
80005756:	c0 60       	breq	80005762 <flashc_memset64+0x1fe>
				flashc_erase_user_page(false);
80005758:	30 0c       	mov	r12,0
8000575a:	f0 1f 00 0f 	mcall	80005794 <flashc_memset64+0x230>
				error_status |= flashc_error_status;
8000575e:	6c 08       	ld.w	r8,r6[0x0]
80005760:	10 43       	or	r3,r8
			}
			flashc_write_user_page();
80005762:	f0 1f 00 0e 	mcall	80005798 <flashc_memset64+0x234>
			error_status |= flashc_error_status;
80005766:	6c 08       	ld.w	r8,r6[0x0]
80005768:	10 43       	or	r3,r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
8000576a:	0e 92       	mov	r2,r7
8000576c:	40 09       	lddsp	r9,sp[0x0]
8000576e:	12 37       	cp.w	r7,r9
80005770:	fe 93 ff 6d 	brlo	8000564a <flashc_memset64+0xe6>
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
80005774:	48 48       	lddpc	r8,80005784 <flashc_memset64+0x220>
80005776:	91 03       	st.w	r8[0x0],r3

	// Return the initial destination pointer as the standard memset function does.
	return dst;
}
80005778:	40 6c       	lddsp	r12,sp[0x18]
8000577a:	2f 4d       	sub	sp,-48
8000577c:	d8 32       	popm	r0-r7,pc
8000577e:	00 00       	add	r0,r0
80005780:	80 00       	ld.sh	r0,r0[0x0]
80005782:	53 d4       	stdsp	sp[0xf4],r4
80005784:	00 00       	add	r0,r0
80005786:	0b d4       	ld.ub	r4,r5[0x5]
80005788:	80 00       	ld.sh	r0,r0[0x0]
8000578a:	54 98       	stdsp	sp[0x124],r8
8000578c:	80 00       	ld.sh	r0,r0[0x0]
8000578e:	54 cc       	stdsp	sp[0x130],r12
80005790:	80 00       	ld.sh	r0,r0[0x0]
80005792:	55 04       	stdsp	sp[0x140],r4
80005794:	80 00       	ld.sh	r0,r0[0x0]
80005796:	55 2c       	stdsp	sp[0x148],r12
80005798:	80 00       	ld.sh	r0,r0[0x0]
8000579a:	55 54       	stdsp	sp[0x154],r4

8000579c <flashc_memcpy>:


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
8000579c:	d4 31       	pushm	r0-r7,lr
8000579e:	20 7d       	sub	sp,28
800057a0:	50 1c       	stdsp	sp[0x4],r12
800057a2:	14 97       	mov	r7,r10
800057a4:	50 49       	stdsp	sp[0x10],r9
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
800057a6:	e0 69 ff ff 	mov	r9,65535
800057aa:	ea 19 80 7f 	orh	r9,0x807f
800057ae:	12 3c       	cp.w	r12,r9
800057b0:	5f b8       	srhi	r8
800057b2:	50 28       	stdsp	sp[0x8],r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
800057b4:	58 0a       	cp.w	r10,0
800057b6:	c0 41       	brne	800057be <flashc_memcpy+0x22>
800057b8:	30 09       	mov	r9,0
800057ba:	50 09       	stdsp	sp[0x0],r9
800057bc:	c5 b8       	rjmp	80005872 <flashc_memcpy+0xd6>
	Union64 flash_dword;
	uint8_t i;
	bool b_user_page;
	unsigned int error_status = 0;
	uint8_t* flash_add;
	uint8_t* dest_add=(uint8_t*)dst;
800057be:	40 16       	lddsp	r6,sp[0x4]
	const uint8_t* src_buf=(const uint8_t*)src;
800057c0:	16 94       	mov	r4,r11
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));
800057c2:	0c 90       	mov	r0,r6
800057c4:	e0 10 fe 00 	andl	r0,0xfe00
800057c8:	30 08       	mov	r8,0
800057ca:	50 08       	stdsp	sp[0x0],r8

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;
800057cc:	4a d1       	lddpc	r1,80005880 <flashc_memcpy+0xe4>
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
800057ce:	30 05       	mov	r5,0
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
800057d0:	fa c3 ff ec 	sub	r3,sp,-20
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
800057d4:	10 92       	mov	r2,r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800057d6:	f0 1f 00 2c 	mcall	80005884 <flashc_memcpy+0xe8>
		error_status |= flashc_error_status;
800057da:	62 08       	ld.w	r8,r1[0x0]
800057dc:	40 09       	lddsp	r9,sp[0x0]
800057de:	10 49       	or	r9,r8
800057e0:	50 09       	stdsp	sp[0x0],r9
800057e2:	00 9b       	mov	r11,r0
800057e4:	e0 ce fe 00 	sub	lr,r0,-512
800057e8:	16 9c       	mov	r12,r11

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
800057ea:	f6 e8 00 00 	ld.d	r8,r11[0]
800057ee:	fa e9 00 14 	st.d	sp[20],r8
800057f2:	04 98       	mov	r8,r2

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
				if (nbytes && (flash_add == dest_add)) {
800057f4:	58 07       	cp.w	r7,0
800057f6:	5f 1a       	srne	r10
800057f8:	f0 0b 00 09 	add	r9,r8,r11
800057fc:	12 36       	cp.w	r6,r9
800057fe:	5f 09       	sreq	r9
80005800:	f5 e9 00 09 	and	r9,r10,r9
80005804:	ea 09 18 00 	cp.b	r9,r5
80005808:	c0 60       	breq	80005814 <flashc_memcpy+0x78>
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
8000580a:	09 39       	ld.ub	r9,r4++
8000580c:	e6 08 0b 09 	st.b	r3[r8],r9
					dest_add++;
80005810:	2f f6       	sub	r6,-1
					nbytes--;
80005812:	20 17       	sub	r7,1
80005814:	2f f8       	sub	r8,-1
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
80005816:	58 88       	cp.w	r8,8
80005818:	ce e1       	brne	800057f4 <flashc_memcpy+0x58>
				}
				flash_add++;
			}

			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
8000581a:	fa e8 00 14 	ld.d	r8,sp[20]
8000581e:	f8 e9 00 00 	st.d	r12[0],r8
80005822:	2f 8b       	sub	r11,-8
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
80005824:	1c 3b       	cp.w	r11,lr
80005826:	ce 11       	brne	800057e8 <flashc_memcpy+0x4c>
80005828:	50 37       	stdsp	sp[0xc],r7
8000582a:	e0 c0 fe 00 	sub	r0,r0,-512
			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
		}

		// Erase the current page if requested and write it from the page buffer.
		if (erase) {
8000582e:	40 48       	lddsp	r8,sp[0x10]
80005830:	58 08       	cp.w	r8,0
80005832:	c1 00       	breq	80005852 <flashc_memcpy+0xb6>
			(b_user_page)? flashc_erase_user_page(false) : flashc_erase_page(-1, false);
80005834:	40 29       	lddsp	r9,sp[0x8]
80005836:	58 09       	cp.w	r9,0
80005838:	c0 50       	breq	80005842 <flashc_memcpy+0xa6>
8000583a:	30 0c       	mov	r12,0
8000583c:	f0 1f 00 13 	mcall	80005888 <flashc_memcpy+0xec>
80005840:	c0 58       	rjmp	8000584a <flashc_memcpy+0xae>
80005842:	30 0b       	mov	r11,0
80005844:	3f fc       	mov	r12,-1
80005846:	f0 1f 00 12 	mcall	8000588c <flashc_memcpy+0xf0>
			error_status |= flashc_error_status;
8000584a:	62 08       	ld.w	r8,r1[0x0]
8000584c:	40 09       	lddsp	r9,sp[0x0]
8000584e:	10 49       	or	r9,r8
80005850:	50 09       	stdsp	sp[0x0],r9
		}

		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
80005852:	40 28       	lddsp	r8,sp[0x8]
80005854:	58 08       	cp.w	r8,0
80005856:	c0 40       	breq	8000585e <flashc_memcpy+0xc2>
80005858:	f0 1f 00 0e 	mcall	80005890 <flashc_memcpy+0xf4>
8000585c:	c0 48       	rjmp	80005864 <flashc_memcpy+0xc8>
8000585e:	3f fc       	mov	r12,-1
80005860:	f0 1f 00 0d 	mcall	80005894 <flashc_memcpy+0xf8>
		error_status |= flashc_error_status;
80005864:	62 08       	ld.w	r8,r1[0x0]
80005866:	40 09       	lddsp	r9,sp[0x0]
80005868:	10 49       	or	r9,r8
8000586a:	50 09       	stdsp	sp[0x0],r9

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
8000586c:	40 38       	lddsp	r8,sp[0xc]
8000586e:	58 08       	cp.w	r8,0
80005870:	cb 31       	brne	800057d6 <flashc_memcpy+0x3a>
		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
		error_status |= flashc_error_status;
	}
	// Update the FLASHC error status.
	flashc_error_status = error_status;
80005872:	48 48       	lddpc	r8,80005880 <flashc_memcpy+0xe4>
80005874:	40 09       	lddsp	r9,sp[0x0]
80005876:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memcpy function does.
	return dst;
}
80005878:	40 1c       	lddsp	r12,sp[0x4]
8000587a:	2f 9d       	sub	sp,-28
8000587c:	d8 32       	popm	r0-r7,pc
8000587e:	00 00       	add	r0,r0
80005880:	00 00       	add	r0,r0
80005882:	0b d4       	ld.ub	r4,r5[0x5]
80005884:	80 00       	ld.sh	r0,r0[0x0]
80005886:	54 98       	stdsp	sp[0x124],r8
80005888:	80 00       	ld.sh	r0,r0[0x0]
8000588a:	55 2c       	stdsp	sp[0x148],r12
8000588c:	80 00       	ld.sh	r0,r0[0x0]
8000588e:	54 cc       	stdsp	sp[0x130],r12
80005890:	80 00       	ld.sh	r0,r0[0x0]
80005892:	55 54       	stdsp	sp[0x154],r4
80005894:	80 00       	ld.sh	r0,r0[0x0]
80005896:	55 04       	stdsp	sp[0x140],r4

80005898 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005898:	f8 08 16 05 	lsr	r8,r12,0x5
8000589c:	a9 68       	lsl	r8,0x8
8000589e:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800058a2:	58 1b       	cp.w	r11,1
800058a4:	c0 d0       	breq	800058be <gpio_enable_module_pin+0x26>
800058a6:	c0 63       	brcs	800058b2 <gpio_enable_module_pin+0x1a>
800058a8:	58 2b       	cp.w	r11,2
800058aa:	c1 00       	breq	800058ca <gpio_enable_module_pin+0x32>
800058ac:	58 3b       	cp.w	r11,3
800058ae:	c1 40       	breq	800058d6 <gpio_enable_module_pin+0x3e>
800058b0:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800058b2:	30 19       	mov	r9,1
800058b4:	f2 0c 09 49 	lsl	r9,r9,r12
800058b8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800058ba:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800058bc:	c1 28       	rjmp	800058e0 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800058be:	30 19       	mov	r9,1
800058c0:	f2 0c 09 49 	lsl	r9,r9,r12
800058c4:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800058c6:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800058c8:	c0 c8       	rjmp	800058e0 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800058ca:	30 19       	mov	r9,1
800058cc:	f2 0c 09 49 	lsl	r9,r9,r12
800058d0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800058d2:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800058d4:	c0 68       	rjmp	800058e0 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800058d6:	30 19       	mov	r9,1
800058d8:	f2 0c 09 49 	lsl	r9,r9,r12
800058dc:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800058de:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800058e0:	30 19       	mov	r9,1
800058e2:	f2 0c 09 4c 	lsl	r12,r9,r12
800058e6:	91 2c       	st.w	r8[0x8],r12
800058e8:	5e fd       	retal	0
800058ea:	d7 03       	nop

800058ec <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800058ec:	d4 21       	pushm	r4-r7,lr
800058ee:	18 97       	mov	r7,r12
800058f0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800058f2:	58 0b       	cp.w	r11,0
800058f4:	c0 31       	brne	800058fa <gpio_enable_module+0xe>
800058f6:	30 05       	mov	r5,0
800058f8:	c0 d8       	rjmp	80005912 <gpio_enable_module+0x26>
800058fa:	30 06       	mov	r6,0
800058fc:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800058fe:	6e 1b       	ld.w	r11,r7[0x4]
80005900:	6e 0c       	ld.w	r12,r7[0x0]
80005902:	f0 1f 00 06 	mcall	80005918 <gpio_enable_module+0x2c>
80005906:	18 45       	or	r5,r12
		gpiomap++;
80005908:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000590a:	2f f6       	sub	r6,-1
8000590c:	0c 34       	cp.w	r4,r6
8000590e:	fe 9b ff f8 	brhi	800058fe <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80005912:	0a 9c       	mov	r12,r5
80005914:	d8 22       	popm	r4-r7,pc
80005916:	00 00       	add	r0,r0
80005918:	80 00       	ld.sh	r0,r0[0x0]
8000591a:	58 98       	cp.w	r8,9

8000591c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000591c:	f8 08 16 05 	lsr	r8,r12,0x5
80005920:	a9 68       	lsl	r8,0x8
80005922:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80005926:	30 19       	mov	r9,1
80005928:	f2 0c 09 4c 	lsl	r12,r9,r12
8000592c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80005930:	91 1c       	st.w	r8[0x4],r12
}
80005932:	5e fc       	retal	r12

80005934 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005934:	f8 08 16 05 	lsr	r8,r12,0x5
80005938:	a9 68       	lsl	r8,0x8
8000593a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000593e:	30 19       	mov	r9,1
80005940:	f2 0c 09 4c 	lsl	r12,r9,r12
80005944:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80005948:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000594c:	91 1c       	st.w	r8[0x4],r12
}
8000594e:	5e fc       	retal	r12

80005950 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80005950:	f8 08 16 05 	lsr	r8,r12,0x5
80005954:	a9 68       	lsl	r8,0x8
80005956:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000595a:	30 19       	mov	r9,1
8000595c:	f2 0c 09 4c 	lsl	r12,r9,r12
80005960:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80005964:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80005968:	91 1c       	st.w	r8[0x4],r12
}
8000596a:	5e fc       	retal	r12

8000596c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000596c:	c0 08       	rjmp	8000596c <_unhandled_interrupt>
8000596e:	d7 03       	nop

80005970 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80005970:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80005974:	49 99       	lddpc	r9,800059d8 <INTC_register_interrupt+0x68>
80005976:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000597a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000597e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80005980:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80005984:	58 0a       	cp.w	r10,0
80005986:	c0 91       	brne	80005998 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005988:	49 59       	lddpc	r9,800059dc <INTC_register_interrupt+0x6c>
8000598a:	49 6a       	lddpc	r10,800059e0 <INTC_register_interrupt+0x70>
8000598c:	12 1a       	sub	r10,r9
8000598e:	fe 79 08 00 	mov	r9,-63488
80005992:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80005996:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80005998:	58 1a       	cp.w	r10,1
8000599a:	c0 a1       	brne	800059ae <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000599c:	49 09       	lddpc	r9,800059dc <INTC_register_interrupt+0x6c>
8000599e:	49 2a       	lddpc	r10,800059e4 <INTC_register_interrupt+0x74>
800059a0:	12 1a       	sub	r10,r9
800059a2:	bf aa       	sbr	r10,0x1e
800059a4:	fe 79 08 00 	mov	r9,-63488
800059a8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800059ac:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800059ae:	58 2a       	cp.w	r10,2
800059b0:	c0 a1       	brne	800059c4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800059b2:	48 b9       	lddpc	r9,800059dc <INTC_register_interrupt+0x6c>
800059b4:	48 da       	lddpc	r10,800059e8 <INTC_register_interrupt+0x78>
800059b6:	12 1a       	sub	r10,r9
800059b8:	bf ba       	sbr	r10,0x1f
800059ba:	fe 79 08 00 	mov	r9,-63488
800059be:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800059c2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800059c4:	48 69       	lddpc	r9,800059dc <INTC_register_interrupt+0x6c>
800059c6:	48 aa       	lddpc	r10,800059ec <INTC_register_interrupt+0x7c>
800059c8:	12 1a       	sub	r10,r9
800059ca:	ea 1a c0 00 	orh	r10,0xc000
800059ce:	fe 79 08 00 	mov	r9,-63488
800059d2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800059d6:	5e fc       	retal	r12
800059d8:	80 00       	ld.sh	r0,r0[0x0]
800059da:	dc 0c       	*unknown*
800059dc:	80 00       	ld.sh	r0,r0[0x0]
800059de:	d0 00       	acall	0x0
800059e0:	80 00       	ld.sh	r0,r0[0x0]
800059e2:	d1 04       	*unknown*
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	d1 12       	popm	r0-r3,r11
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	d1 20       	acall	0x12
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	d1 2e       	*unknown*

800059f0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800059f0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800059f2:	49 18       	lddpc	r8,80005a34 <INTC_init_interrupts+0x44>
800059f4:	e3 b8 00 01 	mtsr	0x4,r8
800059f8:	49 0e       	lddpc	lr,80005a38 <INTC_init_interrupts+0x48>
800059fa:	30 07       	mov	r7,0
800059fc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800059fe:	49 0c       	lddpc	r12,80005a3c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005a00:	49 05       	lddpc	r5,80005a40 <INTC_init_interrupts+0x50>
80005a02:	10 15       	sub	r5,r8
80005a04:	fe 76 08 00 	mov	r6,-63488
80005a08:	c1 08       	rjmp	80005a28 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80005a0a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80005a0c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a0e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80005a10:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80005a14:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a16:	10 3a       	cp.w	r10,r8
80005a18:	fe 9b ff fc 	brhi	80005a10 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80005a1c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80005a20:	2f f7       	sub	r7,-1
80005a22:	2f 8e       	sub	lr,-8
80005a24:	59 37       	cp.w	r7,19
80005a26:	c0 50       	breq	80005a30 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80005a28:	7c 08       	ld.w	r8,lr[0x0]
80005a2a:	58 08       	cp.w	r8,0
80005a2c:	ce f1       	brne	80005a0a <INTC_init_interrupts+0x1a>
80005a2e:	cf 7b       	rjmp	80005a1c <INTC_init_interrupts+0x2c>
80005a30:	d8 22       	popm	r4-r7,pc
80005a32:	00 00       	add	r0,r0
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	d0 00       	acall	0x0
80005a38:	80 00       	ld.sh	r0,r0[0x0]
80005a3a:	dc 0c       	*unknown*
80005a3c:	80 00       	ld.sh	r0,r0[0x0]
80005a3e:	59 6c       	cp.w	r12,22
80005a40:	80 00       	ld.sh	r0,r0[0x0]
80005a42:	d1 04       	*unknown*

80005a44 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80005a44:	fe 78 08 00 	mov	r8,-63488
80005a48:	e0 69 00 83 	mov	r9,131
80005a4c:	f2 0c 01 0c 	sub	r12,r9,r12
80005a50:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80005a54:	f2 ca ff c0 	sub	r10,r9,-64
80005a58:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005a5c:	58 08       	cp.w	r8,0
80005a5e:	c0 21       	brne	80005a62 <_get_interrupt_handler+0x1e>
80005a60:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80005a62:	f0 08 12 00 	clz	r8,r8
80005a66:	48 5a       	lddpc	r10,80005a78 <_get_interrupt_handler+0x34>
80005a68:	f4 09 00 39 	add	r9,r10,r9<<0x3
80005a6c:	f0 08 11 1f 	rsub	r8,r8,31
80005a70:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80005a72:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80005a76:	5e fc       	retal	r12
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	dc 0c       	*unknown*

80005a7c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80005a7c:	f8 c8 00 01 	sub	r8,r12,1
80005a80:	f0 0b 00 0b 	add	r11,r8,r11
80005a84:	f6 0c 0d 0a 	divu	r10,r11,r12
80005a88:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80005a8a:	f4 c8 00 01 	sub	r8,r10,1
80005a8e:	e0 48 00 fe 	cp.w	r8,254
80005a92:	e0 88 00 03 	brls	80005a98 <getBaudDiv+0x1c>
80005a96:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80005a98:	5c 8c       	casts.h	r12
}
80005a9a:	5e fc       	retal	r12

80005a9c <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80005a9c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005aa0:	30 18       	mov	r8,1
80005aa2:	f0 09 18 00 	cp.b	r9,r8
80005aa6:	e0 88 00 04 	brls	80005aae <spi_initMaster+0x12>
80005aaa:	30 2c       	mov	r12,2
80005aac:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
80005aae:	e0 68 00 80 	mov	r8,128
80005ab2:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80005ab4:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80005ab6:	30 19       	mov	r9,1
80005ab8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
80005abc:	f7 39 00 0d 	ld.ub	r9,r11[13]
80005ac0:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80005ac4:	30 09       	mov	r9,0
80005ac6:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80005aca:	30 fa       	mov	r10,15
80005acc:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80005ad0:	99 18       	st.w	r12[0x4],r8
80005ad2:	5e f9       	retal	r9

80005ad4 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80005ad4:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80005ad6:	30 18       	mov	r8,1
80005ad8:	f0 0b 18 00 	cp.b	r11,r8
80005adc:	5f be       	srhi	lr
80005ade:	f0 0a 18 00 	cp.b	r10,r8
80005ae2:	5f b8       	srhi	r8
80005ae4:	fd e8 10 08 	or	r8,lr,r8
80005ae8:	c0 30       	breq	80005aee <spi_selectionMode+0x1a>
80005aea:	30 2c       	mov	r12,2
80005aec:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
80005aee:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
80005af0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80005af4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
80005af8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
80005afc:	99 18       	st.w	r12[0x4],r8
80005afe:	d8 0a       	popm	pc,r12=0

80005b00 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80005b00:	30 18       	mov	r8,1
80005b02:	99 08       	st.w	r12[0x0],r8
}
80005b04:	5e fc       	retal	r12

80005b06 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80005b06:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005b0a:	c0 58       	rjmp	80005b14 <spi_write+0xe>
		if (!timeout--) {
80005b0c:	58 08       	cp.w	r8,0
80005b0e:	c0 21       	brne	80005b12 <spi_write+0xc>
80005b10:	5e ff       	retal	1
80005b12:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80005b14:	78 49       	ld.w	r9,r12[0x10]
80005b16:	e2 19 00 02 	andl	r9,0x2,COH
80005b1a:	cf 90       	breq	80005b0c <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80005b1c:	5c 7b       	castu.h	r11
80005b1e:	99 3b       	st.w	r12[0xc],r11
80005b20:	5e fd       	retal	0

80005b22 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80005b22:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005b26:	c0 58       	rjmp	80005b30 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80005b28:	58 08       	cp.w	r8,0
80005b2a:	c0 21       	brne	80005b2e <spi_read+0xc>
80005b2c:	5e ff       	retal	1
80005b2e:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80005b30:	78 49       	ld.w	r9,r12[0x10]
80005b32:	e2 19 02 01 	andl	r9,0x201,COH
80005b36:	e0 49 02 01 	cp.w	r9,513
80005b3a:	cf 71       	brne	80005b28 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80005b3c:	78 28       	ld.w	r8,r12[0x8]
80005b3e:	b6 08       	st.h	r11[0x0],r8
80005b40:	5e fd       	retal	0
80005b42:	d7 03       	nop

80005b44 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80005b44:	eb cd 40 f8 	pushm	r3-r7,lr
80005b48:	18 95       	mov	r5,r12
80005b4a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005b4c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005b50:	30 38       	mov	r8,3
80005b52:	f0 06 18 00 	cp.b	r6,r8
80005b56:	e0 8b 00 5e 	brhi	80005c12 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
80005b5a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005b5e:	30 18       	mov	r8,1
80005b60:	f0 04 18 00 	cp.b	r4,r8
80005b64:	e0 8b 00 57 	brhi	80005c12 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80005b68:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80005b6c:	30 78       	mov	r8,7
80005b6e:	f0 03 18 00 	cp.b	r3,r8
80005b72:	e0 88 00 50 	brls	80005c12 <spi_setupChipReg+0xce>
80005b76:	31 08       	mov	r8,16
80005b78:	f0 03 18 00 	cp.b	r3,r8
80005b7c:	e0 8b 00 4b 	brhi	80005c12 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80005b80:	14 9b       	mov	r11,r10
80005b82:	6e 1c       	ld.w	r12,r7[0x4]
80005b84:	f0 1f 00 26 	mcall	80005c1c <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80005b88:	c4 55       	brlt	80005c12 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80005b8a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80005b8c:	ec 09 16 01 	lsr	r9,r6,0x1
80005b90:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80005b94:	ec 16 00 01 	eorl	r6,0x1
80005b98:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80005b9c:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80005ba0:	20 83       	sub	r3,8
80005ba2:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80005ba6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80005baa:	ef 39 00 09 	ld.ub	r9,r7[9]
80005bae:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80005bb2:	ef 39 00 0a 	ld.ub	r9,r7[10]
80005bb6:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
80005bba:	0f 89       	ld.ub	r9,r7[0x0]
80005bbc:	30 1a       	mov	r10,1
80005bbe:	f4 09 18 00 	cp.b	r9,r10
80005bc2:	c0 d0       	breq	80005bdc <spi_setupChipReg+0x98>
80005bc4:	c0 a3       	brcs	80005bd8 <spi_setupChipReg+0x94>
80005bc6:	30 2a       	mov	r10,2
80005bc8:	f4 09 18 00 	cp.b	r9,r10
80005bcc:	c0 a0       	breq	80005be0 <spi_setupChipReg+0x9c>
80005bce:	30 3a       	mov	r10,3
80005bd0:	f4 09 18 00 	cp.b	r9,r10
80005bd4:	c1 f1       	brne	80005c12 <spi_setupChipReg+0xce>
80005bd6:	c0 78       	rjmp	80005be4 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80005bd8:	8b c8       	st.w	r5[0x30],r8
		break;
80005bda:	c0 68       	rjmp	80005be6 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80005bdc:	8b d8       	st.w	r5[0x34],r8
		break;
80005bde:	c0 48       	rjmp	80005be6 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80005be0:	8b e8       	st.w	r5[0x38],r8
		break;
80005be2:	c0 28       	rjmp	80005be6 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80005be4:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
80005be6:	48 f8       	lddpc	r8,80005c20 <spi_setupChipReg+0xdc>
80005be8:	70 08       	ld.w	r8,r8[0x0]
80005bea:	58 08       	cp.w	r8,0
80005bec:	c1 61       	brne	80005c18 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
80005bee:	30 0b       	mov	r11,0
80005bf0:	30 1c       	mov	r12,1
80005bf2:	f0 1f 00 0d 	mcall	80005c24 <spi_setupChipReg+0xe0>
80005bf6:	48 b8       	lddpc	r8,80005c20 <spi_setupChipReg+0xdc>
80005bf8:	91 0c       	st.w	r8[0x0],r12
80005bfa:	58 0c       	cp.w	r12,0
80005bfc:	c0 a0       	breq	80005c10 <spi_setupChipReg+0xcc>
80005bfe:	30 09       	mov	r9,0
80005c00:	12 9a       	mov	r10,r9
80005c02:	12 9b       	mov	r11,r9
80005c04:	f0 1f 00 09 	mcall	80005c28 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
80005c08:	48 68       	lddpc	r8,80005c20 <spi_setupChipReg+0xdc>
80005c0a:	70 08       	ld.w	r8,r8[0x0]
80005c0c:	58 08       	cp.w	r8,0
80005c0e:	c0 51       	brne	80005c18 <spi_setupChipReg+0xd4>
80005c10:	c0 08       	rjmp	80005c10 <spi_setupChipReg+0xcc>
80005c12:	30 2c       	mov	r12,2
80005c14:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005c18:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005c1c:	80 00       	ld.sh	r0,r0[0x0]
80005c1e:	5a 7c       	cp.w	r12,-25
80005c20:	00 00       	add	r0,r0
80005c22:	54 14       	stdsp	sp[0x104],r4
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	67 68       	ld.w	r8,r3[0x58]
80005c28:	80 00       	ld.sh	r0,r0[0x0]
80005c2a:	66 10       	ld.w	r0,r3[0x4]

80005c2c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005c2c:	d4 01       	pushm	lr
80005c2e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005c32:	c0 58       	rjmp	80005c3c <spi_unselectChip+0x10>
		if (!timeout--) {
80005c34:	58 08       	cp.w	r8,0
80005c36:	c0 21       	brne	80005c3a <spi_unselectChip+0xe>
80005c38:	da 0a       	popm	pc,r12=1
80005c3a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80005c3c:	78 49       	ld.w	r9,r12[0x10]
80005c3e:	e2 19 02 00 	andl	r9,0x200,COH
80005c42:	cf 90       	breq	80005c34 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005c44:	78 18       	ld.w	r8,r12[0x4]
80005c46:	ea 18 00 0f 	orh	r8,0xf
80005c4a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80005c4c:	fc 18 01 00 	movh	r8,0x100
80005c50:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80005c52:	30 09       	mov	r9,0
80005c54:	12 9a       	mov	r10,r9
80005c56:	12 9b       	mov	r11,r9
80005c58:	48 38       	lddpc	r8,80005c64 <spi_unselectChip+0x38>
80005c5a:	70 0c       	ld.w	r12,r8[0x0]
80005c5c:	f0 1f 00 03 	mcall	80005c68 <spi_unselectChip+0x3c>
80005c60:	d8 0a       	popm	pc,r12=0
80005c62:	00 00       	add	r0,r0
80005c64:	00 00       	add	r0,r0
80005c66:	54 14       	stdsp	sp[0x104],r4
80005c68:	80 00       	ld.sh	r0,r0[0x0]
80005c6a:	66 10       	ld.w	r0,r3[0x4]

80005c6c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80005c6c:	eb cd 40 f8 	pushm	r3-r7,lr
80005c70:	18 94       	mov	r4,r12
80005c72:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80005c74:	49 a6       	lddpc	r6,80005cdc <spi_selectChip+0x70>
80005c76:	30 07       	mov	r7,0
80005c78:	31 45       	mov	r5,20
80005c7a:	0e 99       	mov	r9,r7
80005c7c:	0a 9a       	mov	r10,r5
80005c7e:	0e 9b       	mov	r11,r7
80005c80:	6c 0c       	ld.w	r12,r6[0x0]
80005c82:	f0 1f 00 18 	mcall	80005ce0 <spi_selectChip+0x74>
80005c86:	cf a0       	breq	80005c7a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80005c88:	68 18       	ld.w	r8,r4[0x4]
80005c8a:	ea 18 00 0f 	orh	r8,0xf
80005c8e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80005c90:	68 18       	ld.w	r8,r4[0x4]
80005c92:	e2 18 00 04 	andl	r8,0x4,COH
80005c96:	c1 10       	breq	80005cb8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80005c98:	30 e8       	mov	r8,14
80005c9a:	f0 03 18 00 	cp.b	r3,r8
80005c9e:	e0 8b 00 1c 	brhi	80005cd6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80005ca2:	68 19       	ld.w	r9,r4[0x4]
80005ca4:	e6 08 15 10 	lsl	r8,r3,0x10
80005ca8:	ea 18 ff f0 	orh	r8,0xfff0
80005cac:	e8 18 ff ff 	orl	r8,0xffff
80005cb0:	12 68       	and	r8,r9
80005cb2:	89 18       	st.w	r4[0x4],r8
80005cb4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80005cb8:	30 38       	mov	r8,3
80005cba:	f0 03 18 00 	cp.b	r3,r8
80005cbe:	e0 8b 00 0c 	brhi	80005cd6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80005cc2:	68 19       	ld.w	r9,r4[0x4]
80005cc4:	2f 03       	sub	r3,-16
80005cc6:	30 18       	mov	r8,1
80005cc8:	f0 03 09 48 	lsl	r8,r8,r3
80005ccc:	5c d8       	com	r8
80005cce:	12 68       	and	r8,r9
80005cd0:	89 18       	st.w	r4[0x4],r8
80005cd2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80005cd6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80005cd8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80005cdc:	00 00       	add	r0,r0
80005cde:	54 14       	stdsp	sp[0x104],r4
80005ce0:	80 00       	ld.sh	r0,r0[0x0]
80005ce2:	64 04       	ld.w	r4,r2[0x0]

80005ce4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80005ce4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80005ce6:	f6 08 15 04 	lsl	r8,r11,0x4
80005cea:	14 38       	cp.w	r8,r10
80005cec:	f9 b8 08 10 	movls	r8,16
80005cf0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80005cf4:	f0 0b 02 4b 	mul	r11,r8,r11
80005cf8:	f6 09 16 01 	lsr	r9,r11,0x1
80005cfc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80005d00:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80005d04:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80005d08:	f2 cb 00 01 	sub	r11,r9,1
80005d0c:	e0 4b ff fe 	cp.w	r11,65534
80005d10:	e0 88 00 03 	brls	80005d16 <usart_set_async_baudrate+0x32>
80005d14:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80005d16:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80005d18:	e8 6e 00 00 	mov	lr,524288
80005d1c:	59 08       	cp.w	r8,16
80005d1e:	fc 08 17 10 	movne	r8,lr
80005d22:	f9 b8 00 00 	moveq	r8,0
80005d26:	e4 1b ff f7 	andh	r11,0xfff7
80005d2a:	e0 1b fe cf 	andl	r11,0xfecf
80005d2e:	16 48       	or	r8,r11
80005d30:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80005d32:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80005d36:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80005d3a:	99 89       	st.w	r12[0x20],r9
80005d3c:	d8 0a       	popm	pc,r12=0

80005d3e <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80005d3e:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80005d40:	e2 18 00 02 	andl	r8,0x2,COH
80005d44:	c0 31       	brne	80005d4a <usart_write_char+0xc>
80005d46:	30 2c       	mov	r12,2
80005d48:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80005d4a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
80005d4e:	99 7b       	st.w	r12[0x1c],r11
80005d50:	5e fd       	retal	0
80005d52:	d7 03       	nop

80005d54 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80005d54:	eb cd 40 e0 	pushm	r5-r7,lr
80005d58:	18 96       	mov	r6,r12
80005d5a:	16 95       	mov	r5,r11
80005d5c:	e0 67 27 0f 	mov	r7,9999
80005d60:	c0 68       	rjmp	80005d6c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80005d62:	58 07       	cp.w	r7,0
80005d64:	c0 31       	brne	80005d6a <usart_putchar+0x16>
80005d66:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
80005d6a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80005d6c:	0a 9b       	mov	r11,r5
80005d6e:	0c 9c       	mov	r12,r6
80005d70:	f0 1f 00 03 	mcall	80005d7c <usart_putchar+0x28>
80005d74:	cf 71       	brne	80005d62 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80005d76:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005d7a:	00 00       	add	r0,r0
80005d7c:	80 00       	ld.sh	r0,r0[0x0]
80005d7e:	5d 3e       	musfr	lr

80005d80 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80005d80:	78 58       	ld.w	r8,r12[0x14]
80005d82:	e2 18 00 e0 	andl	r8,0xe0,COH
80005d86:	c0 30       	breq	80005d8c <usart_read_char+0xc>
80005d88:	30 4c       	mov	r12,4
80005d8a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80005d8c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80005d8e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005d92:	c0 31       	brne	80005d98 <usart_read_char+0x18>
80005d94:	30 3c       	mov	r12,3
80005d96:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80005d98:	78 68       	ld.w	r8,r12[0x18]
80005d9a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80005d9e:	97 08       	st.w	r11[0x0],r8
80005da0:	5e fd       	retal	0
80005da2:	d7 03       	nop

80005da4 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80005da4:	eb cd 40 c0 	pushm	r6-r7,lr
80005da8:	20 1d       	sub	sp,4
80005daa:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
80005dac:	1a 97       	mov	r7,sp
80005dae:	1a 9b       	mov	r11,sp
80005db0:	0c 9c       	mov	r12,r6
80005db2:	f0 1f 00 07 	mcall	80005dcc <usart_getchar+0x28>
80005db6:	58 3c       	cp.w	r12,3
80005db8:	cf b0       	breq	80005dae <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
80005dba:	58 4c       	cp.w	r12,4
80005dbc:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80005dc0:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80005dc4:	2f fd       	sub	sp,-4
80005dc6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005dca:	00 00       	add	r0,r0
80005dcc:	80 00       	ld.sh	r0,r0[0x0]
80005dce:	5d 80       	*unknown*

80005dd0 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80005dd0:	eb cd 40 c0 	pushm	r6-r7,lr
80005dd4:	18 96       	mov	r6,r12
80005dd6:	16 97       	mov	r7,r11
  while (*string != '\0')
80005dd8:	17 8b       	ld.ub	r11,r11[0x0]
80005dda:	58 0b       	cp.w	r11,0
80005ddc:	c0 80       	breq	80005dec <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
80005dde:	2f f7       	sub	r7,-1
80005de0:	0c 9c       	mov	r12,r6
80005de2:	f0 1f 00 04 	mcall	80005df0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80005de6:	0f 8b       	ld.ub	r11,r7[0x0]
80005de8:	58 0b       	cp.w	r11,0
80005dea:	cf a1       	brne	80005dde <usart_write_line+0xe>
80005dec:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005df0:	80 00       	ld.sh	r0,r0[0x0]
80005df2:	5d 54       	*unknown*

80005df4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80005df4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80005df8:	e6 18 00 01 	andh	r8,0x1,COH
80005dfc:	c0 71       	brne	80005e0a <usart_reset+0x16>
80005dfe:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80005e00:	3f f8       	mov	r8,-1
80005e02:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005e04:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80005e06:	d5 03       	csrf	0x10
80005e08:	c0 48       	rjmp	80005e10 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80005e0a:	3f f8       	mov	r8,-1
80005e0c:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80005e0e:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80005e10:	30 08       	mov	r8,0
80005e12:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80005e14:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80005e16:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80005e18:	ea 68 61 0c 	mov	r8,680204
80005e1c:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80005e1e:	5e fc       	retal	r12

80005e20 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80005e20:	eb cd 40 e0 	pushm	r5-r7,lr
80005e24:	18 96       	mov	r6,r12
80005e26:	16 97       	mov	r7,r11
80005e28:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80005e2a:	f0 1f 00 2f 	mcall	80005ee4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80005e2e:	58 07       	cp.w	r7,0
80005e30:	c5 80       	breq	80005ee0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80005e32:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005e34:	30 49       	mov	r9,4
80005e36:	f2 08 18 00 	cp.b	r8,r9
80005e3a:	e0 88 00 53 	brls	80005ee0 <usart_init_rs232+0xc0>
80005e3e:	30 99       	mov	r9,9
80005e40:	f2 08 18 00 	cp.b	r8,r9
80005e44:	e0 8b 00 4e 	brhi	80005ee0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80005e48:	0f d9       	ld.ub	r9,r7[0x5]
80005e4a:	30 78       	mov	r8,7
80005e4c:	f0 09 18 00 	cp.b	r9,r8
80005e50:	e0 8b 00 48 	brhi	80005ee0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80005e54:	8e 39       	ld.sh	r9,r7[0x6]
80005e56:	e0 68 01 01 	mov	r8,257
80005e5a:	f0 09 19 00 	cp.h	r9,r8
80005e5e:	e0 8b 00 41 	brhi	80005ee0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80005e62:	ef 39 00 08 	ld.ub	r9,r7[8]
80005e66:	30 38       	mov	r8,3
80005e68:	f0 09 18 00 	cp.b	r9,r8
80005e6c:	e0 8b 00 3a 	brhi	80005ee0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80005e70:	0a 9a       	mov	r10,r5
80005e72:	6e 0b       	ld.w	r11,r7[0x0]
80005e74:	0c 9c       	mov	r12,r6
80005e76:	f0 1f 00 1d 	mcall	80005ee8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80005e7a:	58 1c       	cp.w	r12,1
80005e7c:	c3 20       	breq	80005ee0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80005e7e:	0f c8       	ld.ub	r8,r7[0x4]
80005e80:	30 99       	mov	r9,9
80005e82:	f2 08 18 00 	cp.b	r8,r9
80005e86:	c0 51       	brne	80005e90 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80005e88:	6c 18       	ld.w	r8,r6[0x4]
80005e8a:	b1 b8       	sbr	r8,0x11
80005e8c:	8d 18       	st.w	r6[0x4],r8
80005e8e:	c0 68       	rjmp	80005e9a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80005e90:	6c 19       	ld.w	r9,r6[0x4]
80005e92:	20 58       	sub	r8,5
80005e94:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80005e98:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80005e9a:	6c 19       	ld.w	r9,r6[0x4]
80005e9c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80005ea0:	0f d8       	ld.ub	r8,r7[0x5]
80005ea2:	a9 78       	lsl	r8,0x9
80005ea4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80005ea8:	12 48       	or	r8,r9
80005eaa:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80005eac:	8e 38       	ld.sh	r8,r7[0x6]
80005eae:	30 29       	mov	r9,2
80005eb0:	f2 08 19 00 	cp.h	r8,r9
80005eb4:	e0 88 00 09 	brls	80005ec6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80005eb8:	6c 18       	ld.w	r8,r6[0x4]
80005eba:	ad b8       	sbr	r8,0xd
80005ebc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80005ebe:	8e b8       	ld.uh	r8,r7[0x6]
80005ec0:	20 28       	sub	r8,2
80005ec2:	8d a8       	st.w	r6[0x28],r8
80005ec4:	c0 68       	rjmp	80005ed0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80005ec6:	6c 19       	ld.w	r9,r6[0x4]
80005ec8:	5c 78       	castu.h	r8
80005eca:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80005ece:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80005ed0:	6c 18       	ld.w	r8,r6[0x4]
80005ed2:	e0 18 ff f0 	andl	r8,0xfff0
80005ed6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80005ed8:	35 08       	mov	r8,80
80005eda:	8d 08       	st.w	r6[0x0],r8
80005edc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80005ee0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	5d f4       	*unknown*
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	5c e4       	tnbz	r4

80005eec <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80005eec:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80005ef0:	fe c0 8e f0 	sub	r0,pc,-28944

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80005ef4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80005ef8:	d5 53       	csrf	0x15
  cp      r0, r1
80005efa:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80005efc:	e0 61 0a 50 	mov	r1,2640
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80005f00:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80005f02:	c0 62       	brcc	80005f0e <idata_load_loop_end>
  cp      r0, r1
80005f04:	48 92       	lddpc	r2,80005f28 <udata_clear_loop_end+0x4>

80005f06 <idata_load_loop>:
  brlo    idata_load_loop
80005f06:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80005f08:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80005f0a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80005f0c:	cf d3       	brcs	80005f06 <idata_load_loop>

80005f0e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80005f0e:	e0 60 0a 50 	mov	r0,2640
  mov     r2, 0
  mov     r3, 0
80005f12:	e0 61 54 28 	mov	r1,21544
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80005f16:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80005f18:	c0 62       	brcc	80005f24 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80005f1a:	30 02       	mov	r2,0
80005f1c:	30 03       	mov	r3,0

80005f1e <udata_clear_loop>:
80005f1e:	a1 22       	st.d	r0++,r2
80005f20:	02 30       	cp.w	r0,r1
80005f22:	cf e3       	brcs	80005f1e <udata_clear_loop>

80005f24 <udata_clear_loop_end>:
80005f24:	fe cf e8 f0 	sub	pc,pc,-5904
80005f28:	80 00       	ld.sh	r0,r0[0x0]
80005f2a:	e5 40 f8 c8 	st.w	r2[-1848],r0

80005f2c <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005f2c:	f8 c8 ff f8 	sub	r8,r12,-8
80005f30:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80005f32:	3f f9       	mov	r9,-1
80005f34:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80005f36:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005f38:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005f3a:	30 08       	mov	r8,0
80005f3c:	99 08       	st.w	r12[0x0],r8
}
80005f3e:	5e fc       	retal	r12

80005f40 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005f40:	30 08       	mov	r8,0
80005f42:	99 48       	st.w	r12[0x10],r8
}
80005f44:	5e fc       	retal	r12

80005f46 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80005f46:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005f48:	70 19       	ld.w	r9,r8[0x4]
80005f4a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005f4c:	78 19       	ld.w	r9,r12[0x4]
80005f4e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005f50:	70 19       	ld.w	r9,r8[0x4]
80005f52:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80005f54:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80005f56:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005f58:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005f5a:	78 08       	ld.w	r8,r12[0x0]
80005f5c:	2f f8       	sub	r8,-1
80005f5e:	99 08       	st.w	r12[0x0],r8
}
80005f60:	5e fc       	retal	r12

80005f62 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80005f62:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005f64:	5b fa       	cp.w	r10,-1
80005f66:	c0 31       	brne	80005f6c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005f68:	78 48       	ld.w	r8,r12[0x10]
80005f6a:	c0 c8       	rjmp	80005f82 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005f6c:	f8 c8 ff f8 	sub	r8,r12,-8
80005f70:	70 19       	ld.w	r9,r8[0x4]
80005f72:	72 09       	ld.w	r9,r9[0x0]
80005f74:	12 3a       	cp.w	r10,r9
80005f76:	c0 63       	brcs	80005f82 <vListInsert+0x20>
80005f78:	70 18       	ld.w	r8,r8[0x4]
80005f7a:	70 19       	ld.w	r9,r8[0x4]
80005f7c:	72 09       	ld.w	r9,r9[0x0]
80005f7e:	12 3a       	cp.w	r10,r9
80005f80:	cf c2       	brcc	80005f78 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80005f82:	70 19       	ld.w	r9,r8[0x4]
80005f84:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005f86:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005f88:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005f8a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005f8c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005f8e:	78 08       	ld.w	r8,r12[0x0]
80005f90:	2f f8       	sub	r8,-1
80005f92:	99 08       	st.w	r12[0x0],r8
}
80005f94:	5e fc       	retal	r12

80005f96 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005f96:	78 18       	ld.w	r8,r12[0x4]
80005f98:	78 29       	ld.w	r9,r12[0x8]
80005f9a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005f9c:	78 28       	ld.w	r8,r12[0x8]
80005f9e:	78 19       	ld.w	r9,r12[0x4]
80005fa0:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80005fa2:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005fa4:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005fa6:	18 39       	cp.w	r9,r12
80005fa8:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005fac:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80005fb0:	30 09       	mov	r9,0
80005fb2:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005fb4:	70 09       	ld.w	r9,r8[0x0]
80005fb6:	20 19       	sub	r9,1
80005fb8:	91 09       	st.w	r8[0x0],r9
}
80005fba:	5e fc       	retal	r12

80005fbc <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005fbc:	e0 68 08 08 	mov	r8,2056
80005fc0:	ea 18 08 08 	orh	r8,0x808
80005fc4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005fc6:	e0 68 09 09 	mov	r8,2313
80005fca:	ea 18 09 09 	orh	r8,0x909
80005fce:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80005fd0:	e0 68 0a 0a 	mov	r8,2570
80005fd4:	ea 18 0a 0a 	orh	r8,0xa0a
80005fd8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005fda:	e0 68 0b 0b 	mov	r8,2827
80005fde:	ea 18 0b 0b 	orh	r8,0xb0b
80005fe2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005fe4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005fe6:	e0 68 be ef 	mov	r8,48879
80005fea:	ea 18 de ad 	orh	r8,0xdead
80005fee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80005ff0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80005ff2:	fc 18 00 40 	movh	r8,0x40
80005ff6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005ff8:	e0 68 00 ff 	mov	r8,255
80005ffc:	ea 18 ff 00 	orh	r8,0xff00
80006000:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80006002:	e0 68 01 01 	mov	r8,257
80006006:	ea 18 01 01 	orh	r8,0x101
8000600a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
8000600c:	e0 68 02 02 	mov	r8,514
80006010:	ea 18 02 02 	orh	r8,0x202
80006014:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80006016:	e0 68 03 03 	mov	r8,771
8000601a:	ea 18 03 03 	orh	r8,0x303
8000601e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80006020:	e0 68 04 04 	mov	r8,1028
80006024:	ea 18 04 04 	orh	r8,0x404
80006028:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
8000602a:	e0 68 05 05 	mov	r8,1285
8000602e:	ea 18 05 05 	orh	r8,0x505
80006032:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80006034:	e0 68 06 06 	mov	r8,1542
80006038:	ea 18 06 06 	orh	r8,0x606
8000603c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000603e:	e0 68 07 07 	mov	r8,1799
80006042:	ea 18 07 07 	orh	r8,0x707
80006046:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80006048:	30 08       	mov	r8,0
8000604a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
8000604c:	5e fc       	retal	r12
8000604e:	d7 03       	nop

80006050 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80006050:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80006052:	48 38       	lddpc	r8,8000605c <vPortEnterCritical+0xc>
80006054:	70 09       	ld.w	r9,r8[0x0]
80006056:	2f f9       	sub	r9,-1
80006058:	91 09       	st.w	r8[0x0],r9
}
8000605a:	5e fc       	retal	r12
8000605c:	00 00       	add	r0,r0
8000605e:	05 40       	ld.w	r0,--r2

80006060 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80006060:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80006062:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80006064:	30 0a       	mov	r10,0
80006066:	14 9b       	mov	r11,r10
80006068:	49 2c       	lddpc	r12,800060b0 <xPortStartScheduler+0x50>
8000606a:	f0 1f 00 13 	mcall	800060b4 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
8000606e:	e0 68 5d c0 	mov	r8,24000
80006072:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80006076:	30 08       	mov	r8,0
80006078:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
8000607c:	e0 68 0d 50 	mov	r8,3408
80006080:	ea 18 00 00 	orh	r8,0x0
80006084:	70 00       	ld.w	r0,r8[0x0]
80006086:	60 0d       	ld.w	sp,r0[0x0]
80006088:	1b 00       	ld.w	r0,sp++
8000608a:	e0 68 05 40 	mov	r8,1344
8000608e:	ea 18 00 00 	orh	r8,0x0
80006092:	91 00       	st.w	r8[0x0],r0
80006094:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006098:	2f ed       	sub	sp,-8
8000609a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000609e:	fa f0 ff e0 	ld.w	r0,sp[-32]
800060a2:	e3 b0 00 00 	mtsr	0x0,r0
800060a6:	fa f0 ff dc 	ld.w	r0,sp[-36]
800060aa:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800060ae:	d8 0a       	popm	pc,r12=0
800060b0:	80 00       	ld.sh	r0,r0[0x0]
800060b2:	61 7c       	ld.w	r12,r0[0x5c]
800060b4:	80 00       	ld.sh	r0,r0[0x0]
800060b6:	59 70       	cp.w	r0,23

800060b8 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800060b8:	20 6d       	sub	sp,24
800060ba:	eb cd 00 ff 	pushm	r0-r7
800060be:	fa c7 ff c0 	sub	r7,sp,-64
800060c2:	ee f0 ff f8 	ld.w	r0,r7[-8]
800060c6:	ef 40 ff e0 	st.w	r7[-32],r0
800060ca:	ee f0 ff fc 	ld.w	r0,r7[-4]
800060ce:	ef 40 ff e4 	st.w	r7[-28],r0
800060d2:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800060d6:	e0 68 05 40 	mov	r8,1344
800060da:	ea 18 00 00 	orh	r8,0x0
800060de:	70 00       	ld.w	r0,r8[0x0]
800060e0:	1a d0       	st.w	--sp,r0
800060e2:	f0 1f 00 1a 	mcall	80006148 <LABEL_RET_SCALL_263+0x14>
800060e6:	e0 68 0d 50 	mov	r8,3408
800060ea:	ea 18 00 00 	orh	r8,0x0
800060ee:	70 00       	ld.w	r0,r8[0x0]
800060f0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800060f2:	f0 1f 00 17 	mcall	8000614c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
800060f6:	e0 68 0d 50 	mov	r8,3408
800060fa:	ea 18 00 00 	orh	r8,0x0
800060fe:	70 00       	ld.w	r0,r8[0x0]
80006100:	60 0d       	ld.w	sp,r0[0x0]
80006102:	1b 00       	ld.w	r0,sp++
80006104:	e0 68 05 40 	mov	r8,1344
80006108:	ea 18 00 00 	orh	r8,0x0
8000610c:	91 00       	st.w	r8[0x0],r0
8000610e:	fa c7 ff d8 	sub	r7,sp,-40
80006112:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80006116:	ee f0 ff e0 	ld.w	r0,r7[-32]
8000611a:	e0 61 05 40 	mov	r1,1344
8000611e:	ea 11 00 00 	orh	r1,0x0
80006122:	62 02       	ld.w	r2,r1[0x0]
80006124:	58 02       	cp.w	r2,0
80006126:	c0 70       	breq	80006134 <LABEL_RET_SCALL_263>
80006128:	e4 c2 00 01 	sub	r2,r2,1
8000612c:	83 02       	st.w	r1[0x0],r2
8000612e:	58 02       	cp.w	r2,0
80006130:	c0 21       	brne	80006134 <LABEL_RET_SCALL_263>
80006132:	b1 c0       	cbr	r0,0x10

80006134 <LABEL_RET_SCALL_263>:
80006134:	ef 40 ff f8 	st.w	r7[-8],r0
80006138:	ee f0 ff e4 	ld.w	r0,r7[-28]
8000613c:	ef 40 ff fc 	st.w	r7[-4],r0
80006140:	e3 cd 00 ff 	ldm	sp++,r0-r7
80006144:	2f ad       	sub	sp,-24
80006146:	d6 13       	rets
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	60 50       	ld.w	r0,r0[0x14]
8000614c:	80 00       	ld.sh	r0,r0[0x0]
8000614e:	67 ec       	ld.w	r12,r3[0x78]

80006150 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80006150:	e1 b8 00 43 	mfsr	r8,0x10c
80006154:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80006158:	5e fc       	retal	r12
8000615a:	d7 03       	nop

8000615c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
8000615c:	48 78       	lddpc	r8,80006178 <vPortExitCritical+0x1c>
8000615e:	70 08       	ld.w	r8,r8[0x0]
80006160:	58 08       	cp.w	r8,0
80006162:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80006164:	48 58       	lddpc	r8,80006178 <vPortExitCritical+0x1c>
80006166:	70 09       	ld.w	r9,r8[0x0]
80006168:	20 19       	sub	r9,1
8000616a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
8000616c:	70 08       	ld.w	r8,r8[0x0]
8000616e:	58 08       	cp.w	r8,0
80006170:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80006172:	d5 03       	csrf	0x10
80006174:	5e fc       	retal	r12
80006176:	00 00       	add	r0,r0
80006178:	00 00       	add	r0,r0
8000617a:	05 40       	ld.w	r0,--r2

8000617c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
8000617c:	eb cd 00 ff 	pushm	r0-r7
80006180:	e0 68 05 40 	mov	r8,1344
80006184:	ea 18 00 00 	orh	r8,0x0
80006188:	70 00       	ld.w	r0,r8[0x0]
8000618a:	1a d0       	st.w	--sp,r0
8000618c:	7a 90       	ld.w	r0,sp[0x24]
8000618e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80006192:	58 10       	cp.w	r0,1
80006194:	e0 8b 00 08 	brhi	800061a4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80006198:	e0 68 0d 50 	mov	r8,3408
8000619c:	ea 18 00 00 	orh	r8,0x0
800061a0:	70 00       	ld.w	r0,r8[0x0]
800061a2:	81 0d       	st.w	r0[0x0],sp

800061a4 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
800061a4:	f0 1f 00 12 	mcall	800061ec <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800061a8:	f0 1f 00 12 	mcall	800061f0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
800061ac:	f0 1f 00 12 	mcall	800061f4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
800061b0:	f0 1f 00 12 	mcall	800061f8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800061b4:	7a 90       	ld.w	r0,sp[0x24]
800061b6:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800061ba:	58 10       	cp.w	r0,1
800061bc:	e0 8b 00 0e 	brhi	800061d8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
800061c0:	f0 1f 00 0c 	mcall	800061f0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
800061c4:	f0 1f 00 0e 	mcall	800061fc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
800061c8:	f0 1f 00 0c 	mcall	800061f8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
800061cc:	e0 68 0d 50 	mov	r8,3408
800061d0:	ea 18 00 00 	orh	r8,0x0
800061d4:	70 00       	ld.w	r0,r8[0x0]
800061d6:	60 0d       	ld.w	sp,r0[0x0]

800061d8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
800061d8:	1b 00       	ld.w	r0,sp++
800061da:	e0 68 05 40 	mov	r8,1344
800061de:	ea 18 00 00 	orh	r8,0x0
800061e2:	91 00       	st.w	r8[0x0],r0
800061e4:	e3 cd 00 ff 	ldm	sp++,r0-r7
800061e8:	d6 03       	rete
800061ea:	00 00       	add	r0,r0
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	61 50       	ld.w	r0,r0[0x54]
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	60 50       	ld.w	r0,r0[0x14]
800061f4:	80 00       	ld.sh	r0,r0[0x0]
800061f6:	6a 28       	ld.w	r8,r5[0x8]
800061f8:	80 00       	ld.sh	r0,r0[0x0]
800061fa:	61 5c       	ld.w	r12,r0[0x54]
800061fc:	80 00       	ld.sh	r0,r0[0x0]
800061fe:	67 ec       	ld.w	r12,r3[0x78]

80006200 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80006200:	d4 01       	pushm	lr
	vTaskSuspendAll();
80006202:	f0 1f 00 02 	mcall	80006208 <__malloc_lock+0x8>
}
80006206:	d8 02       	popm	pc
80006208:	80 00       	ld.sh	r0,r0[0x0]
8000620a:	67 dc       	ld.w	r12,r3[0x74]

8000620c <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
8000620c:	d4 01       	pushm	lr
	xTaskResumeAll();
8000620e:	f0 1f 00 02 	mcall	80006214 <__malloc_unlock+0x8>
}
80006212:	d8 02       	popm	pc
80006214:	80 00       	ld.sh	r0,r0[0x0]
80006216:	6b d0       	ld.w	r0,r5[0x74]

80006218 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80006218:	d4 21       	pushm	r4-r7,lr
8000621a:	16 95       	mov	r5,r11
8000621c:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
8000621e:	58 0c       	cp.w	r12,0
80006220:	c0 30       	breq	80006226 <_read+0xe>
80006222:	3f f7       	mov	r7,-1
80006224:	c1 48       	rjmp	8000624c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80006226:	58 0a       	cp.w	r10,0
80006228:	e0 89 00 04 	brgt	80006230 <_read+0x18>
8000622c:	30 07       	mov	r7,0
8000622e:	c0 f8       	rjmp	8000624c <_read+0x34>
80006230:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80006232:	48 84       	lddpc	r4,80006250 <_read+0x38>
80006234:	68 0c       	ld.w	r12,r4[0x0]
80006236:	f0 1f 00 08 	mcall	80006254 <_read+0x3c>
    if (c < 0)
8000623a:	c0 95       	brlt	8000624c <_read+0x34>
      break;

    *ptr++ = c;
8000623c:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80006240:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80006242:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80006246:	58 08       	cp.w	r8,0
80006248:	fe 99 ff f6 	brgt	80006234 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
8000624c:	0e 9c       	mov	r12,r7
8000624e:	d8 22       	popm	r4-r7,pc
80006250:	00 00       	add	r0,r0
80006252:	54 18       	stdsp	sp[0x104],r8
80006254:	80 00       	ld.sh	r0,r0[0x0]
80006256:	5d a4       	*unknown*

80006258 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80006258:	d4 21       	pushm	r4-r7,lr
8000625a:	16 95       	mov	r5,r11
8000625c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
8000625e:	20 1c       	sub	r12,1
80006260:	58 2c       	cp.w	r12,2
80006262:	e0 8b 00 12 	brhi	80006286 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006266:	58 0a       	cp.w	r10,0
80006268:	c0 31       	brne	8000626e <_write+0x16>
8000626a:	30 07       	mov	r7,0
8000626c:	c0 e8       	rjmp	80006288 <_write+0x30>
8000626e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80006270:	48 74       	lddpc	r4,8000628c <_write+0x34>
80006272:	68 0c       	ld.w	r12,r4[0x0]
80006274:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80006278:	f0 1f 00 06 	mcall	80006290 <_write+0x38>
8000627c:	c0 55       	brlt	80006286 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
8000627e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80006280:	0e 36       	cp.w	r6,r7
80006282:	cf 81       	brne	80006272 <_write+0x1a>
80006284:	c0 28       	rjmp	80006288 <_write+0x30>
80006286:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80006288:	0e 9c       	mov	r12,r7
8000628a:	d8 22       	popm	r4-r7,pc
8000628c:	00 00       	add	r0,r0
8000628e:	54 18       	stdsp	sp[0x104],r8
80006290:	80 00       	ld.sh	r0,r0[0x0]
80006292:	5d 54       	*unknown*

80006294 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80006294:	eb cd 40 80 	pushm	r7,lr
80006298:	18 97       	mov	r7,r12
	if( pv )
8000629a:	58 0c       	cp.w	r12,0
8000629c:	c0 80       	breq	800062ac <vPortFree+0x18>
	{
		vTaskSuspendAll();
8000629e:	f0 1f 00 05 	mcall	800062b0 <vPortFree+0x1c>
		{
			free( pv );
800062a2:	0e 9c       	mov	r12,r7
800062a4:	f0 1f 00 04 	mcall	800062b4 <vPortFree+0x20>
		}
		xTaskResumeAll();
800062a8:	f0 1f 00 04 	mcall	800062b8 <vPortFree+0x24>
800062ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800062b0:	80 00       	ld.sh	r0,r0[0x0]
800062b2:	67 dc       	ld.w	r12,r3[0x74]
800062b4:	80 00       	ld.sh	r0,r0[0x0]
800062b6:	76 a4       	ld.w	r4,r11[0x28]
800062b8:	80 00       	ld.sh	r0,r0[0x0]
800062ba:	6b d0       	ld.w	r0,r5[0x74]

800062bc <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800062bc:	eb cd 40 80 	pushm	r7,lr
800062c0:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800062c2:	f0 1f 00 06 	mcall	800062d8 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800062c6:	0e 9c       	mov	r12,r7
800062c8:	f0 1f 00 05 	mcall	800062dc <pvPortMalloc+0x20>
800062cc:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
800062ce:	f0 1f 00 05 	mcall	800062e0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
800062d2:	0e 9c       	mov	r12,r7
800062d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	67 dc       	ld.w	r12,r3[0x74]
800062dc:	80 00       	ld.sh	r0,r0[0x0]
800062de:	76 b4       	ld.w	r4,r11[0x2c]
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	6b d0       	ld.w	r0,r5[0x74]

800062e4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
800062e4:	d4 01       	pushm	lr
800062e6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
800062e8:	78 09       	ld.w	r9,r12[0x0]
800062ea:	58 09       	cp.w	r9,0
800062ec:	c1 10       	breq	8000630e <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
800062ee:	78 3a       	ld.w	r10,r12[0xc]
800062f0:	79 09       	ld.w	r9,r12[0x40]
800062f2:	f4 09 00 09 	add	r9,r10,r9
800062f6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
800062f8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
800062fa:	14 39       	cp.w	r9,r10
800062fc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80006300:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80006304:	79 0a       	ld.w	r10,r12[0x40]
80006306:	78 3b       	ld.w	r11,r12[0xc]
80006308:	10 9c       	mov	r12,r8
8000630a:	f0 1f 00 02 	mcall	80006310 <prvCopyDataFromQueue+0x2c>
8000630e:	d8 02       	popm	pc
80006310:	80 00       	ld.sh	r0,r0[0x0]
80006312:	7b 22       	ld.w	r2,sp[0x48]

80006314 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
80006314:	eb cd 40 c0 	pushm	r6-r7,lr
80006318:	18 97       	mov	r7,r12
8000631a:	14 96       	mov	r6,r10
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
8000631c:	78 e8       	ld.w	r8,r12[0x38]
8000631e:	58 08       	cp.w	r8,0
80006320:	c0 31       	brne	80006326 <xQueueReceiveFromISR+0x12>
80006322:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
80006326:	f0 1f 00 0e 	mcall	8000635c <xQueueReceiveFromISR+0x48>
			--( pxQueue->uxMessagesWaiting );
8000632a:	6e e8       	ld.w	r8,r7[0x38]
8000632c:	20 18       	sub	r8,1
8000632e:	8f e8       	st.w	r7[0x38],r8

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
80006330:	6f 18       	ld.w	r8,r7[0x44]
80006332:	5b f8       	cp.w	r8,-1
80006334:	c0 d1       	brne	8000634e <xQueueReceiveFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80006336:	6e 48       	ld.w	r8,r7[0x10]
80006338:	58 08       	cp.w	r8,0
8000633a:	c0 f0       	breq	80006358 <xQueueReceiveFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8000633c:	ee cc ff f0 	sub	r12,r7,-16
80006340:	f0 1f 00 08 	mcall	80006360 <xQueueReceiveFromISR+0x4c>
80006344:	c0 a0       	breq	80006358 <xQueueReceiveFromISR+0x44>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
80006346:	30 1c       	mov	r12,1
80006348:	8d 0c       	st.w	r6[0x0],r12
8000634a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
8000634e:	2f f8       	sub	r8,-1
80006350:	ef 48 00 44 	st.w	r7[68],r8
80006354:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006358:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	62 e4       	ld.w	r4,r1[0x38]
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	69 ac       	ld.w	r12,r4[0x68]

80006364 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80006364:	eb cd 40 c0 	pushm	r6-r7,lr
80006368:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8000636a:	f0 1f 00 23 	mcall	800063f4 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000636e:	6f 28       	ld.w	r8,r7[0x48]
80006370:	58 08       	cp.w	r8,0
80006372:	e0 8a 00 18 	brle	800063a2 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006376:	6e 98       	ld.w	r8,r7[0x24]
80006378:	58 08       	cp.w	r8,0
8000637a:	c1 40       	breq	800063a2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000637c:	ee c6 ff dc 	sub	r6,r7,-36
80006380:	c0 48       	rjmp	80006388 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006382:	6e 98       	ld.w	r8,r7[0x24]
80006384:	58 08       	cp.w	r8,0
80006386:	c0 e0       	breq	800063a2 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80006388:	0c 9c       	mov	r12,r6
8000638a:	f0 1f 00 1c 	mcall	800063f8 <prvUnlockQueue+0x94>
8000638e:	c0 30       	breq	80006394 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80006390:	f0 1f 00 1b 	mcall	800063fc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80006394:	6f 28       	ld.w	r8,r7[0x48]
80006396:	20 18       	sub	r8,1
80006398:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
8000639c:	58 08       	cp.w	r8,0
8000639e:	fe 99 ff f2 	brgt	80006382 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
800063a2:	3f f8       	mov	r8,-1
800063a4:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
800063a8:	f0 1f 00 16 	mcall	80006400 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
800063ac:	f0 1f 00 12 	mcall	800063f4 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800063b0:	6f 18       	ld.w	r8,r7[0x44]
800063b2:	58 08       	cp.w	r8,0
800063b4:	e0 8a 00 18 	brle	800063e4 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800063b8:	6e 48       	ld.w	r8,r7[0x10]
800063ba:	58 08       	cp.w	r8,0
800063bc:	c1 40       	breq	800063e4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800063be:	ee c6 ff f0 	sub	r6,r7,-16
800063c2:	c0 48       	rjmp	800063ca <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800063c4:	6e 48       	ld.w	r8,r7[0x10]
800063c6:	58 08       	cp.w	r8,0
800063c8:	c0 e0       	breq	800063e4 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800063ca:	0c 9c       	mov	r12,r6
800063cc:	f0 1f 00 0b 	mcall	800063f8 <prvUnlockQueue+0x94>
800063d0:	c0 30       	breq	800063d6 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800063d2:	f0 1f 00 0b 	mcall	800063fc <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800063d6:	6f 18       	ld.w	r8,r7[0x44]
800063d8:	20 18       	sub	r8,1
800063da:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800063de:	58 08       	cp.w	r8,0
800063e0:	fe 99 ff f2 	brgt	800063c4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800063e4:	3f f8       	mov	r8,-1
800063e6:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800063ea:	f0 1f 00 06 	mcall	80006400 <prvUnlockQueue+0x9c>
}
800063ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800063f2:	00 00       	add	r0,r0
800063f4:	80 00       	ld.sh	r0,r0[0x0]
800063f6:	60 50       	ld.w	r0,r0[0x14]
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	69 ac       	ld.w	r12,r4[0x68]
800063fc:	80 00       	ld.sh	r0,r0[0x0]
800063fe:	68 80       	ld.w	r0,r4[0x20]
80006400:	80 00       	ld.sh	r0,r0[0x0]
80006402:	61 5c       	ld.w	r12,r0[0x54]

80006404 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80006404:	d4 31       	pushm	r0-r7,lr
80006406:	20 5d       	sub	sp,20
80006408:	18 97       	mov	r7,r12
8000640a:	50 0b       	stdsp	sp[0x0],r11
8000640c:	50 2a       	stdsp	sp[0x8],r10
8000640e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80006410:	f8 c2 ff dc 	sub	r2,r12,-36
80006414:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006416:	fa c4 ff f4 	sub	r4,sp,-12
8000641a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
8000641c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000641e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80006422:	f0 1f 00 3e 	mcall	80006518 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80006426:	6e e8       	ld.w	r8,r7[0x38]
80006428:	58 08       	cp.w	r8,0
8000642a:	c2 a0       	breq	8000647e <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
8000642c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
8000642e:	40 0b       	lddsp	r11,sp[0x0]
80006430:	0e 9c       	mov	r12,r7
80006432:	f0 1f 00 3b 	mcall	8000651c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80006436:	40 18       	lddsp	r8,sp[0x4]
80006438:	58 08       	cp.w	r8,0
8000643a:	c1 51       	brne	80006464 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
8000643c:	6e e8       	ld.w	r8,r7[0x38]
8000643e:	20 18       	sub	r8,1
80006440:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006442:	6e 08       	ld.w	r8,r7[0x0]
80006444:	58 08       	cp.w	r8,0
80006446:	c0 41       	brne	8000644e <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80006448:	f0 1f 00 36 	mcall	80006520 <xQueueGenericReceive+0x11c>
8000644c:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8000644e:	6e 48       	ld.w	r8,r7[0x10]
80006450:	58 08       	cp.w	r8,0
80006452:	c1 20       	breq	80006476 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80006454:	ee cc ff f0 	sub	r12,r7,-16
80006458:	f0 1f 00 33 	mcall	80006524 <xQueueGenericReceive+0x120>
8000645c:	58 1c       	cp.w	r12,1
8000645e:	c0 c1       	brne	80006476 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80006460:	d7 33       	scall
80006462:	c0 a8       	rjmp	80006476 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80006464:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006466:	6e 98       	ld.w	r8,r7[0x24]
80006468:	58 08       	cp.w	r8,0
8000646a:	c0 60       	breq	80006476 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8000646c:	04 9c       	mov	r12,r2
8000646e:	f0 1f 00 2e 	mcall	80006524 <xQueueGenericReceive+0x120>
80006472:	c0 20       	breq	80006476 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80006474:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80006476:	f0 1f 00 2d 	mcall	80006528 <xQueueGenericReceive+0x124>
8000647a:	30 1c       	mov	r12,1
				return pdPASS;
8000647c:	c4 c8       	rjmp	80006514 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000647e:	40 28       	lddsp	r8,sp[0x8]
80006480:	58 08       	cp.w	r8,0
80006482:	c0 51       	brne	8000648c <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006484:	f0 1f 00 29 	mcall	80006528 <xQueueGenericReceive+0x124>
80006488:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
8000648a:	c4 58       	rjmp	80006514 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
8000648c:	58 05       	cp.w	r5,0
8000648e:	c0 51       	brne	80006498 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006490:	08 9c       	mov	r12,r4
80006492:	f0 1f 00 27 	mcall	8000652c <xQueueGenericReceive+0x128>
80006496:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006498:	f0 1f 00 24 	mcall	80006528 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000649c:	f0 1f 00 25 	mcall	80006530 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
800064a0:	f0 1f 00 1e 	mcall	80006518 <xQueueGenericReceive+0x114>
800064a4:	6f 18       	ld.w	r8,r7[0x44]
800064a6:	5b f8       	cp.w	r8,-1
800064a8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800064ac:	6f 28       	ld.w	r8,r7[0x48]
800064ae:	5b f8       	cp.w	r8,-1
800064b0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800064b4:	f0 1f 00 1d 	mcall	80006528 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800064b8:	06 9b       	mov	r11,r3
800064ba:	08 9c       	mov	r12,r4
800064bc:	f0 1f 00 1e 	mcall	80006534 <xQueueGenericReceive+0x130>
800064c0:	c2 41       	brne	80006508 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800064c2:	f0 1f 00 16 	mcall	80006518 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
800064c6:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
800064c8:	f0 1f 00 18 	mcall	80006528 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
800064cc:	58 06       	cp.w	r6,0
800064ce:	c1 71       	brne	800064fc <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800064d0:	6e 08       	ld.w	r8,r7[0x0]
800064d2:	58 08       	cp.w	r8,0
800064d4:	c0 81       	brne	800064e4 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
800064d6:	f0 1f 00 11 	mcall	80006518 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
800064da:	6e 1c       	ld.w	r12,r7[0x4]
800064dc:	f0 1f 00 17 	mcall	80006538 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
800064e0:	f0 1f 00 12 	mcall	80006528 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800064e4:	40 2b       	lddsp	r11,sp[0x8]
800064e6:	04 9c       	mov	r12,r2
800064e8:	f0 1f 00 15 	mcall	8000653c <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
800064ec:	0e 9c       	mov	r12,r7
800064ee:	f0 1f 00 15 	mcall	80006540 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
800064f2:	f0 1f 00 15 	mcall	80006544 <xQueueGenericReceive+0x140>
800064f6:	c9 61       	brne	80006422 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
800064f8:	d7 33       	scall
800064fa:	c9 4b       	rjmp	80006422 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800064fc:	0e 9c       	mov	r12,r7
800064fe:	f0 1f 00 11 	mcall	80006540 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80006502:	f0 1f 00 11 	mcall	80006544 <xQueueGenericReceive+0x140>
80006506:	c8 eb       	rjmp	80006422 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80006508:	0e 9c       	mov	r12,r7
8000650a:	f0 1f 00 0e 	mcall	80006540 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000650e:	f0 1f 00 0e 	mcall	80006544 <xQueueGenericReceive+0x140>
80006512:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80006514:	2f bd       	sub	sp,-20
80006516:	d8 32       	popm	r0-r7,pc
80006518:	80 00       	ld.sh	r0,r0[0x0]
8000651a:	60 50       	ld.w	r0,r0[0x14]
8000651c:	80 00       	ld.sh	r0,r0[0x0]
8000651e:	62 e4       	ld.w	r4,r1[0x38]
80006520:	80 00       	ld.sh	r0,r0[0x0]
80006522:	68 c4       	ld.w	r4,r4[0x30]
80006524:	80 00       	ld.sh	r0,r0[0x0]
80006526:	69 ac       	ld.w	r12,r4[0x68]
80006528:	80 00       	ld.sh	r0,r0[0x0]
8000652a:	61 5c       	ld.w	r12,r0[0x54]
8000652c:	80 00       	ld.sh	r0,r0[0x0]
8000652e:	68 68       	ld.w	r8,r4[0x18]
80006530:	80 00       	ld.sh	r0,r0[0x0]
80006532:	67 dc       	ld.w	r12,r3[0x74]
80006534:	80 00       	ld.sh	r0,r0[0x0]
80006536:	6b 3c       	ld.w	r12,r5[0x4c]
80006538:	80 00       	ld.sh	r0,r0[0x0]
8000653a:	69 28       	ld.w	r8,r4[0x48]
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	6d dc       	ld.w	r12,r6[0x74]
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	63 64       	ld.w	r4,r1[0x58]
80006544:	80 00       	ld.sh	r0,r0[0x0]
80006546:	6b d0       	ld.w	r0,r5[0x74]

80006548 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80006548:	eb cd 40 80 	pushm	r7,lr
8000654c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000654e:	79 08       	ld.w	r8,r12[0x40]
80006550:	58 08       	cp.w	r8,0
80006552:	c0 a1       	brne	80006566 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80006554:	78 08       	ld.w	r8,r12[0x0]
80006556:	58 08       	cp.w	r8,0
80006558:	c2 b1       	brne	800065ae <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000655a:	78 1c       	ld.w	r12,r12[0x4]
8000655c:	f0 1f 00 17 	mcall	800065b8 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
80006560:	30 08       	mov	r8,0
80006562:	8f 18       	st.w	r7[0x4],r8
80006564:	c2 58       	rjmp	800065ae <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80006566:	58 0a       	cp.w	r10,0
80006568:	c1 01       	brne	80006588 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000656a:	10 9a       	mov	r10,r8
8000656c:	78 2c       	ld.w	r12,r12[0x8]
8000656e:	f0 1f 00 14 	mcall	800065bc <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80006572:	6e 29       	ld.w	r9,r7[0x8]
80006574:	6f 08       	ld.w	r8,r7[0x40]
80006576:	f2 08 00 08 	add	r8,r9,r8
8000657a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000657c:	6e 19       	ld.w	r9,r7[0x4]
8000657e:	12 38       	cp.w	r8,r9
80006580:	c1 73       	brcs	800065ae <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80006582:	6e 08       	ld.w	r8,r7[0x0]
80006584:	8f 28       	st.w	r7[0x8],r8
80006586:	c1 48       	rjmp	800065ae <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80006588:	10 9a       	mov	r10,r8
8000658a:	78 3c       	ld.w	r12,r12[0xc]
8000658c:	f0 1f 00 0c 	mcall	800065bc <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80006590:	6f 08       	ld.w	r8,r7[0x40]
80006592:	6e 39       	ld.w	r9,r7[0xc]
80006594:	f2 08 01 08 	sub	r8,r9,r8
80006598:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000659a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000659c:	12 38       	cp.w	r8,r9
8000659e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
800065a2:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
800065a6:	f3 d8 e3 19 	subcs	r9,r9,r8
800065aa:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
800065ae:	6e e8       	ld.w	r8,r7[0x38]
800065b0:	2f f8       	sub	r8,-1
800065b2:	8f e8       	st.w	r7[0x38],r8
}
800065b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800065b8:	80 00       	ld.sh	r0,r0[0x0]
800065ba:	68 d0       	ld.w	r0,r4[0x34]
800065bc:	80 00       	ld.sh	r0,r0[0x0]
800065be:	7b 22       	ld.w	r2,sp[0x48]

800065c0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800065c0:	eb cd 40 c0 	pushm	r6-r7,lr
800065c4:	18 97       	mov	r7,r12
800065c6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800065c8:	78 ec       	ld.w	r12,r12[0x38]
800065ca:	6e f8       	ld.w	r8,r7[0x3c]
800065cc:	10 3c       	cp.w	r12,r8
800065ce:	c0 33       	brcs	800065d4 <xQueueGenericSendFromISR+0x14>
800065d0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800065d4:	12 9a       	mov	r10,r9
800065d6:	0e 9c       	mov	r12,r7
800065d8:	f0 1f 00 0c 	mcall	80006608 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800065dc:	6f 28       	ld.w	r8,r7[0x48]
800065de:	5b f8       	cp.w	r8,-1
800065e0:	c0 d1       	brne	800065fa <xQueueGenericSendFromISR+0x3a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800065e2:	6e 98       	ld.w	r8,r7[0x24]
800065e4:	58 08       	cp.w	r8,0
800065e6:	c0 f0       	breq	80006604 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800065e8:	ee cc ff dc 	sub	r12,r7,-36
800065ec:	f0 1f 00 08 	mcall	8000660c <xQueueGenericSendFromISR+0x4c>
800065f0:	c0 a0       	breq	80006604 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800065f2:	30 1c       	mov	r12,1
800065f4:	8d 0c       	st.w	r6[0x0],r12
800065f6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800065fa:	2f f8       	sub	r8,-1
800065fc:	ef 48 00 48 	st.w	r7[72],r8
80006600:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006604:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80006608:	80 00       	ld.sh	r0,r0[0x0]
8000660a:	65 48       	ld.w	r8,r2[0x50]
8000660c:	80 00       	ld.sh	r0,r0[0x0]
8000660e:	69 ac       	ld.w	r12,r4[0x68]

80006610 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80006610:	d4 31       	pushm	r0-r7,lr
80006612:	20 5d       	sub	sp,20
80006614:	18 97       	mov	r7,r12
80006616:	50 0b       	stdsp	sp[0x0],r11
80006618:	50 2a       	stdsp	sp[0x8],r10
8000661a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000661c:	f8 c0 ff f0 	sub	r0,r12,-16
80006620:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006622:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80006626:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006628:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000662c:	f0 1f 00 2f 	mcall	800066e8 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80006630:	6e e9       	ld.w	r9,r7[0x38]
80006632:	6e f8       	ld.w	r8,r7[0x3c]
80006634:	10 39       	cp.w	r9,r8
80006636:	c1 42       	brcc	8000665e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80006638:	40 1a       	lddsp	r10,sp[0x4]
8000663a:	40 0b       	lddsp	r11,sp[0x0]
8000663c:	0e 9c       	mov	r12,r7
8000663e:	f0 1f 00 2c 	mcall	800066ec <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80006642:	6e 98       	ld.w	r8,r7[0x24]
80006644:	58 08       	cp.w	r8,0
80006646:	c0 80       	breq	80006656 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80006648:	ee cc ff dc 	sub	r12,r7,-36
8000664c:	f0 1f 00 29 	mcall	800066f0 <xQueueGenericSend+0xe0>
80006650:	58 1c       	cp.w	r12,1
80006652:	c0 21       	brne	80006656 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80006654:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80006656:	f0 1f 00 28 	mcall	800066f4 <xQueueGenericSend+0xe4>
8000665a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000665c:	c4 38       	rjmp	800066e2 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000665e:	40 28       	lddsp	r8,sp[0x8]
80006660:	58 08       	cp.w	r8,0
80006662:	c0 51       	brne	8000666c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80006664:	f0 1f 00 24 	mcall	800066f4 <xQueueGenericSend+0xe4>
80006668:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000666a:	c3 c8       	rjmp	800066e2 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000666c:	58 04       	cp.w	r4,0
8000666e:	c0 51       	brne	80006678 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80006670:	06 9c       	mov	r12,r3
80006672:	f0 1f 00 22 	mcall	800066f8 <xQueueGenericSend+0xe8>
80006676:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80006678:	f0 1f 00 1f 	mcall	800066f4 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000667c:	f0 1f 00 20 	mcall	800066fc <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
80006680:	f0 1f 00 1a 	mcall	800066e8 <xQueueGenericSend+0xd8>
80006684:	6f 18       	ld.w	r8,r7[0x44]
80006686:	5b f8       	cp.w	r8,-1
80006688:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000668c:	6f 28       	ld.w	r8,r7[0x48]
8000668e:	5b f8       	cp.w	r8,-1
80006690:	ef f1 0a 12 	st.weq	r7[0x48],r1
80006694:	f0 1f 00 18 	mcall	800066f4 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80006698:	04 9b       	mov	r11,r2
8000669a:	06 9c       	mov	r12,r3
8000669c:	f0 1f 00 19 	mcall	80006700 <xQueueGenericSend+0xf0>
800066a0:	c1 b1       	brne	800066d6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800066a2:	f0 1f 00 12 	mcall	800066e8 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800066a6:	6e e5       	ld.w	r5,r7[0x38]
800066a8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800066aa:	f0 1f 00 13 	mcall	800066f4 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800066ae:	0c 35       	cp.w	r5,r6
800066b0:	c0 d1       	brne	800066ca <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800066b2:	40 2b       	lddsp	r11,sp[0x8]
800066b4:	00 9c       	mov	r12,r0
800066b6:	f0 1f 00 14 	mcall	80006704 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800066ba:	0e 9c       	mov	r12,r7
800066bc:	f0 1f 00 13 	mcall	80006708 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800066c0:	f0 1f 00 13 	mcall	8000670c <xQueueGenericSend+0xfc>
800066c4:	cb 41       	brne	8000662c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800066c6:	d7 33       	scall
800066c8:	cb 2b       	rjmp	8000662c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800066ca:	0e 9c       	mov	r12,r7
800066cc:	f0 1f 00 0f 	mcall	80006708 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800066d0:	f0 1f 00 0f 	mcall	8000670c <xQueueGenericSend+0xfc>
800066d4:	ca cb       	rjmp	8000662c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800066d6:	0e 9c       	mov	r12,r7
800066d8:	f0 1f 00 0c 	mcall	80006708 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800066dc:	f0 1f 00 0c 	mcall	8000670c <xQueueGenericSend+0xfc>
800066e0:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
800066e2:	2f bd       	sub	sp,-20
800066e4:	d8 32       	popm	r0-r7,pc
800066e6:	00 00       	add	r0,r0
800066e8:	80 00       	ld.sh	r0,r0[0x0]
800066ea:	60 50       	ld.w	r0,r0[0x14]
800066ec:	80 00       	ld.sh	r0,r0[0x0]
800066ee:	65 48       	ld.w	r8,r2[0x50]
800066f0:	80 00       	ld.sh	r0,r0[0x0]
800066f2:	69 ac       	ld.w	r12,r4[0x68]
800066f4:	80 00       	ld.sh	r0,r0[0x0]
800066f6:	61 5c       	ld.w	r12,r0[0x54]
800066f8:	80 00       	ld.sh	r0,r0[0x0]
800066fa:	68 68       	ld.w	r8,r4[0x18]
800066fc:	80 00       	ld.sh	r0,r0[0x0]
800066fe:	67 dc       	ld.w	r12,r3[0x74]
80006700:	80 00       	ld.sh	r0,r0[0x0]
80006702:	6b 3c       	ld.w	r12,r5[0x4c]
80006704:	80 00       	ld.sh	r0,r0[0x0]
80006706:	6d dc       	ld.w	r12,r6[0x74]
80006708:	80 00       	ld.sh	r0,r0[0x0]
8000670a:	63 64       	ld.w	r4,r1[0x58]
8000670c:	80 00       	ld.sh	r0,r0[0x0]
8000670e:	6b d0       	ld.w	r0,r5[0x74]

80006710 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80006710:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006714:	34 cc       	mov	r12,76
80006716:	f0 1f 00 12 	mcall	8000675c <xQueueCreateMutex+0x4c>
8000671a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000671c:	c1 d0       	breq	80006756 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000671e:	30 06       	mov	r6,0
80006720:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80006722:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80006724:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80006726:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006728:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000672a:	30 18       	mov	r8,1
8000672c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000672e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80006732:	3f f8       	mov	r8,-1
80006734:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80006738:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000673c:	2f 0c       	sub	r12,-16
8000673e:	f0 1f 00 09 	mcall	80006760 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80006742:	ee cc ff dc 	sub	r12,r7,-36
80006746:	f0 1f 00 07 	mcall	80006760 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000674a:	0c 99       	mov	r9,r6
8000674c:	0c 9a       	mov	r10,r6
8000674e:	0c 9b       	mov	r11,r6
80006750:	0e 9c       	mov	r12,r7
80006752:	f0 1f 00 05 	mcall	80006764 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80006756:	0e 9c       	mov	r12,r7
80006758:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000675c:	80 00       	ld.sh	r0,r0[0x0]
8000675e:	62 bc       	ld.w	r12,r1[0x2c]
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	5f 2c       	srhs	r12
80006764:	80 00       	ld.sh	r0,r0[0x0]
80006766:	66 10       	ld.w	r0,r3[0x4]

80006768 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80006768:	d4 21       	pushm	r4-r7,lr
8000676a:	18 97       	mov	r7,r12
8000676c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000676e:	58 0c       	cp.w	r12,0
80006770:	c2 f0       	breq	800067ce <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80006772:	34 cc       	mov	r12,76
80006774:	f0 1f 00 17 	mcall	800067d0 <xQueueCreate+0x68>
80006778:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000677a:	c2 a0       	breq	800067ce <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000677c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
80006780:	e8 cc ff ff 	sub	r12,r4,-1
80006784:	f0 1f 00 13 	mcall	800067d0 <xQueueCreate+0x68>
80006788:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000678a:	c1 e0       	breq	800067c6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000678c:	f8 04 00 04 	add	r4,r12,r4
80006790:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80006792:	30 08       	mov	r8,0
80006794:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80006796:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
80006798:	ee c8 00 01 	sub	r8,r7,1
8000679c:	ad 38       	mul	r8,r6
8000679e:	10 0c       	add	r12,r8
800067a0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800067a2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800067a4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800067a8:	3f f8       	mov	r8,-1
800067aa:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800067ae:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800067b2:	ea cc ff f0 	sub	r12,r5,-16
800067b6:	f0 1f 00 08 	mcall	800067d4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800067ba:	ea cc ff dc 	sub	r12,r5,-36
800067be:	f0 1f 00 06 	mcall	800067d4 <xQueueCreate+0x6c>
800067c2:	0a 9c       	mov	r12,r5
800067c4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800067c6:	0a 9c       	mov	r12,r5
800067c8:	f0 1f 00 04 	mcall	800067d8 <xQueueCreate+0x70>
800067cc:	d8 2a       	popm	r4-r7,pc,r12=0
800067ce:	d8 2a       	popm	r4-r7,pc,r12=0
800067d0:	80 00       	ld.sh	r0,r0[0x0]
800067d2:	62 bc       	ld.w	r12,r1[0x2c]
800067d4:	80 00       	ld.sh	r0,r0[0x0]
800067d6:	5f 2c       	srhs	r12
800067d8:	80 00       	ld.sh	r0,r0[0x0]
800067da:	62 94       	ld.w	r4,r1[0x24]

800067dc <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800067dc:	48 38       	lddpc	r8,800067e8 <vTaskSuspendAll+0xc>
800067de:	70 09       	ld.w	r9,r8[0x0]
800067e0:	2f f9       	sub	r9,-1
800067e2:	91 09       	st.w	r8[0x0],r9
}
800067e4:	5e fc       	retal	r12
800067e6:	00 00       	add	r0,r0
800067e8:	00 00       	add	r0,r0
800067ea:	0d 80       	ld.ub	r0,r6[0x0]

800067ec <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800067ec:	49 a8       	lddpc	r8,80006854 <vTaskSwitchContext+0x68>
800067ee:	70 08       	ld.w	r8,r8[0x0]
800067f0:	58 08       	cp.w	r8,0
800067f2:	c0 b1       	brne	80006808 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800067f4:	49 98       	lddpc	r8,80006858 <vTaskSwitchContext+0x6c>
800067f6:	70 08       	ld.w	r8,r8[0x0]
800067f8:	f0 08 00 28 	add	r8,r8,r8<<0x2
800067fc:	49 89       	lddpc	r9,8000685c <vTaskSwitchContext+0x70>
800067fe:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80006802:	58 08       	cp.w	r8,0
80006804:	c0 60       	breq	80006810 <vTaskSwitchContext+0x24>
80006806:	c1 18       	rjmp	80006828 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80006808:	30 19       	mov	r9,1
8000680a:	49 68       	lddpc	r8,80006860 <vTaskSwitchContext+0x74>
8000680c:	91 09       	st.w	r8[0x0],r9
8000680e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006810:	49 28       	lddpc	r8,80006858 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80006812:	49 3a       	lddpc	r10,8000685c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80006814:	70 09       	ld.w	r9,r8[0x0]
80006816:	20 19       	sub	r9,1
80006818:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000681a:	70 09       	ld.w	r9,r8[0x0]
8000681c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006820:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80006824:	58 09       	cp.w	r9,0
80006826:	cf 70       	breq	80006814 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80006828:	48 c8       	lddpc	r8,80006858 <vTaskSwitchContext+0x6c>
8000682a:	70 08       	ld.w	r8,r8[0x0]
8000682c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80006830:	48 b9       	lddpc	r9,8000685c <vTaskSwitchContext+0x70>
80006832:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006836:	70 19       	ld.w	r9,r8[0x4]
80006838:	72 19       	ld.w	r9,r9[0x4]
8000683a:	91 19       	st.w	r8[0x4],r9
8000683c:	f0 ca ff f8 	sub	r10,r8,-8
80006840:	14 39       	cp.w	r9,r10
80006842:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80006846:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000684a:	70 18       	ld.w	r8,r8[0x4]
8000684c:	70 39       	ld.w	r9,r8[0xc]
8000684e:	48 68       	lddpc	r8,80006864 <vTaskSwitchContext+0x78>
80006850:	91 09       	st.w	r8[0x0],r9
80006852:	5e fc       	retal	r12
80006854:	00 00       	add	r0,r0
80006856:	0d 80       	ld.ub	r0,r6[0x0]
80006858:	00 00       	add	r0,r0
8000685a:	0d b8       	ld.ub	r8,r6[0x3]
8000685c:	00 00       	add	r0,r0
8000685e:	0c 9c       	mov	r12,r6
80006860:	00 00       	add	r0,r0
80006862:	0d a0       	ld.ub	r0,r6[0x2]
80006864:	00 00       	add	r0,r0
80006866:	0d 50       	ld.sh	r0,--r6

80006868 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80006868:	48 48       	lddpc	r8,80006878 <vTaskSetTimeOutState+0x10>
8000686a:	70 08       	ld.w	r8,r8[0x0]
8000686c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000686e:	48 48       	lddpc	r8,8000687c <vTaskSetTimeOutState+0x14>
80006870:	70 08       	ld.w	r8,r8[0x0]
80006872:	99 18       	st.w	r12[0x4],r8
}
80006874:	5e fc       	retal	r12
80006876:	00 00       	add	r0,r0
80006878:	00 00       	add	r0,r0
8000687a:	0c 94       	mov	r4,r6
8000687c:	00 00       	add	r0,r0
8000687e:	0d 7c       	ld.ub	r12,--r6

80006880 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80006880:	30 19       	mov	r9,1
80006882:	48 28       	lddpc	r8,80006888 <vTaskMissedYield+0x8>
80006884:	91 09       	st.w	r8[0x0],r9
}
80006886:	5e fc       	retal	r12
80006888:	00 00       	add	r0,r0
8000688a:	0d a0       	ld.ub	r0,r6[0x2]

8000688c <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
8000688c:	58 0c       	cp.w	r12,0
8000688e:	c0 31       	brne	80006894 <uxTaskGetStackHighWaterMark+0x8>
80006890:	48 c8       	lddpc	r8,800068c0 <uxTaskGetStackHighWaterMark+0x34>
80006892:	70 0c       	ld.w	r12,r8[0x0]

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
80006894:	78 ca       	ld.w	r10,r12[0x30]
80006896:	14 98       	mov	r8,r10

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
80006898:	15 8b       	ld.ub	r11,r10[0x0]
8000689a:	3a 59       	mov	r9,-91
8000689c:	f2 0b 18 00 	cp.b	r11,r9
800068a0:	c0 30       	breq	800068a6 <uxTaskGetStackHighWaterMark+0x1a>
800068a2:	30 0c       	mov	r12,0
800068a4:	c0 b8       	rjmp	800068ba <uxTaskGetStackHighWaterMark+0x2e>
800068a6:	3a 5b       	mov	r11,-91
		{
			pucStackByte -= portSTACK_GROWTH;
800068a8:	2f f8       	sub	r8,-1
800068aa:	f0 0a 01 09 	sub	r9,r8,r10
800068ae:	f9 d9 b0 10 	bfexts	r12,r9,0x0,0x10

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
800068b2:	11 89       	ld.ub	r9,r8[0x0]
800068b4:	f6 09 18 00 	cp.b	r9,r11
800068b8:	cf 80       	breq	800068a8 <uxTaskGetStackHighWaterMark+0x1c>
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
800068ba:	f9 dc c0 4e 	bfextu	r12,r12,0x2,0xe
800068be:	5e fc       	retal	r12
800068c0:	00 00       	add	r0,r0
800068c2:	0d 50       	ld.sh	r0,--r6

800068c4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800068c4:	48 28       	lddpc	r8,800068cc <xTaskGetCurrentTaskHandle+0x8>
800068c6:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800068c8:	5e fc       	retal	r12
800068ca:	00 00       	add	r0,r0
800068cc:	00 00       	add	r0,r0
800068ce:	0d 50       	ld.sh	r0,--r6

800068d0 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800068d0:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800068d4:	58 0c       	cp.w	r12,0
800068d6:	c1 f0       	breq	80006914 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800068d8:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800068da:	78 b9       	ld.w	r9,r12[0x2c]
800068dc:	79 18       	ld.w	r8,r12[0x44]
800068de:	10 39       	cp.w	r9,r8
800068e0:	c1 a0       	breq	80006914 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800068e2:	f8 c6 ff fc 	sub	r6,r12,-4
800068e6:	0c 9c       	mov	r12,r6
800068e8:	f0 1f 00 0c 	mcall	80006918 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800068ec:	6f 1c       	ld.w	r12,r7[0x44]
800068ee:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800068f0:	f8 08 11 08 	rsub	r8,r12,8
800068f4:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800068f6:	48 a8       	lddpc	r8,8000691c <vTaskPriorityDisinherit+0x4c>
800068f8:	70 08       	ld.w	r8,r8[0x0]
800068fa:	10 3c       	cp.w	r12,r8
800068fc:	e0 88 00 04 	brls	80006904 <vTaskPriorityDisinherit+0x34>
80006900:	48 78       	lddpc	r8,8000691c <vTaskPriorityDisinherit+0x4c>
80006902:	91 0c       	st.w	r8[0x0],r12
80006904:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006908:	0c 9b       	mov	r11,r6
8000690a:	48 68       	lddpc	r8,80006920 <vTaskPriorityDisinherit+0x50>
8000690c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006910:	f0 1f 00 05 	mcall	80006924 <vTaskPriorityDisinherit+0x54>
80006914:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006918:	80 00       	ld.sh	r0,r0[0x0]
8000691a:	5f 96       	srgt	r6
8000691c:	00 00       	add	r0,r0
8000691e:	0d b8       	ld.ub	r8,r6[0x3]
80006920:	00 00       	add	r0,r0
80006922:	0c 9c       	mov	r12,r6
80006924:	80 00       	ld.sh	r0,r0[0x0]
80006926:	5f 46       	srge	r6

80006928 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80006928:	eb cd 40 c0 	pushm	r6-r7,lr
8000692c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000692e:	49 b8       	lddpc	r8,80006998 <vTaskPriorityInherit+0x70>
80006930:	70 08       	ld.w	r8,r8[0x0]
80006932:	78 b9       	ld.w	r9,r12[0x2c]
80006934:	70 b8       	ld.w	r8,r8[0x2c]
80006936:	10 39       	cp.w	r9,r8
80006938:	c2 d2       	brcc	80006992 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000693a:	49 88       	lddpc	r8,80006998 <vTaskPriorityInherit+0x70>
8000693c:	70 08       	ld.w	r8,r8[0x0]
8000693e:	70 b8       	ld.w	r8,r8[0x2c]
80006940:	f0 08 11 08 	rsub	r8,r8,8
80006944:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
80006946:	f2 09 00 28 	add	r8,r9,r9<<0x2
8000694a:	49 59       	lddpc	r9,8000699c <vTaskPriorityInherit+0x74>
8000694c:	f2 08 00 28 	add	r8,r9,r8<<0x2
80006950:	78 59       	ld.w	r9,r12[0x14]
80006952:	10 39       	cp.w	r9,r8
80006954:	c1 b1       	brne	8000698a <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
80006956:	f8 c6 ff fc 	sub	r6,r12,-4
8000695a:	0c 9c       	mov	r12,r6
8000695c:	f0 1f 00 11 	mcall	800069a0 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80006960:	48 e8       	lddpc	r8,80006998 <vTaskPriorityInherit+0x70>
80006962:	70 08       	ld.w	r8,r8[0x0]
80006964:	70 bc       	ld.w	r12,r8[0x2c]
80006966:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80006968:	48 f8       	lddpc	r8,800069a4 <vTaskPriorityInherit+0x7c>
8000696a:	70 08       	ld.w	r8,r8[0x0]
8000696c:	10 3c       	cp.w	r12,r8
8000696e:	e0 88 00 04 	brls	80006976 <vTaskPriorityInherit+0x4e>
80006972:	48 d8       	lddpc	r8,800069a4 <vTaskPriorityInherit+0x7c>
80006974:	91 0c       	st.w	r8[0x0],r12
80006976:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
8000697a:	0c 9b       	mov	r11,r6
8000697c:	48 88       	lddpc	r8,8000699c <vTaskPriorityInherit+0x74>
8000697e:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80006982:	f0 1f 00 0a 	mcall	800069a8 <vTaskPriorityInherit+0x80>
80006986:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
8000698a:	48 48       	lddpc	r8,80006998 <vTaskPriorityInherit+0x70>
8000698c:	70 08       	ld.w	r8,r8[0x0]
8000698e:	70 b8       	ld.w	r8,r8[0x2c]
80006990:	99 b8       	st.w	r12[0x2c],r8
80006992:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006996:	00 00       	add	r0,r0
80006998:	00 00       	add	r0,r0
8000699a:	0d 50       	ld.sh	r0,--r6
8000699c:	00 00       	add	r0,r0
8000699e:	0c 9c       	mov	r12,r6
800069a0:	80 00       	ld.sh	r0,r0[0x0]
800069a2:	5f 96       	srgt	r6
800069a4:	00 00       	add	r0,r0
800069a6:	0d b8       	ld.ub	r8,r6[0x3]
800069a8:	80 00       	ld.sh	r0,r0[0x0]
800069aa:	5f 46       	srge	r6

800069ac <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800069ac:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800069b0:	78 38       	ld.w	r8,r12[0xc]
800069b2:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800069b4:	ee c6 ff e8 	sub	r6,r7,-24
800069b8:	0c 9c       	mov	r12,r6
800069ba:	f0 1f 00 15 	mcall	80006a0c <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800069be:	49 58       	lddpc	r8,80006a10 <xTaskRemoveFromEventList+0x64>
800069c0:	70 08       	ld.w	r8,r8[0x0]
800069c2:	58 08       	cp.w	r8,0
800069c4:	c1 71       	brne	800069f2 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800069c6:	ee c6 ff fc 	sub	r6,r7,-4
800069ca:	0c 9c       	mov	r12,r6
800069cc:	f0 1f 00 10 	mcall	80006a0c <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800069d0:	6e bc       	ld.w	r12,r7[0x2c]
800069d2:	49 18       	lddpc	r8,80006a14 <xTaskRemoveFromEventList+0x68>
800069d4:	70 08       	ld.w	r8,r8[0x0]
800069d6:	10 3c       	cp.w	r12,r8
800069d8:	e0 88 00 04 	brls	800069e0 <xTaskRemoveFromEventList+0x34>
800069dc:	48 e8       	lddpc	r8,80006a14 <xTaskRemoveFromEventList+0x68>
800069de:	91 0c       	st.w	r8[0x0],r12
800069e0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800069e4:	0c 9b       	mov	r11,r6
800069e6:	48 d8       	lddpc	r8,80006a18 <xTaskRemoveFromEventList+0x6c>
800069e8:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800069ec:	f0 1f 00 0c 	mcall	80006a1c <xTaskRemoveFromEventList+0x70>
800069f0:	c0 58       	rjmp	800069fa <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800069f2:	0c 9b       	mov	r11,r6
800069f4:	48 bc       	lddpc	r12,80006a20 <xTaskRemoveFromEventList+0x74>
800069f6:	f0 1f 00 0a 	mcall	80006a1c <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800069fa:	48 b8       	lddpc	r8,80006a24 <xTaskRemoveFromEventList+0x78>
800069fc:	70 08       	ld.w	r8,r8[0x0]
800069fe:	6e b9       	ld.w	r9,r7[0x2c]
80006a00:	70 b8       	ld.w	r8,r8[0x2c]
80006a02:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80006a04:	5f 2c       	srhs	r12
80006a06:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006a0a:	00 00       	add	r0,r0
80006a0c:	80 00       	ld.sh	r0,r0[0x0]
80006a0e:	5f 96       	srgt	r6
80006a10:	00 00       	add	r0,r0
80006a12:	0d 80       	ld.ub	r0,r6[0x0]
80006a14:	00 00       	add	r0,r0
80006a16:	0d b8       	ld.ub	r8,r6[0x3]
80006a18:	00 00       	add	r0,r0
80006a1a:	0c 9c       	mov	r12,r6
80006a1c:	80 00       	ld.sh	r0,r0[0x0]
80006a1e:	5f 46       	srge	r6
80006a20:	00 00       	add	r0,r0
80006a22:	0d 54       	ld.sh	r4,--r6
80006a24:	00 00       	add	r0,r0
80006a26:	0d 50       	ld.sh	r0,--r6

80006a28 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80006a28:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006a2c:	4b 98       	lddpc	r8,80006b10 <vTaskIncrementTick+0xe8>
80006a2e:	70 08       	ld.w	r8,r8[0x0]
80006a30:	58 08       	cp.w	r8,0
80006a32:	c6 91       	brne	80006b04 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80006a34:	4b 88       	lddpc	r8,80006b14 <vTaskIncrementTick+0xec>
80006a36:	70 09       	ld.w	r9,r8[0x0]
80006a38:	2f f9       	sub	r9,-1
80006a3a:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80006a3c:	70 08       	ld.w	r8,r8[0x0]
80006a3e:	58 08       	cp.w	r8,0
80006a40:	c1 a1       	brne	80006a74 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80006a42:	4b 68       	lddpc	r8,80006b18 <vTaskIncrementTick+0xf0>
80006a44:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80006a46:	4b 69       	lddpc	r9,80006b1c <vTaskIncrementTick+0xf4>
80006a48:	72 0b       	ld.w	r11,r9[0x0]
80006a4a:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80006a4c:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80006a4e:	4b 59       	lddpc	r9,80006b20 <vTaskIncrementTick+0xf8>
80006a50:	72 0a       	ld.w	r10,r9[0x0]
80006a52:	2f fa       	sub	r10,-1
80006a54:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80006a56:	70 08       	ld.w	r8,r8[0x0]
80006a58:	70 08       	ld.w	r8,r8[0x0]
80006a5a:	58 08       	cp.w	r8,0
80006a5c:	c0 51       	brne	80006a66 <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80006a5e:	3f f9       	mov	r9,-1
80006a60:	4b 18       	lddpc	r8,80006b24 <vTaskIncrementTick+0xfc>
80006a62:	91 09       	st.w	r8[0x0],r9
80006a64:	c0 88       	rjmp	80006a74 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80006a66:	4a d8       	lddpc	r8,80006b18 <vTaskIncrementTick+0xf0>
80006a68:	70 08       	ld.w	r8,r8[0x0]
80006a6a:	70 38       	ld.w	r8,r8[0xc]
80006a6c:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80006a6e:	70 19       	ld.w	r9,r8[0x4]
80006a70:	4a d8       	lddpc	r8,80006b24 <vTaskIncrementTick+0xfc>
80006a72:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80006a74:	4a 88       	lddpc	r8,80006b14 <vTaskIncrementTick+0xec>
80006a76:	70 09       	ld.w	r9,r8[0x0]
80006a78:	4a b8       	lddpc	r8,80006b24 <vTaskIncrementTick+0xfc>
80006a7a:	70 08       	ld.w	r8,r8[0x0]
80006a7c:	10 39       	cp.w	r9,r8
80006a7e:	c4 73       	brcs	80006b0c <vTaskIncrementTick+0xe4>
80006a80:	4a 68       	lddpc	r8,80006b18 <vTaskIncrementTick+0xf0>
80006a82:	70 08       	ld.w	r8,r8[0x0]
80006a84:	70 08       	ld.w	r8,r8[0x0]
80006a86:	58 08       	cp.w	r8,0
80006a88:	c0 c0       	breq	80006aa0 <vTaskIncrementTick+0x78>
80006a8a:	4a 48       	lddpc	r8,80006b18 <vTaskIncrementTick+0xf0>
80006a8c:	70 08       	ld.w	r8,r8[0x0]
80006a8e:	70 38       	ld.w	r8,r8[0xc]
80006a90:	70 37       	ld.w	r7,r8[0xc]
80006a92:	6e 18       	ld.w	r8,r7[0x4]
80006a94:	4a 09       	lddpc	r9,80006b14 <vTaskIncrementTick+0xec>
80006a96:	72 09       	ld.w	r9,r9[0x0]
80006a98:	12 38       	cp.w	r8,r9
80006a9a:	e0 88 00 14 	brls	80006ac2 <vTaskIncrementTick+0x9a>
80006a9e:	c0 e8       	rjmp	80006aba <vTaskIncrementTick+0x92>
80006aa0:	3f f9       	mov	r9,-1
80006aa2:	4a 18       	lddpc	r8,80006b24 <vTaskIncrementTick+0xfc>
80006aa4:	91 09       	st.w	r8[0x0],r9
80006aa6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006aaa:	6a 08       	ld.w	r8,r5[0x0]
80006aac:	70 38       	ld.w	r8,r8[0xc]
80006aae:	70 37       	ld.w	r7,r8[0xc]
80006ab0:	6e 18       	ld.w	r8,r7[0x4]
80006ab2:	64 09       	ld.w	r9,r2[0x0]
80006ab4:	12 38       	cp.w	r8,r9
80006ab6:	e0 88 00 0a 	brls	80006aca <vTaskIncrementTick+0xa2>
80006aba:	49 b9       	lddpc	r9,80006b24 <vTaskIncrementTick+0xfc>
80006abc:	93 08       	st.w	r9[0x0],r8
80006abe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006ac2:	49 a4       	lddpc	r4,80006b28 <vTaskIncrementTick+0x100>
80006ac4:	49 a3       	lddpc	r3,80006b2c <vTaskIncrementTick+0x104>
80006ac6:	49 55       	lddpc	r5,80006b18 <vTaskIncrementTick+0xf0>
80006ac8:	49 32       	lddpc	r2,80006b14 <vTaskIncrementTick+0xec>
80006aca:	ee c6 ff fc 	sub	r6,r7,-4
80006ace:	0c 9c       	mov	r12,r6
80006ad0:	f0 1f 00 18 	mcall	80006b30 <vTaskIncrementTick+0x108>
80006ad4:	6e a8       	ld.w	r8,r7[0x28]
80006ad6:	58 08       	cp.w	r8,0
80006ad8:	c0 50       	breq	80006ae2 <vTaskIncrementTick+0xba>
80006ada:	ee cc ff e8 	sub	r12,r7,-24
80006ade:	f0 1f 00 15 	mcall	80006b30 <vTaskIncrementTick+0x108>
80006ae2:	6e bc       	ld.w	r12,r7[0x2c]
80006ae4:	68 08       	ld.w	r8,r4[0x0]
80006ae6:	10 3c       	cp.w	r12,r8
80006ae8:	e9 fc ba 00 	st.whi	r4[0x0],r12
80006aec:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006af0:	0c 9b       	mov	r11,r6
80006af2:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80006af6:	f0 1f 00 10 	mcall	80006b34 <vTaskIncrementTick+0x10c>
80006afa:	6a 08       	ld.w	r8,r5[0x0]
80006afc:	70 08       	ld.w	r8,r8[0x0]
80006afe:	58 08       	cp.w	r8,0
80006b00:	cd 51       	brne	80006aaa <vTaskIncrementTick+0x82>
80006b02:	cc fb       	rjmp	80006aa0 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80006b04:	48 d8       	lddpc	r8,80006b38 <vTaskIncrementTick+0x110>
80006b06:	70 09       	ld.w	r9,r8[0x0]
80006b08:	2f f9       	sub	r9,-1
80006b0a:	91 09       	st.w	r8[0x0],r9
80006b0c:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80006b10:	00 00       	add	r0,r0
80006b12:	0d 80       	ld.ub	r0,r6[0x0]
80006b14:	00 00       	add	r0,r0
80006b16:	0d 7c       	ld.ub	r12,--r6
80006b18:	00 00       	add	r0,r0
80006b1a:	0c 88       	andn	r8,r6
80006b1c:	00 00       	add	r0,r0
80006b1e:	0c 98       	mov	r8,r6
80006b20:	00 00       	add	r0,r0
80006b22:	0c 94       	mov	r4,r6
80006b24:	00 00       	add	r0,r0
80006b26:	05 44       	ld.w	r4,--r2
80006b28:	00 00       	add	r0,r0
80006b2a:	0d b8       	ld.ub	r8,r6[0x3]
80006b2c:	00 00       	add	r0,r0
80006b2e:	0c 9c       	mov	r12,r6
80006b30:	80 00       	ld.sh	r0,r0[0x0]
80006b32:	5f 96       	srgt	r6
80006b34:	80 00       	ld.sh	r0,r0[0x0]
80006b36:	5f 46       	srge	r6
80006b38:	00 00       	add	r0,r0
80006b3a:	0c 80       	andn	r0,r6

80006b3c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80006b3c:	eb cd 40 c0 	pushm	r6-r7,lr
80006b40:	18 97       	mov	r7,r12
80006b42:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80006b44:	f0 1f 00 15 	mcall	80006b98 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80006b48:	6c 08       	ld.w	r8,r6[0x0]
80006b4a:	5b f8       	cp.w	r8,-1
80006b4c:	c0 31       	brne	80006b52 <xTaskCheckForTimeOut+0x16>
80006b4e:	30 07       	mov	r7,0
80006b50:	c1 f8       	rjmp	80006b8e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80006b52:	49 39       	lddpc	r9,80006b9c <xTaskCheckForTimeOut+0x60>
80006b54:	72 09       	ld.w	r9,r9[0x0]
80006b56:	6e 0a       	ld.w	r10,r7[0x0]
80006b58:	12 3a       	cp.w	r10,r9
80006b5a:	c0 70       	breq	80006b68 <xTaskCheckForTimeOut+0x2c>
80006b5c:	49 19       	lddpc	r9,80006ba0 <xTaskCheckForTimeOut+0x64>
80006b5e:	72 09       	ld.w	r9,r9[0x0]
80006b60:	6e 1a       	ld.w	r10,r7[0x4]
80006b62:	12 3a       	cp.w	r10,r9
80006b64:	e0 88 00 14 	brls	80006b8c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80006b68:	48 e9       	lddpc	r9,80006ba0 <xTaskCheckForTimeOut+0x64>
80006b6a:	72 0a       	ld.w	r10,r9[0x0]
80006b6c:	6e 19       	ld.w	r9,r7[0x4]
80006b6e:	12 1a       	sub	r10,r9
80006b70:	14 38       	cp.w	r8,r10
80006b72:	e0 88 00 0d 	brls	80006b8c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80006b76:	48 ba       	lddpc	r10,80006ba0 <xTaskCheckForTimeOut+0x64>
80006b78:	74 0a       	ld.w	r10,r10[0x0]
80006b7a:	14 19       	sub	r9,r10
80006b7c:	f2 08 00 08 	add	r8,r9,r8
80006b80:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80006b82:	0e 9c       	mov	r12,r7
80006b84:	f0 1f 00 08 	mcall	80006ba4 <xTaskCheckForTimeOut+0x68>
80006b88:	30 07       	mov	r7,0
80006b8a:	c0 28       	rjmp	80006b8e <xTaskCheckForTimeOut+0x52>
80006b8c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80006b8e:	f0 1f 00 07 	mcall	80006ba8 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80006b92:	0e 9c       	mov	r12,r7
80006b94:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006b98:	80 00       	ld.sh	r0,r0[0x0]
80006b9a:	60 50       	ld.w	r0,r0[0x14]
80006b9c:	00 00       	add	r0,r0
80006b9e:	0c 94       	mov	r4,r6
80006ba0:	00 00       	add	r0,r0
80006ba2:	0d 7c       	ld.ub	r12,--r6
80006ba4:	80 00       	ld.sh	r0,r0[0x0]
80006ba6:	68 68       	ld.w	r8,r4[0x18]
80006ba8:	80 00       	ld.sh	r0,r0[0x0]
80006baa:	61 5c       	ld.w	r12,r0[0x54]

80006bac <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80006bac:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80006bb0:	f0 1f 00 05 	mcall	80006bc4 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80006bb4:	48 58       	lddpc	r8,80006bc8 <xTaskGetTickCount+0x1c>
80006bb6:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80006bb8:	f0 1f 00 05 	mcall	80006bcc <xTaskGetTickCount+0x20>

	return xTicks;
}
80006bbc:	0e 9c       	mov	r12,r7
80006bbe:	e3 cd 80 80 	ldm	sp++,r7,pc
80006bc2:	00 00       	add	r0,r0
80006bc4:	80 00       	ld.sh	r0,r0[0x0]
80006bc6:	60 50       	ld.w	r0,r0[0x14]
80006bc8:	00 00       	add	r0,r0
80006bca:	0d 7c       	ld.ub	r12,--r6
80006bcc:	80 00       	ld.sh	r0,r0[0x0]
80006bce:	61 5c       	ld.w	r12,r0[0x54]

80006bd0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80006bd0:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80006bd4:	f0 1f 00 2c 	mcall	80006c84 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80006bd8:	4a c8       	lddpc	r8,80006c88 <xTaskResumeAll+0xb8>
80006bda:	70 09       	ld.w	r9,r8[0x0]
80006bdc:	20 19       	sub	r9,1
80006bde:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80006be0:	70 08       	ld.w	r8,r8[0x0]
80006be2:	58 08       	cp.w	r8,0
80006be4:	c4 91       	brne	80006c76 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80006be6:	4a a8       	lddpc	r8,80006c8c <xTaskResumeAll+0xbc>
80006be8:	70 08       	ld.w	r8,r8[0x0]
80006bea:	58 08       	cp.w	r8,0
80006bec:	c4 50       	breq	80006c76 <xTaskResumeAll+0xa6>
80006bee:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006bf0:	4a 85       	lddpc	r5,80006c90 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80006bf2:	4a 93       	lddpc	r3,80006c94 <xTaskResumeAll+0xc4>
80006bf4:	4a 92       	lddpc	r2,80006c98 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006bf6:	4a a1       	lddpc	r1,80006c9c <xTaskResumeAll+0xcc>
80006bf8:	c1 e8       	rjmp	80006c34 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80006bfa:	6a 38       	ld.w	r8,r5[0xc]
80006bfc:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80006bfe:	ee cc ff e8 	sub	r12,r7,-24
80006c02:	f0 1f 00 28 	mcall	80006ca0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80006c06:	ee c6 ff fc 	sub	r6,r7,-4
80006c0a:	0c 9c       	mov	r12,r6
80006c0c:	f0 1f 00 25 	mcall	80006ca0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80006c10:	6e bc       	ld.w	r12,r7[0x2c]
80006c12:	66 08       	ld.w	r8,r3[0x0]
80006c14:	10 3c       	cp.w	r12,r8
80006c16:	e7 fc ba 00 	st.whi	r3[0x0],r12
80006c1a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006c1e:	0c 9b       	mov	r11,r6
80006c20:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80006c24:	f0 1f 00 20 	mcall	80006ca4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80006c28:	62 08       	ld.w	r8,r1[0x0]
80006c2a:	6e b9       	ld.w	r9,r7[0x2c]
80006c2c:	70 b8       	ld.w	r8,r8[0x2c]
80006c2e:	10 39       	cp.w	r9,r8
80006c30:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80006c34:	6a 08       	ld.w	r8,r5[0x0]
80006c36:	58 08       	cp.w	r8,0
80006c38:	ce 11       	brne	80006bfa <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006c3a:	49 c8       	lddpc	r8,80006ca8 <xTaskResumeAll+0xd8>
80006c3c:	70 08       	ld.w	r8,r8[0x0]
80006c3e:	58 08       	cp.w	r8,0
80006c40:	c0 f0       	breq	80006c5e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006c42:	49 a8       	lddpc	r8,80006ca8 <xTaskResumeAll+0xd8>
80006c44:	70 08       	ld.w	r8,r8[0x0]
80006c46:	58 08       	cp.w	r8,0
80006c48:	c1 10       	breq	80006c6a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80006c4a:	49 87       	lddpc	r7,80006ca8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80006c4c:	f0 1f 00 18 	mcall	80006cac <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80006c50:	6e 08       	ld.w	r8,r7[0x0]
80006c52:	20 18       	sub	r8,1
80006c54:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80006c56:	6e 08       	ld.w	r8,r7[0x0]
80006c58:	58 08       	cp.w	r8,0
80006c5a:	cf 91       	brne	80006c4c <xTaskResumeAll+0x7c>
80006c5c:	c0 78       	rjmp	80006c6a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80006c5e:	58 14       	cp.w	r4,1
80006c60:	c0 50       	breq	80006c6a <xTaskResumeAll+0x9a>
80006c62:	49 48       	lddpc	r8,80006cb0 <xTaskResumeAll+0xe0>
80006c64:	70 08       	ld.w	r8,r8[0x0]
80006c66:	58 18       	cp.w	r8,1
80006c68:	c0 71       	brne	80006c76 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80006c6a:	30 09       	mov	r9,0
80006c6c:	49 18       	lddpc	r8,80006cb0 <xTaskResumeAll+0xe0>
80006c6e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80006c70:	d7 33       	scall
80006c72:	30 17       	mov	r7,1
80006c74:	c0 28       	rjmp	80006c78 <xTaskResumeAll+0xa8>
80006c76:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80006c78:	f0 1f 00 0f 	mcall	80006cb4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80006c7c:	0e 9c       	mov	r12,r7
80006c7e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80006c82:	00 00       	add	r0,r0
80006c84:	80 00       	ld.sh	r0,r0[0x0]
80006c86:	60 50       	ld.w	r0,r0[0x14]
80006c88:	00 00       	add	r0,r0
80006c8a:	0d 80       	ld.ub	r0,r6[0x0]
80006c8c:	00 00       	add	r0,r0
80006c8e:	0d 9c       	ld.ub	r12,r6[0x1]
80006c90:	00 00       	add	r0,r0
80006c92:	0d 54       	ld.sh	r4,--r6
80006c94:	00 00       	add	r0,r0
80006c96:	0d b8       	ld.ub	r8,r6[0x3]
80006c98:	00 00       	add	r0,r0
80006c9a:	0c 9c       	mov	r12,r6
80006c9c:	00 00       	add	r0,r0
80006c9e:	0d 50       	ld.sh	r0,--r6
80006ca0:	80 00       	ld.sh	r0,r0[0x0]
80006ca2:	5f 96       	srgt	r6
80006ca4:	80 00       	ld.sh	r0,r0[0x0]
80006ca6:	5f 46       	srge	r6
80006ca8:	00 00       	add	r0,r0
80006caa:	0c 80       	andn	r0,r6
80006cac:	80 00       	ld.sh	r0,r0[0x0]
80006cae:	6a 28       	ld.w	r8,r5[0x8]
80006cb0:	00 00       	add	r0,r0
80006cb2:	0d a0       	ld.ub	r0,r6[0x2]
80006cb4:	80 00       	ld.sh	r0,r0[0x0]
80006cb6:	61 5c       	ld.w	r12,r0[0x54]

80006cb8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80006cb8:	eb cd 40 80 	pushm	r7,lr
80006cbc:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80006cbe:	49 08       	lddpc	r8,80006cfc <prvAddCurrentTaskToDelayedList+0x44>
80006cc0:	70 08       	ld.w	r8,r8[0x0]
80006cc2:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80006cc4:	48 f8       	lddpc	r8,80006d00 <prvAddCurrentTaskToDelayedList+0x48>
80006cc6:	70 08       	ld.w	r8,r8[0x0]
80006cc8:	10 3c       	cp.w	r12,r8
80006cca:	c0 a2       	brcc	80006cde <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006ccc:	48 c8       	lddpc	r8,80006cfc <prvAddCurrentTaskToDelayedList+0x44>
80006cce:	70 0b       	ld.w	r11,r8[0x0]
80006cd0:	48 d8       	lddpc	r8,80006d04 <prvAddCurrentTaskToDelayedList+0x4c>
80006cd2:	70 0c       	ld.w	r12,r8[0x0]
80006cd4:	2f cb       	sub	r11,-4
80006cd6:	f0 1f 00 0d 	mcall	80006d08 <prvAddCurrentTaskToDelayedList+0x50>
80006cda:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006cde:	48 88       	lddpc	r8,80006cfc <prvAddCurrentTaskToDelayedList+0x44>
80006ce0:	70 0b       	ld.w	r11,r8[0x0]
80006ce2:	48 b8       	lddpc	r8,80006d0c <prvAddCurrentTaskToDelayedList+0x54>
80006ce4:	70 0c       	ld.w	r12,r8[0x0]
80006ce6:	2f cb       	sub	r11,-4
80006ce8:	f0 1f 00 08 	mcall	80006d08 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80006cec:	48 98       	lddpc	r8,80006d10 <prvAddCurrentTaskToDelayedList+0x58>
80006cee:	70 08       	ld.w	r8,r8[0x0]
80006cf0:	10 37       	cp.w	r7,r8
80006cf2:	c0 32       	brcc	80006cf8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80006cf4:	48 78       	lddpc	r8,80006d10 <prvAddCurrentTaskToDelayedList+0x58>
80006cf6:	91 07       	st.w	r8[0x0],r7
80006cf8:	e3 cd 80 80 	ldm	sp++,r7,pc
80006cfc:	00 00       	add	r0,r0
80006cfe:	0d 50       	ld.sh	r0,--r6
80006d00:	00 00       	add	r0,r0
80006d02:	0d 7c       	ld.ub	r12,--r6
80006d04:	00 00       	add	r0,r0
80006d06:	0c 98       	mov	r8,r6
80006d08:	80 00       	ld.sh	r0,r0[0x0]
80006d0a:	5f 62       	srmi	r2
80006d0c:	00 00       	add	r0,r0
80006d0e:	0c 88       	andn	r8,r6
80006d10:	00 00       	add	r0,r0
80006d12:	05 44       	ld.w	r4,--r2

80006d14 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80006d14:	eb cd 40 c0 	pushm	r6-r7,lr
80006d18:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80006d1a:	58 0c       	cp.w	r12,0
80006d1c:	c1 10       	breq	80006d3e <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80006d1e:	f0 1f 00 0a 	mcall	80006d44 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80006d22:	48 a8       	lddpc	r8,80006d48 <vTaskDelay+0x34>
80006d24:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006d26:	48 a8       	lddpc	r8,80006d4c <vTaskDelay+0x38>
80006d28:	70 0c       	ld.w	r12,r8[0x0]
80006d2a:	2f cc       	sub	r12,-4
80006d2c:	f0 1f 00 09 	mcall	80006d50 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006d30:	ee 06 00 0c 	add	r12,r7,r6
80006d34:	f0 1f 00 08 	mcall	80006d54 <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80006d38:	f0 1f 00 08 	mcall	80006d58 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006d3c:	c0 21       	brne	80006d40 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80006d3e:	d7 33       	scall
80006d40:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006d44:	80 00       	ld.sh	r0,r0[0x0]
80006d46:	67 dc       	ld.w	r12,r3[0x74]
80006d48:	00 00       	add	r0,r0
80006d4a:	0d 7c       	ld.ub	r12,--r6
80006d4c:	00 00       	add	r0,r0
80006d4e:	0d 50       	ld.sh	r0,--r6
80006d50:	80 00       	ld.sh	r0,r0[0x0]
80006d52:	5f 96       	srgt	r6
80006d54:	80 00       	ld.sh	r0,r0[0x0]
80006d56:	6c b8       	ld.w	r8,r6[0x2c]
80006d58:	80 00       	ld.sh	r0,r0[0x0]
80006d5a:	6b d0       	ld.w	r0,r5[0x74]

80006d5c <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80006d5c:	eb cd 40 c0 	pushm	r6-r7,lr
80006d60:	18 96       	mov	r6,r12
80006d62:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80006d64:	f0 1f 00 18 	mcall	80006dc4 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80006d68:	6c 08       	ld.w	r8,r6[0x0]
80006d6a:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80006d6c:	49 79       	lddpc	r9,80006dc8 <vTaskDelayUntil+0x6c>
80006d6e:	72 09       	ld.w	r9,r9[0x0]
80006d70:	12 38       	cp.w	r8,r9
80006d72:	e0 88 00 0c 	brls	80006d8a <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80006d76:	0e 38       	cp.w	r8,r7
80006d78:	e0 88 00 22 	brls	80006dbc <vTaskDelayUntil+0x60>
80006d7c:	49 38       	lddpc	r8,80006dc8 <vTaskDelayUntil+0x6c>
80006d7e:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006d80:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80006d82:	10 37       	cp.w	r7,r8
80006d84:	e0 88 00 14 	brls	80006dac <vTaskDelayUntil+0x50>
80006d88:	c0 a8       	rjmp	80006d9c <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80006d8a:	0e 38       	cp.w	r8,r7
80006d8c:	e0 8b 00 16 	brhi	80006db8 <vTaskDelayUntil+0x5c>
80006d90:	48 e8       	lddpc	r8,80006dc8 <vTaskDelayUntil+0x6c>
80006d92:	70 08       	ld.w	r8,r8[0x0]
80006d94:	10 37       	cp.w	r7,r8
80006d96:	e0 8b 00 11 	brhi	80006db8 <vTaskDelayUntil+0x5c>
80006d9a:	c1 18       	rjmp	80006dbc <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006d9c:	48 c8       	lddpc	r8,80006dcc <vTaskDelayUntil+0x70>
80006d9e:	70 0c       	ld.w	r12,r8[0x0]
80006da0:	2f cc       	sub	r12,-4
80006da2:	f0 1f 00 0c 	mcall	80006dd0 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80006da6:	0e 9c       	mov	r12,r7
80006da8:	f0 1f 00 0b 	mcall	80006dd4 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80006dac:	f0 1f 00 0b 	mcall	80006dd8 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80006db0:	c0 81       	brne	80006dc0 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80006db2:	d7 33       	scall
80006db4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80006db8:	8d 07       	st.w	r6[0x0],r7
80006dba:	cf 1b       	rjmp	80006d9c <vTaskDelayUntil+0x40>
80006dbc:	8d 07       	st.w	r6[0x0],r7
80006dbe:	cf 7b       	rjmp	80006dac <vTaskDelayUntil+0x50>
80006dc0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006dc4:	80 00       	ld.sh	r0,r0[0x0]
80006dc6:	67 dc       	ld.w	r12,r3[0x74]
80006dc8:	00 00       	add	r0,r0
80006dca:	0d 7c       	ld.ub	r12,--r6
80006dcc:	00 00       	add	r0,r0
80006dce:	0d 50       	ld.sh	r0,--r6
80006dd0:	80 00       	ld.sh	r0,r0[0x0]
80006dd2:	5f 96       	srgt	r6
80006dd4:	80 00       	ld.sh	r0,r0[0x0]
80006dd6:	6c b8       	ld.w	r8,r6[0x2c]
80006dd8:	80 00       	ld.sh	r0,r0[0x0]
80006dda:	6b d0       	ld.w	r0,r5[0x74]

80006ddc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80006ddc:	eb cd 40 c0 	pushm	r6-r7,lr
80006de0:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80006de2:	48 e7       	lddpc	r7,80006e18 <vTaskPlaceOnEventList+0x3c>
80006de4:	6e 0b       	ld.w	r11,r7[0x0]
80006de6:	2e 8b       	sub	r11,-24
80006de8:	f0 1f 00 0d 	mcall	80006e1c <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006dec:	6e 0c       	ld.w	r12,r7[0x0]
80006dee:	2f cc       	sub	r12,-4
80006df0:	f0 1f 00 0c 	mcall	80006e20 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80006df4:	5b f6       	cp.w	r6,-1
80006df6:	c0 81       	brne	80006e06 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80006df8:	6e 0b       	ld.w	r11,r7[0x0]
80006dfa:	2f cb       	sub	r11,-4
80006dfc:	48 ac       	lddpc	r12,80006e24 <vTaskPlaceOnEventList+0x48>
80006dfe:	f0 1f 00 0b 	mcall	80006e28 <vTaskPlaceOnEventList+0x4c>
80006e02:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80006e06:	48 a8       	lddpc	r8,80006e2c <vTaskPlaceOnEventList+0x50>
80006e08:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80006e0a:	ec 0c 00 0c 	add	r12,r6,r12
80006e0e:	f0 1f 00 09 	mcall	80006e30 <vTaskPlaceOnEventList+0x54>
80006e12:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006e16:	00 00       	add	r0,r0
80006e18:	00 00       	add	r0,r0
80006e1a:	0d 50       	ld.sh	r0,--r6
80006e1c:	80 00       	ld.sh	r0,r0[0x0]
80006e1e:	5f 62       	srmi	r2
80006e20:	80 00       	ld.sh	r0,r0[0x0]
80006e22:	5f 96       	srgt	r6
80006e24:	00 00       	add	r0,r0
80006e26:	0d a4       	ld.ub	r4,r6[0x2]
80006e28:	80 00       	ld.sh	r0,r0[0x0]
80006e2a:	5f 46       	srge	r6
80006e2c:	00 00       	add	r0,r0
80006e2e:	0d 7c       	ld.ub	r12,--r6
80006e30:	80 00       	ld.sh	r0,r0[0x0]
80006e32:	6c b8       	ld.w	r8,r6[0x2c]

80006e34 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006e34:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006e38:	49 67       	lddpc	r7,80006e90 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006e3a:	49 74       	lddpc	r4,80006e94 <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80006e3c:	49 73       	lddpc	r3,80006e98 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006e3e:	49 85       	lddpc	r5,80006e9c <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006e40:	6e 08       	ld.w	r8,r7[0x0]
80006e42:	58 08       	cp.w	r8,0
80006e44:	c1 e0       	breq	80006e80 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80006e46:	f0 1f 00 17 	mcall	80006ea0 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80006e4a:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006e4c:	f0 1f 00 16 	mcall	80006ea4 <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80006e50:	58 06       	cp.w	r6,0
80006e52:	c1 70       	breq	80006e80 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80006e54:	f0 1f 00 15 	mcall	80006ea8 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80006e58:	68 38       	ld.w	r8,r4[0xc]
80006e5a:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80006e5c:	ec cc ff fc 	sub	r12,r6,-4
80006e60:	f0 1f 00 13 	mcall	80006eac <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
80006e64:	66 08       	ld.w	r8,r3[0x0]
80006e66:	20 18       	sub	r8,1
80006e68:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80006e6a:	6e 08       	ld.w	r8,r7[0x0]
80006e6c:	20 18       	sub	r8,1
80006e6e:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80006e70:	f0 1f 00 10 	mcall	80006eb0 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80006e74:	6c cc       	ld.w	r12,r6[0x30]
80006e76:	f0 1f 00 10 	mcall	80006eb4 <prvIdleTask+0x80>
		vPortFree( pxTCB );
80006e7a:	0c 9c       	mov	r12,r6
80006e7c:	f0 1f 00 0e 	mcall	80006eb4 <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006e80:	6a 08       	ld.w	r8,r5[0x0]
80006e82:	58 18       	cp.w	r8,1
80006e84:	e0 88 00 03 	brls	80006e8a <prvIdleTask+0x56>
			{
				taskYIELD();
80006e88:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80006e8a:	f0 1f 00 0c 	mcall	80006eb8 <prvIdleTask+0x84>
		}
		#endif
	}
80006e8e:	cd 9b       	rjmp	80006e40 <prvIdleTask+0xc>
80006e90:	00 00       	add	r0,r0
80006e92:	0c 90       	mov	r0,r6
80006e94:	00 00       	add	r0,r0
80006e96:	0d 3c       	ld.ub	r12,r6++
80006e98:	00 00       	add	r0,r0
80006e9a:	0d 9c       	ld.ub	r12,r6[0x1]
80006e9c:	00 00       	add	r0,r0
80006e9e:	0c 9c       	mov	r12,r6
80006ea0:	80 00       	ld.sh	r0,r0[0x0]
80006ea2:	67 dc       	ld.w	r12,r3[0x74]
80006ea4:	80 00       	ld.sh	r0,r0[0x0]
80006ea6:	6b d0       	ld.w	r0,r5[0x74]
80006ea8:	80 00       	ld.sh	r0,r0[0x0]
80006eaa:	60 50       	ld.w	r0,r0[0x14]
80006eac:	80 00       	ld.sh	r0,r0[0x0]
80006eae:	5f 96       	srgt	r6
80006eb0:	80 00       	ld.sh	r0,r0[0x0]
80006eb2:	61 5c       	ld.w	r12,r0[0x54]
80006eb4:	80 00       	ld.sh	r0,r0[0x0]
80006eb6:	62 94       	ld.w	r4,r1[0x24]
80006eb8:	80 00       	ld.sh	r0,r0[0x0]
80006eba:	20 2c       	sub	r12,2

80006ebc <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80006ebc:	d4 31       	pushm	r0-r7,lr
80006ebe:	20 1d       	sub	sp,4
80006ec0:	fa c4 ff d8 	sub	r4,sp,-40
80006ec4:	50 0c       	stdsp	sp[0x0],r12
80006ec6:	16 91       	mov	r1,r11
80006ec8:	14 97       	mov	r7,r10
80006eca:	12 90       	mov	r0,r9
80006ecc:	10 93       	mov	r3,r8
80006ece:	68 02       	ld.w	r2,r4[0x0]
80006ed0:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006ed2:	34 8c       	mov	r12,72
80006ed4:	f0 1f 00 5c 	mcall	80007044 <xTaskGenericCreate+0x188>
80006ed8:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80006eda:	c0 31       	brne	80006ee0 <xTaskGenericCreate+0x24>
80006edc:	3f fc       	mov	r12,-1
80006ede:	ca f8       	rjmp	8000703c <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80006ee0:	58 06       	cp.w	r6,0
80006ee2:	e0 81 00 af 	brne	80007040 <xTaskGenericCreate+0x184>
80006ee6:	0e 9c       	mov	r12,r7
80006ee8:	5c 7c       	castu.h	r12
80006eea:	a3 6c       	lsl	r12,0x2
80006eec:	f0 1f 00 56 	mcall	80007044 <xTaskGenericCreate+0x188>
80006ef0:	18 96       	mov	r6,r12
80006ef2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80006ef4:	c0 61       	brne	80006f00 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80006ef6:	0a 9c       	mov	r12,r5
80006ef8:	f0 1f 00 54 	mcall	80007048 <xTaskGenericCreate+0x18c>
80006efc:	3f fc       	mov	r12,-1
80006efe:	c9 f8       	rjmp	8000703c <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006f00:	5c 77       	castu.h	r7
80006f02:	ee 0a 15 02 	lsl	r10,r7,0x2
80006f06:	e0 6b 00 a5 	mov	r11,165
80006f0a:	0c 9c       	mov	r12,r6
80006f0c:	f0 1f 00 50 	mcall	8000704c <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80006f10:	ee c6 00 01 	sub	r6,r7,1
80006f14:	6a c8       	ld.w	r8,r5[0x30]
80006f16:	f0 06 00 26 	add	r6,r8,r6<<0x2
80006f1a:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80006f1e:	31 0a       	mov	r10,16
80006f20:	02 9b       	mov	r11,r1
80006f22:	ea cc ff cc 	sub	r12,r5,-52
80006f26:	f0 1f 00 4b 	mcall	80007050 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80006f2a:	30 08       	mov	r8,0
80006f2c:	eb 68 00 43 	st.b	r5[67],r8
80006f30:	58 73       	cp.w	r3,7
80006f32:	e6 07 17 80 	movls	r7,r3
80006f36:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80006f3a:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006f3c:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006f40:	ea c4 ff fc 	sub	r4,r5,-4
80006f44:	08 9c       	mov	r12,r4
80006f46:	f0 1f 00 44 	mcall	80007054 <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80006f4a:	ea cc ff e8 	sub	r12,r5,-24
80006f4e:	f0 1f 00 42 	mcall	80007054 <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006f52:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006f54:	ee 07 11 08 	rsub	r7,r7,8
80006f58:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006f5a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006f5c:	00 9a       	mov	r10,r0
80006f5e:	40 0b       	lddsp	r11,sp[0x0]
80006f60:	0c 9c       	mov	r12,r6
80006f62:	f0 1f 00 3e 	mcall	80007058 <xTaskGenericCreate+0x19c>
80006f66:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006f68:	58 02       	cp.w	r2,0
80006f6a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80006f6e:	f0 1f 00 3c 	mcall	8000705c <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80006f72:	4b c8       	lddpc	r8,80007060 <xTaskGenericCreate+0x1a4>
80006f74:	70 09       	ld.w	r9,r8[0x0]
80006f76:	2f f9       	sub	r9,-1
80006f78:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006f7a:	4b b8       	lddpc	r8,80007064 <xTaskGenericCreate+0x1a8>
80006f7c:	70 08       	ld.w	r8,r8[0x0]
80006f7e:	58 08       	cp.w	r8,0
80006f80:	c2 61       	brne	80006fcc <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80006f82:	4b 98       	lddpc	r8,80007064 <xTaskGenericCreate+0x1a8>
80006f84:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006f86:	4b 78       	lddpc	r8,80007060 <xTaskGenericCreate+0x1a4>
80006f88:	70 08       	ld.w	r8,r8[0x0]
80006f8a:	58 18       	cp.w	r8,1
80006f8c:	c2 b1       	brne	80006fe2 <xTaskGenericCreate+0x126>
80006f8e:	4b 77       	lddpc	r7,80007068 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80006f90:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006f94:	0e 9c       	mov	r12,r7
80006f96:	f0 1f 00 36 	mcall	8000706c <xTaskGenericCreate+0x1b0>
80006f9a:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006f9c:	0c 37       	cp.w	r7,r6
80006f9e:	cf b1       	brne	80006f94 <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80006fa0:	4b 47       	lddpc	r7,80007070 <xTaskGenericCreate+0x1b4>
80006fa2:	0e 9c       	mov	r12,r7
80006fa4:	f0 1f 00 32 	mcall	8000706c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006fa8:	4b 36       	lddpc	r6,80007074 <xTaskGenericCreate+0x1b8>
80006faa:	0c 9c       	mov	r12,r6
80006fac:	f0 1f 00 30 	mcall	8000706c <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80006fb0:	4b 2c       	lddpc	r12,80007078 <xTaskGenericCreate+0x1bc>
80006fb2:	f0 1f 00 2f 	mcall	8000706c <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006fb6:	4b 2c       	lddpc	r12,8000707c <xTaskGenericCreate+0x1c0>
80006fb8:	f0 1f 00 2d 	mcall	8000706c <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006fbc:	4b 1c       	lddpc	r12,80007080 <xTaskGenericCreate+0x1c4>
80006fbe:	f0 1f 00 2c 	mcall	8000706c <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80006fc2:	4b 18       	lddpc	r8,80007084 <xTaskGenericCreate+0x1c8>
80006fc4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006fc6:	4b 18       	lddpc	r8,80007088 <xTaskGenericCreate+0x1cc>
80006fc8:	91 06       	st.w	r8[0x0],r6
80006fca:	c0 c8       	rjmp	80006fe2 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006fcc:	4b 08       	lddpc	r8,8000708c <xTaskGenericCreate+0x1d0>
80006fce:	70 08       	ld.w	r8,r8[0x0]
80006fd0:	58 08       	cp.w	r8,0
80006fd2:	c0 81       	brne	80006fe2 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006fd4:	4a 48       	lddpc	r8,80007064 <xTaskGenericCreate+0x1a8>
80006fd6:	70 08       	ld.w	r8,r8[0x0]
80006fd8:	70 b8       	ld.w	r8,r8[0x2c]
80006fda:	10 33       	cp.w	r3,r8
80006fdc:	c0 33       	brcs	80006fe2 <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80006fde:	4a 28       	lddpc	r8,80007064 <xTaskGenericCreate+0x1a8>
80006fe0:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80006fe2:	6a b8       	ld.w	r8,r5[0x2c]
80006fe4:	4a b9       	lddpc	r9,80007090 <xTaskGenericCreate+0x1d4>
80006fe6:	72 09       	ld.w	r9,r9[0x0]
80006fe8:	12 38       	cp.w	r8,r9
80006fea:	e0 88 00 04 	brls	80006ff2 <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80006fee:	4a 99       	lddpc	r9,80007090 <xTaskGenericCreate+0x1d4>
80006ff0:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80006ff2:	4a 98       	lddpc	r8,80007094 <xTaskGenericCreate+0x1d8>
80006ff4:	70 09       	ld.w	r9,r8[0x0]
80006ff6:	2f f9       	sub	r9,-1
80006ff8:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80006ffa:	6a b8       	ld.w	r8,r5[0x2c]
80006ffc:	4a 79       	lddpc	r9,80007098 <xTaskGenericCreate+0x1dc>
80006ffe:	72 09       	ld.w	r9,r9[0x0]
80007000:	12 38       	cp.w	r8,r9
80007002:	e0 88 00 04 	brls	8000700a <xTaskGenericCreate+0x14e>
80007006:	4a 59       	lddpc	r9,80007098 <xTaskGenericCreate+0x1dc>
80007008:	93 08       	st.w	r9[0x0],r8
8000700a:	6a bc       	ld.w	r12,r5[0x2c]
8000700c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80007010:	08 9b       	mov	r11,r4
80007012:	49 68       	lddpc	r8,80007068 <xTaskGenericCreate+0x1ac>
80007014:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80007018:	f0 1f 00 21 	mcall	8000709c <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
8000701c:	f0 1f 00 21 	mcall	800070a0 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80007020:	49 b8       	lddpc	r8,8000708c <xTaskGenericCreate+0x1d0>
80007022:	70 08       	ld.w	r8,r8[0x0]
80007024:	58 08       	cp.w	r8,0
80007026:	c0 a0       	breq	8000703a <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80007028:	48 f8       	lddpc	r8,80007064 <xTaskGenericCreate+0x1a8>
8000702a:	70 08       	ld.w	r8,r8[0x0]
8000702c:	70 b8       	ld.w	r8,r8[0x2c]
8000702e:	10 33       	cp.w	r3,r8
80007030:	e0 88 00 05 	brls	8000703a <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80007034:	d7 33       	scall
80007036:	30 1c       	mov	r12,1
80007038:	c0 28       	rjmp	8000703c <xTaskGenericCreate+0x180>
8000703a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
8000703c:	2f fd       	sub	sp,-4
8000703e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80007040:	99 c6       	st.w	r12[0x30],r6
80007042:	c5 fb       	rjmp	80006f00 <xTaskGenericCreate+0x44>
80007044:	80 00       	ld.sh	r0,r0[0x0]
80007046:	62 bc       	ld.w	r12,r1[0x2c]
80007048:	80 00       	ld.sh	r0,r0[0x0]
8000704a:	62 94       	ld.w	r4,r1[0x24]
8000704c:	80 00       	ld.sh	r0,r0[0x0]
8000704e:	7c 6a       	ld.w	r10,lr[0x18]
80007050:	80 00       	ld.sh	r0,r0[0x0]
80007052:	7f 94       	ld.w	r4,pc[0x64]
80007054:	80 00       	ld.sh	r0,r0[0x0]
80007056:	5f 40       	srge	r0
80007058:	80 00       	ld.sh	r0,r0[0x0]
8000705a:	5f bc       	srhi	r12
8000705c:	80 00       	ld.sh	r0,r0[0x0]
8000705e:	60 50       	ld.w	r0,r0[0x14]
80007060:	00 00       	add	r0,r0
80007062:	0d 9c       	ld.ub	r12,r6[0x1]
80007064:	00 00       	add	r0,r0
80007066:	0d 50       	ld.sh	r0,--r6
80007068:	00 00       	add	r0,r0
8000706a:	0c 9c       	mov	r12,r6
8000706c:	80 00       	ld.sh	r0,r0[0x0]
8000706e:	5f 2c       	srhs	r12
80007070:	00 00       	add	r0,r0
80007072:	0d 68       	ld.uh	r8,--r6
80007074:	00 00       	add	r0,r0
80007076:	0d 84       	ld.ub	r4,r6[0x0]
80007078:	00 00       	add	r0,r0
8000707a:	0d 54       	ld.sh	r4,--r6
8000707c:	00 00       	add	r0,r0
8000707e:	0d 3c       	ld.ub	r12,r6++
80007080:	00 00       	add	r0,r0
80007082:	0d a4       	ld.ub	r4,r6[0x2]
80007084:	00 00       	add	r0,r0
80007086:	0c 88       	andn	r8,r6
80007088:	00 00       	add	r0,r0
8000708a:	0c 98       	mov	r8,r6
8000708c:	00 00       	add	r0,r0
8000708e:	0c 8c       	andn	r12,r6
80007090:	00 00       	add	r0,r0
80007092:	0c 84       	andn	r4,r6
80007094:	00 00       	add	r0,r0
80007096:	0d 98       	ld.ub	r8,r6[0x1]
80007098:	00 00       	add	r0,r0
8000709a:	0d b8       	ld.ub	r8,r6[0x3]
8000709c:	80 00       	ld.sh	r0,r0[0x0]
8000709e:	5f 46       	srge	r6
800070a0:	80 00       	ld.sh	r0,r0[0x0]
800070a2:	61 5c       	ld.w	r12,r0[0x54]

800070a4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800070a4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
800070a6:	30 09       	mov	r9,0
800070a8:	1a d9       	st.w	--sp,r9
800070aa:	1a d9       	st.w	--sp,r9
800070ac:	1a d9       	st.w	--sp,r9
800070ae:	12 98       	mov	r8,r9
800070b0:	e0 6a 01 00 	mov	r10,256
800070b4:	48 9b       	lddpc	r11,800070d8 <vTaskStartScheduler+0x34>
800070b6:	48 ac       	lddpc	r12,800070dc <vTaskStartScheduler+0x38>
800070b8:	f0 1f 00 0a 	mcall	800070e0 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
800070bc:	2f dd       	sub	sp,-12
800070be:	58 1c       	cp.w	r12,1
800070c0:	c0 a1       	brne	800070d4 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800070c2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800070c4:	30 19       	mov	r9,1
800070c6:	48 88       	lddpc	r8,800070e4 <vTaskStartScheduler+0x40>
800070c8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800070ca:	30 09       	mov	r9,0
800070cc:	48 78       	lddpc	r8,800070e8 <vTaskStartScheduler+0x44>
800070ce:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800070d0:	f0 1f 00 07 	mcall	800070ec <vTaskStartScheduler+0x48>
800070d4:	d8 02       	popm	pc
800070d6:	00 00       	add	r0,r0
800070d8:	80 00       	ld.sh	r0,r0[0x0]
800070da:	dc a4       	*unknown*
800070dc:	80 00       	ld.sh	r0,r0[0x0]
800070de:	6e 34       	ld.w	r4,r7[0xc]
800070e0:	80 00       	ld.sh	r0,r0[0x0]
800070e2:	6e bc       	ld.w	r12,r7[0x2c]
800070e4:	00 00       	add	r0,r0
800070e6:	0c 8c       	andn	r12,r6
800070e8:	00 00       	add	r0,r0
800070ea:	0d 7c       	ld.ub	r12,--r6
800070ec:	80 00       	ld.sh	r0,r0[0x0]
800070ee:	60 60       	ld.w	r0,r0[0x18]

800070f0 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
800070f0:	16 cc       	st.b	r11++,r12
	return str;
}
800070f2:	5e fb       	retal	r11

800070f4 <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
800070f4:	eb cd 40 c0 	pushm	r6-r7,lr
800070f8:	20 3d       	sub	sp,12
800070fa:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
800070fc:	30 06       	mov	r6,0
800070fe:	30 07       	mov	r7,0
80007100:	fa e7 00 00 	st.d	sp[0],r6
80007104:	30 0c       	mov	r12,0
80007106:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80007108:	58 08       	cp.w	r8,0
8000710a:	c1 30       	breq	80007130 <PrintHex+0x3c>
8000710c:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
8000710e:	1a 9c       	mov	r12,sp
80007110:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007114:	58 9e       	cp.w	lr,9
80007116:	e0 8a 00 04 	brle	8000711e <PrintHex+0x2a>
8000711a:	2c 9e       	sub	lr,-55
8000711c:	c0 48       	rjmp	80007124 <PrintHex+0x30>
8000711e:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80007122:	2d 0e       	sub	lr,-48
80007124:	f8 09 0b 0e 	st.b	r12[r9],lr
80007128:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
8000712a:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
8000712c:	cf 21       	brne	80007110 <PrintHex+0x1c>
8000712e:	c0 48       	rjmp	80007136 <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80007130:	33 08       	mov	r8,48
80007132:	ba 88       	st.b	sp[0x0],r8
80007134:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80007136:	f6 09 01 08 	sub	r8,r11,r9
8000713a:	58 08       	cp.w	r8,0
8000713c:	e0 8a 00 13 	brle	80007162 <PrintHex+0x6e>
	{
		char num = len - cnt;
80007140:	12 1b       	sub	r11,r9
80007142:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80007146:	18 9e       	mov	lr,r12
80007148:	58 0c       	cp.w	r12,0
8000714a:	e0 8a 00 0c 	brle	80007162 <PrintHex+0x6e>
8000714e:	1a 9b       	mov	r11,sp
80007150:	12 0b       	add	r11,r9
80007152:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007154:	33 07       	mov	r7,48
80007156:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007158:	2f f8       	sub	r8,-1
8000715a:	1c 38       	cp.w	r8,lr
8000715c:	cf d5       	brlt	80007156 <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000715e:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007162:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80007166:	f0 cb ff ff 	sub	r11,r8,-1
8000716a:	58 0b       	cp.w	r11,0
8000716c:	e0 8a 00 19 	brle	8000719e <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80007170:	fa cb ff f4 	sub	r11,sp,-12
80007174:	f6 09 00 09 	add	r9,r11,r9
80007178:	37 8b       	mov	r11,120
8000717a:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
8000717e:	fa c9 ff f4 	sub	r9,sp,-12
80007182:	10 09       	add	r9,r8
80007184:	33 0b       	mov	r11,48
80007186:	f3 6b ff f4 	st.b	r9[-12],r11
8000718a:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
8000718e:	fa ce 00 01 	sub	lr,sp,1
80007192:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80007194:	11 8b       	ld.ub	r11,r8[0x0]
80007196:	12 cb       	st.b	r9++,r11
80007198:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
8000719a:	1c 38       	cp.w	r8,lr
8000719c:	cf c1       	brne	80007194 <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
8000719e:	14 9c       	mov	r12,r10
800071a0:	2f dd       	sub	sp,-12
800071a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

800071a6 <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
800071a6:	d4 21       	pushm	r4-r7,lr
800071a8:	20 3d       	sub	sp,12
800071aa:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
800071ac:	30 06       	mov	r6,0
800071ae:	30 07       	mov	r7,0
800071b0:	fa e7 00 00 	st.d	sp[0],r6
800071b4:	30 0c       	mov	r12,0
800071b6:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
800071b8:	58 08       	cp.w	r8,0
800071ba:	c0 35       	brlt	800071c0 <PrintDec+0x1a>
800071bc:	14 97       	mov	r7,r10
800071be:	c0 58       	rjmp	800071c8 <PrintDec+0x22>
	{
		*p++ = '-';
800071c0:	14 97       	mov	r7,r10
800071c2:	32 d9       	mov	r9,45
800071c4:	0e c9       	st.b	r7++,r9
		i = -i;
800071c6:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
800071c8:	58 08       	cp.w	r8,0
800071ca:	c0 51       	brne	800071d4 <PrintDec+0x2e>
800071cc:	33 08       	mov	r8,48
800071ce:	ba 88       	st.b	sp[0x0],r8
800071d0:	30 1e       	mov	lr,1
800071d2:	c2 f8       	rjmp	80007230 <PrintDec+0x8a>
	
	int ten = i%10;
800071d4:	e0 65 66 67 	mov	r5,26215
800071d8:	ea 15 66 66 	orh	r5,0x6666
800071dc:	f0 05 04 44 	muls.d	r4,r8,r5
800071e0:	ea 0c 14 02 	asr	r12,r5,0x2
800071e4:	f0 09 14 1f 	asr	r9,r8,0x1f
800071e8:	f8 09 01 09 	sub	r9,r12,r9
800071ec:	f2 09 00 29 	add	r9,r9,r9<<0x2
800071f0:	f0 09 01 19 	sub	r9,r8,r9<<0x1
800071f4:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
800071f6:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
800071f8:	e0 66 66 67 	mov	r6,26215
800071fc:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80007200:	2d 09       	sub	r9,-48
80007202:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80007206:	2f fe       	sub	lr,-1
		i /= 10;
80007208:	f0 06 04 44 	muls.d	r4,r8,r6
8000720c:	ea 09 14 02 	asr	r9,r5,0x2
80007210:	bf 58       	asr	r8,0x1f
80007212:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80007216:	f0 06 04 44 	muls.d	r4,r8,r6
8000721a:	ea 09 14 02 	asr	r9,r5,0x2
8000721e:	f0 05 14 1f 	asr	r5,r8,0x1f
80007222:	0a 19       	sub	r9,r5
80007224:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007228:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
8000722c:	58 08       	cp.w	r8,0
8000722e:	ce 91       	brne	80007200 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80007230:	f6 0e 01 08 	sub	r8,r11,lr
80007234:	58 08       	cp.w	r8,0
80007236:	e0 89 00 06 	brgt	80007242 <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
8000723a:	58 0e       	cp.w	lr,0
8000723c:	e0 89 00 14 	brgt	80007264 <PrintDec+0xbe>
80007240:	c1 d8       	rjmp	8000727a <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80007242:	1c 1b       	sub	r11,lr
80007244:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80007246:	16 9c       	mov	r12,r11
80007248:	58 0b       	cp.w	r11,0
8000724a:	fe 9a ff f8 	brle	8000723a <PrintDec+0x94>
8000724e:	1a 99       	mov	r9,sp
80007250:	1c 09       	add	r9,lr
80007252:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80007254:	33 06       	mov	r6,48
80007256:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80007258:	2f f8       	sub	r8,-1
8000725a:	18 38       	cp.w	r8,r12
8000725c:	cf d5       	brlt	80007256 <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
8000725e:	f6 0e 00 0e 	add	lr,r11,lr
80007262:	ce cb       	rjmp	8000723a <PrintDec+0x94>
80007264:	fa c8 ff f4 	sub	r8,sp,-12
80007268:	1c 08       	add	r8,lr
8000726a:	20 d8       	sub	r8,13
8000726c:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80007270:	11 89       	ld.ub	r9,r8[0x0]
80007272:	0e c9       	st.b	r7++,r9
80007274:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80007276:	16 38       	cp.w	r8,r11
80007278:	cf c1       	brne	80007270 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
8000727a:	14 9c       	mov	r12,r10
8000727c:	2f dd       	sub	sp,-12
8000727e:	d8 22       	popm	r4-r7,pc

80007280 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80007280:	d4 31       	pushm	r0-r7,lr
80007282:	fa cd 02 08 	sub	sp,sp,520
80007286:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80007288:	e0 6a 01 00 	mov	r10,256
8000728c:	30 0b       	mov	r11,0
8000728e:	fa cc fe f8 	sub	r12,sp,-264
80007292:	f0 1f 00 4e 	mcall	800073c8 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80007296:	fa c4 fd d4 	sub	r4,sp,-556
8000729a:	30 0a       	mov	r10,0
8000729c:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000729e:	fa c3 ff fc 	sub	r3,sp,-4
800072a2:	e0 61 01 00 	mov	r1,256
800072a6:	14 90       	mov	r0,r10
			
					if(*str == '%')
800072a8:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
800072aa:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
800072ae:	02 9a       	mov	r10,r1
800072b0:	00 9b       	mov	r11,r0
800072b2:	06 9c       	mov	r12,r3
800072b4:	f0 1f 00 45 	mcall	800073c8 <log+0x148>
			
					if(*str == '%')
800072b8:	0f 88       	ld.ub	r8,r7[0x0]
800072ba:	e4 08 18 00 	cp.b	r8,r2
800072be:	c5 71       	brne	8000736c <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
800072c0:	ee c8 ff ff 	sub	r8,r7,-1
800072c4:	11 89       	ld.ub	r9,r8[0x0]
800072c6:	4c 2a       	lddpc	r10,800073cc <log+0x14c>
800072c8:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
800072ca:	23 09       	sub	r9,48
800072cc:	30 9a       	mov	r10,9
800072ce:	f4 09 18 00 	cp.b	r9,r10
800072d2:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
800072d6:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
800072da:	f7 b9 08 30 	subls	r9,48
800072de:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
800072e2:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
800072e6:	0f 88       	ld.ub	r8,r7[0x0]
800072e8:	22 58       	sub	r8,37
800072ea:	e0 48 00 53 	cp.w	r8,83
800072ee:	e0 8b 00 31 	brhi	80007350 <log+0xd0>
800072f2:	4b 89       	lddpc	r9,800073d0 <log+0x150>
800072f4:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
800072f8:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
800072fc:	06 9a       	mov	r10,r3
800072fe:	40 0b       	lddsp	r11,sp[0x0]
80007300:	5c 5b       	castu.b	r11
80007302:	68 0c       	ld.w	r12,r4[0x0]
80007304:	f0 1f 00 34 	mcall	800073d4 <log+0x154>
							break;
80007308:	c2 98       	rjmp	8000735a <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
8000730a:	4b 4c       	lddpc	r12,800073d8 <log+0x158>
8000730c:	f0 1f 00 34 	mcall	800073dc <log+0x15c>
80007310:	08 95       	mov	r5,r4
80007312:	06 9c       	mov	r12,r3
							break;
80007314:	c2 38       	rjmp	8000735a <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80007316:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
8000731a:	06 9a       	mov	r10,r3
8000731c:	40 0b       	lddsp	r11,sp[0x0]
8000731e:	5c 5b       	castu.b	r11
80007320:	68 0c       	ld.w	r12,r4[0x0]
80007322:	f0 1f 00 30 	mcall	800073e0 <log+0x160>
80007326:	06 9c       	mov	r12,r3
							break;
80007328:	c1 98       	rjmp	8000735a <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
8000732a:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
8000732e:	06 9b       	mov	r11,r3
80007330:	09 bc       	ld.ub	r12,r4[0x3]
80007332:	f0 1f 00 2d 	mcall	800073e4 <log+0x164>
80007336:	06 9c       	mov	r12,r3
							break;
80007338:	c1 18       	rjmp	8000735a <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
8000733a:	e8 c5 ff fc 	sub	r5,r4,-4
8000733e:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80007340:	c0 d8       	rjmp	8000735a <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80007342:	06 9b       	mov	r11,r3
80007344:	32 5c       	mov	r12,37
80007346:	f0 1f 00 28 	mcall	800073e4 <log+0x164>
8000734a:	08 95       	mov	r5,r4
8000734c:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
8000734e:	c0 68       	rjmp	8000735a <log+0xda>
							
							default:
							log("I need relax.");
80007350:	4a 6c       	lddpc	r12,800073e8 <log+0x168>
80007352:	f0 1f 00 23 	mcall	800073dc <log+0x15c>
80007356:	08 95       	mov	r5,r4
80007358:	06 9c       	mov	r12,r3
						}
						str++;
8000735a:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
8000735c:	1a dc       	st.w	--sp,r12
8000735e:	1a d6       	st.w	--sp,r6
80007360:	4a 3b       	lddpc	r11,800073ec <log+0x16c>
80007362:	0c 9c       	mov	r12,r6
80007364:	f0 1f 00 23 	mcall	800073f0 <log+0x170>
80007368:	2f ed       	sub	sp,-8
8000736a:	c0 a8       	rjmp	8000737e <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
8000736c:	2f f7       	sub	r7,-1
8000736e:	1a d8       	st.w	--sp,r8
80007370:	1a d6       	st.w	--sp,r6
80007372:	4a 1b       	lddpc	r11,800073f4 <log+0x174>
80007374:	0c 9c       	mov	r12,r6
80007376:	f0 1f 00 1f 	mcall	800073f0 <log+0x170>
8000737a:	08 95       	mov	r5,r4
8000737c:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
8000737e:	0f 89       	ld.ub	r9,r7[0x0]
80007380:	30 08       	mov	r8,0
80007382:	f0 09 18 00 	cp.b	r9,r8
80007386:	c0 30       	breq	8000738c <log+0x10c>
80007388:	0a 94       	mov	r4,r5
8000738a:	c9 2b       	rjmp	800072ae <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
8000738c:	fa c7 fe f8 	sub	r7,sp,-264
80007390:	1a d7       	st.w	--sp,r7
80007392:	49 ab       	lddpc	r11,800073f8 <log+0x178>
80007394:	0e 9c       	mov	r12,r7
80007396:	f0 1f 00 17 	mcall	800073f0 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
8000739a:	5c 5c       	castu.b	r12
8000739c:	f8 c6 ff ff 	sub	r6,r12,-1
800073a0:	0c 9c       	mov	r12,r6
800073a2:	f0 1f 00 17 	mcall	800073fc <log+0x17c>
800073a6:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
800073a8:	0c 9a       	mov	r10,r6
800073aa:	0e 9b       	mov	r11,r7
800073ac:	f0 1f 00 15 	mcall	80007400 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
800073b0:	30 09       	mov	r9,0
800073b2:	30 5a       	mov	r10,5
800073b4:	fa cb fe f8 	sub	r11,sp,-264
800073b8:	49 38       	lddpc	r8,80007404 <log+0x184>
800073ba:	70 0c       	ld.w	r12,r8[0x0]
800073bc:	f0 1f 00 13 	mcall	80007408 <log+0x188>
800073c0:	2f fd       	sub	sp,-4
	
	
}
800073c2:	fe 3d fd f8 	sub	sp,-520
800073c6:	d8 32       	popm	r0-r7,pc
800073c8:	80 00       	ld.sh	r0,r0[0x0]
800073ca:	7c 6a       	ld.w	r10,lr[0x18]
800073cc:	00 00       	add	r0,r0
800073ce:	0d bc       	ld.ub	r12,r6[0x3]
800073d0:	80 00       	ld.sh	r0,r0[0x0]
800073d2:	dc ac       	*unknown*
800073d4:	80 00       	ld.sh	r0,r0[0x0]
800073d6:	71 a6       	ld.w	r6,r8[0x68]
800073d8:	80 00       	ld.sh	r0,r0[0x0]
800073da:	df 58       	*unknown*
800073dc:	80 00       	ld.sh	r0,r0[0x0]
800073de:	72 80       	ld.w	r0,r9[0x20]
800073e0:	80 00       	ld.sh	r0,r0[0x0]
800073e2:	70 f4       	ld.w	r4,r8[0x3c]
800073e4:	80 00       	ld.sh	r0,r0[0x0]
800073e6:	70 f0       	ld.w	r0,r8[0x3c]
800073e8:	80 00       	ld.sh	r0,r0[0x0]
800073ea:	df 68       	*unknown*
800073ec:	80 00       	ld.sh	r0,r0[0x0]
800073ee:	df 78       	*unknown*
800073f0:	80 00       	ld.sh	r0,r0[0x0]
800073f2:	7f 58       	ld.w	r8,pc[0x54]
800073f4:	80 00       	ld.sh	r0,r0[0x0]
800073f6:	df 80       	acall	0xf8
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	df 88       	*unknown*
800073fc:	80 00       	ld.sh	r0,r0[0x0]
800073fe:	62 bc       	ld.w	r12,r1[0x2c]
80007400:	80 00       	ld.sh	r0,r0[0x0]
80007402:	7b 22       	ld.w	r2,sp[0x48]
80007404:	00 00       	add	r0,r0
80007406:	54 1c       	stdsp	sp[0x104],r12
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	66 10       	ld.w	r0,r3[0x4]

8000740c <logFromISR>:
	
	
int logFromISR(char * content, ...)
	{
8000740c:	d4 31       	pushm	r0-r7,lr
8000740e:	fa cd 02 0c 	sub	sp,sp,524
80007412:	18 97       	mov	r7,r12
		
		
		char logTmp[MAX_LOG_LINE_SIZE];
		memset(logTmp, '\0', MAX_LOG_LINE_SIZE);
80007414:	e0 6a 01 00 	mov	r10,256
80007418:	30 0b       	mov	r11,0
8000741a:	fa cc fe f4 	sub	r12,sp,-268
8000741e:	f0 1f 00 4c 	mcall	8000754c <logFromISR+0x140>
	
	
}
	
	
int logFromISR(char * content, ...)
80007422:	fa c4 fd d0 	sub	r4,sp,-560
80007426:	30 0a       	mov	r10,0
80007428:	50 0a       	stdsp	sp[0x0],r10
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000742a:	fa c3 ff fc 	sub	r3,sp,-4
8000742e:	e0 61 01 00 	mov	r1,256
80007432:	14 90       	mov	r0,r10
			
			if(*str == '%')
80007434:	32 52       	mov	r2,37
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
80007436:	fa c6 fe f4 	sub	r6,sp,-268
		//}
		
		do
		{
			char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
			memset(strTmp, 0, MAX_LOG_LINE_SIZE);
8000743a:	02 9a       	mov	r10,r1
8000743c:	00 9b       	mov	r11,r0
8000743e:	06 9c       	mov	r12,r3
80007440:	f0 1f 00 43 	mcall	8000754c <logFromISR+0x140>
			
			if(*str == '%')
80007444:	0f 88       	ld.ub	r8,r7[0x0]
80007446:	e4 08 18 00 	cp.b	r8,r2
8000744a:	c5 11       	brne	800074ec <logFromISR+0xe0>
			{
				static char lench = 0;
				lench =*(str + 1);
8000744c:	ee c8 ff ff 	sub	r8,r7,-1
80007450:	11 89       	ld.ub	r9,r8[0x0]
80007452:	4c 0a       	lddpc	r10,80007550 <logFromISR+0x144>
80007454:	b4 89       	st.b	r10[0x0],r9
				if((lench >= '0') &&  (lench <= '9'))
80007456:	23 09       	sub	r9,48
80007458:	30 9a       	mov	r10,9
8000745a:	f4 09 18 00 	cp.b	r9,r10
8000745e:	ee 08 17 b0 	movhi	r8,r7
				{
					len = *(++str) - '0';
80007462:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80007466:	f7 b9 08 30 	subls	r9,48
8000746a:	fb f9 8a 00 	st.wls	sp[0x0],r9
				}
				
				str++;
8000746e:	f0 c7 ff ff 	sub	r7,r8,-1
				
				switch(*(str))
80007472:	0f 88       	ld.ub	r8,r7[0x0]
80007474:	22 58       	sub	r8,37
80007476:	e0 48 00 53 	cp.w	r8,83
8000747a:	e0 8b 00 2b 	brhi	800074d0 <logFromISR+0xc4>
8000747e:	4b 69       	lddpc	r9,80007554 <logFromISR+0x148>
80007480:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
				{
					case('d'):
					case('D'):
					x = va_arg(arg_ptr,int);
80007484:	e8 c5 ff fc 	sub	r5,r4,-4
					strTmp = PrintDec(x, len, strTmp);
80007488:	06 9a       	mov	r10,r3
8000748a:	40 0b       	lddsp	r11,sp[0x0]
8000748c:	5c 5b       	castu.b	r11
8000748e:	68 0c       	ld.w	r12,r4[0x0]
80007490:	f0 1f 00 32 	mcall	80007558 <logFromISR+0x14c>
					break;
80007494:	c2 38       	rjmp	800074da <logFromISR+0xce>
					case('x'):
					case('X'):
					x = va_arg(arg_ptr,int);
80007496:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintHex(x,len, strTmp);
8000749a:	06 9a       	mov	r10,r3
8000749c:	40 0b       	lddsp	r11,sp[0x0]
8000749e:	5c 5b       	castu.b	r11
800074a0:	68 0c       	ld.w	r12,r4[0x0]
800074a2:	f0 1f 00 2f 	mcall	8000755c <logFromISR+0x150>
800074a6:	06 9c       	mov	r12,r3
					break;
800074a8:	c1 98       	rjmp	800074da <logFromISR+0xce>
					case('c'):
					case('C'):
					y = va_arg(arg_ptr,int);
800074aa:	e8 c5 ff fc 	sub	r5,r4,-4
					PrintChar(y, strTmp);
800074ae:	06 9b       	mov	r11,r3
800074b0:	09 bc       	ld.ub	r12,r4[0x3]
800074b2:	f0 1f 00 2c 	mcall	80007560 <logFromISR+0x154>
800074b6:	06 9c       	mov	r12,r3
					break;
800074b8:	c1 18       	rjmp	800074da <logFromISR+0xce>
					case('s'):
					case('S'):
					strTmp = va_arg(arg_ptr,char*);
800074ba:	e8 c5 ff fc 	sub	r5,r4,-4
800074be:	68 0c       	ld.w	r12,r4[0x0]
					//PrintStr(s);
					break;
800074c0:	c0 d8       	rjmp	800074da <logFromISR+0xce>
					case('%'):
					PrintChar('%', strTmp);
800074c2:	06 9b       	mov	r11,r3
800074c4:	32 5c       	mov	r12,37
800074c6:	f0 1f 00 27 	mcall	80007560 <logFromISR+0x154>
800074ca:	08 95       	mov	r5,r4
800074cc:	06 9c       	mov	r12,r3
					//PrintChar('%');
					break;
800074ce:	c0 68       	rjmp	800074da <logFromISR+0xce>
					default:
					log("I need relax.");
800074d0:	4a 5c       	lddpc	r12,80007564 <logFromISR+0x158>
800074d2:	f0 1f 00 26 	mcall	80007568 <logFromISR+0x15c>
800074d6:	08 95       	mov	r5,r4
800074d8:	06 9c       	mov	r12,r3
				}
				str++;
800074da:	2f f7       	sub	r7,-1
				
				length = sprintf(logTmp,"%s%s",logTmp,strTmp );
800074dc:	1a dc       	st.w	--sp,r12
800074de:	1a d6       	st.w	--sp,r6
800074e0:	4a 3b       	lddpc	r11,8000756c <logFromISR+0x160>
800074e2:	0c 9c       	mov	r12,r6
800074e4:	f0 1f 00 23 	mcall	80007570 <logFromISR+0x164>
800074e8:	2f ed       	sub	sp,-8
800074ea:	c0 a8       	rjmp	800074fe <logFromISR+0xf2>
			//}
			//else
			//length = sprintf(logTmp,"%s%c",logTmp, *str++);
			//}
			else
			length = sprintf(logTmp,"%s%c",logTmp, *str++);
800074ec:	2f f7       	sub	r7,-1
800074ee:	1a d8       	st.w	--sp,r8
800074f0:	1a d6       	st.w	--sp,r6
800074f2:	4a 1b       	lddpc	r11,80007574 <logFromISR+0x168>
800074f4:	0c 9c       	mov	r12,r6
800074f6:	f0 1f 00 1f 	mcall	80007570 <logFromISR+0x164>
800074fa:	08 95       	mov	r5,r4
800074fc:	2f ed       	sub	sp,-8
			
			
			
		}while(*str != '\0');
800074fe:	0f 89       	ld.ub	r9,r7[0x0]
80007500:	30 08       	mov	r8,0
80007502:	f0 09 18 00 	cp.b	r9,r8
80007506:	c0 30       	breq	8000750c <logFromISR+0x100>
80007508:	0a 94       	mov	r4,r5
8000750a:	c9 8b       	rjmp	8000743a <logFromISR+0x2e>
		
		
		
		va_end(arg_ptr);
		//while(1)
		length = sprintf(logTmp,"%s\r\n",logTmp);
8000750c:	fa c7 fe f4 	sub	r7,sp,-268
80007510:	1a d7       	st.w	--sp,r7
80007512:	49 ab       	lddpc	r11,80007578 <logFromISR+0x16c>
80007514:	0e 9c       	mov	r12,r7
80007516:	f0 1f 00 17 	mcall	80007570 <logFromISR+0x164>
		
		char * p = pvPortMalloc(length+1);
8000751a:	5c 5c       	castu.b	r12
8000751c:	f8 c6 ff ff 	sub	r6,r12,-1
80007520:	0c 9c       	mov	r12,r6
80007522:	f0 1f 00 17 	mcall	8000757c <logFromISR+0x170>
80007526:	54 3c       	stdsp	sp[0x10c],r12
		memcpy(p, logTmp, length+1);
80007528:	0c 9a       	mov	r10,r6
8000752a:	0e 9b       	mov	r11,r7
8000752c:	f0 1f 00 15 	mcall	80007580 <logFromISR+0x174>
		//
		portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
80007530:	30 09       	mov	r9,0
80007532:	54 29       	stdsp	sp[0x108],r9
		
		//usart_write_line(EXAMPLE_USART, p);
		//vPortFree(p);
		xQueueSendFromISR( logQueue, &p, &xHigherPriorityTaskWoken );
80007534:	fa ca fe f8 	sub	r10,sp,-264
80007538:	fa cb fe f4 	sub	r11,sp,-268
8000753c:	49 28       	lddpc	r8,80007584 <logFromISR+0x178>
8000753e:	70 0c       	ld.w	r12,r8[0x0]
80007540:	f0 1f 00 12 	mcall	80007588 <logFromISR+0x17c>
80007544:	2f fd       	sub	sp,-4
		
		//if (xHigherPriorityTaskWoken == pdTRUE)
		//{
			////taskYIELD();
		//}
	}
80007546:	fe 3d fd f4 	sub	sp,-524
8000754a:	d8 32       	popm	r0-r7,pc
8000754c:	80 00       	ld.sh	r0,r0[0x0]
8000754e:	7c 6a       	ld.w	r10,lr[0x18]
80007550:	00 00       	add	r0,r0
80007552:	0d bd       	ld.ub	sp,r6[0x3]
80007554:	80 00       	ld.sh	r0,r0[0x0]
80007556:	dd fc       	*unknown*
80007558:	80 00       	ld.sh	r0,r0[0x0]
8000755a:	71 a6       	ld.w	r6,r8[0x68]
8000755c:	80 00       	ld.sh	r0,r0[0x0]
8000755e:	70 f4       	ld.w	r4,r8[0x3c]
80007560:	80 00       	ld.sh	r0,r0[0x0]
80007562:	70 f0       	ld.w	r0,r8[0x3c]
80007564:	80 00       	ld.sh	r0,r0[0x0]
80007566:	df 68       	*unknown*
80007568:	80 00       	ld.sh	r0,r0[0x0]
8000756a:	72 80       	ld.w	r0,r9[0x20]
8000756c:	80 00       	ld.sh	r0,r0[0x0]
8000756e:	df 78       	*unknown*
80007570:	80 00       	ld.sh	r0,r0[0x0]
80007572:	7f 58       	ld.w	r8,pc[0x54]
80007574:	80 00       	ld.sh	r0,r0[0x0]
80007576:	df 80       	acall	0xf8
80007578:	80 00       	ld.sh	r0,r0[0x0]
8000757a:	df 88       	*unknown*
8000757c:	80 00       	ld.sh	r0,r0[0x0]
8000757e:	62 bc       	ld.w	r12,r1[0x2c]
80007580:	80 00       	ld.sh	r0,r0[0x0]
80007582:	7b 22       	ld.w	r2,sp[0x48]
80007584:	00 00       	add	r0,r0
80007586:	54 1c       	stdsp	sp[0x104],r12
80007588:	80 00       	ld.sh	r0,r0[0x0]
8000758a:	65 c0       	ld.w	r0,r2[0x70]

8000758c <log_init>:
		
	return str;
}

void log_init(void)
{
8000758c:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
8000758e:	30 2b       	mov	r11,2
80007590:	48 fc       	lddpc	r12,800075cc <log_init+0x40>
80007592:	f0 1f 00 10 	mcall	800075d0 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80007596:	e0 6a 36 00 	mov	r10,13824
8000759a:	ea 1a 01 6e 	orh	r10,0x16e
8000759e:	48 eb       	lddpc	r11,800075d4 <log_init+0x48>
800075a0:	fe 7c 18 00 	mov	r12,-59392
800075a4:	f0 1f 00 0d 	mcall	800075d8 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
800075a8:	30 4b       	mov	r11,4
800075aa:	33 2c       	mov	r12,50
800075ac:	f0 1f 00 0c 	mcall	800075dc <log_init+0x50>
800075b0:	48 c8       	lddpc	r8,800075e0 <log_init+0x54>
800075b2:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800075b4:	30 09       	mov	r9,0
800075b6:	1a d9       	st.w	--sp,r9
800075b8:	1a d9       	st.w	--sp,r9
800075ba:	1a d9       	st.w	--sp,r9
800075bc:	30 28       	mov	r8,2
800075be:	36 4a       	mov	r10,100
800075c0:	48 9b       	lddpc	r11,800075e4 <log_init+0x58>
800075c2:	48 ac       	lddpc	r12,800075e8 <log_init+0x5c>
800075c4:	f0 1f 00 0a 	mcall	800075ec <log_init+0x60>
800075c8:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
800075ca:	d8 02       	popm	pc
800075cc:	80 00       	ld.sh	r0,r0[0x0]
800075ce:	df 94       	*unknown*
800075d0:	80 00       	ld.sh	r0,r0[0x0]
800075d2:	58 ec       	cp.w	r12,14
800075d4:	80 00       	ld.sh	r0,r0[0x0]
800075d6:	df 4c       	*unknown*
800075d8:	80 00       	ld.sh	r0,r0[0x0]
800075da:	5e 20       	reths	r0
800075dc:	80 00       	ld.sh	r0,r0[0x0]
800075de:	67 68       	ld.w	r8,r3[0x58]
800075e0:	00 00       	add	r0,r0
800075e2:	54 1c       	stdsp	sp[0x104],r12
800075e4:	80 00       	ld.sh	r0,r0[0x0]
800075e6:	df 90       	acall	0xf9
800075e8:	80 00       	ld.sh	r0,r0[0x0]
800075ea:	75 f0       	ld.w	r0,r10[0x7c]
800075ec:	80 00       	ld.sh	r0,r0[0x0]
800075ee:	6e bc       	ld.w	r12,r7[0x2c]

800075f0 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
800075f0:	eb cd 40 f8 	pushm	r3-r7,lr
800075f4:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
800075f6:	48 c7       	lddpc	r7,80007624 <task_log+0x34>
800075f8:	30 05       	mov	r5,0
800075fa:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
800075fc:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80007600:	0a 99       	mov	r9,r5
80007602:	08 9a       	mov	r10,r4
80007604:	1a 9b       	mov	r11,sp
80007606:	6e 0c       	ld.w	r12,r7[0x0]
80007608:	f0 1f 00 08 	mcall	80007628 <task_log+0x38>
8000760c:	58 1c       	cp.w	r12,1
8000760e:	cf 91       	brne	80007600 <task_log+0x10>
		{
			if( NULL != str)
80007610:	40 0b       	lddsp	r11,sp[0x0]
80007612:	58 0b       	cp.w	r11,0
80007614:	cf 60       	breq	80007600 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80007616:	06 9c       	mov	r12,r3
80007618:	f0 1f 00 05 	mcall	8000762c <task_log+0x3c>
				vPortFree(str);
8000761c:	40 0c       	lddsp	r12,sp[0x0]
8000761e:	f0 1f 00 05 	mcall	80007630 <task_log+0x40>
80007622:	ce fb       	rjmp	80007600 <task_log+0x10>
80007624:	00 00       	add	r0,r0
80007626:	54 1c       	stdsp	sp[0x104],r12
80007628:	80 00       	ld.sh	r0,r0[0x0]
8000762a:	64 04       	ld.w	r4,r2[0x0]
8000762c:	80 00       	ld.sh	r0,r0[0x0]
8000762e:	5d d0       	*unknown*
80007630:	80 00       	ld.sh	r0,r0[0x0]
80007632:	62 94       	ld.w	r4,r1[0x24]

80007634 <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80007634:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80007636:	fe 78 10 00 	mov	r8,-61440
8000763a:	30 19       	mov	r9,1
8000763c:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80007640:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80007644:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80007648:	d3 03       	ssrf	0x10
	local_start_pll0();
8000764a:	f0 1f 00 0c 	mcall	80007678 <main+0x44>
		
	INTC_init_interrupts();
8000764e:	f0 1f 00 0c 	mcall	8000767c <main+0x48>
		
	log_init();
80007652:	f0 1f 00 0c 	mcall	80007680 <main+0x4c>
	log("----start debug----");
80007656:	48 cc       	lddpc	r12,80007684 <main+0x50>
80007658:	f0 1f 00 0c 	mcall	80007688 <main+0x54>
	
	xg_flashc_init();
8000765c:	f0 1f 00 0c 	mcall	8000768c <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80007660:	f0 1f 00 0c 	mcall	80007690 <main+0x5c>
		
	app_init();
80007664:	f0 1f 00 0c 	mcall	80007694 <main+0x60>
		
	xcmp_init();
80007668:	f0 1f 00 0c 	mcall	80007698 <main+0x64>

	local_start_timer();
8000766c:	f0 1f 00 0c 	mcall	8000769c <main+0x68>
	
	//xg_rtc_init();
		
	vTaskStartScheduler();
80007670:	f0 1f 00 0c 	mcall	800076a0 <main+0x6c>
	return 0;
	
}
80007674:	d8 0a       	popm	pc,r12=0
80007676:	00 00       	add	r0,r0
80007678:	80 00       	ld.sh	r0,r0[0x0]
8000767a:	50 08       	stdsp	sp[0x0],r8
8000767c:	80 00       	ld.sh	r0,r0[0x0]
8000767e:	59 f0       	cp.w	r0,31
80007680:	80 00       	ld.sh	r0,r0[0x0]
80007682:	75 8c       	ld.w	r12,r10[0x60]
80007684:	80 00       	ld.sh	r0,r0[0x0]
80007686:	df a4       	*unknown*
80007688:	80 00       	ld.sh	r0,r0[0x0]
8000768a:	72 80       	ld.w	r0,r9[0x20]
8000768c:	80 00       	ld.sh	r0,r0[0x0]
8000768e:	50 ec       	stdsp	sp[0x38],r12
80007690:	80 00       	ld.sh	r0,r0[0x0]
80007692:	4f fc       	lddpc	r12,8000788c <_malloc_r+0x1c8>
80007694:	80 00       	ld.sh	r0,r0[0x0]
80007696:	20 3c       	sub	r12,3
80007698:	80 00       	ld.sh	r0,r0[0x0]
8000769a:	3f 18       	mov	r8,-15
8000769c:	80 00       	ld.sh	r0,r0[0x0]
8000769e:	50 c0       	stdsp	sp[0x30],r0
800076a0:	80 00       	ld.sh	r0,r0[0x0]
800076a2:	70 a4       	ld.w	r4,r8[0x28]

800076a4 <free>:
800076a4:	d4 01       	pushm	lr
800076a6:	e0 68 0a 48 	mov	r8,2632
800076aa:	18 9b       	mov	r11,r12
800076ac:	70 0c       	ld.w	r12,r8[0x0]
800076ae:	e0 a0 1e 73 	rcall	8000b394 <_free_r>
800076b2:	d8 02       	popm	pc

800076b4 <malloc>:
800076b4:	d4 01       	pushm	lr
800076b6:	e0 68 0a 48 	mov	r8,2632
800076ba:	18 9b       	mov	r11,r12
800076bc:	70 0c       	ld.w	r12,r8[0x0]
800076be:	c0 3c       	rcall	800076c4 <_malloc_r>
800076c0:	d8 02       	popm	pc
800076c2:	d7 03       	nop

800076c4 <_malloc_r>:
800076c4:	d4 31       	pushm	r0-r7,lr
800076c6:	f6 c8 ff f5 	sub	r8,r11,-11
800076ca:	18 95       	mov	r5,r12
800076cc:	10 97       	mov	r7,r8
800076ce:	e0 17 ff f8 	andl	r7,0xfff8
800076d2:	59 68       	cp.w	r8,22
800076d4:	f9 b7 08 10 	movls	r7,16
800076d8:	16 37       	cp.w	r7,r11
800076da:	5f 38       	srlo	r8
800076dc:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
800076e0:	c0 50       	breq	800076ea <_malloc_r+0x26>
800076e2:	30 c8       	mov	r8,12
800076e4:	99 38       	st.w	r12[0xc],r8
800076e6:	e0 8f 01 fa 	bral	80007ada <_malloc_r+0x416>
800076ea:	fe b0 f5 8b 	rcall	80006200 <__malloc_lock>
800076ee:	e0 47 01 f7 	cp.w	r7,503
800076f2:	e0 8b 00 1d 	brhi	8000772c <_malloc_r+0x68>
800076f6:	ee 03 16 03 	lsr	r3,r7,0x3
800076fa:	e0 68 05 48 	mov	r8,1352
800076fe:	f0 03 00 38 	add	r8,r8,r3<<0x3
80007702:	70 36       	ld.w	r6,r8[0xc]
80007704:	10 36       	cp.w	r6,r8
80007706:	c0 61       	brne	80007712 <_malloc_r+0x4e>
80007708:	ec c8 ff f8 	sub	r8,r6,-8
8000770c:	70 36       	ld.w	r6,r8[0xc]
8000770e:	10 36       	cp.w	r6,r8
80007710:	c0 c0       	breq	80007728 <_malloc_r+0x64>
80007712:	6c 18       	ld.w	r8,r6[0x4]
80007714:	e0 18 ff fc 	andl	r8,0xfffc
80007718:	6c 3a       	ld.w	r10,r6[0xc]
8000771a:	ec 08 00 09 	add	r9,r6,r8
8000771e:	0a 9c       	mov	r12,r5
80007720:	6c 28       	ld.w	r8,r6[0x8]
80007722:	95 28       	st.w	r10[0x8],r8
80007724:	91 3a       	st.w	r8[0xc],r10
80007726:	c4 78       	rjmp	800077b4 <_malloc_r+0xf0>
80007728:	2f e3       	sub	r3,-2
8000772a:	c4 d8       	rjmp	800077c4 <_malloc_r+0x100>
8000772c:	ee 03 16 09 	lsr	r3,r7,0x9
80007730:	c0 41       	brne	80007738 <_malloc_r+0x74>
80007732:	ee 03 16 03 	lsr	r3,r7,0x3
80007736:	c2 68       	rjmp	80007782 <_malloc_r+0xbe>
80007738:	58 43       	cp.w	r3,4
8000773a:	e0 8b 00 06 	brhi	80007746 <_malloc_r+0x82>
8000773e:	ee 03 16 06 	lsr	r3,r7,0x6
80007742:	2c 83       	sub	r3,-56
80007744:	c1 f8       	rjmp	80007782 <_malloc_r+0xbe>
80007746:	59 43       	cp.w	r3,20
80007748:	e0 8b 00 04 	brhi	80007750 <_malloc_r+0x8c>
8000774c:	2a 53       	sub	r3,-91
8000774e:	c1 a8       	rjmp	80007782 <_malloc_r+0xbe>
80007750:	e0 43 00 54 	cp.w	r3,84
80007754:	e0 8b 00 06 	brhi	80007760 <_malloc_r+0x9c>
80007758:	ee 03 16 0c 	lsr	r3,r7,0xc
8000775c:	29 23       	sub	r3,-110
8000775e:	c1 28       	rjmp	80007782 <_malloc_r+0xbe>
80007760:	e0 43 01 54 	cp.w	r3,340
80007764:	e0 8b 00 06 	brhi	80007770 <_malloc_r+0xac>
80007768:	ee 03 16 0f 	lsr	r3,r7,0xf
8000776c:	28 93       	sub	r3,-119
8000776e:	c0 a8       	rjmp	80007782 <_malloc_r+0xbe>
80007770:	e0 43 05 54 	cp.w	r3,1364
80007774:	e0 88 00 04 	brls	8000777c <_malloc_r+0xb8>
80007778:	37 e3       	mov	r3,126
8000777a:	c0 48       	rjmp	80007782 <_malloc_r+0xbe>
8000777c:	ee 03 16 12 	lsr	r3,r7,0x12
80007780:	28 43       	sub	r3,-124
80007782:	e0 6a 05 48 	mov	r10,1352
80007786:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000778a:	74 36       	ld.w	r6,r10[0xc]
8000778c:	c1 98       	rjmp	800077be <_malloc_r+0xfa>
8000778e:	6c 19       	ld.w	r9,r6[0x4]
80007790:	e0 19 ff fc 	andl	r9,0xfffc
80007794:	f2 07 01 0b 	sub	r11,r9,r7
80007798:	58 fb       	cp.w	r11,15
8000779a:	e0 8a 00 04 	brle	800077a2 <_malloc_r+0xde>
8000779e:	20 13       	sub	r3,1
800077a0:	c1 18       	rjmp	800077c2 <_malloc_r+0xfe>
800077a2:	6c 38       	ld.w	r8,r6[0xc]
800077a4:	58 0b       	cp.w	r11,0
800077a6:	c0 b5       	brlt	800077bc <_malloc_r+0xf8>
800077a8:	6c 2a       	ld.w	r10,r6[0x8]
800077aa:	ec 09 00 09 	add	r9,r6,r9
800077ae:	0a 9c       	mov	r12,r5
800077b0:	91 2a       	st.w	r8[0x8],r10
800077b2:	95 38       	st.w	r10[0xc],r8
800077b4:	72 18       	ld.w	r8,r9[0x4]
800077b6:	a1 a8       	sbr	r8,0x0
800077b8:	93 18       	st.w	r9[0x4],r8
800077ba:	cb c8       	rjmp	80007932 <_malloc_r+0x26e>
800077bc:	10 96       	mov	r6,r8
800077be:	14 36       	cp.w	r6,r10
800077c0:	ce 71       	brne	8000778e <_malloc_r+0xca>
800077c2:	2f f3       	sub	r3,-1
800077c4:	e0 6a 05 48 	mov	r10,1352
800077c8:	f4 cc ff f8 	sub	r12,r10,-8
800077cc:	78 26       	ld.w	r6,r12[0x8]
800077ce:	18 36       	cp.w	r6,r12
800077d0:	c6 c0       	breq	800078a8 <_malloc_r+0x1e4>
800077d2:	6c 19       	ld.w	r9,r6[0x4]
800077d4:	e0 19 ff fc 	andl	r9,0xfffc
800077d8:	f2 07 01 08 	sub	r8,r9,r7
800077dc:	58 f8       	cp.w	r8,15
800077de:	e0 89 00 8f 	brgt	800078fc <_malloc_r+0x238>
800077e2:	99 3c       	st.w	r12[0xc],r12
800077e4:	99 2c       	st.w	r12[0x8],r12
800077e6:	58 08       	cp.w	r8,0
800077e8:	c0 55       	brlt	800077f2 <_malloc_r+0x12e>
800077ea:	ec 09 00 09 	add	r9,r6,r9
800077ee:	0a 9c       	mov	r12,r5
800077f0:	ce 2b       	rjmp	800077b4 <_malloc_r+0xf0>
800077f2:	e0 49 01 ff 	cp.w	r9,511
800077f6:	e0 8b 00 13 	brhi	8000781c <_malloc_r+0x158>
800077fa:	a3 99       	lsr	r9,0x3
800077fc:	f4 09 00 38 	add	r8,r10,r9<<0x3
80007800:	70 2b       	ld.w	r11,r8[0x8]
80007802:	8d 38       	st.w	r6[0xc],r8
80007804:	8d 2b       	st.w	r6[0x8],r11
80007806:	97 36       	st.w	r11[0xc],r6
80007808:	91 26       	st.w	r8[0x8],r6
8000780a:	a3 49       	asr	r9,0x2
8000780c:	74 18       	ld.w	r8,r10[0x4]
8000780e:	30 1b       	mov	r11,1
80007810:	f6 09 09 49 	lsl	r9,r11,r9
80007814:	f1 e9 10 09 	or	r9,r8,r9
80007818:	95 19       	st.w	r10[0x4],r9
8000781a:	c4 78       	rjmp	800078a8 <_malloc_r+0x1e4>
8000781c:	f2 0a 16 09 	lsr	r10,r9,0x9
80007820:	58 4a       	cp.w	r10,4
80007822:	e0 8b 00 07 	brhi	80007830 <_malloc_r+0x16c>
80007826:	f2 0a 16 06 	lsr	r10,r9,0x6
8000782a:	2c 8a       	sub	r10,-56
8000782c:	c2 08       	rjmp	8000786c <_malloc_r+0x1a8>
8000782e:	d7 03       	nop
80007830:	59 4a       	cp.w	r10,20
80007832:	e0 8b 00 04 	brhi	8000783a <_malloc_r+0x176>
80007836:	2a 5a       	sub	r10,-91
80007838:	c1 a8       	rjmp	8000786c <_malloc_r+0x1a8>
8000783a:	e0 4a 00 54 	cp.w	r10,84
8000783e:	e0 8b 00 06 	brhi	8000784a <_malloc_r+0x186>
80007842:	f2 0a 16 0c 	lsr	r10,r9,0xc
80007846:	29 2a       	sub	r10,-110
80007848:	c1 28       	rjmp	8000786c <_malloc_r+0x1a8>
8000784a:	e0 4a 01 54 	cp.w	r10,340
8000784e:	e0 8b 00 06 	brhi	8000785a <_malloc_r+0x196>
80007852:	f2 0a 16 0f 	lsr	r10,r9,0xf
80007856:	28 9a       	sub	r10,-119
80007858:	c0 a8       	rjmp	8000786c <_malloc_r+0x1a8>
8000785a:	e0 4a 05 54 	cp.w	r10,1364
8000785e:	e0 88 00 04 	brls	80007866 <_malloc_r+0x1a2>
80007862:	37 ea       	mov	r10,126
80007864:	c0 48       	rjmp	8000786c <_malloc_r+0x1a8>
80007866:	f2 0a 16 12 	lsr	r10,r9,0x12
8000786a:	28 4a       	sub	r10,-124
8000786c:	e0 6b 05 48 	mov	r11,1352
80007870:	f6 0a 00 34 	add	r4,r11,r10<<0x3
80007874:	68 28       	ld.w	r8,r4[0x8]
80007876:	08 38       	cp.w	r8,r4
80007878:	c0 e1       	brne	80007894 <_malloc_r+0x1d0>
8000787a:	76 19       	ld.w	r9,r11[0x4]
8000787c:	a3 4a       	asr	r10,0x2
8000787e:	30 1e       	mov	lr,1
80007880:	fc 0a 09 4a 	lsl	r10,lr,r10
80007884:	f3 ea 10 0a 	or	r10,r9,r10
80007888:	10 99       	mov	r9,r8
8000788a:	97 1a       	st.w	r11[0x4],r10
8000788c:	c0 a8       	rjmp	800078a0 <_malloc_r+0x1dc>
8000788e:	70 28       	ld.w	r8,r8[0x8]
80007890:	08 38       	cp.w	r8,r4
80007892:	c0 60       	breq	8000789e <_malloc_r+0x1da>
80007894:	70 1a       	ld.w	r10,r8[0x4]
80007896:	e0 1a ff fc 	andl	r10,0xfffc
8000789a:	14 39       	cp.w	r9,r10
8000789c:	cf 93       	brcs	8000788e <_malloc_r+0x1ca>
8000789e:	70 39       	ld.w	r9,r8[0xc]
800078a0:	8d 39       	st.w	r6[0xc],r9
800078a2:	8d 28       	st.w	r6[0x8],r8
800078a4:	91 36       	st.w	r8[0xc],r6
800078a6:	93 26       	st.w	r9[0x8],r6
800078a8:	e6 08 14 02 	asr	r8,r3,0x2
800078ac:	30 1b       	mov	r11,1
800078ae:	e0 64 05 48 	mov	r4,1352
800078b2:	f6 08 09 4b 	lsl	r11,r11,r8
800078b6:	68 18       	ld.w	r8,r4[0x4]
800078b8:	10 3b       	cp.w	r11,r8
800078ba:	e0 8b 00 6b 	brhi	80007990 <_malloc_r+0x2cc>
800078be:	f7 e8 00 09 	and	r9,r11,r8
800078c2:	c0 b1       	brne	800078d8 <_malloc_r+0x214>
800078c4:	e0 13 ff fc 	andl	r3,0xfffc
800078c8:	a1 7b       	lsl	r11,0x1
800078ca:	2f c3       	sub	r3,-4
800078cc:	c0 38       	rjmp	800078d2 <_malloc_r+0x20e>
800078ce:	2f c3       	sub	r3,-4
800078d0:	a1 7b       	lsl	r11,0x1
800078d2:	f7 e8 00 09 	and	r9,r11,r8
800078d6:	cf c0       	breq	800078ce <_malloc_r+0x20a>
800078d8:	e8 03 00 3e 	add	lr,r4,r3<<0x3
800078dc:	06 92       	mov	r2,r3
800078de:	1c 91       	mov	r1,lr
800078e0:	62 36       	ld.w	r6,r1[0xc]
800078e2:	c2 e8       	rjmp	8000793e <_malloc_r+0x27a>
800078e4:	6c 1a       	ld.w	r10,r6[0x4]
800078e6:	e0 1a ff fc 	andl	r10,0xfffc
800078ea:	f4 07 01 08 	sub	r8,r10,r7
800078ee:	58 f8       	cp.w	r8,15
800078f0:	e0 8a 00 15 	brle	8000791a <_malloc_r+0x256>
800078f4:	6c 3a       	ld.w	r10,r6[0xc]
800078f6:	6c 29       	ld.w	r9,r6[0x8]
800078f8:	95 29       	st.w	r10[0x8],r9
800078fa:	93 3a       	st.w	r9[0xc],r10
800078fc:	0e 99       	mov	r9,r7
800078fe:	ec 07 00 07 	add	r7,r6,r7
80007902:	a1 a9       	sbr	r9,0x0
80007904:	99 37       	st.w	r12[0xc],r7
80007906:	99 27       	st.w	r12[0x8],r7
80007908:	8d 19       	st.w	r6[0x4],r9
8000790a:	ee 08 09 08 	st.w	r7[r8],r8
8000790e:	8f 2c       	st.w	r7[0x8],r12
80007910:	8f 3c       	st.w	r7[0xc],r12
80007912:	a1 a8       	sbr	r8,0x0
80007914:	0a 9c       	mov	r12,r5
80007916:	8f 18       	st.w	r7[0x4],r8
80007918:	c0 d8       	rjmp	80007932 <_malloc_r+0x26e>
8000791a:	6c 39       	ld.w	r9,r6[0xc]
8000791c:	58 08       	cp.w	r8,0
8000791e:	c0 f5       	brlt	8000793c <_malloc_r+0x278>
80007920:	ec 0a 00 0a 	add	r10,r6,r10
80007924:	74 18       	ld.w	r8,r10[0x4]
80007926:	a1 a8       	sbr	r8,0x0
80007928:	0a 9c       	mov	r12,r5
8000792a:	95 18       	st.w	r10[0x4],r8
8000792c:	6c 28       	ld.w	r8,r6[0x8]
8000792e:	93 28       	st.w	r9[0x8],r8
80007930:	91 39       	st.w	r8[0xc],r9
80007932:	fe b0 f4 6d 	rcall	8000620c <__malloc_unlock>
80007936:	ec cc ff f8 	sub	r12,r6,-8
8000793a:	d8 32       	popm	r0-r7,pc
8000793c:	12 96       	mov	r6,r9
8000793e:	02 36       	cp.w	r6,r1
80007940:	cd 21       	brne	800078e4 <_malloc_r+0x220>
80007942:	2f f2       	sub	r2,-1
80007944:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
80007948:	c0 30       	breq	8000794e <_malloc_r+0x28a>
8000794a:	2f 81       	sub	r1,-8
8000794c:	cc ab       	rjmp	800078e0 <_malloc_r+0x21c>
8000794e:	1c 98       	mov	r8,lr
80007950:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
80007954:	c0 81       	brne	80007964 <_malloc_r+0x2a0>
80007956:	68 19       	ld.w	r9,r4[0x4]
80007958:	f6 08 11 ff 	rsub	r8,r11,-1
8000795c:	f3 e8 00 08 	and	r8,r9,r8
80007960:	89 18       	st.w	r4[0x4],r8
80007962:	c0 78       	rjmp	80007970 <_malloc_r+0x2ac>
80007964:	f0 c9 00 08 	sub	r9,r8,8
80007968:	20 13       	sub	r3,1
8000796a:	70 08       	ld.w	r8,r8[0x0]
8000796c:	12 38       	cp.w	r8,r9
8000796e:	cf 10       	breq	80007950 <_malloc_r+0x28c>
80007970:	a1 7b       	lsl	r11,0x1
80007972:	68 18       	ld.w	r8,r4[0x4]
80007974:	10 3b       	cp.w	r11,r8
80007976:	e0 8b 00 0d 	brhi	80007990 <_malloc_r+0x2cc>
8000797a:	58 0b       	cp.w	r11,0
8000797c:	c0 a0       	breq	80007990 <_malloc_r+0x2cc>
8000797e:	04 93       	mov	r3,r2
80007980:	c0 38       	rjmp	80007986 <_malloc_r+0x2c2>
80007982:	2f c3       	sub	r3,-4
80007984:	a1 7b       	lsl	r11,0x1
80007986:	f7 e8 00 09 	and	r9,r11,r8
8000798a:	ca 71       	brne	800078d8 <_malloc_r+0x214>
8000798c:	cf bb       	rjmp	80007982 <_malloc_r+0x2be>
8000798e:	d7 03       	nop
80007990:	68 23       	ld.w	r3,r4[0x8]
80007992:	66 12       	ld.w	r2,r3[0x4]
80007994:	e0 12 ff fc 	andl	r2,0xfffc
80007998:	0e 32       	cp.w	r2,r7
8000799a:	5f 39       	srlo	r9
8000799c:	e4 07 01 08 	sub	r8,r2,r7
800079a0:	58 f8       	cp.w	r8,15
800079a2:	5f aa       	srle	r10
800079a4:	f5 e9 10 09 	or	r9,r10,r9
800079a8:	e0 80 00 9a 	breq	80007adc <_malloc_r+0x418>
800079ac:	e0 68 0d c8 	mov	r8,3528
800079b0:	70 01       	ld.w	r1,r8[0x0]
800079b2:	e0 68 09 54 	mov	r8,2388
800079b6:	2f 01       	sub	r1,-16
800079b8:	70 08       	ld.w	r8,r8[0x0]
800079ba:	0e 01       	add	r1,r7
800079bc:	5b f8       	cp.w	r8,-1
800079be:	c0 40       	breq	800079c6 <_malloc_r+0x302>
800079c0:	28 11       	sub	r1,-127
800079c2:	e0 11 ff 80 	andl	r1,0xff80
800079c6:	02 9b       	mov	r11,r1
800079c8:	0a 9c       	mov	r12,r5
800079ca:	e0 a0 02 b7 	rcall	80007f38 <_sbrk_r>
800079ce:	18 96       	mov	r6,r12
800079d0:	5b fc       	cp.w	r12,-1
800079d2:	c7 50       	breq	80007abc <_malloc_r+0x3f8>
800079d4:	e6 02 00 08 	add	r8,r3,r2
800079d8:	10 3c       	cp.w	r12,r8
800079da:	c0 32       	brcc	800079e0 <_malloc_r+0x31c>
800079dc:	08 33       	cp.w	r3,r4
800079de:	c6 f1       	brne	80007abc <_malloc_r+0x3f8>
800079e0:	e0 6a 0d cc 	mov	r10,3532
800079e4:	74 09       	ld.w	r9,r10[0x0]
800079e6:	e2 09 00 09 	add	r9,r1,r9
800079ea:	95 09       	st.w	r10[0x0],r9
800079ec:	10 36       	cp.w	r6,r8
800079ee:	c0 a1       	brne	80007a02 <_malloc_r+0x33e>
800079f0:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
800079f4:	c0 71       	brne	80007a02 <_malloc_r+0x33e>
800079f6:	e2 02 00 02 	add	r2,r1,r2
800079fa:	68 28       	ld.w	r8,r4[0x8]
800079fc:	a1 a2       	sbr	r2,0x0
800079fe:	91 12       	st.w	r8[0x4],r2
80007a00:	c4 f8       	rjmp	80007a9e <_malloc_r+0x3da>
80007a02:	e0 6a 09 54 	mov	r10,2388
80007a06:	74 0b       	ld.w	r11,r10[0x0]
80007a08:	5b fb       	cp.w	r11,-1
80007a0a:	c0 31       	brne	80007a10 <_malloc_r+0x34c>
80007a0c:	95 06       	st.w	r10[0x0],r6
80007a0e:	c0 78       	rjmp	80007a1c <_malloc_r+0x358>
80007a10:	ec 09 00 09 	add	r9,r6,r9
80007a14:	e0 6a 0d cc 	mov	r10,3532
80007a18:	10 19       	sub	r9,r8
80007a1a:	95 09       	st.w	r10[0x0],r9
80007a1c:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80007a20:	f0 09 11 08 	rsub	r9,r8,8
80007a24:	58 08       	cp.w	r8,0
80007a26:	f2 08 17 10 	movne	r8,r9
80007a2a:	ed d8 e1 06 	addne	r6,r6,r8
80007a2e:	28 08       	sub	r8,-128
80007a30:	ec 01 00 01 	add	r1,r6,r1
80007a34:	0a 9c       	mov	r12,r5
80007a36:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
80007a3a:	f0 01 01 01 	sub	r1,r8,r1
80007a3e:	02 9b       	mov	r11,r1
80007a40:	e0 a0 02 7c 	rcall	80007f38 <_sbrk_r>
80007a44:	e0 68 0d cc 	mov	r8,3532
80007a48:	5b fc       	cp.w	r12,-1
80007a4a:	ec 0c 17 00 	moveq	r12,r6
80007a4e:	f9 b1 00 00 	moveq	r1,0
80007a52:	70 09       	ld.w	r9,r8[0x0]
80007a54:	0c 1c       	sub	r12,r6
80007a56:	89 26       	st.w	r4[0x8],r6
80007a58:	02 0c       	add	r12,r1
80007a5a:	12 01       	add	r1,r9
80007a5c:	a1 ac       	sbr	r12,0x0
80007a5e:	91 01       	st.w	r8[0x0],r1
80007a60:	8d 1c       	st.w	r6[0x4],r12
80007a62:	08 33       	cp.w	r3,r4
80007a64:	c1 d0       	breq	80007a9e <_malloc_r+0x3da>
80007a66:	58 f2       	cp.w	r2,15
80007a68:	e0 8b 00 05 	brhi	80007a72 <_malloc_r+0x3ae>
80007a6c:	30 18       	mov	r8,1
80007a6e:	8d 18       	st.w	r6[0x4],r8
80007a70:	c2 68       	rjmp	80007abc <_malloc_r+0x3f8>
80007a72:	30 59       	mov	r9,5
80007a74:	20 c2       	sub	r2,12
80007a76:	e0 12 ff f8 	andl	r2,0xfff8
80007a7a:	e6 02 00 08 	add	r8,r3,r2
80007a7e:	91 29       	st.w	r8[0x8],r9
80007a80:	91 19       	st.w	r8[0x4],r9
80007a82:	66 18       	ld.w	r8,r3[0x4]
80007a84:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007a88:	e5 e8 10 08 	or	r8,r2,r8
80007a8c:	87 18       	st.w	r3[0x4],r8
80007a8e:	58 f2       	cp.w	r2,15
80007a90:	e0 88 00 07 	brls	80007a9e <_malloc_r+0x3da>
80007a94:	e6 cb ff f8 	sub	r11,r3,-8
80007a98:	0a 9c       	mov	r12,r5
80007a9a:	e0 a0 1c 7d 	rcall	8000b394 <_free_r>
80007a9e:	e0 69 0d c4 	mov	r9,3524
80007aa2:	72 0a       	ld.w	r10,r9[0x0]
80007aa4:	e0 68 0d cc 	mov	r8,3532
80007aa8:	70 08       	ld.w	r8,r8[0x0]
80007aaa:	14 38       	cp.w	r8,r10
80007aac:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007ab0:	e0 69 0d c0 	mov	r9,3520
80007ab4:	72 0a       	ld.w	r10,r9[0x0]
80007ab6:	14 38       	cp.w	r8,r10
80007ab8:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80007abc:	68 28       	ld.w	r8,r4[0x8]
80007abe:	70 18       	ld.w	r8,r8[0x4]
80007ac0:	e0 18 ff fc 	andl	r8,0xfffc
80007ac4:	0e 38       	cp.w	r8,r7
80007ac6:	5f 39       	srlo	r9
80007ac8:	0e 18       	sub	r8,r7
80007aca:	58 f8       	cp.w	r8,15
80007acc:	5f aa       	srle	r10
80007ace:	f5 e9 10 09 	or	r9,r10,r9
80007ad2:	c0 50       	breq	80007adc <_malloc_r+0x418>
80007ad4:	0a 9c       	mov	r12,r5
80007ad6:	fe b0 f3 9b 	rcall	8000620c <__malloc_unlock>
80007ada:	d8 3a       	popm	r0-r7,pc,r12=0
80007adc:	68 26       	ld.w	r6,r4[0x8]
80007ade:	a1 a8       	sbr	r8,0x0
80007ae0:	0e 99       	mov	r9,r7
80007ae2:	a1 a9       	sbr	r9,0x0
80007ae4:	8d 19       	st.w	r6[0x4],r9
80007ae6:	ec 07 00 07 	add	r7,r6,r7
80007aea:	0a 9c       	mov	r12,r5
80007aec:	89 27       	st.w	r4[0x8],r7
80007aee:	8f 18       	st.w	r7[0x4],r8
80007af0:	fe b0 f3 8e 	rcall	8000620c <__malloc_unlock>
80007af4:	ec cc ff f8 	sub	r12,r6,-8
80007af8:	d8 32       	popm	r0-r7,pc
80007afa:	d7 03       	nop

80007afc <memcmp>:
80007afc:	d4 01       	pushm	lr
80007afe:	30 08       	mov	r8,0
80007b00:	c0 d8       	rjmp	80007b1a <memcmp+0x1e>
80007b02:	f8 08 07 0e 	ld.ub	lr,r12[r8]
80007b06:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007b0a:	20 1a       	sub	r10,1
80007b0c:	2f f8       	sub	r8,-1
80007b0e:	f2 0e 18 00 	cp.b	lr,r9
80007b12:	c0 40       	breq	80007b1a <memcmp+0x1e>
80007b14:	fc 09 01 0c 	sub	r12,lr,r9
80007b18:	d8 02       	popm	pc
80007b1a:	58 0a       	cp.w	r10,0
80007b1c:	cf 31       	brne	80007b02 <memcmp+0x6>
80007b1e:	14 9c       	mov	r12,r10
80007b20:	d8 02       	popm	pc

80007b22 <memcpy>:
80007b22:	58 8a       	cp.w	r10,8
80007b24:	c2 f5       	brlt	80007b82 <memcpy+0x60>
80007b26:	f9 eb 10 09 	or	r9,r12,r11
80007b2a:	e2 19 00 03 	andl	r9,0x3,COH
80007b2e:	e0 81 00 97 	brne	80007c5c <memcpy+0x13a>
80007b32:	e0 4a 00 20 	cp.w	r10,32
80007b36:	c3 b4       	brge	80007bac <memcpy+0x8a>
80007b38:	f4 08 14 02 	asr	r8,r10,0x2
80007b3c:	f0 09 11 08 	rsub	r9,r8,8
80007b40:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007b44:	76 69       	ld.w	r9,r11[0x18]
80007b46:	99 69       	st.w	r12[0x18],r9
80007b48:	76 59       	ld.w	r9,r11[0x14]
80007b4a:	99 59       	st.w	r12[0x14],r9
80007b4c:	76 49       	ld.w	r9,r11[0x10]
80007b4e:	99 49       	st.w	r12[0x10],r9
80007b50:	76 39       	ld.w	r9,r11[0xc]
80007b52:	99 39       	st.w	r12[0xc],r9
80007b54:	76 29       	ld.w	r9,r11[0x8]
80007b56:	99 29       	st.w	r12[0x8],r9
80007b58:	76 19       	ld.w	r9,r11[0x4]
80007b5a:	99 19       	st.w	r12[0x4],r9
80007b5c:	76 09       	ld.w	r9,r11[0x0]
80007b5e:	99 09       	st.w	r12[0x0],r9
80007b60:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007b64:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007b68:	e0 1a 00 03 	andl	r10,0x3
80007b6c:	f4 0a 11 04 	rsub	r10,r10,4
80007b70:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007b74:	17 a9       	ld.ub	r9,r11[0x2]
80007b76:	b0 a9       	st.b	r8[0x2],r9
80007b78:	17 99       	ld.ub	r9,r11[0x1]
80007b7a:	b0 99       	st.b	r8[0x1],r9
80007b7c:	17 89       	ld.ub	r9,r11[0x0]
80007b7e:	b0 89       	st.b	r8[0x0],r9
80007b80:	5e fc       	retal	r12
80007b82:	f4 0a 11 09 	rsub	r10,r10,9
80007b86:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007b8a:	17 f9       	ld.ub	r9,r11[0x7]
80007b8c:	b8 f9       	st.b	r12[0x7],r9
80007b8e:	17 e9       	ld.ub	r9,r11[0x6]
80007b90:	b8 e9       	st.b	r12[0x6],r9
80007b92:	17 d9       	ld.ub	r9,r11[0x5]
80007b94:	b8 d9       	st.b	r12[0x5],r9
80007b96:	17 c9       	ld.ub	r9,r11[0x4]
80007b98:	b8 c9       	st.b	r12[0x4],r9
80007b9a:	17 b9       	ld.ub	r9,r11[0x3]
80007b9c:	b8 b9       	st.b	r12[0x3],r9
80007b9e:	17 a9       	ld.ub	r9,r11[0x2]
80007ba0:	b8 a9       	st.b	r12[0x2],r9
80007ba2:	17 99       	ld.ub	r9,r11[0x1]
80007ba4:	b8 99       	st.b	r12[0x1],r9
80007ba6:	17 89       	ld.ub	r9,r11[0x0]
80007ba8:	b8 89       	st.b	r12[0x0],r9
80007baa:	5e fc       	retal	r12
80007bac:	eb cd 40 c0 	pushm	r6-r7,lr
80007bb0:	18 99       	mov	r9,r12
80007bb2:	22 0a       	sub	r10,32
80007bb4:	b7 07       	ld.d	r6,r11++
80007bb6:	b3 26       	st.d	r9++,r6
80007bb8:	b7 07       	ld.d	r6,r11++
80007bba:	b3 26       	st.d	r9++,r6
80007bbc:	b7 07       	ld.d	r6,r11++
80007bbe:	b3 26       	st.d	r9++,r6
80007bc0:	b7 07       	ld.d	r6,r11++
80007bc2:	b3 26       	st.d	r9++,r6
80007bc4:	22 0a       	sub	r10,32
80007bc6:	cf 74       	brge	80007bb4 <memcpy+0x92>
80007bc8:	2f 0a       	sub	r10,-16
80007bca:	c0 65       	brlt	80007bd6 <memcpy+0xb4>
80007bcc:	b7 07       	ld.d	r6,r11++
80007bce:	b3 26       	st.d	r9++,r6
80007bd0:	b7 07       	ld.d	r6,r11++
80007bd2:	b3 26       	st.d	r9++,r6
80007bd4:	21 0a       	sub	r10,16
80007bd6:	5c 3a       	neg	r10
80007bd8:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007bdc:	d7 03       	nop
80007bde:	d7 03       	nop
80007be0:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007be4:	f3 66 00 0e 	st.b	r9[14],r6
80007be8:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007bec:	f3 66 00 0d 	st.b	r9[13],r6
80007bf0:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007bf4:	f3 66 00 0c 	st.b	r9[12],r6
80007bf8:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007bfc:	f3 66 00 0b 	st.b	r9[11],r6
80007c00:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007c04:	f3 66 00 0a 	st.b	r9[10],r6
80007c08:	f7 36 00 09 	ld.ub	r6,r11[9]
80007c0c:	f3 66 00 09 	st.b	r9[9],r6
80007c10:	f7 36 00 08 	ld.ub	r6,r11[8]
80007c14:	f3 66 00 08 	st.b	r9[8],r6
80007c18:	f7 36 00 07 	ld.ub	r6,r11[7]
80007c1c:	f3 66 00 07 	st.b	r9[7],r6
80007c20:	f7 36 00 06 	ld.ub	r6,r11[6]
80007c24:	f3 66 00 06 	st.b	r9[6],r6
80007c28:	f7 36 00 05 	ld.ub	r6,r11[5]
80007c2c:	f3 66 00 05 	st.b	r9[5],r6
80007c30:	f7 36 00 04 	ld.ub	r6,r11[4]
80007c34:	f3 66 00 04 	st.b	r9[4],r6
80007c38:	f7 36 00 03 	ld.ub	r6,r11[3]
80007c3c:	f3 66 00 03 	st.b	r9[3],r6
80007c40:	f7 36 00 02 	ld.ub	r6,r11[2]
80007c44:	f3 66 00 02 	st.b	r9[2],r6
80007c48:	f7 36 00 01 	ld.ub	r6,r11[1]
80007c4c:	f3 66 00 01 	st.b	r9[1],r6
80007c50:	f7 36 00 00 	ld.ub	r6,r11[0]
80007c54:	f3 66 00 00 	st.b	r9[0],r6
80007c58:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007c5c:	20 1a       	sub	r10,1
80007c5e:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007c62:	f8 0a 0b 09 	st.b	r12[r10],r9
80007c66:	cf b1       	brne	80007c5c <memcpy+0x13a>
80007c68:	5e fc       	retal	r12

80007c6a <memset>:
80007c6a:	18 98       	mov	r8,r12
80007c6c:	c0 38       	rjmp	80007c72 <memset+0x8>
80007c6e:	10 cb       	st.b	r8++,r11
80007c70:	20 1a       	sub	r10,1
80007c72:	58 0a       	cp.w	r10,0
80007c74:	cf d1       	brne	80007c6e <memset+0x4>
80007c76:	5e fc       	retal	r12

80007c78 <_realloc_r>:
80007c78:	d4 31       	pushm	r0-r7,lr
80007c7a:	20 1d       	sub	sp,4
80007c7c:	16 94       	mov	r4,r11
80007c7e:	18 92       	mov	r2,r12
80007c80:	14 9b       	mov	r11,r10
80007c82:	58 04       	cp.w	r4,0
80007c84:	c0 51       	brne	80007c8e <_realloc_r+0x16>
80007c86:	fe b0 fd 1f 	rcall	800076c4 <_malloc_r>
80007c8a:	18 95       	mov	r5,r12
80007c8c:	c5 39       	rjmp	80007f32 <_realloc_r+0x2ba>
80007c8e:	50 0a       	stdsp	sp[0x0],r10
80007c90:	fe b0 f2 b8 	rcall	80006200 <__malloc_lock>
80007c94:	40 0b       	lddsp	r11,sp[0x0]
80007c96:	f6 c8 ff f5 	sub	r8,r11,-11
80007c9a:	e8 c1 00 08 	sub	r1,r4,8
80007c9e:	10 96       	mov	r6,r8
80007ca0:	62 1c       	ld.w	r12,r1[0x4]
80007ca2:	e0 16 ff f8 	andl	r6,0xfff8
80007ca6:	59 68       	cp.w	r8,22
80007ca8:	f9 b6 08 10 	movls	r6,16
80007cac:	16 36       	cp.w	r6,r11
80007cae:	5f 38       	srlo	r8
80007cb0:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
80007cb4:	c0 50       	breq	80007cbe <_realloc_r+0x46>
80007cb6:	30 c8       	mov	r8,12
80007cb8:	30 05       	mov	r5,0
80007cba:	85 38       	st.w	r2[0xc],r8
80007cbc:	c3 b9       	rjmp	80007f32 <_realloc_r+0x2ba>
80007cbe:	18 90       	mov	r0,r12
80007cc0:	e0 10 ff fc 	andl	r0,0xfffc
80007cc4:	0c 30       	cp.w	r0,r6
80007cc6:	e0 84 01 0b 	brge	80007edc <_realloc_r+0x264>
80007cca:	e0 68 05 48 	mov	r8,1352
80007cce:	e2 00 00 09 	add	r9,r1,r0
80007cd2:	70 25       	ld.w	r5,r8[0x8]
80007cd4:	0a 39       	cp.w	r9,r5
80007cd6:	c0 90       	breq	80007ce8 <_realloc_r+0x70>
80007cd8:	72 1a       	ld.w	r10,r9[0x4]
80007cda:	a1 ca       	cbr	r10,0x0
80007cdc:	f2 0a 00 0a 	add	r10,r9,r10
80007ce0:	74 1a       	ld.w	r10,r10[0x4]
80007ce2:	ed ba 00 00 	bld	r10,0x0
80007ce6:	c2 20       	breq	80007d2a <_realloc_r+0xb2>
80007ce8:	72 1a       	ld.w	r10,r9[0x4]
80007cea:	e0 1a ff fc 	andl	r10,0xfffc
80007cee:	f4 00 00 03 	add	r3,r10,r0
80007cf2:	0a 39       	cp.w	r9,r5
80007cf4:	c1 31       	brne	80007d1a <_realloc_r+0xa2>
80007cf6:	ec c7 ff f0 	sub	r7,r6,-16
80007cfa:	0e 33       	cp.w	r3,r7
80007cfc:	c1 95       	brlt	80007d2e <_realloc_r+0xb6>
80007cfe:	e2 06 00 09 	add	r9,r1,r6
80007d02:	0c 13       	sub	r3,r6
80007d04:	a1 a3       	sbr	r3,0x0
80007d06:	93 13       	st.w	r9[0x4],r3
80007d08:	91 29       	st.w	r8[0x8],r9
80007d0a:	04 9c       	mov	r12,r2
80007d0c:	62 18       	ld.w	r8,r1[0x4]
80007d0e:	08 95       	mov	r5,r4
80007d10:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007d14:	10 46       	or	r6,r8
80007d16:	83 16       	st.w	r1[0x4],r6
80007d18:	c0 b9       	rjmp	80007f2e <_realloc_r+0x2b6>
80007d1a:	0c 33       	cp.w	r3,r6
80007d1c:	c0 95       	brlt	80007d2e <_realloc_r+0xb6>
80007d1e:	72 28       	ld.w	r8,r9[0x8]
80007d20:	02 97       	mov	r7,r1
80007d22:	72 39       	ld.w	r9,r9[0xc]
80007d24:	93 28       	st.w	r9[0x8],r8
80007d26:	91 39       	st.w	r8[0xc],r9
80007d28:	cd c8       	rjmp	80007ee0 <_realloc_r+0x268>
80007d2a:	30 0a       	mov	r10,0
80007d2c:	14 99       	mov	r9,r10
80007d2e:	ed bc 00 00 	bld	r12,0x0
80007d32:	e0 80 00 95 	breq	80007e5c <_realloc_r+0x1e4>
80007d36:	62 07       	ld.w	r7,r1[0x0]
80007d38:	e2 07 01 07 	sub	r7,r1,r7
80007d3c:	6e 1c       	ld.w	r12,r7[0x4]
80007d3e:	e0 1c ff fc 	andl	r12,0xfffc
80007d42:	58 09       	cp.w	r9,0
80007d44:	c5 60       	breq	80007df0 <_realloc_r+0x178>
80007d46:	f8 00 00 03 	add	r3,r12,r0
80007d4a:	0a 39       	cp.w	r9,r5
80007d4c:	c4 81       	brne	80007ddc <_realloc_r+0x164>
80007d4e:	14 03       	add	r3,r10
80007d50:	ec c9 ff f0 	sub	r9,r6,-16
80007d54:	12 33       	cp.w	r3,r9
80007d56:	c4 d5       	brlt	80007df0 <_realloc_r+0x178>
80007d58:	6e 3a       	ld.w	r10,r7[0xc]
80007d5a:	6e 29       	ld.w	r9,r7[0x8]
80007d5c:	95 29       	st.w	r10[0x8],r9
80007d5e:	93 3a       	st.w	r9[0xc],r10
80007d60:	ee c5 ff f8 	sub	r5,r7,-8
80007d64:	e0 ca 00 04 	sub	r10,r0,4
80007d68:	e0 4a 00 24 	cp.w	r10,36
80007d6c:	e0 8b 00 25 	brhi	80007db6 <_realloc_r+0x13e>
80007d70:	0a 99       	mov	r9,r5
80007d72:	59 3a       	cp.w	r10,19
80007d74:	e0 88 00 1a 	brls	80007da8 <_realloc_r+0x130>
80007d78:	09 09       	ld.w	r9,r4++
80007d7a:	8b 09       	st.w	r5[0x0],r9
80007d7c:	09 09       	ld.w	r9,r4++
80007d7e:	8f 39       	st.w	r7[0xc],r9
80007d80:	ee c9 ff f0 	sub	r9,r7,-16
80007d84:	59 ba       	cp.w	r10,27
80007d86:	e0 88 00 11 	brls	80007da8 <_realloc_r+0x130>
80007d8a:	09 0b       	ld.w	r11,r4++
80007d8c:	93 0b       	st.w	r9[0x0],r11
80007d8e:	09 09       	ld.w	r9,r4++
80007d90:	8f 59       	st.w	r7[0x14],r9
80007d92:	ee c9 ff e8 	sub	r9,r7,-24
80007d96:	e0 4a 00 24 	cp.w	r10,36
80007d9a:	c0 71       	brne	80007da8 <_realloc_r+0x130>
80007d9c:	09 0a       	ld.w	r10,r4++
80007d9e:	93 0a       	st.w	r9[0x0],r10
80007da0:	ee c9 ff e0 	sub	r9,r7,-32
80007da4:	09 0a       	ld.w	r10,r4++
80007da6:	8f 7a       	st.w	r7[0x1c],r10
80007da8:	09 0a       	ld.w	r10,r4++
80007daa:	12 aa       	st.w	r9++,r10
80007dac:	68 0a       	ld.w	r10,r4[0x0]
80007dae:	93 0a       	st.w	r9[0x0],r10
80007db0:	68 1a       	ld.w	r10,r4[0x4]
80007db2:	93 1a       	st.w	r9[0x4],r10
80007db4:	c0 78       	rjmp	80007dc2 <_realloc_r+0x14a>
80007db6:	50 08       	stdsp	sp[0x0],r8
80007db8:	08 9b       	mov	r11,r4
80007dba:	0a 9c       	mov	r12,r5
80007dbc:	e0 a0 1d 8f 	rcall	8000b8da <memmove>
80007dc0:	40 08       	lddsp	r8,sp[0x0]
80007dc2:	ee 06 00 09 	add	r9,r7,r6
80007dc6:	0c 13       	sub	r3,r6
80007dc8:	a1 a3       	sbr	r3,0x0
80007dca:	93 13       	st.w	r9[0x4],r3
80007dcc:	91 29       	st.w	r8[0x8],r9
80007dce:	04 9c       	mov	r12,r2
80007dd0:	6e 18       	ld.w	r8,r7[0x4]
80007dd2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007dd6:	10 46       	or	r6,r8
80007dd8:	8f 16       	st.w	r7[0x4],r6
80007dda:	ca a8       	rjmp	80007f2e <_realloc_r+0x2b6>
80007ddc:	14 03       	add	r3,r10
80007dde:	0c 33       	cp.w	r3,r6
80007de0:	c0 85       	brlt	80007df0 <_realloc_r+0x178>
80007de2:	72 28       	ld.w	r8,r9[0x8]
80007de4:	72 39       	ld.w	r9,r9[0xc]
80007de6:	93 28       	st.w	r9[0x8],r8
80007de8:	91 39       	st.w	r8[0xc],r9
80007dea:	6e 28       	ld.w	r8,r7[0x8]
80007dec:	6e 39       	ld.w	r9,r7[0xc]
80007dee:	c0 78       	rjmp	80007dfc <_realloc_r+0x184>
80007df0:	f8 00 00 03 	add	r3,r12,r0
80007df4:	0c 33       	cp.w	r3,r6
80007df6:	c3 35       	brlt	80007e5c <_realloc_r+0x1e4>
80007df8:	6e 39       	ld.w	r9,r7[0xc]
80007dfa:	6e 28       	ld.w	r8,r7[0x8]
80007dfc:	93 28       	st.w	r9[0x8],r8
80007dfe:	91 39       	st.w	r8[0xc],r9
80007e00:	e0 ca 00 04 	sub	r10,r0,4
80007e04:	ee cc ff f8 	sub	r12,r7,-8
80007e08:	e0 4a 00 24 	cp.w	r10,36
80007e0c:	e0 8b 00 24 	brhi	80007e54 <_realloc_r+0x1dc>
80007e10:	59 3a       	cp.w	r10,19
80007e12:	e0 88 00 1a 	brls	80007e46 <_realloc_r+0x1ce>
80007e16:	09 08       	ld.w	r8,r4++
80007e18:	99 08       	st.w	r12[0x0],r8
80007e1a:	09 08       	ld.w	r8,r4++
80007e1c:	8f 38       	st.w	r7[0xc],r8
80007e1e:	ee cc ff f0 	sub	r12,r7,-16
80007e22:	59 ba       	cp.w	r10,27
80007e24:	e0 88 00 11 	brls	80007e46 <_realloc_r+0x1ce>
80007e28:	09 08       	ld.w	r8,r4++
80007e2a:	99 08       	st.w	r12[0x0],r8
80007e2c:	09 08       	ld.w	r8,r4++
80007e2e:	8f 58       	st.w	r7[0x14],r8
80007e30:	ee cc ff e8 	sub	r12,r7,-24
80007e34:	e0 4a 00 24 	cp.w	r10,36
80007e38:	c0 71       	brne	80007e46 <_realloc_r+0x1ce>
80007e3a:	09 08       	ld.w	r8,r4++
80007e3c:	99 08       	st.w	r12[0x0],r8
80007e3e:	ee cc ff e0 	sub	r12,r7,-32
80007e42:	09 08       	ld.w	r8,r4++
80007e44:	8f 78       	st.w	r7[0x1c],r8
80007e46:	09 08       	ld.w	r8,r4++
80007e48:	18 a8       	st.w	r12++,r8
80007e4a:	68 08       	ld.w	r8,r4[0x0]
80007e4c:	99 08       	st.w	r12[0x0],r8
80007e4e:	68 18       	ld.w	r8,r4[0x4]
80007e50:	99 18       	st.w	r12[0x4],r8
80007e52:	c4 78       	rjmp	80007ee0 <_realloc_r+0x268>
80007e54:	08 9b       	mov	r11,r4
80007e56:	e0 a0 1d 42 	rcall	8000b8da <memmove>
80007e5a:	c4 38       	rjmp	80007ee0 <_realloc_r+0x268>
80007e5c:	04 9c       	mov	r12,r2
80007e5e:	fe b0 fc 33 	rcall	800076c4 <_malloc_r>
80007e62:	18 95       	mov	r5,r12
80007e64:	c3 a0       	breq	80007ed8 <_realloc_r+0x260>
80007e66:	62 18       	ld.w	r8,r1[0x4]
80007e68:	f8 c9 00 08 	sub	r9,r12,8
80007e6c:	a1 c8       	cbr	r8,0x0
80007e6e:	e2 08 00 08 	add	r8,r1,r8
80007e72:	10 39       	cp.w	r9,r8
80007e74:	c0 71       	brne	80007e82 <_realloc_r+0x20a>
80007e76:	72 13       	ld.w	r3,r9[0x4]
80007e78:	02 97       	mov	r7,r1
80007e7a:	e0 13 ff fc 	andl	r3,0xfffc
80007e7e:	00 03       	add	r3,r0
80007e80:	c3 08       	rjmp	80007ee0 <_realloc_r+0x268>
80007e82:	e0 ca 00 04 	sub	r10,r0,4
80007e86:	e0 4a 00 24 	cp.w	r10,36
80007e8a:	e0 8b 00 20 	brhi	80007eca <_realloc_r+0x252>
80007e8e:	08 99       	mov	r9,r4
80007e90:	18 98       	mov	r8,r12
80007e92:	59 3a       	cp.w	r10,19
80007e94:	e0 88 00 14 	brls	80007ebc <_realloc_r+0x244>
80007e98:	13 0b       	ld.w	r11,r9++
80007e9a:	10 ab       	st.w	r8++,r11
80007e9c:	13 0b       	ld.w	r11,r9++
80007e9e:	10 ab       	st.w	r8++,r11
80007ea0:	59 ba       	cp.w	r10,27
80007ea2:	e0 88 00 0d 	brls	80007ebc <_realloc_r+0x244>
80007ea6:	13 0b       	ld.w	r11,r9++
80007ea8:	10 ab       	st.w	r8++,r11
80007eaa:	13 0b       	ld.w	r11,r9++
80007eac:	10 ab       	st.w	r8++,r11
80007eae:	e0 4a 00 24 	cp.w	r10,36
80007eb2:	c0 51       	brne	80007ebc <_realloc_r+0x244>
80007eb4:	13 0a       	ld.w	r10,r9++
80007eb6:	10 aa       	st.w	r8++,r10
80007eb8:	13 0a       	ld.w	r10,r9++
80007eba:	10 aa       	st.w	r8++,r10
80007ebc:	13 0a       	ld.w	r10,r9++
80007ebe:	10 aa       	st.w	r8++,r10
80007ec0:	72 0a       	ld.w	r10,r9[0x0]
80007ec2:	91 0a       	st.w	r8[0x0],r10
80007ec4:	72 19       	ld.w	r9,r9[0x4]
80007ec6:	91 19       	st.w	r8[0x4],r9
80007ec8:	c0 48       	rjmp	80007ed0 <_realloc_r+0x258>
80007eca:	08 9b       	mov	r11,r4
80007ecc:	e0 a0 1d 07 	rcall	8000b8da <memmove>
80007ed0:	08 9b       	mov	r11,r4
80007ed2:	04 9c       	mov	r12,r2
80007ed4:	e0 a0 1a 60 	rcall	8000b394 <_free_r>
80007ed8:	04 9c       	mov	r12,r2
80007eda:	c2 a8       	rjmp	80007f2e <_realloc_r+0x2b6>
80007edc:	00 93       	mov	r3,r0
80007ede:	02 97       	mov	r7,r1
80007ee0:	e6 06 01 09 	sub	r9,r3,r6
80007ee4:	6e 18       	ld.w	r8,r7[0x4]
80007ee6:	58 f9       	cp.w	r9,15
80007ee8:	e0 88 00 16 	brls	80007f14 <_realloc_r+0x29c>
80007eec:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007ef0:	ed e8 10 08 	or	r8,r6,r8
80007ef4:	8f 18       	st.w	r7[0x4],r8
80007ef6:	12 98       	mov	r8,r9
80007ef8:	a1 a8       	sbr	r8,0x0
80007efa:	ee 06 00 0b 	add	r11,r7,r6
80007efe:	f6 09 00 09 	add	r9,r11,r9
80007f02:	97 18       	st.w	r11[0x4],r8
80007f04:	72 18       	ld.w	r8,r9[0x4]
80007f06:	a1 a8       	sbr	r8,0x0
80007f08:	2f 8b       	sub	r11,-8
80007f0a:	93 18       	st.w	r9[0x4],r8
80007f0c:	04 9c       	mov	r12,r2
80007f0e:	e0 a0 1a 43 	rcall	8000b394 <_free_r>
80007f12:	c0 b8       	rjmp	80007f28 <_realloc_r+0x2b0>
80007f14:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007f18:	e7 e8 10 08 	or	r8,r3,r8
80007f1c:	8f 18       	st.w	r7[0x4],r8
80007f1e:	ee 03 00 03 	add	r3,r7,r3
80007f22:	66 18       	ld.w	r8,r3[0x4]
80007f24:	a1 a8       	sbr	r8,0x0
80007f26:	87 18       	st.w	r3[0x4],r8
80007f28:	04 9c       	mov	r12,r2
80007f2a:	ee c5 ff f8 	sub	r5,r7,-8
80007f2e:	fe b0 f1 6f 	rcall	8000620c <__malloc_unlock>
80007f32:	0a 9c       	mov	r12,r5
80007f34:	2f fd       	sub	sp,-4
80007f36:	d8 32       	popm	r0-r7,pc

80007f38 <_sbrk_r>:
80007f38:	d4 21       	pushm	r4-r7,lr
80007f3a:	30 08       	mov	r8,0
80007f3c:	18 97       	mov	r7,r12
80007f3e:	e0 66 54 20 	mov	r6,21536
80007f42:	16 9c       	mov	r12,r11
80007f44:	8d 08       	st.w	r6[0x0],r8
80007f46:	c8 5c       	rcall	80008050 <_sbrk>
80007f48:	5b fc       	cp.w	r12,-1
80007f4a:	c0 51       	brne	80007f54 <_sbrk_r+0x1c>
80007f4c:	6c 08       	ld.w	r8,r6[0x0]
80007f4e:	58 08       	cp.w	r8,0
80007f50:	ef f8 1a 03 	st.wne	r7[0xc],r8
80007f54:	d8 22       	popm	r4-r7,pc
80007f56:	d7 03       	nop

80007f58 <sprintf>:
80007f58:	d4 01       	pushm	lr
80007f5a:	21 7d       	sub	sp,92
80007f5c:	e0 68 ff ff 	mov	r8,65535
80007f60:	ea 18 7f ff 	orh	r8,0x7fff
80007f64:	50 58       	stdsp	sp[0x14],r8
80007f66:	50 28       	stdsp	sp[0x8],r8
80007f68:	e0 68 02 08 	mov	r8,520
80007f6c:	ba 68       	st.h	sp[0xc],r8
80007f6e:	3f f8       	mov	r8,-1
80007f70:	ba 78       	st.h	sp[0xe],r8
80007f72:	e0 68 0a 48 	mov	r8,2632
80007f76:	50 4c       	stdsp	sp[0x10],r12
80007f78:	16 9a       	mov	r10,r11
80007f7a:	50 0c       	stdsp	sp[0x0],r12
80007f7c:	fa c9 ff a0 	sub	r9,sp,-96
80007f80:	70 0c       	ld.w	r12,r8[0x0]
80007f82:	1a 9b       	mov	r11,sp
80007f84:	e0 a0 02 1a 	rcall	800083b8 <_vfprintf_r>
80007f88:	30 09       	mov	r9,0
80007f8a:	40 08       	lddsp	r8,sp[0x0]
80007f8c:	b0 89       	st.b	r8[0x0],r9
80007f8e:	2e 9d       	sub	sp,-92
80007f90:	d8 02       	popm	pc
80007f92:	d7 03       	nop

80007f94 <strncpy>:
80007f94:	30 08       	mov	r8,0
80007f96:	10 3a       	cp.w	r10,r8
80007f98:	5e 0c       	reteq	r12
80007f9a:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007f9e:	f8 08 0b 09 	st.b	r12[r8],r9
80007fa2:	2f f8       	sub	r8,-1
80007fa4:	58 09       	cp.w	r9,0
80007fa6:	cf 81       	brne	80007f96 <strncpy+0x2>
80007fa8:	10 3a       	cp.w	r10,r8
80007faa:	5e 0c       	reteq	r12
80007fac:	f8 08 0b 09 	st.b	r12[r8],r9
80007fb0:	2f f8       	sub	r8,-1
80007fb2:	cf bb       	rjmp	80007fa8 <strncpy+0x14>

80007fb4 <_close>:
80007fb4:	30 28       	mov	r8,2
80007fb6:	d6 73       	breakpoint
80007fb8:	3f fc       	mov	r12,-1
80007fba:	35 8b       	mov	r11,88
80007fbc:	58 0c       	cp.w	r12,0
80007fbe:	5e 4c       	retge	r12
80007fc0:	e0 6a 54 20 	mov	r10,21536
80007fc4:	95 0b       	st.w	r10[0x0],r11
80007fc6:	5e fc       	retal	r12

80007fc8 <_lseek>:
80007fc8:	30 58       	mov	r8,5
80007fca:	d6 73       	breakpoint
80007fcc:	3f fc       	mov	r12,-1
80007fce:	35 8b       	mov	r11,88
80007fd0:	58 0c       	cp.w	r12,0
80007fd2:	5e 4c       	retge	r12
80007fd4:	e0 6a 54 20 	mov	r10,21536
80007fd8:	95 0b       	st.w	r10[0x0],r11
80007fda:	5e fc       	retal	r12

80007fdc <isatty>:
80007fdc:	30 b8       	mov	r8,11
80007fde:	d6 73       	breakpoint
80007fe0:	3f fc       	mov	r12,-1
80007fe2:	35 8b       	mov	r11,88
80007fe4:	58 0c       	cp.w	r12,0
80007fe6:	5e 4c       	retge	r12
80007fe8:	e0 6a 54 20 	mov	r10,21536
80007fec:	95 0b       	st.w	r10[0x0],r11
80007fee:	5e fc       	retal	r12

80007ff0 <_fstat_host>:
80007ff0:	30 98       	mov	r8,9
80007ff2:	d6 73       	breakpoint
80007ff4:	3f fc       	mov	r12,-1
80007ff6:	35 8b       	mov	r11,88
80007ff8:	58 0c       	cp.w	r12,0
80007ffa:	5e 4c       	retge	r12
80007ffc:	e0 6a 54 20 	mov	r10,21536
80008000:	95 0b       	st.w	r10[0x0],r11
80008002:	5e fc       	retal	r12

80008004 <_fstat>:
80008004:	d4 21       	pushm	r4-r7,lr
80008006:	21 0d       	sub	sp,64
80008008:	16 97       	mov	r7,r11
8000800a:	1a 9b       	mov	r11,sp
8000800c:	cf 2f       	rcall	80007ff0 <_fstat_host>
8000800e:	c0 34       	brge	80008014 <_fstat+0x10>
80008010:	3f fc       	mov	r12,-1
80008012:	c1 c8       	rjmp	8000804a <_fstat+0x46>
80008014:	40 08       	lddsp	r8,sp[0x0]
80008016:	ae 08       	st.h	r7[0x0],r8
80008018:	40 18       	lddsp	r8,sp[0x4]
8000801a:	ae 18       	st.h	r7[0x2],r8
8000801c:	40 28       	lddsp	r8,sp[0x8]
8000801e:	8f 18       	st.w	r7[0x4],r8
80008020:	40 38       	lddsp	r8,sp[0xc]
80008022:	ae 48       	st.h	r7[0x8],r8
80008024:	40 48       	lddsp	r8,sp[0x10]
80008026:	ae 58       	st.h	r7[0xa],r8
80008028:	40 58       	lddsp	r8,sp[0x14]
8000802a:	ae 68       	st.h	r7[0xc],r8
8000802c:	40 68       	lddsp	r8,sp[0x18]
8000802e:	ae 78       	st.h	r7[0xe],r8
80008030:	40 88       	lddsp	r8,sp[0x20]
80008032:	8f 48       	st.w	r7[0x10],r8
80008034:	40 a8       	lddsp	r8,sp[0x28]
80008036:	8f b8       	st.w	r7[0x2c],r8
80008038:	40 c8       	lddsp	r8,sp[0x30]
8000803a:	8f c8       	st.w	r7[0x30],r8
8000803c:	40 d8       	lddsp	r8,sp[0x34]
8000803e:	8f 58       	st.w	r7[0x14],r8
80008040:	40 e8       	lddsp	r8,sp[0x38]
80008042:	30 0c       	mov	r12,0
80008044:	8f 78       	st.w	r7[0x1c],r8
80008046:	40 f8       	lddsp	r8,sp[0x3c]
80008048:	8f 98       	st.w	r7[0x24],r8
8000804a:	2f 0d       	sub	sp,-64
8000804c:	d8 22       	popm	r4-r7,pc
8000804e:	d7 03       	nop

80008050 <_sbrk>:
80008050:	d4 01       	pushm	lr
80008052:	e0 68 0d f4 	mov	r8,3572
80008056:	70 09       	ld.w	r9,r8[0x0]
80008058:	58 09       	cp.w	r9,0
8000805a:	c0 41       	brne	80008062 <_sbrk+0x12>
8000805c:	e0 69 54 28 	mov	r9,21544
80008060:	91 09       	st.w	r8[0x0],r9
80008062:	e0 69 0d f4 	mov	r9,3572
80008066:	e0 7a 70 00 	mov	r10,94208
8000806a:	72 08       	ld.w	r8,r9[0x0]
8000806c:	f0 0c 00 0c 	add	r12,r8,r12
80008070:	14 3c       	cp.w	r12,r10
80008072:	e0 8b 00 04 	brhi	8000807a <_sbrk+0x2a>
80008076:	93 0c       	st.w	r9[0x0],r12
80008078:	c0 68       	rjmp	80008084 <_sbrk+0x34>
8000807a:	e0 a0 18 15 	rcall	8000b0a4 <__errno>
8000807e:	30 c8       	mov	r8,12
80008080:	99 08       	st.w	r12[0x0],r8
80008082:	3f f8       	mov	r8,-1
80008084:	10 9c       	mov	r12,r8
80008086:	d8 02       	popm	pc

80008088 <get_arg>:
80008088:	d4 31       	pushm	r0-r7,lr
8000808a:	20 8d       	sub	sp,32
8000808c:	fa c4 ff bc 	sub	r4,sp,-68
80008090:	50 4b       	stdsp	sp[0x10],r11
80008092:	68 2e       	ld.w	lr,r4[0x8]
80008094:	50 58       	stdsp	sp[0x14],r8
80008096:	12 96       	mov	r6,r9
80008098:	7c 0b       	ld.w	r11,lr[0x0]
8000809a:	70 05       	ld.w	r5,r8[0x0]
8000809c:	50 6e       	stdsp	sp[0x18],lr
8000809e:	58 0b       	cp.w	r11,0
800080a0:	f4 0b 17 00 	moveq	r11,r10
800080a4:	68 03       	ld.w	r3,r4[0x0]
800080a6:	68 11       	ld.w	r1,r4[0x4]
800080a8:	40 49       	lddsp	r9,sp[0x10]
800080aa:	30 08       	mov	r8,0
800080ac:	c2 89       	rjmp	800082fc <get_arg+0x274>
800080ae:	2f fb       	sub	r11,-1
800080b0:	32 5c       	mov	r12,37
800080b2:	17 8a       	ld.ub	r10,r11[0x0]
800080b4:	f8 0a 18 00 	cp.b	r10,r12
800080b8:	5f 1e       	srne	lr
800080ba:	f0 0a 18 00 	cp.b	r10,r8
800080be:	5f 1c       	srne	r12
800080c0:	fd ec 00 0c 	and	r12,lr,r12
800080c4:	f0 0c 18 00 	cp.b	r12,r8
800080c8:	cf 31       	brne	800080ae <get_arg+0x26>
800080ca:	58 0a       	cp.w	r10,0
800080cc:	e0 80 01 25 	breq	80008316 <get_arg+0x28e>
800080d0:	30 0c       	mov	r12,0
800080d2:	3f fa       	mov	r10,-1
800080d4:	18 90       	mov	r0,r12
800080d6:	50 3a       	stdsp	sp[0xc],r10
800080d8:	18 94       	mov	r4,r12
800080da:	18 92       	mov	r2,r12
800080dc:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
800080e0:	16 97       	mov	r7,r11
800080e2:	50 7c       	stdsp	sp[0x1c],r12
800080e4:	fe cc 9e 58 	sub	r12,pc,-25000
800080e8:	0f 3a       	ld.ub	r10,r7++
800080ea:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
800080ee:	40 7c       	lddsp	r12,sp[0x1c]
800080f0:	1c 0c       	add	r12,lr
800080f2:	fe ce 9f 2e 	sub	lr,pc,-24786
800080f6:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
800080fa:	20 1e       	sub	lr,1
800080fc:	50 0e       	stdsp	sp[0x0],lr
800080fe:	fe ce 9f a6 	sub	lr,pc,-24666
80008102:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80008106:	50 7c       	stdsp	sp[0x1c],r12
80008108:	40 0c       	lddsp	r12,sp[0x0]
8000810a:	58 7c       	cp.w	r12,7
8000810c:	e0 8b 00 f1 	brhi	800082ee <get_arg+0x266>
80008110:	fe ce a1 58 	sub	lr,pc,-24232
80008114:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80008118:	36 8b       	mov	r11,104
8000811a:	f6 0a 18 00 	cp.b	r10,r11
8000811e:	e0 80 00 e8 	breq	800082ee <get_arg+0x266>
80008122:	37 1b       	mov	r11,113
80008124:	f6 0a 18 00 	cp.b	r10,r11
80008128:	c0 70       	breq	80008136 <get_arg+0xae>
8000812a:	34 cb       	mov	r11,76
8000812c:	f6 0a 18 00 	cp.b	r10,r11
80008130:	c0 51       	brne	8000813a <get_arg+0xb2>
80008132:	a3 b4       	sbr	r4,0x3
80008134:	cd d8       	rjmp	800082ee <get_arg+0x266>
80008136:	a5 b4       	sbr	r4,0x5
80008138:	cd b8       	rjmp	800082ee <get_arg+0x266>
8000813a:	08 9a       	mov	r10,r4
8000813c:	0e 9b       	mov	r11,r7
8000813e:	a5 aa       	sbr	r10,0x4
80008140:	17 3c       	ld.ub	r12,r11++
80008142:	a5 b4       	sbr	r4,0x5
80008144:	36 ce       	mov	lr,108
80008146:	fc 0c 18 00 	cp.b	r12,lr
8000814a:	e0 80 00 d3 	breq	800082f0 <get_arg+0x268>
8000814e:	14 94       	mov	r4,r10
80008150:	cc f8       	rjmp	800082ee <get_arg+0x266>
80008152:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80008156:	36 7c       	mov	r12,103
80008158:	f8 0a 18 00 	cp.b	r10,r12
8000815c:	e0 8b 00 27 	brhi	800081aa <get_arg+0x122>
80008160:	36 5b       	mov	r11,101
80008162:	f6 0a 18 00 	cp.b	r10,r11
80008166:	c4 82       	brcc	800081f6 <get_arg+0x16e>
80008168:	34 fb       	mov	r11,79
8000816a:	f6 0a 18 00 	cp.b	r10,r11
8000816e:	c4 80       	breq	800081fe <get_arg+0x176>
80008170:	e0 8b 00 0c 	brhi	80008188 <get_arg+0x100>
80008174:	34 5b       	mov	r11,69
80008176:	f6 0a 18 00 	cp.b	r10,r11
8000817a:	c3 e0       	breq	800081f6 <get_arg+0x16e>
8000817c:	34 7b       	mov	r11,71
8000817e:	f6 0a 18 00 	cp.b	r10,r11
80008182:	c3 a0       	breq	800081f6 <get_arg+0x16e>
80008184:	34 4b       	mov	r11,68
80008186:	c0 88       	rjmp	80008196 <get_arg+0x10e>
80008188:	35 8b       	mov	r11,88
8000818a:	f6 0a 18 00 	cp.b	r10,r11
8000818e:	c2 c0       	breq	800081e6 <get_arg+0x15e>
80008190:	e0 8b 00 07 	brhi	8000819e <get_arg+0x116>
80008194:	35 5b       	mov	r11,85
80008196:	f6 0a 18 00 	cp.b	r10,r11
8000819a:	c3 51       	brne	80008204 <get_arg+0x17c>
8000819c:	c3 18       	rjmp	800081fe <get_arg+0x176>
8000819e:	36 3b       	mov	r11,99
800081a0:	f6 0a 18 00 	cp.b	r10,r11
800081a4:	c2 f0       	breq	80008202 <get_arg+0x17a>
800081a6:	36 4b       	mov	r11,100
800081a8:	c0 e8       	rjmp	800081c4 <get_arg+0x13c>
800081aa:	37 0b       	mov	r11,112
800081ac:	f6 0a 18 00 	cp.b	r10,r11
800081b0:	c2 50       	breq	800081fa <get_arg+0x172>
800081b2:	e0 8b 00 0d 	brhi	800081cc <get_arg+0x144>
800081b6:	36 eb       	mov	r11,110
800081b8:	f6 0a 18 00 	cp.b	r10,r11
800081bc:	c1 f0       	breq	800081fa <get_arg+0x172>
800081be:	e0 8b 00 14 	brhi	800081e6 <get_arg+0x15e>
800081c2:	36 9b       	mov	r11,105
800081c4:	f6 0a 18 00 	cp.b	r10,r11
800081c8:	c1 e1       	brne	80008204 <get_arg+0x17c>
800081ca:	c0 e8       	rjmp	800081e6 <get_arg+0x15e>
800081cc:	37 5b       	mov	r11,117
800081ce:	f6 0a 18 00 	cp.b	r10,r11
800081d2:	c0 a0       	breq	800081e6 <get_arg+0x15e>
800081d4:	37 8b       	mov	r11,120
800081d6:	f6 0a 18 00 	cp.b	r10,r11
800081da:	c0 60       	breq	800081e6 <get_arg+0x15e>
800081dc:	37 3b       	mov	r11,115
800081de:	f6 0a 18 00 	cp.b	r10,r11
800081e2:	c1 11       	brne	80008204 <get_arg+0x17c>
800081e4:	c0 b8       	rjmp	800081fa <get_arg+0x172>
800081e6:	ed b4 00 04 	bld	r4,0x4
800081ea:	c0 a0       	breq	800081fe <get_arg+0x176>
800081ec:	ed b4 00 05 	bld	r4,0x5
800081f0:	c0 91       	brne	80008202 <get_arg+0x17a>
800081f2:	30 20       	mov	r0,2
800081f4:	c0 88       	rjmp	80008204 <get_arg+0x17c>
800081f6:	30 40       	mov	r0,4
800081f8:	c0 68       	rjmp	80008204 <get_arg+0x17c>
800081fa:	30 30       	mov	r0,3
800081fc:	c0 48       	rjmp	80008204 <get_arg+0x17c>
800081fe:	30 10       	mov	r0,1
80008200:	c0 28       	rjmp	80008204 <get_arg+0x17c>
80008202:	30 00       	mov	r0,0
80008204:	40 3b       	lddsp	r11,sp[0xc]
80008206:	5b fb       	cp.w	r11,-1
80008208:	c0 40       	breq	80008210 <get_arg+0x188>
8000820a:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000820e:	c7 08       	rjmp	800082ee <get_arg+0x266>
80008210:	58 60       	cp.w	r0,6
80008212:	e0 8b 00 6e 	brhi	800082ee <get_arg+0x266>
80008216:	6c 0a       	ld.w	r10,r6[0x0]
80008218:	ea cc ff ff 	sub	r12,r5,-1
8000821c:	fe ce a2 44 	sub	lr,pc,-23996
80008220:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80008224:	f4 cb ff f8 	sub	r11,r10,-8
80008228:	8d 0b       	st.w	r6[0x0],r11
8000822a:	f4 ea 00 00 	ld.d	r10,r10[0]
8000822e:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008232:	c0 f8       	rjmp	80008250 <get_arg+0x1c8>
80008234:	f4 cb ff fc 	sub	r11,r10,-4
80008238:	8d 0b       	st.w	r6[0x0],r11
8000823a:	74 0a       	ld.w	r10,r10[0x0]
8000823c:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80008240:	c0 88       	rjmp	80008250 <get_arg+0x1c8>
80008242:	f4 cb ff f8 	sub	r11,r10,-8
80008246:	8d 0b       	st.w	r6[0x0],r11
80008248:	f4 ea 00 00 	ld.d	r10,r10[0]
8000824c:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80008250:	0e 9b       	mov	r11,r7
80008252:	18 95       	mov	r5,r12
80008254:	c4 e8       	rjmp	800082f0 <get_arg+0x268>
80008256:	62 0a       	ld.w	r10,r1[0x0]
80008258:	5b fa       	cp.w	r10,-1
8000825a:	c0 b1       	brne	80008270 <get_arg+0x1e8>
8000825c:	50 19       	stdsp	sp[0x4],r9
8000825e:	50 28       	stdsp	sp[0x8],r8
80008260:	e0 6a 00 80 	mov	r10,128
80008264:	30 0b       	mov	r11,0
80008266:	02 9c       	mov	r12,r1
80008268:	fe b0 fd 01 	rcall	80007c6a <memset>
8000826c:	40 28       	lddsp	r8,sp[0x8]
8000826e:	40 19       	lddsp	r9,sp[0x4]
80008270:	e4 cc 00 01 	sub	r12,r2,1
80008274:	0e 9b       	mov	r11,r7
80008276:	50 3c       	stdsp	sp[0xc],r12
80008278:	f2 0c 0c 49 	max	r9,r9,r12
8000827c:	c3 a8       	rjmp	800082f0 <get_arg+0x268>
8000827e:	62 0a       	ld.w	r10,r1[0x0]
80008280:	5b fa       	cp.w	r10,-1
80008282:	c0 b1       	brne	80008298 <get_arg+0x210>
80008284:	50 19       	stdsp	sp[0x4],r9
80008286:	50 28       	stdsp	sp[0x8],r8
80008288:	e0 6a 00 80 	mov	r10,128
8000828c:	30 0b       	mov	r11,0
8000828e:	02 9c       	mov	r12,r1
80008290:	fe b0 fc ed 	rcall	80007c6a <memset>
80008294:	40 28       	lddsp	r8,sp[0x8]
80008296:	40 19       	lddsp	r9,sp[0x4]
80008298:	20 12       	sub	r2,1
8000829a:	30 0a       	mov	r10,0
8000829c:	0e 9b       	mov	r11,r7
8000829e:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
800082a2:	f2 02 0c 49 	max	r9,r9,r2
800082a6:	c2 58       	rjmp	800082f0 <get_arg+0x268>
800082a8:	16 97       	mov	r7,r11
800082aa:	6c 0a       	ld.w	r10,r6[0x0]
800082ac:	f4 cb ff fc 	sub	r11,r10,-4
800082b0:	8d 0b       	st.w	r6[0x0],r11
800082b2:	74 0a       	ld.w	r10,r10[0x0]
800082b4:	0e 9b       	mov	r11,r7
800082b6:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
800082ba:	2f f5       	sub	r5,-1
800082bc:	c1 a8       	rjmp	800082f0 <get_arg+0x268>
800082be:	f4 c2 00 30 	sub	r2,r10,48
800082c2:	c0 68       	rjmp	800082ce <get_arg+0x246>
800082c4:	e4 02 00 22 	add	r2,r2,r2<<0x2
800082c8:	2f f7       	sub	r7,-1
800082ca:	f4 02 00 12 	add	r2,r10,r2<<0x1
800082ce:	0f 8a       	ld.ub	r10,r7[0x0]
800082d0:	58 0a       	cp.w	r10,0
800082d2:	c0 e0       	breq	800082ee <get_arg+0x266>
800082d4:	23 0a       	sub	r10,48
800082d6:	58 9a       	cp.w	r10,9
800082d8:	fe 98 ff f6 	brls	800082c4 <get_arg+0x23c>
800082dc:	c0 98       	rjmp	800082ee <get_arg+0x266>
800082de:	2f f7       	sub	r7,-1
800082e0:	0f 8a       	ld.ub	r10,r7[0x0]
800082e2:	58 0a       	cp.w	r10,0
800082e4:	c0 50       	breq	800082ee <get_arg+0x266>
800082e6:	23 0a       	sub	r10,48
800082e8:	58 9a       	cp.w	r10,9
800082ea:	fe 98 ff fa 	brls	800082de <get_arg+0x256>
800082ee:	0e 9b       	mov	r11,r7
800082f0:	40 7c       	lddsp	r12,sp[0x1c]
800082f2:	30 ba       	mov	r10,11
800082f4:	f4 0c 18 00 	cp.b	r12,r10
800082f8:	fe 91 fe f2 	brne	800080dc <get_arg+0x54>
800082fc:	40 42       	lddsp	r2,sp[0x10]
800082fe:	17 8c       	ld.ub	r12,r11[0x0]
80008300:	0a 32       	cp.w	r2,r5
80008302:	5f 4a       	srge	r10
80008304:	f0 0c 18 00 	cp.b	r12,r8
80008308:	5f 1c       	srne	r12
8000830a:	f9 ea 00 0a 	and	r10,r12,r10
8000830e:	f0 0a 18 00 	cp.b	r10,r8
80008312:	fe 91 fe cf 	brne	800080b0 <get_arg+0x28>
80008316:	30 08       	mov	r8,0
80008318:	40 4e       	lddsp	lr,sp[0x10]
8000831a:	17 8a       	ld.ub	r10,r11[0x0]
8000831c:	e2 05 00 21 	add	r1,r1,r5<<0x2
80008320:	f0 0a 18 00 	cp.b	r10,r8
80008324:	fc 09 17 10 	movne	r9,lr
80008328:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000832c:	06 9e       	mov	lr,r3
8000832e:	c2 a8       	rjmp	80008382 <get_arg+0x2fa>
80008330:	62 0a       	ld.w	r10,r1[0x0]
80008332:	58 3a       	cp.w	r10,3
80008334:	c1 e0       	breq	80008370 <get_arg+0x2e8>
80008336:	e0 89 00 07 	brgt	80008344 <get_arg+0x2bc>
8000833a:	58 1a       	cp.w	r10,1
8000833c:	c1 a0       	breq	80008370 <get_arg+0x2e8>
8000833e:	58 2a       	cp.w	r10,2
80008340:	c1 81       	brne	80008370 <get_arg+0x2e8>
80008342:	c0 58       	rjmp	8000834c <get_arg+0x2c4>
80008344:	58 5a       	cp.w	r10,5
80008346:	c0 c0       	breq	8000835e <get_arg+0x2d6>
80008348:	c0 b5       	brlt	8000835e <get_arg+0x2d6>
8000834a:	c1 38       	rjmp	80008370 <get_arg+0x2e8>
8000834c:	6c 0a       	ld.w	r10,r6[0x0]
8000834e:	f4 cc ff f8 	sub	r12,r10,-8
80008352:	8d 0c       	st.w	r6[0x0],r12
80008354:	f4 e2 00 00 	ld.d	r2,r10[0]
80008358:	f0 e3 00 00 	st.d	r8[0],r2
8000835c:	c1 08       	rjmp	8000837c <get_arg+0x2f4>
8000835e:	6c 0a       	ld.w	r10,r6[0x0]
80008360:	f4 cc ff f8 	sub	r12,r10,-8
80008364:	8d 0c       	st.w	r6[0x0],r12
80008366:	f4 e2 00 00 	ld.d	r2,r10[0]
8000836a:	f0 e3 00 00 	st.d	r8[0],r2
8000836e:	c0 78       	rjmp	8000837c <get_arg+0x2f4>
80008370:	6c 0a       	ld.w	r10,r6[0x0]
80008372:	f4 cc ff fc 	sub	r12,r10,-4
80008376:	8d 0c       	st.w	r6[0x0],r12
80008378:	74 0a       	ld.w	r10,r10[0x0]
8000837a:	91 0a       	st.w	r8[0x0],r10
8000837c:	2f f5       	sub	r5,-1
8000837e:	2f 88       	sub	r8,-8
80008380:	2f c1       	sub	r1,-4
80008382:	12 35       	cp.w	r5,r9
80008384:	fe 9a ff d6 	brle	80008330 <get_arg+0x2a8>
80008388:	1c 93       	mov	r3,lr
8000838a:	40 52       	lddsp	r2,sp[0x14]
8000838c:	40 6e       	lddsp	lr,sp[0x18]
8000838e:	85 05       	st.w	r2[0x0],r5
80008390:	9d 0b       	st.w	lr[0x0],r11
80008392:	40 4b       	lddsp	r11,sp[0x10]
80008394:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80008398:	2f 8d       	sub	sp,-32
8000839a:	d8 32       	popm	r0-r7,pc

8000839c <__sprint_r>:
8000839c:	d4 21       	pushm	r4-r7,lr
8000839e:	14 97       	mov	r7,r10
800083a0:	74 28       	ld.w	r8,r10[0x8]
800083a2:	58 08       	cp.w	r8,0
800083a4:	c0 41       	brne	800083ac <__sprint_r+0x10>
800083a6:	95 18       	st.w	r10[0x4],r8
800083a8:	10 9c       	mov	r12,r8
800083aa:	d8 22       	popm	r4-r7,pc
800083ac:	e0 a0 18 ba 	rcall	8000b520 <__sfvwrite_r>
800083b0:	30 08       	mov	r8,0
800083b2:	8f 18       	st.w	r7[0x4],r8
800083b4:	8f 28       	st.w	r7[0x8],r8
800083b6:	d8 22       	popm	r4-r7,pc

800083b8 <_vfprintf_r>:
800083b8:	d4 31       	pushm	r0-r7,lr
800083ba:	fa cd 06 bc 	sub	sp,sp,1724
800083be:	51 09       	stdsp	sp[0x40],r9
800083c0:	16 91       	mov	r1,r11
800083c2:	14 97       	mov	r7,r10
800083c4:	18 95       	mov	r5,r12
800083c6:	e0 a0 1a 1d 	rcall	8000b800 <_localeconv_r>
800083ca:	78 0c       	ld.w	r12,r12[0x0]
800083cc:	50 cc       	stdsp	sp[0x30],r12
800083ce:	58 05       	cp.w	r5,0
800083d0:	c0 70       	breq	800083de <_vfprintf_r+0x26>
800083d2:	6a 68       	ld.w	r8,r5[0x18]
800083d4:	58 08       	cp.w	r8,0
800083d6:	c0 41       	brne	800083de <_vfprintf_r+0x26>
800083d8:	0a 9c       	mov	r12,r5
800083da:	e0 a0 17 43 	rcall	8000b260 <__sinit>
800083de:	fe c8 a0 42 	sub	r8,pc,-24510
800083e2:	10 31       	cp.w	r1,r8
800083e4:	c0 31       	brne	800083ea <_vfprintf_r+0x32>
800083e6:	6a 01       	ld.w	r1,r5[0x0]
800083e8:	c0 c8       	rjmp	80008400 <_vfprintf_r+0x48>
800083ea:	fe c8 a0 2e 	sub	r8,pc,-24530
800083ee:	10 31       	cp.w	r1,r8
800083f0:	c0 31       	brne	800083f6 <_vfprintf_r+0x3e>
800083f2:	6a 11       	ld.w	r1,r5[0x4]
800083f4:	c0 68       	rjmp	80008400 <_vfprintf_r+0x48>
800083f6:	fe c8 a0 1a 	sub	r8,pc,-24550
800083fa:	10 31       	cp.w	r1,r8
800083fc:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80008400:	82 68       	ld.sh	r8,r1[0xc]
80008402:	ed b8 00 03 	bld	r8,0x3
80008406:	c0 41       	brne	8000840e <_vfprintf_r+0x56>
80008408:	62 48       	ld.w	r8,r1[0x10]
8000840a:	58 08       	cp.w	r8,0
8000840c:	c0 71       	brne	8000841a <_vfprintf_r+0x62>
8000840e:	02 9b       	mov	r11,r1
80008410:	0a 9c       	mov	r12,r5
80008412:	e0 a0 0f 5d 	rcall	8000a2cc <__swsetup_r>
80008416:	e0 81 0f 54 	brne	8000a2be <_vfprintf_r+0x1f06>
8000841a:	82 68       	ld.sh	r8,r1[0xc]
8000841c:	10 99       	mov	r9,r8
8000841e:	e2 19 00 1a 	andl	r9,0x1a,COH
80008422:	58 a9       	cp.w	r9,10
80008424:	c3 c1       	brne	8000849c <_vfprintf_r+0xe4>
80008426:	82 79       	ld.sh	r9,r1[0xe]
80008428:	30 0a       	mov	r10,0
8000842a:	f4 09 19 00 	cp.h	r9,r10
8000842e:	c3 75       	brlt	8000849c <_vfprintf_r+0xe4>
80008430:	a1 d8       	cbr	r8,0x1
80008432:	fb 58 05 d0 	st.h	sp[1488],r8
80008436:	62 88       	ld.w	r8,r1[0x20]
80008438:	fb 48 05 e4 	st.w	sp[1508],r8
8000843c:	62 a8       	ld.w	r8,r1[0x28]
8000843e:	fb 48 05 ec 	st.w	sp[1516],r8
80008442:	fa c8 ff bc 	sub	r8,sp,-68
80008446:	fb 48 05 d4 	st.w	sp[1492],r8
8000844a:	fb 48 05 c4 	st.w	sp[1476],r8
8000844e:	e0 68 04 00 	mov	r8,1024
80008452:	fb 48 05 d8 	st.w	sp[1496],r8
80008456:	fb 48 05 cc 	st.w	sp[1484],r8
8000845a:	30 08       	mov	r8,0
8000845c:	fb 59 05 d2 	st.h	sp[1490],r9
80008460:	0e 9a       	mov	r10,r7
80008462:	41 09       	lddsp	r9,sp[0x40]
80008464:	fa c7 fa 3c 	sub	r7,sp,-1476
80008468:	fb 48 05 dc 	st.w	sp[1500],r8
8000846c:	0a 9c       	mov	r12,r5
8000846e:	0e 9b       	mov	r11,r7
80008470:	ca 4f       	rcall	800083b8 <_vfprintf_r>
80008472:	50 bc       	stdsp	sp[0x2c],r12
80008474:	c0 95       	brlt	80008486 <_vfprintf_r+0xce>
80008476:	0e 9b       	mov	r11,r7
80008478:	0a 9c       	mov	r12,r5
8000847a:	e0 a0 16 1b 	rcall	8000b0b0 <_fflush_r>
8000847e:	40 be       	lddsp	lr,sp[0x2c]
80008480:	f9 be 01 ff 	movne	lr,-1
80008484:	50 be       	stdsp	sp[0x2c],lr
80008486:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000848a:	ed b8 00 06 	bld	r8,0x6
8000848e:	e0 81 0f 1a 	brne	8000a2c2 <_vfprintf_r+0x1f0a>
80008492:	82 68       	ld.sh	r8,r1[0xc]
80008494:	a7 a8       	sbr	r8,0x6
80008496:	a2 68       	st.h	r1[0xc],r8
80008498:	e0 8f 0f 15 	bral	8000a2c2 <_vfprintf_r+0x1f0a>
8000849c:	30 08       	mov	r8,0
8000849e:	fb 48 06 b4 	st.w	sp[1716],r8
800084a2:	fb 48 06 90 	st.w	sp[1680],r8
800084a6:	fb 48 06 8c 	st.w	sp[1676],r8
800084aa:	fb 48 06 b0 	st.w	sp[1712],r8
800084ae:	30 08       	mov	r8,0
800084b0:	30 09       	mov	r9,0
800084b2:	50 a7       	stdsp	sp[0x28],r7
800084b4:	50 78       	stdsp	sp[0x1c],r8
800084b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800084ba:	3f f8       	mov	r8,-1
800084bc:	50 59       	stdsp	sp[0x14],r9
800084be:	fb 43 06 88 	st.w	sp[1672],r3
800084c2:	fb 48 05 44 	st.w	sp[1348],r8
800084c6:	12 9c       	mov	r12,r9
800084c8:	50 69       	stdsp	sp[0x18],r9
800084ca:	50 d9       	stdsp	sp[0x34],r9
800084cc:	50 e9       	stdsp	sp[0x38],r9
800084ce:	50 b9       	stdsp	sp[0x2c],r9
800084d0:	12 97       	mov	r7,r9
800084d2:	0a 94       	mov	r4,r5
800084d4:	40 a2       	lddsp	r2,sp[0x28]
800084d6:	32 5a       	mov	r10,37
800084d8:	30 08       	mov	r8,0
800084da:	c0 28       	rjmp	800084de <_vfprintf_r+0x126>
800084dc:	2f f2       	sub	r2,-1
800084de:	05 89       	ld.ub	r9,r2[0x0]
800084e0:	f0 09 18 00 	cp.b	r9,r8
800084e4:	5f 1b       	srne	r11
800084e6:	f4 09 18 00 	cp.b	r9,r10
800084ea:	5f 19       	srne	r9
800084ec:	f3 eb 00 0b 	and	r11,r9,r11
800084f0:	f0 0b 18 00 	cp.b	r11,r8
800084f4:	cf 41       	brne	800084dc <_vfprintf_r+0x124>
800084f6:	40 ab       	lddsp	r11,sp[0x28]
800084f8:	e4 0b 01 06 	sub	r6,r2,r11
800084fc:	c1 e0       	breq	80008538 <_vfprintf_r+0x180>
800084fe:	fa f8 06 90 	ld.w	r8,sp[1680]
80008502:	0c 08       	add	r8,r6
80008504:	87 0b       	st.w	r3[0x0],r11
80008506:	fb 48 06 90 	st.w	sp[1680],r8
8000850a:	87 16       	st.w	r3[0x4],r6
8000850c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008510:	2f f8       	sub	r8,-1
80008512:	fb 48 06 8c 	st.w	sp[1676],r8
80008516:	58 78       	cp.w	r8,7
80008518:	e0 89 00 04 	brgt	80008520 <_vfprintf_r+0x168>
8000851c:	2f 83       	sub	r3,-8
8000851e:	c0 a8       	rjmp	80008532 <_vfprintf_r+0x17a>
80008520:	fa ca f9 78 	sub	r10,sp,-1672
80008524:	02 9b       	mov	r11,r1
80008526:	08 9c       	mov	r12,r4
80008528:	c3 af       	rcall	8000839c <__sprint_r>
8000852a:	e0 81 0e c6 	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000852e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008532:	40 ba       	lddsp	r10,sp[0x2c]
80008534:	0c 0a       	add	r10,r6
80008536:	50 ba       	stdsp	sp[0x2c],r10
80008538:	05 89       	ld.ub	r9,r2[0x0]
8000853a:	30 08       	mov	r8,0
8000853c:	f0 09 18 00 	cp.b	r9,r8
80008540:	e0 80 0e aa 	breq	8000a294 <_vfprintf_r+0x1edc>
80008544:	30 09       	mov	r9,0
80008546:	fb 68 06 bb 	st.b	sp[1723],r8
8000854a:	0e 96       	mov	r6,r7
8000854c:	e4 c8 ff ff 	sub	r8,r2,-1
80008550:	3f fe       	mov	lr,-1
80008552:	50 93       	stdsp	sp[0x24],r3
80008554:	50 41       	stdsp	sp[0x10],r1
80008556:	0e 93       	mov	r3,r7
80008558:	04 91       	mov	r1,r2
8000855a:	50 89       	stdsp	sp[0x20],r9
8000855c:	50 a8       	stdsp	sp[0x28],r8
8000855e:	50 2e       	stdsp	sp[0x8],lr
80008560:	50 39       	stdsp	sp[0xc],r9
80008562:	12 95       	mov	r5,r9
80008564:	12 90       	mov	r0,r9
80008566:	10 97       	mov	r7,r8
80008568:	08 92       	mov	r2,r4
8000856a:	c0 78       	rjmp	80008578 <_vfprintf_r+0x1c0>
8000856c:	3f fc       	mov	r12,-1
8000856e:	08 97       	mov	r7,r4
80008570:	50 2c       	stdsp	sp[0x8],r12
80008572:	c0 38       	rjmp	80008578 <_vfprintf_r+0x1c0>
80008574:	30 0b       	mov	r11,0
80008576:	50 3b       	stdsp	sp[0xc],r11
80008578:	0f 38       	ld.ub	r8,r7++
8000857a:	c0 28       	rjmp	8000857e <_vfprintf_r+0x1c6>
8000857c:	12 90       	mov	r0,r9
8000857e:	f0 c9 00 20 	sub	r9,r8,32
80008582:	e0 49 00 58 	cp.w	r9,88
80008586:	e0 8b 0a 30 	brhi	800099e6 <_vfprintf_r+0x162e>
8000858a:	fe ca a5 96 	sub	r10,pc,-23146
8000858e:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80008592:	50 a7       	stdsp	sp[0x28],r7
80008594:	50 80       	stdsp	sp[0x20],r0
80008596:	0c 97       	mov	r7,r6
80008598:	04 94       	mov	r4,r2
8000859a:	06 96       	mov	r6,r3
8000859c:	02 92       	mov	r2,r1
8000859e:	fe c9 a3 6e 	sub	r9,pc,-23698
800085a2:	40 93       	lddsp	r3,sp[0x24]
800085a4:	10 90       	mov	r0,r8
800085a6:	40 41       	lddsp	r1,sp[0x10]
800085a8:	50 d9       	stdsp	sp[0x34],r9
800085aa:	e0 8f 08 8e 	bral	800096c6 <_vfprintf_r+0x130e>
800085ae:	30 08       	mov	r8,0
800085b0:	fb 39 06 bb 	ld.ub	r9,sp[1723]
800085b4:	f0 09 18 00 	cp.b	r9,r8
800085b8:	ce 01       	brne	80008578 <_vfprintf_r+0x1c0>
800085ba:	32 08       	mov	r8,32
800085bc:	c6 e8       	rjmp	80008698 <_vfprintf_r+0x2e0>
800085be:	a1 a5       	sbr	r5,0x0
800085c0:	cd cb       	rjmp	80008578 <_vfprintf_r+0x1c0>
800085c2:	0f 89       	ld.ub	r9,r7[0x0]
800085c4:	f2 c8 00 30 	sub	r8,r9,48
800085c8:	58 98       	cp.w	r8,9
800085ca:	e0 8b 00 1d 	brhi	80008604 <_vfprintf_r+0x24c>
800085ce:	ee c8 ff ff 	sub	r8,r7,-1
800085d2:	30 0b       	mov	r11,0
800085d4:	23 09       	sub	r9,48
800085d6:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800085da:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800085de:	11 39       	ld.ub	r9,r8++
800085e0:	f2 ca 00 30 	sub	r10,r9,48
800085e4:	58 9a       	cp.w	r10,9
800085e6:	fe 98 ff f7 	brls	800085d4 <_vfprintf_r+0x21c>
800085ea:	e0 49 00 24 	cp.w	r9,36
800085ee:	cc 31       	brne	80008574 <_vfprintf_r+0x1bc>
800085f0:	e0 4b 00 20 	cp.w	r11,32
800085f4:	e0 89 0e 60 	brgt	8000a2b4 <_vfprintf_r+0x1efc>
800085f8:	20 1b       	sub	r11,1
800085fa:	fa f9 06 b4 	ld.w	r9,sp[1716]
800085fe:	12 3b       	cp.w	r11,r9
80008600:	c0 95       	brlt	80008612 <_vfprintf_r+0x25a>
80008602:	c1 08       	rjmp	80008622 <_vfprintf_r+0x26a>
80008604:	fa f9 06 b4 	ld.w	r9,sp[1716]
80008608:	ec ca ff ff 	sub	r10,r6,-1
8000860c:	12 36       	cp.w	r6,r9
8000860e:	c1 f5       	brlt	8000864c <_vfprintf_r+0x294>
80008610:	c2 68       	rjmp	8000865c <_vfprintf_r+0x2a4>
80008612:	fa ce f9 44 	sub	lr,sp,-1724
80008616:	10 97       	mov	r7,r8
80008618:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000861c:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80008620:	c3 58       	rjmp	8000868a <_vfprintf_r+0x2d2>
80008622:	10 97       	mov	r7,r8
80008624:	fa c8 f9 50 	sub	r8,sp,-1712
80008628:	1a d8       	st.w	--sp,r8
8000862a:	fa c8 fa b8 	sub	r8,sp,-1352
8000862e:	1a d8       	st.w	--sp,r8
80008630:	fa c8 fb b4 	sub	r8,sp,-1100
80008634:	02 9a       	mov	r10,r1
80008636:	1a d8       	st.w	--sp,r8
80008638:	04 9c       	mov	r12,r2
8000863a:	fa c8 f9 40 	sub	r8,sp,-1728
8000863e:	fa c9 ff b4 	sub	r9,sp,-76
80008642:	fe b0 fd 23 	rcall	80008088 <get_arg>
80008646:	2f dd       	sub	sp,-12
80008648:	78 00       	ld.w	r0,r12[0x0]
8000864a:	c2 08       	rjmp	8000868a <_vfprintf_r+0x2d2>
8000864c:	fa cc f9 44 	sub	r12,sp,-1724
80008650:	14 96       	mov	r6,r10
80008652:	f8 03 00 38 	add	r8,r12,r3<<0x3
80008656:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000865a:	c1 88       	rjmp	8000868a <_vfprintf_r+0x2d2>
8000865c:	41 08       	lddsp	r8,sp[0x40]
8000865e:	59 f9       	cp.w	r9,31
80008660:	e0 89 00 11 	brgt	80008682 <_vfprintf_r+0x2ca>
80008664:	f0 cb ff fc 	sub	r11,r8,-4
80008668:	51 0b       	stdsp	sp[0x40],r11
8000866a:	70 00       	ld.w	r0,r8[0x0]
8000866c:	fa cb f9 44 	sub	r11,sp,-1724
80008670:	f6 09 00 38 	add	r8,r11,r9<<0x3
80008674:	f1 40 fd 88 	st.w	r8[-632],r0
80008678:	2f f9       	sub	r9,-1
8000867a:	14 96       	mov	r6,r10
8000867c:	fb 49 06 b4 	st.w	sp[1716],r9
80008680:	c0 58       	rjmp	8000868a <_vfprintf_r+0x2d2>
80008682:	70 00       	ld.w	r0,r8[0x0]
80008684:	14 96       	mov	r6,r10
80008686:	2f c8       	sub	r8,-4
80008688:	51 08       	stdsp	sp[0x40],r8
8000868a:	58 00       	cp.w	r0,0
8000868c:	fe 94 ff 76 	brge	80008578 <_vfprintf_r+0x1c0>
80008690:	5c 30       	neg	r0
80008692:	a3 a5       	sbr	r5,0x2
80008694:	c7 2b       	rjmp	80008578 <_vfprintf_r+0x1c0>
80008696:	32 b8       	mov	r8,43
80008698:	fb 68 06 bb 	st.b	sp[1723],r8
8000869c:	c6 eb       	rjmp	80008578 <_vfprintf_r+0x1c0>
8000869e:	0f 38       	ld.ub	r8,r7++
800086a0:	e0 48 00 2a 	cp.w	r8,42
800086a4:	c0 30       	breq	800086aa <_vfprintf_r+0x2f2>
800086a6:	30 09       	mov	r9,0
800086a8:	c7 98       	rjmp	8000879a <_vfprintf_r+0x3e2>
800086aa:	0f 88       	ld.ub	r8,r7[0x0]
800086ac:	f0 c9 00 30 	sub	r9,r8,48
800086b0:	58 99       	cp.w	r9,9
800086b2:	e0 8b 00 1f 	brhi	800086f0 <_vfprintf_r+0x338>
800086b6:	ee c4 ff ff 	sub	r4,r7,-1
800086ba:	30 0b       	mov	r11,0
800086bc:	23 08       	sub	r8,48
800086be:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
800086c2:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
800086c6:	09 38       	ld.ub	r8,r4++
800086c8:	f0 c9 00 30 	sub	r9,r8,48
800086cc:	58 99       	cp.w	r9,9
800086ce:	fe 98 ff f7 	brls	800086bc <_vfprintf_r+0x304>
800086d2:	e0 48 00 24 	cp.w	r8,36
800086d6:	fe 91 ff 4f 	brne	80008574 <_vfprintf_r+0x1bc>
800086da:	e0 4b 00 20 	cp.w	r11,32
800086de:	e0 89 0d eb 	brgt	8000a2b4 <_vfprintf_r+0x1efc>
800086e2:	20 1b       	sub	r11,1
800086e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800086e8:	10 3b       	cp.w	r11,r8
800086ea:	c0 a5       	brlt	800086fe <_vfprintf_r+0x346>
800086ec:	c1 18       	rjmp	8000870e <_vfprintf_r+0x356>
800086ee:	d7 03       	nop
800086f0:	fa fa 06 b4 	ld.w	r10,sp[1716]
800086f4:	ec c9 ff ff 	sub	r9,r6,-1
800086f8:	14 36       	cp.w	r6,r10
800086fa:	c1 f5       	brlt	80008738 <_vfprintf_r+0x380>
800086fc:	c2 88       	rjmp	8000874c <_vfprintf_r+0x394>
800086fe:	fa ca f9 44 	sub	r10,sp,-1724
80008702:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
80008706:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000870a:	50 2b       	stdsp	sp[0x8],r11
8000870c:	c3 c8       	rjmp	80008784 <_vfprintf_r+0x3cc>
8000870e:	fa c8 f9 50 	sub	r8,sp,-1712
80008712:	1a d8       	st.w	--sp,r8
80008714:	fa c8 fa b8 	sub	r8,sp,-1352
80008718:	1a d8       	st.w	--sp,r8
8000871a:	fa c8 fb b4 	sub	r8,sp,-1100
8000871e:	02 9a       	mov	r10,r1
80008720:	1a d8       	st.w	--sp,r8
80008722:	04 9c       	mov	r12,r2
80008724:	fa c8 f9 40 	sub	r8,sp,-1728
80008728:	fa c9 ff b4 	sub	r9,sp,-76
8000872c:	fe b0 fc ae 	rcall	80008088 <get_arg>
80008730:	2f dd       	sub	sp,-12
80008732:	78 0c       	ld.w	r12,r12[0x0]
80008734:	50 2c       	stdsp	sp[0x8],r12
80008736:	c2 78       	rjmp	80008784 <_vfprintf_r+0x3cc>
80008738:	12 96       	mov	r6,r9
8000873a:	0e 94       	mov	r4,r7
8000873c:	fa c9 f9 44 	sub	r9,sp,-1724
80008740:	f2 03 00 38 	add	r8,r9,r3<<0x3
80008744:	f0 f8 fd 88 	ld.w	r8,r8[-632]
80008748:	50 28       	stdsp	sp[0x8],r8
8000874a:	c1 d8       	rjmp	80008784 <_vfprintf_r+0x3cc>
8000874c:	41 08       	lddsp	r8,sp[0x40]
8000874e:	59 fa       	cp.w	r10,31
80008750:	e0 89 00 14 	brgt	80008778 <_vfprintf_r+0x3c0>
80008754:	f0 cb ff fc 	sub	r11,r8,-4
80008758:	70 08       	ld.w	r8,r8[0x0]
8000875a:	51 0b       	stdsp	sp[0x40],r11
8000875c:	50 28       	stdsp	sp[0x8],r8
8000875e:	fa c6 f9 44 	sub	r6,sp,-1724
80008762:	40 2e       	lddsp	lr,sp[0x8]
80008764:	ec 0a 00 38 	add	r8,r6,r10<<0x3
80008768:	f1 4e fd 88 	st.w	r8[-632],lr
8000876c:	2f fa       	sub	r10,-1
8000876e:	0e 94       	mov	r4,r7
80008770:	fb 4a 06 b4 	st.w	sp[1716],r10
80008774:	12 96       	mov	r6,r9
80008776:	c0 78       	rjmp	80008784 <_vfprintf_r+0x3cc>
80008778:	70 0c       	ld.w	r12,r8[0x0]
8000877a:	0e 94       	mov	r4,r7
8000877c:	2f c8       	sub	r8,-4
8000877e:	50 2c       	stdsp	sp[0x8],r12
80008780:	12 96       	mov	r6,r9
80008782:	51 08       	stdsp	sp[0x40],r8
80008784:	40 2b       	lddsp	r11,sp[0x8]
80008786:	58 0b       	cp.w	r11,0
80008788:	fe 95 fe f2 	brlt	8000856c <_vfprintf_r+0x1b4>
8000878c:	08 97       	mov	r7,r4
8000878e:	cf 5a       	rjmp	80008578 <_vfprintf_r+0x1c0>
80008790:	f2 09 00 29 	add	r9,r9,r9<<0x2
80008794:	0f 38       	ld.ub	r8,r7++
80008796:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000879a:	f0 ca 00 30 	sub	r10,r8,48
8000879e:	58 9a       	cp.w	r10,9
800087a0:	fe 98 ff f8 	brls	80008790 <_vfprintf_r+0x3d8>
800087a4:	3f fa       	mov	r10,-1
800087a6:	f2 0a 0c 49 	max	r9,r9,r10
800087aa:	50 29       	stdsp	sp[0x8],r9
800087ac:	ce 9a       	rjmp	8000857e <_vfprintf_r+0x1c6>
800087ae:	a7 b5       	sbr	r5,0x7
800087b0:	ce 4a       	rjmp	80008578 <_vfprintf_r+0x1c0>
800087b2:	30 09       	mov	r9,0
800087b4:	23 08       	sub	r8,48
800087b6:	f2 09 00 29 	add	r9,r9,r9<<0x2
800087ba:	f0 09 00 19 	add	r9,r8,r9<<0x1
800087be:	0f 38       	ld.ub	r8,r7++
800087c0:	f0 ca 00 30 	sub	r10,r8,48
800087c4:	58 9a       	cp.w	r10,9
800087c6:	fe 98 ff f7 	brls	800087b4 <_vfprintf_r+0x3fc>
800087ca:	e0 48 00 24 	cp.w	r8,36
800087ce:	fe 91 fe d7 	brne	8000857c <_vfprintf_r+0x1c4>
800087d2:	e0 49 00 20 	cp.w	r9,32
800087d6:	e0 89 0d 6f 	brgt	8000a2b4 <_vfprintf_r+0x1efc>
800087da:	f2 c3 00 01 	sub	r3,r9,1
800087de:	30 19       	mov	r9,1
800087e0:	50 39       	stdsp	sp[0xc],r9
800087e2:	cc ba       	rjmp	80008578 <_vfprintf_r+0x1c0>
800087e4:	a3 b5       	sbr	r5,0x3
800087e6:	cc 9a       	rjmp	80008578 <_vfprintf_r+0x1c0>
800087e8:	a7 a5       	sbr	r5,0x6
800087ea:	cc 7a       	rjmp	80008578 <_vfprintf_r+0x1c0>
800087ec:	0a 98       	mov	r8,r5
800087ee:	a5 b5       	sbr	r5,0x5
800087f0:	a5 a8       	sbr	r8,0x4
800087f2:	0f 89       	ld.ub	r9,r7[0x0]
800087f4:	36 ce       	mov	lr,108
800087f6:	fc 09 18 00 	cp.b	r9,lr
800087fa:	f7 b7 00 ff 	subeq	r7,-1
800087fe:	f0 05 17 10 	movne	r5,r8
80008802:	cb ba       	rjmp	80008578 <_vfprintf_r+0x1c0>
80008804:	a5 b5       	sbr	r5,0x5
80008806:	cb 9a       	rjmp	80008578 <_vfprintf_r+0x1c0>
80008808:	50 a7       	stdsp	sp[0x28],r7
8000880a:	50 80       	stdsp	sp[0x20],r0
8000880c:	0c 97       	mov	r7,r6
8000880e:	10 90       	mov	r0,r8
80008810:	06 96       	mov	r6,r3
80008812:	04 94       	mov	r4,r2
80008814:	40 93       	lddsp	r3,sp[0x24]
80008816:	02 92       	mov	r2,r1
80008818:	0e 99       	mov	r9,r7
8000881a:	40 41       	lddsp	r1,sp[0x10]
8000881c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008820:	40 3c       	lddsp	r12,sp[0xc]
80008822:	58 0c       	cp.w	r12,0
80008824:	c1 d0       	breq	8000885e <_vfprintf_r+0x4a6>
80008826:	10 36       	cp.w	r6,r8
80008828:	c0 64       	brge	80008834 <_vfprintf_r+0x47c>
8000882a:	fa cb f9 44 	sub	r11,sp,-1724
8000882e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008832:	c1 d8       	rjmp	8000886c <_vfprintf_r+0x4b4>
80008834:	fa c8 f9 50 	sub	r8,sp,-1712
80008838:	1a d8       	st.w	--sp,r8
8000883a:	fa c8 fa b8 	sub	r8,sp,-1352
8000883e:	1a d8       	st.w	--sp,r8
80008840:	fa c8 fb b4 	sub	r8,sp,-1100
80008844:	1a d8       	st.w	--sp,r8
80008846:	fa c8 f9 40 	sub	r8,sp,-1728
8000884a:	fa c9 ff b4 	sub	r9,sp,-76
8000884e:	04 9a       	mov	r10,r2
80008850:	0c 9b       	mov	r11,r6
80008852:	08 9c       	mov	r12,r4
80008854:	fe b0 fc 1a 	rcall	80008088 <get_arg>
80008858:	2f dd       	sub	sp,-12
8000885a:	19 b8       	ld.ub	r8,r12[0x3]
8000885c:	c2 28       	rjmp	800088a0 <_vfprintf_r+0x4e8>
8000885e:	2f f7       	sub	r7,-1
80008860:	10 39       	cp.w	r9,r8
80008862:	c0 84       	brge	80008872 <_vfprintf_r+0x4ba>
80008864:	fa ca f9 44 	sub	r10,sp,-1724
80008868:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000886c:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
80008870:	c1 88       	rjmp	800088a0 <_vfprintf_r+0x4e8>
80008872:	41 09       	lddsp	r9,sp[0x40]
80008874:	59 f8       	cp.w	r8,31
80008876:	e0 89 00 12 	brgt	8000889a <_vfprintf_r+0x4e2>
8000887a:	f2 ca ff fc 	sub	r10,r9,-4
8000887e:	51 0a       	stdsp	sp[0x40],r10
80008880:	72 09       	ld.w	r9,r9[0x0]
80008882:	fa c6 f9 44 	sub	r6,sp,-1724
80008886:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000888a:	2f f8       	sub	r8,-1
8000888c:	f5 49 fd 88 	st.w	r10[-632],r9
80008890:	fb 48 06 b4 	st.w	sp[1716],r8
80008894:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80008898:	c0 48       	rjmp	800088a0 <_vfprintf_r+0x4e8>
8000889a:	13 b8       	ld.ub	r8,r9[0x3]
8000889c:	2f c9       	sub	r9,-4
8000889e:	51 09       	stdsp	sp[0x40],r9
800088a0:	fb 68 06 60 	st.b	sp[1632],r8
800088a4:	30 0e       	mov	lr,0
800088a6:	30 08       	mov	r8,0
800088a8:	30 12       	mov	r2,1
800088aa:	fb 68 06 bb 	st.b	sp[1723],r8
800088ae:	50 2e       	stdsp	sp[0x8],lr
800088b0:	e0 8f 08 ad 	bral	80009a0a <_vfprintf_r+0x1652>
800088b4:	50 a7       	stdsp	sp[0x28],r7
800088b6:	50 80       	stdsp	sp[0x20],r0
800088b8:	0c 97       	mov	r7,r6
800088ba:	04 94       	mov	r4,r2
800088bc:	06 96       	mov	r6,r3
800088be:	02 92       	mov	r2,r1
800088c0:	40 93       	lddsp	r3,sp[0x24]
800088c2:	10 90       	mov	r0,r8
800088c4:	40 41       	lddsp	r1,sp[0x10]
800088c6:	a5 a5       	sbr	r5,0x4
800088c8:	c0 a8       	rjmp	800088dc <_vfprintf_r+0x524>
800088ca:	50 a7       	stdsp	sp[0x28],r7
800088cc:	50 80       	stdsp	sp[0x20],r0
800088ce:	0c 97       	mov	r7,r6
800088d0:	04 94       	mov	r4,r2
800088d2:	06 96       	mov	r6,r3
800088d4:	02 92       	mov	r2,r1
800088d6:	40 93       	lddsp	r3,sp[0x24]
800088d8:	10 90       	mov	r0,r8
800088da:	40 41       	lddsp	r1,sp[0x10]
800088dc:	ed b5 00 05 	bld	r5,0x5
800088e0:	c5 11       	brne	80008982 <_vfprintf_r+0x5ca>
800088e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800088e6:	40 3c       	lddsp	r12,sp[0xc]
800088e8:	58 0c       	cp.w	r12,0
800088ea:	c1 e0       	breq	80008926 <_vfprintf_r+0x56e>
800088ec:	10 36       	cp.w	r6,r8
800088ee:	c0 64       	brge	800088fa <_vfprintf_r+0x542>
800088f0:	fa cb f9 44 	sub	r11,sp,-1724
800088f4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800088f8:	c2 08       	rjmp	80008938 <_vfprintf_r+0x580>
800088fa:	fa c8 f9 50 	sub	r8,sp,-1712
800088fe:	1a d8       	st.w	--sp,r8
80008900:	fa c8 fa b8 	sub	r8,sp,-1352
80008904:	0c 9b       	mov	r11,r6
80008906:	1a d8       	st.w	--sp,r8
80008908:	fa c8 fb b4 	sub	r8,sp,-1100
8000890c:	1a d8       	st.w	--sp,r8
8000890e:	fa c9 ff b4 	sub	r9,sp,-76
80008912:	fa c8 f9 40 	sub	r8,sp,-1728
80008916:	04 9a       	mov	r10,r2
80008918:	08 9c       	mov	r12,r4
8000891a:	fe b0 fb b7 	rcall	80008088 <get_arg>
8000891e:	2f dd       	sub	sp,-12
80008920:	78 1b       	ld.w	r11,r12[0x4]
80008922:	78 09       	ld.w	r9,r12[0x0]
80008924:	c2 b8       	rjmp	8000897a <_vfprintf_r+0x5c2>
80008926:	ee ca ff ff 	sub	r10,r7,-1
8000892a:	10 37       	cp.w	r7,r8
8000892c:	c0 b4       	brge	80008942 <_vfprintf_r+0x58a>
8000892e:	fa c9 f9 44 	sub	r9,sp,-1724
80008932:	14 97       	mov	r7,r10
80008934:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008938:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000893c:	ec f9 fd 88 	ld.w	r9,r6[-632]
80008940:	c1 d8       	rjmp	8000897a <_vfprintf_r+0x5c2>
80008942:	41 09       	lddsp	r9,sp[0x40]
80008944:	59 f8       	cp.w	r8,31
80008946:	e0 89 00 14 	brgt	8000896e <_vfprintf_r+0x5b6>
8000894a:	f2 cb ff f8 	sub	r11,r9,-8
8000894e:	51 0b       	stdsp	sp[0x40],r11
80008950:	fa c6 f9 44 	sub	r6,sp,-1724
80008954:	72 1b       	ld.w	r11,r9[0x4]
80008956:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000895a:	72 09       	ld.w	r9,r9[0x0]
8000895c:	f9 4b fd 8c 	st.w	r12[-628],r11
80008960:	f9 49 fd 88 	st.w	r12[-632],r9
80008964:	2f f8       	sub	r8,-1
80008966:	14 97       	mov	r7,r10
80008968:	fb 48 06 b4 	st.w	sp[1716],r8
8000896c:	c0 78       	rjmp	8000897a <_vfprintf_r+0x5c2>
8000896e:	f2 c8 ff f8 	sub	r8,r9,-8
80008972:	72 1b       	ld.w	r11,r9[0x4]
80008974:	14 97       	mov	r7,r10
80008976:	51 08       	stdsp	sp[0x40],r8
80008978:	72 09       	ld.w	r9,r9[0x0]
8000897a:	16 98       	mov	r8,r11
8000897c:	fa e9 00 00 	st.d	sp[0],r8
80008980:	ca e8       	rjmp	80008adc <_vfprintf_r+0x724>
80008982:	ed b5 00 04 	bld	r5,0x4
80008986:	c1 71       	brne	800089b4 <_vfprintf_r+0x5fc>
80008988:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000898c:	40 3e       	lddsp	lr,sp[0xc]
8000898e:	58 0e       	cp.w	lr,0
80008990:	c0 80       	breq	800089a0 <_vfprintf_r+0x5e8>
80008992:	10 36       	cp.w	r6,r8
80008994:	c6 94       	brge	80008a66 <_vfprintf_r+0x6ae>
80008996:	fa cc f9 44 	sub	r12,sp,-1724
8000899a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000899e:	c8 28       	rjmp	80008aa2 <_vfprintf_r+0x6ea>
800089a0:	ee ca ff ff 	sub	r10,r7,-1
800089a4:	10 37       	cp.w	r7,r8
800089a6:	e0 84 00 81 	brge	80008aa8 <_vfprintf_r+0x6f0>
800089aa:	fa cb f9 44 	sub	r11,sp,-1724
800089ae:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089b2:	c7 78       	rjmp	80008aa0 <_vfprintf_r+0x6e8>
800089b4:	ed b5 00 06 	bld	r5,0x6
800089b8:	c4 b1       	brne	80008a4e <_vfprintf_r+0x696>
800089ba:	fa f8 06 b4 	ld.w	r8,sp[1716]
800089be:	40 3c       	lddsp	r12,sp[0xc]
800089c0:	58 0c       	cp.w	r12,0
800089c2:	c1 d0       	breq	800089fc <_vfprintf_r+0x644>
800089c4:	10 36       	cp.w	r6,r8
800089c6:	c0 64       	brge	800089d2 <_vfprintf_r+0x61a>
800089c8:	fa cb f9 44 	sub	r11,sp,-1724
800089cc:	f6 06 00 36 	add	r6,r11,r6<<0x3
800089d0:	c1 f8       	rjmp	80008a0e <_vfprintf_r+0x656>
800089d2:	fa c8 f9 50 	sub	r8,sp,-1712
800089d6:	1a d8       	st.w	--sp,r8
800089d8:	fa c8 fa b8 	sub	r8,sp,-1352
800089dc:	1a d8       	st.w	--sp,r8
800089de:	fa c8 fb b4 	sub	r8,sp,-1100
800089e2:	1a d8       	st.w	--sp,r8
800089e4:	fa c8 f9 40 	sub	r8,sp,-1728
800089e8:	fa c9 ff b4 	sub	r9,sp,-76
800089ec:	04 9a       	mov	r10,r2
800089ee:	0c 9b       	mov	r11,r6
800089f0:	08 9c       	mov	r12,r4
800089f2:	fe b0 fb 4b 	rcall	80008088 <get_arg>
800089f6:	2f dd       	sub	sp,-12
800089f8:	98 18       	ld.sh	r8,r12[0x2]
800089fa:	c2 68       	rjmp	80008a46 <_vfprintf_r+0x68e>
800089fc:	ee ca ff ff 	sub	r10,r7,-1
80008a00:	10 37       	cp.w	r7,r8
80008a02:	c0 94       	brge	80008a14 <_vfprintf_r+0x65c>
80008a04:	fa c9 f9 44 	sub	r9,sp,-1724
80008a08:	14 97       	mov	r7,r10
80008a0a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008a0e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80008a12:	c1 a8       	rjmp	80008a46 <_vfprintf_r+0x68e>
80008a14:	41 09       	lddsp	r9,sp[0x40]
80008a16:	59 f8       	cp.w	r8,31
80008a18:	e0 89 00 13 	brgt	80008a3e <_vfprintf_r+0x686>
80008a1c:	f2 cb ff fc 	sub	r11,r9,-4
80008a20:	51 0b       	stdsp	sp[0x40],r11
80008a22:	72 09       	ld.w	r9,r9[0x0]
80008a24:	fa c6 f9 44 	sub	r6,sp,-1724
80008a28:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008a2c:	2f f8       	sub	r8,-1
80008a2e:	f7 49 fd 88 	st.w	r11[-632],r9
80008a32:	fb 48 06 b4 	st.w	sp[1716],r8
80008a36:	14 97       	mov	r7,r10
80008a38:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008a3c:	c0 58       	rjmp	80008a46 <_vfprintf_r+0x68e>
80008a3e:	92 18       	ld.sh	r8,r9[0x2]
80008a40:	14 97       	mov	r7,r10
80008a42:	2f c9       	sub	r9,-4
80008a44:	51 09       	stdsp	sp[0x40],r9
80008a46:	50 18       	stdsp	sp[0x4],r8
80008a48:	bf 58       	asr	r8,0x1f
80008a4a:	50 08       	stdsp	sp[0x0],r8
80008a4c:	c4 88       	rjmp	80008adc <_vfprintf_r+0x724>
80008a4e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008a52:	40 3c       	lddsp	r12,sp[0xc]
80008a54:	58 0c       	cp.w	r12,0
80008a56:	c1 d0       	breq	80008a90 <_vfprintf_r+0x6d8>
80008a58:	10 36       	cp.w	r6,r8
80008a5a:	c0 64       	brge	80008a66 <_vfprintf_r+0x6ae>
80008a5c:	fa cb f9 44 	sub	r11,sp,-1724
80008a60:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008a64:	c1 f8       	rjmp	80008aa2 <_vfprintf_r+0x6ea>
80008a66:	fa c8 f9 50 	sub	r8,sp,-1712
80008a6a:	1a d8       	st.w	--sp,r8
80008a6c:	fa c8 fa b8 	sub	r8,sp,-1352
80008a70:	0c 9b       	mov	r11,r6
80008a72:	1a d8       	st.w	--sp,r8
80008a74:	fa c8 fb b4 	sub	r8,sp,-1100
80008a78:	04 9a       	mov	r10,r2
80008a7a:	1a d8       	st.w	--sp,r8
80008a7c:	08 9c       	mov	r12,r4
80008a7e:	fa c8 f9 40 	sub	r8,sp,-1728
80008a82:	fa c9 ff b4 	sub	r9,sp,-76
80008a86:	fe b0 fb 01 	rcall	80008088 <get_arg>
80008a8a:	2f dd       	sub	sp,-12
80008a8c:	78 0b       	ld.w	r11,r12[0x0]
80008a8e:	c2 48       	rjmp	80008ad6 <_vfprintf_r+0x71e>
80008a90:	ee ca ff ff 	sub	r10,r7,-1
80008a94:	10 37       	cp.w	r7,r8
80008a96:	c0 94       	brge	80008aa8 <_vfprintf_r+0x6f0>
80008a98:	fa c9 f9 44 	sub	r9,sp,-1724
80008a9c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008aa0:	14 97       	mov	r7,r10
80008aa2:	ec fb fd 88 	ld.w	r11,r6[-632]
80008aa6:	c1 88       	rjmp	80008ad6 <_vfprintf_r+0x71e>
80008aa8:	41 09       	lddsp	r9,sp[0x40]
80008aaa:	59 f8       	cp.w	r8,31
80008aac:	e0 89 00 11 	brgt	80008ace <_vfprintf_r+0x716>
80008ab0:	f2 cb ff fc 	sub	r11,r9,-4
80008ab4:	51 0b       	stdsp	sp[0x40],r11
80008ab6:	fa c6 f9 44 	sub	r6,sp,-1724
80008aba:	72 0b       	ld.w	r11,r9[0x0]
80008abc:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008ac0:	f3 4b fd 88 	st.w	r9[-632],r11
80008ac4:	2f f8       	sub	r8,-1
80008ac6:	14 97       	mov	r7,r10
80008ac8:	fb 48 06 b4 	st.w	sp[1716],r8
80008acc:	c0 58       	rjmp	80008ad6 <_vfprintf_r+0x71e>
80008ace:	72 0b       	ld.w	r11,r9[0x0]
80008ad0:	14 97       	mov	r7,r10
80008ad2:	2f c9       	sub	r9,-4
80008ad4:	51 09       	stdsp	sp[0x40],r9
80008ad6:	50 1b       	stdsp	sp[0x4],r11
80008ad8:	bf 5b       	asr	r11,0x1f
80008ada:	50 0b       	stdsp	sp[0x0],r11
80008adc:	fa ea 00 00 	ld.d	r10,sp[0]
80008ae0:	58 0a       	cp.w	r10,0
80008ae2:	5c 2b       	cpc	r11
80008ae4:	c0 e4       	brge	80008b00 <_vfprintf_r+0x748>
80008ae6:	30 08       	mov	r8,0
80008ae8:	fa ea 00 00 	ld.d	r10,sp[0]
80008aec:	30 09       	mov	r9,0
80008aee:	f0 0a 01 0a 	sub	r10,r8,r10
80008af2:	f2 0b 01 4b 	sbc	r11,r9,r11
80008af6:	32 d8       	mov	r8,45
80008af8:	fa eb 00 00 	st.d	sp[0],r10
80008afc:	fb 68 06 bb 	st.b	sp[1723],r8
80008b00:	30 18       	mov	r8,1
80008b02:	e0 8f 06 fa 	bral	800098f6 <_vfprintf_r+0x153e>
80008b06:	50 a7       	stdsp	sp[0x28],r7
80008b08:	50 80       	stdsp	sp[0x20],r0
80008b0a:	0c 97       	mov	r7,r6
80008b0c:	04 94       	mov	r4,r2
80008b0e:	06 96       	mov	r6,r3
80008b10:	02 92       	mov	r2,r1
80008b12:	40 93       	lddsp	r3,sp[0x24]
80008b14:	10 90       	mov	r0,r8
80008b16:	40 41       	lddsp	r1,sp[0x10]
80008b18:	0e 99       	mov	r9,r7
80008b1a:	ed b5 00 03 	bld	r5,0x3
80008b1e:	c4 11       	brne	80008ba0 <_vfprintf_r+0x7e8>
80008b20:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008b24:	40 3a       	lddsp	r10,sp[0xc]
80008b26:	58 0a       	cp.w	r10,0
80008b28:	c1 90       	breq	80008b5a <_vfprintf_r+0x7a2>
80008b2a:	10 36       	cp.w	r6,r8
80008b2c:	c6 45       	brlt	80008bf4 <_vfprintf_r+0x83c>
80008b2e:	fa c8 f9 50 	sub	r8,sp,-1712
80008b32:	1a d8       	st.w	--sp,r8
80008b34:	fa c8 fa b8 	sub	r8,sp,-1352
80008b38:	1a d8       	st.w	--sp,r8
80008b3a:	fa c8 fb b4 	sub	r8,sp,-1100
80008b3e:	0c 9b       	mov	r11,r6
80008b40:	1a d8       	st.w	--sp,r8
80008b42:	04 9a       	mov	r10,r2
80008b44:	fa c8 f9 40 	sub	r8,sp,-1728
80008b48:	fa c9 ff b4 	sub	r9,sp,-76
80008b4c:	08 9c       	mov	r12,r4
80008b4e:	fe b0 fa 9d 	rcall	80008088 <get_arg>
80008b52:	2f dd       	sub	sp,-12
80008b54:	78 16       	ld.w	r6,r12[0x4]
80008b56:	50 76       	stdsp	sp[0x1c],r6
80008b58:	c4 88       	rjmp	80008be8 <_vfprintf_r+0x830>
80008b5a:	2f f7       	sub	r7,-1
80008b5c:	10 39       	cp.w	r9,r8
80008b5e:	c0 c4       	brge	80008b76 <_vfprintf_r+0x7be>
80008b60:	fa ce f9 44 	sub	lr,sp,-1724
80008b64:	fc 06 00 36 	add	r6,lr,r6<<0x3
80008b68:	ec fc fd 8c 	ld.w	r12,r6[-628]
80008b6c:	50 7c       	stdsp	sp[0x1c],r12
80008b6e:	ec f6 fd 88 	ld.w	r6,r6[-632]
80008b72:	50 56       	stdsp	sp[0x14],r6
80008b74:	c6 68       	rjmp	80008c40 <_vfprintf_r+0x888>
80008b76:	41 09       	lddsp	r9,sp[0x40]
80008b78:	59 f8       	cp.w	r8,31
80008b7a:	e0 89 00 10 	brgt	80008b9a <_vfprintf_r+0x7e2>
80008b7e:	f2 ca ff f8 	sub	r10,r9,-8
80008b82:	72 1b       	ld.w	r11,r9[0x4]
80008b84:	51 0a       	stdsp	sp[0x40],r10
80008b86:	72 09       	ld.w	r9,r9[0x0]
80008b88:	fa ca f9 44 	sub	r10,sp,-1724
80008b8c:	50 7b       	stdsp	sp[0x1c],r11
80008b8e:	50 59       	stdsp	sp[0x14],r9
80008b90:	f4 08 00 39 	add	r9,r10,r8<<0x3
80008b94:	40 5b       	lddsp	r11,sp[0x14]
80008b96:	40 7a       	lddsp	r10,sp[0x1c]
80008b98:	c4 78       	rjmp	80008c26 <_vfprintf_r+0x86e>
80008b9a:	72 18       	ld.w	r8,r9[0x4]
80008b9c:	50 78       	stdsp	sp[0x1c],r8
80008b9e:	c4 c8       	rjmp	80008c36 <_vfprintf_r+0x87e>
80008ba0:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008ba4:	40 3e       	lddsp	lr,sp[0xc]
80008ba6:	58 0e       	cp.w	lr,0
80008ba8:	c2 30       	breq	80008bee <_vfprintf_r+0x836>
80008baa:	10 36       	cp.w	r6,r8
80008bac:	c0 94       	brge	80008bbe <_vfprintf_r+0x806>
80008bae:	fa cc f9 44 	sub	r12,sp,-1724
80008bb2:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008bb6:	ec fb fd 8c 	ld.w	r11,r6[-628]
80008bba:	50 7b       	stdsp	sp[0x1c],r11
80008bbc:	cd 9b       	rjmp	80008b6e <_vfprintf_r+0x7b6>
80008bbe:	fa c8 f9 50 	sub	r8,sp,-1712
80008bc2:	1a d8       	st.w	--sp,r8
80008bc4:	fa c8 fa b8 	sub	r8,sp,-1352
80008bc8:	04 9a       	mov	r10,r2
80008bca:	1a d8       	st.w	--sp,r8
80008bcc:	fa c8 fb b4 	sub	r8,sp,-1100
80008bd0:	0c 9b       	mov	r11,r6
80008bd2:	1a d8       	st.w	--sp,r8
80008bd4:	08 9c       	mov	r12,r4
80008bd6:	fa c8 f9 40 	sub	r8,sp,-1728
80008bda:	fa c9 ff b4 	sub	r9,sp,-76
80008bde:	fe b0 fa 55 	rcall	80008088 <get_arg>
80008be2:	2f dd       	sub	sp,-12
80008be4:	78 1a       	ld.w	r10,r12[0x4]
80008be6:	50 7a       	stdsp	sp[0x1c],r10
80008be8:	78 0c       	ld.w	r12,r12[0x0]
80008bea:	50 5c       	stdsp	sp[0x14],r12
80008bec:	c2 a8       	rjmp	80008c40 <_vfprintf_r+0x888>
80008bee:	2f f7       	sub	r7,-1
80008bf0:	10 39       	cp.w	r9,r8
80008bf2:	c0 94       	brge	80008c04 <_vfprintf_r+0x84c>
80008bf4:	fa c9 f9 44 	sub	r9,sp,-1724
80008bf8:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008bfc:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80008c00:	50 78       	stdsp	sp[0x1c],r8
80008c02:	cb 6b       	rjmp	80008b6e <_vfprintf_r+0x7b6>
80008c04:	41 09       	lddsp	r9,sp[0x40]
80008c06:	59 f8       	cp.w	r8,31
80008c08:	e0 89 00 15 	brgt	80008c32 <_vfprintf_r+0x87a>
80008c0c:	f2 ca ff f8 	sub	r10,r9,-8
80008c10:	72 16       	ld.w	r6,r9[0x4]
80008c12:	72 09       	ld.w	r9,r9[0x0]
80008c14:	51 0a       	stdsp	sp[0x40],r10
80008c16:	50 59       	stdsp	sp[0x14],r9
80008c18:	fa ce f9 44 	sub	lr,sp,-1724
80008c1c:	50 76       	stdsp	sp[0x1c],r6
80008c1e:	fc 08 00 39 	add	r9,lr,r8<<0x3
80008c22:	40 5b       	lddsp	r11,sp[0x14]
80008c24:	0c 9a       	mov	r10,r6
80008c26:	f2 eb fd 88 	st.d	r9[-632],r10
80008c2a:	2f f8       	sub	r8,-1
80008c2c:	fb 48 06 b4 	st.w	sp[1716],r8
80008c30:	c0 88       	rjmp	80008c40 <_vfprintf_r+0x888>
80008c32:	72 1c       	ld.w	r12,r9[0x4]
80008c34:	50 7c       	stdsp	sp[0x1c],r12
80008c36:	f2 c8 ff f8 	sub	r8,r9,-8
80008c3a:	51 08       	stdsp	sp[0x40],r8
80008c3c:	72 09       	ld.w	r9,r9[0x0]
80008c3e:	50 59       	stdsp	sp[0x14],r9
80008c40:	40 5b       	lddsp	r11,sp[0x14]
80008c42:	40 7a       	lddsp	r10,sp[0x1c]
80008c44:	e0 a0 19 54 	rcall	8000beec <__isinfd>
80008c48:	18 96       	mov	r6,r12
80008c4a:	c1 70       	breq	80008c78 <_vfprintf_r+0x8c0>
80008c4c:	30 08       	mov	r8,0
80008c4e:	30 09       	mov	r9,0
80008c50:	40 5b       	lddsp	r11,sp[0x14]
80008c52:	40 7a       	lddsp	r10,sp[0x1c]
80008c54:	e0 a0 1d b4 	rcall	8000c7bc <__avr32_f64_cmp_lt>
80008c58:	c0 40       	breq	80008c60 <_vfprintf_r+0x8a8>
80008c5a:	32 d8       	mov	r8,45
80008c5c:	fb 68 06 bb 	st.b	sp[1723],r8
80008c60:	fe c8 aa 1c 	sub	r8,pc,-21988
80008c64:	fe c6 aa 1c 	sub	r6,pc,-21988
80008c68:	a7 d5       	cbr	r5,0x7
80008c6a:	e0 40 00 47 	cp.w	r0,71
80008c6e:	f0 06 17 a0 	movle	r6,r8
80008c72:	30 32       	mov	r2,3
80008c74:	e0 8f 06 ce 	bral	80009a10 <_vfprintf_r+0x1658>
80008c78:	40 5b       	lddsp	r11,sp[0x14]
80008c7a:	40 7a       	lddsp	r10,sp[0x1c]
80008c7c:	e0 a0 19 4d 	rcall	8000bf16 <__isnand>
80008c80:	c0 e0       	breq	80008c9c <_vfprintf_r+0x8e4>
80008c82:	50 26       	stdsp	sp[0x8],r6
80008c84:	fe c8 aa 38 	sub	r8,pc,-21960
80008c88:	fe c6 aa 38 	sub	r6,pc,-21960
80008c8c:	a7 d5       	cbr	r5,0x7
80008c8e:	e0 40 00 47 	cp.w	r0,71
80008c92:	f0 06 17 a0 	movle	r6,r8
80008c96:	30 32       	mov	r2,3
80008c98:	e0 8f 06 c2 	bral	80009a1c <_vfprintf_r+0x1664>
80008c9c:	40 2a       	lddsp	r10,sp[0x8]
80008c9e:	5b fa       	cp.w	r10,-1
80008ca0:	c0 41       	brne	80008ca8 <_vfprintf_r+0x8f0>
80008ca2:	30 69       	mov	r9,6
80008ca4:	50 29       	stdsp	sp[0x8],r9
80008ca6:	c1 18       	rjmp	80008cc8 <_vfprintf_r+0x910>
80008ca8:	e0 40 00 47 	cp.w	r0,71
80008cac:	5f 09       	sreq	r9
80008cae:	e0 40 00 67 	cp.w	r0,103
80008cb2:	5f 08       	sreq	r8
80008cb4:	f3 e8 10 08 	or	r8,r9,r8
80008cb8:	f8 08 18 00 	cp.b	r8,r12
80008cbc:	c0 60       	breq	80008cc8 <_vfprintf_r+0x910>
80008cbe:	40 28       	lddsp	r8,sp[0x8]
80008cc0:	58 08       	cp.w	r8,0
80008cc2:	f9 b8 00 01 	moveq	r8,1
80008cc6:	50 28       	stdsp	sp[0x8],r8
80008cc8:	40 78       	lddsp	r8,sp[0x1c]
80008cca:	40 59       	lddsp	r9,sp[0x14]
80008ccc:	fa e9 06 94 	st.d	sp[1684],r8
80008cd0:	a9 a5       	sbr	r5,0x8
80008cd2:	fa f8 06 94 	ld.w	r8,sp[1684]
80008cd6:	58 08       	cp.w	r8,0
80008cd8:	c0 65       	brlt	80008ce4 <_vfprintf_r+0x92c>
80008cda:	40 5e       	lddsp	lr,sp[0x14]
80008cdc:	30 0c       	mov	r12,0
80008cde:	50 6e       	stdsp	sp[0x18],lr
80008ce0:	50 9c       	stdsp	sp[0x24],r12
80008ce2:	c0 78       	rjmp	80008cf0 <_vfprintf_r+0x938>
80008ce4:	40 5b       	lddsp	r11,sp[0x14]
80008ce6:	32 da       	mov	r10,45
80008ce8:	ee 1b 80 00 	eorh	r11,0x8000
80008cec:	50 9a       	stdsp	sp[0x24],r10
80008cee:	50 6b       	stdsp	sp[0x18],r11
80008cf0:	e0 40 00 46 	cp.w	r0,70
80008cf4:	5f 09       	sreq	r9
80008cf6:	e0 40 00 66 	cp.w	r0,102
80008cfa:	5f 08       	sreq	r8
80008cfc:	f3 e8 10 08 	or	r8,r9,r8
80008d00:	50 48       	stdsp	sp[0x10],r8
80008d02:	c0 40       	breq	80008d0a <_vfprintf_r+0x952>
80008d04:	40 22       	lddsp	r2,sp[0x8]
80008d06:	30 39       	mov	r9,3
80008d08:	c1 08       	rjmp	80008d28 <_vfprintf_r+0x970>
80008d0a:	e0 40 00 45 	cp.w	r0,69
80008d0e:	5f 09       	sreq	r9
80008d10:	e0 40 00 65 	cp.w	r0,101
80008d14:	5f 08       	sreq	r8
80008d16:	40 22       	lddsp	r2,sp[0x8]
80008d18:	10 49       	or	r9,r8
80008d1a:	2f f2       	sub	r2,-1
80008d1c:	40 46       	lddsp	r6,sp[0x10]
80008d1e:	ec 09 18 00 	cp.b	r9,r6
80008d22:	fb f2 00 02 	ld.weq	r2,sp[0x8]
80008d26:	30 29       	mov	r9,2
80008d28:	fa c8 f9 5c 	sub	r8,sp,-1700
80008d2c:	1a d8       	st.w	--sp,r8
80008d2e:	fa c8 f9 54 	sub	r8,sp,-1708
80008d32:	1a d8       	st.w	--sp,r8
80008d34:	fa c8 f9 4c 	sub	r8,sp,-1716
80008d38:	08 9c       	mov	r12,r4
80008d3a:	1a d8       	st.w	--sp,r8
80008d3c:	04 98       	mov	r8,r2
80008d3e:	40 9b       	lddsp	r11,sp[0x24]
80008d40:	40 aa       	lddsp	r10,sp[0x28]
80008d42:	e0 a0 0b c3 	rcall	8000a4c8 <_dtoa_r>
80008d46:	e0 40 00 47 	cp.w	r0,71
80008d4a:	5f 19       	srne	r9
80008d4c:	e0 40 00 67 	cp.w	r0,103
80008d50:	5f 18       	srne	r8
80008d52:	18 96       	mov	r6,r12
80008d54:	2f dd       	sub	sp,-12
80008d56:	f3 e8 00 08 	and	r8,r9,r8
80008d5a:	c0 41       	brne	80008d62 <_vfprintf_r+0x9aa>
80008d5c:	ed b5 00 00 	bld	r5,0x0
80008d60:	c3 01       	brne	80008dc0 <_vfprintf_r+0xa08>
80008d62:	ec 02 00 0e 	add	lr,r6,r2
80008d66:	50 3e       	stdsp	sp[0xc],lr
80008d68:	40 4c       	lddsp	r12,sp[0x10]
80008d6a:	58 0c       	cp.w	r12,0
80008d6c:	c1 50       	breq	80008d96 <_vfprintf_r+0x9de>
80008d6e:	0d 89       	ld.ub	r9,r6[0x0]
80008d70:	33 08       	mov	r8,48
80008d72:	f0 09 18 00 	cp.b	r9,r8
80008d76:	c0 b1       	brne	80008d8c <_vfprintf_r+0x9d4>
80008d78:	30 08       	mov	r8,0
80008d7a:	30 09       	mov	r9,0
80008d7c:	40 6b       	lddsp	r11,sp[0x18]
80008d7e:	40 7a       	lddsp	r10,sp[0x1c]
80008d80:	e0 a0 1c d7 	rcall	8000c72e <__avr32_f64_cmp_eq>
80008d84:	fb b2 00 01 	rsubeq	r2,1
80008d88:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
80008d8c:	40 3b       	lddsp	r11,sp[0xc]
80008d8e:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008d92:	10 0b       	add	r11,r8
80008d94:	50 3b       	stdsp	sp[0xc],r11
80008d96:	40 6b       	lddsp	r11,sp[0x18]
80008d98:	30 08       	mov	r8,0
80008d9a:	30 09       	mov	r9,0
80008d9c:	40 7a       	lddsp	r10,sp[0x1c]
80008d9e:	e0 a0 1c c8 	rcall	8000c72e <__avr32_f64_cmp_eq>
80008da2:	c0 90       	breq	80008db4 <_vfprintf_r+0x9fc>
80008da4:	40 3a       	lddsp	r10,sp[0xc]
80008da6:	fb 4a 06 a4 	st.w	sp[1700],r10
80008daa:	c0 58       	rjmp	80008db4 <_vfprintf_r+0x9fc>
80008dac:	10 c9       	st.b	r8++,r9
80008dae:	fb 48 06 a4 	st.w	sp[1700],r8
80008db2:	c0 28       	rjmp	80008db6 <_vfprintf_r+0x9fe>
80008db4:	33 09       	mov	r9,48
80008db6:	fa f8 06 a4 	ld.w	r8,sp[1700]
80008dba:	40 3e       	lddsp	lr,sp[0xc]
80008dbc:	1c 38       	cp.w	r8,lr
80008dbe:	cf 73       	brcs	80008dac <_vfprintf_r+0x9f4>
80008dc0:	e0 40 00 47 	cp.w	r0,71
80008dc4:	5f 09       	sreq	r9
80008dc6:	e0 40 00 67 	cp.w	r0,103
80008dca:	5f 08       	sreq	r8
80008dcc:	f3 e8 10 08 	or	r8,r9,r8
80008dd0:	fa f9 06 a4 	ld.w	r9,sp[1700]
80008dd4:	0c 19       	sub	r9,r6
80008dd6:	50 69       	stdsp	sp[0x18],r9
80008dd8:	58 08       	cp.w	r8,0
80008dda:	c0 b0       	breq	80008df0 <_vfprintf_r+0xa38>
80008ddc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008de0:	5b d8       	cp.w	r8,-3
80008de2:	c0 55       	brlt	80008dec <_vfprintf_r+0xa34>
80008de4:	40 2c       	lddsp	r12,sp[0x8]
80008de6:	18 38       	cp.w	r8,r12
80008de8:	e0 8a 00 6a 	brle	80008ebc <_vfprintf_r+0xb04>
80008dec:	20 20       	sub	r0,2
80008dee:	c0 58       	rjmp	80008df8 <_vfprintf_r+0xa40>
80008df0:	e0 40 00 65 	cp.w	r0,101
80008df4:	e0 89 00 46 	brgt	80008e80 <_vfprintf_r+0xac8>
80008df8:	fa fb 06 ac 	ld.w	r11,sp[1708]
80008dfc:	fb 60 06 9c 	st.b	sp[1692],r0
80008e00:	20 1b       	sub	r11,1
80008e02:	fb 4b 06 ac 	st.w	sp[1708],r11
80008e06:	c0 47       	brpl	80008e0e <_vfprintf_r+0xa56>
80008e08:	5c 3b       	neg	r11
80008e0a:	32 d8       	mov	r8,45
80008e0c:	c0 28       	rjmp	80008e10 <_vfprintf_r+0xa58>
80008e0e:	32 b8       	mov	r8,43
80008e10:	fb 68 06 9d 	st.b	sp[1693],r8
80008e14:	58 9b       	cp.w	r11,9
80008e16:	e0 8a 00 1d 	brle	80008e50 <_vfprintf_r+0xa98>
80008e1a:	fa c9 fa 35 	sub	r9,sp,-1483
80008e1e:	30 aa       	mov	r10,10
80008e20:	12 98       	mov	r8,r9
80008e22:	0e 9c       	mov	r12,r7
80008e24:	0c 92       	mov	r2,r6
80008e26:	f6 0a 0c 06 	divs	r6,r11,r10
80008e2a:	0e 9b       	mov	r11,r7
80008e2c:	2d 0b       	sub	r11,-48
80008e2e:	10 fb       	st.b	--r8,r11
80008e30:	0c 9b       	mov	r11,r6
80008e32:	58 96       	cp.w	r6,9
80008e34:	fe 99 ff f9 	brgt	80008e26 <_vfprintf_r+0xa6e>
80008e38:	2d 0b       	sub	r11,-48
80008e3a:	18 97       	mov	r7,r12
80008e3c:	04 96       	mov	r6,r2
80008e3e:	10 fb       	st.b	--r8,r11
80008e40:	fa ca f9 62 	sub	r10,sp,-1694
80008e44:	c0 38       	rjmp	80008e4a <_vfprintf_r+0xa92>
80008e46:	11 3b       	ld.ub	r11,r8++
80008e48:	14 cb       	st.b	r10++,r11
80008e4a:	12 38       	cp.w	r8,r9
80008e4c:	cf d3       	brcs	80008e46 <_vfprintf_r+0xa8e>
80008e4e:	c0 98       	rjmp	80008e60 <_vfprintf_r+0xaa8>
80008e50:	2d 0b       	sub	r11,-48
80008e52:	33 08       	mov	r8,48
80008e54:	fb 6b 06 9f 	st.b	sp[1695],r11
80008e58:	fb 68 06 9e 	st.b	sp[1694],r8
80008e5c:	fa ca f9 60 	sub	r10,sp,-1696
80008e60:	fa c8 f9 64 	sub	r8,sp,-1692
80008e64:	f4 08 01 08 	sub	r8,r10,r8
80008e68:	50 e8       	stdsp	sp[0x38],r8
80008e6a:	10 92       	mov	r2,r8
80008e6c:	40 6b       	lddsp	r11,sp[0x18]
80008e6e:	16 02       	add	r2,r11
80008e70:	58 1b       	cp.w	r11,1
80008e72:	e0 89 00 05 	brgt	80008e7c <_vfprintf_r+0xac4>
80008e76:	ed b5 00 00 	bld	r5,0x0
80008e7a:	c3 51       	brne	80008ee4 <_vfprintf_r+0xb2c>
80008e7c:	2f f2       	sub	r2,-1
80008e7e:	c3 38       	rjmp	80008ee4 <_vfprintf_r+0xb2c>
80008e80:	e0 40 00 66 	cp.w	r0,102
80008e84:	c1 c1       	brne	80008ebc <_vfprintf_r+0xb04>
80008e86:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008e8a:	58 02       	cp.w	r2,0
80008e8c:	e0 8a 00 0c 	brle	80008ea4 <_vfprintf_r+0xaec>
80008e90:	40 2a       	lddsp	r10,sp[0x8]
80008e92:	58 0a       	cp.w	r10,0
80008e94:	c0 41       	brne	80008e9c <_vfprintf_r+0xae4>
80008e96:	ed b5 00 00 	bld	r5,0x0
80008e9a:	c2 51       	brne	80008ee4 <_vfprintf_r+0xb2c>
80008e9c:	2f f2       	sub	r2,-1
80008e9e:	40 29       	lddsp	r9,sp[0x8]
80008ea0:	12 02       	add	r2,r9
80008ea2:	c0 b8       	rjmp	80008eb8 <_vfprintf_r+0xb00>
80008ea4:	40 28       	lddsp	r8,sp[0x8]
80008ea6:	58 08       	cp.w	r8,0
80008ea8:	c0 61       	brne	80008eb4 <_vfprintf_r+0xafc>
80008eaa:	ed b5 00 00 	bld	r5,0x0
80008eae:	c0 30       	breq	80008eb4 <_vfprintf_r+0xafc>
80008eb0:	30 12       	mov	r2,1
80008eb2:	c1 98       	rjmp	80008ee4 <_vfprintf_r+0xb2c>
80008eb4:	40 22       	lddsp	r2,sp[0x8]
80008eb6:	2f e2       	sub	r2,-2
80008eb8:	36 60       	mov	r0,102
80008eba:	c1 58       	rjmp	80008ee4 <_vfprintf_r+0xb2c>
80008ebc:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008ec0:	40 6e       	lddsp	lr,sp[0x18]
80008ec2:	1c 32       	cp.w	r2,lr
80008ec4:	c0 65       	brlt	80008ed0 <_vfprintf_r+0xb18>
80008ec6:	ed b5 00 00 	bld	r5,0x0
80008eca:	f7 b2 00 ff 	subeq	r2,-1
80008ece:	c0 a8       	rjmp	80008ee2 <_vfprintf_r+0xb2a>
80008ed0:	e4 08 11 02 	rsub	r8,r2,2
80008ed4:	40 6c       	lddsp	r12,sp[0x18]
80008ed6:	58 02       	cp.w	r2,0
80008ed8:	f0 02 17 a0 	movle	r2,r8
80008edc:	f9 b2 09 01 	movgt	r2,1
80008ee0:	18 02       	add	r2,r12
80008ee2:	36 70       	mov	r0,103
80008ee4:	40 9b       	lddsp	r11,sp[0x24]
80008ee6:	58 0b       	cp.w	r11,0
80008ee8:	e0 80 05 94 	breq	80009a10 <_vfprintf_r+0x1658>
80008eec:	32 d8       	mov	r8,45
80008eee:	fb 68 06 bb 	st.b	sp[1723],r8
80008ef2:	e0 8f 05 93 	bral	80009a18 <_vfprintf_r+0x1660>
80008ef6:	50 a7       	stdsp	sp[0x28],r7
80008ef8:	04 94       	mov	r4,r2
80008efa:	0c 97       	mov	r7,r6
80008efc:	02 92       	mov	r2,r1
80008efe:	06 96       	mov	r6,r3
80008f00:	40 41       	lddsp	r1,sp[0x10]
80008f02:	40 93       	lddsp	r3,sp[0x24]
80008f04:	0e 99       	mov	r9,r7
80008f06:	ed b5 00 05 	bld	r5,0x5
80008f0a:	c4 81       	brne	80008f9a <_vfprintf_r+0xbe2>
80008f0c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008f10:	40 3e       	lddsp	lr,sp[0xc]
80008f12:	58 0e       	cp.w	lr,0
80008f14:	c1 d0       	breq	80008f4e <_vfprintf_r+0xb96>
80008f16:	10 36       	cp.w	r6,r8
80008f18:	c0 64       	brge	80008f24 <_vfprintf_r+0xb6c>
80008f1a:	fa cc f9 44 	sub	r12,sp,-1724
80008f1e:	f8 06 00 36 	add	r6,r12,r6<<0x3
80008f22:	c1 d8       	rjmp	80008f5c <_vfprintf_r+0xba4>
80008f24:	fa c8 f9 50 	sub	r8,sp,-1712
80008f28:	1a d8       	st.w	--sp,r8
80008f2a:	fa c8 fa b8 	sub	r8,sp,-1352
80008f2e:	04 9a       	mov	r10,r2
80008f30:	1a d8       	st.w	--sp,r8
80008f32:	fa c8 fb b4 	sub	r8,sp,-1100
80008f36:	0c 9b       	mov	r11,r6
80008f38:	1a d8       	st.w	--sp,r8
80008f3a:	08 9c       	mov	r12,r4
80008f3c:	fa c8 f9 40 	sub	r8,sp,-1728
80008f40:	fa c9 ff b4 	sub	r9,sp,-76
80008f44:	fe b0 f8 a2 	rcall	80008088 <get_arg>
80008f48:	2f dd       	sub	sp,-12
80008f4a:	78 0a       	ld.w	r10,r12[0x0]
80008f4c:	c2 08       	rjmp	80008f8c <_vfprintf_r+0xbd4>
80008f4e:	2f f7       	sub	r7,-1
80008f50:	10 39       	cp.w	r9,r8
80008f52:	c0 84       	brge	80008f62 <_vfprintf_r+0xbaa>
80008f54:	fa cb f9 44 	sub	r11,sp,-1724
80008f58:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008f5c:	ec fa fd 88 	ld.w	r10,r6[-632]
80008f60:	c1 68       	rjmp	80008f8c <_vfprintf_r+0xbd4>
80008f62:	41 09       	lddsp	r9,sp[0x40]
80008f64:	59 f8       	cp.w	r8,31
80008f66:	e0 89 00 10 	brgt	80008f86 <_vfprintf_r+0xbce>
80008f6a:	f2 ca ff fc 	sub	r10,r9,-4
80008f6e:	51 0a       	stdsp	sp[0x40],r10
80008f70:	fa c6 f9 44 	sub	r6,sp,-1724
80008f74:	72 0a       	ld.w	r10,r9[0x0]
80008f76:	ec 08 00 39 	add	r9,r6,r8<<0x3
80008f7a:	f3 4a fd 88 	st.w	r9[-632],r10
80008f7e:	2f f8       	sub	r8,-1
80008f80:	fb 48 06 b4 	st.w	sp[1716],r8
80008f84:	c0 48       	rjmp	80008f8c <_vfprintf_r+0xbd4>
80008f86:	72 0a       	ld.w	r10,r9[0x0]
80008f88:	2f c9       	sub	r9,-4
80008f8a:	51 09       	stdsp	sp[0x40],r9
80008f8c:	40 be       	lddsp	lr,sp[0x2c]
80008f8e:	1c 98       	mov	r8,lr
80008f90:	95 1e       	st.w	r10[0x4],lr
80008f92:	bf 58       	asr	r8,0x1f
80008f94:	95 08       	st.w	r10[0x0],r8
80008f96:	fe 9f fa 9f 	bral	800084d4 <_vfprintf_r+0x11c>
80008f9a:	ed b5 00 04 	bld	r5,0x4
80008f9e:	c4 80       	breq	8000902e <_vfprintf_r+0xc76>
80008fa0:	e2 15 00 40 	andl	r5,0x40,COH
80008fa4:	c4 50       	breq	8000902e <_vfprintf_r+0xc76>
80008fa6:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008faa:	40 3c       	lddsp	r12,sp[0xc]
80008fac:	58 0c       	cp.w	r12,0
80008fae:	c1 d0       	breq	80008fe8 <_vfprintf_r+0xc30>
80008fb0:	10 36       	cp.w	r6,r8
80008fb2:	c0 64       	brge	80008fbe <_vfprintf_r+0xc06>
80008fb4:	fa cb f9 44 	sub	r11,sp,-1724
80008fb8:	f6 06 00 36 	add	r6,r11,r6<<0x3
80008fbc:	c1 d8       	rjmp	80008ff6 <_vfprintf_r+0xc3e>
80008fbe:	fa c8 f9 50 	sub	r8,sp,-1712
80008fc2:	1a d8       	st.w	--sp,r8
80008fc4:	fa c8 fa b8 	sub	r8,sp,-1352
80008fc8:	04 9a       	mov	r10,r2
80008fca:	1a d8       	st.w	--sp,r8
80008fcc:	fa c8 fb b4 	sub	r8,sp,-1100
80008fd0:	0c 9b       	mov	r11,r6
80008fd2:	1a d8       	st.w	--sp,r8
80008fd4:	08 9c       	mov	r12,r4
80008fd6:	fa c8 f9 40 	sub	r8,sp,-1728
80008fda:	fa c9 ff b4 	sub	r9,sp,-76
80008fde:	fe b0 f8 55 	rcall	80008088 <get_arg>
80008fe2:	2f dd       	sub	sp,-12
80008fe4:	78 0a       	ld.w	r10,r12[0x0]
80008fe6:	c2 08       	rjmp	80009026 <_vfprintf_r+0xc6e>
80008fe8:	2f f7       	sub	r7,-1
80008fea:	10 39       	cp.w	r9,r8
80008fec:	c0 84       	brge	80008ffc <_vfprintf_r+0xc44>
80008fee:	fa ca f9 44 	sub	r10,sp,-1724
80008ff2:	f4 06 00 36 	add	r6,r10,r6<<0x3
80008ff6:	ec fa fd 88 	ld.w	r10,r6[-632]
80008ffa:	c1 68       	rjmp	80009026 <_vfprintf_r+0xc6e>
80008ffc:	41 09       	lddsp	r9,sp[0x40]
80008ffe:	59 f8       	cp.w	r8,31
80009000:	e0 89 00 10 	brgt	80009020 <_vfprintf_r+0xc68>
80009004:	f2 ca ff fc 	sub	r10,r9,-4
80009008:	51 0a       	stdsp	sp[0x40],r10
8000900a:	fa c6 f9 44 	sub	r6,sp,-1724
8000900e:	72 0a       	ld.w	r10,r9[0x0]
80009010:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009014:	f3 4a fd 88 	st.w	r9[-632],r10
80009018:	2f f8       	sub	r8,-1
8000901a:	fb 48 06 b4 	st.w	sp[1716],r8
8000901e:	c0 48       	rjmp	80009026 <_vfprintf_r+0xc6e>
80009020:	72 0a       	ld.w	r10,r9[0x0]
80009022:	2f c9       	sub	r9,-4
80009024:	51 09       	stdsp	sp[0x40],r9
80009026:	40 be       	lddsp	lr,sp[0x2c]
80009028:	b4 0e       	st.h	r10[0x0],lr
8000902a:	fe 9f fa 55 	bral	800084d4 <_vfprintf_r+0x11c>
8000902e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009032:	40 3c       	lddsp	r12,sp[0xc]
80009034:	58 0c       	cp.w	r12,0
80009036:	c1 d0       	breq	80009070 <_vfprintf_r+0xcb8>
80009038:	10 36       	cp.w	r6,r8
8000903a:	c0 64       	brge	80009046 <_vfprintf_r+0xc8e>
8000903c:	fa cb f9 44 	sub	r11,sp,-1724
80009040:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009044:	c1 d8       	rjmp	8000907e <_vfprintf_r+0xcc6>
80009046:	fa c8 f9 50 	sub	r8,sp,-1712
8000904a:	1a d8       	st.w	--sp,r8
8000904c:	fa c8 fa b8 	sub	r8,sp,-1352
80009050:	04 9a       	mov	r10,r2
80009052:	1a d8       	st.w	--sp,r8
80009054:	fa c8 fb b4 	sub	r8,sp,-1100
80009058:	0c 9b       	mov	r11,r6
8000905a:	1a d8       	st.w	--sp,r8
8000905c:	08 9c       	mov	r12,r4
8000905e:	fa c8 f9 40 	sub	r8,sp,-1728
80009062:	fa c9 ff b4 	sub	r9,sp,-76
80009066:	fe b0 f8 11 	rcall	80008088 <get_arg>
8000906a:	2f dd       	sub	sp,-12
8000906c:	78 0a       	ld.w	r10,r12[0x0]
8000906e:	c2 08       	rjmp	800090ae <_vfprintf_r+0xcf6>
80009070:	2f f7       	sub	r7,-1
80009072:	10 39       	cp.w	r9,r8
80009074:	c0 84       	brge	80009084 <_vfprintf_r+0xccc>
80009076:	fa ca f9 44 	sub	r10,sp,-1724
8000907a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000907e:	ec fa fd 88 	ld.w	r10,r6[-632]
80009082:	c1 68       	rjmp	800090ae <_vfprintf_r+0xcf6>
80009084:	41 09       	lddsp	r9,sp[0x40]
80009086:	59 f8       	cp.w	r8,31
80009088:	e0 89 00 10 	brgt	800090a8 <_vfprintf_r+0xcf0>
8000908c:	f2 ca ff fc 	sub	r10,r9,-4
80009090:	51 0a       	stdsp	sp[0x40],r10
80009092:	fa c6 f9 44 	sub	r6,sp,-1724
80009096:	72 0a       	ld.w	r10,r9[0x0]
80009098:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000909c:	f3 4a fd 88 	st.w	r9[-632],r10
800090a0:	2f f8       	sub	r8,-1
800090a2:	fb 48 06 b4 	st.w	sp[1716],r8
800090a6:	c0 48       	rjmp	800090ae <_vfprintf_r+0xcf6>
800090a8:	72 0a       	ld.w	r10,r9[0x0]
800090aa:	2f c9       	sub	r9,-4
800090ac:	51 09       	stdsp	sp[0x40],r9
800090ae:	40 be       	lddsp	lr,sp[0x2c]
800090b0:	95 0e       	st.w	r10[0x0],lr
800090b2:	fe 9f fa 11 	bral	800084d4 <_vfprintf_r+0x11c>
800090b6:	50 a7       	stdsp	sp[0x28],r7
800090b8:	50 80       	stdsp	sp[0x20],r0
800090ba:	0c 97       	mov	r7,r6
800090bc:	04 94       	mov	r4,r2
800090be:	06 96       	mov	r6,r3
800090c0:	02 92       	mov	r2,r1
800090c2:	40 93       	lddsp	r3,sp[0x24]
800090c4:	10 90       	mov	r0,r8
800090c6:	40 41       	lddsp	r1,sp[0x10]
800090c8:	a5 a5       	sbr	r5,0x4
800090ca:	c0 a8       	rjmp	800090de <_vfprintf_r+0xd26>
800090cc:	50 a7       	stdsp	sp[0x28],r7
800090ce:	50 80       	stdsp	sp[0x20],r0
800090d0:	0c 97       	mov	r7,r6
800090d2:	04 94       	mov	r4,r2
800090d4:	06 96       	mov	r6,r3
800090d6:	02 92       	mov	r2,r1
800090d8:	40 93       	lddsp	r3,sp[0x24]
800090da:	10 90       	mov	r0,r8
800090dc:	40 41       	lddsp	r1,sp[0x10]
800090de:	ed b5 00 05 	bld	r5,0x5
800090e2:	c5 d1       	brne	8000919c <_vfprintf_r+0xde4>
800090e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
800090e8:	40 3c       	lddsp	r12,sp[0xc]
800090ea:	58 0c       	cp.w	r12,0
800090ec:	c2 60       	breq	80009138 <_vfprintf_r+0xd80>
800090ee:	10 36       	cp.w	r6,r8
800090f0:	c0 a4       	brge	80009104 <_vfprintf_r+0xd4c>
800090f2:	fa cb f9 44 	sub	r11,sp,-1724
800090f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800090fa:	ec e8 fd 88 	ld.d	r8,r6[-632]
800090fe:	fa e9 00 00 	st.d	sp[0],r8
80009102:	c1 88       	rjmp	80009132 <_vfprintf_r+0xd7a>
80009104:	fa c8 f9 50 	sub	r8,sp,-1712
80009108:	1a d8       	st.w	--sp,r8
8000910a:	fa c8 fa b8 	sub	r8,sp,-1352
8000910e:	04 9a       	mov	r10,r2
80009110:	1a d8       	st.w	--sp,r8
80009112:	0c 9b       	mov	r11,r6
80009114:	fa c8 fb b4 	sub	r8,sp,-1100
80009118:	08 9c       	mov	r12,r4
8000911a:	1a d8       	st.w	--sp,r8
8000911c:	fa c8 f9 40 	sub	r8,sp,-1728
80009120:	fa c9 ff b4 	sub	r9,sp,-76
80009124:	fe b0 f7 b2 	rcall	80008088 <get_arg>
80009128:	2f dd       	sub	sp,-12
8000912a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000912e:	fa eb 00 00 	st.d	sp[0],r10
80009132:	30 08       	mov	r8,0
80009134:	e0 8f 03 de 	bral	800098f0 <_vfprintf_r+0x1538>
80009138:	ee ca ff ff 	sub	r10,r7,-1
8000913c:	10 37       	cp.w	r7,r8
8000913e:	c0 b4       	brge	80009154 <_vfprintf_r+0xd9c>
80009140:	fa c9 f9 44 	sub	r9,sp,-1724
80009144:	14 97       	mov	r7,r10
80009146:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000914a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000914e:	fa eb 00 00 	st.d	sp[0],r10
80009152:	c1 88       	rjmp	80009182 <_vfprintf_r+0xdca>
80009154:	41 09       	lddsp	r9,sp[0x40]
80009156:	59 f8       	cp.w	r8,31
80009158:	e0 89 00 18 	brgt	80009188 <_vfprintf_r+0xdd0>
8000915c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009160:	f2 cb ff f8 	sub	r11,r9,-8
80009164:	fa e7 00 00 	st.d	sp[0],r6
80009168:	51 0b       	stdsp	sp[0x40],r11
8000916a:	fa c6 f9 44 	sub	r6,sp,-1724
8000916e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009172:	fa e6 00 00 	ld.d	r6,sp[0]
80009176:	f2 e7 fd 88 	st.d	r9[-632],r6
8000917a:	2f f8       	sub	r8,-1
8000917c:	14 97       	mov	r7,r10
8000917e:	fb 48 06 b4 	st.w	sp[1716],r8
80009182:	40 38       	lddsp	r8,sp[0xc]
80009184:	e0 8f 03 b6 	bral	800098f0 <_vfprintf_r+0x1538>
80009188:	f2 e6 00 00 	ld.d	r6,r9[0]
8000918c:	40 38       	lddsp	r8,sp[0xc]
8000918e:	fa e7 00 00 	st.d	sp[0],r6
80009192:	2f 89       	sub	r9,-8
80009194:	14 97       	mov	r7,r10
80009196:	51 09       	stdsp	sp[0x40],r9
80009198:	e0 8f 03 ac 	bral	800098f0 <_vfprintf_r+0x1538>
8000919c:	ed b5 00 04 	bld	r5,0x4
800091a0:	c1 61       	brne	800091cc <_vfprintf_r+0xe14>
800091a2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091a6:	40 3e       	lddsp	lr,sp[0xc]
800091a8:	58 0e       	cp.w	lr,0
800091aa:	c0 80       	breq	800091ba <_vfprintf_r+0xe02>
800091ac:	10 36       	cp.w	r6,r8
800091ae:	c6 74       	brge	8000927c <_vfprintf_r+0xec4>
800091b0:	fa cc f9 44 	sub	r12,sp,-1724
800091b4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800091b8:	c8 08       	rjmp	800092b8 <_vfprintf_r+0xf00>
800091ba:	ee ca ff ff 	sub	r10,r7,-1
800091be:	10 37       	cp.w	r7,r8
800091c0:	c7 f4       	brge	800092be <_vfprintf_r+0xf06>
800091c2:	fa cb f9 44 	sub	r11,sp,-1724
800091c6:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091ca:	c7 68       	rjmp	800092b6 <_vfprintf_r+0xefe>
800091cc:	ed b5 00 06 	bld	r5,0x6
800091d0:	c4 a1       	brne	80009264 <_vfprintf_r+0xeac>
800091d2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800091d6:	40 3c       	lddsp	r12,sp[0xc]
800091d8:	58 0c       	cp.w	r12,0
800091da:	c1 d0       	breq	80009214 <_vfprintf_r+0xe5c>
800091dc:	10 36       	cp.w	r6,r8
800091de:	c0 64       	brge	800091ea <_vfprintf_r+0xe32>
800091e0:	fa cb f9 44 	sub	r11,sp,-1724
800091e4:	f6 06 00 36 	add	r6,r11,r6<<0x3
800091e8:	c1 f8       	rjmp	80009226 <_vfprintf_r+0xe6e>
800091ea:	fa c8 f9 50 	sub	r8,sp,-1712
800091ee:	1a d8       	st.w	--sp,r8
800091f0:	fa c8 fa b8 	sub	r8,sp,-1352
800091f4:	1a d8       	st.w	--sp,r8
800091f6:	fa c8 fb b4 	sub	r8,sp,-1100
800091fa:	1a d8       	st.w	--sp,r8
800091fc:	fa c8 f9 40 	sub	r8,sp,-1728
80009200:	fa c9 ff b4 	sub	r9,sp,-76
80009204:	04 9a       	mov	r10,r2
80009206:	0c 9b       	mov	r11,r6
80009208:	08 9c       	mov	r12,r4
8000920a:	fe b0 f7 3f 	rcall	80008088 <get_arg>
8000920e:	2f dd       	sub	sp,-12
80009210:	98 18       	ld.sh	r8,r12[0x2]
80009212:	c2 68       	rjmp	8000925e <_vfprintf_r+0xea6>
80009214:	ee ca ff ff 	sub	r10,r7,-1
80009218:	10 37       	cp.w	r7,r8
8000921a:	c0 94       	brge	8000922c <_vfprintf_r+0xe74>
8000921c:	fa c9 f9 44 	sub	r9,sp,-1724
80009220:	14 97       	mov	r7,r10
80009222:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009226:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000922a:	c1 a8       	rjmp	8000925e <_vfprintf_r+0xea6>
8000922c:	41 09       	lddsp	r9,sp[0x40]
8000922e:	59 f8       	cp.w	r8,31
80009230:	e0 89 00 13 	brgt	80009256 <_vfprintf_r+0xe9e>
80009234:	f2 cb ff fc 	sub	r11,r9,-4
80009238:	51 0b       	stdsp	sp[0x40],r11
8000923a:	72 09       	ld.w	r9,r9[0x0]
8000923c:	fa c6 f9 44 	sub	r6,sp,-1724
80009240:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009244:	2f f8       	sub	r8,-1
80009246:	f7 49 fd 88 	st.w	r11[-632],r9
8000924a:	fb 48 06 b4 	st.w	sp[1716],r8
8000924e:	14 97       	mov	r7,r10
80009250:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009254:	c0 58       	rjmp	8000925e <_vfprintf_r+0xea6>
80009256:	92 18       	ld.sh	r8,r9[0x2]
80009258:	14 97       	mov	r7,r10
8000925a:	2f c9       	sub	r9,-4
8000925c:	51 09       	stdsp	sp[0x40],r9
8000925e:	5c 78       	castu.h	r8
80009260:	50 18       	stdsp	sp[0x4],r8
80009262:	c4 68       	rjmp	800092ee <_vfprintf_r+0xf36>
80009264:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009268:	40 3c       	lddsp	r12,sp[0xc]
8000926a:	58 0c       	cp.w	r12,0
8000926c:	c1 d0       	breq	800092a6 <_vfprintf_r+0xeee>
8000926e:	10 36       	cp.w	r6,r8
80009270:	c0 64       	brge	8000927c <_vfprintf_r+0xec4>
80009272:	fa cb f9 44 	sub	r11,sp,-1724
80009276:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000927a:	c1 f8       	rjmp	800092b8 <_vfprintf_r+0xf00>
8000927c:	fa c8 f9 50 	sub	r8,sp,-1712
80009280:	1a d8       	st.w	--sp,r8
80009282:	fa c8 fa b8 	sub	r8,sp,-1352
80009286:	0c 9b       	mov	r11,r6
80009288:	1a d8       	st.w	--sp,r8
8000928a:	fa c8 fb b4 	sub	r8,sp,-1100
8000928e:	04 9a       	mov	r10,r2
80009290:	1a d8       	st.w	--sp,r8
80009292:	08 9c       	mov	r12,r4
80009294:	fa c8 f9 40 	sub	r8,sp,-1728
80009298:	fa c9 ff b4 	sub	r9,sp,-76
8000929c:	fe b0 f6 f6 	rcall	80008088 <get_arg>
800092a0:	2f dd       	sub	sp,-12
800092a2:	78 0b       	ld.w	r11,r12[0x0]
800092a4:	c2 48       	rjmp	800092ec <_vfprintf_r+0xf34>
800092a6:	ee ca ff ff 	sub	r10,r7,-1
800092aa:	10 37       	cp.w	r7,r8
800092ac:	c0 94       	brge	800092be <_vfprintf_r+0xf06>
800092ae:	fa c9 f9 44 	sub	r9,sp,-1724
800092b2:	f2 06 00 36 	add	r6,r9,r6<<0x3
800092b6:	14 97       	mov	r7,r10
800092b8:	ec fb fd 88 	ld.w	r11,r6[-632]
800092bc:	c1 88       	rjmp	800092ec <_vfprintf_r+0xf34>
800092be:	41 09       	lddsp	r9,sp[0x40]
800092c0:	59 f8       	cp.w	r8,31
800092c2:	e0 89 00 11 	brgt	800092e4 <_vfprintf_r+0xf2c>
800092c6:	f2 cb ff fc 	sub	r11,r9,-4
800092ca:	51 0b       	stdsp	sp[0x40],r11
800092cc:	fa c6 f9 44 	sub	r6,sp,-1724
800092d0:	72 0b       	ld.w	r11,r9[0x0]
800092d2:	ec 08 00 39 	add	r9,r6,r8<<0x3
800092d6:	f3 4b fd 88 	st.w	r9[-632],r11
800092da:	2f f8       	sub	r8,-1
800092dc:	14 97       	mov	r7,r10
800092de:	fb 48 06 b4 	st.w	sp[1716],r8
800092e2:	c0 58       	rjmp	800092ec <_vfprintf_r+0xf34>
800092e4:	72 0b       	ld.w	r11,r9[0x0]
800092e6:	14 97       	mov	r7,r10
800092e8:	2f c9       	sub	r9,-4
800092ea:	51 09       	stdsp	sp[0x40],r9
800092ec:	50 1b       	stdsp	sp[0x4],r11
800092ee:	30 0e       	mov	lr,0
800092f0:	50 0e       	stdsp	sp[0x0],lr
800092f2:	1c 98       	mov	r8,lr
800092f4:	e0 8f 02 fe 	bral	800098f0 <_vfprintf_r+0x1538>
800092f8:	50 a7       	stdsp	sp[0x28],r7
800092fa:	50 80       	stdsp	sp[0x20],r0
800092fc:	0c 97       	mov	r7,r6
800092fe:	04 94       	mov	r4,r2
80009300:	06 96       	mov	r6,r3
80009302:	02 92       	mov	r2,r1
80009304:	40 93       	lddsp	r3,sp[0x24]
80009306:	40 41       	lddsp	r1,sp[0x10]
80009308:	0e 99       	mov	r9,r7
8000930a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000930e:	40 3c       	lddsp	r12,sp[0xc]
80009310:	58 0c       	cp.w	r12,0
80009312:	c1 d0       	breq	8000934c <_vfprintf_r+0xf94>
80009314:	10 36       	cp.w	r6,r8
80009316:	c0 64       	brge	80009322 <_vfprintf_r+0xf6a>
80009318:	fa cb f9 44 	sub	r11,sp,-1724
8000931c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009320:	c1 d8       	rjmp	8000935a <_vfprintf_r+0xfa2>
80009322:	fa c8 f9 50 	sub	r8,sp,-1712
80009326:	1a d8       	st.w	--sp,r8
80009328:	fa c8 fa b8 	sub	r8,sp,-1352
8000932c:	1a d8       	st.w	--sp,r8
8000932e:	fa c8 fb b4 	sub	r8,sp,-1100
80009332:	1a d8       	st.w	--sp,r8
80009334:	fa c9 ff b4 	sub	r9,sp,-76
80009338:	fa c8 f9 40 	sub	r8,sp,-1728
8000933c:	04 9a       	mov	r10,r2
8000933e:	0c 9b       	mov	r11,r6
80009340:	08 9c       	mov	r12,r4
80009342:	fe b0 f6 a3 	rcall	80008088 <get_arg>
80009346:	2f dd       	sub	sp,-12
80009348:	78 09       	ld.w	r9,r12[0x0]
8000934a:	c2 18       	rjmp	8000938c <_vfprintf_r+0xfd4>
8000934c:	2f f7       	sub	r7,-1
8000934e:	10 39       	cp.w	r9,r8
80009350:	c0 84       	brge	80009360 <_vfprintf_r+0xfa8>
80009352:	fa ca f9 44 	sub	r10,sp,-1724
80009356:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000935a:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000935e:	c1 78       	rjmp	8000938c <_vfprintf_r+0xfd4>
80009360:	41 09       	lddsp	r9,sp[0x40]
80009362:	59 f8       	cp.w	r8,31
80009364:	e0 89 00 10 	brgt	80009384 <_vfprintf_r+0xfcc>
80009368:	f2 ca ff fc 	sub	r10,r9,-4
8000936c:	51 0a       	stdsp	sp[0x40],r10
8000936e:	fa c6 f9 44 	sub	r6,sp,-1724
80009372:	72 09       	ld.w	r9,r9[0x0]
80009374:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80009378:	f5 49 fd 88 	st.w	r10[-632],r9
8000937c:	2f f8       	sub	r8,-1
8000937e:	fb 48 06 b4 	st.w	sp[1716],r8
80009382:	c0 58       	rjmp	8000938c <_vfprintf_r+0xfd4>
80009384:	f2 c8 ff fc 	sub	r8,r9,-4
80009388:	51 08       	stdsp	sp[0x40],r8
8000938a:	72 09       	ld.w	r9,r9[0x0]
8000938c:	33 08       	mov	r8,48
8000938e:	fb 68 06 b8 	st.b	sp[1720],r8
80009392:	37 88       	mov	r8,120
80009394:	30 0e       	mov	lr,0
80009396:	fb 68 06 b9 	st.b	sp[1721],r8
8000939a:	fe cc b1 46 	sub	r12,pc,-20154
8000939e:	50 19       	stdsp	sp[0x4],r9
800093a0:	a1 b5       	sbr	r5,0x1
800093a2:	50 0e       	stdsp	sp[0x0],lr
800093a4:	50 dc       	stdsp	sp[0x34],r12
800093a6:	30 28       	mov	r8,2
800093a8:	37 80       	mov	r0,120
800093aa:	e0 8f 02 a3 	bral	800098f0 <_vfprintf_r+0x1538>
800093ae:	50 a7       	stdsp	sp[0x28],r7
800093b0:	50 80       	stdsp	sp[0x20],r0
800093b2:	10 90       	mov	r0,r8
800093b4:	30 08       	mov	r8,0
800093b6:	fb 68 06 bb 	st.b	sp[1723],r8
800093ba:	0c 97       	mov	r7,r6
800093bc:	04 94       	mov	r4,r2
800093be:	06 96       	mov	r6,r3
800093c0:	02 92       	mov	r2,r1
800093c2:	40 93       	lddsp	r3,sp[0x24]
800093c4:	40 41       	lddsp	r1,sp[0x10]
800093c6:	0e 99       	mov	r9,r7
800093c8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800093cc:	40 3b       	lddsp	r11,sp[0xc]
800093ce:	58 0b       	cp.w	r11,0
800093d0:	c1 d0       	breq	8000940a <_vfprintf_r+0x1052>
800093d2:	10 36       	cp.w	r6,r8
800093d4:	c0 64       	brge	800093e0 <_vfprintf_r+0x1028>
800093d6:	fa ca f9 44 	sub	r10,sp,-1724
800093da:	f4 06 00 36 	add	r6,r10,r6<<0x3
800093de:	c1 d8       	rjmp	80009418 <_vfprintf_r+0x1060>
800093e0:	fa c8 f9 50 	sub	r8,sp,-1712
800093e4:	1a d8       	st.w	--sp,r8
800093e6:	fa c8 fa b8 	sub	r8,sp,-1352
800093ea:	1a d8       	st.w	--sp,r8
800093ec:	fa c8 fb b4 	sub	r8,sp,-1100
800093f0:	0c 9b       	mov	r11,r6
800093f2:	1a d8       	st.w	--sp,r8
800093f4:	04 9a       	mov	r10,r2
800093f6:	fa c8 f9 40 	sub	r8,sp,-1728
800093fa:	fa c9 ff b4 	sub	r9,sp,-76
800093fe:	08 9c       	mov	r12,r4
80009400:	fe b0 f6 44 	rcall	80008088 <get_arg>
80009404:	2f dd       	sub	sp,-12
80009406:	78 06       	ld.w	r6,r12[0x0]
80009408:	c2 08       	rjmp	80009448 <_vfprintf_r+0x1090>
8000940a:	2f f7       	sub	r7,-1
8000940c:	10 39       	cp.w	r9,r8
8000940e:	c0 84       	brge	8000941e <_vfprintf_r+0x1066>
80009410:	fa c9 f9 44 	sub	r9,sp,-1724
80009414:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009418:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000941c:	c1 68       	rjmp	80009448 <_vfprintf_r+0x1090>
8000941e:	41 09       	lddsp	r9,sp[0x40]
80009420:	59 f8       	cp.w	r8,31
80009422:	e0 89 00 10 	brgt	80009442 <_vfprintf_r+0x108a>
80009426:	f2 ca ff fc 	sub	r10,r9,-4
8000942a:	51 0a       	stdsp	sp[0x40],r10
8000942c:	72 06       	ld.w	r6,r9[0x0]
8000942e:	fa ce f9 44 	sub	lr,sp,-1724
80009432:	fc 08 00 39 	add	r9,lr,r8<<0x3
80009436:	f3 46 fd 88 	st.w	r9[-632],r6
8000943a:	2f f8       	sub	r8,-1
8000943c:	fb 48 06 b4 	st.w	sp[1716],r8
80009440:	c0 48       	rjmp	80009448 <_vfprintf_r+0x1090>
80009442:	72 06       	ld.w	r6,r9[0x0]
80009444:	2f c9       	sub	r9,-4
80009446:	51 09       	stdsp	sp[0x40],r9
80009448:	40 2c       	lddsp	r12,sp[0x8]
8000944a:	58 0c       	cp.w	r12,0
8000944c:	c1 05       	brlt	8000946c <_vfprintf_r+0x10b4>
8000944e:	18 9a       	mov	r10,r12
80009450:	30 0b       	mov	r11,0
80009452:	0c 9c       	mov	r12,r6
80009454:	e0 a0 12 38 	rcall	8000b8c4 <memchr>
80009458:	e0 80 02 df 	breq	80009a16 <_vfprintf_r+0x165e>
8000945c:	f8 06 01 02 	sub	r2,r12,r6
80009460:	40 2b       	lddsp	r11,sp[0x8]
80009462:	16 32       	cp.w	r2,r11
80009464:	e0 89 02 d9 	brgt	80009a16 <_vfprintf_r+0x165e>
80009468:	e0 8f 02 d4 	bral	80009a10 <_vfprintf_r+0x1658>
8000946c:	30 0a       	mov	r10,0
8000946e:	0c 9c       	mov	r12,r6
80009470:	50 2a       	stdsp	sp[0x8],r10
80009472:	e0 a0 15 99 	rcall	8000bfa4 <strlen>
80009476:	18 92       	mov	r2,r12
80009478:	e0 8f 02 d2 	bral	80009a1c <_vfprintf_r+0x1664>
8000947c:	50 a7       	stdsp	sp[0x28],r7
8000947e:	50 80       	stdsp	sp[0x20],r0
80009480:	0c 97       	mov	r7,r6
80009482:	04 94       	mov	r4,r2
80009484:	06 96       	mov	r6,r3
80009486:	02 92       	mov	r2,r1
80009488:	40 93       	lddsp	r3,sp[0x24]
8000948a:	10 90       	mov	r0,r8
8000948c:	40 41       	lddsp	r1,sp[0x10]
8000948e:	a5 a5       	sbr	r5,0x4
80009490:	c0 a8       	rjmp	800094a4 <_vfprintf_r+0x10ec>
80009492:	50 a7       	stdsp	sp[0x28],r7
80009494:	50 80       	stdsp	sp[0x20],r0
80009496:	0c 97       	mov	r7,r6
80009498:	04 94       	mov	r4,r2
8000949a:	06 96       	mov	r6,r3
8000949c:	02 92       	mov	r2,r1
8000949e:	40 93       	lddsp	r3,sp[0x24]
800094a0:	10 90       	mov	r0,r8
800094a2:	40 41       	lddsp	r1,sp[0x10]
800094a4:	ed b5 00 05 	bld	r5,0x5
800094a8:	c5 61       	brne	80009554 <_vfprintf_r+0x119c>
800094aa:	fa f8 06 b4 	ld.w	r8,sp[1716]
800094ae:	40 39       	lddsp	r9,sp[0xc]
800094b0:	58 09       	cp.w	r9,0
800094b2:	c2 10       	breq	800094f4 <_vfprintf_r+0x113c>
800094b4:	10 36       	cp.w	r6,r8
800094b6:	c0 74       	brge	800094c4 <_vfprintf_r+0x110c>
800094b8:	fa c8 f9 44 	sub	r8,sp,-1724
800094bc:	f0 06 00 36 	add	r6,r8,r6<<0x3
800094c0:	c2 38       	rjmp	80009506 <_vfprintf_r+0x114e>
800094c2:	d7 03       	nop
800094c4:	fa c8 f9 50 	sub	r8,sp,-1712
800094c8:	1a d8       	st.w	--sp,r8
800094ca:	fa c8 fa b8 	sub	r8,sp,-1352
800094ce:	1a d8       	st.w	--sp,r8
800094d0:	fa c8 fb b4 	sub	r8,sp,-1100
800094d4:	1a d8       	st.w	--sp,r8
800094d6:	fa c8 f9 40 	sub	r8,sp,-1728
800094da:	fa c9 ff b4 	sub	r9,sp,-76
800094de:	04 9a       	mov	r10,r2
800094e0:	0c 9b       	mov	r11,r6
800094e2:	08 9c       	mov	r12,r4
800094e4:	fe b0 f5 d2 	rcall	80008088 <get_arg>
800094e8:	2f dd       	sub	sp,-12
800094ea:	f8 e8 00 00 	ld.d	r8,r12[0]
800094ee:	fa e9 00 00 	st.d	sp[0],r8
800094f2:	c2 e8       	rjmp	8000954e <_vfprintf_r+0x1196>
800094f4:	ee ca ff ff 	sub	r10,r7,-1
800094f8:	10 37       	cp.w	r7,r8
800094fa:	c0 b4       	brge	80009510 <_vfprintf_r+0x1158>
800094fc:	fa c8 f9 44 	sub	r8,sp,-1724
80009500:	14 97       	mov	r7,r10
80009502:	f0 06 00 36 	add	r6,r8,r6<<0x3
80009506:	ec ea fd 88 	ld.d	r10,r6[-632]
8000950a:	fa eb 00 00 	st.d	sp[0],r10
8000950e:	c2 08       	rjmp	8000954e <_vfprintf_r+0x1196>
80009510:	41 09       	lddsp	r9,sp[0x40]
80009512:	59 f8       	cp.w	r8,31
80009514:	e0 89 00 16 	brgt	80009540 <_vfprintf_r+0x1188>
80009518:	f2 e6 00 00 	ld.d	r6,r9[0]
8000951c:	f2 cb ff f8 	sub	r11,r9,-8
80009520:	fa e7 00 00 	st.d	sp[0],r6
80009524:	51 0b       	stdsp	sp[0x40],r11
80009526:	fa c6 f9 44 	sub	r6,sp,-1724
8000952a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000952e:	fa e6 00 00 	ld.d	r6,sp[0]
80009532:	f2 e7 fd 88 	st.d	r9[-632],r6
80009536:	2f f8       	sub	r8,-1
80009538:	14 97       	mov	r7,r10
8000953a:	fb 48 06 b4 	st.w	sp[1716],r8
8000953e:	c0 88       	rjmp	8000954e <_vfprintf_r+0x1196>
80009540:	f2 e6 00 00 	ld.d	r6,r9[0]
80009544:	2f 89       	sub	r9,-8
80009546:	fa e7 00 00 	st.d	sp[0],r6
8000954a:	51 09       	stdsp	sp[0x40],r9
8000954c:	14 97       	mov	r7,r10
8000954e:	30 18       	mov	r8,1
80009550:	e0 8f 01 d0 	bral	800098f0 <_vfprintf_r+0x1538>
80009554:	ed b5 00 04 	bld	r5,0x4
80009558:	c1 61       	brne	80009584 <_vfprintf_r+0x11cc>
8000955a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000955e:	40 3e       	lddsp	lr,sp[0xc]
80009560:	58 0e       	cp.w	lr,0
80009562:	c0 80       	breq	80009572 <_vfprintf_r+0x11ba>
80009564:	10 36       	cp.w	r6,r8
80009566:	c6 74       	brge	80009634 <_vfprintf_r+0x127c>
80009568:	fa cc f9 44 	sub	r12,sp,-1724
8000956c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009570:	c8 08       	rjmp	80009670 <_vfprintf_r+0x12b8>
80009572:	ee ca ff ff 	sub	r10,r7,-1
80009576:	10 37       	cp.w	r7,r8
80009578:	c7 f4       	brge	80009676 <_vfprintf_r+0x12be>
8000957a:	fa cb f9 44 	sub	r11,sp,-1724
8000957e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009582:	c7 68       	rjmp	8000966e <_vfprintf_r+0x12b6>
80009584:	ed b5 00 06 	bld	r5,0x6
80009588:	c4 a1       	brne	8000961c <_vfprintf_r+0x1264>
8000958a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000958e:	40 3c       	lddsp	r12,sp[0xc]
80009590:	58 0c       	cp.w	r12,0
80009592:	c1 d0       	breq	800095cc <_vfprintf_r+0x1214>
80009594:	10 36       	cp.w	r6,r8
80009596:	c0 64       	brge	800095a2 <_vfprintf_r+0x11ea>
80009598:	fa cb f9 44 	sub	r11,sp,-1724
8000959c:	f6 06 00 36 	add	r6,r11,r6<<0x3
800095a0:	c1 f8       	rjmp	800095de <_vfprintf_r+0x1226>
800095a2:	fa c8 f9 50 	sub	r8,sp,-1712
800095a6:	1a d8       	st.w	--sp,r8
800095a8:	fa c8 fa b8 	sub	r8,sp,-1352
800095ac:	1a d8       	st.w	--sp,r8
800095ae:	fa c8 fb b4 	sub	r8,sp,-1100
800095b2:	1a d8       	st.w	--sp,r8
800095b4:	fa c8 f9 40 	sub	r8,sp,-1728
800095b8:	fa c9 ff b4 	sub	r9,sp,-76
800095bc:	04 9a       	mov	r10,r2
800095be:	0c 9b       	mov	r11,r6
800095c0:	08 9c       	mov	r12,r4
800095c2:	fe b0 f5 63 	rcall	80008088 <get_arg>
800095c6:	2f dd       	sub	sp,-12
800095c8:	98 18       	ld.sh	r8,r12[0x2]
800095ca:	c2 68       	rjmp	80009616 <_vfprintf_r+0x125e>
800095cc:	ee ca ff ff 	sub	r10,r7,-1
800095d0:	10 37       	cp.w	r7,r8
800095d2:	c0 94       	brge	800095e4 <_vfprintf_r+0x122c>
800095d4:	fa c9 f9 44 	sub	r9,sp,-1724
800095d8:	14 97       	mov	r7,r10
800095da:	f2 06 00 36 	add	r6,r9,r6<<0x3
800095de:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
800095e2:	c1 a8       	rjmp	80009616 <_vfprintf_r+0x125e>
800095e4:	41 09       	lddsp	r9,sp[0x40]
800095e6:	59 f8       	cp.w	r8,31
800095e8:	e0 89 00 13 	brgt	8000960e <_vfprintf_r+0x1256>
800095ec:	f2 cb ff fc 	sub	r11,r9,-4
800095f0:	51 0b       	stdsp	sp[0x40],r11
800095f2:	72 09       	ld.w	r9,r9[0x0]
800095f4:	fa c6 f9 44 	sub	r6,sp,-1724
800095f8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
800095fc:	2f f8       	sub	r8,-1
800095fe:	f7 49 fd 88 	st.w	r11[-632],r9
80009602:	fb 48 06 b4 	st.w	sp[1716],r8
80009606:	14 97       	mov	r7,r10
80009608:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000960c:	c0 58       	rjmp	80009616 <_vfprintf_r+0x125e>
8000960e:	92 18       	ld.sh	r8,r9[0x2]
80009610:	14 97       	mov	r7,r10
80009612:	2f c9       	sub	r9,-4
80009614:	51 09       	stdsp	sp[0x40],r9
80009616:	5c 78       	castu.h	r8
80009618:	50 18       	stdsp	sp[0x4],r8
8000961a:	c4 68       	rjmp	800096a6 <_vfprintf_r+0x12ee>
8000961c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009620:	40 3c       	lddsp	r12,sp[0xc]
80009622:	58 0c       	cp.w	r12,0
80009624:	c1 d0       	breq	8000965e <_vfprintf_r+0x12a6>
80009626:	10 36       	cp.w	r6,r8
80009628:	c0 64       	brge	80009634 <_vfprintf_r+0x127c>
8000962a:	fa cb f9 44 	sub	r11,sp,-1724
8000962e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009632:	c1 f8       	rjmp	80009670 <_vfprintf_r+0x12b8>
80009634:	fa c8 f9 50 	sub	r8,sp,-1712
80009638:	1a d8       	st.w	--sp,r8
8000963a:	fa c8 fa b8 	sub	r8,sp,-1352
8000963e:	0c 9b       	mov	r11,r6
80009640:	1a d8       	st.w	--sp,r8
80009642:	fa c8 fb b4 	sub	r8,sp,-1100
80009646:	04 9a       	mov	r10,r2
80009648:	1a d8       	st.w	--sp,r8
8000964a:	08 9c       	mov	r12,r4
8000964c:	fa c8 f9 40 	sub	r8,sp,-1728
80009650:	fa c9 ff b4 	sub	r9,sp,-76
80009654:	fe b0 f5 1a 	rcall	80008088 <get_arg>
80009658:	2f dd       	sub	sp,-12
8000965a:	78 0b       	ld.w	r11,r12[0x0]
8000965c:	c2 48       	rjmp	800096a4 <_vfprintf_r+0x12ec>
8000965e:	ee ca ff ff 	sub	r10,r7,-1
80009662:	10 37       	cp.w	r7,r8
80009664:	c0 94       	brge	80009676 <_vfprintf_r+0x12be>
80009666:	fa c9 f9 44 	sub	r9,sp,-1724
8000966a:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000966e:	14 97       	mov	r7,r10
80009670:	ec fb fd 88 	ld.w	r11,r6[-632]
80009674:	c1 88       	rjmp	800096a4 <_vfprintf_r+0x12ec>
80009676:	41 09       	lddsp	r9,sp[0x40]
80009678:	59 f8       	cp.w	r8,31
8000967a:	e0 89 00 11 	brgt	8000969c <_vfprintf_r+0x12e4>
8000967e:	f2 cb ff fc 	sub	r11,r9,-4
80009682:	51 0b       	stdsp	sp[0x40],r11
80009684:	fa c6 f9 44 	sub	r6,sp,-1724
80009688:	72 0b       	ld.w	r11,r9[0x0]
8000968a:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000968e:	f3 4b fd 88 	st.w	r9[-632],r11
80009692:	2f f8       	sub	r8,-1
80009694:	14 97       	mov	r7,r10
80009696:	fb 48 06 b4 	st.w	sp[1716],r8
8000969a:	c0 58       	rjmp	800096a4 <_vfprintf_r+0x12ec>
8000969c:	72 0b       	ld.w	r11,r9[0x0]
8000969e:	14 97       	mov	r7,r10
800096a0:	2f c9       	sub	r9,-4
800096a2:	51 09       	stdsp	sp[0x40],r9
800096a4:	50 1b       	stdsp	sp[0x4],r11
800096a6:	30 0e       	mov	lr,0
800096a8:	30 18       	mov	r8,1
800096aa:	50 0e       	stdsp	sp[0x0],lr
800096ac:	c2 29       	rjmp	800098f0 <_vfprintf_r+0x1538>
800096ae:	50 a7       	stdsp	sp[0x28],r7
800096b0:	50 80       	stdsp	sp[0x20],r0
800096b2:	0c 97       	mov	r7,r6
800096b4:	04 94       	mov	r4,r2
800096b6:	06 96       	mov	r6,r3
800096b8:	02 92       	mov	r2,r1
800096ba:	fe cc b4 66 	sub	r12,pc,-19354
800096be:	40 93       	lddsp	r3,sp[0x24]
800096c0:	10 90       	mov	r0,r8
800096c2:	40 41       	lddsp	r1,sp[0x10]
800096c4:	50 dc       	stdsp	sp[0x34],r12
800096c6:	ed b5 00 05 	bld	r5,0x5
800096ca:	c5 51       	brne	80009774 <_vfprintf_r+0x13bc>
800096cc:	fa f8 06 b4 	ld.w	r8,sp[1716]
800096d0:	40 3b       	lddsp	r11,sp[0xc]
800096d2:	58 0b       	cp.w	r11,0
800096d4:	c2 20       	breq	80009718 <_vfprintf_r+0x1360>
800096d6:	10 36       	cp.w	r6,r8
800096d8:	c0 a4       	brge	800096ec <_vfprintf_r+0x1334>
800096da:	fa ca f9 44 	sub	r10,sp,-1724
800096de:	f4 06 00 36 	add	r6,r10,r6<<0x3
800096e2:	ec e8 fd 88 	ld.d	r8,r6[-632]
800096e6:	fa e9 00 00 	st.d	sp[0],r8
800096ea:	cf 28       	rjmp	800098ce <_vfprintf_r+0x1516>
800096ec:	fa c8 f9 50 	sub	r8,sp,-1712
800096f0:	1a d8       	st.w	--sp,r8
800096f2:	fa c8 fa b8 	sub	r8,sp,-1352
800096f6:	04 9a       	mov	r10,r2
800096f8:	1a d8       	st.w	--sp,r8
800096fa:	0c 9b       	mov	r11,r6
800096fc:	fa c8 fb b4 	sub	r8,sp,-1100
80009700:	08 9c       	mov	r12,r4
80009702:	1a d8       	st.w	--sp,r8
80009704:	fa c8 f9 40 	sub	r8,sp,-1728
80009708:	fa c9 ff b4 	sub	r9,sp,-76
8000970c:	fe b0 f4 be 	rcall	80008088 <get_arg>
80009710:	2f dd       	sub	sp,-12
80009712:	f8 ea 00 00 	ld.d	r10,r12[0]
80009716:	c0 c8       	rjmp	8000972e <_vfprintf_r+0x1376>
80009718:	ee ca ff ff 	sub	r10,r7,-1
8000971c:	10 37       	cp.w	r7,r8
8000971e:	c0 b4       	brge	80009734 <_vfprintf_r+0x137c>
80009720:	fa c9 f9 44 	sub	r9,sp,-1724
80009724:	14 97       	mov	r7,r10
80009726:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000972a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000972e:	fa eb 00 00 	st.d	sp[0],r10
80009732:	cc e8       	rjmp	800098ce <_vfprintf_r+0x1516>
80009734:	41 09       	lddsp	r9,sp[0x40]
80009736:	59 f8       	cp.w	r8,31
80009738:	e0 89 00 16 	brgt	80009764 <_vfprintf_r+0x13ac>
8000973c:	f2 e6 00 00 	ld.d	r6,r9[0]
80009740:	f2 cb ff f8 	sub	r11,r9,-8
80009744:	fa e7 00 00 	st.d	sp[0],r6
80009748:	51 0b       	stdsp	sp[0x40],r11
8000974a:	fa c6 f9 44 	sub	r6,sp,-1724
8000974e:	ec 08 00 39 	add	r9,r6,r8<<0x3
80009752:	fa e6 00 00 	ld.d	r6,sp[0]
80009756:	f2 e7 fd 88 	st.d	r9[-632],r6
8000975a:	2f f8       	sub	r8,-1
8000975c:	14 97       	mov	r7,r10
8000975e:	fb 48 06 b4 	st.w	sp[1716],r8
80009762:	cb 68       	rjmp	800098ce <_vfprintf_r+0x1516>
80009764:	f2 e6 00 00 	ld.d	r6,r9[0]
80009768:	2f 89       	sub	r9,-8
8000976a:	fa e7 00 00 	st.d	sp[0],r6
8000976e:	51 09       	stdsp	sp[0x40],r9
80009770:	14 97       	mov	r7,r10
80009772:	ca e8       	rjmp	800098ce <_vfprintf_r+0x1516>
80009774:	ed b5 00 04 	bld	r5,0x4
80009778:	c1 71       	brne	800097a6 <_vfprintf_r+0x13ee>
8000977a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000977e:	40 3e       	lddsp	lr,sp[0xc]
80009780:	58 0e       	cp.w	lr,0
80009782:	c0 80       	breq	80009792 <_vfprintf_r+0x13da>
80009784:	10 36       	cp.w	r6,r8
80009786:	c6 94       	brge	80009858 <_vfprintf_r+0x14a0>
80009788:	fa cc f9 44 	sub	r12,sp,-1724
8000978c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80009790:	c8 28       	rjmp	80009894 <_vfprintf_r+0x14dc>
80009792:	ee ca ff ff 	sub	r10,r7,-1
80009796:	10 37       	cp.w	r7,r8
80009798:	e0 84 00 81 	brge	8000989a <_vfprintf_r+0x14e2>
8000979c:	fa cb f9 44 	sub	r11,sp,-1724
800097a0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800097a4:	c7 78       	rjmp	80009892 <_vfprintf_r+0x14da>
800097a6:	ed b5 00 06 	bld	r5,0x6
800097aa:	c4 b1       	brne	80009840 <_vfprintf_r+0x1488>
800097ac:	fa f8 06 b4 	ld.w	r8,sp[1716]
800097b0:	40 3c       	lddsp	r12,sp[0xc]
800097b2:	58 0c       	cp.w	r12,0
800097b4:	c1 d0       	breq	800097ee <_vfprintf_r+0x1436>
800097b6:	10 36       	cp.w	r6,r8
800097b8:	c0 64       	brge	800097c4 <_vfprintf_r+0x140c>
800097ba:	fa cb f9 44 	sub	r11,sp,-1724
800097be:	f6 06 00 36 	add	r6,r11,r6<<0x3
800097c2:	c1 f8       	rjmp	80009800 <_vfprintf_r+0x1448>
800097c4:	fa c8 f9 50 	sub	r8,sp,-1712
800097c8:	1a d8       	st.w	--sp,r8
800097ca:	fa c8 fa b8 	sub	r8,sp,-1352
800097ce:	1a d8       	st.w	--sp,r8
800097d0:	fa c8 fb b4 	sub	r8,sp,-1100
800097d4:	1a d8       	st.w	--sp,r8
800097d6:	fa c8 f9 40 	sub	r8,sp,-1728
800097da:	fa c9 ff b4 	sub	r9,sp,-76
800097de:	04 9a       	mov	r10,r2
800097e0:	0c 9b       	mov	r11,r6
800097e2:	08 9c       	mov	r12,r4
800097e4:	fe b0 f4 52 	rcall	80008088 <get_arg>
800097e8:	2f dd       	sub	sp,-12
800097ea:	98 18       	ld.sh	r8,r12[0x2]
800097ec:	c2 78       	rjmp	8000983a <_vfprintf_r+0x1482>
800097ee:	ee ca ff ff 	sub	r10,r7,-1
800097f2:	10 37       	cp.w	r7,r8
800097f4:	c0 a4       	brge	80009808 <_vfprintf_r+0x1450>
800097f6:	fa c9 f9 44 	sub	r9,sp,-1724
800097fa:	14 97       	mov	r7,r10
800097fc:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009800:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80009804:	c1 b8       	rjmp	8000983a <_vfprintf_r+0x1482>
80009806:	d7 03       	nop
80009808:	41 09       	lddsp	r9,sp[0x40]
8000980a:	59 f8       	cp.w	r8,31
8000980c:	e0 89 00 13 	brgt	80009832 <_vfprintf_r+0x147a>
80009810:	f2 cb ff fc 	sub	r11,r9,-4
80009814:	51 0b       	stdsp	sp[0x40],r11
80009816:	72 09       	ld.w	r9,r9[0x0]
80009818:	fa c6 f9 44 	sub	r6,sp,-1724
8000981c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80009820:	2f f8       	sub	r8,-1
80009822:	f7 49 fd 88 	st.w	r11[-632],r9
80009826:	fb 48 06 b4 	st.w	sp[1716],r8
8000982a:	14 97       	mov	r7,r10
8000982c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80009830:	c0 58       	rjmp	8000983a <_vfprintf_r+0x1482>
80009832:	92 18       	ld.sh	r8,r9[0x2]
80009834:	14 97       	mov	r7,r10
80009836:	2f c9       	sub	r9,-4
80009838:	51 09       	stdsp	sp[0x40],r9
8000983a:	5c 78       	castu.h	r8
8000983c:	50 18       	stdsp	sp[0x4],r8
8000983e:	c4 68       	rjmp	800098ca <_vfprintf_r+0x1512>
80009840:	fa f8 06 b4 	ld.w	r8,sp[1716]
80009844:	40 3c       	lddsp	r12,sp[0xc]
80009846:	58 0c       	cp.w	r12,0
80009848:	c1 d0       	breq	80009882 <_vfprintf_r+0x14ca>
8000984a:	10 36       	cp.w	r6,r8
8000984c:	c0 64       	brge	80009858 <_vfprintf_r+0x14a0>
8000984e:	fa cb f9 44 	sub	r11,sp,-1724
80009852:	f6 06 00 36 	add	r6,r11,r6<<0x3
80009856:	c1 f8       	rjmp	80009894 <_vfprintf_r+0x14dc>
80009858:	fa c8 f9 50 	sub	r8,sp,-1712
8000985c:	1a d8       	st.w	--sp,r8
8000985e:	fa c8 fa b8 	sub	r8,sp,-1352
80009862:	0c 9b       	mov	r11,r6
80009864:	1a d8       	st.w	--sp,r8
80009866:	fa c8 fb b4 	sub	r8,sp,-1100
8000986a:	04 9a       	mov	r10,r2
8000986c:	1a d8       	st.w	--sp,r8
8000986e:	08 9c       	mov	r12,r4
80009870:	fa c8 f9 40 	sub	r8,sp,-1728
80009874:	fa c9 ff b4 	sub	r9,sp,-76
80009878:	fe b0 f4 08 	rcall	80008088 <get_arg>
8000987c:	2f dd       	sub	sp,-12
8000987e:	78 0b       	ld.w	r11,r12[0x0]
80009880:	c2 48       	rjmp	800098c8 <_vfprintf_r+0x1510>
80009882:	ee ca ff ff 	sub	r10,r7,-1
80009886:	10 37       	cp.w	r7,r8
80009888:	c0 94       	brge	8000989a <_vfprintf_r+0x14e2>
8000988a:	fa c9 f9 44 	sub	r9,sp,-1724
8000988e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80009892:	14 97       	mov	r7,r10
80009894:	ec fb fd 88 	ld.w	r11,r6[-632]
80009898:	c1 88       	rjmp	800098c8 <_vfprintf_r+0x1510>
8000989a:	41 09       	lddsp	r9,sp[0x40]
8000989c:	59 f8       	cp.w	r8,31
8000989e:	e0 89 00 11 	brgt	800098c0 <_vfprintf_r+0x1508>
800098a2:	f2 cb ff fc 	sub	r11,r9,-4
800098a6:	51 0b       	stdsp	sp[0x40],r11
800098a8:	fa c6 f9 44 	sub	r6,sp,-1724
800098ac:	72 0b       	ld.w	r11,r9[0x0]
800098ae:	ec 08 00 39 	add	r9,r6,r8<<0x3
800098b2:	f3 4b fd 88 	st.w	r9[-632],r11
800098b6:	2f f8       	sub	r8,-1
800098b8:	14 97       	mov	r7,r10
800098ba:	fb 48 06 b4 	st.w	sp[1716],r8
800098be:	c0 58       	rjmp	800098c8 <_vfprintf_r+0x1510>
800098c0:	72 0b       	ld.w	r11,r9[0x0]
800098c2:	14 97       	mov	r7,r10
800098c4:	2f c9       	sub	r9,-4
800098c6:	51 09       	stdsp	sp[0x40],r9
800098c8:	50 1b       	stdsp	sp[0x4],r11
800098ca:	30 0e       	mov	lr,0
800098cc:	50 0e       	stdsp	sp[0x0],lr
800098ce:	40 08       	lddsp	r8,sp[0x0]
800098d0:	40 1c       	lddsp	r12,sp[0x4]
800098d2:	18 48       	or	r8,r12
800098d4:	5f 19       	srne	r9
800098d6:	0a 98       	mov	r8,r5
800098d8:	eb e9 00 09 	and	r9,r5,r9
800098dc:	a1 b8       	sbr	r8,0x1
800098de:	58 09       	cp.w	r9,0
800098e0:	c0 70       	breq	800098ee <_vfprintf_r+0x1536>
800098e2:	10 95       	mov	r5,r8
800098e4:	fb 60 06 b9 	st.b	sp[1721],r0
800098e8:	33 08       	mov	r8,48
800098ea:	fb 68 06 b8 	st.b	sp[1720],r8
800098ee:	30 28       	mov	r8,2
800098f0:	30 09       	mov	r9,0
800098f2:	fb 69 06 bb 	st.b	sp[1723],r9
800098f6:	0a 99       	mov	r9,r5
800098f8:	a7 d9       	cbr	r9,0x7
800098fa:	40 2b       	lddsp	r11,sp[0x8]
800098fc:	40 16       	lddsp	r6,sp[0x4]
800098fe:	58 0b       	cp.w	r11,0
80009900:	5f 1a       	srne	r10
80009902:	f2 05 17 40 	movge	r5,r9
80009906:	fa c2 f9 78 	sub	r2,sp,-1672
8000990a:	40 09       	lddsp	r9,sp[0x0]
8000990c:	0c 49       	or	r9,r6
8000990e:	5f 19       	srne	r9
80009910:	f5 e9 10 09 	or	r9,r10,r9
80009914:	c5 c0       	breq	800099cc <_vfprintf_r+0x1614>
80009916:	30 19       	mov	r9,1
80009918:	f2 08 18 00 	cp.b	r8,r9
8000991c:	c0 60       	breq	80009928 <_vfprintf_r+0x1570>
8000991e:	30 29       	mov	r9,2
80009920:	f2 08 18 00 	cp.b	r8,r9
80009924:	c0 41       	brne	8000992c <_vfprintf_r+0x1574>
80009926:	c3 c8       	rjmp	8000999e <_vfprintf_r+0x15e6>
80009928:	04 96       	mov	r6,r2
8000992a:	c3 08       	rjmp	8000998a <_vfprintf_r+0x15d2>
8000992c:	04 96       	mov	r6,r2
8000992e:	fa e8 00 00 	ld.d	r8,sp[0]
80009932:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80009936:	2d 0a       	sub	r10,-48
80009938:	0c fa       	st.b	--r6,r10
8000993a:	f0 0b 16 03 	lsr	r11,r8,0x3
8000993e:	f2 0c 16 03 	lsr	r12,r9,0x3
80009942:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
80009946:	18 99       	mov	r9,r12
80009948:	16 98       	mov	r8,r11
8000994a:	58 08       	cp.w	r8,0
8000994c:	5c 29       	cpc	r9
8000994e:	cf 21       	brne	80009932 <_vfprintf_r+0x157a>
80009950:	fa e9 00 00 	st.d	sp[0],r8
80009954:	ed b5 00 00 	bld	r5,0x0
80009958:	c4 51       	brne	800099e2 <_vfprintf_r+0x162a>
8000995a:	33 09       	mov	r9,48
8000995c:	f2 0a 18 00 	cp.b	r10,r9
80009960:	c4 10       	breq	800099e2 <_vfprintf_r+0x162a>
80009962:	0c f9       	st.b	--r6,r9
80009964:	c3 f8       	rjmp	800099e2 <_vfprintf_r+0x162a>
80009966:	fa ea 00 00 	ld.d	r10,sp[0]
8000996a:	30 a8       	mov	r8,10
8000996c:	30 09       	mov	r9,0
8000996e:	e0 a0 1a 19 	rcall	8000cda0 <__avr32_umod64>
80009972:	30 a8       	mov	r8,10
80009974:	2d 0a       	sub	r10,-48
80009976:	30 09       	mov	r9,0
80009978:	ac 8a       	st.b	r6[0x0],r10
8000997a:	fa ea 00 00 	ld.d	r10,sp[0]
8000997e:	e0 a0 18 df 	rcall	8000cb3c <__avr32_udiv64>
80009982:	16 99       	mov	r9,r11
80009984:	14 98       	mov	r8,r10
80009986:	fa e9 00 00 	st.d	sp[0],r8
8000998a:	20 16       	sub	r6,1
8000998c:	fa ea 00 00 	ld.d	r10,sp[0]
80009990:	58 9a       	cp.w	r10,9
80009992:	5c 2b       	cpc	r11
80009994:	fe 9b ff e9 	brhi	80009966 <_vfprintf_r+0x15ae>
80009998:	1b f8       	ld.ub	r8,sp[0x7]
8000999a:	2d 08       	sub	r8,-48
8000999c:	c2 08       	rjmp	800099dc <_vfprintf_r+0x1624>
8000999e:	04 96       	mov	r6,r2
800099a0:	fa e8 00 00 	ld.d	r8,sp[0]
800099a4:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
800099a8:	40 de       	lddsp	lr,sp[0x34]
800099aa:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
800099ae:	0c fa       	st.b	--r6,r10
800099b0:	f2 0b 16 04 	lsr	r11,r9,0x4
800099b4:	f0 0a 16 04 	lsr	r10,r8,0x4
800099b8:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
800099bc:	16 99       	mov	r9,r11
800099be:	14 98       	mov	r8,r10
800099c0:	58 08       	cp.w	r8,0
800099c2:	5c 29       	cpc	r9
800099c4:	cf 01       	brne	800099a4 <_vfprintf_r+0x15ec>
800099c6:	fa e9 00 00 	st.d	sp[0],r8
800099ca:	c0 c8       	rjmp	800099e2 <_vfprintf_r+0x162a>
800099cc:	58 08       	cp.w	r8,0
800099ce:	c0 91       	brne	800099e0 <_vfprintf_r+0x1628>
800099d0:	ed b5 00 00 	bld	r5,0x0
800099d4:	c0 61       	brne	800099e0 <_vfprintf_r+0x1628>
800099d6:	fa c6 f9 79 	sub	r6,sp,-1671
800099da:	33 08       	mov	r8,48
800099dc:	ac 88       	st.b	r6[0x0],r8
800099de:	c0 28       	rjmp	800099e2 <_vfprintf_r+0x162a>
800099e0:	04 96       	mov	r6,r2
800099e2:	0c 12       	sub	r2,r6
800099e4:	c1 c8       	rjmp	80009a1c <_vfprintf_r+0x1664>
800099e6:	50 a7       	stdsp	sp[0x28],r7
800099e8:	50 80       	stdsp	sp[0x20],r0
800099ea:	40 93       	lddsp	r3,sp[0x24]
800099ec:	0c 97       	mov	r7,r6
800099ee:	10 90       	mov	r0,r8
800099f0:	04 94       	mov	r4,r2
800099f2:	40 41       	lddsp	r1,sp[0x10]
800099f4:	58 08       	cp.w	r8,0
800099f6:	e0 80 04 4f 	breq	8000a294 <_vfprintf_r+0x1edc>
800099fa:	fb 68 06 60 	st.b	sp[1632],r8
800099fe:	30 0c       	mov	r12,0
80009a00:	30 08       	mov	r8,0
80009a02:	30 12       	mov	r2,1
80009a04:	fb 68 06 bb 	st.b	sp[1723],r8
80009a08:	50 2c       	stdsp	sp[0x8],r12
80009a0a:	fa c6 f9 a0 	sub	r6,sp,-1632
80009a0e:	c0 78       	rjmp	80009a1c <_vfprintf_r+0x1664>
80009a10:	30 0b       	mov	r11,0
80009a12:	50 2b       	stdsp	sp[0x8],r11
80009a14:	c0 48       	rjmp	80009a1c <_vfprintf_r+0x1664>
80009a16:	40 22       	lddsp	r2,sp[0x8]
80009a18:	30 0a       	mov	r10,0
80009a1a:	50 2a       	stdsp	sp[0x8],r10
80009a1c:	40 29       	lddsp	r9,sp[0x8]
80009a1e:	e4 09 0c 49 	max	r9,r2,r9
80009a22:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009a26:	50 39       	stdsp	sp[0xc],r9
80009a28:	0a 9e       	mov	lr,r5
80009a2a:	30 09       	mov	r9,0
80009a2c:	e2 1e 00 02 	andl	lr,0x2,COH
80009a30:	f2 08 18 00 	cp.b	r8,r9
80009a34:	fb f8 10 03 	ld.wne	r8,sp[0xc]
80009a38:	f7 b8 01 ff 	subne	r8,-1
80009a3c:	fb f8 1a 03 	st.wne	sp[0xc],r8
80009a40:	0a 9b       	mov	r11,r5
80009a42:	58 0e       	cp.w	lr,0
80009a44:	fb fc 10 03 	ld.wne	r12,sp[0xc]
80009a48:	f7 bc 01 fe 	subne	r12,-2
80009a4c:	fb fc 1a 03 	st.wne	sp[0xc],r12
80009a50:	e2 1b 00 84 	andl	r11,0x84,COH
80009a54:	50 fe       	stdsp	sp[0x3c],lr
80009a56:	50 9b       	stdsp	sp[0x24],r11
80009a58:	c4 71       	brne	80009ae6 <_vfprintf_r+0x172e>
80009a5a:	40 8a       	lddsp	r10,sp[0x20]
80009a5c:	40 39       	lddsp	r9,sp[0xc]
80009a5e:	12 1a       	sub	r10,r9
80009a60:	50 4a       	stdsp	sp[0x10],r10
80009a62:	58 0a       	cp.w	r10,0
80009a64:	e0 89 00 20 	brgt	80009aa4 <_vfprintf_r+0x16ec>
80009a68:	c3 f8       	rjmp	80009ae6 <_vfprintf_r+0x172e>
80009a6a:	2f 09       	sub	r9,-16
80009a6c:	2f f8       	sub	r8,-1
80009a6e:	fe ce b8 02 	sub	lr,pc,-18430
80009a72:	31 0c       	mov	r12,16
80009a74:	fb 49 06 90 	st.w	sp[1680],r9
80009a78:	87 0e       	st.w	r3[0x0],lr
80009a7a:	87 1c       	st.w	r3[0x4],r12
80009a7c:	fb 48 06 8c 	st.w	sp[1676],r8
80009a80:	58 78       	cp.w	r8,7
80009a82:	e0 89 00 04 	brgt	80009a8a <_vfprintf_r+0x16d2>
80009a86:	2f 83       	sub	r3,-8
80009a88:	c0 b8       	rjmp	80009a9e <_vfprintf_r+0x16e6>
80009a8a:	fa ca f9 78 	sub	r10,sp,-1672
80009a8e:	02 9b       	mov	r11,r1
80009a90:	08 9c       	mov	r12,r4
80009a92:	fe b0 f4 85 	rcall	8000839c <__sprint_r>
80009a96:	e0 81 04 10 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009a9a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009a9e:	40 4b       	lddsp	r11,sp[0x10]
80009aa0:	21 0b       	sub	r11,16
80009aa2:	50 4b       	stdsp	sp[0x10],r11
80009aa4:	fa f9 06 90 	ld.w	r9,sp[1680]
80009aa8:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009aac:	fe ca b8 40 	sub	r10,pc,-18368
80009ab0:	40 4e       	lddsp	lr,sp[0x10]
80009ab2:	59 0e       	cp.w	lr,16
80009ab4:	fe 99 ff db 	brgt	80009a6a <_vfprintf_r+0x16b2>
80009ab8:	1c 09       	add	r9,lr
80009aba:	2f f8       	sub	r8,-1
80009abc:	87 0a       	st.w	r3[0x0],r10
80009abe:	fb 49 06 90 	st.w	sp[1680],r9
80009ac2:	87 1e       	st.w	r3[0x4],lr
80009ac4:	fb 48 06 8c 	st.w	sp[1676],r8
80009ac8:	58 78       	cp.w	r8,7
80009aca:	e0 89 00 04 	brgt	80009ad2 <_vfprintf_r+0x171a>
80009ace:	2f 83       	sub	r3,-8
80009ad0:	c0 b8       	rjmp	80009ae6 <_vfprintf_r+0x172e>
80009ad2:	fa ca f9 78 	sub	r10,sp,-1672
80009ad6:	02 9b       	mov	r11,r1
80009ad8:	08 9c       	mov	r12,r4
80009ada:	fe b0 f4 61 	rcall	8000839c <__sprint_r>
80009ade:	e0 81 03 ec 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009ae2:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ae6:	30 09       	mov	r9,0
80009ae8:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80009aec:	f2 08 18 00 	cp.b	r8,r9
80009af0:	c1 f0       	breq	80009b2e <_vfprintf_r+0x1776>
80009af2:	fa f8 06 90 	ld.w	r8,sp[1680]
80009af6:	fa c9 f9 45 	sub	r9,sp,-1723
80009afa:	2f f8       	sub	r8,-1
80009afc:	87 09       	st.w	r3[0x0],r9
80009afe:	fb 48 06 90 	st.w	sp[1680],r8
80009b02:	30 19       	mov	r9,1
80009b04:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b08:	87 19       	st.w	r3[0x4],r9
80009b0a:	2f f8       	sub	r8,-1
80009b0c:	fb 48 06 8c 	st.w	sp[1676],r8
80009b10:	58 78       	cp.w	r8,7
80009b12:	e0 89 00 04 	brgt	80009b1a <_vfprintf_r+0x1762>
80009b16:	2f 83       	sub	r3,-8
80009b18:	c0 b8       	rjmp	80009b2e <_vfprintf_r+0x1776>
80009b1a:	fa ca f9 78 	sub	r10,sp,-1672
80009b1e:	02 9b       	mov	r11,r1
80009b20:	08 9c       	mov	r12,r4
80009b22:	fe b0 f4 3d 	rcall	8000839c <__sprint_r>
80009b26:	e0 81 03 c8 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009b2a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b2e:	40 fc       	lddsp	r12,sp[0x3c]
80009b30:	58 0c       	cp.w	r12,0
80009b32:	c1 f0       	breq	80009b70 <_vfprintf_r+0x17b8>
80009b34:	fa f8 06 90 	ld.w	r8,sp[1680]
80009b38:	fa c9 f9 48 	sub	r9,sp,-1720
80009b3c:	2f e8       	sub	r8,-2
80009b3e:	87 09       	st.w	r3[0x0],r9
80009b40:	fb 48 06 90 	st.w	sp[1680],r8
80009b44:	30 29       	mov	r9,2
80009b46:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009b4a:	87 19       	st.w	r3[0x4],r9
80009b4c:	2f f8       	sub	r8,-1
80009b4e:	fb 48 06 8c 	st.w	sp[1676],r8
80009b52:	58 78       	cp.w	r8,7
80009b54:	e0 89 00 04 	brgt	80009b5c <_vfprintf_r+0x17a4>
80009b58:	2f 83       	sub	r3,-8
80009b5a:	c0 b8       	rjmp	80009b70 <_vfprintf_r+0x17b8>
80009b5c:	fa ca f9 78 	sub	r10,sp,-1672
80009b60:	02 9b       	mov	r11,r1
80009b62:	08 9c       	mov	r12,r4
80009b64:	fe b0 f4 1c 	rcall	8000839c <__sprint_r>
80009b68:	e0 81 03 a7 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009b6c:	fa c3 f9 e0 	sub	r3,sp,-1568
80009b70:	40 9b       	lddsp	r11,sp[0x24]
80009b72:	e0 4b 00 80 	cp.w	r11,128
80009b76:	c4 71       	brne	80009c04 <_vfprintf_r+0x184c>
80009b78:	40 8a       	lddsp	r10,sp[0x20]
80009b7a:	40 39       	lddsp	r9,sp[0xc]
80009b7c:	12 1a       	sub	r10,r9
80009b7e:	50 4a       	stdsp	sp[0x10],r10
80009b80:	58 0a       	cp.w	r10,0
80009b82:	e0 89 00 20 	brgt	80009bc2 <_vfprintf_r+0x180a>
80009b86:	c3 f8       	rjmp	80009c04 <_vfprintf_r+0x184c>
80009b88:	2f 09       	sub	r9,-16
80009b8a:	2f f8       	sub	r8,-1
80009b8c:	fe ce b9 10 	sub	lr,pc,-18160
80009b90:	31 0c       	mov	r12,16
80009b92:	fb 49 06 90 	st.w	sp[1680],r9
80009b96:	87 0e       	st.w	r3[0x0],lr
80009b98:	87 1c       	st.w	r3[0x4],r12
80009b9a:	fb 48 06 8c 	st.w	sp[1676],r8
80009b9e:	58 78       	cp.w	r8,7
80009ba0:	e0 89 00 04 	brgt	80009ba8 <_vfprintf_r+0x17f0>
80009ba4:	2f 83       	sub	r3,-8
80009ba6:	c0 b8       	rjmp	80009bbc <_vfprintf_r+0x1804>
80009ba8:	fa ca f9 78 	sub	r10,sp,-1672
80009bac:	02 9b       	mov	r11,r1
80009bae:	08 9c       	mov	r12,r4
80009bb0:	fe b0 f3 f6 	rcall	8000839c <__sprint_r>
80009bb4:	e0 81 03 81 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009bb8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009bbc:	40 4b       	lddsp	r11,sp[0x10]
80009bbe:	21 0b       	sub	r11,16
80009bc0:	50 4b       	stdsp	sp[0x10],r11
80009bc2:	fa f9 06 90 	ld.w	r9,sp[1680]
80009bc6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009bca:	fe ca b9 4e 	sub	r10,pc,-18098
80009bce:	40 4e       	lddsp	lr,sp[0x10]
80009bd0:	59 0e       	cp.w	lr,16
80009bd2:	fe 99 ff db 	brgt	80009b88 <_vfprintf_r+0x17d0>
80009bd6:	1c 09       	add	r9,lr
80009bd8:	2f f8       	sub	r8,-1
80009bda:	87 0a       	st.w	r3[0x0],r10
80009bdc:	fb 49 06 90 	st.w	sp[1680],r9
80009be0:	87 1e       	st.w	r3[0x4],lr
80009be2:	fb 48 06 8c 	st.w	sp[1676],r8
80009be6:	58 78       	cp.w	r8,7
80009be8:	e0 89 00 04 	brgt	80009bf0 <_vfprintf_r+0x1838>
80009bec:	2f 83       	sub	r3,-8
80009bee:	c0 b8       	rjmp	80009c04 <_vfprintf_r+0x184c>
80009bf0:	fa ca f9 78 	sub	r10,sp,-1672
80009bf4:	02 9b       	mov	r11,r1
80009bf6:	08 9c       	mov	r12,r4
80009bf8:	fe b0 f3 d2 	rcall	8000839c <__sprint_r>
80009bfc:	e0 81 03 5d 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009c00:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c04:	40 2c       	lddsp	r12,sp[0x8]
80009c06:	04 1c       	sub	r12,r2
80009c08:	50 2c       	stdsp	sp[0x8],r12
80009c0a:	58 0c       	cp.w	r12,0
80009c0c:	e0 89 00 20 	brgt	80009c4c <_vfprintf_r+0x1894>
80009c10:	c3 f8       	rjmp	80009c8e <_vfprintf_r+0x18d6>
80009c12:	2f 09       	sub	r9,-16
80009c14:	2f f8       	sub	r8,-1
80009c16:	fe cb b9 9a 	sub	r11,pc,-18022
80009c1a:	31 0a       	mov	r10,16
80009c1c:	fb 49 06 90 	st.w	sp[1680],r9
80009c20:	87 0b       	st.w	r3[0x0],r11
80009c22:	87 1a       	st.w	r3[0x4],r10
80009c24:	fb 48 06 8c 	st.w	sp[1676],r8
80009c28:	58 78       	cp.w	r8,7
80009c2a:	e0 89 00 04 	brgt	80009c32 <_vfprintf_r+0x187a>
80009c2e:	2f 83       	sub	r3,-8
80009c30:	c0 b8       	rjmp	80009c46 <_vfprintf_r+0x188e>
80009c32:	fa ca f9 78 	sub	r10,sp,-1672
80009c36:	02 9b       	mov	r11,r1
80009c38:	08 9c       	mov	r12,r4
80009c3a:	fe b0 f3 b1 	rcall	8000839c <__sprint_r>
80009c3e:	e0 81 03 3c 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009c42:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c46:	40 29       	lddsp	r9,sp[0x8]
80009c48:	21 09       	sub	r9,16
80009c4a:	50 29       	stdsp	sp[0x8],r9
80009c4c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009c50:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009c54:	fe ca b9 d8 	sub	r10,pc,-17960
80009c58:	40 2e       	lddsp	lr,sp[0x8]
80009c5a:	59 0e       	cp.w	lr,16
80009c5c:	fe 99 ff db 	brgt	80009c12 <_vfprintf_r+0x185a>
80009c60:	1c 09       	add	r9,lr
80009c62:	2f f8       	sub	r8,-1
80009c64:	87 0a       	st.w	r3[0x0],r10
80009c66:	fb 49 06 90 	st.w	sp[1680],r9
80009c6a:	87 1e       	st.w	r3[0x4],lr
80009c6c:	fb 48 06 8c 	st.w	sp[1676],r8
80009c70:	58 78       	cp.w	r8,7
80009c72:	e0 89 00 04 	brgt	80009c7a <_vfprintf_r+0x18c2>
80009c76:	2f 83       	sub	r3,-8
80009c78:	c0 b8       	rjmp	80009c8e <_vfprintf_r+0x18d6>
80009c7a:	fa ca f9 78 	sub	r10,sp,-1672
80009c7e:	02 9b       	mov	r11,r1
80009c80:	08 9c       	mov	r12,r4
80009c82:	fe b0 f3 8d 	rcall	8000839c <__sprint_r>
80009c86:	e0 81 03 18 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009c8a:	fa c3 f9 e0 	sub	r3,sp,-1568
80009c8e:	ed b5 00 08 	bld	r5,0x8
80009c92:	c0 b0       	breq	80009ca8 <_vfprintf_r+0x18f0>
80009c94:	fa f8 06 90 	ld.w	r8,sp[1680]
80009c98:	87 12       	st.w	r3[0x4],r2
80009c9a:	87 06       	st.w	r3[0x0],r6
80009c9c:	f0 02 00 02 	add	r2,r8,r2
80009ca0:	fb 42 06 90 	st.w	sp[1680],r2
80009ca4:	e0 8f 01 d4 	bral	8000a04c <_vfprintf_r+0x1c94>
80009ca8:	e0 40 00 65 	cp.w	r0,101
80009cac:	e0 8a 01 d6 	brle	8000a058 <_vfprintf_r+0x1ca0>
80009cb0:	30 08       	mov	r8,0
80009cb2:	30 09       	mov	r9,0
80009cb4:	40 5b       	lddsp	r11,sp[0x14]
80009cb6:	40 7a       	lddsp	r10,sp[0x1c]
80009cb8:	e0 a0 15 3b 	rcall	8000c72e <__avr32_f64_cmp_eq>
80009cbc:	c7 90       	breq	80009dae <_vfprintf_r+0x19f6>
80009cbe:	fa f8 06 90 	ld.w	r8,sp[1680]
80009cc2:	fe c9 ba 5a 	sub	r9,pc,-17830
80009cc6:	2f f8       	sub	r8,-1
80009cc8:	87 09       	st.w	r3[0x0],r9
80009cca:	fb 48 06 90 	st.w	sp[1680],r8
80009cce:	30 19       	mov	r9,1
80009cd0:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009cd4:	87 19       	st.w	r3[0x4],r9
80009cd6:	2f f8       	sub	r8,-1
80009cd8:	fb 48 06 8c 	st.w	sp[1676],r8
80009cdc:	58 78       	cp.w	r8,7
80009cde:	e0 89 00 05 	brgt	80009ce8 <_vfprintf_r+0x1930>
80009ce2:	2f 83       	sub	r3,-8
80009ce4:	c0 c8       	rjmp	80009cfc <_vfprintf_r+0x1944>
80009ce6:	d7 03       	nop
80009ce8:	fa ca f9 78 	sub	r10,sp,-1672
80009cec:	02 9b       	mov	r11,r1
80009cee:	08 9c       	mov	r12,r4
80009cf0:	fe b0 f3 56 	rcall	8000839c <__sprint_r>
80009cf4:	e0 81 02 e1 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009cf8:	fa c3 f9 e0 	sub	r3,sp,-1568
80009cfc:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009d00:	40 6c       	lddsp	r12,sp[0x18]
80009d02:	18 38       	cp.w	r8,r12
80009d04:	c0 55       	brlt	80009d0e <_vfprintf_r+0x1956>
80009d06:	ed b5 00 00 	bld	r5,0x0
80009d0a:	e0 81 02 6b 	brne	8000a1e0 <_vfprintf_r+0x1e28>
80009d0e:	fa f8 06 90 	ld.w	r8,sp[1680]
80009d12:	2f f8       	sub	r8,-1
80009d14:	40 cb       	lddsp	r11,sp[0x30]
80009d16:	fb 48 06 90 	st.w	sp[1680],r8
80009d1a:	30 19       	mov	r9,1
80009d1c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d20:	87 0b       	st.w	r3[0x0],r11
80009d22:	2f f8       	sub	r8,-1
80009d24:	87 19       	st.w	r3[0x4],r9
80009d26:	fb 48 06 8c 	st.w	sp[1676],r8
80009d2a:	58 78       	cp.w	r8,7
80009d2c:	e0 89 00 04 	brgt	80009d34 <_vfprintf_r+0x197c>
80009d30:	2f 83       	sub	r3,-8
80009d32:	c0 b8       	rjmp	80009d48 <_vfprintf_r+0x1990>
80009d34:	fa ca f9 78 	sub	r10,sp,-1672
80009d38:	02 9b       	mov	r11,r1
80009d3a:	08 9c       	mov	r12,r4
80009d3c:	fe b0 f3 30 	rcall	8000839c <__sprint_r>
80009d40:	e0 81 02 bb 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009d44:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d48:	40 66       	lddsp	r6,sp[0x18]
80009d4a:	20 16       	sub	r6,1
80009d4c:	58 06       	cp.w	r6,0
80009d4e:	e0 89 00 1d 	brgt	80009d88 <_vfprintf_r+0x19d0>
80009d52:	e0 8f 02 47 	bral	8000a1e0 <_vfprintf_r+0x1e28>
80009d56:	2f 09       	sub	r9,-16
80009d58:	2f f8       	sub	r8,-1
80009d5a:	fb 49 06 90 	st.w	sp[1680],r9
80009d5e:	87 02       	st.w	r3[0x0],r2
80009d60:	87 10       	st.w	r3[0x4],r0
80009d62:	fb 48 06 8c 	st.w	sp[1676],r8
80009d66:	58 78       	cp.w	r8,7
80009d68:	e0 89 00 04 	brgt	80009d70 <_vfprintf_r+0x19b8>
80009d6c:	2f 83       	sub	r3,-8
80009d6e:	c0 b8       	rjmp	80009d84 <_vfprintf_r+0x19cc>
80009d70:	fa ca f9 78 	sub	r10,sp,-1672
80009d74:	02 9b       	mov	r11,r1
80009d76:	08 9c       	mov	r12,r4
80009d78:	fe b0 f3 12 	rcall	8000839c <__sprint_r>
80009d7c:	e0 81 02 9d 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009d80:	fa c3 f9 e0 	sub	r3,sp,-1568
80009d84:	21 06       	sub	r6,16
80009d86:	c0 48       	rjmp	80009d8e <_vfprintf_r+0x19d6>
80009d88:	fe c2 bb 0c 	sub	r2,pc,-17652
80009d8c:	31 00       	mov	r0,16
80009d8e:	fa f9 06 90 	ld.w	r9,sp[1680]
80009d92:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009d96:	fe ca bb 1a 	sub	r10,pc,-17638
80009d9a:	59 06       	cp.w	r6,16
80009d9c:	fe 99 ff dd 	brgt	80009d56 <_vfprintf_r+0x199e>
80009da0:	0c 09       	add	r9,r6
80009da2:	87 0a       	st.w	r3[0x0],r10
80009da4:	fb 49 06 90 	st.w	sp[1680],r9
80009da8:	2f f8       	sub	r8,-1
80009daa:	87 16       	st.w	r3[0x4],r6
80009dac:	c5 39       	rjmp	8000a052 <_vfprintf_r+0x1c9a>
80009dae:	fa fa 06 ac 	ld.w	r10,sp[1708]
80009db2:	58 0a       	cp.w	r10,0
80009db4:	e0 89 00 92 	brgt	80009ed8 <_vfprintf_r+0x1b20>
80009db8:	fa f8 06 90 	ld.w	r8,sp[1680]
80009dbc:	fe c9 bb 54 	sub	r9,pc,-17580
80009dc0:	2f f8       	sub	r8,-1
80009dc2:	87 09       	st.w	r3[0x0],r9
80009dc4:	fb 48 06 90 	st.w	sp[1680],r8
80009dc8:	30 19       	mov	r9,1
80009dca:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009dce:	87 19       	st.w	r3[0x4],r9
80009dd0:	2f f8       	sub	r8,-1
80009dd2:	fb 48 06 8c 	st.w	sp[1676],r8
80009dd6:	58 78       	cp.w	r8,7
80009dd8:	e0 89 00 04 	brgt	80009de0 <_vfprintf_r+0x1a28>
80009ddc:	2f 83       	sub	r3,-8
80009dde:	c0 b8       	rjmp	80009df4 <_vfprintf_r+0x1a3c>
80009de0:	fa ca f9 78 	sub	r10,sp,-1672
80009de4:	02 9b       	mov	r11,r1
80009de6:	08 9c       	mov	r12,r4
80009de8:	fe b0 f2 da 	rcall	8000839c <__sprint_r>
80009dec:	e0 81 02 65 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009df0:	fa c3 f9 e0 	sub	r3,sp,-1568
80009df4:	fa f8 06 ac 	ld.w	r8,sp[1708]
80009df8:	58 08       	cp.w	r8,0
80009dfa:	c0 81       	brne	80009e0a <_vfprintf_r+0x1a52>
80009dfc:	40 6a       	lddsp	r10,sp[0x18]
80009dfe:	58 0a       	cp.w	r10,0
80009e00:	c0 51       	brne	80009e0a <_vfprintf_r+0x1a52>
80009e02:	ed b5 00 00 	bld	r5,0x0
80009e06:	e0 81 01 ed 	brne	8000a1e0 <_vfprintf_r+0x1e28>
80009e0a:	40 c9       	lddsp	r9,sp[0x30]
80009e0c:	fa f8 06 90 	ld.w	r8,sp[1680]
80009e10:	2f f8       	sub	r8,-1
80009e12:	87 09       	st.w	r3[0x0],r9
80009e14:	fb 48 06 90 	st.w	sp[1680],r8
80009e18:	30 19       	mov	r9,1
80009e1a:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e1e:	87 19       	st.w	r3[0x4],r9
80009e20:	2f f8       	sub	r8,-1
80009e22:	fb 48 06 8c 	st.w	sp[1676],r8
80009e26:	58 78       	cp.w	r8,7
80009e28:	e0 89 00 04 	brgt	80009e30 <_vfprintf_r+0x1a78>
80009e2c:	2f 83       	sub	r3,-8
80009e2e:	c0 b8       	rjmp	80009e44 <_vfprintf_r+0x1a8c>
80009e30:	fa ca f9 78 	sub	r10,sp,-1672
80009e34:	02 9b       	mov	r11,r1
80009e36:	08 9c       	mov	r12,r4
80009e38:	fe b0 f2 b2 	rcall	8000839c <__sprint_r>
80009e3c:	e0 81 02 3d 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009e40:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e44:	fa f2 06 ac 	ld.w	r2,sp[1708]
80009e48:	5c 32       	neg	r2
80009e4a:	58 02       	cp.w	r2,0
80009e4c:	e0 89 00 1d 	brgt	80009e86 <_vfprintf_r+0x1ace>
80009e50:	c3 d8       	rjmp	80009eca <_vfprintf_r+0x1b12>
80009e52:	2f 09       	sub	r9,-16
80009e54:	2f f8       	sub	r8,-1
80009e56:	31 0e       	mov	lr,16
80009e58:	fb 49 06 90 	st.w	sp[1680],r9
80009e5c:	87 00       	st.w	r3[0x0],r0
80009e5e:	87 1e       	st.w	r3[0x4],lr
80009e60:	fb 48 06 8c 	st.w	sp[1676],r8
80009e64:	58 78       	cp.w	r8,7
80009e66:	e0 89 00 04 	brgt	80009e6e <_vfprintf_r+0x1ab6>
80009e6a:	2f 83       	sub	r3,-8
80009e6c:	c0 b8       	rjmp	80009e82 <_vfprintf_r+0x1aca>
80009e6e:	fa ca f9 78 	sub	r10,sp,-1672
80009e72:	02 9b       	mov	r11,r1
80009e74:	08 9c       	mov	r12,r4
80009e76:	fe b0 f2 93 	rcall	8000839c <__sprint_r>
80009e7a:	e0 81 02 1e 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009e7e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009e82:	21 02       	sub	r2,16
80009e84:	c0 38       	rjmp	80009e8a <_vfprintf_r+0x1ad2>
80009e86:	fe c0 bc 0a 	sub	r0,pc,-17398
80009e8a:	fa f9 06 90 	ld.w	r9,sp[1680]
80009e8e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009e92:	fe ca bc 16 	sub	r10,pc,-17386
80009e96:	59 02       	cp.w	r2,16
80009e98:	fe 99 ff dd 	brgt	80009e52 <_vfprintf_r+0x1a9a>
80009e9c:	04 09       	add	r9,r2
80009e9e:	2f f8       	sub	r8,-1
80009ea0:	87 0a       	st.w	r3[0x0],r10
80009ea2:	fb 49 06 90 	st.w	sp[1680],r9
80009ea6:	87 12       	st.w	r3[0x4],r2
80009ea8:	fb 48 06 8c 	st.w	sp[1676],r8
80009eac:	58 78       	cp.w	r8,7
80009eae:	e0 89 00 04 	brgt	80009eb6 <_vfprintf_r+0x1afe>
80009eb2:	2f 83       	sub	r3,-8
80009eb4:	c0 b8       	rjmp	80009eca <_vfprintf_r+0x1b12>
80009eb6:	fa ca f9 78 	sub	r10,sp,-1672
80009eba:	02 9b       	mov	r11,r1
80009ebc:	08 9c       	mov	r12,r4
80009ebe:	fe b0 f2 6f 	rcall	8000839c <__sprint_r>
80009ec2:	e0 81 01 fa 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009ec6:	fa c3 f9 e0 	sub	r3,sp,-1568
80009eca:	40 6c       	lddsp	r12,sp[0x18]
80009ecc:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ed0:	87 06       	st.w	r3[0x0],r6
80009ed2:	87 1c       	st.w	r3[0x4],r12
80009ed4:	18 08       	add	r8,r12
80009ed6:	cb 98       	rjmp	8000a048 <_vfprintf_r+0x1c90>
80009ed8:	fa f9 06 90 	ld.w	r9,sp[1680]
80009edc:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009ee0:	40 6b       	lddsp	r11,sp[0x18]
80009ee2:	16 3a       	cp.w	r10,r11
80009ee4:	c6 f5       	brlt	80009fc2 <_vfprintf_r+0x1c0a>
80009ee6:	16 09       	add	r9,r11
80009ee8:	2f f8       	sub	r8,-1
80009eea:	87 06       	st.w	r3[0x0],r6
80009eec:	fb 49 06 90 	st.w	sp[1680],r9
80009ef0:	87 1b       	st.w	r3[0x4],r11
80009ef2:	fb 48 06 8c 	st.w	sp[1676],r8
80009ef6:	58 78       	cp.w	r8,7
80009ef8:	e0 89 00 04 	brgt	80009f00 <_vfprintf_r+0x1b48>
80009efc:	2f 83       	sub	r3,-8
80009efe:	c0 b8       	rjmp	80009f14 <_vfprintf_r+0x1b5c>
80009f00:	fa ca f9 78 	sub	r10,sp,-1672
80009f04:	02 9b       	mov	r11,r1
80009f06:	08 9c       	mov	r12,r4
80009f08:	fe b0 f2 4a 	rcall	8000839c <__sprint_r>
80009f0c:	e0 81 01 d5 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009f10:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f14:	fa f6 06 ac 	ld.w	r6,sp[1708]
80009f18:	40 6a       	lddsp	r10,sp[0x18]
80009f1a:	14 16       	sub	r6,r10
80009f1c:	58 06       	cp.w	r6,0
80009f1e:	e0 89 00 1c 	brgt	80009f56 <_vfprintf_r+0x1b9e>
80009f22:	c3 d8       	rjmp	80009f9c <_vfprintf_r+0x1be4>
80009f24:	2f 09       	sub	r9,-16
80009f26:	2f f8       	sub	r8,-1
80009f28:	fb 49 06 90 	st.w	sp[1680],r9
80009f2c:	87 02       	st.w	r3[0x0],r2
80009f2e:	87 10       	st.w	r3[0x4],r0
80009f30:	fb 48 06 8c 	st.w	sp[1676],r8
80009f34:	58 78       	cp.w	r8,7
80009f36:	e0 89 00 04 	brgt	80009f3e <_vfprintf_r+0x1b86>
80009f3a:	2f 83       	sub	r3,-8
80009f3c:	c0 b8       	rjmp	80009f52 <_vfprintf_r+0x1b9a>
80009f3e:	fa ca f9 78 	sub	r10,sp,-1672
80009f42:	02 9b       	mov	r11,r1
80009f44:	08 9c       	mov	r12,r4
80009f46:	fe b0 f2 2b 	rcall	8000839c <__sprint_r>
80009f4a:	e0 81 01 b6 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009f4e:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f52:	21 06       	sub	r6,16
80009f54:	c0 48       	rjmp	80009f5c <_vfprintf_r+0x1ba4>
80009f56:	fe c2 bc da 	sub	r2,pc,-17190
80009f5a:	31 00       	mov	r0,16
80009f5c:	fa f9 06 90 	ld.w	r9,sp[1680]
80009f60:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009f64:	fe ca bc e8 	sub	r10,pc,-17176
80009f68:	59 06       	cp.w	r6,16
80009f6a:	fe 99 ff dd 	brgt	80009f24 <_vfprintf_r+0x1b6c>
80009f6e:	0c 09       	add	r9,r6
80009f70:	2f f8       	sub	r8,-1
80009f72:	87 0a       	st.w	r3[0x0],r10
80009f74:	fb 49 06 90 	st.w	sp[1680],r9
80009f78:	87 16       	st.w	r3[0x4],r6
80009f7a:	fb 48 06 8c 	st.w	sp[1676],r8
80009f7e:	58 78       	cp.w	r8,7
80009f80:	e0 89 00 04 	brgt	80009f88 <_vfprintf_r+0x1bd0>
80009f84:	2f 83       	sub	r3,-8
80009f86:	c0 b8       	rjmp	80009f9c <_vfprintf_r+0x1be4>
80009f88:	fa ca f9 78 	sub	r10,sp,-1672
80009f8c:	02 9b       	mov	r11,r1
80009f8e:	08 9c       	mov	r12,r4
80009f90:	fe b0 f2 06 	rcall	8000839c <__sprint_r>
80009f94:	e0 81 01 91 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009f98:	fa c3 f9 e0 	sub	r3,sp,-1568
80009f9c:	ed b5 00 00 	bld	r5,0x0
80009fa0:	e0 81 01 20 	brne	8000a1e0 <_vfprintf_r+0x1e28>
80009fa4:	40 c9       	lddsp	r9,sp[0x30]
80009fa6:	fa f8 06 90 	ld.w	r8,sp[1680]
80009faa:	2f f8       	sub	r8,-1
80009fac:	87 09       	st.w	r3[0x0],r9
80009fae:	fb 48 06 90 	st.w	sp[1680],r8
80009fb2:	30 19       	mov	r9,1
80009fb4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80009fb8:	87 19       	st.w	r3[0x4],r9
80009fba:	2f f8       	sub	r8,-1
80009fbc:	fb 48 06 8c 	st.w	sp[1676],r8
80009fc0:	c0 29       	rjmp	8000a1c4 <_vfprintf_r+0x1e0c>
80009fc2:	14 09       	add	r9,r10
80009fc4:	2f f8       	sub	r8,-1
80009fc6:	fb 49 06 90 	st.w	sp[1680],r9
80009fca:	87 06       	st.w	r3[0x0],r6
80009fcc:	87 1a       	st.w	r3[0x4],r10
80009fce:	fb 48 06 8c 	st.w	sp[1676],r8
80009fd2:	58 78       	cp.w	r8,7
80009fd4:	e0 89 00 04 	brgt	80009fdc <_vfprintf_r+0x1c24>
80009fd8:	2f 83       	sub	r3,-8
80009fda:	c0 b8       	rjmp	80009ff0 <_vfprintf_r+0x1c38>
80009fdc:	fa ca f9 78 	sub	r10,sp,-1672
80009fe0:	02 9b       	mov	r11,r1
80009fe2:	08 9c       	mov	r12,r4
80009fe4:	fe b0 f1 dc 	rcall	8000839c <__sprint_r>
80009fe8:	e0 81 01 67 	brne	8000a2b6 <_vfprintf_r+0x1efe>
80009fec:	fa c3 f9 e0 	sub	r3,sp,-1568
80009ff0:	40 c8       	lddsp	r8,sp[0x30]
80009ff2:	87 08       	st.w	r3[0x0],r8
80009ff4:	fa f8 06 90 	ld.w	r8,sp[1680]
80009ff8:	2f f8       	sub	r8,-1
80009ffa:	30 19       	mov	r9,1
80009ffc:	fb 48 06 90 	st.w	sp[1680],r8
8000a000:	87 19       	st.w	r3[0x4],r9
8000a002:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a006:	2f f8       	sub	r8,-1
8000a008:	fb 48 06 8c 	st.w	sp[1676],r8
8000a00c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000a010:	58 78       	cp.w	r8,7
8000a012:	e0 89 00 04 	brgt	8000a01a <_vfprintf_r+0x1c62>
8000a016:	2f 83       	sub	r3,-8
8000a018:	c0 b8       	rjmp	8000a02e <_vfprintf_r+0x1c76>
8000a01a:	fa ca f9 78 	sub	r10,sp,-1672
8000a01e:	02 9b       	mov	r11,r1
8000a020:	08 9c       	mov	r12,r4
8000a022:	fe b0 f1 bd 	rcall	8000839c <__sprint_r>
8000a026:	e0 81 01 48 	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000a02a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a02e:	04 06       	add	r6,r2
8000a030:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000a034:	87 06       	st.w	r3[0x0],r6
8000a036:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a03a:	40 66       	lddsp	r6,sp[0x18]
8000a03c:	40 6e       	lddsp	lr,sp[0x18]
8000a03e:	10 16       	sub	r6,r8
8000a040:	f2 08 01 08 	sub	r8,r9,r8
8000a044:	87 16       	st.w	r3[0x4],r6
8000a046:	1c 08       	add	r8,lr
8000a048:	fb 48 06 90 	st.w	sp[1680],r8
8000a04c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a050:	2f f8       	sub	r8,-1
8000a052:	fb 48 06 8c 	st.w	sp[1676],r8
8000a056:	cb 78       	rjmp	8000a1c4 <_vfprintf_r+0x1e0c>
8000a058:	40 6c       	lddsp	r12,sp[0x18]
8000a05a:	58 1c       	cp.w	r12,1
8000a05c:	e0 89 00 06 	brgt	8000a068 <_vfprintf_r+0x1cb0>
8000a060:	ed b5 00 00 	bld	r5,0x0
8000a064:	e0 81 00 85 	brne	8000a16e <_vfprintf_r+0x1db6>
8000a068:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a06c:	2f f8       	sub	r8,-1
8000a06e:	30 19       	mov	r9,1
8000a070:	fb 48 06 90 	st.w	sp[1680],r8
8000a074:	87 06       	st.w	r3[0x0],r6
8000a076:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a07a:	87 19       	st.w	r3[0x4],r9
8000a07c:	2f f8       	sub	r8,-1
8000a07e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a082:	58 78       	cp.w	r8,7
8000a084:	e0 89 00 04 	brgt	8000a08c <_vfprintf_r+0x1cd4>
8000a088:	2f 83       	sub	r3,-8
8000a08a:	c0 b8       	rjmp	8000a0a0 <_vfprintf_r+0x1ce8>
8000a08c:	fa ca f9 78 	sub	r10,sp,-1672
8000a090:	02 9b       	mov	r11,r1
8000a092:	08 9c       	mov	r12,r4
8000a094:	fe b0 f1 84 	rcall	8000839c <__sprint_r>
8000a098:	e0 81 01 0f 	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000a09c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0a0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a0a4:	2f f8       	sub	r8,-1
8000a0a6:	40 cb       	lddsp	r11,sp[0x30]
8000a0a8:	fb 48 06 90 	st.w	sp[1680],r8
8000a0ac:	30 19       	mov	r9,1
8000a0ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a0b2:	87 0b       	st.w	r3[0x0],r11
8000a0b4:	2f f8       	sub	r8,-1
8000a0b6:	87 19       	st.w	r3[0x4],r9
8000a0b8:	fb 48 06 8c 	st.w	sp[1676],r8
8000a0bc:	58 78       	cp.w	r8,7
8000a0be:	e0 89 00 05 	brgt	8000a0c8 <_vfprintf_r+0x1d10>
8000a0c2:	2f 83       	sub	r3,-8
8000a0c4:	c0 c8       	rjmp	8000a0dc <_vfprintf_r+0x1d24>
8000a0c6:	d7 03       	nop
8000a0c8:	fa ca f9 78 	sub	r10,sp,-1672
8000a0cc:	02 9b       	mov	r11,r1
8000a0ce:	08 9c       	mov	r12,r4
8000a0d0:	fe b0 f1 66 	rcall	8000839c <__sprint_r>
8000a0d4:	e0 81 00 f1 	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000a0d8:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a0dc:	30 08       	mov	r8,0
8000a0de:	30 09       	mov	r9,0
8000a0e0:	40 5b       	lddsp	r11,sp[0x14]
8000a0e2:	40 7a       	lddsp	r10,sp[0x1c]
8000a0e4:	e0 a0 13 25 	rcall	8000c72e <__avr32_f64_cmp_eq>
8000a0e8:	40 68       	lddsp	r8,sp[0x18]
8000a0ea:	20 18       	sub	r8,1
8000a0ec:	58 0c       	cp.w	r12,0
8000a0ee:	c0 d1       	brne	8000a108 <_vfprintf_r+0x1d50>
8000a0f0:	2f f6       	sub	r6,-1
8000a0f2:	87 18       	st.w	r3[0x4],r8
8000a0f4:	87 06       	st.w	r3[0x0],r6
8000a0f6:	fa f6 06 90 	ld.w	r6,sp[1680]
8000a0fa:	10 06       	add	r6,r8
8000a0fc:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a100:	fb 46 06 90 	st.w	sp[1680],r6
8000a104:	2f f8       	sub	r8,-1
8000a106:	c3 18       	rjmp	8000a168 <_vfprintf_r+0x1db0>
8000a108:	10 96       	mov	r6,r8
8000a10a:	58 08       	cp.w	r8,0
8000a10c:	e0 89 00 1c 	brgt	8000a144 <_vfprintf_r+0x1d8c>
8000a110:	c4 b8       	rjmp	8000a1a6 <_vfprintf_r+0x1dee>
8000a112:	2f 09       	sub	r9,-16
8000a114:	2f f8       	sub	r8,-1
8000a116:	fb 49 06 90 	st.w	sp[1680],r9
8000a11a:	87 02       	st.w	r3[0x0],r2
8000a11c:	87 10       	st.w	r3[0x4],r0
8000a11e:	fb 48 06 8c 	st.w	sp[1676],r8
8000a122:	58 78       	cp.w	r8,7
8000a124:	e0 89 00 04 	brgt	8000a12c <_vfprintf_r+0x1d74>
8000a128:	2f 83       	sub	r3,-8
8000a12a:	c0 b8       	rjmp	8000a140 <_vfprintf_r+0x1d88>
8000a12c:	fa ca f9 78 	sub	r10,sp,-1672
8000a130:	02 9b       	mov	r11,r1
8000a132:	08 9c       	mov	r12,r4
8000a134:	fe b0 f1 34 	rcall	8000839c <__sprint_r>
8000a138:	e0 81 00 bf 	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000a13c:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a140:	21 06       	sub	r6,16
8000a142:	c0 48       	rjmp	8000a14a <_vfprintf_r+0x1d92>
8000a144:	fe c2 be c8 	sub	r2,pc,-16696
8000a148:	31 00       	mov	r0,16
8000a14a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a14e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a152:	fe ca be d6 	sub	r10,pc,-16682
8000a156:	59 06       	cp.w	r6,16
8000a158:	fe 99 ff dd 	brgt	8000a112 <_vfprintf_r+0x1d5a>
8000a15c:	0c 09       	add	r9,r6
8000a15e:	87 0a       	st.w	r3[0x0],r10
8000a160:	fb 49 06 90 	st.w	sp[1680],r9
8000a164:	2f f8       	sub	r8,-1
8000a166:	87 16       	st.w	r3[0x4],r6
8000a168:	fb 48 06 8c 	st.w	sp[1676],r8
8000a16c:	c0 e8       	rjmp	8000a188 <_vfprintf_r+0x1dd0>
8000a16e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a172:	2f f8       	sub	r8,-1
8000a174:	30 19       	mov	r9,1
8000a176:	fb 48 06 90 	st.w	sp[1680],r8
8000a17a:	87 06       	st.w	r3[0x0],r6
8000a17c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a180:	87 19       	st.w	r3[0x4],r9
8000a182:	2f f8       	sub	r8,-1
8000a184:	fb 48 06 8c 	st.w	sp[1676],r8
8000a188:	58 78       	cp.w	r8,7
8000a18a:	e0 89 00 04 	brgt	8000a192 <_vfprintf_r+0x1dda>
8000a18e:	2f 83       	sub	r3,-8
8000a190:	c0 b8       	rjmp	8000a1a6 <_vfprintf_r+0x1dee>
8000a192:	fa ca f9 78 	sub	r10,sp,-1672
8000a196:	02 9b       	mov	r11,r1
8000a198:	08 9c       	mov	r12,r4
8000a19a:	fe b0 f1 01 	rcall	8000839c <__sprint_r>
8000a19e:	e0 81 00 8c 	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000a1a2:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1a6:	40 ea       	lddsp	r10,sp[0x38]
8000a1a8:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a1ac:	14 08       	add	r8,r10
8000a1ae:	fa c9 f9 64 	sub	r9,sp,-1692
8000a1b2:	fb 48 06 90 	st.w	sp[1680],r8
8000a1b6:	87 1a       	st.w	r3[0x4],r10
8000a1b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a1bc:	87 09       	st.w	r3[0x0],r9
8000a1be:	2f f8       	sub	r8,-1
8000a1c0:	fb 48 06 8c 	st.w	sp[1676],r8
8000a1c4:	58 78       	cp.w	r8,7
8000a1c6:	e0 89 00 04 	brgt	8000a1ce <_vfprintf_r+0x1e16>
8000a1ca:	2f 83       	sub	r3,-8
8000a1cc:	c0 a8       	rjmp	8000a1e0 <_vfprintf_r+0x1e28>
8000a1ce:	fa ca f9 78 	sub	r10,sp,-1672
8000a1d2:	02 9b       	mov	r11,r1
8000a1d4:	08 9c       	mov	r12,r4
8000a1d6:	fe b0 f0 e3 	rcall	8000839c <__sprint_r>
8000a1da:	c6 e1       	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000a1dc:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a1e0:	e2 15 00 04 	andl	r5,0x4,COH
8000a1e4:	c3 f0       	breq	8000a262 <_vfprintf_r+0x1eaa>
8000a1e6:	40 86       	lddsp	r6,sp[0x20]
8000a1e8:	40 39       	lddsp	r9,sp[0xc]
8000a1ea:	12 16       	sub	r6,r9
8000a1ec:	58 06       	cp.w	r6,0
8000a1ee:	e0 89 00 1a 	brgt	8000a222 <_vfprintf_r+0x1e6a>
8000a1f2:	c3 88       	rjmp	8000a262 <_vfprintf_r+0x1eaa>
8000a1f4:	2f 09       	sub	r9,-16
8000a1f6:	2f f8       	sub	r8,-1
8000a1f8:	fb 49 06 90 	st.w	sp[1680],r9
8000a1fc:	87 05       	st.w	r3[0x0],r5
8000a1fe:	87 12       	st.w	r3[0x4],r2
8000a200:	fb 48 06 8c 	st.w	sp[1676],r8
8000a204:	58 78       	cp.w	r8,7
8000a206:	e0 89 00 04 	brgt	8000a20e <_vfprintf_r+0x1e56>
8000a20a:	2f 83       	sub	r3,-8
8000a20c:	c0 98       	rjmp	8000a21e <_vfprintf_r+0x1e66>
8000a20e:	00 9a       	mov	r10,r0
8000a210:	02 9b       	mov	r11,r1
8000a212:	08 9c       	mov	r12,r4
8000a214:	fe b0 f0 c4 	rcall	8000839c <__sprint_r>
8000a218:	c4 f1       	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000a21a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a21e:	21 06       	sub	r6,16
8000a220:	c0 68       	rjmp	8000a22c <_vfprintf_r+0x1e74>
8000a222:	fe c5 bf b6 	sub	r5,pc,-16458
8000a226:	31 02       	mov	r2,16
8000a228:	fa c0 f9 78 	sub	r0,sp,-1672
8000a22c:	fa f9 06 90 	ld.w	r9,sp[1680]
8000a230:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000a234:	fe ca bf c8 	sub	r10,pc,-16440
8000a238:	59 06       	cp.w	r6,16
8000a23a:	fe 99 ff dd 	brgt	8000a1f4 <_vfprintf_r+0x1e3c>
8000a23e:	0c 09       	add	r9,r6
8000a240:	2f f8       	sub	r8,-1
8000a242:	87 0a       	st.w	r3[0x0],r10
8000a244:	87 16       	st.w	r3[0x4],r6
8000a246:	fb 49 06 90 	st.w	sp[1680],r9
8000a24a:	fb 48 06 8c 	st.w	sp[1676],r8
8000a24e:	58 78       	cp.w	r8,7
8000a250:	e0 8a 00 09 	brle	8000a262 <_vfprintf_r+0x1eaa>
8000a254:	fa ca f9 78 	sub	r10,sp,-1672
8000a258:	02 9b       	mov	r11,r1
8000a25a:	08 9c       	mov	r12,r4
8000a25c:	fe b0 f0 a0 	rcall	8000839c <__sprint_r>
8000a260:	c2 b1       	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000a262:	40 bc       	lddsp	r12,sp[0x2c]
8000a264:	40 36       	lddsp	r6,sp[0xc]
8000a266:	40 8e       	lddsp	lr,sp[0x20]
8000a268:	ec 0e 0c 48 	max	r8,r6,lr
8000a26c:	10 0c       	add	r12,r8
8000a26e:	50 bc       	stdsp	sp[0x2c],r12
8000a270:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a274:	58 08       	cp.w	r8,0
8000a276:	c0 80       	breq	8000a286 <_vfprintf_r+0x1ece>
8000a278:	fa ca f9 78 	sub	r10,sp,-1672
8000a27c:	02 9b       	mov	r11,r1
8000a27e:	08 9c       	mov	r12,r4
8000a280:	fe b0 f0 8e 	rcall	8000839c <__sprint_r>
8000a284:	c1 91       	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000a286:	30 0b       	mov	r11,0
8000a288:	fa c3 f9 e0 	sub	r3,sp,-1568
8000a28c:	fb 4b 06 8c 	st.w	sp[1676],r11
8000a290:	fe 9f f1 22 	bral	800084d4 <_vfprintf_r+0x11c>
8000a294:	08 95       	mov	r5,r4
8000a296:	fa f8 06 90 	ld.w	r8,sp[1680]
8000a29a:	58 08       	cp.w	r8,0
8000a29c:	c0 80       	breq	8000a2ac <_vfprintf_r+0x1ef4>
8000a29e:	08 9c       	mov	r12,r4
8000a2a0:	fa ca f9 78 	sub	r10,sp,-1672
8000a2a4:	02 9b       	mov	r11,r1
8000a2a6:	fe b0 f0 7b 	rcall	8000839c <__sprint_r>
8000a2aa:	c0 61       	brne	8000a2b6 <_vfprintf_r+0x1efe>
8000a2ac:	30 08       	mov	r8,0
8000a2ae:	fb 48 06 8c 	st.w	sp[1676],r8
8000a2b2:	c0 28       	rjmp	8000a2b6 <_vfprintf_r+0x1efe>
8000a2b4:	40 41       	lddsp	r1,sp[0x10]
8000a2b6:	82 68       	ld.sh	r8,r1[0xc]
8000a2b8:	ed b8 00 06 	bld	r8,0x6
8000a2bc:	c0 31       	brne	8000a2c2 <_vfprintf_r+0x1f0a>
8000a2be:	3f fa       	mov	r10,-1
8000a2c0:	50 ba       	stdsp	sp[0x2c],r10
8000a2c2:	40 bc       	lddsp	r12,sp[0x2c]
8000a2c4:	fe 3d f9 44 	sub	sp,-1724
8000a2c8:	d8 32       	popm	r0-r7,pc
8000a2ca:	d7 03       	nop

8000a2cc <__swsetup_r>:
8000a2cc:	d4 21       	pushm	r4-r7,lr
8000a2ce:	e0 68 0a 48 	mov	r8,2632
8000a2d2:	18 96       	mov	r6,r12
8000a2d4:	16 97       	mov	r7,r11
8000a2d6:	70 0c       	ld.w	r12,r8[0x0]
8000a2d8:	58 0c       	cp.w	r12,0
8000a2da:	c0 60       	breq	8000a2e6 <__swsetup_r+0x1a>
8000a2dc:	78 68       	ld.w	r8,r12[0x18]
8000a2de:	58 08       	cp.w	r8,0
8000a2e0:	c0 31       	brne	8000a2e6 <__swsetup_r+0x1a>
8000a2e2:	e0 a0 07 bf 	rcall	8000b260 <__sinit>
8000a2e6:	fe c8 bf 4a 	sub	r8,pc,-16566
8000a2ea:	10 37       	cp.w	r7,r8
8000a2ec:	c0 61       	brne	8000a2f8 <__swsetup_r+0x2c>
8000a2ee:	e0 68 0a 48 	mov	r8,2632
8000a2f2:	70 08       	ld.w	r8,r8[0x0]
8000a2f4:	70 07       	ld.w	r7,r8[0x0]
8000a2f6:	c1 28       	rjmp	8000a31a <__swsetup_r+0x4e>
8000a2f8:	fe c8 bf 3c 	sub	r8,pc,-16580
8000a2fc:	10 37       	cp.w	r7,r8
8000a2fe:	c0 61       	brne	8000a30a <__swsetup_r+0x3e>
8000a300:	e0 68 0a 48 	mov	r8,2632
8000a304:	70 08       	ld.w	r8,r8[0x0]
8000a306:	70 17       	ld.w	r7,r8[0x4]
8000a308:	c0 98       	rjmp	8000a31a <__swsetup_r+0x4e>
8000a30a:	fe c8 bf 2e 	sub	r8,pc,-16594
8000a30e:	10 37       	cp.w	r7,r8
8000a310:	c0 51       	brne	8000a31a <__swsetup_r+0x4e>
8000a312:	e0 68 0a 48 	mov	r8,2632
8000a316:	70 08       	ld.w	r8,r8[0x0]
8000a318:	70 27       	ld.w	r7,r8[0x8]
8000a31a:	8e 68       	ld.sh	r8,r7[0xc]
8000a31c:	ed b8 00 03 	bld	r8,0x3
8000a320:	c1 e0       	breq	8000a35c <__swsetup_r+0x90>
8000a322:	ed b8 00 04 	bld	r8,0x4
8000a326:	c3 e1       	brne	8000a3a2 <__swsetup_r+0xd6>
8000a328:	ed b8 00 02 	bld	r8,0x2
8000a32c:	c1 51       	brne	8000a356 <__swsetup_r+0x8a>
8000a32e:	6e db       	ld.w	r11,r7[0x34]
8000a330:	58 0b       	cp.w	r11,0
8000a332:	c0 a0       	breq	8000a346 <__swsetup_r+0x7a>
8000a334:	ee c8 ff bc 	sub	r8,r7,-68
8000a338:	10 3b       	cp.w	r11,r8
8000a33a:	c0 40       	breq	8000a342 <__swsetup_r+0x76>
8000a33c:	0c 9c       	mov	r12,r6
8000a33e:	e0 a0 08 2b 	rcall	8000b394 <_free_r>
8000a342:	30 08       	mov	r8,0
8000a344:	8f d8       	st.w	r7[0x34],r8
8000a346:	8e 68       	ld.sh	r8,r7[0xc]
8000a348:	e0 18 ff db 	andl	r8,0xffdb
8000a34c:	ae 68       	st.h	r7[0xc],r8
8000a34e:	30 08       	mov	r8,0
8000a350:	8f 18       	st.w	r7[0x4],r8
8000a352:	6e 48       	ld.w	r8,r7[0x10]
8000a354:	8f 08       	st.w	r7[0x0],r8
8000a356:	8e 68       	ld.sh	r8,r7[0xc]
8000a358:	a3 b8       	sbr	r8,0x3
8000a35a:	ae 68       	st.h	r7[0xc],r8
8000a35c:	6e 48       	ld.w	r8,r7[0x10]
8000a35e:	58 08       	cp.w	r8,0
8000a360:	c0 b1       	brne	8000a376 <__swsetup_r+0xaa>
8000a362:	8e 68       	ld.sh	r8,r7[0xc]
8000a364:	e2 18 02 80 	andl	r8,0x280,COH
8000a368:	e0 48 02 00 	cp.w	r8,512
8000a36c:	c0 50       	breq	8000a376 <__swsetup_r+0xaa>
8000a36e:	0c 9c       	mov	r12,r6
8000a370:	0e 9b       	mov	r11,r7
8000a372:	e0 a0 0a 4b 	rcall	8000b808 <__smakebuf_r>
8000a376:	8e 69       	ld.sh	r9,r7[0xc]
8000a378:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000a37c:	c0 70       	breq	8000a38a <__swsetup_r+0xbe>
8000a37e:	30 08       	mov	r8,0
8000a380:	8f 28       	st.w	r7[0x8],r8
8000a382:	6e 58       	ld.w	r8,r7[0x14]
8000a384:	5c 38       	neg	r8
8000a386:	8f 68       	st.w	r7[0x18],r8
8000a388:	c0 68       	rjmp	8000a394 <__swsetup_r+0xc8>
8000a38a:	ed b9 00 01 	bld	r9,0x1
8000a38e:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000a392:	8f 28       	st.w	r7[0x8],r8
8000a394:	6e 48       	ld.w	r8,r7[0x10]
8000a396:	58 08       	cp.w	r8,0
8000a398:	c0 61       	brne	8000a3a4 <__swsetup_r+0xd8>
8000a39a:	8e 68       	ld.sh	r8,r7[0xc]
8000a39c:	ed b8 00 07 	bld	r8,0x7
8000a3a0:	c0 21       	brne	8000a3a4 <__swsetup_r+0xd8>
8000a3a2:	dc 2a       	popm	r4-r7,pc,r12=-1
8000a3a4:	d8 2a       	popm	r4-r7,pc,r12=0
8000a3a6:	d7 03       	nop

8000a3a8 <quorem>:
8000a3a8:	d4 31       	pushm	r0-r7,lr
8000a3aa:	20 2d       	sub	sp,8
8000a3ac:	18 97       	mov	r7,r12
8000a3ae:	78 48       	ld.w	r8,r12[0x10]
8000a3b0:	76 46       	ld.w	r6,r11[0x10]
8000a3b2:	0c 38       	cp.w	r8,r6
8000a3b4:	c0 34       	brge	8000a3ba <quorem+0x12>
8000a3b6:	30 0c       	mov	r12,0
8000a3b8:	c8 58       	rjmp	8000a4c2 <quorem+0x11a>
8000a3ba:	ec c2 ff fc 	sub	r2,r6,-4
8000a3be:	f6 c3 ff ec 	sub	r3,r11,-20
8000a3c2:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000a3c6:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000a3ca:	2f f9       	sub	r9,-1
8000a3cc:	20 16       	sub	r6,1
8000a3ce:	f8 09 0d 08 	divu	r8,r12,r9
8000a3d2:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000a3d6:	ee c4 ff ec 	sub	r4,r7,-20
8000a3da:	10 95       	mov	r5,r8
8000a3dc:	58 08       	cp.w	r8,0
8000a3de:	c4 10       	breq	8000a460 <quorem+0xb8>
8000a3e0:	30 09       	mov	r9,0
8000a3e2:	06 9a       	mov	r10,r3
8000a3e4:	08 98       	mov	r8,r4
8000a3e6:	12 91       	mov	r1,r9
8000a3e8:	50 0b       	stdsp	sp[0x0],r11
8000a3ea:	70 0e       	ld.w	lr,r8[0x0]
8000a3ec:	b1 8e       	lsr	lr,0x10
8000a3ee:	50 1e       	stdsp	sp[0x4],lr
8000a3f0:	15 0e       	ld.w	lr,r10++
8000a3f2:	fc 00 16 10 	lsr	r0,lr,0x10
8000a3f6:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a3fa:	ea 0e 03 41 	mac	r1,r5,lr
8000a3fe:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000a402:	b1 81       	lsr	r1,0x10
8000a404:	40 1b       	lddsp	r11,sp[0x4]
8000a406:	ea 00 02 40 	mul	r0,r5,r0
8000a40a:	e2 00 00 00 	add	r0,r1,r0
8000a40e:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000a412:	02 1b       	sub	r11,r1
8000a414:	50 1b       	stdsp	sp[0x4],r11
8000a416:	70 0b       	ld.w	r11,r8[0x0]
8000a418:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000a41c:	02 09       	add	r9,r1
8000a41e:	f2 0e 01 0e 	sub	lr,r9,lr
8000a422:	b0 1e       	st.h	r8[0x2],lr
8000a424:	fc 09 14 10 	asr	r9,lr,0x10
8000a428:	40 1e       	lddsp	lr,sp[0x4]
8000a42a:	fc 09 00 09 	add	r9,lr,r9
8000a42e:	b0 09       	st.h	r8[0x0],r9
8000a430:	e0 01 16 10 	lsr	r1,r0,0x10
8000a434:	2f c8       	sub	r8,-4
8000a436:	b1 49       	asr	r9,0x10
8000a438:	04 3a       	cp.w	r10,r2
8000a43a:	fe 98 ff d8 	brls	8000a3ea <quorem+0x42>
8000a43e:	40 0b       	lddsp	r11,sp[0x0]
8000a440:	58 0c       	cp.w	r12,0
8000a442:	c0 f1       	brne	8000a460 <quorem+0xb8>
8000a444:	ec c8 ff fb 	sub	r8,r6,-5
8000a448:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a44c:	c0 28       	rjmp	8000a450 <quorem+0xa8>
8000a44e:	20 16       	sub	r6,1
8000a450:	20 48       	sub	r8,4
8000a452:	08 38       	cp.w	r8,r4
8000a454:	e0 88 00 05 	brls	8000a45e <quorem+0xb6>
8000a458:	70 09       	ld.w	r9,r8[0x0]
8000a45a:	58 09       	cp.w	r9,0
8000a45c:	cf 90       	breq	8000a44e <quorem+0xa6>
8000a45e:	8f 46       	st.w	r7[0x10],r6
8000a460:	0e 9c       	mov	r12,r7
8000a462:	e0 a0 0a d2 	rcall	8000ba06 <__mcmp>
8000a466:	c2 d5       	brlt	8000a4c0 <quorem+0x118>
8000a468:	2f f5       	sub	r5,-1
8000a46a:	08 98       	mov	r8,r4
8000a46c:	30 09       	mov	r9,0
8000a46e:	07 0b       	ld.w	r11,r3++
8000a470:	f6 0a 16 10 	lsr	r10,r11,0x10
8000a474:	70 0c       	ld.w	r12,r8[0x0]
8000a476:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a47a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000a47e:	14 1e       	sub	lr,r10
8000a480:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000a484:	16 1a       	sub	r10,r11
8000a486:	12 0a       	add	r10,r9
8000a488:	b0 1a       	st.h	r8[0x2],r10
8000a48a:	b1 4a       	asr	r10,0x10
8000a48c:	fc 0a 00 09 	add	r9,lr,r10
8000a490:	b0 09       	st.h	r8[0x0],r9
8000a492:	2f c8       	sub	r8,-4
8000a494:	b1 49       	asr	r9,0x10
8000a496:	04 33       	cp.w	r3,r2
8000a498:	fe 98 ff eb 	brls	8000a46e <quorem+0xc6>
8000a49c:	ec c8 ff fb 	sub	r8,r6,-5
8000a4a0:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000a4a4:	58 09       	cp.w	r9,0
8000a4a6:	c0 d1       	brne	8000a4c0 <quorem+0x118>
8000a4a8:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000a4ac:	c0 28       	rjmp	8000a4b0 <quorem+0x108>
8000a4ae:	20 16       	sub	r6,1
8000a4b0:	20 48       	sub	r8,4
8000a4b2:	08 38       	cp.w	r8,r4
8000a4b4:	e0 88 00 05 	brls	8000a4be <quorem+0x116>
8000a4b8:	70 09       	ld.w	r9,r8[0x0]
8000a4ba:	58 09       	cp.w	r9,0
8000a4bc:	cf 90       	breq	8000a4ae <quorem+0x106>
8000a4be:	8f 46       	st.w	r7[0x10],r6
8000a4c0:	0a 9c       	mov	r12,r5
8000a4c2:	2f ed       	sub	sp,-8
8000a4c4:	d8 32       	popm	r0-r7,pc
8000a4c6:	d7 03       	nop

8000a4c8 <_dtoa_r>:
8000a4c8:	d4 31       	pushm	r0-r7,lr
8000a4ca:	21 ad       	sub	sp,104
8000a4cc:	fa c4 ff 74 	sub	r4,sp,-140
8000a4d0:	18 97       	mov	r7,r12
8000a4d2:	16 95       	mov	r5,r11
8000a4d4:	68 2c       	ld.w	r12,r4[0x8]
8000a4d6:	50 c9       	stdsp	sp[0x30],r9
8000a4d8:	68 16       	ld.w	r6,r4[0x4]
8000a4da:	68 09       	ld.w	r9,r4[0x0]
8000a4dc:	50 e8       	stdsp	sp[0x38],r8
8000a4de:	14 94       	mov	r4,r10
8000a4e0:	51 2c       	stdsp	sp[0x48],r12
8000a4e2:	fa e5 00 08 	st.d	sp[8],r4
8000a4e6:	51 59       	stdsp	sp[0x54],r9
8000a4e8:	6e 95       	ld.w	r5,r7[0x24]
8000a4ea:	58 05       	cp.w	r5,0
8000a4ec:	c0 91       	brne	8000a4fe <_dtoa_r+0x36>
8000a4ee:	31 0c       	mov	r12,16
8000a4f0:	fe b0 e8 e2 	rcall	800076b4 <malloc>
8000a4f4:	99 35       	st.w	r12[0xc],r5
8000a4f6:	8f 9c       	st.w	r7[0x24],r12
8000a4f8:	99 15       	st.w	r12[0x4],r5
8000a4fa:	99 25       	st.w	r12[0x8],r5
8000a4fc:	99 05       	st.w	r12[0x0],r5
8000a4fe:	6e 99       	ld.w	r9,r7[0x24]
8000a500:	72 08       	ld.w	r8,r9[0x0]
8000a502:	58 08       	cp.w	r8,0
8000a504:	c0 f0       	breq	8000a522 <_dtoa_r+0x5a>
8000a506:	72 1a       	ld.w	r10,r9[0x4]
8000a508:	91 1a       	st.w	r8[0x4],r10
8000a50a:	30 1a       	mov	r10,1
8000a50c:	72 19       	ld.w	r9,r9[0x4]
8000a50e:	f4 09 09 49 	lsl	r9,r10,r9
8000a512:	10 9b       	mov	r11,r8
8000a514:	91 29       	st.w	r8[0x8],r9
8000a516:	0e 9c       	mov	r12,r7
8000a518:	e0 a0 0a 90 	rcall	8000ba38 <_Bfree>
8000a51c:	6e 98       	ld.w	r8,r7[0x24]
8000a51e:	30 09       	mov	r9,0
8000a520:	91 09       	st.w	r8[0x0],r9
8000a522:	40 28       	lddsp	r8,sp[0x8]
8000a524:	10 94       	mov	r4,r8
8000a526:	58 08       	cp.w	r8,0
8000a528:	c0 64       	brge	8000a534 <_dtoa_r+0x6c>
8000a52a:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000a52e:	50 28       	stdsp	sp[0x8],r8
8000a530:	30 18       	mov	r8,1
8000a532:	c0 28       	rjmp	8000a536 <_dtoa_r+0x6e>
8000a534:	30 08       	mov	r8,0
8000a536:	8d 08       	st.w	r6[0x0],r8
8000a538:	fc 1c 7f f0 	movh	r12,0x7ff0
8000a53c:	40 26       	lddsp	r6,sp[0x8]
8000a53e:	0c 98       	mov	r8,r6
8000a540:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000a544:	18 38       	cp.w	r8,r12
8000a546:	c2 01       	brne	8000a586 <_dtoa_r+0xbe>
8000a548:	e0 68 27 0f 	mov	r8,9999
8000a54c:	41 5b       	lddsp	r11,sp[0x54]
8000a54e:	97 08       	st.w	r11[0x0],r8
8000a550:	40 3a       	lddsp	r10,sp[0xc]
8000a552:	58 0a       	cp.w	r10,0
8000a554:	c0 71       	brne	8000a562 <_dtoa_r+0x9a>
8000a556:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000a55a:	c0 41       	brne	8000a562 <_dtoa_r+0x9a>
8000a55c:	fe cc c1 d0 	sub	r12,pc,-15920
8000a560:	c0 38       	rjmp	8000a566 <_dtoa_r+0x9e>
8000a562:	fe cc c1 ca 	sub	r12,pc,-15926
8000a566:	41 29       	lddsp	r9,sp[0x48]
8000a568:	58 09       	cp.w	r9,0
8000a56a:	e0 80 05 9a 	breq	8000b09e <_dtoa_r+0xbd6>
8000a56e:	f8 c8 ff fd 	sub	r8,r12,-3
8000a572:	f8 c9 ff f8 	sub	r9,r12,-8
8000a576:	11 8b       	ld.ub	r11,r8[0x0]
8000a578:	30 0a       	mov	r10,0
8000a57a:	41 25       	lddsp	r5,sp[0x48]
8000a57c:	f4 0b 18 00 	cp.b	r11,r10
8000a580:	f2 08 17 10 	movne	r8,r9
8000a584:	c1 68       	rjmp	8000a5b0 <_dtoa_r+0xe8>
8000a586:	fa ea 00 08 	ld.d	r10,sp[8]
8000a58a:	30 08       	mov	r8,0
8000a58c:	fa eb 00 3c 	st.d	sp[60],r10
8000a590:	30 09       	mov	r9,0
8000a592:	e0 a0 10 ce 	rcall	8000c72e <__avr32_f64_cmp_eq>
8000a596:	c1 00       	breq	8000a5b6 <_dtoa_r+0xee>
8000a598:	30 18       	mov	r8,1
8000a59a:	41 5a       	lddsp	r10,sp[0x54]
8000a59c:	95 08       	st.w	r10[0x0],r8
8000a59e:	fe cc c3 36 	sub	r12,pc,-15562
8000a5a2:	41 29       	lddsp	r9,sp[0x48]
8000a5a4:	f8 08 00 08 	add	r8,r12,r8
8000a5a8:	58 09       	cp.w	r9,0
8000a5aa:	e0 80 05 7a 	breq	8000b09e <_dtoa_r+0xbd6>
8000a5ae:	12 95       	mov	r5,r9
8000a5b0:	8b 08       	st.w	r5[0x0],r8
8000a5b2:	e0 8f 05 76 	bral	8000b09e <_dtoa_r+0xbd6>
8000a5b6:	fa c8 ff 9c 	sub	r8,sp,-100
8000a5ba:	fa c9 ff a0 	sub	r9,sp,-96
8000a5be:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5c2:	0e 9c       	mov	r12,r7
8000a5c4:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000a5c8:	e0 a0 0a 8a 	rcall	8000badc <__d2b>
8000a5cc:	18 93       	mov	r3,r12
8000a5ce:	58 05       	cp.w	r5,0
8000a5d0:	c0 d0       	breq	8000a5ea <_dtoa_r+0x122>
8000a5d2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a5d6:	30 04       	mov	r4,0
8000a5d8:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000a5dc:	ea c5 03 ff 	sub	r5,r5,1023
8000a5e0:	10 9b       	mov	r11,r8
8000a5e2:	51 74       	stdsp	sp[0x5c],r4
8000a5e4:	ea 1b 3f f0 	orh	r11,0x3ff0
8000a5e8:	c2 58       	rjmp	8000a632 <_dtoa_r+0x16a>
8000a5ea:	41 88       	lddsp	r8,sp[0x60]
8000a5ec:	41 9c       	lddsp	r12,sp[0x64]
8000a5ee:	10 0c       	add	r12,r8
8000a5f0:	f8 c5 fb ce 	sub	r5,r12,-1074
8000a5f4:	e0 45 00 20 	cp.w	r5,32
8000a5f8:	e0 8a 00 0e 	brle	8000a614 <_dtoa_r+0x14c>
8000a5fc:	f8 cc fb ee 	sub	r12,r12,-1042
8000a600:	40 3b       	lddsp	r11,sp[0xc]
8000a602:	ea 08 11 40 	rsub	r8,r5,64
8000a606:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000a60a:	ec 08 09 46 	lsl	r6,r6,r8
8000a60e:	0c 4c       	or	r12,r6
8000a610:	c0 78       	rjmp	8000a61e <_dtoa_r+0x156>
8000a612:	d7 03       	nop
8000a614:	ea 0c 11 20 	rsub	r12,r5,32
8000a618:	40 3a       	lddsp	r10,sp[0xc]
8000a61a:	f4 0c 09 4c 	lsl	r12,r10,r12
8000a61e:	e0 a0 10 14 	rcall	8000c646 <__avr32_u32_to_f64>
8000a622:	fc 18 fe 10 	movh	r8,0xfe10
8000a626:	30 19       	mov	r9,1
8000a628:	ea c5 04 33 	sub	r5,r5,1075
8000a62c:	f0 0b 00 0b 	add	r11,r8,r11
8000a630:	51 79       	stdsp	sp[0x5c],r9
8000a632:	30 08       	mov	r8,0
8000a634:	fc 19 3f f8 	movh	r9,0x3ff8
8000a638:	e0 a0 0e 9c 	rcall	8000c370 <__avr32_f64_sub>
8000a63c:	e0 68 43 61 	mov	r8,17249
8000a640:	ea 18 63 6f 	orh	r8,0x636f
8000a644:	e0 69 87 a7 	mov	r9,34727
8000a648:	ea 19 3f d2 	orh	r9,0x3fd2
8000a64c:	e0 a0 0d a6 	rcall	8000c198 <__avr32_f64_mul>
8000a650:	e0 68 c8 b3 	mov	r8,51379
8000a654:	ea 18 8b 60 	orh	r8,0x8b60
8000a658:	e0 69 8a 28 	mov	r9,35368
8000a65c:	ea 19 3f c6 	orh	r9,0x3fc6
8000a660:	e0 a0 0f 56 	rcall	8000c50c <__avr32_f64_add>
8000a664:	0a 9c       	mov	r12,r5
8000a666:	14 90       	mov	r0,r10
8000a668:	16 91       	mov	r1,r11
8000a66a:	e0 a0 0f f2 	rcall	8000c64e <__avr32_s32_to_f64>
8000a66e:	e0 68 79 fb 	mov	r8,31227
8000a672:	ea 18 50 9f 	orh	r8,0x509f
8000a676:	e0 69 44 13 	mov	r9,17427
8000a67a:	ea 19 3f d3 	orh	r9,0x3fd3
8000a67e:	e0 a0 0d 8d 	rcall	8000c198 <__avr32_f64_mul>
8000a682:	14 98       	mov	r8,r10
8000a684:	16 99       	mov	r9,r11
8000a686:	00 9a       	mov	r10,r0
8000a688:	02 9b       	mov	r11,r1
8000a68a:	e0 a0 0f 41 	rcall	8000c50c <__avr32_f64_add>
8000a68e:	14 90       	mov	r0,r10
8000a690:	16 91       	mov	r1,r11
8000a692:	e0 a0 0f c7 	rcall	8000c620 <__avr32_f64_to_s32>
8000a696:	30 08       	mov	r8,0
8000a698:	18 96       	mov	r6,r12
8000a69a:	30 09       	mov	r9,0
8000a69c:	00 9a       	mov	r10,r0
8000a69e:	02 9b       	mov	r11,r1
8000a6a0:	e0 a0 10 8e 	rcall	8000c7bc <__avr32_f64_cmp_lt>
8000a6a4:	c0 c0       	breq	8000a6bc <_dtoa_r+0x1f4>
8000a6a6:	0c 9c       	mov	r12,r6
8000a6a8:	e0 a0 0f d3 	rcall	8000c64e <__avr32_s32_to_f64>
8000a6ac:	14 98       	mov	r8,r10
8000a6ae:	16 99       	mov	r9,r11
8000a6b0:	00 9a       	mov	r10,r0
8000a6b2:	02 9b       	mov	r11,r1
8000a6b4:	e0 a0 10 3d 	rcall	8000c72e <__avr32_f64_cmp_eq>
8000a6b8:	f7 b6 00 01 	subeq	r6,1
8000a6bc:	59 66       	cp.w	r6,22
8000a6be:	e0 88 00 05 	brls	8000a6c8 <_dtoa_r+0x200>
8000a6c2:	30 18       	mov	r8,1
8000a6c4:	51 48       	stdsp	sp[0x50],r8
8000a6c6:	c1 38       	rjmp	8000a6ec <_dtoa_r+0x224>
8000a6c8:	fe c8 c2 7c 	sub	r8,pc,-15748
8000a6cc:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a6d0:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000a6d4:	e0 a0 10 74 	rcall	8000c7bc <__avr32_f64_cmp_lt>
8000a6d8:	f9 b4 00 00 	moveq	r4,0
8000a6dc:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000a6e0:	f7 b6 01 01 	subne	r6,1
8000a6e4:	f9 bc 01 00 	movne	r12,0
8000a6e8:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000a6ec:	41 90       	lddsp	r0,sp[0x64]
8000a6ee:	20 10       	sub	r0,1
8000a6f0:	0a 10       	sub	r0,r5
8000a6f2:	c0 46       	brmi	8000a6fa <_dtoa_r+0x232>
8000a6f4:	50 40       	stdsp	sp[0x10],r0
8000a6f6:	30 00       	mov	r0,0
8000a6f8:	c0 48       	rjmp	8000a700 <_dtoa_r+0x238>
8000a6fa:	30 0b       	mov	r11,0
8000a6fc:	5c 30       	neg	r0
8000a6fe:	50 4b       	stdsp	sp[0x10],r11
8000a700:	ec 02 11 00 	rsub	r2,r6,0
8000a704:	58 06       	cp.w	r6,0
8000a706:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000a70a:	f5 d6 e4 0a 	addge	r10,r10,r6
8000a70e:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000a712:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000a716:	f9 b2 04 00 	movge	r2,0
8000a71a:	e1 d6 e5 10 	sublt	r0,r0,r6
8000a71e:	f9 b9 05 00 	movlt	r9,0
8000a722:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000a726:	40 c8       	lddsp	r8,sp[0x30]
8000a728:	58 98       	cp.w	r8,9
8000a72a:	e0 8b 00 20 	brhi	8000a76a <_dtoa_r+0x2a2>
8000a72e:	58 58       	cp.w	r8,5
8000a730:	f9 b4 0a 01 	movle	r4,1
8000a734:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000a738:	f7 b5 09 04 	subgt	r5,4
8000a73c:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000a740:	f9 b4 09 00 	movgt	r4,0
8000a744:	40 cc       	lddsp	r12,sp[0x30]
8000a746:	58 3c       	cp.w	r12,3
8000a748:	c2 d0       	breq	8000a7a2 <_dtoa_r+0x2da>
8000a74a:	e0 89 00 05 	brgt	8000a754 <_dtoa_r+0x28c>
8000a74e:	58 2c       	cp.w	r12,2
8000a750:	c1 01       	brne	8000a770 <_dtoa_r+0x2a8>
8000a752:	c1 88       	rjmp	8000a782 <_dtoa_r+0x2ba>
8000a754:	40 cb       	lddsp	r11,sp[0x30]
8000a756:	58 4b       	cp.w	r11,4
8000a758:	c0 60       	breq	8000a764 <_dtoa_r+0x29c>
8000a75a:	58 5b       	cp.w	r11,5
8000a75c:	c0 a1       	brne	8000a770 <_dtoa_r+0x2a8>
8000a75e:	30 1a       	mov	r10,1
8000a760:	50 da       	stdsp	sp[0x34],r10
8000a762:	c2 28       	rjmp	8000a7a6 <_dtoa_r+0x2de>
8000a764:	30 19       	mov	r9,1
8000a766:	50 d9       	stdsp	sp[0x34],r9
8000a768:	c0 f8       	rjmp	8000a786 <_dtoa_r+0x2be>
8000a76a:	30 08       	mov	r8,0
8000a76c:	30 14       	mov	r4,1
8000a76e:	50 c8       	stdsp	sp[0x30],r8
8000a770:	3f f5       	mov	r5,-1
8000a772:	30 1c       	mov	r12,1
8000a774:	30 0b       	mov	r11,0
8000a776:	50 95       	stdsp	sp[0x24],r5
8000a778:	50 dc       	stdsp	sp[0x34],r12
8000a77a:	0a 91       	mov	r1,r5
8000a77c:	31 28       	mov	r8,18
8000a77e:	50 eb       	stdsp	sp[0x38],r11
8000a780:	c2 08       	rjmp	8000a7c0 <_dtoa_r+0x2f8>
8000a782:	30 0a       	mov	r10,0
8000a784:	50 da       	stdsp	sp[0x34],r10
8000a786:	40 e9       	lddsp	r9,sp[0x38]
8000a788:	58 09       	cp.w	r9,0
8000a78a:	e0 89 00 07 	brgt	8000a798 <_dtoa_r+0x2d0>
8000a78e:	30 18       	mov	r8,1
8000a790:	50 98       	stdsp	sp[0x24],r8
8000a792:	10 91       	mov	r1,r8
8000a794:	50 e8       	stdsp	sp[0x38],r8
8000a796:	c1 58       	rjmp	8000a7c0 <_dtoa_r+0x2f8>
8000a798:	40 e5       	lddsp	r5,sp[0x38]
8000a79a:	50 95       	stdsp	sp[0x24],r5
8000a79c:	0a 91       	mov	r1,r5
8000a79e:	0a 98       	mov	r8,r5
8000a7a0:	c1 08       	rjmp	8000a7c0 <_dtoa_r+0x2f8>
8000a7a2:	30 0c       	mov	r12,0
8000a7a4:	50 dc       	stdsp	sp[0x34],r12
8000a7a6:	40 eb       	lddsp	r11,sp[0x38]
8000a7a8:	ec 0b 00 0b 	add	r11,r6,r11
8000a7ac:	50 9b       	stdsp	sp[0x24],r11
8000a7ae:	16 98       	mov	r8,r11
8000a7b0:	2f f8       	sub	r8,-1
8000a7b2:	58 08       	cp.w	r8,0
8000a7b4:	e0 89 00 05 	brgt	8000a7be <_dtoa_r+0x2f6>
8000a7b8:	10 91       	mov	r1,r8
8000a7ba:	30 18       	mov	r8,1
8000a7bc:	c0 28       	rjmp	8000a7c0 <_dtoa_r+0x2f8>
8000a7be:	10 91       	mov	r1,r8
8000a7c0:	30 09       	mov	r9,0
8000a7c2:	6e 9a       	ld.w	r10,r7[0x24]
8000a7c4:	95 19       	st.w	r10[0x4],r9
8000a7c6:	30 49       	mov	r9,4
8000a7c8:	c0 68       	rjmp	8000a7d4 <_dtoa_r+0x30c>
8000a7ca:	d7 03       	nop
8000a7cc:	6a 1a       	ld.w	r10,r5[0x4]
8000a7ce:	a1 79       	lsl	r9,0x1
8000a7d0:	2f fa       	sub	r10,-1
8000a7d2:	8b 1a       	st.w	r5[0x4],r10
8000a7d4:	6e 95       	ld.w	r5,r7[0x24]
8000a7d6:	f2 ca ff ec 	sub	r10,r9,-20
8000a7da:	10 3a       	cp.w	r10,r8
8000a7dc:	fe 98 ff f8 	brls	8000a7cc <_dtoa_r+0x304>
8000a7e0:	6a 1b       	ld.w	r11,r5[0x4]
8000a7e2:	0e 9c       	mov	r12,r7
8000a7e4:	e0 a0 09 44 	rcall	8000ba6c <_Balloc>
8000a7e8:	58 e1       	cp.w	r1,14
8000a7ea:	5f 88       	srls	r8
8000a7ec:	8b 0c       	st.w	r5[0x0],r12
8000a7ee:	f1 e4 00 04 	and	r4,r8,r4
8000a7f2:	6e 98       	ld.w	r8,r7[0x24]
8000a7f4:	70 08       	ld.w	r8,r8[0x0]
8000a7f6:	50 88       	stdsp	sp[0x20],r8
8000a7f8:	e0 80 01 82 	breq	8000aafc <_dtoa_r+0x634>
8000a7fc:	58 06       	cp.w	r6,0
8000a7fe:	e0 8a 00 43 	brle	8000a884 <_dtoa_r+0x3bc>
8000a802:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000a806:	fe c8 c3 ba 	sub	r8,pc,-15430
8000a80a:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
8000a80e:	fa e5 00 18 	st.d	sp[24],r4
8000a812:	ec 04 14 04 	asr	r4,r6,0x4
8000a816:	ed b4 00 04 	bld	r4,0x4
8000a81a:	c0 30       	breq	8000a820 <_dtoa_r+0x358>
8000a81c:	30 25       	mov	r5,2
8000a81e:	c1 08       	rjmp	8000a83e <_dtoa_r+0x376>
8000a820:	fe c8 c3 0c 	sub	r8,pc,-15604
8000a824:	f0 e8 00 20 	ld.d	r8,r8[32]
8000a828:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a82c:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
8000a830:	e0 a0 0f fa 	rcall	8000c824 <__avr32_f64_div>
8000a834:	30 35       	mov	r5,3
8000a836:	14 98       	mov	r8,r10
8000a838:	16 99       	mov	r9,r11
8000a83a:	fa e9 00 08 	st.d	sp[8],r8
8000a83e:	fe cc c3 2a 	sub	r12,pc,-15574
8000a842:	50 a3       	stdsp	sp[0x28],r3
8000a844:	0c 93       	mov	r3,r6
8000a846:	18 96       	mov	r6,r12
8000a848:	c0 f8       	rjmp	8000a866 <_dtoa_r+0x39e>
8000a84a:	fa ea 00 18 	ld.d	r10,sp[24]
8000a84e:	ed b4 00 00 	bld	r4,0x0
8000a852:	c0 81       	brne	8000a862 <_dtoa_r+0x39a>
8000a854:	ec e8 00 00 	ld.d	r8,r6[0]
8000a858:	2f f5       	sub	r5,-1
8000a85a:	e0 a0 0c 9f 	rcall	8000c198 <__avr32_f64_mul>
8000a85e:	fa eb 00 18 	st.d	sp[24],r10
8000a862:	a1 54       	asr	r4,0x1
8000a864:	2f 86       	sub	r6,-8
8000a866:	58 04       	cp.w	r4,0
8000a868:	cf 11       	brne	8000a84a <_dtoa_r+0x382>
8000a86a:	fa e8 00 18 	ld.d	r8,sp[24]
8000a86e:	fa ea 00 08 	ld.d	r10,sp[8]
8000a872:	06 96       	mov	r6,r3
8000a874:	e0 a0 0f d8 	rcall	8000c824 <__avr32_f64_div>
8000a878:	40 a3       	lddsp	r3,sp[0x28]
8000a87a:	14 98       	mov	r8,r10
8000a87c:	16 99       	mov	r9,r11
8000a87e:	fa e9 00 08 	st.d	sp[8],r8
8000a882:	c2 f8       	rjmp	8000a8e0 <_dtoa_r+0x418>
8000a884:	ec 08 11 00 	rsub	r8,r6,0
8000a888:	c0 31       	brne	8000a88e <_dtoa_r+0x3c6>
8000a88a:	30 25       	mov	r5,2
8000a88c:	c2 a8       	rjmp	8000a8e0 <_dtoa_r+0x418>
8000a88e:	fe cc c3 7a 	sub	r12,pc,-15494
8000a892:	f0 04 14 04 	asr	r4,r8,0x4
8000a896:	50 1c       	stdsp	sp[0x4],r12
8000a898:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000a89c:	fe c9 c4 50 	sub	r9,pc,-15280
8000a8a0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000a8a4:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a8a8:	e0 a0 0c 78 	rcall	8000c198 <__avr32_f64_mul>
8000a8ac:	40 1c       	lddsp	r12,sp[0x4]
8000a8ae:	50 63       	stdsp	sp[0x18],r3
8000a8b0:	30 25       	mov	r5,2
8000a8b2:	0c 93       	mov	r3,r6
8000a8b4:	fa eb 00 08 	st.d	sp[8],r10
8000a8b8:	18 96       	mov	r6,r12
8000a8ba:	c0 f8       	rjmp	8000a8d8 <_dtoa_r+0x410>
8000a8bc:	fa ea 00 08 	ld.d	r10,sp[8]
8000a8c0:	ed b4 00 00 	bld	r4,0x0
8000a8c4:	c0 81       	brne	8000a8d4 <_dtoa_r+0x40c>
8000a8c6:	ec e8 00 00 	ld.d	r8,r6[0]
8000a8ca:	2f f5       	sub	r5,-1
8000a8cc:	e0 a0 0c 66 	rcall	8000c198 <__avr32_f64_mul>
8000a8d0:	fa eb 00 08 	st.d	sp[8],r10
8000a8d4:	a1 54       	asr	r4,0x1
8000a8d6:	2f 86       	sub	r6,-8
8000a8d8:	58 04       	cp.w	r4,0
8000a8da:	cf 11       	brne	8000a8bc <_dtoa_r+0x3f4>
8000a8dc:	06 96       	mov	r6,r3
8000a8de:	40 63       	lddsp	r3,sp[0x18]
8000a8e0:	41 4a       	lddsp	r10,sp[0x50]
8000a8e2:	58 0a       	cp.w	r10,0
8000a8e4:	c2 a0       	breq	8000a938 <_dtoa_r+0x470>
8000a8e6:	fa e8 00 08 	ld.d	r8,sp[8]
8000a8ea:	58 01       	cp.w	r1,0
8000a8ec:	5f 94       	srgt	r4
8000a8ee:	fa e9 00 18 	st.d	sp[24],r8
8000a8f2:	30 08       	mov	r8,0
8000a8f4:	fc 19 3f f0 	movh	r9,0x3ff0
8000a8f8:	fa ea 00 18 	ld.d	r10,sp[24]
8000a8fc:	e0 a0 0f 60 	rcall	8000c7bc <__avr32_f64_cmp_lt>
8000a900:	f9 bc 00 00 	moveq	r12,0
8000a904:	f9 bc 01 01 	movne	r12,1
8000a908:	e9 ec 00 0c 	and	r12,r4,r12
8000a90c:	c1 60       	breq	8000a938 <_dtoa_r+0x470>
8000a90e:	40 98       	lddsp	r8,sp[0x24]
8000a910:	58 08       	cp.w	r8,0
8000a912:	e0 8a 00 f1 	brle	8000aaf4 <_dtoa_r+0x62c>
8000a916:	30 08       	mov	r8,0
8000a918:	fc 19 40 24 	movh	r9,0x4024
8000a91c:	ec c4 00 01 	sub	r4,r6,1
8000a920:	fa ea 00 18 	ld.d	r10,sp[24]
8000a924:	2f f5       	sub	r5,-1
8000a926:	50 64       	stdsp	sp[0x18],r4
8000a928:	e0 a0 0c 38 	rcall	8000c198 <__avr32_f64_mul>
8000a92c:	40 94       	lddsp	r4,sp[0x24]
8000a92e:	14 98       	mov	r8,r10
8000a930:	16 99       	mov	r9,r11
8000a932:	fa e9 00 08 	st.d	sp[8],r8
8000a936:	c0 38       	rjmp	8000a93c <_dtoa_r+0x474>
8000a938:	50 66       	stdsp	sp[0x18],r6
8000a93a:	02 94       	mov	r4,r1
8000a93c:	0a 9c       	mov	r12,r5
8000a93e:	e0 a0 0e 88 	rcall	8000c64e <__avr32_s32_to_f64>
8000a942:	fa e8 00 08 	ld.d	r8,sp[8]
8000a946:	e0 a0 0c 29 	rcall	8000c198 <__avr32_f64_mul>
8000a94a:	30 08       	mov	r8,0
8000a94c:	fc 19 40 1c 	movh	r9,0x401c
8000a950:	e0 a0 0d de 	rcall	8000c50c <__avr32_f64_add>
8000a954:	14 98       	mov	r8,r10
8000a956:	16 99       	mov	r9,r11
8000a958:	fa e9 00 28 	st.d	sp[40],r8
8000a95c:	fc 18 fc c0 	movh	r8,0xfcc0
8000a960:	40 a5       	lddsp	r5,sp[0x28]
8000a962:	10 05       	add	r5,r8
8000a964:	50 a5       	stdsp	sp[0x28],r5
8000a966:	58 04       	cp.w	r4,0
8000a968:	c2 11       	brne	8000a9aa <_dtoa_r+0x4e2>
8000a96a:	fa ea 00 08 	ld.d	r10,sp[8]
8000a96e:	30 08       	mov	r8,0
8000a970:	fc 19 40 14 	movh	r9,0x4014
8000a974:	e0 a0 0c fe 	rcall	8000c370 <__avr32_f64_sub>
8000a978:	40 bc       	lddsp	r12,sp[0x2c]
8000a97a:	fa eb 00 08 	st.d	sp[8],r10
8000a97e:	14 98       	mov	r8,r10
8000a980:	16 99       	mov	r9,r11
8000a982:	18 9a       	mov	r10,r12
8000a984:	0a 9b       	mov	r11,r5
8000a986:	e0 a0 0f 1b 	rcall	8000c7bc <__avr32_f64_cmp_lt>
8000a98a:	e0 81 02 54 	brne	8000ae32 <_dtoa_r+0x96a>
8000a98e:	0a 98       	mov	r8,r5
8000a990:	40 b9       	lddsp	r9,sp[0x2c]
8000a992:	ee 18 80 00 	eorh	r8,0x8000
8000a996:	fa ea 00 08 	ld.d	r10,sp[8]
8000a99a:	10 95       	mov	r5,r8
8000a99c:	12 98       	mov	r8,r9
8000a99e:	0a 99       	mov	r9,r5
8000a9a0:	e0 a0 0f 0e 	rcall	8000c7bc <__avr32_f64_cmp_lt>
8000a9a4:	e0 81 02 3e 	brne	8000ae20 <_dtoa_r+0x958>
8000a9a8:	ca 68       	rjmp	8000aaf4 <_dtoa_r+0x62c>
8000a9aa:	fe c9 c5 5e 	sub	r9,pc,-15010
8000a9ae:	e8 c8 00 01 	sub	r8,r4,1
8000a9b2:	40 d5       	lddsp	r5,sp[0x34]
8000a9b4:	58 05       	cp.w	r5,0
8000a9b6:	c4 f0       	breq	8000aa54 <_dtoa_r+0x58c>
8000a9b8:	30 0c       	mov	r12,0
8000a9ba:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
8000a9be:	51 3c       	stdsp	sp[0x4c],r12
8000a9c0:	30 0a       	mov	r10,0
8000a9c2:	fc 1b 3f e0 	movh	r11,0x3fe0
8000a9c6:	e0 a0 0f 2f 	rcall	8000c824 <__avr32_f64_div>
8000a9ca:	fa e8 00 28 	ld.d	r8,sp[40]
8000a9ce:	40 85       	lddsp	r5,sp[0x20]
8000a9d0:	e0 a0 0c d0 	rcall	8000c370 <__avr32_f64_sub>
8000a9d4:	fa eb 00 28 	st.d	sp[40],r10
8000a9d8:	fa ea 00 08 	ld.d	r10,sp[8]
8000a9dc:	e0 a0 0e 22 	rcall	8000c620 <__avr32_f64_to_s32>
8000a9e0:	51 6c       	stdsp	sp[0x58],r12
8000a9e2:	e0 a0 0e 36 	rcall	8000c64e <__avr32_s32_to_f64>
8000a9e6:	14 98       	mov	r8,r10
8000a9e8:	16 99       	mov	r9,r11
8000a9ea:	fa ea 00 08 	ld.d	r10,sp[8]
8000a9ee:	e0 a0 0c c1 	rcall	8000c370 <__avr32_f64_sub>
8000a9f2:	fa eb 00 08 	st.d	sp[8],r10
8000a9f6:	41 68       	lddsp	r8,sp[0x58]
8000a9f8:	2d 08       	sub	r8,-48
8000a9fa:	0a c8       	st.b	r5++,r8
8000a9fc:	41 39       	lddsp	r9,sp[0x4c]
8000a9fe:	2f f9       	sub	r9,-1
8000aa00:	51 39       	stdsp	sp[0x4c],r9
8000aa02:	fa e8 00 28 	ld.d	r8,sp[40]
8000aa06:	e0 a0 0e db 	rcall	8000c7bc <__avr32_f64_cmp_lt>
8000aa0a:	e0 81 03 39 	brne	8000b07c <_dtoa_r+0xbb4>
8000aa0e:	fa e8 00 08 	ld.d	r8,sp[8]
8000aa12:	30 0a       	mov	r10,0
8000aa14:	fc 1b 3f f0 	movh	r11,0x3ff0
8000aa18:	e0 a0 0c ac 	rcall	8000c370 <__avr32_f64_sub>
8000aa1c:	fa e8 00 28 	ld.d	r8,sp[40]
8000aa20:	e0 a0 0e ce 	rcall	8000c7bc <__avr32_f64_cmp_lt>
8000aa24:	fa ea 00 28 	ld.d	r10,sp[40]
8000aa28:	30 08       	mov	r8,0
8000aa2a:	fc 19 40 24 	movh	r9,0x4024
8000aa2e:	e0 81 00 da 	brne	8000abe2 <_dtoa_r+0x71a>
8000aa32:	41 3c       	lddsp	r12,sp[0x4c]
8000aa34:	08 3c       	cp.w	r12,r4
8000aa36:	c5 f4       	brge	8000aaf4 <_dtoa_r+0x62c>
8000aa38:	e0 a0 0b b0 	rcall	8000c198 <__avr32_f64_mul>
8000aa3c:	30 08       	mov	r8,0
8000aa3e:	fa eb 00 28 	st.d	sp[40],r10
8000aa42:	fc 19 40 24 	movh	r9,0x4024
8000aa46:	fa ea 00 08 	ld.d	r10,sp[8]
8000aa4a:	e0 a0 0b a7 	rcall	8000c198 <__avr32_f64_mul>
8000aa4e:	fa eb 00 08 	st.d	sp[8],r10
8000aa52:	cc 3b       	rjmp	8000a9d8 <_dtoa_r+0x510>
8000aa54:	40 85       	lddsp	r5,sp[0x20]
8000aa56:	08 05       	add	r5,r4
8000aa58:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
8000aa5c:	51 35       	stdsp	sp[0x4c],r5
8000aa5e:	fa e8 00 28 	ld.d	r8,sp[40]
8000aa62:	40 85       	lddsp	r5,sp[0x20]
8000aa64:	e0 a0 0b 9a 	rcall	8000c198 <__avr32_f64_mul>
8000aa68:	fa eb 00 28 	st.d	sp[40],r10
8000aa6c:	fa ea 00 08 	ld.d	r10,sp[8]
8000aa70:	e0 a0 0d d8 	rcall	8000c620 <__avr32_f64_to_s32>
8000aa74:	51 6c       	stdsp	sp[0x58],r12
8000aa76:	e0 a0 0d ec 	rcall	8000c64e <__avr32_s32_to_f64>
8000aa7a:	14 98       	mov	r8,r10
8000aa7c:	16 99       	mov	r9,r11
8000aa7e:	fa ea 00 08 	ld.d	r10,sp[8]
8000aa82:	e0 a0 0c 77 	rcall	8000c370 <__avr32_f64_sub>
8000aa86:	fa eb 00 08 	st.d	sp[8],r10
8000aa8a:	41 68       	lddsp	r8,sp[0x58]
8000aa8c:	2d 08       	sub	r8,-48
8000aa8e:	0a c8       	st.b	r5++,r8
8000aa90:	41 3c       	lddsp	r12,sp[0x4c]
8000aa92:	18 35       	cp.w	r5,r12
8000aa94:	c2 81       	brne	8000aae4 <_dtoa_r+0x61c>
8000aa96:	30 08       	mov	r8,0
8000aa98:	fc 19 3f e0 	movh	r9,0x3fe0
8000aa9c:	fa ea 00 28 	ld.d	r10,sp[40]
8000aaa0:	e0 a0 0d 36 	rcall	8000c50c <__avr32_f64_add>
8000aaa4:	40 85       	lddsp	r5,sp[0x20]
8000aaa6:	fa e8 00 08 	ld.d	r8,sp[8]
8000aaaa:	08 05       	add	r5,r4
8000aaac:	e0 a0 0e 88 	rcall	8000c7bc <__avr32_f64_cmp_lt>
8000aab0:	e0 81 00 99 	brne	8000abe2 <_dtoa_r+0x71a>
8000aab4:	fa e8 00 28 	ld.d	r8,sp[40]
8000aab8:	30 0a       	mov	r10,0
8000aaba:	fc 1b 3f e0 	movh	r11,0x3fe0
8000aabe:	e0 a0 0c 59 	rcall	8000c370 <__avr32_f64_sub>
8000aac2:	14 98       	mov	r8,r10
8000aac4:	16 99       	mov	r9,r11
8000aac6:	fa ea 00 08 	ld.d	r10,sp[8]
8000aaca:	e0 a0 0e 79 	rcall	8000c7bc <__avr32_f64_cmp_lt>
8000aace:	c1 30       	breq	8000aaf4 <_dtoa_r+0x62c>
8000aad0:	33 09       	mov	r9,48
8000aad2:	0a 98       	mov	r8,r5
8000aad4:	11 7a       	ld.ub	r10,--r8
8000aad6:	f2 0a 18 00 	cp.b	r10,r9
8000aada:	e0 81 02 d1 	brne	8000b07c <_dtoa_r+0xbb4>
8000aade:	10 95       	mov	r5,r8
8000aae0:	cf 9b       	rjmp	8000aad2 <_dtoa_r+0x60a>
8000aae2:	d7 03       	nop
8000aae4:	30 08       	mov	r8,0
8000aae6:	fc 19 40 24 	movh	r9,0x4024
8000aaea:	e0 a0 0b 57 	rcall	8000c198 <__avr32_f64_mul>
8000aaee:	fa eb 00 08 	st.d	sp[8],r10
8000aaf2:	cb db       	rjmp	8000aa6c <_dtoa_r+0x5a4>
8000aaf4:	fa ea 00 3c 	ld.d	r10,sp[60]
8000aaf8:	fa eb 00 08 	st.d	sp[8],r10
8000aafc:	58 e6       	cp.w	r6,14
8000aafe:	5f ab       	srle	r11
8000ab00:	41 8a       	lddsp	r10,sp[0x60]
8000ab02:	30 08       	mov	r8,0
8000ab04:	f4 09 11 ff 	rsub	r9,r10,-1
8000ab08:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
8000ab0c:	f0 09 18 00 	cp.b	r9,r8
8000ab10:	e0 80 00 82 	breq	8000ac14 <_dtoa_r+0x74c>
8000ab14:	40 ea       	lddsp	r10,sp[0x38]
8000ab16:	58 01       	cp.w	r1,0
8000ab18:	5f a9       	srle	r9
8000ab1a:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
8000ab1e:	fe ca c6 d2 	sub	r10,pc,-14638
8000ab22:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000ab26:	fa e5 00 10 	st.d	sp[16],r4
8000ab2a:	f0 09 18 00 	cp.b	r9,r8
8000ab2e:	c1 40       	breq	8000ab56 <_dtoa_r+0x68e>
8000ab30:	58 01       	cp.w	r1,0
8000ab32:	e0 81 01 77 	brne	8000ae20 <_dtoa_r+0x958>
8000ab36:	30 08       	mov	r8,0
8000ab38:	fc 19 40 14 	movh	r9,0x4014
8000ab3c:	08 9a       	mov	r10,r4
8000ab3e:	0a 9b       	mov	r11,r5
8000ab40:	e0 a0 0b 2c 	rcall	8000c198 <__avr32_f64_mul>
8000ab44:	fa e8 00 08 	ld.d	r8,sp[8]
8000ab48:	e0 a0 0e 06 	rcall	8000c754 <__avr32_f64_cmp_ge>
8000ab4c:	e0 81 01 6a 	brne	8000ae20 <_dtoa_r+0x958>
8000ab50:	02 92       	mov	r2,r1
8000ab52:	e0 8f 01 72 	bral	8000ae36 <_dtoa_r+0x96e>
8000ab56:	40 85       	lddsp	r5,sp[0x20]
8000ab58:	30 14       	mov	r4,1
8000ab5a:	fa e8 00 10 	ld.d	r8,sp[16]
8000ab5e:	fa ea 00 08 	ld.d	r10,sp[8]
8000ab62:	e0 a0 0e 61 	rcall	8000c824 <__avr32_f64_div>
8000ab66:	e0 a0 0d 5d 	rcall	8000c620 <__avr32_f64_to_s32>
8000ab6a:	18 92       	mov	r2,r12
8000ab6c:	e0 a0 0d 71 	rcall	8000c64e <__avr32_s32_to_f64>
8000ab70:	fa e8 00 10 	ld.d	r8,sp[16]
8000ab74:	e0 a0 0b 12 	rcall	8000c198 <__avr32_f64_mul>
8000ab78:	14 98       	mov	r8,r10
8000ab7a:	16 99       	mov	r9,r11
8000ab7c:	fa ea 00 08 	ld.d	r10,sp[8]
8000ab80:	e0 a0 0b f8 	rcall	8000c370 <__avr32_f64_sub>
8000ab84:	fa eb 00 08 	st.d	sp[8],r10
8000ab88:	e4 c8 ff d0 	sub	r8,r2,-48
8000ab8c:	0a c8       	st.b	r5++,r8
8000ab8e:	fc 19 40 24 	movh	r9,0x4024
8000ab92:	30 08       	mov	r8,0
8000ab94:	02 34       	cp.w	r4,r1
8000ab96:	c3 31       	brne	8000abfc <_dtoa_r+0x734>
8000ab98:	fa e8 00 08 	ld.d	r8,sp[8]
8000ab9c:	e0 a0 0c b8 	rcall	8000c50c <__avr32_f64_add>
8000aba0:	16 91       	mov	r1,r11
8000aba2:	14 90       	mov	r0,r10
8000aba4:	14 98       	mov	r8,r10
8000aba6:	02 99       	mov	r9,r1
8000aba8:	fa ea 00 10 	ld.d	r10,sp[16]
8000abac:	e0 a0 0e 08 	rcall	8000c7bc <__avr32_f64_cmp_lt>
8000abb0:	c1 a1       	brne	8000abe4 <_dtoa_r+0x71c>
8000abb2:	fa e8 00 10 	ld.d	r8,sp[16]
8000abb6:	00 9a       	mov	r10,r0
8000abb8:	02 9b       	mov	r11,r1
8000abba:	e0 a0 0d ba 	rcall	8000c72e <__avr32_f64_cmp_eq>
8000abbe:	e0 80 02 5e 	breq	8000b07a <_dtoa_r+0xbb2>
8000abc2:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000abc6:	c0 f1       	brne	8000abe4 <_dtoa_r+0x71c>
8000abc8:	e0 8f 02 59 	bral	8000b07a <_dtoa_r+0xbb2>
8000abcc:	40 8a       	lddsp	r10,sp[0x20]
8000abce:	14 38       	cp.w	r8,r10
8000abd0:	c0 30       	breq	8000abd6 <_dtoa_r+0x70e>
8000abd2:	10 95       	mov	r5,r8
8000abd4:	c0 98       	rjmp	8000abe6 <_dtoa_r+0x71e>
8000abd6:	33 08       	mov	r8,48
8000abd8:	40 89       	lddsp	r9,sp[0x20]
8000abda:	2f f6       	sub	r6,-1
8000abdc:	b2 88       	st.b	r9[0x0],r8
8000abde:	40 88       	lddsp	r8,sp[0x20]
8000abe0:	c0 88       	rjmp	8000abf0 <_dtoa_r+0x728>
8000abe2:	40 66       	lddsp	r6,sp[0x18]
8000abe4:	33 99       	mov	r9,57
8000abe6:	0a 98       	mov	r8,r5
8000abe8:	11 7a       	ld.ub	r10,--r8
8000abea:	f2 0a 18 00 	cp.b	r10,r9
8000abee:	ce f0       	breq	8000abcc <_dtoa_r+0x704>
8000abf0:	50 66       	stdsp	sp[0x18],r6
8000abf2:	11 89       	ld.ub	r9,r8[0x0]
8000abf4:	2f f9       	sub	r9,-1
8000abf6:	b0 89       	st.b	r8[0x0],r9
8000abf8:	e0 8f 02 42 	bral	8000b07c <_dtoa_r+0xbb4>
8000abfc:	e0 a0 0a ce 	rcall	8000c198 <__avr32_f64_mul>
8000ac00:	2f f4       	sub	r4,-1
8000ac02:	fa eb 00 08 	st.d	sp[8],r10
8000ac06:	30 08       	mov	r8,0
8000ac08:	30 09       	mov	r9,0
8000ac0a:	e0 a0 0d 92 	rcall	8000c72e <__avr32_f64_cmp_eq>
8000ac0e:	ca 60       	breq	8000ab5a <_dtoa_r+0x692>
8000ac10:	e0 8f 02 35 	bral	8000b07a <_dtoa_r+0xbb2>
8000ac14:	40 d8       	lddsp	r8,sp[0x34]
8000ac16:	58 08       	cp.w	r8,0
8000ac18:	c0 51       	brne	8000ac22 <_dtoa_r+0x75a>
8000ac1a:	04 98       	mov	r8,r2
8000ac1c:	00 95       	mov	r5,r0
8000ac1e:	40 d4       	lddsp	r4,sp[0x34]
8000ac20:	c3 78       	rjmp	8000ac8e <_dtoa_r+0x7c6>
8000ac22:	40 c5       	lddsp	r5,sp[0x30]
8000ac24:	58 15       	cp.w	r5,1
8000ac26:	e0 89 00 0f 	brgt	8000ac44 <_dtoa_r+0x77c>
8000ac2a:	41 74       	lddsp	r4,sp[0x5c]
8000ac2c:	58 04       	cp.w	r4,0
8000ac2e:	c0 40       	breq	8000ac36 <_dtoa_r+0x76e>
8000ac30:	f4 c9 fb cd 	sub	r9,r10,-1075
8000ac34:	c0 48       	rjmp	8000ac3c <_dtoa_r+0x774>
8000ac36:	41 99       	lddsp	r9,sp[0x64]
8000ac38:	f2 09 11 36 	rsub	r9,r9,54
8000ac3c:	04 98       	mov	r8,r2
8000ac3e:	00 95       	mov	r5,r0
8000ac40:	c1 c8       	rjmp	8000ac78 <_dtoa_r+0x7b0>
8000ac42:	d7 03       	nop
8000ac44:	e2 c8 00 01 	sub	r8,r1,1
8000ac48:	58 01       	cp.w	r1,0
8000ac4a:	e0 05 17 40 	movge	r5,r0
8000ac4e:	e2 09 17 40 	movge	r9,r1
8000ac52:	e1 d1 e5 15 	sublt	r5,r0,r1
8000ac56:	f9 b9 05 00 	movlt	r9,0
8000ac5a:	10 32       	cp.w	r2,r8
8000ac5c:	e5 d8 e4 18 	subge	r8,r2,r8
8000ac60:	f1 d2 e5 18 	sublt	r8,r8,r2
8000ac64:	e5 d8 e5 02 	addlt	r2,r2,r8
8000ac68:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
8000ac6c:	f9 d8 e5 0c 	addlt	r12,r12,r8
8000ac70:	fb fc 5a 11 	st.wlt	sp[0x44],r12
8000ac74:	f9 b8 05 00 	movlt	r8,0
8000ac78:	40 4b       	lddsp	r11,sp[0x10]
8000ac7a:	12 0b       	add	r11,r9
8000ac7c:	50 08       	stdsp	sp[0x0],r8
8000ac7e:	50 4b       	stdsp	sp[0x10],r11
8000ac80:	12 00       	add	r0,r9
8000ac82:	30 1b       	mov	r11,1
8000ac84:	0e 9c       	mov	r12,r7
8000ac86:	e0 a0 08 a7 	rcall	8000bdd4 <__i2b>
8000ac8a:	40 08       	lddsp	r8,sp[0x0]
8000ac8c:	18 94       	mov	r4,r12
8000ac8e:	40 4a       	lddsp	r10,sp[0x10]
8000ac90:	58 05       	cp.w	r5,0
8000ac92:	5f 99       	srgt	r9
8000ac94:	58 0a       	cp.w	r10,0
8000ac96:	5f 9a       	srgt	r10
8000ac98:	f5 e9 00 09 	and	r9,r10,r9
8000ac9c:	c0 80       	breq	8000acac <_dtoa_r+0x7e4>
8000ac9e:	40 4c       	lddsp	r12,sp[0x10]
8000aca0:	f8 05 0d 49 	min	r9,r12,r5
8000aca4:	12 1c       	sub	r12,r9
8000aca6:	12 10       	sub	r0,r9
8000aca8:	50 4c       	stdsp	sp[0x10],r12
8000acaa:	12 15       	sub	r5,r9
8000acac:	58 02       	cp.w	r2,0
8000acae:	e0 8a 00 27 	brle	8000acfc <_dtoa_r+0x834>
8000acb2:	40 db       	lddsp	r11,sp[0x34]
8000acb4:	58 0b       	cp.w	r11,0
8000acb6:	c1 d0       	breq	8000acf0 <_dtoa_r+0x828>
8000acb8:	58 08       	cp.w	r8,0
8000acba:	e0 8a 00 17 	brle	8000ace8 <_dtoa_r+0x820>
8000acbe:	10 9a       	mov	r10,r8
8000acc0:	50 08       	stdsp	sp[0x0],r8
8000acc2:	08 9b       	mov	r11,r4
8000acc4:	0e 9c       	mov	r12,r7
8000acc6:	e0 a0 08 cd 	rcall	8000be60 <__pow5mult>
8000acca:	06 9a       	mov	r10,r3
8000accc:	18 9b       	mov	r11,r12
8000acce:	18 94       	mov	r4,r12
8000acd0:	0e 9c       	mov	r12,r7
8000acd2:	e0 a0 08 01 	rcall	8000bcd4 <__multiply>
8000acd6:	18 99       	mov	r9,r12
8000acd8:	06 9b       	mov	r11,r3
8000acda:	50 19       	stdsp	sp[0x4],r9
8000acdc:	0e 9c       	mov	r12,r7
8000acde:	e0 a0 06 ad 	rcall	8000ba38 <_Bfree>
8000ace2:	40 19       	lddsp	r9,sp[0x4]
8000ace4:	40 08       	lddsp	r8,sp[0x0]
8000ace6:	12 93       	mov	r3,r9
8000ace8:	e4 08 01 0a 	sub	r10,r2,r8
8000acec:	c0 80       	breq	8000acfc <_dtoa_r+0x834>
8000acee:	c0 28       	rjmp	8000acf2 <_dtoa_r+0x82a>
8000acf0:	04 9a       	mov	r10,r2
8000acf2:	06 9b       	mov	r11,r3
8000acf4:	0e 9c       	mov	r12,r7
8000acf6:	e0 a0 08 b5 	rcall	8000be60 <__pow5mult>
8000acfa:	18 93       	mov	r3,r12
8000acfc:	30 1b       	mov	r11,1
8000acfe:	0e 9c       	mov	r12,r7
8000ad00:	e0 a0 08 6a 	rcall	8000bdd4 <__i2b>
8000ad04:	41 1a       	lddsp	r10,sp[0x44]
8000ad06:	18 92       	mov	r2,r12
8000ad08:	58 0a       	cp.w	r10,0
8000ad0a:	e0 8a 00 07 	brle	8000ad18 <_dtoa_r+0x850>
8000ad0e:	18 9b       	mov	r11,r12
8000ad10:	0e 9c       	mov	r12,r7
8000ad12:	e0 a0 08 a7 	rcall	8000be60 <__pow5mult>
8000ad16:	18 92       	mov	r2,r12
8000ad18:	40 c9       	lddsp	r9,sp[0x30]
8000ad1a:	58 19       	cp.w	r9,1
8000ad1c:	e0 89 00 14 	brgt	8000ad44 <_dtoa_r+0x87c>
8000ad20:	40 38       	lddsp	r8,sp[0xc]
8000ad22:	58 08       	cp.w	r8,0
8000ad24:	c1 01       	brne	8000ad44 <_dtoa_r+0x87c>
8000ad26:	40 29       	lddsp	r9,sp[0x8]
8000ad28:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
8000ad2c:	c0 c1       	brne	8000ad44 <_dtoa_r+0x87c>
8000ad2e:	12 98       	mov	r8,r9
8000ad30:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000ad34:	c0 80       	breq	8000ad44 <_dtoa_r+0x87c>
8000ad36:	40 4c       	lddsp	r12,sp[0x10]
8000ad38:	30 1b       	mov	r11,1
8000ad3a:	2f fc       	sub	r12,-1
8000ad3c:	2f f0       	sub	r0,-1
8000ad3e:	50 4c       	stdsp	sp[0x10],r12
8000ad40:	50 6b       	stdsp	sp[0x18],r11
8000ad42:	c0 38       	rjmp	8000ad48 <_dtoa_r+0x880>
8000ad44:	30 0a       	mov	r10,0
8000ad46:	50 6a       	stdsp	sp[0x18],r10
8000ad48:	41 19       	lddsp	r9,sp[0x44]
8000ad4a:	58 09       	cp.w	r9,0
8000ad4c:	c0 31       	brne	8000ad52 <_dtoa_r+0x88a>
8000ad4e:	30 1c       	mov	r12,1
8000ad50:	c0 98       	rjmp	8000ad62 <_dtoa_r+0x89a>
8000ad52:	64 48       	ld.w	r8,r2[0x10]
8000ad54:	2f c8       	sub	r8,-4
8000ad56:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
8000ad5a:	e0 a0 05 df 	rcall	8000b918 <__hi0bits>
8000ad5e:	f8 0c 11 20 	rsub	r12,r12,32
8000ad62:	40 4b       	lddsp	r11,sp[0x10]
8000ad64:	f8 0b 00 08 	add	r8,r12,r11
8000ad68:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000ad6c:	c0 c0       	breq	8000ad84 <_dtoa_r+0x8bc>
8000ad6e:	f0 08 11 20 	rsub	r8,r8,32
8000ad72:	58 48       	cp.w	r8,4
8000ad74:	e0 8a 00 06 	brle	8000ad80 <_dtoa_r+0x8b8>
8000ad78:	20 48       	sub	r8,4
8000ad7a:	10 0b       	add	r11,r8
8000ad7c:	50 4b       	stdsp	sp[0x10],r11
8000ad7e:	c0 78       	rjmp	8000ad8c <_dtoa_r+0x8c4>
8000ad80:	58 48       	cp.w	r8,4
8000ad82:	c0 70       	breq	8000ad90 <_dtoa_r+0x8c8>
8000ad84:	40 4a       	lddsp	r10,sp[0x10]
8000ad86:	2e 48       	sub	r8,-28
8000ad88:	10 0a       	add	r10,r8
8000ad8a:	50 4a       	stdsp	sp[0x10],r10
8000ad8c:	10 00       	add	r0,r8
8000ad8e:	10 05       	add	r5,r8
8000ad90:	58 00       	cp.w	r0,0
8000ad92:	e0 8a 00 08 	brle	8000ada2 <_dtoa_r+0x8da>
8000ad96:	06 9b       	mov	r11,r3
8000ad98:	00 9a       	mov	r10,r0
8000ad9a:	0e 9c       	mov	r12,r7
8000ad9c:	e0 a0 07 58 	rcall	8000bc4c <__lshift>
8000ada0:	18 93       	mov	r3,r12
8000ada2:	40 49       	lddsp	r9,sp[0x10]
8000ada4:	58 09       	cp.w	r9,0
8000ada6:	e0 8a 00 08 	brle	8000adb6 <_dtoa_r+0x8ee>
8000adaa:	04 9b       	mov	r11,r2
8000adac:	12 9a       	mov	r10,r9
8000adae:	0e 9c       	mov	r12,r7
8000adb0:	e0 a0 07 4e 	rcall	8000bc4c <__lshift>
8000adb4:	18 92       	mov	r2,r12
8000adb6:	41 48       	lddsp	r8,sp[0x50]
8000adb8:	58 08       	cp.w	r8,0
8000adba:	c1 b0       	breq	8000adf0 <_dtoa_r+0x928>
8000adbc:	04 9b       	mov	r11,r2
8000adbe:	06 9c       	mov	r12,r3
8000adc0:	e0 a0 06 23 	rcall	8000ba06 <__mcmp>
8000adc4:	c1 64       	brge	8000adf0 <_dtoa_r+0x928>
8000adc6:	06 9b       	mov	r11,r3
8000adc8:	30 09       	mov	r9,0
8000adca:	30 aa       	mov	r10,10
8000adcc:	0e 9c       	mov	r12,r7
8000adce:	e0 a0 08 0b 	rcall	8000bde4 <__multadd>
8000add2:	20 16       	sub	r6,1
8000add4:	18 93       	mov	r3,r12
8000add6:	40 dc       	lddsp	r12,sp[0x34]
8000add8:	58 0c       	cp.w	r12,0
8000adda:	c0 31       	brne	8000ade0 <_dtoa_r+0x918>
8000addc:	40 91       	lddsp	r1,sp[0x24]
8000adde:	c0 98       	rjmp	8000adf0 <_dtoa_r+0x928>
8000ade0:	08 9b       	mov	r11,r4
8000ade2:	40 91       	lddsp	r1,sp[0x24]
8000ade4:	30 09       	mov	r9,0
8000ade6:	30 aa       	mov	r10,10
8000ade8:	0e 9c       	mov	r12,r7
8000adea:	e0 a0 07 fd 	rcall	8000bde4 <__multadd>
8000adee:	18 94       	mov	r4,r12
8000adf0:	58 01       	cp.w	r1,0
8000adf2:	5f a9       	srle	r9
8000adf4:	40 cb       	lddsp	r11,sp[0x30]
8000adf6:	58 2b       	cp.w	r11,2
8000adf8:	5f 98       	srgt	r8
8000adfa:	f3 e8 00 08 	and	r8,r9,r8
8000adfe:	c2 50       	breq	8000ae48 <_dtoa_r+0x980>
8000ae00:	58 01       	cp.w	r1,0
8000ae02:	c1 11       	brne	8000ae24 <_dtoa_r+0x95c>
8000ae04:	04 9b       	mov	r11,r2
8000ae06:	02 99       	mov	r9,r1
8000ae08:	30 5a       	mov	r10,5
8000ae0a:	0e 9c       	mov	r12,r7
8000ae0c:	e0 a0 07 ec 	rcall	8000bde4 <__multadd>
8000ae10:	18 92       	mov	r2,r12
8000ae12:	18 9b       	mov	r11,r12
8000ae14:	06 9c       	mov	r12,r3
8000ae16:	e0 a0 05 f8 	rcall	8000ba06 <__mcmp>
8000ae1a:	e0 89 00 0f 	brgt	8000ae38 <_dtoa_r+0x970>
8000ae1e:	c0 38       	rjmp	8000ae24 <_dtoa_r+0x95c>
8000ae20:	30 02       	mov	r2,0
8000ae22:	04 94       	mov	r4,r2
8000ae24:	40 ea       	lddsp	r10,sp[0x38]
8000ae26:	30 09       	mov	r9,0
8000ae28:	5c da       	com	r10
8000ae2a:	40 85       	lddsp	r5,sp[0x20]
8000ae2c:	50 6a       	stdsp	sp[0x18],r10
8000ae2e:	50 49       	stdsp	sp[0x10],r9
8000ae30:	c0 f9       	rjmp	8000b04e <_dtoa_r+0xb86>
8000ae32:	08 92       	mov	r2,r4
8000ae34:	40 66       	lddsp	r6,sp[0x18]
8000ae36:	04 94       	mov	r4,r2
8000ae38:	2f f6       	sub	r6,-1
8000ae3a:	50 66       	stdsp	sp[0x18],r6
8000ae3c:	33 18       	mov	r8,49
8000ae3e:	40 85       	lddsp	r5,sp[0x20]
8000ae40:	0a c8       	st.b	r5++,r8
8000ae42:	30 08       	mov	r8,0
8000ae44:	50 48       	stdsp	sp[0x10],r8
8000ae46:	c0 49       	rjmp	8000b04e <_dtoa_r+0xb86>
8000ae48:	40 dc       	lddsp	r12,sp[0x34]
8000ae4a:	58 0c       	cp.w	r12,0
8000ae4c:	e0 80 00 b5 	breq	8000afb6 <_dtoa_r+0xaee>
8000ae50:	58 05       	cp.w	r5,0
8000ae52:	e0 8a 00 08 	brle	8000ae62 <_dtoa_r+0x99a>
8000ae56:	08 9b       	mov	r11,r4
8000ae58:	0a 9a       	mov	r10,r5
8000ae5a:	0e 9c       	mov	r12,r7
8000ae5c:	e0 a0 06 f8 	rcall	8000bc4c <__lshift>
8000ae60:	18 94       	mov	r4,r12
8000ae62:	40 6b       	lddsp	r11,sp[0x18]
8000ae64:	58 0b       	cp.w	r11,0
8000ae66:	c0 31       	brne	8000ae6c <_dtoa_r+0x9a4>
8000ae68:	08 9c       	mov	r12,r4
8000ae6a:	c1 38       	rjmp	8000ae90 <_dtoa_r+0x9c8>
8000ae6c:	68 1b       	ld.w	r11,r4[0x4]
8000ae6e:	0e 9c       	mov	r12,r7
8000ae70:	e0 a0 05 fe 	rcall	8000ba6c <_Balloc>
8000ae74:	68 4a       	ld.w	r10,r4[0x10]
8000ae76:	18 95       	mov	r5,r12
8000ae78:	e8 cb ff f4 	sub	r11,r4,-12
8000ae7c:	2f ea       	sub	r10,-2
8000ae7e:	2f 4c       	sub	r12,-12
8000ae80:	a3 6a       	lsl	r10,0x2
8000ae82:	fe b0 e6 50 	rcall	80007b22 <memcpy>
8000ae86:	0a 9b       	mov	r11,r5
8000ae88:	30 1a       	mov	r10,1
8000ae8a:	0e 9c       	mov	r12,r7
8000ae8c:	e0 a0 06 e0 	rcall	8000bc4c <__lshift>
8000ae90:	50 44       	stdsp	sp[0x10],r4
8000ae92:	40 3a       	lddsp	r10,sp[0xc]
8000ae94:	30 19       	mov	r9,1
8000ae96:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
8000ae9a:	18 94       	mov	r4,r12
8000ae9c:	50 da       	stdsp	sp[0x34],r10
8000ae9e:	40 85       	lddsp	r5,sp[0x20]
8000aea0:	50 99       	stdsp	sp[0x24],r9
8000aea2:	50 26       	stdsp	sp[0x8],r6
8000aea4:	50 e1       	stdsp	sp[0x38],r1
8000aea6:	04 9b       	mov	r11,r2
8000aea8:	06 9c       	mov	r12,r3
8000aeaa:	fe b0 fa 7f 	rcall	8000a3a8 <quorem>
8000aeae:	40 4b       	lddsp	r11,sp[0x10]
8000aeb0:	f8 c0 ff d0 	sub	r0,r12,-48
8000aeb4:	06 9c       	mov	r12,r3
8000aeb6:	e0 a0 05 a8 	rcall	8000ba06 <__mcmp>
8000aeba:	08 9a       	mov	r10,r4
8000aebc:	50 6c       	stdsp	sp[0x18],r12
8000aebe:	04 9b       	mov	r11,r2
8000aec0:	0e 9c       	mov	r12,r7
8000aec2:	e0 a0 06 5d 	rcall	8000bb7c <__mdiff>
8000aec6:	18 91       	mov	r1,r12
8000aec8:	78 38       	ld.w	r8,r12[0xc]
8000aeca:	58 08       	cp.w	r8,0
8000aecc:	c0 30       	breq	8000aed2 <_dtoa_r+0xa0a>
8000aece:	30 16       	mov	r6,1
8000aed0:	c0 68       	rjmp	8000aedc <_dtoa_r+0xa14>
8000aed2:	18 9b       	mov	r11,r12
8000aed4:	06 9c       	mov	r12,r3
8000aed6:	e0 a0 05 98 	rcall	8000ba06 <__mcmp>
8000aeda:	18 96       	mov	r6,r12
8000aedc:	0e 9c       	mov	r12,r7
8000aede:	02 9b       	mov	r11,r1
8000aee0:	e0 a0 05 ac 	rcall	8000ba38 <_Bfree>
8000aee4:	40 cc       	lddsp	r12,sp[0x30]
8000aee6:	ed ec 10 08 	or	r8,r6,r12
8000aeea:	c0 d1       	brne	8000af04 <_dtoa_r+0xa3c>
8000aeec:	40 db       	lddsp	r11,sp[0x34]
8000aeee:	58 0b       	cp.w	r11,0
8000aef0:	c0 a1       	brne	8000af04 <_dtoa_r+0xa3c>
8000aef2:	40 26       	lddsp	r6,sp[0x8]
8000aef4:	e0 40 00 39 	cp.w	r0,57
8000aef8:	c3 00       	breq	8000af58 <_dtoa_r+0xa90>
8000aefa:	40 6a       	lddsp	r10,sp[0x18]
8000aefc:	58 0a       	cp.w	r10,0
8000aefe:	e0 89 00 24 	brgt	8000af46 <_dtoa_r+0xa7e>
8000af02:	c2 f8       	rjmp	8000af60 <_dtoa_r+0xa98>
8000af04:	40 69       	lddsp	r9,sp[0x18]
8000af06:	58 09       	cp.w	r9,0
8000af08:	c0 85       	brlt	8000af18 <_dtoa_r+0xa50>
8000af0a:	12 98       	mov	r8,r9
8000af0c:	40 cc       	lddsp	r12,sp[0x30]
8000af0e:	18 48       	or	r8,r12
8000af10:	c1 d1       	brne	8000af4a <_dtoa_r+0xa82>
8000af12:	40 db       	lddsp	r11,sp[0x34]
8000af14:	58 0b       	cp.w	r11,0
8000af16:	c1 a1       	brne	8000af4a <_dtoa_r+0xa82>
8000af18:	0c 99       	mov	r9,r6
8000af1a:	40 26       	lddsp	r6,sp[0x8]
8000af1c:	58 09       	cp.w	r9,0
8000af1e:	e0 8a 00 21 	brle	8000af60 <_dtoa_r+0xa98>
8000af22:	06 9b       	mov	r11,r3
8000af24:	30 1a       	mov	r10,1
8000af26:	0e 9c       	mov	r12,r7
8000af28:	e0 a0 06 92 	rcall	8000bc4c <__lshift>
8000af2c:	04 9b       	mov	r11,r2
8000af2e:	18 93       	mov	r3,r12
8000af30:	e0 a0 05 6b 	rcall	8000ba06 <__mcmp>
8000af34:	e0 89 00 06 	brgt	8000af40 <_dtoa_r+0xa78>
8000af38:	c1 41       	brne	8000af60 <_dtoa_r+0xa98>
8000af3a:	ed b0 00 00 	bld	r0,0x0
8000af3e:	c1 11       	brne	8000af60 <_dtoa_r+0xa98>
8000af40:	e0 40 00 39 	cp.w	r0,57
8000af44:	c0 a0       	breq	8000af58 <_dtoa_r+0xa90>
8000af46:	2f f0       	sub	r0,-1
8000af48:	c0 c8       	rjmp	8000af60 <_dtoa_r+0xa98>
8000af4a:	58 06       	cp.w	r6,0
8000af4c:	e0 8a 00 0c 	brle	8000af64 <_dtoa_r+0xa9c>
8000af50:	40 26       	lddsp	r6,sp[0x8]
8000af52:	e0 40 00 39 	cp.w	r0,57
8000af56:	c0 41       	brne	8000af5e <_dtoa_r+0xa96>
8000af58:	33 98       	mov	r8,57
8000af5a:	0a c8       	st.b	r5++,r8
8000af5c:	c6 78       	rjmp	8000b02a <_dtoa_r+0xb62>
8000af5e:	2f f0       	sub	r0,-1
8000af60:	0a c0       	st.b	r5++,r0
8000af62:	c7 58       	rjmp	8000b04c <_dtoa_r+0xb84>
8000af64:	0a c0       	st.b	r5++,r0
8000af66:	40 9a       	lddsp	r10,sp[0x24]
8000af68:	40 e9       	lddsp	r9,sp[0x38]
8000af6a:	12 3a       	cp.w	r10,r9
8000af6c:	c4 30       	breq	8000aff2 <_dtoa_r+0xb2a>
8000af6e:	06 9b       	mov	r11,r3
8000af70:	30 09       	mov	r9,0
8000af72:	30 aa       	mov	r10,10
8000af74:	0e 9c       	mov	r12,r7
8000af76:	e0 a0 07 37 	rcall	8000bde4 <__multadd>
8000af7a:	40 48       	lddsp	r8,sp[0x10]
8000af7c:	18 93       	mov	r3,r12
8000af7e:	08 38       	cp.w	r8,r4
8000af80:	c0 91       	brne	8000af92 <_dtoa_r+0xaca>
8000af82:	10 9b       	mov	r11,r8
8000af84:	30 09       	mov	r9,0
8000af86:	30 aa       	mov	r10,10
8000af88:	0e 9c       	mov	r12,r7
8000af8a:	e0 a0 07 2d 	rcall	8000bde4 <__multadd>
8000af8e:	50 4c       	stdsp	sp[0x10],r12
8000af90:	c0 e8       	rjmp	8000afac <_dtoa_r+0xae4>
8000af92:	40 4b       	lddsp	r11,sp[0x10]
8000af94:	30 09       	mov	r9,0
8000af96:	30 aa       	mov	r10,10
8000af98:	0e 9c       	mov	r12,r7
8000af9a:	e0 a0 07 25 	rcall	8000bde4 <__multadd>
8000af9e:	08 9b       	mov	r11,r4
8000afa0:	50 4c       	stdsp	sp[0x10],r12
8000afa2:	30 09       	mov	r9,0
8000afa4:	30 aa       	mov	r10,10
8000afa6:	0e 9c       	mov	r12,r7
8000afa8:	e0 a0 07 1e 	rcall	8000bde4 <__multadd>
8000afac:	18 94       	mov	r4,r12
8000afae:	40 9c       	lddsp	r12,sp[0x24]
8000afb0:	2f fc       	sub	r12,-1
8000afb2:	50 9c       	stdsp	sp[0x24],r12
8000afb4:	c7 9b       	rjmp	8000aea6 <_dtoa_r+0x9de>
8000afb6:	30 18       	mov	r8,1
8000afb8:	06 90       	mov	r0,r3
8000afba:	40 85       	lddsp	r5,sp[0x20]
8000afbc:	08 93       	mov	r3,r4
8000afbe:	0c 94       	mov	r4,r6
8000afc0:	10 96       	mov	r6,r8
8000afc2:	04 9b       	mov	r11,r2
8000afc4:	00 9c       	mov	r12,r0
8000afc6:	fe b0 f9 f1 	rcall	8000a3a8 <quorem>
8000afca:	2d 0c       	sub	r12,-48
8000afcc:	0a cc       	st.b	r5++,r12
8000afce:	02 36       	cp.w	r6,r1
8000afd0:	c0 a4       	brge	8000afe4 <_dtoa_r+0xb1c>
8000afd2:	00 9b       	mov	r11,r0
8000afd4:	30 09       	mov	r9,0
8000afd6:	30 aa       	mov	r10,10
8000afd8:	0e 9c       	mov	r12,r7
8000afda:	2f f6       	sub	r6,-1
8000afdc:	e0 a0 07 04 	rcall	8000bde4 <__multadd>
8000afe0:	18 90       	mov	r0,r12
8000afe2:	cf 0b       	rjmp	8000afc2 <_dtoa_r+0xafa>
8000afe4:	08 96       	mov	r6,r4
8000afe6:	30 0b       	mov	r11,0
8000afe8:	06 94       	mov	r4,r3
8000afea:	50 4b       	stdsp	sp[0x10],r11
8000afec:	00 93       	mov	r3,r0
8000afee:	18 90       	mov	r0,r12
8000aff0:	c0 28       	rjmp	8000aff4 <_dtoa_r+0xb2c>
8000aff2:	40 26       	lddsp	r6,sp[0x8]
8000aff4:	06 9b       	mov	r11,r3
8000aff6:	30 1a       	mov	r10,1
8000aff8:	0e 9c       	mov	r12,r7
8000affa:	e0 a0 06 29 	rcall	8000bc4c <__lshift>
8000affe:	04 9b       	mov	r11,r2
8000b000:	18 93       	mov	r3,r12
8000b002:	e0 a0 05 02 	rcall	8000ba06 <__mcmp>
8000b006:	e0 89 00 12 	brgt	8000b02a <_dtoa_r+0xb62>
8000b00a:	c1 b1       	brne	8000b040 <_dtoa_r+0xb78>
8000b00c:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
8000b010:	c0 d1       	brne	8000b02a <_dtoa_r+0xb62>
8000b012:	c1 78       	rjmp	8000b040 <_dtoa_r+0xb78>
8000b014:	40 89       	lddsp	r9,sp[0x20]
8000b016:	12 38       	cp.w	r8,r9
8000b018:	c0 30       	breq	8000b01e <_dtoa_r+0xb56>
8000b01a:	10 95       	mov	r5,r8
8000b01c:	c0 88       	rjmp	8000b02c <_dtoa_r+0xb64>
8000b01e:	2f f6       	sub	r6,-1
8000b020:	50 66       	stdsp	sp[0x18],r6
8000b022:	33 18       	mov	r8,49
8000b024:	40 8c       	lddsp	r12,sp[0x20]
8000b026:	b8 88       	st.b	r12[0x0],r8
8000b028:	c1 38       	rjmp	8000b04e <_dtoa_r+0xb86>
8000b02a:	33 9a       	mov	r10,57
8000b02c:	0a 98       	mov	r8,r5
8000b02e:	11 79       	ld.ub	r9,--r8
8000b030:	f4 09 18 00 	cp.b	r9,r10
8000b034:	cf 00       	breq	8000b014 <_dtoa_r+0xb4c>
8000b036:	2f f9       	sub	r9,-1
8000b038:	b0 89       	st.b	r8[0x0],r9
8000b03a:	c0 98       	rjmp	8000b04c <_dtoa_r+0xb84>
8000b03c:	10 95       	mov	r5,r8
8000b03e:	c0 28       	rjmp	8000b042 <_dtoa_r+0xb7a>
8000b040:	33 09       	mov	r9,48
8000b042:	0a 98       	mov	r8,r5
8000b044:	11 7a       	ld.ub	r10,--r8
8000b046:	f2 0a 18 00 	cp.b	r10,r9
8000b04a:	cf 90       	breq	8000b03c <_dtoa_r+0xb74>
8000b04c:	50 66       	stdsp	sp[0x18],r6
8000b04e:	04 9b       	mov	r11,r2
8000b050:	0e 9c       	mov	r12,r7
8000b052:	e0 a0 04 f3 	rcall	8000ba38 <_Bfree>
8000b056:	58 04       	cp.w	r4,0
8000b058:	c1 20       	breq	8000b07c <_dtoa_r+0xbb4>
8000b05a:	40 4b       	lddsp	r11,sp[0x10]
8000b05c:	08 3b       	cp.w	r11,r4
8000b05e:	5f 19       	srne	r9
8000b060:	58 0b       	cp.w	r11,0
8000b062:	5f 18       	srne	r8
8000b064:	f3 e8 00 08 	and	r8,r9,r8
8000b068:	c0 40       	breq	8000b070 <_dtoa_r+0xba8>
8000b06a:	0e 9c       	mov	r12,r7
8000b06c:	e0 a0 04 e6 	rcall	8000ba38 <_Bfree>
8000b070:	08 9b       	mov	r11,r4
8000b072:	0e 9c       	mov	r12,r7
8000b074:	e0 a0 04 e2 	rcall	8000ba38 <_Bfree>
8000b078:	c0 28       	rjmp	8000b07c <_dtoa_r+0xbb4>
8000b07a:	50 66       	stdsp	sp[0x18],r6
8000b07c:	0e 9c       	mov	r12,r7
8000b07e:	06 9b       	mov	r11,r3
8000b080:	e0 a0 04 dc 	rcall	8000ba38 <_Bfree>
8000b084:	30 08       	mov	r8,0
8000b086:	aa 88       	st.b	r5[0x0],r8
8000b088:	40 68       	lddsp	r8,sp[0x18]
8000b08a:	41 5a       	lddsp	r10,sp[0x54]
8000b08c:	2f f8       	sub	r8,-1
8000b08e:	41 29       	lddsp	r9,sp[0x48]
8000b090:	95 08       	st.w	r10[0x0],r8
8000b092:	40 8c       	lddsp	r12,sp[0x20]
8000b094:	58 09       	cp.w	r9,0
8000b096:	fb f8 10 12 	ld.wne	r8,sp[0x48]
8000b09a:	f1 f5 1a 00 	st.wne	r8[0x0],r5
8000b09e:	2e 6d       	sub	sp,-104
8000b0a0:	d8 32       	popm	r0-r7,pc
8000b0a2:	d7 03       	nop

8000b0a4 <__errno>:
8000b0a4:	e0 68 0a 48 	mov	r8,2632
8000b0a8:	70 0c       	ld.w	r12,r8[0x0]
8000b0aa:	2f 4c       	sub	r12,-12
8000b0ac:	5e fc       	retal	r12
8000b0ae:	d7 03       	nop

8000b0b0 <_fflush_r>:
8000b0b0:	d4 21       	pushm	r4-r7,lr
8000b0b2:	16 97       	mov	r7,r11
8000b0b4:	18 96       	mov	r6,r12
8000b0b6:	76 48       	ld.w	r8,r11[0x10]
8000b0b8:	58 08       	cp.w	r8,0
8000b0ba:	c7 f0       	breq	8000b1b8 <_fflush_r+0x108>
8000b0bc:	58 0c       	cp.w	r12,0
8000b0be:	c0 50       	breq	8000b0c8 <_fflush_r+0x18>
8000b0c0:	78 68       	ld.w	r8,r12[0x18]
8000b0c2:	58 08       	cp.w	r8,0
8000b0c4:	c0 21       	brne	8000b0c8 <_fflush_r+0x18>
8000b0c6:	cc dc       	rcall	8000b260 <__sinit>
8000b0c8:	fe c8 cd 2c 	sub	r8,pc,-13012
8000b0cc:	10 37       	cp.w	r7,r8
8000b0ce:	c0 31       	brne	8000b0d4 <_fflush_r+0x24>
8000b0d0:	6c 07       	ld.w	r7,r6[0x0]
8000b0d2:	c0 c8       	rjmp	8000b0ea <_fflush_r+0x3a>
8000b0d4:	fe c8 cd 18 	sub	r8,pc,-13032
8000b0d8:	10 37       	cp.w	r7,r8
8000b0da:	c0 31       	brne	8000b0e0 <_fflush_r+0x30>
8000b0dc:	6c 17       	ld.w	r7,r6[0x4]
8000b0de:	c0 68       	rjmp	8000b0ea <_fflush_r+0x3a>
8000b0e0:	fe c8 cd 04 	sub	r8,pc,-13052
8000b0e4:	10 37       	cp.w	r7,r8
8000b0e6:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b0ea:	8e 6a       	ld.sh	r10,r7[0xc]
8000b0ec:	14 98       	mov	r8,r10
8000b0ee:	ed ba 00 03 	bld	r10,0x3
8000b0f2:	c4 20       	breq	8000b176 <_fflush_r+0xc6>
8000b0f4:	ab ba       	sbr	r10,0xb
8000b0f6:	ae 6a       	st.h	r7[0xc],r10
8000b0f8:	6e 18       	ld.w	r8,r7[0x4]
8000b0fa:	58 08       	cp.w	r8,0
8000b0fc:	e0 89 00 06 	brgt	8000b108 <_fflush_r+0x58>
8000b100:	6f 08       	ld.w	r8,r7[0x40]
8000b102:	58 08       	cp.w	r8,0
8000b104:	e0 8a 00 5a 	brle	8000b1b8 <_fflush_r+0x108>
8000b108:	6e b8       	ld.w	r8,r7[0x2c]
8000b10a:	58 08       	cp.w	r8,0
8000b10c:	c5 60       	breq	8000b1b8 <_fflush_r+0x108>
8000b10e:	e2 1a 10 00 	andl	r10,0x1000,COH
8000b112:	c0 30       	breq	8000b118 <_fflush_r+0x68>
8000b114:	6f 55       	ld.w	r5,r7[0x54]
8000b116:	c0 f8       	rjmp	8000b134 <_fflush_r+0x84>
8000b118:	30 19       	mov	r9,1
8000b11a:	6e 8b       	ld.w	r11,r7[0x20]
8000b11c:	0c 9c       	mov	r12,r6
8000b11e:	5d 18       	icall	r8
8000b120:	18 95       	mov	r5,r12
8000b122:	5b fc       	cp.w	r12,-1
8000b124:	c0 81       	brne	8000b134 <_fflush_r+0x84>
8000b126:	6c 38       	ld.w	r8,r6[0xc]
8000b128:	59 d8       	cp.w	r8,29
8000b12a:	c4 70       	breq	8000b1b8 <_fflush_r+0x108>
8000b12c:	8e 68       	ld.sh	r8,r7[0xc]
8000b12e:	a7 a8       	sbr	r8,0x6
8000b130:	ae 68       	st.h	r7[0xc],r8
8000b132:	d8 22       	popm	r4-r7,pc
8000b134:	8e 68       	ld.sh	r8,r7[0xc]
8000b136:	ed b8 00 02 	bld	r8,0x2
8000b13a:	c0 91       	brne	8000b14c <_fflush_r+0x9c>
8000b13c:	6e 18       	ld.w	r8,r7[0x4]
8000b13e:	10 15       	sub	r5,r8
8000b140:	6e d8       	ld.w	r8,r7[0x34]
8000b142:	58 08       	cp.w	r8,0
8000b144:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000b148:	eb d8 e1 15 	subne	r5,r5,r8
8000b14c:	6e b8       	ld.w	r8,r7[0x2c]
8000b14e:	0c 9c       	mov	r12,r6
8000b150:	30 09       	mov	r9,0
8000b152:	0a 9a       	mov	r10,r5
8000b154:	6e 8b       	ld.w	r11,r7[0x20]
8000b156:	5d 18       	icall	r8
8000b158:	8e 68       	ld.sh	r8,r7[0xc]
8000b15a:	0a 3c       	cp.w	r12,r5
8000b15c:	c2 61       	brne	8000b1a8 <_fflush_r+0xf8>
8000b15e:	ab d8       	cbr	r8,0xb
8000b160:	30 0c       	mov	r12,0
8000b162:	6e 49       	ld.w	r9,r7[0x10]
8000b164:	ae 68       	st.h	r7[0xc],r8
8000b166:	8f 1c       	st.w	r7[0x4],r12
8000b168:	8f 09       	st.w	r7[0x0],r9
8000b16a:	ed b8 00 0c 	bld	r8,0xc
8000b16e:	c2 51       	brne	8000b1b8 <_fflush_r+0x108>
8000b170:	ef 45 00 54 	st.w	r7[84],r5
8000b174:	d8 22       	popm	r4-r7,pc
8000b176:	6e 45       	ld.w	r5,r7[0x10]
8000b178:	58 05       	cp.w	r5,0
8000b17a:	c1 f0       	breq	8000b1b8 <_fflush_r+0x108>
8000b17c:	6e 04       	ld.w	r4,r7[0x0]
8000b17e:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000b182:	8f 05       	st.w	r7[0x0],r5
8000b184:	f9 b8 01 00 	movne	r8,0
8000b188:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000b18c:	0a 14       	sub	r4,r5
8000b18e:	8f 28       	st.w	r7[0x8],r8
8000b190:	c1 18       	rjmp	8000b1b2 <_fflush_r+0x102>
8000b192:	08 99       	mov	r9,r4
8000b194:	0a 9a       	mov	r10,r5
8000b196:	6e a8       	ld.w	r8,r7[0x28]
8000b198:	6e 8b       	ld.w	r11,r7[0x20]
8000b19a:	0c 9c       	mov	r12,r6
8000b19c:	5d 18       	icall	r8
8000b19e:	18 14       	sub	r4,r12
8000b1a0:	58 0c       	cp.w	r12,0
8000b1a2:	e0 89 00 07 	brgt	8000b1b0 <_fflush_r+0x100>
8000b1a6:	8e 68       	ld.sh	r8,r7[0xc]
8000b1a8:	a7 a8       	sbr	r8,0x6
8000b1aa:	3f fc       	mov	r12,-1
8000b1ac:	ae 68       	st.h	r7[0xc],r8
8000b1ae:	d8 22       	popm	r4-r7,pc
8000b1b0:	18 05       	add	r5,r12
8000b1b2:	58 04       	cp.w	r4,0
8000b1b4:	fe 99 ff ef 	brgt	8000b192 <_fflush_r+0xe2>
8000b1b8:	d8 2a       	popm	r4-r7,pc,r12=0
8000b1ba:	d7 03       	nop

8000b1bc <__sfp_lock_acquire>:
8000b1bc:	5e fc       	retal	r12

8000b1be <__sfp_lock_release>:
8000b1be:	5e fc       	retal	r12

8000b1c0 <_cleanup_r>:
8000b1c0:	d4 01       	pushm	lr
8000b1c2:	fe cb f0 ae 	sub	r11,pc,-3922
8000b1c6:	e0 a0 02 f7 	rcall	8000b7b4 <_fwalk>
8000b1ca:	d8 02       	popm	pc

8000b1cc <__sfmoreglue>:
8000b1cc:	d4 21       	pushm	r4-r7,lr
8000b1ce:	16 95       	mov	r5,r11
8000b1d0:	f6 06 10 5c 	mul	r6,r11,92
8000b1d4:	ec cb ff f4 	sub	r11,r6,-12
8000b1d8:	fe b0 e2 76 	rcall	800076c4 <_malloc_r>
8000b1dc:	18 97       	mov	r7,r12
8000b1de:	c0 90       	breq	8000b1f0 <__sfmoreglue+0x24>
8000b1e0:	99 15       	st.w	r12[0x4],r5
8000b1e2:	30 0b       	mov	r11,0
8000b1e4:	2f 4c       	sub	r12,-12
8000b1e6:	0c 9a       	mov	r10,r6
8000b1e8:	8f 2c       	st.w	r7[0x8],r12
8000b1ea:	8f 0b       	st.w	r7[0x0],r11
8000b1ec:	fe b0 e5 3f 	rcall	80007c6a <memset>
8000b1f0:	0e 9c       	mov	r12,r7
8000b1f2:	d8 22       	popm	r4-r7,pc

8000b1f4 <__sfp>:
8000b1f4:	d4 21       	pushm	r4-r7,lr
8000b1f6:	fe c8 cd f6 	sub	r8,pc,-12810
8000b1fa:	18 96       	mov	r6,r12
8000b1fc:	70 07       	ld.w	r7,r8[0x0]
8000b1fe:	6e 68       	ld.w	r8,r7[0x18]
8000b200:	58 08       	cp.w	r8,0
8000b202:	c0 31       	brne	8000b208 <__sfp+0x14>
8000b204:	0e 9c       	mov	r12,r7
8000b206:	c2 dc       	rcall	8000b260 <__sinit>
8000b208:	ee c7 ff 28 	sub	r7,r7,-216
8000b20c:	30 05       	mov	r5,0
8000b20e:	6e 2c       	ld.w	r12,r7[0x8]
8000b210:	6e 18       	ld.w	r8,r7[0x4]
8000b212:	c0 68       	rjmp	8000b21e <__sfp+0x2a>
8000b214:	98 69       	ld.sh	r9,r12[0xc]
8000b216:	ea 09 19 00 	cp.h	r9,r5
8000b21a:	c1 10       	breq	8000b23c <__sfp+0x48>
8000b21c:	2a 4c       	sub	r12,-92
8000b21e:	20 18       	sub	r8,1
8000b220:	cf a7       	brpl	8000b214 <__sfp+0x20>
8000b222:	6e 08       	ld.w	r8,r7[0x0]
8000b224:	58 08       	cp.w	r8,0
8000b226:	c0 61       	brne	8000b232 <__sfp+0x3e>
8000b228:	30 4b       	mov	r11,4
8000b22a:	0c 9c       	mov	r12,r6
8000b22c:	cd 0f       	rcall	8000b1cc <__sfmoreglue>
8000b22e:	8f 0c       	st.w	r7[0x0],r12
8000b230:	c0 30       	breq	8000b236 <__sfp+0x42>
8000b232:	6e 07       	ld.w	r7,r7[0x0]
8000b234:	ce db       	rjmp	8000b20e <__sfp+0x1a>
8000b236:	30 c8       	mov	r8,12
8000b238:	8d 38       	st.w	r6[0xc],r8
8000b23a:	d8 22       	popm	r4-r7,pc
8000b23c:	30 08       	mov	r8,0
8000b23e:	f9 48 00 4c 	st.w	r12[76],r8
8000b242:	99 08       	st.w	r12[0x0],r8
8000b244:	99 28       	st.w	r12[0x8],r8
8000b246:	99 18       	st.w	r12[0x4],r8
8000b248:	99 48       	st.w	r12[0x10],r8
8000b24a:	99 58       	st.w	r12[0x14],r8
8000b24c:	99 68       	st.w	r12[0x18],r8
8000b24e:	99 d8       	st.w	r12[0x34],r8
8000b250:	99 e8       	st.w	r12[0x38],r8
8000b252:	f9 48 00 48 	st.w	r12[72],r8
8000b256:	3f f8       	mov	r8,-1
8000b258:	b8 78       	st.h	r12[0xe],r8
8000b25a:	30 18       	mov	r8,1
8000b25c:	b8 68       	st.h	r12[0xc],r8
8000b25e:	d8 22       	popm	r4-r7,pc

8000b260 <__sinit>:
8000b260:	d4 21       	pushm	r4-r7,lr
8000b262:	18 96       	mov	r6,r12
8000b264:	78 67       	ld.w	r7,r12[0x18]
8000b266:	58 07       	cp.w	r7,0
8000b268:	c4 91       	brne	8000b2fa <__sinit+0x9a>
8000b26a:	fe c8 00 aa 	sub	r8,pc,170
8000b26e:	30 15       	mov	r5,1
8000b270:	99 a8       	st.w	r12[0x28],r8
8000b272:	f9 47 00 d8 	st.w	r12[216],r7
8000b276:	f9 47 00 dc 	st.w	r12[220],r7
8000b27a:	f9 47 00 e0 	st.w	r12[224],r7
8000b27e:	99 65       	st.w	r12[0x18],r5
8000b280:	cb af       	rcall	8000b1f4 <__sfp>
8000b282:	8d 0c       	st.w	r6[0x0],r12
8000b284:	0c 9c       	mov	r12,r6
8000b286:	cb 7f       	rcall	8000b1f4 <__sfp>
8000b288:	8d 1c       	st.w	r6[0x4],r12
8000b28a:	0c 9c       	mov	r12,r6
8000b28c:	cb 4f       	rcall	8000b1f4 <__sfp>
8000b28e:	6c 09       	ld.w	r9,r6[0x0]
8000b290:	30 48       	mov	r8,4
8000b292:	93 07       	st.w	r9[0x0],r7
8000b294:	b2 68       	st.h	r9[0xc],r8
8000b296:	93 17       	st.w	r9[0x4],r7
8000b298:	93 27       	st.w	r9[0x8],r7
8000b29a:	6c 18       	ld.w	r8,r6[0x4]
8000b29c:	b2 77       	st.h	r9[0xe],r7
8000b29e:	93 47       	st.w	r9[0x10],r7
8000b2a0:	93 57       	st.w	r9[0x14],r7
8000b2a2:	93 67       	st.w	r9[0x18],r7
8000b2a4:	93 89       	st.w	r9[0x20],r9
8000b2a6:	91 07       	st.w	r8[0x0],r7
8000b2a8:	91 17       	st.w	r8[0x4],r7
8000b2aa:	91 27       	st.w	r8[0x8],r7
8000b2ac:	fe ce f3 24 	sub	lr,pc,-3292
8000b2b0:	fe cb f3 54 	sub	r11,pc,-3244
8000b2b4:	93 9e       	st.w	r9[0x24],lr
8000b2b6:	93 ab       	st.w	r9[0x28],r11
8000b2b8:	fe ca f3 7c 	sub	r10,pc,-3204
8000b2bc:	fe c4 f3 88 	sub	r4,pc,-3192
8000b2c0:	93 ba       	st.w	r9[0x2c],r10
8000b2c2:	93 c4       	st.w	r9[0x30],r4
8000b2c4:	30 99       	mov	r9,9
8000b2c6:	b0 69       	st.h	r8[0xc],r9
8000b2c8:	b0 75       	st.h	r8[0xe],r5
8000b2ca:	91 c4       	st.w	r8[0x30],r4
8000b2cc:	91 47       	st.w	r8[0x10],r7
8000b2ce:	91 57       	st.w	r8[0x14],r7
8000b2d0:	91 67       	st.w	r8[0x18],r7
8000b2d2:	91 88       	st.w	r8[0x20],r8
8000b2d4:	91 9e       	st.w	r8[0x24],lr
8000b2d6:	91 ab       	st.w	r8[0x28],r11
8000b2d8:	91 ba       	st.w	r8[0x2c],r10
8000b2da:	8d 2c       	st.w	r6[0x8],r12
8000b2dc:	31 28       	mov	r8,18
8000b2de:	99 07       	st.w	r12[0x0],r7
8000b2e0:	b8 68       	st.h	r12[0xc],r8
8000b2e2:	99 17       	st.w	r12[0x4],r7
8000b2e4:	99 27       	st.w	r12[0x8],r7
8000b2e6:	30 28       	mov	r8,2
8000b2e8:	b8 78       	st.h	r12[0xe],r8
8000b2ea:	99 c4       	st.w	r12[0x30],r4
8000b2ec:	99 67       	st.w	r12[0x18],r7
8000b2ee:	99 9e       	st.w	r12[0x24],lr
8000b2f0:	99 ab       	st.w	r12[0x28],r11
8000b2f2:	99 ba       	st.w	r12[0x2c],r10
8000b2f4:	99 47       	st.w	r12[0x10],r7
8000b2f6:	99 57       	st.w	r12[0x14],r7
8000b2f8:	99 8c       	st.w	r12[0x20],r12
8000b2fa:	d8 22       	popm	r4-r7,pc

8000b2fc <_malloc_trim_r>:
8000b2fc:	d4 21       	pushm	r4-r7,lr
8000b2fe:	16 95       	mov	r5,r11
8000b300:	18 97       	mov	r7,r12
8000b302:	fe b0 d7 7f 	rcall	80006200 <__malloc_lock>
8000b306:	e0 64 05 48 	mov	r4,1352
8000b30a:	68 28       	ld.w	r8,r4[0x8]
8000b30c:	70 16       	ld.w	r6,r8[0x4]
8000b30e:	e0 16 ff fc 	andl	r6,0xfffc
8000b312:	ec c8 ff 91 	sub	r8,r6,-111
8000b316:	f0 05 01 05 	sub	r5,r8,r5
8000b31a:	e0 15 ff 80 	andl	r5,0xff80
8000b31e:	ea c5 00 80 	sub	r5,r5,128
8000b322:	e0 45 00 7f 	cp.w	r5,127
8000b326:	e0 8a 00 25 	brle	8000b370 <_malloc_trim_r+0x74>
8000b32a:	30 0b       	mov	r11,0
8000b32c:	0e 9c       	mov	r12,r7
8000b32e:	fe b0 e6 05 	rcall	80007f38 <_sbrk_r>
8000b332:	68 28       	ld.w	r8,r4[0x8]
8000b334:	0c 08       	add	r8,r6
8000b336:	10 3c       	cp.w	r12,r8
8000b338:	c1 c1       	brne	8000b370 <_malloc_trim_r+0x74>
8000b33a:	ea 0b 11 00 	rsub	r11,r5,0
8000b33e:	0e 9c       	mov	r12,r7
8000b340:	fe b0 e5 fc 	rcall	80007f38 <_sbrk_r>
8000b344:	5b fc       	cp.w	r12,-1
8000b346:	c1 91       	brne	8000b378 <_malloc_trim_r+0x7c>
8000b348:	30 0b       	mov	r11,0
8000b34a:	0e 9c       	mov	r12,r7
8000b34c:	fe b0 e5 f6 	rcall	80007f38 <_sbrk_r>
8000b350:	68 28       	ld.w	r8,r4[0x8]
8000b352:	f8 08 01 09 	sub	r9,r12,r8
8000b356:	58 f9       	cp.w	r9,15
8000b358:	e0 8a 00 0c 	brle	8000b370 <_malloc_trim_r+0x74>
8000b35c:	a1 a9       	sbr	r9,0x0
8000b35e:	91 19       	st.w	r8[0x4],r9
8000b360:	e0 68 09 54 	mov	r8,2388
8000b364:	70 09       	ld.w	r9,r8[0x0]
8000b366:	e0 68 0d cc 	mov	r8,3532
8000b36a:	f8 09 01 09 	sub	r9,r12,r9
8000b36e:	91 09       	st.w	r8[0x0],r9
8000b370:	0e 9c       	mov	r12,r7
8000b372:	fe b0 d7 4d 	rcall	8000620c <__malloc_unlock>
8000b376:	d8 2a       	popm	r4-r7,pc,r12=0
8000b378:	68 28       	ld.w	r8,r4[0x8]
8000b37a:	0a 16       	sub	r6,r5
8000b37c:	a1 a6       	sbr	r6,0x0
8000b37e:	91 16       	st.w	r8[0x4],r6
8000b380:	e0 68 0d cc 	mov	r8,3532
8000b384:	70 09       	ld.w	r9,r8[0x0]
8000b386:	0a 19       	sub	r9,r5
8000b388:	0e 9c       	mov	r12,r7
8000b38a:	91 09       	st.w	r8[0x0],r9
8000b38c:	fe b0 d7 40 	rcall	8000620c <__malloc_unlock>
8000b390:	da 2a       	popm	r4-r7,pc,r12=1
8000b392:	d7 03       	nop

8000b394 <_free_r>:
8000b394:	d4 21       	pushm	r4-r7,lr
8000b396:	16 96       	mov	r6,r11
8000b398:	18 97       	mov	r7,r12
8000b39a:	58 0b       	cp.w	r11,0
8000b39c:	e0 80 00 c0 	breq	8000b51c <_free_r+0x188>
8000b3a0:	fe b0 d7 30 	rcall	80006200 <__malloc_lock>
8000b3a4:	20 86       	sub	r6,8
8000b3a6:	e0 6a 05 48 	mov	r10,1352
8000b3aa:	6c 18       	ld.w	r8,r6[0x4]
8000b3ac:	74 2e       	ld.w	lr,r10[0x8]
8000b3ae:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
8000b3b2:	a1 c8       	cbr	r8,0x0
8000b3b4:	ec 08 00 09 	add	r9,r6,r8
8000b3b8:	72 1b       	ld.w	r11,r9[0x4]
8000b3ba:	e0 1b ff fc 	andl	r11,0xfffc
8000b3be:	1c 39       	cp.w	r9,lr
8000b3c0:	c1 e1       	brne	8000b3fc <_free_r+0x68>
8000b3c2:	f6 08 00 08 	add	r8,r11,r8
8000b3c6:	58 0c       	cp.w	r12,0
8000b3c8:	c0 81       	brne	8000b3d8 <_free_r+0x44>
8000b3ca:	6c 09       	ld.w	r9,r6[0x0]
8000b3cc:	12 16       	sub	r6,r9
8000b3ce:	12 08       	add	r8,r9
8000b3d0:	6c 3b       	ld.w	r11,r6[0xc]
8000b3d2:	6c 29       	ld.w	r9,r6[0x8]
8000b3d4:	97 29       	st.w	r11[0x8],r9
8000b3d6:	93 3b       	st.w	r9[0xc],r11
8000b3d8:	10 99       	mov	r9,r8
8000b3da:	95 26       	st.w	r10[0x8],r6
8000b3dc:	a1 a9       	sbr	r9,0x0
8000b3de:	8d 19       	st.w	r6[0x4],r9
8000b3e0:	e0 69 09 50 	mov	r9,2384
8000b3e4:	72 09       	ld.w	r9,r9[0x0]
8000b3e6:	12 38       	cp.w	r8,r9
8000b3e8:	c0 63       	brcs	8000b3f4 <_free_r+0x60>
8000b3ea:	e0 68 0d c8 	mov	r8,3528
8000b3ee:	0e 9c       	mov	r12,r7
8000b3f0:	70 0b       	ld.w	r11,r8[0x0]
8000b3f2:	c8 5f       	rcall	8000b2fc <_malloc_trim_r>
8000b3f4:	0e 9c       	mov	r12,r7
8000b3f6:	fe b0 d7 0b 	rcall	8000620c <__malloc_unlock>
8000b3fa:	d8 22       	popm	r4-r7,pc
8000b3fc:	93 1b       	st.w	r9[0x4],r11
8000b3fe:	58 0c       	cp.w	r12,0
8000b400:	c0 30       	breq	8000b406 <_free_r+0x72>
8000b402:	30 0c       	mov	r12,0
8000b404:	c1 08       	rjmp	8000b424 <_free_r+0x90>
8000b406:	6c 0e       	ld.w	lr,r6[0x0]
8000b408:	f4 c5 ff f8 	sub	r5,r10,-8
8000b40c:	1c 16       	sub	r6,lr
8000b40e:	1c 08       	add	r8,lr
8000b410:	6c 2e       	ld.w	lr,r6[0x8]
8000b412:	0a 3e       	cp.w	lr,r5
8000b414:	f9 bc 00 01 	moveq	r12,1
8000b418:	ed f5 10 03 	ld.wne	r5,r6[0xc]
8000b41c:	eb fe 1a 02 	st.wne	r5[0x8],lr
8000b420:	fd f5 1a 03 	st.wne	lr[0xc],r5
8000b424:	f2 0b 00 0e 	add	lr,r9,r11
8000b428:	7c 1e       	ld.w	lr,lr[0x4]
8000b42a:	ed be 00 00 	bld	lr,0x0
8000b42e:	c1 40       	breq	8000b456 <_free_r+0xc2>
8000b430:	16 08       	add	r8,r11
8000b432:	58 0c       	cp.w	r12,0
8000b434:	c0 d1       	brne	8000b44e <_free_r+0xba>
8000b436:	e0 6e 05 48 	mov	lr,1352
8000b43a:	72 2b       	ld.w	r11,r9[0x8]
8000b43c:	2f 8e       	sub	lr,-8
8000b43e:	1c 3b       	cp.w	r11,lr
8000b440:	c0 71       	brne	8000b44e <_free_r+0xba>
8000b442:	97 36       	st.w	r11[0xc],r6
8000b444:	97 26       	st.w	r11[0x8],r6
8000b446:	8d 2b       	st.w	r6[0x8],r11
8000b448:	8d 3b       	st.w	r6[0xc],r11
8000b44a:	30 1c       	mov	r12,1
8000b44c:	c0 58       	rjmp	8000b456 <_free_r+0xc2>
8000b44e:	72 2b       	ld.w	r11,r9[0x8]
8000b450:	72 39       	ld.w	r9,r9[0xc]
8000b452:	93 2b       	st.w	r9[0x8],r11
8000b454:	97 39       	st.w	r11[0xc],r9
8000b456:	10 99       	mov	r9,r8
8000b458:	ec 08 09 08 	st.w	r6[r8],r8
8000b45c:	a1 a9       	sbr	r9,0x0
8000b45e:	8d 19       	st.w	r6[0x4],r9
8000b460:	58 0c       	cp.w	r12,0
8000b462:	c5 a1       	brne	8000b516 <_free_r+0x182>
8000b464:	e0 48 01 ff 	cp.w	r8,511
8000b468:	e0 8b 00 13 	brhi	8000b48e <_free_r+0xfa>
8000b46c:	a3 98       	lsr	r8,0x3
8000b46e:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000b472:	72 2b       	ld.w	r11,r9[0x8]
8000b474:	8d 39       	st.w	r6[0xc],r9
8000b476:	8d 2b       	st.w	r6[0x8],r11
8000b478:	97 36       	st.w	r11[0xc],r6
8000b47a:	93 26       	st.w	r9[0x8],r6
8000b47c:	a3 48       	asr	r8,0x2
8000b47e:	74 19       	ld.w	r9,r10[0x4]
8000b480:	30 1b       	mov	r11,1
8000b482:	f6 08 09 48 	lsl	r8,r11,r8
8000b486:	f3 e8 10 08 	or	r8,r9,r8
8000b48a:	95 18       	st.w	r10[0x4],r8
8000b48c:	c4 58       	rjmp	8000b516 <_free_r+0x182>
8000b48e:	f0 0b 16 09 	lsr	r11,r8,0x9
8000b492:	58 4b       	cp.w	r11,4
8000b494:	e0 8b 00 06 	brhi	8000b4a0 <_free_r+0x10c>
8000b498:	f0 0b 16 06 	lsr	r11,r8,0x6
8000b49c:	2c 8b       	sub	r11,-56
8000b49e:	c2 08       	rjmp	8000b4de <_free_r+0x14a>
8000b4a0:	59 4b       	cp.w	r11,20
8000b4a2:	e0 8b 00 04 	brhi	8000b4aa <_free_r+0x116>
8000b4a6:	2a 5b       	sub	r11,-91
8000b4a8:	c1 b8       	rjmp	8000b4de <_free_r+0x14a>
8000b4aa:	e0 4b 00 54 	cp.w	r11,84
8000b4ae:	e0 8b 00 06 	brhi	8000b4ba <_free_r+0x126>
8000b4b2:	f0 0b 16 0c 	lsr	r11,r8,0xc
8000b4b6:	29 2b       	sub	r11,-110
8000b4b8:	c1 38       	rjmp	8000b4de <_free_r+0x14a>
8000b4ba:	e0 4b 01 54 	cp.w	r11,340
8000b4be:	e0 8b 00 06 	brhi	8000b4ca <_free_r+0x136>
8000b4c2:	f0 0b 16 0f 	lsr	r11,r8,0xf
8000b4c6:	28 9b       	sub	r11,-119
8000b4c8:	c0 b8       	rjmp	8000b4de <_free_r+0x14a>
8000b4ca:	e0 4b 05 54 	cp.w	r11,1364
8000b4ce:	e0 88 00 05 	brls	8000b4d8 <_free_r+0x144>
8000b4d2:	37 eb       	mov	r11,126
8000b4d4:	c0 58       	rjmp	8000b4de <_free_r+0x14a>
8000b4d6:	d7 03       	nop
8000b4d8:	f0 0b 16 12 	lsr	r11,r8,0x12
8000b4dc:	28 4b       	sub	r11,-124
8000b4de:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
8000b4e2:	78 29       	ld.w	r9,r12[0x8]
8000b4e4:	18 39       	cp.w	r9,r12
8000b4e6:	c0 e1       	brne	8000b502 <_free_r+0x16e>
8000b4e8:	74 18       	ld.w	r8,r10[0x4]
8000b4ea:	a3 4b       	asr	r11,0x2
8000b4ec:	30 1c       	mov	r12,1
8000b4ee:	f8 0b 09 4b 	lsl	r11,r12,r11
8000b4f2:	f1 eb 10 0b 	or	r11,r8,r11
8000b4f6:	12 98       	mov	r8,r9
8000b4f8:	95 1b       	st.w	r10[0x4],r11
8000b4fa:	c0 a8       	rjmp	8000b50e <_free_r+0x17a>
8000b4fc:	72 29       	ld.w	r9,r9[0x8]
8000b4fe:	18 39       	cp.w	r9,r12
8000b500:	c0 60       	breq	8000b50c <_free_r+0x178>
8000b502:	72 1a       	ld.w	r10,r9[0x4]
8000b504:	e0 1a ff fc 	andl	r10,0xfffc
8000b508:	14 38       	cp.w	r8,r10
8000b50a:	cf 93       	brcs	8000b4fc <_free_r+0x168>
8000b50c:	72 38       	ld.w	r8,r9[0xc]
8000b50e:	8d 38       	st.w	r6[0xc],r8
8000b510:	8d 29       	st.w	r6[0x8],r9
8000b512:	93 36       	st.w	r9[0xc],r6
8000b514:	91 26       	st.w	r8[0x8],r6
8000b516:	0e 9c       	mov	r12,r7
8000b518:	fe b0 d6 7a 	rcall	8000620c <__malloc_unlock>
8000b51c:	d8 22       	popm	r4-r7,pc
8000b51e:	d7 03       	nop

8000b520 <__sfvwrite_r>:
8000b520:	d4 31       	pushm	r0-r7,lr
8000b522:	20 3d       	sub	sp,12
8000b524:	14 94       	mov	r4,r10
8000b526:	18 95       	mov	r5,r12
8000b528:	16 97       	mov	r7,r11
8000b52a:	74 28       	ld.w	r8,r10[0x8]
8000b52c:	58 08       	cp.w	r8,0
8000b52e:	e0 80 01 40 	breq	8000b7ae <__sfvwrite_r+0x28e>
8000b532:	96 68       	ld.sh	r8,r11[0xc]
8000b534:	ed b8 00 03 	bld	r8,0x3
8000b538:	c0 41       	brne	8000b540 <__sfvwrite_r+0x20>
8000b53a:	76 48       	ld.w	r8,r11[0x10]
8000b53c:	58 08       	cp.w	r8,0
8000b53e:	c0 c1       	brne	8000b556 <__sfvwrite_r+0x36>
8000b540:	0e 9b       	mov	r11,r7
8000b542:	0a 9c       	mov	r12,r5
8000b544:	fe b0 f6 c4 	rcall	8000a2cc <__swsetup_r>
8000b548:	c0 70       	breq	8000b556 <__sfvwrite_r+0x36>
8000b54a:	8e 68       	ld.sh	r8,r7[0xc]
8000b54c:	a7 a8       	sbr	r8,0x6
8000b54e:	ae 68       	st.h	r7[0xc],r8
8000b550:	30 98       	mov	r8,9
8000b552:	8b 38       	st.w	r5[0xc],r8
8000b554:	c2 b9       	rjmp	8000b7aa <__sfvwrite_r+0x28a>
8000b556:	8e 63       	ld.sh	r3,r7[0xc]
8000b558:	68 00       	ld.w	r0,r4[0x0]
8000b55a:	06 96       	mov	r6,r3
8000b55c:	e2 16 00 02 	andl	r6,0x2,COH
8000b560:	c2 10       	breq	8000b5a2 <__sfvwrite_r+0x82>
8000b562:	30 03       	mov	r3,0
8000b564:	e0 62 04 00 	mov	r2,1024
8000b568:	06 96       	mov	r6,r3
8000b56a:	c0 48       	rjmp	8000b572 <__sfvwrite_r+0x52>
8000b56c:	60 03       	ld.w	r3,r0[0x0]
8000b56e:	60 16       	ld.w	r6,r0[0x4]
8000b570:	2f 80       	sub	r0,-8
8000b572:	58 06       	cp.w	r6,0
8000b574:	cf c0       	breq	8000b56c <__sfvwrite_r+0x4c>
8000b576:	e0 46 04 00 	cp.w	r6,1024
8000b57a:	ec 09 17 80 	movls	r9,r6
8000b57e:	e4 09 17 b0 	movhi	r9,r2
8000b582:	06 9a       	mov	r10,r3
8000b584:	6e a8       	ld.w	r8,r7[0x28]
8000b586:	6e 8b       	ld.w	r11,r7[0x20]
8000b588:	0a 9c       	mov	r12,r5
8000b58a:	5d 18       	icall	r8
8000b58c:	18 16       	sub	r6,r12
8000b58e:	58 0c       	cp.w	r12,0
8000b590:	e0 8a 01 0a 	brle	8000b7a4 <__sfvwrite_r+0x284>
8000b594:	68 28       	ld.w	r8,r4[0x8]
8000b596:	18 18       	sub	r8,r12
8000b598:	89 28       	st.w	r4[0x8],r8
8000b59a:	e0 80 01 0a 	breq	8000b7ae <__sfvwrite_r+0x28e>
8000b59e:	18 03       	add	r3,r12
8000b5a0:	ce 9b       	rjmp	8000b572 <__sfvwrite_r+0x52>
8000b5a2:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
8000b5a6:	c0 70       	breq	8000b5b4 <__sfvwrite_r+0x94>
8000b5a8:	50 06       	stdsp	sp[0x0],r6
8000b5aa:	0c 93       	mov	r3,r6
8000b5ac:	0c 91       	mov	r1,r6
8000b5ae:	50 15       	stdsp	sp[0x4],r5
8000b5b0:	08 92       	mov	r2,r4
8000b5b2:	c9 c8       	rjmp	8000b6ea <__sfvwrite_r+0x1ca>
8000b5b4:	06 96       	mov	r6,r3
8000b5b6:	08 91       	mov	r1,r4
8000b5b8:	c0 48       	rjmp	8000b5c0 <__sfvwrite_r+0xa0>
8000b5ba:	60 03       	ld.w	r3,r0[0x0]
8000b5bc:	60 16       	ld.w	r6,r0[0x4]
8000b5be:	2f 80       	sub	r0,-8
8000b5c0:	58 06       	cp.w	r6,0
8000b5c2:	cf c0       	breq	8000b5ba <__sfvwrite_r+0x9a>
8000b5c4:	8e 68       	ld.sh	r8,r7[0xc]
8000b5c6:	6e 24       	ld.w	r4,r7[0x8]
8000b5c8:	10 99       	mov	r9,r8
8000b5ca:	e2 19 02 00 	andl	r9,0x200,COH
8000b5ce:	c5 50       	breq	8000b678 <__sfvwrite_r+0x158>
8000b5d0:	08 36       	cp.w	r6,r4
8000b5d2:	c4 43       	brcs	8000b65a <__sfvwrite_r+0x13a>
8000b5d4:	10 99       	mov	r9,r8
8000b5d6:	e2 19 04 80 	andl	r9,0x480,COH
8000b5da:	c4 00       	breq	8000b65a <__sfvwrite_r+0x13a>
8000b5dc:	6e 4b       	ld.w	r11,r7[0x10]
8000b5de:	6e 09       	ld.w	r9,r7[0x0]
8000b5e0:	16 19       	sub	r9,r11
8000b5e2:	50 09       	stdsp	sp[0x0],r9
8000b5e4:	6e 59       	ld.w	r9,r7[0x14]
8000b5e6:	10 9c       	mov	r12,r8
8000b5e8:	f2 09 00 1a 	add	r10,r9,r9<<0x1
8000b5ec:	30 28       	mov	r8,2
8000b5ee:	f4 08 0c 08 	divs	r8,r10,r8
8000b5f2:	fa e9 00 04 	st.d	sp[4],r8
8000b5f6:	10 94       	mov	r4,r8
8000b5f8:	40 09       	lddsp	r9,sp[0x0]
8000b5fa:	e2 1c 04 00 	andl	r12,0x400,COH
8000b5fe:	2f f9       	sub	r9,-1
8000b600:	0c 09       	add	r9,r6
8000b602:	12 38       	cp.w	r8,r9
8000b604:	f2 04 17 30 	movlo	r4,r9
8000b608:	58 0c       	cp.w	r12,0
8000b60a:	c1 10       	breq	8000b62c <__sfvwrite_r+0x10c>
8000b60c:	08 9b       	mov	r11,r4
8000b60e:	0a 9c       	mov	r12,r5
8000b610:	fe b0 e0 5a 	rcall	800076c4 <_malloc_r>
8000b614:	18 92       	mov	r2,r12
8000b616:	c1 40       	breq	8000b63e <__sfvwrite_r+0x11e>
8000b618:	40 0a       	lddsp	r10,sp[0x0]
8000b61a:	6e 4b       	ld.w	r11,r7[0x10]
8000b61c:	fe b0 e2 83 	rcall	80007b22 <memcpy>
8000b620:	8e 68       	ld.sh	r8,r7[0xc]
8000b622:	e0 18 fb 7f 	andl	r8,0xfb7f
8000b626:	a7 b8       	sbr	r8,0x7
8000b628:	ae 68       	st.h	r7[0xc],r8
8000b62a:	c0 d8       	rjmp	8000b644 <__sfvwrite_r+0x124>
8000b62c:	08 9a       	mov	r10,r4
8000b62e:	0a 9c       	mov	r12,r5
8000b630:	fe b0 e3 24 	rcall	80007c78 <_realloc_r>
8000b634:	18 92       	mov	r2,r12
8000b636:	c0 71       	brne	8000b644 <__sfvwrite_r+0x124>
8000b638:	6e 4b       	ld.w	r11,r7[0x10]
8000b63a:	0a 9c       	mov	r12,r5
8000b63c:	ca ce       	rcall	8000b394 <_free_r>
8000b63e:	30 c8       	mov	r8,12
8000b640:	8b 38       	st.w	r5[0xc],r8
8000b642:	cb 18       	rjmp	8000b7a4 <__sfvwrite_r+0x284>
8000b644:	40 0a       	lddsp	r10,sp[0x0]
8000b646:	40 09       	lddsp	r9,sp[0x0]
8000b648:	e8 0a 01 0a 	sub	r10,r4,r10
8000b64c:	e4 09 00 08 	add	r8,r2,r9
8000b650:	8f 54       	st.w	r7[0x14],r4
8000b652:	8f 2a       	st.w	r7[0x8],r10
8000b654:	8f 08       	st.w	r7[0x0],r8
8000b656:	8f 42       	st.w	r7[0x10],r2
8000b658:	0c 94       	mov	r4,r6
8000b65a:	08 36       	cp.w	r6,r4
8000b65c:	ec 04 17 30 	movlo	r4,r6
8000b660:	06 9b       	mov	r11,r3
8000b662:	08 9a       	mov	r10,r4
8000b664:	6e 0c       	ld.w	r12,r7[0x0]
8000b666:	c3 ad       	rcall	8000b8da <memmove>
8000b668:	6e 08       	ld.w	r8,r7[0x0]
8000b66a:	08 08       	add	r8,r4
8000b66c:	8f 08       	st.w	r7[0x0],r8
8000b66e:	6e 28       	ld.w	r8,r7[0x8]
8000b670:	08 18       	sub	r8,r4
8000b672:	0c 94       	mov	r4,r6
8000b674:	8f 28       	st.w	r7[0x8],r8
8000b676:	c2 e8       	rjmp	8000b6d2 <__sfvwrite_r+0x1b2>
8000b678:	08 36       	cp.w	r6,r4
8000b67a:	5f ba       	srhi	r10
8000b67c:	6e 0c       	ld.w	r12,r7[0x0]
8000b67e:	6e 48       	ld.w	r8,r7[0x10]
8000b680:	10 3c       	cp.w	r12,r8
8000b682:	5f b8       	srhi	r8
8000b684:	f5 e8 00 08 	and	r8,r10,r8
8000b688:	f2 08 18 00 	cp.b	r8,r9
8000b68c:	c0 d0       	breq	8000b6a6 <__sfvwrite_r+0x186>
8000b68e:	06 9b       	mov	r11,r3
8000b690:	08 9a       	mov	r10,r4
8000b692:	c2 4d       	rcall	8000b8da <memmove>
8000b694:	6e 08       	ld.w	r8,r7[0x0]
8000b696:	08 08       	add	r8,r4
8000b698:	0e 9b       	mov	r11,r7
8000b69a:	8f 08       	st.w	r7[0x0],r8
8000b69c:	0a 9c       	mov	r12,r5
8000b69e:	fe b0 fd 09 	rcall	8000b0b0 <_fflush_r>
8000b6a2:	c1 80       	breq	8000b6d2 <__sfvwrite_r+0x1b2>
8000b6a4:	c8 08       	rjmp	8000b7a4 <__sfvwrite_r+0x284>
8000b6a6:	6e 59       	ld.w	r9,r7[0x14]
8000b6a8:	12 36       	cp.w	r6,r9
8000b6aa:	c0 a3       	brcs	8000b6be <__sfvwrite_r+0x19e>
8000b6ac:	6e a8       	ld.w	r8,r7[0x28]
8000b6ae:	06 9a       	mov	r10,r3
8000b6b0:	6e 8b       	ld.w	r11,r7[0x20]
8000b6b2:	0a 9c       	mov	r12,r5
8000b6b4:	5d 18       	icall	r8
8000b6b6:	18 94       	mov	r4,r12
8000b6b8:	e0 89 00 0d 	brgt	8000b6d2 <__sfvwrite_r+0x1b2>
8000b6bc:	c7 48       	rjmp	8000b7a4 <__sfvwrite_r+0x284>
8000b6be:	0c 9a       	mov	r10,r6
8000b6c0:	06 9b       	mov	r11,r3
8000b6c2:	c0 cd       	rcall	8000b8da <memmove>
8000b6c4:	6e 08       	ld.w	r8,r7[0x0]
8000b6c6:	0c 08       	add	r8,r6
8000b6c8:	0c 94       	mov	r4,r6
8000b6ca:	8f 08       	st.w	r7[0x0],r8
8000b6cc:	6e 28       	ld.w	r8,r7[0x8]
8000b6ce:	0c 18       	sub	r8,r6
8000b6d0:	8f 28       	st.w	r7[0x8],r8
8000b6d2:	62 28       	ld.w	r8,r1[0x8]
8000b6d4:	08 18       	sub	r8,r4
8000b6d6:	83 28       	st.w	r1[0x8],r8
8000b6d8:	c6 b0       	breq	8000b7ae <__sfvwrite_r+0x28e>
8000b6da:	08 16       	sub	r6,r4
8000b6dc:	08 03       	add	r3,r4
8000b6de:	c7 1b       	rjmp	8000b5c0 <__sfvwrite_r+0xa0>
8000b6e0:	60 03       	ld.w	r3,r0[0x0]
8000b6e2:	60 11       	ld.w	r1,r0[0x4]
8000b6e4:	30 08       	mov	r8,0
8000b6e6:	2f 80       	sub	r0,-8
8000b6e8:	50 08       	stdsp	sp[0x0],r8
8000b6ea:	58 01       	cp.w	r1,0
8000b6ec:	cf a0       	breq	8000b6e0 <__sfvwrite_r+0x1c0>
8000b6ee:	40 0a       	lddsp	r10,sp[0x0]
8000b6f0:	58 0a       	cp.w	r10,0
8000b6f2:	c1 41       	brne	8000b71a <__sfvwrite_r+0x1fa>
8000b6f4:	e2 c6 ff ff 	sub	r6,r1,-1
8000b6f8:	02 9a       	mov	r10,r1
8000b6fa:	30 ab       	mov	r11,10
8000b6fc:	06 9c       	mov	r12,r3
8000b6fe:	ce 3c       	rcall	8000b8c4 <memchr>
8000b700:	f8 c8 ff ff 	sub	r8,r12,-1
8000b704:	58 0c       	cp.w	r12,0
8000b706:	f1 d3 e1 16 	subne	r6,r8,r3
8000b70a:	f9 b9 01 01 	movne	r9,1
8000b70e:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000b712:	f9 b8 00 01 	moveq	r8,1
8000b716:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000b71a:	02 36       	cp.w	r6,r1
8000b71c:	ec 04 17 80 	movls	r4,r6
8000b720:	e2 04 17 b0 	movhi	r4,r1
8000b724:	6e 59       	ld.w	r9,r7[0x14]
8000b726:	6e 25       	ld.w	r5,r7[0x8]
8000b728:	f2 05 00 05 	add	r5,r9,r5
8000b72c:	0a 34       	cp.w	r4,r5
8000b72e:	5f 9a       	srgt	r10
8000b730:	6e 0c       	ld.w	r12,r7[0x0]
8000b732:	6e 48       	ld.w	r8,r7[0x10]
8000b734:	10 3c       	cp.w	r12,r8
8000b736:	5f b8       	srhi	r8
8000b738:	f5 e8 00 08 	and	r8,r10,r8
8000b73c:	30 0a       	mov	r10,0
8000b73e:	f4 08 18 00 	cp.b	r8,r10
8000b742:	c0 d0       	breq	8000b75c <__sfvwrite_r+0x23c>
8000b744:	06 9b       	mov	r11,r3
8000b746:	0a 9a       	mov	r10,r5
8000b748:	cc 9c       	rcall	8000b8da <memmove>
8000b74a:	6e 08       	ld.w	r8,r7[0x0]
8000b74c:	0a 08       	add	r8,r5
8000b74e:	0e 9b       	mov	r11,r7
8000b750:	8f 08       	st.w	r7[0x0],r8
8000b752:	40 1c       	lddsp	r12,sp[0x4]
8000b754:	fe b0 fc ae 	rcall	8000b0b0 <_fflush_r>
8000b758:	c1 70       	breq	8000b786 <__sfvwrite_r+0x266>
8000b75a:	c2 58       	rjmp	8000b7a4 <__sfvwrite_r+0x284>
8000b75c:	12 34       	cp.w	r4,r9
8000b75e:	c0 a5       	brlt	8000b772 <__sfvwrite_r+0x252>
8000b760:	6e a8       	ld.w	r8,r7[0x28]
8000b762:	06 9a       	mov	r10,r3
8000b764:	6e 8b       	ld.w	r11,r7[0x20]
8000b766:	40 1c       	lddsp	r12,sp[0x4]
8000b768:	5d 18       	icall	r8
8000b76a:	18 95       	mov	r5,r12
8000b76c:	e0 89 00 0d 	brgt	8000b786 <__sfvwrite_r+0x266>
8000b770:	c1 a8       	rjmp	8000b7a4 <__sfvwrite_r+0x284>
8000b772:	08 9a       	mov	r10,r4
8000b774:	06 9b       	mov	r11,r3
8000b776:	cb 2c       	rcall	8000b8da <memmove>
8000b778:	6e 08       	ld.w	r8,r7[0x0]
8000b77a:	08 08       	add	r8,r4
8000b77c:	08 95       	mov	r5,r4
8000b77e:	8f 08       	st.w	r7[0x0],r8
8000b780:	6e 28       	ld.w	r8,r7[0x8]
8000b782:	08 18       	sub	r8,r4
8000b784:	8f 28       	st.w	r7[0x8],r8
8000b786:	0a 16       	sub	r6,r5
8000b788:	c0 71       	brne	8000b796 <__sfvwrite_r+0x276>
8000b78a:	0e 9b       	mov	r11,r7
8000b78c:	40 1c       	lddsp	r12,sp[0x4]
8000b78e:	fe b0 fc 91 	rcall	8000b0b0 <_fflush_r>
8000b792:	c0 91       	brne	8000b7a4 <__sfvwrite_r+0x284>
8000b794:	50 06       	stdsp	sp[0x0],r6
8000b796:	64 28       	ld.w	r8,r2[0x8]
8000b798:	0a 18       	sub	r8,r5
8000b79a:	85 28       	st.w	r2[0x8],r8
8000b79c:	c0 90       	breq	8000b7ae <__sfvwrite_r+0x28e>
8000b79e:	0a 11       	sub	r1,r5
8000b7a0:	0a 03       	add	r3,r5
8000b7a2:	ca 4b       	rjmp	8000b6ea <__sfvwrite_r+0x1ca>
8000b7a4:	8e 68       	ld.sh	r8,r7[0xc]
8000b7a6:	a7 a8       	sbr	r8,0x6
8000b7a8:	ae 68       	st.h	r7[0xc],r8
8000b7aa:	3f fc       	mov	r12,-1
8000b7ac:	c0 28       	rjmp	8000b7b0 <__sfvwrite_r+0x290>
8000b7ae:	30 0c       	mov	r12,0
8000b7b0:	2f dd       	sub	sp,-12
8000b7b2:	d8 32       	popm	r0-r7,pc

8000b7b4 <_fwalk>:
8000b7b4:	d4 31       	pushm	r0-r7,lr
8000b7b6:	30 05       	mov	r5,0
8000b7b8:	16 91       	mov	r1,r11
8000b7ba:	f8 c7 ff 28 	sub	r7,r12,-216
8000b7be:	0a 92       	mov	r2,r5
8000b7c0:	fe b0 fc fe 	rcall	8000b1bc <__sfp_lock_acquire>
8000b7c4:	3f f3       	mov	r3,-1
8000b7c6:	c1 68       	rjmp	8000b7f2 <_fwalk+0x3e>
8000b7c8:	6e 26       	ld.w	r6,r7[0x8]
8000b7ca:	6e 14       	ld.w	r4,r7[0x4]
8000b7cc:	2f 46       	sub	r6,-12
8000b7ce:	c0 c8       	rjmp	8000b7e6 <_fwalk+0x32>
8000b7d0:	8c 08       	ld.sh	r8,r6[0x0]
8000b7d2:	e4 08 19 00 	cp.h	r8,r2
8000b7d6:	c0 70       	breq	8000b7e4 <_fwalk+0x30>
8000b7d8:	8c 18       	ld.sh	r8,r6[0x2]
8000b7da:	e6 08 19 00 	cp.h	r8,r3
8000b7de:	c0 30       	breq	8000b7e4 <_fwalk+0x30>
8000b7e0:	5d 11       	icall	r1
8000b7e2:	18 45       	or	r5,r12
8000b7e4:	2a 46       	sub	r6,-92
8000b7e6:	20 14       	sub	r4,1
8000b7e8:	ec cc 00 0c 	sub	r12,r6,12
8000b7ec:	58 04       	cp.w	r4,0
8000b7ee:	cf 14       	brge	8000b7d0 <_fwalk+0x1c>
8000b7f0:	6e 07       	ld.w	r7,r7[0x0]
8000b7f2:	58 07       	cp.w	r7,0
8000b7f4:	ce a1       	brne	8000b7c8 <_fwalk+0x14>
8000b7f6:	fe b0 fc e4 	rcall	8000b1be <__sfp_lock_release>
8000b7fa:	0a 9c       	mov	r12,r5
8000b7fc:	d8 32       	popm	r0-r7,pc
8000b7fe:	d7 03       	nop

8000b800 <_localeconv_r>:
8000b800:	fe cc d3 fc 	sub	r12,pc,-11268
8000b804:	5e fc       	retal	r12
8000b806:	d7 03       	nop

8000b808 <__smakebuf_r>:
8000b808:	d4 21       	pushm	r4-r7,lr
8000b80a:	20 fd       	sub	sp,60
8000b80c:	96 68       	ld.sh	r8,r11[0xc]
8000b80e:	16 97       	mov	r7,r11
8000b810:	18 96       	mov	r6,r12
8000b812:	e2 18 00 02 	andl	r8,0x2,COH
8000b816:	c3 d1       	brne	8000b890 <__smakebuf_r+0x88>
8000b818:	96 7b       	ld.sh	r11,r11[0xe]
8000b81a:	f0 0b 19 00 	cp.h	r11,r8
8000b81e:	c0 55       	brlt	8000b828 <__smakebuf_r+0x20>
8000b820:	1a 9a       	mov	r10,sp
8000b822:	e0 a0 04 81 	rcall	8000c124 <_fstat_r>
8000b826:	c0 f4       	brge	8000b844 <__smakebuf_r+0x3c>
8000b828:	8e 65       	ld.sh	r5,r7[0xc]
8000b82a:	0a 98       	mov	r8,r5
8000b82c:	ab b8       	sbr	r8,0xb
8000b82e:	e2 15 00 80 	andl	r5,0x80,COH
8000b832:	ae 68       	st.h	r7[0xc],r8
8000b834:	30 04       	mov	r4,0
8000b836:	e0 68 04 00 	mov	r8,1024
8000b83a:	f9 b5 01 40 	movne	r5,64
8000b83e:	f0 05 17 00 	moveq	r5,r8
8000b842:	c1 c8       	rjmp	8000b87a <__smakebuf_r+0x72>
8000b844:	40 18       	lddsp	r8,sp[0x4]
8000b846:	e2 18 f0 00 	andl	r8,0xf000,COH
8000b84a:	e0 48 20 00 	cp.w	r8,8192
8000b84e:	5f 04       	sreq	r4
8000b850:	e0 48 80 00 	cp.w	r8,32768
8000b854:	c0 e1       	brne	8000b870 <__smakebuf_r+0x68>
8000b856:	6e b9       	ld.w	r9,r7[0x2c]
8000b858:	fe c8 f9 1c 	sub	r8,pc,-1764
8000b85c:	10 39       	cp.w	r9,r8
8000b85e:	c0 91       	brne	8000b870 <__smakebuf_r+0x68>
8000b860:	8e 68       	ld.sh	r8,r7[0xc]
8000b862:	e0 65 04 00 	mov	r5,1024
8000b866:	ab a8       	sbr	r8,0xa
8000b868:	ef 45 00 50 	st.w	r7[80],r5
8000b86c:	ae 68       	st.h	r7[0xc],r8
8000b86e:	c0 68       	rjmp	8000b87a <__smakebuf_r+0x72>
8000b870:	8e 68       	ld.sh	r8,r7[0xc]
8000b872:	e0 65 04 00 	mov	r5,1024
8000b876:	ab b8       	sbr	r8,0xb
8000b878:	ae 68       	st.h	r7[0xc],r8
8000b87a:	0a 9b       	mov	r11,r5
8000b87c:	0c 9c       	mov	r12,r6
8000b87e:	fe b0 df 23 	rcall	800076c4 <_malloc_r>
8000b882:	8e 68       	ld.sh	r8,r7[0xc]
8000b884:	c0 d1       	brne	8000b89e <__smakebuf_r+0x96>
8000b886:	ed b8 00 09 	bld	r8,0x9
8000b88a:	c1 b0       	breq	8000b8c0 <__smakebuf_r+0xb8>
8000b88c:	a1 b8       	sbr	r8,0x1
8000b88e:	ae 68       	st.h	r7[0xc],r8
8000b890:	ee c8 ff b9 	sub	r8,r7,-71
8000b894:	8f 48       	st.w	r7[0x10],r8
8000b896:	8f 08       	st.w	r7[0x0],r8
8000b898:	30 18       	mov	r8,1
8000b89a:	8f 58       	st.w	r7[0x14],r8
8000b89c:	c1 28       	rjmp	8000b8c0 <__smakebuf_r+0xb8>
8000b89e:	a7 b8       	sbr	r8,0x7
8000b8a0:	8f 4c       	st.w	r7[0x10],r12
8000b8a2:	ae 68       	st.h	r7[0xc],r8
8000b8a4:	8f 55       	st.w	r7[0x14],r5
8000b8a6:	fe c8 06 e6 	sub	r8,pc,1766
8000b8aa:	8f 0c       	st.w	r7[0x0],r12
8000b8ac:	8d a8       	st.w	r6[0x28],r8
8000b8ae:	58 04       	cp.w	r4,0
8000b8b0:	c0 80       	breq	8000b8c0 <__smakebuf_r+0xb8>
8000b8b2:	8e 7c       	ld.sh	r12,r7[0xe]
8000b8b4:	fe b0 e3 94 	rcall	80007fdc <isatty>
8000b8b8:	c0 40       	breq	8000b8c0 <__smakebuf_r+0xb8>
8000b8ba:	8e 68       	ld.sh	r8,r7[0xc]
8000b8bc:	a1 a8       	sbr	r8,0x0
8000b8be:	ae 68       	st.h	r7[0xc],r8
8000b8c0:	2f 1d       	sub	sp,-60
8000b8c2:	d8 22       	popm	r4-r7,pc

8000b8c4 <memchr>:
8000b8c4:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000b8c8:	c0 68       	rjmp	8000b8d4 <memchr+0x10>
8000b8ca:	20 1a       	sub	r10,1
8000b8cc:	19 88       	ld.ub	r8,r12[0x0]
8000b8ce:	16 38       	cp.w	r8,r11
8000b8d0:	5e 0c       	reteq	r12
8000b8d2:	2f fc       	sub	r12,-1
8000b8d4:	58 0a       	cp.w	r10,0
8000b8d6:	cf a1       	brne	8000b8ca <memchr+0x6>
8000b8d8:	5e fa       	retal	r10

8000b8da <memmove>:
8000b8da:	d4 01       	pushm	lr
8000b8dc:	18 3b       	cp.w	r11,r12
8000b8de:	c1 92       	brcc	8000b910 <memmove+0x36>
8000b8e0:	f6 0a 00 09 	add	r9,r11,r10
8000b8e4:	12 3c       	cp.w	r12,r9
8000b8e6:	c1 52       	brcc	8000b910 <memmove+0x36>
8000b8e8:	f8 0a 00 0b 	add	r11,r12,r10
8000b8ec:	30 08       	mov	r8,0
8000b8ee:	c0 68       	rjmp	8000b8fa <memmove+0x20>
8000b8f0:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000b8f4:	20 1a       	sub	r10,1
8000b8f6:	f6 08 0b 0e 	st.b	r11[r8],lr
8000b8fa:	20 18       	sub	r8,1
8000b8fc:	58 0a       	cp.w	r10,0
8000b8fe:	cf 91       	brne	8000b8f0 <memmove+0x16>
8000b900:	d8 02       	popm	pc
8000b902:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000b906:	20 1a       	sub	r10,1
8000b908:	f8 08 0b 09 	st.b	r12[r8],r9
8000b90c:	2f f8       	sub	r8,-1
8000b90e:	c0 28       	rjmp	8000b912 <memmove+0x38>
8000b910:	30 08       	mov	r8,0
8000b912:	58 0a       	cp.w	r10,0
8000b914:	cf 71       	brne	8000b902 <memmove+0x28>
8000b916:	d8 02       	popm	pc

8000b918 <__hi0bits>:
8000b918:	18 98       	mov	r8,r12
8000b91a:	e0 1c 00 00 	andl	r12,0x0
8000b91e:	f0 09 15 10 	lsl	r9,r8,0x10
8000b922:	58 0c       	cp.w	r12,0
8000b924:	f2 08 17 00 	moveq	r8,r9
8000b928:	f9 bc 00 10 	moveq	r12,16
8000b92c:	f9 bc 01 00 	movne	r12,0
8000b930:	10 9a       	mov	r10,r8
8000b932:	f0 09 15 08 	lsl	r9,r8,0x8
8000b936:	e6 1a ff 00 	andh	r10,0xff00,COH
8000b93a:	f7 bc 00 f8 	subeq	r12,-8
8000b93e:	f2 08 17 00 	moveq	r8,r9
8000b942:	10 9a       	mov	r10,r8
8000b944:	f0 09 15 04 	lsl	r9,r8,0x4
8000b948:	e6 1a f0 00 	andh	r10,0xf000,COH
8000b94c:	f7 bc 00 fc 	subeq	r12,-4
8000b950:	f2 08 17 00 	moveq	r8,r9
8000b954:	10 9a       	mov	r10,r8
8000b956:	f0 09 15 02 	lsl	r9,r8,0x2
8000b95a:	e6 1a c0 00 	andh	r10,0xc000,COH
8000b95e:	f7 bc 00 fe 	subeq	r12,-2
8000b962:	f2 08 17 00 	moveq	r8,r9
8000b966:	58 08       	cp.w	r8,0
8000b968:	5e 5c       	retlt	r12
8000b96a:	ed b8 00 1e 	bld	r8,0x1e
8000b96e:	f9 bc 01 20 	movne	r12,32
8000b972:	f7 bc 00 ff 	subeq	r12,-1
8000b976:	5e fc       	retal	r12

8000b978 <__lo0bits>:
8000b978:	18 99       	mov	r9,r12
8000b97a:	78 08       	ld.w	r8,r12[0x0]
8000b97c:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000b980:	c1 50       	breq	8000b9aa <__lo0bits+0x32>
8000b982:	ed b8 00 00 	bld	r8,0x0
8000b986:	c0 21       	brne	8000b98a <__lo0bits+0x12>
8000b988:	5e fd       	retal	0
8000b98a:	10 9b       	mov	r11,r8
8000b98c:	f0 0a 16 01 	lsr	r10,r8,0x1
8000b990:	e2 1b 00 02 	andl	r11,0x2,COH
8000b994:	a3 88       	lsr	r8,0x2
8000b996:	58 0b       	cp.w	r11,0
8000b998:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000b99c:	f9 bc 01 01 	movne	r12,1
8000b9a0:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000b9a4:	f9 bc 00 02 	moveq	r12,2
8000b9a8:	5e fc       	retal	r12
8000b9aa:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000b9ae:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b9b2:	58 0a       	cp.w	r10,0
8000b9b4:	f6 08 17 00 	moveq	r8,r11
8000b9b8:	f9 bc 00 10 	moveq	r12,16
8000b9bc:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000b9c0:	f0 0a 16 08 	lsr	r10,r8,0x8
8000b9c4:	58 0b       	cp.w	r11,0
8000b9c6:	f7 bc 00 f8 	subeq	r12,-8
8000b9ca:	f4 08 17 00 	moveq	r8,r10
8000b9ce:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000b9d2:	f0 0a 16 04 	lsr	r10,r8,0x4
8000b9d6:	58 0b       	cp.w	r11,0
8000b9d8:	f7 bc 00 fc 	subeq	r12,-4
8000b9dc:	f4 08 17 00 	moveq	r8,r10
8000b9e0:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000b9e4:	f0 0a 16 02 	lsr	r10,r8,0x2
8000b9e8:	58 0b       	cp.w	r11,0
8000b9ea:	f7 bc 00 fe 	subeq	r12,-2
8000b9ee:	f4 08 17 00 	moveq	r8,r10
8000b9f2:	ed b8 00 00 	bld	r8,0x0
8000b9f6:	c0 60       	breq	8000ba02 <__lo0bits+0x8a>
8000b9f8:	a1 98       	lsr	r8,0x1
8000b9fa:	c0 31       	brne	8000ba00 <__lo0bits+0x88>
8000b9fc:	32 0c       	mov	r12,32
8000b9fe:	5e fc       	retal	r12
8000ba00:	2f fc       	sub	r12,-1
8000ba02:	93 08       	st.w	r9[0x0],r8
8000ba04:	5e fc       	retal	r12

8000ba06 <__mcmp>:
8000ba06:	d4 01       	pushm	lr
8000ba08:	18 98       	mov	r8,r12
8000ba0a:	76 49       	ld.w	r9,r11[0x10]
8000ba0c:	78 4c       	ld.w	r12,r12[0x10]
8000ba0e:	12 1c       	sub	r12,r9
8000ba10:	c1 31       	brne	8000ba36 <__mcmp+0x30>
8000ba12:	2f b9       	sub	r9,-5
8000ba14:	a3 69       	lsl	r9,0x2
8000ba16:	12 0b       	add	r11,r9
8000ba18:	f0 09 00 09 	add	r9,r8,r9
8000ba1c:	2e c8       	sub	r8,-20
8000ba1e:	13 4e       	ld.w	lr,--r9
8000ba20:	17 4a       	ld.w	r10,--r11
8000ba22:	14 3e       	cp.w	lr,r10
8000ba24:	c0 60       	breq	8000ba30 <__mcmp+0x2a>
8000ba26:	f9 bc 03 ff 	movlo	r12,-1
8000ba2a:	f9 bc 02 01 	movhs	r12,1
8000ba2e:	d8 02       	popm	pc
8000ba30:	10 39       	cp.w	r9,r8
8000ba32:	fe 9b ff f6 	brhi	8000ba1e <__mcmp+0x18>
8000ba36:	d8 02       	popm	pc

8000ba38 <_Bfree>:
8000ba38:	d4 21       	pushm	r4-r7,lr
8000ba3a:	18 97       	mov	r7,r12
8000ba3c:	16 95       	mov	r5,r11
8000ba3e:	78 96       	ld.w	r6,r12[0x24]
8000ba40:	58 06       	cp.w	r6,0
8000ba42:	c0 91       	brne	8000ba54 <_Bfree+0x1c>
8000ba44:	31 0c       	mov	r12,16
8000ba46:	fe b0 de 37 	rcall	800076b4 <malloc>
8000ba4a:	99 36       	st.w	r12[0xc],r6
8000ba4c:	8f 9c       	st.w	r7[0x24],r12
8000ba4e:	99 16       	st.w	r12[0x4],r6
8000ba50:	99 26       	st.w	r12[0x8],r6
8000ba52:	99 06       	st.w	r12[0x0],r6
8000ba54:	58 05       	cp.w	r5,0
8000ba56:	c0 90       	breq	8000ba68 <_Bfree+0x30>
8000ba58:	6a 19       	ld.w	r9,r5[0x4]
8000ba5a:	6e 98       	ld.w	r8,r7[0x24]
8000ba5c:	70 38       	ld.w	r8,r8[0xc]
8000ba5e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000ba62:	8b 0a       	st.w	r5[0x0],r10
8000ba64:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000ba68:	d8 22       	popm	r4-r7,pc
8000ba6a:	d7 03       	nop

8000ba6c <_Balloc>:
8000ba6c:	d4 21       	pushm	r4-r7,lr
8000ba6e:	18 97       	mov	r7,r12
8000ba70:	16 96       	mov	r6,r11
8000ba72:	78 95       	ld.w	r5,r12[0x24]
8000ba74:	58 05       	cp.w	r5,0
8000ba76:	c0 91       	brne	8000ba88 <_Balloc+0x1c>
8000ba78:	31 0c       	mov	r12,16
8000ba7a:	fe b0 de 1d 	rcall	800076b4 <malloc>
8000ba7e:	99 35       	st.w	r12[0xc],r5
8000ba80:	8f 9c       	st.w	r7[0x24],r12
8000ba82:	99 15       	st.w	r12[0x4],r5
8000ba84:	99 25       	st.w	r12[0x8],r5
8000ba86:	99 05       	st.w	r12[0x0],r5
8000ba88:	6e 95       	ld.w	r5,r7[0x24]
8000ba8a:	6a 38       	ld.w	r8,r5[0xc]
8000ba8c:	58 08       	cp.w	r8,0
8000ba8e:	c0 b1       	brne	8000baa4 <_Balloc+0x38>
8000ba90:	31 0a       	mov	r10,16
8000ba92:	30 4b       	mov	r11,4
8000ba94:	0e 9c       	mov	r12,r7
8000ba96:	e0 a0 02 a7 	rcall	8000bfe4 <_calloc_r>
8000ba9a:	8b 3c       	st.w	r5[0xc],r12
8000ba9c:	6e 98       	ld.w	r8,r7[0x24]
8000ba9e:	70 3c       	ld.w	r12,r8[0xc]
8000baa0:	58 0c       	cp.w	r12,0
8000baa2:	c1 b0       	breq	8000bad8 <_Balloc+0x6c>
8000baa4:	6e 98       	ld.w	r8,r7[0x24]
8000baa6:	70 38       	ld.w	r8,r8[0xc]
8000baa8:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000baac:	70 0c       	ld.w	r12,r8[0x0]
8000baae:	58 0c       	cp.w	r12,0
8000bab0:	c0 40       	breq	8000bab8 <_Balloc+0x4c>
8000bab2:	78 09       	ld.w	r9,r12[0x0]
8000bab4:	91 09       	st.w	r8[0x0],r9
8000bab6:	c0 e8       	rjmp	8000bad2 <_Balloc+0x66>
8000bab8:	0e 9c       	mov	r12,r7
8000baba:	30 17       	mov	r7,1
8000babc:	0e 9b       	mov	r11,r7
8000babe:	ee 06 09 47 	lsl	r7,r7,r6
8000bac2:	ee ca ff fb 	sub	r10,r7,-5
8000bac6:	a3 6a       	lsl	r10,0x2
8000bac8:	e0 a0 02 8e 	rcall	8000bfe4 <_calloc_r>
8000bacc:	c0 60       	breq	8000bad8 <_Balloc+0x6c>
8000bace:	99 16       	st.w	r12[0x4],r6
8000bad0:	99 27       	st.w	r12[0x8],r7
8000bad2:	30 08       	mov	r8,0
8000bad4:	99 38       	st.w	r12[0xc],r8
8000bad6:	99 48       	st.w	r12[0x10],r8
8000bad8:	d8 22       	popm	r4-r7,pc
8000bada:	d7 03       	nop

8000badc <__d2b>:
8000badc:	d4 31       	pushm	r0-r7,lr
8000bade:	20 2d       	sub	sp,8
8000bae0:	16 93       	mov	r3,r11
8000bae2:	12 96       	mov	r6,r9
8000bae4:	10 95       	mov	r5,r8
8000bae6:	14 92       	mov	r2,r10
8000bae8:	30 1b       	mov	r11,1
8000baea:	cc 1f       	rcall	8000ba6c <_Balloc>
8000baec:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000baf0:	50 09       	stdsp	sp[0x0],r9
8000baf2:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000baf6:	b5 a9       	sbr	r9,0x14
8000baf8:	f0 01 16 14 	lsr	r1,r8,0x14
8000bafc:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000bb00:	18 94       	mov	r4,r12
8000bb02:	58 02       	cp.w	r2,0
8000bb04:	c1 d0       	breq	8000bb3e <__d2b+0x62>
8000bb06:	fa cc ff f8 	sub	r12,sp,-8
8000bb0a:	18 d2       	st.w	--r12,r2
8000bb0c:	c3 6f       	rcall	8000b978 <__lo0bits>
8000bb0e:	40 18       	lddsp	r8,sp[0x4]
8000bb10:	c0 d0       	breq	8000bb2a <__d2b+0x4e>
8000bb12:	40 09       	lddsp	r9,sp[0x0]
8000bb14:	f8 0a 11 20 	rsub	r10,r12,32
8000bb18:	f2 0a 09 4a 	lsl	r10,r9,r10
8000bb1c:	f5 e8 10 08 	or	r8,r10,r8
8000bb20:	89 58       	st.w	r4[0x14],r8
8000bb22:	f2 0c 0a 49 	lsr	r9,r9,r12
8000bb26:	50 09       	stdsp	sp[0x0],r9
8000bb28:	c0 28       	rjmp	8000bb2c <__d2b+0x50>
8000bb2a:	89 58       	st.w	r4[0x14],r8
8000bb2c:	40 08       	lddsp	r8,sp[0x0]
8000bb2e:	58 08       	cp.w	r8,0
8000bb30:	f9 b3 01 02 	movne	r3,2
8000bb34:	f9 b3 00 01 	moveq	r3,1
8000bb38:	89 68       	st.w	r4[0x18],r8
8000bb3a:	89 43       	st.w	r4[0x10],r3
8000bb3c:	c0 88       	rjmp	8000bb4c <__d2b+0x70>
8000bb3e:	1a 9c       	mov	r12,sp
8000bb40:	c1 cf       	rcall	8000b978 <__lo0bits>
8000bb42:	30 13       	mov	r3,1
8000bb44:	40 08       	lddsp	r8,sp[0x0]
8000bb46:	2e 0c       	sub	r12,-32
8000bb48:	89 43       	st.w	r4[0x10],r3
8000bb4a:	89 58       	st.w	r4[0x14],r8
8000bb4c:	58 01       	cp.w	r1,0
8000bb4e:	c0 90       	breq	8000bb60 <__d2b+0x84>
8000bb50:	e2 c1 04 33 	sub	r1,r1,1075
8000bb54:	18 01       	add	r1,r12
8000bb56:	8d 01       	st.w	r6[0x0],r1
8000bb58:	f8 0c 11 35 	rsub	r12,r12,53
8000bb5c:	8b 0c       	st.w	r5[0x0],r12
8000bb5e:	c0 c8       	rjmp	8000bb76 <__d2b+0x9a>
8000bb60:	e6 c8 ff fc 	sub	r8,r3,-4
8000bb64:	f8 cc 04 32 	sub	r12,r12,1074
8000bb68:	a5 73       	lsl	r3,0x5
8000bb6a:	8d 0c       	st.w	r6[0x0],r12
8000bb6c:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000bb70:	cd 4e       	rcall	8000b918 <__hi0bits>
8000bb72:	18 13       	sub	r3,r12
8000bb74:	8b 03       	st.w	r5[0x0],r3
8000bb76:	08 9c       	mov	r12,r4
8000bb78:	2f ed       	sub	sp,-8
8000bb7a:	d8 32       	popm	r0-r7,pc

8000bb7c <__mdiff>:
8000bb7c:	d4 31       	pushm	r0-r7,lr
8000bb7e:	74 48       	ld.w	r8,r10[0x10]
8000bb80:	76 45       	ld.w	r5,r11[0x10]
8000bb82:	16 97       	mov	r7,r11
8000bb84:	14 96       	mov	r6,r10
8000bb86:	10 15       	sub	r5,r8
8000bb88:	c1 31       	brne	8000bbae <__mdiff+0x32>
8000bb8a:	2f b8       	sub	r8,-5
8000bb8c:	ee ce ff ec 	sub	lr,r7,-20
8000bb90:	a3 68       	lsl	r8,0x2
8000bb92:	f4 08 00 0b 	add	r11,r10,r8
8000bb96:	ee 08 00 08 	add	r8,r7,r8
8000bb9a:	11 4a       	ld.w	r10,--r8
8000bb9c:	17 49       	ld.w	r9,--r11
8000bb9e:	12 3a       	cp.w	r10,r9
8000bba0:	c0 30       	breq	8000bba6 <__mdiff+0x2a>
8000bba2:	c0 e2       	brcc	8000bbbe <__mdiff+0x42>
8000bba4:	c0 78       	rjmp	8000bbb2 <__mdiff+0x36>
8000bba6:	1c 38       	cp.w	r8,lr
8000bba8:	fe 9b ff f9 	brhi	8000bb9a <__mdiff+0x1e>
8000bbac:	c4 98       	rjmp	8000bc3e <__mdiff+0xc2>
8000bbae:	58 05       	cp.w	r5,0
8000bbb0:	c0 64       	brge	8000bbbc <__mdiff+0x40>
8000bbb2:	0e 98       	mov	r8,r7
8000bbb4:	30 15       	mov	r5,1
8000bbb6:	0c 97       	mov	r7,r6
8000bbb8:	10 96       	mov	r6,r8
8000bbba:	c0 28       	rjmp	8000bbbe <__mdiff+0x42>
8000bbbc:	30 05       	mov	r5,0
8000bbbe:	6e 1b       	ld.w	r11,r7[0x4]
8000bbc0:	c5 6f       	rcall	8000ba6c <_Balloc>
8000bbc2:	6e 49       	ld.w	r9,r7[0x10]
8000bbc4:	6c 44       	ld.w	r4,r6[0x10]
8000bbc6:	99 35       	st.w	r12[0xc],r5
8000bbc8:	2f b4       	sub	r4,-5
8000bbca:	f2 c5 ff fb 	sub	r5,r9,-5
8000bbce:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000bbd2:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000bbd6:	2e c6       	sub	r6,-20
8000bbd8:	2e c7       	sub	r7,-20
8000bbda:	f8 c8 ff ec 	sub	r8,r12,-20
8000bbde:	30 0a       	mov	r10,0
8000bbe0:	0f 0e       	ld.w	lr,r7++
8000bbe2:	0d 0b       	ld.w	r11,r6++
8000bbe4:	fc 02 16 10 	lsr	r2,lr,0x10
8000bbe8:	f6 03 16 10 	lsr	r3,r11,0x10
8000bbec:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000bbf0:	e4 03 01 03 	sub	r3,r2,r3
8000bbf4:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bbf8:	fc 0b 01 0b 	sub	r11,lr,r11
8000bbfc:	f6 0a 00 0a 	add	r10,r11,r10
8000bc00:	b0 1a       	st.h	r8[0x2],r10
8000bc02:	b1 4a       	asr	r10,0x10
8000bc04:	e6 0a 00 0a 	add	r10,r3,r10
8000bc08:	b0 0a       	st.h	r8[0x0],r10
8000bc0a:	2f c8       	sub	r8,-4
8000bc0c:	b1 4a       	asr	r10,0x10
8000bc0e:	08 36       	cp.w	r6,r4
8000bc10:	ce 83       	brcs	8000bbe0 <__mdiff+0x64>
8000bc12:	c0 d8       	rjmp	8000bc2c <__mdiff+0xb0>
8000bc14:	0f 0b       	ld.w	r11,r7++
8000bc16:	f6 0e 16 10 	lsr	lr,r11,0x10
8000bc1a:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bc1e:	16 0a       	add	r10,r11
8000bc20:	b0 1a       	st.h	r8[0x2],r10
8000bc22:	b1 4a       	asr	r10,0x10
8000bc24:	1c 0a       	add	r10,lr
8000bc26:	b0 0a       	st.h	r8[0x0],r10
8000bc28:	2f c8       	sub	r8,-4
8000bc2a:	b1 4a       	asr	r10,0x10
8000bc2c:	0a 37       	cp.w	r7,r5
8000bc2e:	cf 33       	brcs	8000bc14 <__mdiff+0x98>
8000bc30:	c0 28       	rjmp	8000bc34 <__mdiff+0xb8>
8000bc32:	20 19       	sub	r9,1
8000bc34:	11 4a       	ld.w	r10,--r8
8000bc36:	58 0a       	cp.w	r10,0
8000bc38:	cf d0       	breq	8000bc32 <__mdiff+0xb6>
8000bc3a:	99 49       	st.w	r12[0x10],r9
8000bc3c:	d8 32       	popm	r0-r7,pc
8000bc3e:	30 0b       	mov	r11,0
8000bc40:	c1 6f       	rcall	8000ba6c <_Balloc>
8000bc42:	30 18       	mov	r8,1
8000bc44:	99 48       	st.w	r12[0x10],r8
8000bc46:	30 08       	mov	r8,0
8000bc48:	99 58       	st.w	r12[0x14],r8
8000bc4a:	d8 32       	popm	r0-r7,pc

8000bc4c <__lshift>:
8000bc4c:	d4 31       	pushm	r0-r7,lr
8000bc4e:	16 97       	mov	r7,r11
8000bc50:	76 46       	ld.w	r6,r11[0x10]
8000bc52:	f4 02 14 05 	asr	r2,r10,0x5
8000bc56:	2f f6       	sub	r6,-1
8000bc58:	14 93       	mov	r3,r10
8000bc5a:	18 94       	mov	r4,r12
8000bc5c:	04 06       	add	r6,r2
8000bc5e:	76 1b       	ld.w	r11,r11[0x4]
8000bc60:	6e 28       	ld.w	r8,r7[0x8]
8000bc62:	c0 38       	rjmp	8000bc68 <__lshift+0x1c>
8000bc64:	2f fb       	sub	r11,-1
8000bc66:	a1 78       	lsl	r8,0x1
8000bc68:	10 36       	cp.w	r6,r8
8000bc6a:	fe 99 ff fd 	brgt	8000bc64 <__lshift+0x18>
8000bc6e:	08 9c       	mov	r12,r4
8000bc70:	cf ee       	rcall	8000ba6c <_Balloc>
8000bc72:	30 09       	mov	r9,0
8000bc74:	18 95       	mov	r5,r12
8000bc76:	f8 c8 ff ec 	sub	r8,r12,-20
8000bc7a:	12 9a       	mov	r10,r9
8000bc7c:	c0 38       	rjmp	8000bc82 <__lshift+0x36>
8000bc7e:	10 aa       	st.w	r8++,r10
8000bc80:	2f f9       	sub	r9,-1
8000bc82:	04 39       	cp.w	r9,r2
8000bc84:	cf d5       	brlt	8000bc7e <__lshift+0x32>
8000bc86:	6e 4b       	ld.w	r11,r7[0x10]
8000bc88:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000bc8c:	2f bb       	sub	r11,-5
8000bc8e:	ee c9 ff ec 	sub	r9,r7,-20
8000bc92:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000bc96:	58 03       	cp.w	r3,0
8000bc98:	c1 30       	breq	8000bcbe <__lshift+0x72>
8000bc9a:	e6 0c 11 20 	rsub	r12,r3,32
8000bc9e:	30 0a       	mov	r10,0
8000bca0:	72 02       	ld.w	r2,r9[0x0]
8000bca2:	e4 03 09 42 	lsl	r2,r2,r3
8000bca6:	04 4a       	or	r10,r2
8000bca8:	10 aa       	st.w	r8++,r10
8000bcaa:	13 0a       	ld.w	r10,r9++
8000bcac:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000bcb0:	16 39       	cp.w	r9,r11
8000bcb2:	cf 73       	brcs	8000bca0 <__lshift+0x54>
8000bcb4:	91 0a       	st.w	r8[0x0],r10
8000bcb6:	58 0a       	cp.w	r10,0
8000bcb8:	c0 70       	breq	8000bcc6 <__lshift+0x7a>
8000bcba:	2f f6       	sub	r6,-1
8000bcbc:	c0 58       	rjmp	8000bcc6 <__lshift+0x7a>
8000bcbe:	13 0a       	ld.w	r10,r9++
8000bcc0:	10 aa       	st.w	r8++,r10
8000bcc2:	16 39       	cp.w	r9,r11
8000bcc4:	cf d3       	brcs	8000bcbe <__lshift+0x72>
8000bcc6:	08 9c       	mov	r12,r4
8000bcc8:	20 16       	sub	r6,1
8000bcca:	0e 9b       	mov	r11,r7
8000bccc:	8b 46       	st.w	r5[0x10],r6
8000bcce:	cb 5e       	rcall	8000ba38 <_Bfree>
8000bcd0:	0a 9c       	mov	r12,r5
8000bcd2:	d8 32       	popm	r0-r7,pc

8000bcd4 <__multiply>:
8000bcd4:	d4 31       	pushm	r0-r7,lr
8000bcd6:	20 2d       	sub	sp,8
8000bcd8:	76 49       	ld.w	r9,r11[0x10]
8000bcda:	74 48       	ld.w	r8,r10[0x10]
8000bcdc:	16 96       	mov	r6,r11
8000bcde:	14 95       	mov	r5,r10
8000bce0:	10 39       	cp.w	r9,r8
8000bce2:	ec 08 17 50 	movlt	r8,r6
8000bce6:	ea 06 17 50 	movlt	r6,r5
8000bcea:	f0 05 17 50 	movlt	r5,r8
8000bcee:	6c 28       	ld.w	r8,r6[0x8]
8000bcf0:	76 43       	ld.w	r3,r11[0x10]
8000bcf2:	74 42       	ld.w	r2,r10[0x10]
8000bcf4:	76 1b       	ld.w	r11,r11[0x4]
8000bcf6:	e4 03 00 07 	add	r7,r2,r3
8000bcfa:	10 37       	cp.w	r7,r8
8000bcfc:	f7 bb 09 ff 	subgt	r11,-1
8000bd00:	cb 6e       	rcall	8000ba6c <_Balloc>
8000bd02:	ee c4 ff fb 	sub	r4,r7,-5
8000bd06:	f8 c9 ff ec 	sub	r9,r12,-20
8000bd0a:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000bd0e:	30 0a       	mov	r10,0
8000bd10:	12 98       	mov	r8,r9
8000bd12:	c0 28       	rjmp	8000bd16 <__multiply+0x42>
8000bd14:	10 aa       	st.w	r8++,r10
8000bd16:	08 38       	cp.w	r8,r4
8000bd18:	cf e3       	brcs	8000bd14 <__multiply+0x40>
8000bd1a:	2f b3       	sub	r3,-5
8000bd1c:	2f b2       	sub	r2,-5
8000bd1e:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000bd22:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000bd26:	ec cb ff ec 	sub	r11,r6,-20
8000bd2a:	50 12       	stdsp	sp[0x4],r2
8000bd2c:	ea ca ff ec 	sub	r10,r5,-20
8000bd30:	c4 48       	rjmp	8000bdb8 <__multiply+0xe4>
8000bd32:	94 95       	ld.uh	r5,r10[0x2]
8000bd34:	58 05       	cp.w	r5,0
8000bd36:	c2 00       	breq	8000bd76 <__multiply+0xa2>
8000bd38:	12 98       	mov	r8,r9
8000bd3a:	16 96       	mov	r6,r11
8000bd3c:	30 0e       	mov	lr,0
8000bd3e:	50 09       	stdsp	sp[0x0],r9
8000bd40:	0d 02       	ld.w	r2,r6++
8000bd42:	e4 00 16 10 	lsr	r0,r2,0x10
8000bd46:	70 01       	ld.w	r1,r8[0x0]
8000bd48:	70 09       	ld.w	r9,r8[0x0]
8000bd4a:	b1 81       	lsr	r1,0x10
8000bd4c:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000bd50:	e0 05 03 41 	mac	r1,r0,r5
8000bd54:	ab 32       	mul	r2,r5
8000bd56:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000bd5a:	00 02       	add	r2,r0
8000bd5c:	e4 0e 00 0e 	add	lr,r2,lr
8000bd60:	b0 1e       	st.h	r8[0x2],lr
8000bd62:	b1 8e       	lsr	lr,0x10
8000bd64:	1c 01       	add	r1,lr
8000bd66:	b0 01       	st.h	r8[0x0],r1
8000bd68:	e2 0e 16 10 	lsr	lr,r1,0x10
8000bd6c:	2f c8       	sub	r8,-4
8000bd6e:	06 36       	cp.w	r6,r3
8000bd70:	ce 83       	brcs	8000bd40 <__multiply+0x6c>
8000bd72:	40 09       	lddsp	r9,sp[0x0]
8000bd74:	91 0e       	st.w	r8[0x0],lr
8000bd76:	94 86       	ld.uh	r6,r10[0x0]
8000bd78:	58 06       	cp.w	r6,0
8000bd7a:	c1 d0       	breq	8000bdb4 <__multiply+0xe0>
8000bd7c:	72 02       	ld.w	r2,r9[0x0]
8000bd7e:	12 98       	mov	r8,r9
8000bd80:	16 9e       	mov	lr,r11
8000bd82:	30 05       	mov	r5,0
8000bd84:	b0 12       	st.h	r8[0x2],r2
8000bd86:	1d 01       	ld.w	r1,lr++
8000bd88:	90 82       	ld.uh	r2,r8[0x0]
8000bd8a:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000bd8e:	ad 30       	mul	r0,r6
8000bd90:	e0 02 00 02 	add	r2,r0,r2
8000bd94:	e4 05 00 05 	add	r5,r2,r5
8000bd98:	b0 05       	st.h	r8[0x0],r5
8000bd9a:	b1 85       	lsr	r5,0x10
8000bd9c:	b1 81       	lsr	r1,0x10
8000bd9e:	2f c8       	sub	r8,-4
8000bda0:	ad 31       	mul	r1,r6
8000bda2:	90 92       	ld.uh	r2,r8[0x2]
8000bda4:	e2 02 00 02 	add	r2,r1,r2
8000bda8:	0a 02       	add	r2,r5
8000bdaa:	e4 05 16 10 	lsr	r5,r2,0x10
8000bdae:	06 3e       	cp.w	lr,r3
8000bdb0:	ce a3       	brcs	8000bd84 <__multiply+0xb0>
8000bdb2:	91 02       	st.w	r8[0x0],r2
8000bdb4:	2f ca       	sub	r10,-4
8000bdb6:	2f c9       	sub	r9,-4
8000bdb8:	40 18       	lddsp	r8,sp[0x4]
8000bdba:	10 3a       	cp.w	r10,r8
8000bdbc:	cb b3       	brcs	8000bd32 <__multiply+0x5e>
8000bdbe:	c0 28       	rjmp	8000bdc2 <__multiply+0xee>
8000bdc0:	20 17       	sub	r7,1
8000bdc2:	58 07       	cp.w	r7,0
8000bdc4:	e0 8a 00 05 	brle	8000bdce <__multiply+0xfa>
8000bdc8:	09 48       	ld.w	r8,--r4
8000bdca:	58 08       	cp.w	r8,0
8000bdcc:	cf a0       	breq	8000bdc0 <__multiply+0xec>
8000bdce:	99 47       	st.w	r12[0x10],r7
8000bdd0:	2f ed       	sub	sp,-8
8000bdd2:	d8 32       	popm	r0-r7,pc

8000bdd4 <__i2b>:
8000bdd4:	d4 21       	pushm	r4-r7,lr
8000bdd6:	16 97       	mov	r7,r11
8000bdd8:	30 1b       	mov	r11,1
8000bdda:	c4 9e       	rcall	8000ba6c <_Balloc>
8000bddc:	30 19       	mov	r9,1
8000bdde:	99 57       	st.w	r12[0x14],r7
8000bde0:	99 49       	st.w	r12[0x10],r9
8000bde2:	d8 22       	popm	r4-r7,pc

8000bde4 <__multadd>:
8000bde4:	d4 31       	pushm	r0-r7,lr
8000bde6:	30 08       	mov	r8,0
8000bde8:	12 95       	mov	r5,r9
8000bdea:	16 97       	mov	r7,r11
8000bdec:	18 96       	mov	r6,r12
8000bdee:	76 44       	ld.w	r4,r11[0x10]
8000bdf0:	f6 c9 ff ec 	sub	r9,r11,-20
8000bdf4:	72 0b       	ld.w	r11,r9[0x0]
8000bdf6:	f6 0c 16 10 	lsr	r12,r11,0x10
8000bdfa:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000bdfe:	f4 0c 02 4c 	mul	r12,r10,r12
8000be02:	f4 0b 03 45 	mac	r5,r10,r11
8000be06:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000be0a:	b1 85       	lsr	r5,0x10
8000be0c:	18 05       	add	r5,r12
8000be0e:	ea 0c 15 10 	lsl	r12,r5,0x10
8000be12:	f8 0b 00 0b 	add	r11,r12,r11
8000be16:	12 ab       	st.w	r9++,r11
8000be18:	2f f8       	sub	r8,-1
8000be1a:	b1 85       	lsr	r5,0x10
8000be1c:	08 38       	cp.w	r8,r4
8000be1e:	ce b5       	brlt	8000bdf4 <__multadd+0x10>
8000be20:	58 05       	cp.w	r5,0
8000be22:	c1 c0       	breq	8000be5a <__multadd+0x76>
8000be24:	6e 28       	ld.w	r8,r7[0x8]
8000be26:	10 34       	cp.w	r4,r8
8000be28:	c1 35       	brlt	8000be4e <__multadd+0x6a>
8000be2a:	6e 1b       	ld.w	r11,r7[0x4]
8000be2c:	0c 9c       	mov	r12,r6
8000be2e:	2f fb       	sub	r11,-1
8000be30:	c1 ee       	rcall	8000ba6c <_Balloc>
8000be32:	6e 4a       	ld.w	r10,r7[0x10]
8000be34:	ee cb ff f4 	sub	r11,r7,-12
8000be38:	18 93       	mov	r3,r12
8000be3a:	2f ea       	sub	r10,-2
8000be3c:	2f 4c       	sub	r12,-12
8000be3e:	a3 6a       	lsl	r10,0x2
8000be40:	fe b0 de 71 	rcall	80007b22 <memcpy>
8000be44:	0e 9b       	mov	r11,r7
8000be46:	0c 9c       	mov	r12,r6
8000be48:	fe b0 fd f8 	rcall	8000ba38 <_Bfree>
8000be4c:	06 97       	mov	r7,r3
8000be4e:	e8 c8 ff ff 	sub	r8,r4,-1
8000be52:	2f b4       	sub	r4,-5
8000be54:	8f 48       	st.w	r7[0x10],r8
8000be56:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000be5a:	0e 9c       	mov	r12,r7
8000be5c:	d8 32       	popm	r0-r7,pc
8000be5e:	d7 03       	nop

8000be60 <__pow5mult>:
8000be60:	d4 31       	pushm	r0-r7,lr
8000be62:	14 96       	mov	r6,r10
8000be64:	18 97       	mov	r7,r12
8000be66:	16 94       	mov	r4,r11
8000be68:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000be6c:	c0 90       	breq	8000be7e <__pow5mult+0x1e>
8000be6e:	20 18       	sub	r8,1
8000be70:	fe c9 da 30 	sub	r9,pc,-9680
8000be74:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000be78:	30 09       	mov	r9,0
8000be7a:	cb 5f       	rcall	8000bde4 <__multadd>
8000be7c:	18 94       	mov	r4,r12
8000be7e:	a3 46       	asr	r6,0x2
8000be80:	c3 40       	breq	8000bee8 <__pow5mult+0x88>
8000be82:	6e 95       	ld.w	r5,r7[0x24]
8000be84:	58 05       	cp.w	r5,0
8000be86:	c0 91       	brne	8000be98 <__pow5mult+0x38>
8000be88:	31 0c       	mov	r12,16
8000be8a:	fe b0 dc 15 	rcall	800076b4 <malloc>
8000be8e:	99 35       	st.w	r12[0xc],r5
8000be90:	8f 9c       	st.w	r7[0x24],r12
8000be92:	99 15       	st.w	r12[0x4],r5
8000be94:	99 25       	st.w	r12[0x8],r5
8000be96:	99 05       	st.w	r12[0x0],r5
8000be98:	6e 93       	ld.w	r3,r7[0x24]
8000be9a:	66 25       	ld.w	r5,r3[0x8]
8000be9c:	58 05       	cp.w	r5,0
8000be9e:	c0 c1       	brne	8000beb6 <__pow5mult+0x56>
8000bea0:	e0 6b 02 71 	mov	r11,625
8000bea4:	0e 9c       	mov	r12,r7
8000bea6:	c9 7f       	rcall	8000bdd4 <__i2b>
8000bea8:	87 2c       	st.w	r3[0x8],r12
8000beaa:	30 08       	mov	r8,0
8000beac:	18 95       	mov	r5,r12
8000beae:	99 08       	st.w	r12[0x0],r8
8000beb0:	c0 38       	rjmp	8000beb6 <__pow5mult+0x56>
8000beb2:	06 9c       	mov	r12,r3
8000beb4:	18 95       	mov	r5,r12
8000beb6:	ed b6 00 00 	bld	r6,0x0
8000beba:	c0 b1       	brne	8000bed0 <__pow5mult+0x70>
8000bebc:	08 9b       	mov	r11,r4
8000bebe:	0a 9a       	mov	r10,r5
8000bec0:	0e 9c       	mov	r12,r7
8000bec2:	c0 9f       	rcall	8000bcd4 <__multiply>
8000bec4:	08 9b       	mov	r11,r4
8000bec6:	18 93       	mov	r3,r12
8000bec8:	0e 9c       	mov	r12,r7
8000beca:	06 94       	mov	r4,r3
8000becc:	fe b0 fd b6 	rcall	8000ba38 <_Bfree>
8000bed0:	a1 56       	asr	r6,0x1
8000bed2:	c0 b0       	breq	8000bee8 <__pow5mult+0x88>
8000bed4:	6a 03       	ld.w	r3,r5[0x0]
8000bed6:	58 03       	cp.w	r3,0
8000bed8:	ce d1       	brne	8000beb2 <__pow5mult+0x52>
8000beda:	0a 9a       	mov	r10,r5
8000bedc:	0a 9b       	mov	r11,r5
8000bede:	0e 9c       	mov	r12,r7
8000bee0:	cf ae       	rcall	8000bcd4 <__multiply>
8000bee2:	8b 0c       	st.w	r5[0x0],r12
8000bee4:	99 03       	st.w	r12[0x0],r3
8000bee6:	ce 7b       	rjmp	8000beb4 <__pow5mult+0x54>
8000bee8:	08 9c       	mov	r12,r4
8000beea:	d8 32       	popm	r0-r7,pc

8000beec <__isinfd>:
8000beec:	14 98       	mov	r8,r10
8000beee:	fc 19 7f f0 	movh	r9,0x7ff0
8000bef2:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bef6:	f0 0b 11 00 	rsub	r11,r8,0
8000befa:	f7 e8 10 08 	or	r8,r11,r8
8000befe:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000bf02:	f2 08 01 08 	sub	r8,r9,r8
8000bf06:	f0 0c 11 00 	rsub	r12,r8,0
8000bf0a:	f9 e8 10 08 	or	r8,r12,r8
8000bf0e:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000bf12:	2f fc       	sub	r12,-1
8000bf14:	5e fc       	retal	r12

8000bf16 <__isnand>:
8000bf16:	14 98       	mov	r8,r10
8000bf18:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000bf1c:	f0 0c 11 00 	rsub	r12,r8,0
8000bf20:	10 4c       	or	r12,r8
8000bf22:	fc 18 7f f0 	movh	r8,0x7ff0
8000bf26:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000bf2a:	f0 0c 01 0c 	sub	r12,r8,r12
8000bf2e:	bf 9c       	lsr	r12,0x1f
8000bf30:	5e fc       	retal	r12
8000bf32:	d7 03       	nop

8000bf34 <__sclose>:
8000bf34:	d4 01       	pushm	lr
8000bf36:	96 7b       	ld.sh	r11,r11[0xe]
8000bf38:	c8 2c       	rcall	8000c03c <_close_r>
8000bf3a:	d8 02       	popm	pc

8000bf3c <__sseek>:
8000bf3c:	d4 21       	pushm	r4-r7,lr
8000bf3e:	16 97       	mov	r7,r11
8000bf40:	96 7b       	ld.sh	r11,r11[0xe]
8000bf42:	c0 3d       	rcall	8000c148 <_lseek_r>
8000bf44:	8e 68       	ld.sh	r8,r7[0xc]
8000bf46:	10 99       	mov	r9,r8
8000bf48:	ad c8       	cbr	r8,0xc
8000bf4a:	ad a9       	sbr	r9,0xc
8000bf4c:	5b fc       	cp.w	r12,-1
8000bf4e:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000bf52:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000bf56:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000bf5a:	d8 22       	popm	r4-r7,pc

8000bf5c <__swrite>:
8000bf5c:	d4 21       	pushm	r4-r7,lr
8000bf5e:	96 68       	ld.sh	r8,r11[0xc]
8000bf60:	16 97       	mov	r7,r11
8000bf62:	14 95       	mov	r5,r10
8000bf64:	12 94       	mov	r4,r9
8000bf66:	e2 18 01 00 	andl	r8,0x100,COH
8000bf6a:	18 96       	mov	r6,r12
8000bf6c:	c0 50       	breq	8000bf76 <__swrite+0x1a>
8000bf6e:	30 29       	mov	r9,2
8000bf70:	30 0a       	mov	r10,0
8000bf72:	96 7b       	ld.sh	r11,r11[0xe]
8000bf74:	ce ac       	rcall	8000c148 <_lseek_r>
8000bf76:	8e 68       	ld.sh	r8,r7[0xc]
8000bf78:	ad c8       	cbr	r8,0xc
8000bf7a:	08 99       	mov	r9,r4
8000bf7c:	0a 9a       	mov	r10,r5
8000bf7e:	8e 7b       	ld.sh	r11,r7[0xe]
8000bf80:	0c 9c       	mov	r12,r6
8000bf82:	ae 68       	st.h	r7[0xc],r8
8000bf84:	c1 cc       	rcall	8000bfbc <_write_r>
8000bf86:	d8 22       	popm	r4-r7,pc

8000bf88 <__sread>:
8000bf88:	d4 21       	pushm	r4-r7,lr
8000bf8a:	16 97       	mov	r7,r11
8000bf8c:	96 7b       	ld.sh	r11,r11[0xe]
8000bf8e:	cf 1c       	rcall	8000c170 <_read_r>
8000bf90:	c0 65       	brlt	8000bf9c <__sread+0x14>
8000bf92:	6f 58       	ld.w	r8,r7[0x54]
8000bf94:	18 08       	add	r8,r12
8000bf96:	ef 48 00 54 	st.w	r7[84],r8
8000bf9a:	d8 22       	popm	r4-r7,pc
8000bf9c:	8e 68       	ld.sh	r8,r7[0xc]
8000bf9e:	ad c8       	cbr	r8,0xc
8000bfa0:	ae 68       	st.h	r7[0xc],r8
8000bfa2:	d8 22       	popm	r4-r7,pc

8000bfa4 <strlen>:
8000bfa4:	30 09       	mov	r9,0
8000bfa6:	18 98       	mov	r8,r12
8000bfa8:	c0 28       	rjmp	8000bfac <strlen+0x8>
8000bfaa:	2f f8       	sub	r8,-1
8000bfac:	11 8a       	ld.ub	r10,r8[0x0]
8000bfae:	f2 0a 18 00 	cp.b	r10,r9
8000bfb2:	cf c1       	brne	8000bfaa <strlen+0x6>
8000bfb4:	f0 0c 01 0c 	sub	r12,r8,r12
8000bfb8:	5e fc       	retal	r12
8000bfba:	d7 03       	nop

8000bfbc <_write_r>:
8000bfbc:	d4 21       	pushm	r4-r7,lr
8000bfbe:	16 98       	mov	r8,r11
8000bfc0:	18 97       	mov	r7,r12
8000bfc2:	10 9c       	mov	r12,r8
8000bfc4:	30 08       	mov	r8,0
8000bfc6:	14 9b       	mov	r11,r10
8000bfc8:	e0 66 54 20 	mov	r6,21536
8000bfcc:	12 9a       	mov	r10,r9
8000bfce:	8d 08       	st.w	r6[0x0],r8
8000bfd0:	fe b0 d1 44 	rcall	80006258 <_write>
8000bfd4:	5b fc       	cp.w	r12,-1
8000bfd6:	c0 51       	brne	8000bfe0 <_write_r+0x24>
8000bfd8:	6c 08       	ld.w	r8,r6[0x0]
8000bfda:	58 08       	cp.w	r8,0
8000bfdc:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bfe0:	d8 22       	popm	r4-r7,pc
8000bfe2:	d7 03       	nop

8000bfe4 <_calloc_r>:
8000bfe4:	d4 21       	pushm	r4-r7,lr
8000bfe6:	f4 0b 02 4b 	mul	r11,r10,r11
8000bfea:	fe b0 db 6d 	rcall	800076c4 <_malloc_r>
8000bfee:	18 97       	mov	r7,r12
8000bff0:	c2 30       	breq	8000c036 <_calloc_r+0x52>
8000bff2:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000bff6:	e0 1a ff fc 	andl	r10,0xfffc
8000bffa:	20 4a       	sub	r10,4
8000bffc:	e0 4a 00 24 	cp.w	r10,36
8000c000:	e0 8b 00 18 	brhi	8000c030 <_calloc_r+0x4c>
8000c004:	18 98       	mov	r8,r12
8000c006:	59 3a       	cp.w	r10,19
8000c008:	e0 88 00 0f 	brls	8000c026 <_calloc_r+0x42>
8000c00c:	30 09       	mov	r9,0
8000c00e:	10 a9       	st.w	r8++,r9
8000c010:	10 a9       	st.w	r8++,r9
8000c012:	59 ba       	cp.w	r10,27
8000c014:	e0 88 00 09 	brls	8000c026 <_calloc_r+0x42>
8000c018:	10 a9       	st.w	r8++,r9
8000c01a:	10 a9       	st.w	r8++,r9
8000c01c:	e0 4a 00 24 	cp.w	r10,36
8000c020:	c0 31       	brne	8000c026 <_calloc_r+0x42>
8000c022:	10 a9       	st.w	r8++,r9
8000c024:	10 a9       	st.w	r8++,r9
8000c026:	30 09       	mov	r9,0
8000c028:	10 a9       	st.w	r8++,r9
8000c02a:	91 19       	st.w	r8[0x4],r9
8000c02c:	91 09       	st.w	r8[0x0],r9
8000c02e:	c0 48       	rjmp	8000c036 <_calloc_r+0x52>
8000c030:	30 0b       	mov	r11,0
8000c032:	fe b0 de 1c 	rcall	80007c6a <memset>
8000c036:	0e 9c       	mov	r12,r7
8000c038:	d8 22       	popm	r4-r7,pc
8000c03a:	d7 03       	nop

8000c03c <_close_r>:
8000c03c:	d4 21       	pushm	r4-r7,lr
8000c03e:	30 08       	mov	r8,0
8000c040:	18 97       	mov	r7,r12
8000c042:	e0 66 54 20 	mov	r6,21536
8000c046:	16 9c       	mov	r12,r11
8000c048:	8d 08       	st.w	r6[0x0],r8
8000c04a:	fe b0 df b5 	rcall	80007fb4 <_close>
8000c04e:	5b fc       	cp.w	r12,-1
8000c050:	c0 51       	brne	8000c05a <_close_r+0x1e>
8000c052:	6c 08       	ld.w	r8,r6[0x0]
8000c054:	58 08       	cp.w	r8,0
8000c056:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c05a:	d8 22       	popm	r4-r7,pc

8000c05c <_fclose_r>:
8000c05c:	d4 21       	pushm	r4-r7,lr
8000c05e:	18 96       	mov	r6,r12
8000c060:	16 97       	mov	r7,r11
8000c062:	58 0b       	cp.w	r11,0
8000c064:	c0 31       	brne	8000c06a <_fclose_r+0xe>
8000c066:	16 95       	mov	r5,r11
8000c068:	c5 38       	rjmp	8000c10e <_fclose_r+0xb2>
8000c06a:	fe b0 f8 a9 	rcall	8000b1bc <__sfp_lock_acquire>
8000c06e:	58 06       	cp.w	r6,0
8000c070:	c0 70       	breq	8000c07e <_fclose_r+0x22>
8000c072:	6c 68       	ld.w	r8,r6[0x18]
8000c074:	58 08       	cp.w	r8,0
8000c076:	c0 41       	brne	8000c07e <_fclose_r+0x22>
8000c078:	0c 9c       	mov	r12,r6
8000c07a:	fe b0 f8 f3 	rcall	8000b260 <__sinit>
8000c07e:	fe c8 dc e2 	sub	r8,pc,-8990
8000c082:	10 37       	cp.w	r7,r8
8000c084:	c0 31       	brne	8000c08a <_fclose_r+0x2e>
8000c086:	6c 07       	ld.w	r7,r6[0x0]
8000c088:	c0 c8       	rjmp	8000c0a0 <_fclose_r+0x44>
8000c08a:	fe c8 dc ce 	sub	r8,pc,-9010
8000c08e:	10 37       	cp.w	r7,r8
8000c090:	c0 31       	brne	8000c096 <_fclose_r+0x3a>
8000c092:	6c 17       	ld.w	r7,r6[0x4]
8000c094:	c0 68       	rjmp	8000c0a0 <_fclose_r+0x44>
8000c096:	fe c8 dc ba 	sub	r8,pc,-9030
8000c09a:	10 37       	cp.w	r7,r8
8000c09c:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000c0a0:	8e 69       	ld.sh	r9,r7[0xc]
8000c0a2:	30 08       	mov	r8,0
8000c0a4:	f0 09 19 00 	cp.h	r9,r8
8000c0a8:	c0 51       	brne	8000c0b2 <_fclose_r+0x56>
8000c0aa:	fe b0 f8 8a 	rcall	8000b1be <__sfp_lock_release>
8000c0ae:	30 05       	mov	r5,0
8000c0b0:	c2 f8       	rjmp	8000c10e <_fclose_r+0xb2>
8000c0b2:	0e 9b       	mov	r11,r7
8000c0b4:	0c 9c       	mov	r12,r6
8000c0b6:	fe b0 f7 fd 	rcall	8000b0b0 <_fflush_r>
8000c0ba:	6e c8       	ld.w	r8,r7[0x30]
8000c0bc:	18 95       	mov	r5,r12
8000c0be:	58 08       	cp.w	r8,0
8000c0c0:	c0 60       	breq	8000c0cc <_fclose_r+0x70>
8000c0c2:	6e 8b       	ld.w	r11,r7[0x20]
8000c0c4:	0c 9c       	mov	r12,r6
8000c0c6:	5d 18       	icall	r8
8000c0c8:	f9 b5 05 ff 	movlt	r5,-1
8000c0cc:	8e 68       	ld.sh	r8,r7[0xc]
8000c0ce:	ed b8 00 07 	bld	r8,0x7
8000c0d2:	c0 51       	brne	8000c0dc <_fclose_r+0x80>
8000c0d4:	6e 4b       	ld.w	r11,r7[0x10]
8000c0d6:	0c 9c       	mov	r12,r6
8000c0d8:	fe b0 f9 5e 	rcall	8000b394 <_free_r>
8000c0dc:	6e db       	ld.w	r11,r7[0x34]
8000c0de:	58 0b       	cp.w	r11,0
8000c0e0:	c0 a0       	breq	8000c0f4 <_fclose_r+0x98>
8000c0e2:	ee c8 ff bc 	sub	r8,r7,-68
8000c0e6:	10 3b       	cp.w	r11,r8
8000c0e8:	c0 40       	breq	8000c0f0 <_fclose_r+0x94>
8000c0ea:	0c 9c       	mov	r12,r6
8000c0ec:	fe b0 f9 54 	rcall	8000b394 <_free_r>
8000c0f0:	30 08       	mov	r8,0
8000c0f2:	8f d8       	st.w	r7[0x34],r8
8000c0f4:	6f 2b       	ld.w	r11,r7[0x48]
8000c0f6:	58 0b       	cp.w	r11,0
8000c0f8:	c0 70       	breq	8000c106 <_fclose_r+0xaa>
8000c0fa:	0c 9c       	mov	r12,r6
8000c0fc:	fe b0 f9 4c 	rcall	8000b394 <_free_r>
8000c100:	30 08       	mov	r8,0
8000c102:	ef 48 00 48 	st.w	r7[72],r8
8000c106:	30 08       	mov	r8,0
8000c108:	ae 68       	st.h	r7[0xc],r8
8000c10a:	fe b0 f8 5a 	rcall	8000b1be <__sfp_lock_release>
8000c10e:	0a 9c       	mov	r12,r5
8000c110:	d8 22       	popm	r4-r7,pc
8000c112:	d7 03       	nop

8000c114 <fclose>:
8000c114:	d4 01       	pushm	lr
8000c116:	e0 68 0a 48 	mov	r8,2632
8000c11a:	18 9b       	mov	r11,r12
8000c11c:	70 0c       	ld.w	r12,r8[0x0]
8000c11e:	c9 ff       	rcall	8000c05c <_fclose_r>
8000c120:	d8 02       	popm	pc
8000c122:	d7 03       	nop

8000c124 <_fstat_r>:
8000c124:	d4 21       	pushm	r4-r7,lr
8000c126:	16 98       	mov	r8,r11
8000c128:	18 97       	mov	r7,r12
8000c12a:	10 9c       	mov	r12,r8
8000c12c:	30 08       	mov	r8,0
8000c12e:	e0 66 54 20 	mov	r6,21536
8000c132:	14 9b       	mov	r11,r10
8000c134:	8d 08       	st.w	r6[0x0],r8
8000c136:	fe b0 df 67 	rcall	80008004 <_fstat>
8000c13a:	5b fc       	cp.w	r12,-1
8000c13c:	c0 51       	brne	8000c146 <_fstat_r+0x22>
8000c13e:	6c 08       	ld.w	r8,r6[0x0]
8000c140:	58 08       	cp.w	r8,0
8000c142:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c146:	d8 22       	popm	r4-r7,pc

8000c148 <_lseek_r>:
8000c148:	d4 21       	pushm	r4-r7,lr
8000c14a:	16 98       	mov	r8,r11
8000c14c:	18 97       	mov	r7,r12
8000c14e:	10 9c       	mov	r12,r8
8000c150:	30 08       	mov	r8,0
8000c152:	14 9b       	mov	r11,r10
8000c154:	e0 66 54 20 	mov	r6,21536
8000c158:	12 9a       	mov	r10,r9
8000c15a:	8d 08       	st.w	r6[0x0],r8
8000c15c:	fe b0 df 36 	rcall	80007fc8 <_lseek>
8000c160:	5b fc       	cp.w	r12,-1
8000c162:	c0 51       	brne	8000c16c <_lseek_r+0x24>
8000c164:	6c 08       	ld.w	r8,r6[0x0]
8000c166:	58 08       	cp.w	r8,0
8000c168:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c16c:	d8 22       	popm	r4-r7,pc
8000c16e:	d7 03       	nop

8000c170 <_read_r>:
8000c170:	d4 21       	pushm	r4-r7,lr
8000c172:	16 98       	mov	r8,r11
8000c174:	18 97       	mov	r7,r12
8000c176:	10 9c       	mov	r12,r8
8000c178:	30 08       	mov	r8,0
8000c17a:	14 9b       	mov	r11,r10
8000c17c:	e0 66 54 20 	mov	r6,21536
8000c180:	12 9a       	mov	r10,r9
8000c182:	8d 08       	st.w	r6[0x0],r8
8000c184:	fe b0 d0 4a 	rcall	80006218 <_read>
8000c188:	5b fc       	cp.w	r12,-1
8000c18a:	c0 51       	brne	8000c194 <_read_r+0x24>
8000c18c:	6c 08       	ld.w	r8,r6[0x0]
8000c18e:	58 08       	cp.w	r8,0
8000c190:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000c194:	d8 22       	popm	r4-r7,pc
8000c196:	d7 03       	nop

8000c198 <__avr32_f64_mul>:
8000c198:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000c19c:	e0 80 00 dc 	breq	8000c354 <__avr32_f64_mul_op1_zero>
8000c1a0:	d4 21       	pushm	r4-r7,lr
8000c1a2:	f7 e9 20 0e 	eor	lr,r11,r9
8000c1a6:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c1aa:	30 15       	mov	r5,1
8000c1ac:	c4 30       	breq	8000c232 <__avr32_f64_mul_op1_subnormal>
8000c1ae:	ab 6b       	lsl	r11,0xa
8000c1b0:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000c1b4:	ab 6a       	lsl	r10,0xa
8000c1b6:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000c1ba:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c1be:	c5 c0       	breq	8000c276 <__avr32_f64_mul_op2_subnormal>
8000c1c0:	a1 78       	lsl	r8,0x1
8000c1c2:	5c f9       	rol	r9
8000c1c4:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000c1c8:	e0 47 07 ff 	cp.w	r7,2047
8000c1cc:	c7 70       	breq	8000c2ba <__avr32_f64_mul_op_nan_or_inf>
8000c1ce:	e0 46 07 ff 	cp.w	r6,2047
8000c1d2:	c7 40       	breq	8000c2ba <__avr32_f64_mul_op_nan_or_inf>
8000c1d4:	ee 06 00 0c 	add	r12,r7,r6
8000c1d8:	e0 2c 03 fe 	sub	r12,1022
8000c1dc:	f6 08 06 44 	mulu.d	r4,r11,r8
8000c1e0:	f4 09 07 44 	macu.d	r4,r10,r9
8000c1e4:	f4 08 06 46 	mulu.d	r6,r10,r8
8000c1e8:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000c1ec:	08 07       	add	r7,r4
8000c1ee:	f4 05 00 4a 	adc	r10,r10,r5
8000c1f2:	5c 0b       	acr	r11
8000c1f4:	ed bb 00 14 	bld	r11,0x14
8000c1f8:	c0 50       	breq	8000c202 <__avr32_f64_mul+0x6a>
8000c1fa:	a1 77       	lsl	r7,0x1
8000c1fc:	5c fa       	rol	r10
8000c1fe:	5c fb       	rol	r11
8000c200:	20 1c       	sub	r12,1
8000c202:	58 0c       	cp.w	r12,0
8000c204:	e0 8a 00 6f 	brle	8000c2e2 <__avr32_f64_mul_res_subnormal>
8000c208:	e0 4c 07 ff 	cp.w	r12,2047
8000c20c:	e0 84 00 9c 	brge	8000c344 <__avr32_f64_mul_res_inf>
8000c210:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000c214:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000c218:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000c21c:	ee 17 80 00 	eorh	r7,0x8000
8000c220:	f1 b7 04 20 	satu	r7,0x1
8000c224:	0e 0a       	add	r10,r7
8000c226:	5c 0b       	acr	r11
8000c228:	ed be 00 1f 	bld	lr,0x1f
8000c22c:	ef bb 00 1f 	bst	r11,0x1f
8000c230:	d8 22       	popm	r4-r7,pc

8000c232 <__avr32_f64_mul_op1_subnormal>:
8000c232:	e4 1b 00 0f 	andh	r11,0xf
8000c236:	f4 0c 12 00 	clz	r12,r10
8000c23a:	f6 06 12 00 	clz	r6,r11
8000c23e:	f7 bc 03 e1 	sublo	r12,-31
8000c242:	f8 06 17 30 	movlo	r6,r12
8000c246:	f7 b6 02 01 	subhs	r6,1
8000c24a:	e0 46 00 20 	cp.w	r6,32
8000c24e:	c0 d4       	brge	8000c268 <__avr32_f64_mul_op1_subnormal+0x36>
8000c250:	ec 0c 11 20 	rsub	r12,r6,32
8000c254:	f6 06 09 4b 	lsl	r11,r11,r6
8000c258:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000c25c:	18 4b       	or	r11,r12
8000c25e:	f4 06 09 4a 	lsl	r10,r10,r6
8000c262:	20 b6       	sub	r6,11
8000c264:	0c 17       	sub	r7,r6
8000c266:	ca ab       	rjmp	8000c1ba <__avr32_f64_mul+0x22>
8000c268:	f4 06 09 4b 	lsl	r11,r10,r6
8000c26c:	c6 40       	breq	8000c334 <__avr32_f64_mul_res_zero>
8000c26e:	30 0a       	mov	r10,0
8000c270:	20 b6       	sub	r6,11
8000c272:	0c 17       	sub	r7,r6
8000c274:	ca 3b       	rjmp	8000c1ba <__avr32_f64_mul+0x22>

8000c276 <__avr32_f64_mul_op2_subnormal>:
8000c276:	e4 19 00 0f 	andh	r9,0xf
8000c27a:	f0 0c 12 00 	clz	r12,r8
8000c27e:	f2 05 12 00 	clz	r5,r9
8000c282:	f7 bc 03 ea 	sublo	r12,-22
8000c286:	f8 05 17 30 	movlo	r5,r12
8000c28a:	f7 b5 02 0a 	subhs	r5,10
8000c28e:	e0 45 00 20 	cp.w	r5,32
8000c292:	c0 d4       	brge	8000c2ac <__avr32_f64_mul_op2_subnormal+0x36>
8000c294:	ea 0c 11 20 	rsub	r12,r5,32
8000c298:	f2 05 09 49 	lsl	r9,r9,r5
8000c29c:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000c2a0:	18 49       	or	r9,r12
8000c2a2:	f0 05 09 48 	lsl	r8,r8,r5
8000c2a6:	20 25       	sub	r5,2
8000c2a8:	0a 16       	sub	r6,r5
8000c2aa:	c8 fb       	rjmp	8000c1c8 <__avr32_f64_mul+0x30>
8000c2ac:	f0 05 09 49 	lsl	r9,r8,r5
8000c2b0:	c4 20       	breq	8000c334 <__avr32_f64_mul_res_zero>
8000c2b2:	30 08       	mov	r8,0
8000c2b4:	20 25       	sub	r5,2
8000c2b6:	0a 16       	sub	r6,r5
8000c2b8:	c8 8b       	rjmp	8000c1c8 <__avr32_f64_mul+0x30>

8000c2ba <__avr32_f64_mul_op_nan_or_inf>:
8000c2ba:	e4 19 00 0f 	andh	r9,0xf
8000c2be:	e4 1b 00 0f 	andh	r11,0xf
8000c2c2:	14 4b       	or	r11,r10
8000c2c4:	10 49       	or	r9,r8
8000c2c6:	e0 47 07 ff 	cp.w	r7,2047
8000c2ca:	c0 91       	brne	8000c2dc <__avr32_f64_mul_op1_not_naninf>
8000c2cc:	58 0b       	cp.w	r11,0
8000c2ce:	c3 81       	brne	8000c33e <__avr32_f64_mul_res_nan>
8000c2d0:	e0 46 07 ff 	cp.w	r6,2047
8000c2d4:	c3 81       	brne	8000c344 <__avr32_f64_mul_res_inf>
8000c2d6:	58 09       	cp.w	r9,0
8000c2d8:	c3 60       	breq	8000c344 <__avr32_f64_mul_res_inf>
8000c2da:	c3 28       	rjmp	8000c33e <__avr32_f64_mul_res_nan>

8000c2dc <__avr32_f64_mul_op1_not_naninf>:
8000c2dc:	58 09       	cp.w	r9,0
8000c2de:	c3 30       	breq	8000c344 <__avr32_f64_mul_res_inf>
8000c2e0:	c2 f8       	rjmp	8000c33e <__avr32_f64_mul_res_nan>

8000c2e2 <__avr32_f64_mul_res_subnormal>:
8000c2e2:	5c 3c       	neg	r12
8000c2e4:	2f fc       	sub	r12,-1
8000c2e6:	f1 bc 04 c0 	satu	r12,0x6
8000c2ea:	e0 4c 00 20 	cp.w	r12,32
8000c2ee:	c1 14       	brge	8000c310 <__avr32_f64_mul_res_subnormal+0x2e>
8000c2f0:	f8 08 11 20 	rsub	r8,r12,32
8000c2f4:	0e 46       	or	r6,r7
8000c2f6:	ee 0c 0a 47 	lsr	r7,r7,r12
8000c2fa:	f4 08 09 49 	lsl	r9,r10,r8
8000c2fe:	12 47       	or	r7,r9
8000c300:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c304:	f6 08 09 49 	lsl	r9,r11,r8
8000c308:	12 4a       	or	r10,r9
8000c30a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c30e:	c8 3b       	rjmp	8000c214 <__avr32_f64_mul+0x7c>
8000c310:	f8 08 11 20 	rsub	r8,r12,32
8000c314:	f9 b9 00 00 	moveq	r9,0
8000c318:	c0 30       	breq	8000c31e <__avr32_f64_mul_res_subnormal+0x3c>
8000c31a:	f6 08 09 49 	lsl	r9,r11,r8
8000c31e:	0e 46       	or	r6,r7
8000c320:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000c324:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000c328:	f3 ea 10 07 	or	r7,r9,r10
8000c32c:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000c330:	30 0b       	mov	r11,0
8000c332:	c7 1b       	rjmp	8000c214 <__avr32_f64_mul+0x7c>

8000c334 <__avr32_f64_mul_res_zero>:
8000c334:	1c 9b       	mov	r11,lr
8000c336:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c33a:	30 0a       	mov	r10,0
8000c33c:	d8 22       	popm	r4-r7,pc

8000c33e <__avr32_f64_mul_res_nan>:
8000c33e:	3f fb       	mov	r11,-1
8000c340:	3f fa       	mov	r10,-1
8000c342:	d8 22       	popm	r4-r7,pc

8000c344 <__avr32_f64_mul_res_inf>:
8000c344:	f0 6b 00 00 	mov	r11,-1048576
8000c348:	ed be 00 1f 	bld	lr,0x1f
8000c34c:	ef bb 00 1f 	bst	r11,0x1f
8000c350:	30 0a       	mov	r10,0
8000c352:	d8 22       	popm	r4-r7,pc

8000c354 <__avr32_f64_mul_op1_zero>:
8000c354:	f7 e9 20 0b 	eor	r11,r11,r9
8000c358:	e6 1b 80 00 	andh	r11,0x8000,COH
8000c35c:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000c360:	e0 4c 07 ff 	cp.w	r12,2047
8000c364:	5e 1c       	retne	r12
8000c366:	3f fa       	mov	r10,-1
8000c368:	3f fb       	mov	r11,-1
8000c36a:	5e fc       	retal	r12

8000c36c <__avr32_f64_sub_from_add>:
8000c36c:	ee 19 80 00 	eorh	r9,0x8000

8000c370 <__avr32_f64_sub>:
8000c370:	f7 e9 20 0c 	eor	r12,r11,r9
8000c374:	e0 86 00 ca 	brmi	8000c508 <__avr32_f64_add_from_sub>
8000c378:	eb cd 40 e0 	pushm	r5-r7,lr
8000c37c:	16 9c       	mov	r12,r11
8000c37e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c382:	bf db       	cbr	r11,0x1f
8000c384:	bf d9       	cbr	r9,0x1f
8000c386:	10 3a       	cp.w	r10,r8
8000c388:	f2 0b 13 00 	cpc	r11,r9
8000c38c:	c0 92       	brcc	8000c39e <__avr32_f64_sub+0x2e>
8000c38e:	16 97       	mov	r7,r11
8000c390:	12 9b       	mov	r11,r9
8000c392:	0e 99       	mov	r9,r7
8000c394:	14 97       	mov	r7,r10
8000c396:	10 9a       	mov	r10,r8
8000c398:	0e 98       	mov	r8,r7
8000c39a:	ee 1c 80 00 	eorh	r12,0x8000
8000c39e:	f6 07 16 14 	lsr	r7,r11,0x14
8000c3a2:	ab 7b       	lsl	r11,0xb
8000c3a4:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c3a8:	ab 7a       	lsl	r10,0xb
8000c3aa:	bf bb       	sbr	r11,0x1f
8000c3ac:	f2 06 16 14 	lsr	r6,r9,0x14
8000c3b0:	c4 40       	breq	8000c438 <__avr32_f64_sub_opL_subnormal>
8000c3b2:	ab 79       	lsl	r9,0xb
8000c3b4:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c3b8:	ab 78       	lsl	r8,0xb
8000c3ba:	bf b9       	sbr	r9,0x1f

8000c3bc <__avr32_f64_sub_opL_subnormal_done>:
8000c3bc:	e0 47 07 ff 	cp.w	r7,2047
8000c3c0:	c4 f0       	breq	8000c45e <__avr32_f64_sub_opH_nan_or_inf>
8000c3c2:	0e 26       	rsub	r6,r7
8000c3c4:	c1 20       	breq	8000c3e8 <__avr32_f64_sub_shift_done>
8000c3c6:	ec 05 11 20 	rsub	r5,r6,32
8000c3ca:	e0 46 00 20 	cp.w	r6,32
8000c3ce:	c7 c2       	brcc	8000c4c6 <__avr32_f64_sub_longshift>
8000c3d0:	f0 05 09 4e 	lsl	lr,r8,r5
8000c3d4:	f2 05 09 45 	lsl	r5,r9,r5
8000c3d8:	f0 06 0a 48 	lsr	r8,r8,r6
8000c3dc:	f2 06 0a 49 	lsr	r9,r9,r6
8000c3e0:	0a 48       	or	r8,r5
8000c3e2:	58 0e       	cp.w	lr,0
8000c3e4:	5f 1e       	srne	lr
8000c3e6:	1c 48       	or	r8,lr

8000c3e8 <__avr32_f64_sub_shift_done>:
8000c3e8:	10 1a       	sub	r10,r8
8000c3ea:	f6 09 01 4b 	sbc	r11,r11,r9
8000c3ee:	f6 06 12 00 	clz	r6,r11
8000c3f2:	c0 e0       	breq	8000c40e <__avr32_f64_sub_longnormalize_done>
8000c3f4:	c7 83       	brcs	8000c4e4 <__avr32_f64_sub_longnormalize>
8000c3f6:	ec 0e 11 20 	rsub	lr,r6,32
8000c3fa:	f6 06 09 4b 	lsl	r11,r11,r6
8000c3fe:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c402:	1c 4b       	or	r11,lr
8000c404:	f4 06 09 4a 	lsl	r10,r10,r6
8000c408:	0c 17       	sub	r7,r6
8000c40a:	e0 8a 00 39 	brle	8000c47c <__avr32_f64_sub_subnormal_result>

8000c40e <__avr32_f64_sub_longnormalize_done>:
8000c40e:	f4 09 15 15 	lsl	r9,r10,0x15
8000c412:	ab 9a       	lsr	r10,0xb
8000c414:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c418:	ab 9b       	lsr	r11,0xb
8000c41a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c41e:	18 4b       	or	r11,r12

8000c420 <__avr32_f64_sub_round>:
8000c420:	fc 17 80 00 	movh	r7,0x8000
8000c424:	ed ba 00 00 	bld	r10,0x0
8000c428:	f7 b7 01 ff 	subne	r7,-1
8000c42c:	0e 39       	cp.w	r9,r7
8000c42e:	5f 29       	srhs	r9
8000c430:	12 0a       	add	r10,r9
8000c432:	5c 0b       	acr	r11
8000c434:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c438 <__avr32_f64_sub_opL_subnormal>:
8000c438:	ab 79       	lsl	r9,0xb
8000c43a:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000c43e:	ab 78       	lsl	r8,0xb
8000c440:	f3 e8 10 0e 	or	lr,r9,r8
8000c444:	f9 b6 01 01 	movne	r6,1
8000c448:	ee 0e 11 00 	rsub	lr,r7,0
8000c44c:	f9 b7 00 01 	moveq	r7,1
8000c450:	ef bb 00 1f 	bst	r11,0x1f
8000c454:	f7 ea 10 0e 	or	lr,r11,r10
8000c458:	f9 b7 00 00 	moveq	r7,0
8000c45c:	cb 0b       	rjmp	8000c3bc <__avr32_f64_sub_opL_subnormal_done>

8000c45e <__avr32_f64_sub_opH_nan_or_inf>:
8000c45e:	bf db       	cbr	r11,0x1f
8000c460:	f7 ea 10 0e 	or	lr,r11,r10
8000c464:	c0 81       	brne	8000c474 <__avr32_f64_sub_return_nan>
8000c466:	e0 46 07 ff 	cp.w	r6,2047
8000c46a:	c0 50       	breq	8000c474 <__avr32_f64_sub_return_nan>
8000c46c:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000c470:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c474 <__avr32_f64_sub_return_nan>:
8000c474:	3f fa       	mov	r10,-1
8000c476:	3f fb       	mov	r11,-1
8000c478:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c47c <__avr32_f64_sub_subnormal_result>:
8000c47c:	5c 37       	neg	r7
8000c47e:	2f f7       	sub	r7,-1
8000c480:	f1 b7 04 c0 	satu	r7,0x6
8000c484:	e0 47 00 20 	cp.w	r7,32
8000c488:	c1 14       	brge	8000c4aa <__avr32_f64_sub_subnormal_result+0x2e>
8000c48a:	ee 08 11 20 	rsub	r8,r7,32
8000c48e:	f4 08 09 49 	lsl	r9,r10,r8
8000c492:	5f 16       	srne	r6
8000c494:	f4 07 0a 4a 	lsr	r10,r10,r7
8000c498:	0c 4a       	or	r10,r6
8000c49a:	f6 08 09 49 	lsl	r9,r11,r8
8000c49e:	f5 e9 10 0a 	or	r10,r10,r9
8000c4a2:	f4 07 0a 4b 	lsr	r11,r10,r7
8000c4a6:	30 07       	mov	r7,0
8000c4a8:	cb 3b       	rjmp	8000c40e <__avr32_f64_sub_longnormalize_done>
8000c4aa:	ee 08 11 40 	rsub	r8,r7,64
8000c4ae:	f6 08 09 49 	lsl	r9,r11,r8
8000c4b2:	14 49       	or	r9,r10
8000c4b4:	5f 16       	srne	r6
8000c4b6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000c4ba:	0c 4a       	or	r10,r6
8000c4bc:	30 0b       	mov	r11,0
8000c4be:	30 07       	mov	r7,0
8000c4c0:	ca 7b       	rjmp	8000c40e <__avr32_f64_sub_longnormalize_done>
8000c4c2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c4c6 <__avr32_f64_sub_longshift>:
8000c4c6:	f1 b6 04 c0 	satu	r6,0x6
8000c4ca:	f0 0e 17 00 	moveq	lr,r8
8000c4ce:	c0 40       	breq	8000c4d6 <__avr32_f64_sub_longshift+0x10>
8000c4d0:	f2 05 09 4e 	lsl	lr,r9,r5
8000c4d4:	10 4e       	or	lr,r8
8000c4d6:	f2 06 0a 48 	lsr	r8,r9,r6
8000c4da:	30 09       	mov	r9,0
8000c4dc:	58 0e       	cp.w	lr,0
8000c4de:	5f 1e       	srne	lr
8000c4e0:	1c 48       	or	r8,lr
8000c4e2:	c8 3b       	rjmp	8000c3e8 <__avr32_f64_sub_shift_done>

8000c4e4 <__avr32_f64_sub_longnormalize>:
8000c4e4:	f4 06 12 00 	clz	r6,r10
8000c4e8:	f9 b7 03 00 	movlo	r7,0
8000c4ec:	f9 b6 03 00 	movlo	r6,0
8000c4f0:	f9 bc 03 00 	movlo	r12,0
8000c4f4:	f7 b6 02 e0 	subhs	r6,-32
8000c4f8:	f4 06 09 4b 	lsl	r11,r10,r6
8000c4fc:	30 0a       	mov	r10,0
8000c4fe:	0c 17       	sub	r7,r6
8000c500:	fe 9a ff be 	brle	8000c47c <__avr32_f64_sub_subnormal_result>
8000c504:	c8 5b       	rjmp	8000c40e <__avr32_f64_sub_longnormalize_done>
8000c506:	d7 03       	nop

8000c508 <__avr32_f64_add_from_sub>:
8000c508:	ee 19 80 00 	eorh	r9,0x8000

8000c50c <__avr32_f64_add>:
8000c50c:	f7 e9 20 0c 	eor	r12,r11,r9
8000c510:	fe 96 ff 2e 	brmi	8000c36c <__avr32_f64_sub_from_add>
8000c514:	eb cd 40 e0 	pushm	r5-r7,lr
8000c518:	16 9c       	mov	r12,r11
8000c51a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000c51e:	bf db       	cbr	r11,0x1f
8000c520:	bf d9       	cbr	r9,0x1f
8000c522:	12 3b       	cp.w	r11,r9
8000c524:	c0 72       	brcc	8000c532 <__avr32_f64_add+0x26>
8000c526:	16 97       	mov	r7,r11
8000c528:	12 9b       	mov	r11,r9
8000c52a:	0e 99       	mov	r9,r7
8000c52c:	14 97       	mov	r7,r10
8000c52e:	10 9a       	mov	r10,r8
8000c530:	0e 98       	mov	r8,r7
8000c532:	30 0e       	mov	lr,0
8000c534:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000c538:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000c53c:	b5 ab       	sbr	r11,0x14
8000c53e:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000c542:	c6 20       	breq	8000c606 <__avr32_f64_add_op2_subnormal>
8000c544:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000c548:	b5 a9       	sbr	r9,0x14
8000c54a:	e0 47 07 ff 	cp.w	r7,2047
8000c54e:	c2 80       	breq	8000c59e <__avr32_f64_add_opH_nan_or_inf>
8000c550:	0e 26       	rsub	r6,r7
8000c552:	c1 20       	breq	8000c576 <__avr32_f64_add_shift_done>
8000c554:	e0 46 00 36 	cp.w	r6,54
8000c558:	c1 52       	brcc	8000c582 <__avr32_f64_add_res_of_done>
8000c55a:	ec 05 11 20 	rsub	r5,r6,32
8000c55e:	e0 46 00 20 	cp.w	r6,32
8000c562:	c3 52       	brcc	8000c5cc <__avr32_f64_add_longshift>
8000c564:	f0 05 09 4e 	lsl	lr,r8,r5
8000c568:	f2 05 09 45 	lsl	r5,r9,r5
8000c56c:	f0 06 0a 48 	lsr	r8,r8,r6
8000c570:	f2 06 0a 49 	lsr	r9,r9,r6
8000c574:	0a 48       	or	r8,r5

8000c576 <__avr32_f64_add_shift_done>:
8000c576:	10 0a       	add	r10,r8
8000c578:	f6 09 00 4b 	adc	r11,r11,r9
8000c57c:	ed bb 00 15 	bld	r11,0x15
8000c580:	c3 40       	breq	8000c5e8 <__avr32_f64_add_res_of>

8000c582 <__avr32_f64_add_res_of_done>:
8000c582:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c586:	18 4b       	or	r11,r12

8000c588 <__avr32_f64_add_round>:
8000c588:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000c58c:	18 4e       	or	lr,r12
8000c58e:	ee 1e 80 00 	eorh	lr,0x8000
8000c592:	f1 be 04 20 	satu	lr,0x1
8000c596:	1c 0a       	add	r10,lr
8000c598:	5c 0b       	acr	r11
8000c59a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c59e <__avr32_f64_add_opH_nan_or_inf>:
8000c59e:	b5 cb       	cbr	r11,0x14
8000c5a0:	f7 ea 10 0e 	or	lr,r11,r10
8000c5a4:	c1 01       	brne	8000c5c4 <__avr32_f64_add_return_nan>
8000c5a6:	e0 46 07 ff 	cp.w	r6,2047
8000c5aa:	c0 30       	breq	8000c5b0 <__avr32_f64_add_opL_nan_or_inf>
8000c5ac:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c5b0 <__avr32_f64_add_opL_nan_or_inf>:
8000c5b0:	b5 c9       	cbr	r9,0x14
8000c5b2:	f3 e8 10 0e 	or	lr,r9,r8
8000c5b6:	c0 71       	brne	8000c5c4 <__avr32_f64_add_return_nan>
8000c5b8:	30 0a       	mov	r10,0
8000c5ba:	fc 1b 7f f0 	movh	r11,0x7ff0
8000c5be:	18 4b       	or	r11,r12
8000c5c0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c5c4 <__avr32_f64_add_return_nan>:
8000c5c4:	3f fa       	mov	r10,-1
8000c5c6:	3f fb       	mov	r11,-1
8000c5c8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000c5cc <__avr32_f64_add_longshift>:
8000c5cc:	f1 b6 04 c0 	satu	r6,0x6
8000c5d0:	f0 0e 17 00 	moveq	lr,r8
8000c5d4:	c0 60       	breq	8000c5e0 <__avr32_f64_add_longshift+0x14>
8000c5d6:	f2 05 09 4e 	lsl	lr,r9,r5
8000c5da:	58 08       	cp.w	r8,0
8000c5dc:	5f 18       	srne	r8
8000c5de:	10 4e       	or	lr,r8
8000c5e0:	f2 06 0a 48 	lsr	r8,r9,r6
8000c5e4:	30 09       	mov	r9,0
8000c5e6:	cc 8b       	rjmp	8000c576 <__avr32_f64_add_shift_done>

8000c5e8 <__avr32_f64_add_res_of>:
8000c5e8:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000c5ec:	a1 9b       	lsr	r11,0x1
8000c5ee:	5d 0a       	ror	r10
8000c5f0:	5d 0e       	ror	lr
8000c5f2:	2f f7       	sub	r7,-1
8000c5f4:	e0 47 07 ff 	cp.w	r7,2047
8000c5f8:	f9 ba 00 00 	moveq	r10,0
8000c5fc:	f9 bb 00 00 	moveq	r11,0
8000c600:	f9 be 00 00 	moveq	lr,0
8000c604:	cb fb       	rjmp	8000c582 <__avr32_f64_add_res_of_done>

8000c606 <__avr32_f64_add_op2_subnormal>:
8000c606:	30 16       	mov	r6,1
8000c608:	58 07       	cp.w	r7,0
8000c60a:	ca 01       	brne	8000c54a <__avr32_f64_add+0x3e>
8000c60c:	b5 cb       	cbr	r11,0x14
8000c60e:	10 0a       	add	r10,r8
8000c610:	f6 09 00 4b 	adc	r11,r11,r9
8000c614:	18 4b       	or	r11,r12
8000c616:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000c61a:	d7 03       	nop

8000c61c <__avr32_f64_to_u32>:
8000c61c:	58 0b       	cp.w	r11,0
8000c61e:	5e 6d       	retmi	0

8000c620 <__avr32_f64_to_s32>:
8000c620:	f6 0c 15 01 	lsl	r12,r11,0x1
8000c624:	b5 9c       	lsr	r12,0x15
8000c626:	e0 2c 03 ff 	sub	r12,1023
8000c62a:	5e 3d       	retlo	0
8000c62c:	f8 0c 11 1f 	rsub	r12,r12,31
8000c630:	16 99       	mov	r9,r11
8000c632:	ab 7b       	lsl	r11,0xb
8000c634:	bf bb       	sbr	r11,0x1f
8000c636:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000c63a:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000c63e:	a1 79       	lsl	r9,0x1
8000c640:	5e 2b       	reths	r11
8000c642:	5c 3b       	neg	r11
8000c644:	5e fb       	retal	r11

8000c646 <__avr32_u32_to_f64>:
8000c646:	f8 cb 00 00 	sub	r11,r12,0
8000c64a:	30 0c       	mov	r12,0
8000c64c:	c0 38       	rjmp	8000c652 <__avr32_s32_to_f64+0x4>

8000c64e <__avr32_s32_to_f64>:
8000c64e:	18 9b       	mov	r11,r12
8000c650:	5c 4b       	abs	r11
8000c652:	30 0a       	mov	r10,0
8000c654:	5e 0b       	reteq	r11
8000c656:	d4 01       	pushm	lr
8000c658:	e0 69 04 1e 	mov	r9,1054
8000c65c:	f6 08 12 00 	clz	r8,r11
8000c660:	c1 70       	breq	8000c68e <__avr32_s32_to_f64+0x40>
8000c662:	c0 c3       	brcs	8000c67a <__avr32_s32_to_f64+0x2c>
8000c664:	f0 0e 11 20 	rsub	lr,r8,32
8000c668:	f6 08 09 4b 	lsl	r11,r11,r8
8000c66c:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000c670:	1c 4b       	or	r11,lr
8000c672:	f4 08 09 4a 	lsl	r10,r10,r8
8000c676:	10 19       	sub	r9,r8
8000c678:	c0 b8       	rjmp	8000c68e <__avr32_s32_to_f64+0x40>
8000c67a:	f4 08 12 00 	clz	r8,r10
8000c67e:	f9 b8 03 00 	movlo	r8,0
8000c682:	f7 b8 02 e0 	subhs	r8,-32
8000c686:	f4 08 09 4b 	lsl	r11,r10,r8
8000c68a:	30 0a       	mov	r10,0
8000c68c:	10 19       	sub	r9,r8
8000c68e:	58 09       	cp.w	r9,0
8000c690:	e0 89 00 30 	brgt	8000c6f0 <__avr32_s32_to_f64+0xa2>
8000c694:	5c 39       	neg	r9
8000c696:	2f f9       	sub	r9,-1
8000c698:	e0 49 00 36 	cp.w	r9,54
8000c69c:	c0 43       	brcs	8000c6a4 <__avr32_s32_to_f64+0x56>
8000c69e:	30 0b       	mov	r11,0
8000c6a0:	30 0a       	mov	r10,0
8000c6a2:	c2 68       	rjmp	8000c6ee <__avr32_s32_to_f64+0xa0>
8000c6a4:	2f 69       	sub	r9,-10
8000c6a6:	f2 08 11 20 	rsub	r8,r9,32
8000c6aa:	e0 49 00 20 	cp.w	r9,32
8000c6ae:	c0 b2       	brcc	8000c6c4 <__avr32_s32_to_f64+0x76>
8000c6b0:	f4 08 09 4e 	lsl	lr,r10,r8
8000c6b4:	f6 08 09 48 	lsl	r8,r11,r8
8000c6b8:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c6bc:	f6 09 0a 4b 	lsr	r11,r11,r9
8000c6c0:	10 4b       	or	r11,r8
8000c6c2:	c0 88       	rjmp	8000c6d2 <__avr32_s32_to_f64+0x84>
8000c6c4:	f6 08 09 4e 	lsl	lr,r11,r8
8000c6c8:	14 4e       	or	lr,r10
8000c6ca:	16 9a       	mov	r10,r11
8000c6cc:	30 0b       	mov	r11,0
8000c6ce:	f4 09 0a 4a 	lsr	r10,r10,r9
8000c6d2:	ed ba 00 00 	bld	r10,0x0
8000c6d6:	c0 92       	brcc	8000c6e8 <__avr32_s32_to_f64+0x9a>
8000c6d8:	1c 7e       	tst	lr,lr
8000c6da:	c0 41       	brne	8000c6e2 <__avr32_s32_to_f64+0x94>
8000c6dc:	ed ba 00 01 	bld	r10,0x1
8000c6e0:	c0 42       	brcc	8000c6e8 <__avr32_s32_to_f64+0x9a>
8000c6e2:	2f fa       	sub	r10,-1
8000c6e4:	f7 bb 02 ff 	subhs	r11,-1
8000c6e8:	5c fc       	rol	r12
8000c6ea:	5d 0b       	ror	r11
8000c6ec:	5d 0a       	ror	r10
8000c6ee:	d8 02       	popm	pc
8000c6f0:	e0 68 03 ff 	mov	r8,1023
8000c6f4:	ed ba 00 0b 	bld	r10,0xb
8000c6f8:	f7 b8 00 ff 	subeq	r8,-1
8000c6fc:	10 0a       	add	r10,r8
8000c6fe:	5c 0b       	acr	r11
8000c700:	f7 b9 03 fe 	sublo	r9,-2
8000c704:	e0 49 07 ff 	cp.w	r9,2047
8000c708:	c0 55       	brlt	8000c712 <__avr32_s32_to_f64+0xc4>
8000c70a:	30 0a       	mov	r10,0
8000c70c:	fc 1b ff e0 	movh	r11,0xffe0
8000c710:	c0 c8       	rjmp	8000c728 <__floatsidf_return_op1>
8000c712:	ed bb 00 1f 	bld	r11,0x1f
8000c716:	f7 b9 01 01 	subne	r9,1
8000c71a:	ab 9a       	lsr	r10,0xb
8000c71c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000c720:	a1 7b       	lsl	r11,0x1
8000c722:	ab 9b       	lsr	r11,0xb
8000c724:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000c728 <__floatsidf_return_op1>:
8000c728:	a1 7c       	lsl	r12,0x1
8000c72a:	5d 0b       	ror	r11
8000c72c:	d8 02       	popm	pc

8000c72e <__avr32_f64_cmp_eq>:
8000c72e:	10 3a       	cp.w	r10,r8
8000c730:	f2 0b 13 00 	cpc	r11,r9
8000c734:	c0 80       	breq	8000c744 <__avr32_f64_cmp_eq+0x16>
8000c736:	a1 7b       	lsl	r11,0x1
8000c738:	a1 79       	lsl	r9,0x1
8000c73a:	14 4b       	or	r11,r10
8000c73c:	12 4b       	or	r11,r9
8000c73e:	10 4b       	or	r11,r8
8000c740:	5e 0f       	reteq	1
8000c742:	5e fd       	retal	0
8000c744:	a1 7b       	lsl	r11,0x1
8000c746:	fc 1c ff e0 	movh	r12,0xffe0
8000c74a:	58 0a       	cp.w	r10,0
8000c74c:	f8 0b 13 00 	cpc	r11,r12
8000c750:	5e 8f       	retls	1
8000c752:	5e fd       	retal	0

8000c754 <__avr32_f64_cmp_ge>:
8000c754:	1a de       	st.w	--sp,lr
8000c756:	1a d7       	st.w	--sp,r7
8000c758:	a1 7b       	lsl	r11,0x1
8000c75a:	5f 3c       	srlo	r12
8000c75c:	a1 79       	lsl	r9,0x1
8000c75e:	5f 37       	srlo	r7
8000c760:	5c fc       	rol	r12
8000c762:	fc 1e ff e0 	movh	lr,0xffe0
8000c766:	58 0a       	cp.w	r10,0
8000c768:	fc 0b 13 00 	cpc	r11,lr
8000c76c:	e0 8b 00 1d 	brhi	8000c7a6 <__avr32_f64_cmp_ge+0x52>
8000c770:	58 08       	cp.w	r8,0
8000c772:	fc 09 13 00 	cpc	r9,lr
8000c776:	e0 8b 00 18 	brhi	8000c7a6 <__avr32_f64_cmp_ge+0x52>
8000c77a:	58 0b       	cp.w	r11,0
8000c77c:	f5 ba 00 00 	subfeq	r10,0
8000c780:	c1 50       	breq	8000c7aa <__avr32_f64_cmp_ge+0x56>
8000c782:	1b 07       	ld.w	r7,sp++
8000c784:	1b 0e       	ld.w	lr,sp++
8000c786:	58 3c       	cp.w	r12,3
8000c788:	c0 a0       	breq	8000c79c <__avr32_f64_cmp_ge+0x48>
8000c78a:	58 1c       	cp.w	r12,1
8000c78c:	c0 33       	brcs	8000c792 <__avr32_f64_cmp_ge+0x3e>
8000c78e:	5e 0f       	reteq	1
8000c790:	5e 1d       	retne	0
8000c792:	10 3a       	cp.w	r10,r8
8000c794:	f2 0b 13 00 	cpc	r11,r9
8000c798:	5e 2f       	reths	1
8000c79a:	5e 3d       	retlo	0
8000c79c:	14 38       	cp.w	r8,r10
8000c79e:	f6 09 13 00 	cpc	r9,r11
8000c7a2:	5e 2f       	reths	1
8000c7a4:	5e 3d       	retlo	0
8000c7a6:	1b 07       	ld.w	r7,sp++
8000c7a8:	d8 0a       	popm	pc,r12=0
8000c7aa:	58 17       	cp.w	r7,1
8000c7ac:	5f 0c       	sreq	r12
8000c7ae:	58 09       	cp.w	r9,0
8000c7b0:	f5 b8 00 00 	subfeq	r8,0
8000c7b4:	1b 07       	ld.w	r7,sp++
8000c7b6:	1b 0e       	ld.w	lr,sp++
8000c7b8:	5e 0f       	reteq	1
8000c7ba:	5e fc       	retal	r12

8000c7bc <__avr32_f64_cmp_lt>:
8000c7bc:	1a de       	st.w	--sp,lr
8000c7be:	1a d7       	st.w	--sp,r7
8000c7c0:	a1 7b       	lsl	r11,0x1
8000c7c2:	5f 3c       	srlo	r12
8000c7c4:	a1 79       	lsl	r9,0x1
8000c7c6:	5f 37       	srlo	r7
8000c7c8:	5c fc       	rol	r12
8000c7ca:	fc 1e ff e0 	movh	lr,0xffe0
8000c7ce:	58 0a       	cp.w	r10,0
8000c7d0:	fc 0b 13 00 	cpc	r11,lr
8000c7d4:	e0 8b 00 1d 	brhi	8000c80e <__avr32_f64_cmp_lt+0x52>
8000c7d8:	58 08       	cp.w	r8,0
8000c7da:	fc 09 13 00 	cpc	r9,lr
8000c7de:	e0 8b 00 18 	brhi	8000c80e <__avr32_f64_cmp_lt+0x52>
8000c7e2:	58 0b       	cp.w	r11,0
8000c7e4:	f5 ba 00 00 	subfeq	r10,0
8000c7e8:	c1 50       	breq	8000c812 <__avr32_f64_cmp_lt+0x56>
8000c7ea:	1b 07       	ld.w	r7,sp++
8000c7ec:	1b 0e       	ld.w	lr,sp++
8000c7ee:	58 3c       	cp.w	r12,3
8000c7f0:	c0 a0       	breq	8000c804 <__avr32_f64_cmp_lt+0x48>
8000c7f2:	58 1c       	cp.w	r12,1
8000c7f4:	c0 33       	brcs	8000c7fa <__avr32_f64_cmp_lt+0x3e>
8000c7f6:	5e 0d       	reteq	0
8000c7f8:	5e 1f       	retne	1
8000c7fa:	10 3a       	cp.w	r10,r8
8000c7fc:	f2 0b 13 00 	cpc	r11,r9
8000c800:	5e 2d       	reths	0
8000c802:	5e 3f       	retlo	1
8000c804:	14 38       	cp.w	r8,r10
8000c806:	f6 09 13 00 	cpc	r9,r11
8000c80a:	5e 2d       	reths	0
8000c80c:	5e 3f       	retlo	1
8000c80e:	1b 07       	ld.w	r7,sp++
8000c810:	d8 0a       	popm	pc,r12=0
8000c812:	58 17       	cp.w	r7,1
8000c814:	5f 1c       	srne	r12
8000c816:	58 09       	cp.w	r9,0
8000c818:	f5 b8 00 00 	subfeq	r8,0
8000c81c:	1b 07       	ld.w	r7,sp++
8000c81e:	1b 0e       	ld.w	lr,sp++
8000c820:	5e 0d       	reteq	0
8000c822:	5e fc       	retal	r12

8000c824 <__avr32_f64_div>:
8000c824:	eb cd 40 ff 	pushm	r0-r7,lr
8000c828:	f7 e9 20 0e 	eor	lr,r11,r9
8000c82c:	f6 07 16 14 	lsr	r7,r11,0x14
8000c830:	a9 7b       	lsl	r11,0x9
8000c832:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000c836:	a9 7a       	lsl	r10,0x9
8000c838:	bd bb       	sbr	r11,0x1d
8000c83a:	e4 1b 3f ff 	andh	r11,0x3fff
8000c83e:	ab d7       	cbr	r7,0xb
8000c840:	e0 80 00 cc 	breq	8000c9d8 <__avr32_f64_div_round_subnormal+0x54>
8000c844:	e0 47 07 ff 	cp.w	r7,2047
8000c848:	e0 84 00 b5 	brge	8000c9b2 <__avr32_f64_div_round_subnormal+0x2e>
8000c84c:	f2 06 16 14 	lsr	r6,r9,0x14
8000c850:	a9 79       	lsl	r9,0x9
8000c852:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000c856:	a9 78       	lsl	r8,0x9
8000c858:	bd b9       	sbr	r9,0x1d
8000c85a:	e4 19 3f ff 	andh	r9,0x3fff
8000c85e:	ab d6       	cbr	r6,0xb
8000c860:	e0 80 00 e2 	breq	8000ca24 <__avr32_f64_div_round_subnormal+0xa0>
8000c864:	e0 46 07 ff 	cp.w	r6,2047
8000c868:	e0 84 00 b2 	brge	8000c9cc <__avr32_f64_div_round_subnormal+0x48>
8000c86c:	0c 17       	sub	r7,r6
8000c86e:	fe 37 fc 01 	sub	r7,-1023
8000c872:	fc 1c 80 00 	movh	r12,0x8000
8000c876:	f8 03 16 01 	lsr	r3,r12,0x1
8000c87a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000c87e:	5c d4       	com	r4
8000c880:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000c884:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c888:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c88c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c890:	ea 03 15 02 	lsl	r3,r5,0x2
8000c894:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c898:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c89c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c8a0:	ea 03 15 02 	lsl	r3,r5,0x2
8000c8a4:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c8a8:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000c8ac:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c8b0:	ea 03 15 02 	lsl	r3,r5,0x2
8000c8b4:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c8b8:	e4 09 07 40 	macu.d	r0,r2,r9
8000c8bc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c8c0:	02 04       	add	r4,r1
8000c8c2:	5c 05       	acr	r5
8000c8c4:	a3 65       	lsl	r5,0x2
8000c8c6:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c8ca:	a3 64       	lsl	r4,0x2
8000c8cc:	5c 34       	neg	r4
8000c8ce:	f8 05 01 45 	sbc	r5,r12,r5
8000c8d2:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c8d6:	e4 05 07 40 	macu.d	r0,r2,r5
8000c8da:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c8de:	02 04       	add	r4,r1
8000c8e0:	5c 05       	acr	r5
8000c8e2:	ea 03 15 02 	lsl	r3,r5,0x2
8000c8e6:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c8ea:	e8 02 15 02 	lsl	r2,r4,0x2
8000c8ee:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c8f2:	e4 09 07 40 	macu.d	r0,r2,r9
8000c8f6:	e6 09 06 44 	mulu.d	r4,r3,r9
8000c8fa:	02 04       	add	r4,r1
8000c8fc:	5c 05       	acr	r5
8000c8fe:	a3 65       	lsl	r5,0x2
8000c900:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000c904:	a3 64       	lsl	r4,0x2
8000c906:	5c 34       	neg	r4
8000c908:	f8 05 01 45 	sbc	r5,r12,r5
8000c90c:	e6 04 06 40 	mulu.d	r0,r3,r4
8000c910:	e4 05 07 40 	macu.d	r0,r2,r5
8000c914:	e6 05 06 44 	mulu.d	r4,r3,r5
8000c918:	02 04       	add	r4,r1
8000c91a:	5c 05       	acr	r5
8000c91c:	ea 03 15 02 	lsl	r3,r5,0x2
8000c920:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000c924:	e8 02 15 02 	lsl	r2,r4,0x2
8000c928:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000c92c:	e4 0b 07 40 	macu.d	r0,r2,r11
8000c930:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000c934:	02 02       	add	r2,r1
8000c936:	5c 03       	acr	r3
8000c938:	ed b3 00 1c 	bld	r3,0x1c
8000c93c:	c0 90       	breq	8000c94e <__avr32_f64_div+0x12a>
8000c93e:	a1 72       	lsl	r2,0x1
8000c940:	5c f3       	rol	r3
8000c942:	20 17       	sub	r7,1
8000c944:	a3 9a       	lsr	r10,0x3
8000c946:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000c94a:	a3 9b       	lsr	r11,0x3
8000c94c:	c0 58       	rjmp	8000c956 <__avr32_f64_div+0x132>
8000c94e:	a5 8a       	lsr	r10,0x4
8000c950:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000c954:	a5 8b       	lsr	r11,0x4
8000c956:	58 07       	cp.w	r7,0
8000c958:	e0 8a 00 8b 	brle	8000ca6e <__avr32_f64_div_res_subnormal>
8000c95c:	e0 12 ff 00 	andl	r2,0xff00
8000c960:	e8 12 00 80 	orl	r2,0x80
8000c964:	e6 08 06 40 	mulu.d	r0,r3,r8
8000c968:	e4 09 07 40 	macu.d	r0,r2,r9
8000c96c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000c970:	e6 09 06 48 	mulu.d	r8,r3,r9
8000c974:	00 05       	add	r5,r0
8000c976:	f0 01 00 48 	adc	r8,r8,r1
8000c97a:	5c 09       	acr	r9
8000c97c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000c980:	58 04       	cp.w	r4,0
8000c982:	5c 25       	cpc	r5

8000c984 <__avr32_f64_div_round_subnormal>:
8000c984:	f4 08 13 00 	cpc	r8,r10
8000c988:	f6 09 13 00 	cpc	r9,r11
8000c98c:	5f 36       	srlo	r6
8000c98e:	f8 06 17 00 	moveq	r6,r12
8000c992:	e4 0a 16 08 	lsr	r10,r2,0x8
8000c996:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000c99a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000c99e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000c9a2:	ed be 00 1f 	bld	lr,0x1f
8000c9a6:	ef bb 00 1f 	bst	r11,0x1f
8000c9aa:	0c 0a       	add	r10,r6
8000c9ac:	5c 0b       	acr	r11
8000c9ae:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000c9b2:	e4 1b 00 0f 	andh	r11,0xf
8000c9b6:	14 4b       	or	r11,r10
8000c9b8:	e0 81 00 a7 	brne	8000cb06 <__avr32_f64_div_res_subnormal+0x98>
8000c9bc:	f2 06 16 14 	lsr	r6,r9,0x14
8000c9c0:	ab d6       	cbr	r6,0xb
8000c9c2:	e0 46 07 ff 	cp.w	r6,2047
8000c9c6:	e0 81 00 a4 	brne	8000cb0e <__avr32_f64_div_res_subnormal+0xa0>
8000c9ca:	c9 e8       	rjmp	8000cb06 <__avr32_f64_div_res_subnormal+0x98>
8000c9cc:	e4 19 00 0f 	andh	r9,0xf
8000c9d0:	10 49       	or	r9,r8
8000c9d2:	e0 81 00 9a 	brne	8000cb06 <__avr32_f64_div_res_subnormal+0x98>
8000c9d6:	c9 28       	rjmp	8000cafa <__avr32_f64_div_res_subnormal+0x8c>
8000c9d8:	a3 7b       	lsl	r11,0x3
8000c9da:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000c9de:	a3 7a       	lsl	r10,0x3
8000c9e0:	f5 eb 10 04 	or	r4,r10,r11
8000c9e4:	e0 80 00 a0 	breq	8000cb24 <__avr32_f64_div_op1_zero>
8000c9e8:	f6 04 12 00 	clz	r4,r11
8000c9ec:	c1 70       	breq	8000ca1a <__avr32_f64_div_round_subnormal+0x96>
8000c9ee:	c0 c3       	brcs	8000ca06 <__avr32_f64_div_round_subnormal+0x82>
8000c9f0:	e8 05 11 20 	rsub	r5,r4,32
8000c9f4:	f6 04 09 4b 	lsl	r11,r11,r4
8000c9f8:	f4 05 0a 45 	lsr	r5,r10,r5
8000c9fc:	0a 4b       	or	r11,r5
8000c9fe:	f4 04 09 4a 	lsl	r10,r10,r4
8000ca02:	08 17       	sub	r7,r4
8000ca04:	c0 b8       	rjmp	8000ca1a <__avr32_f64_div_round_subnormal+0x96>
8000ca06:	f4 04 12 00 	clz	r4,r10
8000ca0a:	f9 b4 03 00 	movlo	r4,0
8000ca0e:	f7 b4 02 e0 	subhs	r4,-32
8000ca12:	f4 04 09 4b 	lsl	r11,r10,r4
8000ca16:	30 0a       	mov	r10,0
8000ca18:	08 17       	sub	r7,r4
8000ca1a:	a3 8a       	lsr	r10,0x2
8000ca1c:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000ca20:	a3 8b       	lsr	r11,0x2
8000ca22:	c1 1b       	rjmp	8000c844 <__avr32_f64_div+0x20>
8000ca24:	a3 79       	lsl	r9,0x3
8000ca26:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000ca2a:	a3 78       	lsl	r8,0x3
8000ca2c:	f3 e8 10 04 	or	r4,r9,r8
8000ca30:	c6 f0       	breq	8000cb0e <__avr32_f64_div_res_subnormal+0xa0>
8000ca32:	f2 04 12 00 	clz	r4,r9
8000ca36:	c1 70       	breq	8000ca64 <__avr32_f64_div_round_subnormal+0xe0>
8000ca38:	c0 c3       	brcs	8000ca50 <__avr32_f64_div_round_subnormal+0xcc>
8000ca3a:	e8 05 11 20 	rsub	r5,r4,32
8000ca3e:	f2 04 09 49 	lsl	r9,r9,r4
8000ca42:	f0 05 0a 45 	lsr	r5,r8,r5
8000ca46:	0a 49       	or	r9,r5
8000ca48:	f0 04 09 48 	lsl	r8,r8,r4
8000ca4c:	08 16       	sub	r6,r4
8000ca4e:	c0 b8       	rjmp	8000ca64 <__avr32_f64_div_round_subnormal+0xe0>
8000ca50:	f0 04 12 00 	clz	r4,r8
8000ca54:	f9 b4 03 00 	movlo	r4,0
8000ca58:	f7 b4 02 e0 	subhs	r4,-32
8000ca5c:	f0 04 09 49 	lsl	r9,r8,r4
8000ca60:	30 08       	mov	r8,0
8000ca62:	08 16       	sub	r6,r4
8000ca64:	a3 88       	lsr	r8,0x2
8000ca66:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000ca6a:	a3 89       	lsr	r9,0x2
8000ca6c:	cf ca       	rjmp	8000c864 <__avr32_f64_div+0x40>

8000ca6e <__avr32_f64_div_res_subnormal>:
8000ca6e:	5c 37       	neg	r7
8000ca70:	2f f7       	sub	r7,-1
8000ca72:	f1 b7 04 c0 	satu	r7,0x6
8000ca76:	e0 47 00 20 	cp.w	r7,32
8000ca7a:	c1 54       	brge	8000caa4 <__avr32_f64_div_res_subnormal+0x36>
8000ca7c:	ee 06 11 20 	rsub	r6,r7,32
8000ca80:	e4 07 0a 42 	lsr	r2,r2,r7
8000ca84:	e6 06 09 4c 	lsl	r12,r3,r6
8000ca88:	18 42       	or	r2,r12
8000ca8a:	e6 07 0a 43 	lsr	r3,r3,r7
8000ca8e:	f4 06 09 41 	lsl	r1,r10,r6
8000ca92:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ca96:	f6 06 09 4c 	lsl	r12,r11,r6
8000ca9a:	18 4a       	or	r10,r12
8000ca9c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000caa0:	30 00       	mov	r0,0
8000caa2:	c1 58       	rjmp	8000cacc <__avr32_f64_div_res_subnormal+0x5e>
8000caa4:	ee 06 11 20 	rsub	r6,r7,32
8000caa8:	f9 b0 00 00 	moveq	r0,0
8000caac:	f9 bc 00 00 	moveq	r12,0
8000cab0:	c0 50       	breq	8000caba <__avr32_f64_div_res_subnormal+0x4c>
8000cab2:	f4 06 09 40 	lsl	r0,r10,r6
8000cab6:	f6 06 09 4c 	lsl	r12,r11,r6
8000caba:	e6 07 0a 42 	lsr	r2,r3,r7
8000cabe:	30 03       	mov	r3,0
8000cac0:	f4 07 0a 41 	lsr	r1,r10,r7
8000cac4:	18 41       	or	r1,r12
8000cac6:	f6 07 0a 4a 	lsr	r10,r11,r7
8000caca:	30 0b       	mov	r11,0
8000cacc:	e0 12 ff 00 	andl	r2,0xff00
8000cad0:	e8 12 00 80 	orl	r2,0x80
8000cad4:	e6 08 06 46 	mulu.d	r6,r3,r8
8000cad8:	e4 09 07 46 	macu.d	r6,r2,r9
8000cadc:	e4 08 06 44 	mulu.d	r4,r2,r8
8000cae0:	e6 09 06 48 	mulu.d	r8,r3,r9
8000cae4:	0c 05       	add	r5,r6
8000cae6:	f0 07 00 48 	adc	r8,r8,r7
8000caea:	5c 09       	acr	r9
8000caec:	30 07       	mov	r7,0
8000caee:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000caf2:	00 34       	cp.w	r4,r0
8000caf4:	e2 05 13 00 	cpc	r5,r1
8000caf8:	c4 6b       	rjmp	8000c984 <__avr32_f64_div_round_subnormal>
8000cafa:	1c 9b       	mov	r11,lr
8000cafc:	e6 1b 80 00 	andh	r11,0x8000,COH
8000cb00:	30 0a       	mov	r10,0
8000cb02:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000cb06:	3f fb       	mov	r11,-1
8000cb08:	30 0a       	mov	r10,0
8000cb0a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000cb0e:	f5 eb 10 04 	or	r4,r10,r11
8000cb12:	c0 90       	breq	8000cb24 <__avr32_f64_div_op1_zero>
8000cb14:	1c 9b       	mov	r11,lr
8000cb16:	e6 1b 80 00 	andh	r11,0x8000,COH
8000cb1a:	ea 1b 7f f0 	orh	r11,0x7ff0
8000cb1e:	30 0a       	mov	r10,0
8000cb20:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000cb24 <__avr32_f64_div_op1_zero>:
8000cb24:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000cb28:	ce f0       	breq	8000cb06 <__avr32_f64_div_res_subnormal+0x98>
8000cb2a:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000cb2e:	e0 44 07 ff 	cp.w	r4,2047
8000cb32:	ce 41       	brne	8000cafa <__avr32_f64_div_res_subnormal+0x8c>
8000cb34:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000cb38:	ce 10       	breq	8000cafa <__avr32_f64_div_res_subnormal+0x8c>
8000cb3a:	ce 6b       	rjmp	8000cb06 <__avr32_f64_div_res_subnormal+0x98>

8000cb3c <__avr32_udiv64>:
8000cb3c:	d4 31       	pushm	r0-r7,lr
8000cb3e:	1a 97       	mov	r7,sp
8000cb40:	20 3d       	sub	sp,12
8000cb42:	10 9c       	mov	r12,r8
8000cb44:	12 9e       	mov	lr,r9
8000cb46:	14 93       	mov	r3,r10
8000cb48:	58 09       	cp.w	r9,0
8000cb4a:	e0 81 00 bd 	brne	8000ccc4 <__avr32_udiv64+0x188>
8000cb4e:	16 38       	cp.w	r8,r11
8000cb50:	e0 88 00 40 	brls	8000cbd0 <__avr32_udiv64+0x94>
8000cb54:	f0 08 12 00 	clz	r8,r8
8000cb58:	c0 d0       	breq	8000cb72 <__avr32_udiv64+0x36>
8000cb5a:	f6 08 09 4b 	lsl	r11,r11,r8
8000cb5e:	f0 09 11 20 	rsub	r9,r8,32
8000cb62:	f8 08 09 4c 	lsl	r12,r12,r8
8000cb66:	f4 09 0a 49 	lsr	r9,r10,r9
8000cb6a:	f4 08 09 43 	lsl	r3,r10,r8
8000cb6e:	f3 eb 10 0b 	or	r11,r9,r11
8000cb72:	f8 0e 16 10 	lsr	lr,r12,0x10
8000cb76:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000cb7a:	f6 0e 0d 00 	divu	r0,r11,lr
8000cb7e:	e6 0b 16 10 	lsr	r11,r3,0x10
8000cb82:	00 99       	mov	r9,r0
8000cb84:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cb88:	e0 0a 02 48 	mul	r8,r0,r10
8000cb8c:	10 3b       	cp.w	r11,r8
8000cb8e:	c0 a2       	brcc	8000cba2 <__avr32_udiv64+0x66>
8000cb90:	20 19       	sub	r9,1
8000cb92:	18 0b       	add	r11,r12
8000cb94:	18 3b       	cp.w	r11,r12
8000cb96:	c0 63       	brcs	8000cba2 <__avr32_udiv64+0x66>
8000cb98:	10 3b       	cp.w	r11,r8
8000cb9a:	f7 b9 03 01 	sublo	r9,1
8000cb9e:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cba2:	f6 08 01 01 	sub	r1,r11,r8
8000cba6:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000cbaa:	e2 0e 0d 00 	divu	r0,r1,lr
8000cbae:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000cbb2:	00 98       	mov	r8,r0
8000cbb4:	e0 0a 02 4a 	mul	r10,r0,r10
8000cbb8:	14 33       	cp.w	r3,r10
8000cbba:	c0 82       	brcc	8000cbca <__avr32_udiv64+0x8e>
8000cbbc:	20 18       	sub	r8,1
8000cbbe:	18 03       	add	r3,r12
8000cbc0:	18 33       	cp.w	r3,r12
8000cbc2:	c0 43       	brcs	8000cbca <__avr32_udiv64+0x8e>
8000cbc4:	14 33       	cp.w	r3,r10
8000cbc6:	f7 b8 03 01 	sublo	r8,1
8000cbca:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000cbce:	cd f8       	rjmp	8000cd8c <__avr32_udiv64+0x250>
8000cbd0:	58 08       	cp.w	r8,0
8000cbd2:	c0 51       	brne	8000cbdc <__avr32_udiv64+0xa0>
8000cbd4:	30 19       	mov	r9,1
8000cbd6:	f2 08 0d 08 	divu	r8,r9,r8
8000cbda:	10 9c       	mov	r12,r8
8000cbdc:	f8 06 12 00 	clz	r6,r12
8000cbe0:	c0 41       	brne	8000cbe8 <__avr32_udiv64+0xac>
8000cbe2:	18 1b       	sub	r11,r12
8000cbe4:	30 19       	mov	r9,1
8000cbe6:	c4 08       	rjmp	8000cc66 <__avr32_udiv64+0x12a>
8000cbe8:	ec 01 11 20 	rsub	r1,r6,32
8000cbec:	f4 01 0a 49 	lsr	r9,r10,r1
8000cbf0:	f8 06 09 4c 	lsl	r12,r12,r6
8000cbf4:	f6 06 09 48 	lsl	r8,r11,r6
8000cbf8:	f6 01 0a 41 	lsr	r1,r11,r1
8000cbfc:	f3 e8 10 08 	or	r8,r9,r8
8000cc00:	f8 03 16 10 	lsr	r3,r12,0x10
8000cc04:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000cc08:	e2 03 0d 00 	divu	r0,r1,r3
8000cc0c:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cc10:	00 9e       	mov	lr,r0
8000cc12:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cc16:	e0 05 02 49 	mul	r9,r0,r5
8000cc1a:	12 3b       	cp.w	r11,r9
8000cc1c:	c0 a2       	brcc	8000cc30 <__avr32_udiv64+0xf4>
8000cc1e:	20 1e       	sub	lr,1
8000cc20:	18 0b       	add	r11,r12
8000cc22:	18 3b       	cp.w	r11,r12
8000cc24:	c0 63       	brcs	8000cc30 <__avr32_udiv64+0xf4>
8000cc26:	12 3b       	cp.w	r11,r9
8000cc28:	f7 be 03 01 	sublo	lr,1
8000cc2c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cc30:	12 1b       	sub	r11,r9
8000cc32:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000cc36:	f6 03 0d 02 	divu	r2,r11,r3
8000cc3a:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000cc3e:	04 99       	mov	r9,r2
8000cc40:	e4 05 02 4b 	mul	r11,r2,r5
8000cc44:	16 38       	cp.w	r8,r11
8000cc46:	c0 a2       	brcc	8000cc5a <__avr32_udiv64+0x11e>
8000cc48:	20 19       	sub	r9,1
8000cc4a:	18 08       	add	r8,r12
8000cc4c:	18 38       	cp.w	r8,r12
8000cc4e:	c0 63       	brcs	8000cc5a <__avr32_udiv64+0x11e>
8000cc50:	16 38       	cp.w	r8,r11
8000cc52:	f7 b9 03 01 	sublo	r9,1
8000cc56:	f1 dc e3 08 	addcs	r8,r8,r12
8000cc5a:	f4 06 09 43 	lsl	r3,r10,r6
8000cc5e:	f0 0b 01 0b 	sub	r11,r8,r11
8000cc62:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000cc66:	f8 06 16 10 	lsr	r6,r12,0x10
8000cc6a:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000cc6e:	f6 06 0d 00 	divu	r0,r11,r6
8000cc72:	e6 0b 16 10 	lsr	r11,r3,0x10
8000cc76:	00 9a       	mov	r10,r0
8000cc78:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cc7c:	e0 0e 02 48 	mul	r8,r0,lr
8000cc80:	10 3b       	cp.w	r11,r8
8000cc82:	c0 a2       	brcc	8000cc96 <__avr32_udiv64+0x15a>
8000cc84:	20 1a       	sub	r10,1
8000cc86:	18 0b       	add	r11,r12
8000cc88:	18 3b       	cp.w	r11,r12
8000cc8a:	c0 63       	brcs	8000cc96 <__avr32_udiv64+0x15a>
8000cc8c:	10 3b       	cp.w	r11,r8
8000cc8e:	f7 ba 03 01 	sublo	r10,1
8000cc92:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cc96:	f6 08 01 01 	sub	r1,r11,r8
8000cc9a:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000cc9e:	e2 06 0d 00 	divu	r0,r1,r6
8000cca2:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000cca6:	00 98       	mov	r8,r0
8000cca8:	e0 0e 02 4b 	mul	r11,r0,lr
8000ccac:	16 33       	cp.w	r3,r11
8000ccae:	c0 82       	brcc	8000ccbe <__avr32_udiv64+0x182>
8000ccb0:	20 18       	sub	r8,1
8000ccb2:	18 03       	add	r3,r12
8000ccb4:	18 33       	cp.w	r3,r12
8000ccb6:	c0 43       	brcs	8000ccbe <__avr32_udiv64+0x182>
8000ccb8:	16 33       	cp.w	r3,r11
8000ccba:	f7 b8 03 01 	sublo	r8,1
8000ccbe:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000ccc2:	c6 98       	rjmp	8000cd94 <__avr32_udiv64+0x258>
8000ccc4:	16 39       	cp.w	r9,r11
8000ccc6:	e0 8b 00 65 	brhi	8000cd90 <__avr32_udiv64+0x254>
8000ccca:	f2 09 12 00 	clz	r9,r9
8000ccce:	c0 b1       	brne	8000cce4 <__avr32_udiv64+0x1a8>
8000ccd0:	10 3a       	cp.w	r10,r8
8000ccd2:	5f 2a       	srhs	r10
8000ccd4:	1c 3b       	cp.w	r11,lr
8000ccd6:	5f b8       	srhi	r8
8000ccd8:	10 4a       	or	r10,r8
8000ccda:	f2 0a 18 00 	cp.b	r10,r9
8000ccde:	c5 90       	breq	8000cd90 <__avr32_udiv64+0x254>
8000cce0:	30 18       	mov	r8,1
8000cce2:	c5 98       	rjmp	8000cd94 <__avr32_udiv64+0x258>
8000cce4:	f0 09 09 46 	lsl	r6,r8,r9
8000cce8:	f2 03 11 20 	rsub	r3,r9,32
8000ccec:	fc 09 09 4e 	lsl	lr,lr,r9
8000ccf0:	f0 03 0a 48 	lsr	r8,r8,r3
8000ccf4:	f6 09 09 4c 	lsl	r12,r11,r9
8000ccf8:	f4 03 0a 42 	lsr	r2,r10,r3
8000ccfc:	ef 46 ff f4 	st.w	r7[-12],r6
8000cd00:	f6 03 0a 43 	lsr	r3,r11,r3
8000cd04:	18 42       	or	r2,r12
8000cd06:	f1 ee 10 0c 	or	r12,r8,lr
8000cd0a:	f8 01 16 10 	lsr	r1,r12,0x10
8000cd0e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000cd12:	e6 01 0d 04 	divu	r4,r3,r1
8000cd16:	e4 03 16 10 	lsr	r3,r2,0x10
8000cd1a:	08 9e       	mov	lr,r4
8000cd1c:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000cd20:	e8 06 02 48 	mul	r8,r4,r6
8000cd24:	10 33       	cp.w	r3,r8
8000cd26:	c0 a2       	brcc	8000cd3a <__avr32_udiv64+0x1fe>
8000cd28:	20 1e       	sub	lr,1
8000cd2a:	18 03       	add	r3,r12
8000cd2c:	18 33       	cp.w	r3,r12
8000cd2e:	c0 63       	brcs	8000cd3a <__avr32_udiv64+0x1fe>
8000cd30:	10 33       	cp.w	r3,r8
8000cd32:	f7 be 03 01 	sublo	lr,1
8000cd36:	e7 dc e3 03 	addcs	r3,r3,r12
8000cd3a:	10 13       	sub	r3,r8
8000cd3c:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000cd40:	e6 01 0d 00 	divu	r0,r3,r1
8000cd44:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000cd48:	00 98       	mov	r8,r0
8000cd4a:	e0 06 02 46 	mul	r6,r0,r6
8000cd4e:	0c 3b       	cp.w	r11,r6
8000cd50:	c0 a2       	brcc	8000cd64 <__avr32_udiv64+0x228>
8000cd52:	20 18       	sub	r8,1
8000cd54:	18 0b       	add	r11,r12
8000cd56:	18 3b       	cp.w	r11,r12
8000cd58:	c0 63       	brcs	8000cd64 <__avr32_udiv64+0x228>
8000cd5a:	0c 3b       	cp.w	r11,r6
8000cd5c:	f7 dc e3 0b 	addcs	r11,r11,r12
8000cd60:	f7 b8 03 01 	sublo	r8,1
8000cd64:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000cd68:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000cd6c:	0c 1b       	sub	r11,r6
8000cd6e:	f0 04 06 42 	mulu.d	r2,r8,r4
8000cd72:	06 95       	mov	r5,r3
8000cd74:	16 35       	cp.w	r5,r11
8000cd76:	e0 8b 00 0a 	brhi	8000cd8a <__avr32_udiv64+0x24e>
8000cd7a:	5f 0b       	sreq	r11
8000cd7c:	f4 09 09 49 	lsl	r9,r10,r9
8000cd80:	12 32       	cp.w	r2,r9
8000cd82:	5f b9       	srhi	r9
8000cd84:	f7 e9 00 09 	and	r9,r11,r9
8000cd88:	c0 60       	breq	8000cd94 <__avr32_udiv64+0x258>
8000cd8a:	20 18       	sub	r8,1
8000cd8c:	30 09       	mov	r9,0
8000cd8e:	c0 38       	rjmp	8000cd94 <__avr32_udiv64+0x258>
8000cd90:	30 09       	mov	r9,0
8000cd92:	12 98       	mov	r8,r9
8000cd94:	10 9a       	mov	r10,r8
8000cd96:	12 93       	mov	r3,r9
8000cd98:	10 92       	mov	r2,r8
8000cd9a:	12 9b       	mov	r11,r9
8000cd9c:	2f dd       	sub	sp,-12
8000cd9e:	d8 32       	popm	r0-r7,pc

8000cda0 <__avr32_umod64>:
8000cda0:	d4 31       	pushm	r0-r7,lr
8000cda2:	1a 97       	mov	r7,sp
8000cda4:	20 3d       	sub	sp,12
8000cda6:	10 9c       	mov	r12,r8
8000cda8:	12 95       	mov	r5,r9
8000cdaa:	14 9e       	mov	lr,r10
8000cdac:	16 91       	mov	r1,r11
8000cdae:	16 96       	mov	r6,r11
8000cdb0:	58 09       	cp.w	r9,0
8000cdb2:	e0 81 00 81 	brne	8000ceb4 <__avr32_umod64+0x114>
8000cdb6:	16 38       	cp.w	r8,r11
8000cdb8:	e0 88 00 12 	brls	8000cddc <__avr32_umod64+0x3c>
8000cdbc:	f0 08 12 00 	clz	r8,r8
8000cdc0:	c4 e0       	breq	8000ce5c <__avr32_umod64+0xbc>
8000cdc2:	f6 08 09 46 	lsl	r6,r11,r8
8000cdc6:	f8 08 09 4c 	lsl	r12,r12,r8
8000cdca:	f0 0b 11 20 	rsub	r11,r8,32
8000cdce:	f4 08 09 4e 	lsl	lr,r10,r8
8000cdd2:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000cdd6:	f7 e6 10 06 	or	r6,r11,r6
8000cdda:	c4 18       	rjmp	8000ce5c <__avr32_umod64+0xbc>
8000cddc:	58 08       	cp.w	r8,0
8000cdde:	c0 51       	brne	8000cde8 <__avr32_umod64+0x48>
8000cde0:	30 19       	mov	r9,1
8000cde2:	f2 08 0d 08 	divu	r8,r9,r8
8000cde6:	10 9c       	mov	r12,r8
8000cde8:	f8 08 12 00 	clz	r8,r12
8000cdec:	c0 31       	brne	8000cdf2 <__avr32_umod64+0x52>
8000cdee:	18 16       	sub	r6,r12
8000cdf0:	c3 68       	rjmp	8000ce5c <__avr32_umod64+0xbc>
8000cdf2:	f0 03 11 20 	rsub	r3,r8,32
8000cdf6:	f4 03 0a 4b 	lsr	r11,r10,r3
8000cdfa:	f8 08 09 4c 	lsl	r12,r12,r8
8000cdfe:	ec 08 09 49 	lsl	r9,r6,r8
8000ce02:	ec 03 0a 43 	lsr	r3,r6,r3
8000ce06:	f7 e9 10 09 	or	r9,r11,r9
8000ce0a:	f8 05 16 10 	lsr	r5,r12,0x10
8000ce0e:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000ce12:	e6 05 0d 02 	divu	r2,r3,r5
8000ce16:	f2 0e 16 10 	lsr	lr,r9,0x10
8000ce1a:	ec 02 02 4b 	mul	r11,r6,r2
8000ce1e:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000ce22:	16 3e       	cp.w	lr,r11
8000ce24:	c0 72       	brcc	8000ce32 <__avr32_umod64+0x92>
8000ce26:	18 0e       	add	lr,r12
8000ce28:	18 3e       	cp.w	lr,r12
8000ce2a:	c0 43       	brcs	8000ce32 <__avr32_umod64+0x92>
8000ce2c:	16 3e       	cp.w	lr,r11
8000ce2e:	fd dc e3 0e 	addcs	lr,lr,r12
8000ce32:	fc 0b 01 03 	sub	r3,lr,r11
8000ce36:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000ce3a:	e6 05 0d 02 	divu	r2,r3,r5
8000ce3e:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ce42:	a5 36       	mul	r6,r2
8000ce44:	0c 39       	cp.w	r9,r6
8000ce46:	c0 72       	brcc	8000ce54 <__avr32_umod64+0xb4>
8000ce48:	18 09       	add	r9,r12
8000ce4a:	18 39       	cp.w	r9,r12
8000ce4c:	c0 43       	brcs	8000ce54 <__avr32_umod64+0xb4>
8000ce4e:	0c 39       	cp.w	r9,r6
8000ce50:	f3 dc e3 09 	addcs	r9,r9,r12
8000ce54:	f2 06 01 06 	sub	r6,r9,r6
8000ce58:	f4 08 09 4e 	lsl	lr,r10,r8
8000ce5c:	f8 0a 16 10 	lsr	r10,r12,0x10
8000ce60:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000ce64:	ec 0a 0d 02 	divu	r2,r6,r10
8000ce68:	fc 09 16 10 	lsr	r9,lr,0x10
8000ce6c:	ea 02 02 4b 	mul	r11,r5,r2
8000ce70:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000ce74:	16 39       	cp.w	r9,r11
8000ce76:	c0 72       	brcc	8000ce84 <__avr32_umod64+0xe4>
8000ce78:	18 09       	add	r9,r12
8000ce7a:	18 39       	cp.w	r9,r12
8000ce7c:	c0 43       	brcs	8000ce84 <__avr32_umod64+0xe4>
8000ce7e:	16 39       	cp.w	r9,r11
8000ce80:	f3 dc e3 09 	addcs	r9,r9,r12
8000ce84:	f2 0b 01 0b 	sub	r11,r9,r11
8000ce88:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000ce8c:	f6 0a 0d 0a 	divu	r10,r11,r10
8000ce90:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000ce94:	ea 0a 02 4a 	mul	r10,r5,r10
8000ce98:	14 3e       	cp.w	lr,r10
8000ce9a:	c0 72       	brcc	8000cea8 <__avr32_umod64+0x108>
8000ce9c:	18 0e       	add	lr,r12
8000ce9e:	18 3e       	cp.w	lr,r12
8000cea0:	c0 43       	brcs	8000cea8 <__avr32_umod64+0x108>
8000cea2:	14 3e       	cp.w	lr,r10
8000cea4:	fd dc e3 0e 	addcs	lr,lr,r12
8000cea8:	fc 0a 01 0a 	sub	r10,lr,r10
8000ceac:	30 0b       	mov	r11,0
8000ceae:	f4 08 0a 4a 	lsr	r10,r10,r8
8000ceb2:	c7 b8       	rjmp	8000cfa8 <__avr32_umod64+0x208>
8000ceb4:	16 39       	cp.w	r9,r11
8000ceb6:	e0 8b 00 79 	brhi	8000cfa8 <__avr32_umod64+0x208>
8000ceba:	f2 09 12 00 	clz	r9,r9
8000cebe:	c1 21       	brne	8000cee2 <__avr32_umod64+0x142>
8000cec0:	10 3a       	cp.w	r10,r8
8000cec2:	5f 2b       	srhs	r11
8000cec4:	0a 31       	cp.w	r1,r5
8000cec6:	5f ba       	srhi	r10
8000cec8:	f7 ea 10 0a 	or	r10,r11,r10
8000cecc:	f2 0a 18 00 	cp.b	r10,r9
8000ced0:	c0 60       	breq	8000cedc <__avr32_umod64+0x13c>
8000ced2:	fc 08 01 0c 	sub	r12,lr,r8
8000ced6:	e2 05 01 46 	sbc	r6,r1,r5
8000ceda:	18 9e       	mov	lr,r12
8000cedc:	0c 9b       	mov	r11,r6
8000cede:	1c 9a       	mov	r10,lr
8000cee0:	c6 48       	rjmp	8000cfa8 <__avr32_umod64+0x208>
8000cee2:	ea 09 09 4c 	lsl	r12,r5,r9
8000cee6:	f2 06 11 20 	rsub	r6,r9,32
8000ceea:	f6 09 09 4b 	lsl	r11,r11,r9
8000ceee:	f0 09 09 42 	lsl	r2,r8,r9
8000cef2:	ef 46 ff f4 	st.w	r7[-12],r6
8000cef6:	f0 06 0a 48 	lsr	r8,r8,r6
8000cefa:	18 48       	or	r8,r12
8000cefc:	e2 06 0a 4c 	lsr	r12,r1,r6
8000cf00:	f4 09 09 43 	lsl	r3,r10,r9
8000cf04:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000cf08:	f4 06 0a 4a 	lsr	r10,r10,r6
8000cf0c:	16 4a       	or	r10,r11
8000cf0e:	f0 0b 16 10 	lsr	r11,r8,0x10
8000cf12:	f8 0b 0d 04 	divu	r4,r12,r11
8000cf16:	f4 0c 16 10 	lsr	r12,r10,0x10
8000cf1a:	08 91       	mov	r1,r4
8000cf1c:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000cf20:	e8 0e 02 46 	mul	r6,r4,lr
8000cf24:	0c 3c       	cp.w	r12,r6
8000cf26:	c0 a2       	brcc	8000cf3a <__avr32_umod64+0x19a>
8000cf28:	20 11       	sub	r1,1
8000cf2a:	10 0c       	add	r12,r8
8000cf2c:	10 3c       	cp.w	r12,r8
8000cf2e:	c0 63       	brcs	8000cf3a <__avr32_umod64+0x19a>
8000cf30:	0c 3c       	cp.w	r12,r6
8000cf32:	f7 b1 03 01 	sublo	r1,1
8000cf36:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000cf3a:	0c 1c       	sub	r12,r6
8000cf3c:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000cf40:	f8 0b 0d 04 	divu	r4,r12,r11
8000cf44:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000cf48:	08 96       	mov	r6,r4
8000cf4a:	e8 0e 02 4e 	mul	lr,r4,lr
8000cf4e:	1c 3b       	cp.w	r11,lr
8000cf50:	c0 a2       	brcc	8000cf64 <__avr32_umod64+0x1c4>
8000cf52:	20 16       	sub	r6,1
8000cf54:	10 0b       	add	r11,r8
8000cf56:	10 3b       	cp.w	r11,r8
8000cf58:	c0 63       	brcs	8000cf64 <__avr32_umod64+0x1c4>
8000cf5a:	1c 3b       	cp.w	r11,lr
8000cf5c:	f7 b6 03 01 	sublo	r6,1
8000cf60:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000cf64:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000cf68:	1c 1b       	sub	r11,lr
8000cf6a:	e2 02 06 40 	mulu.d	r0,r1,r2
8000cf6e:	00 9e       	mov	lr,r0
8000cf70:	02 9c       	mov	r12,r1
8000cf72:	16 3c       	cp.w	r12,r11
8000cf74:	e0 8b 00 08 	brhi	8000cf84 <__avr32_umod64+0x1e4>
8000cf78:	5f 06       	sreq	r6
8000cf7a:	06 30       	cp.w	r0,r3
8000cf7c:	5f ba       	srhi	r10
8000cf7e:	ed ea 00 0a 	and	r10,r6,r10
8000cf82:	c0 60       	breq	8000cf8e <__avr32_umod64+0x1ee>
8000cf84:	fc 02 01 04 	sub	r4,lr,r2
8000cf88:	f8 08 01 4c 	sbc	r12,r12,r8
8000cf8c:	08 9e       	mov	lr,r4
8000cf8e:	e6 0e 01 0a 	sub	r10,r3,lr
8000cf92:	f6 0c 01 4c 	sbc	r12,r11,r12
8000cf96:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000cf9a:	f8 09 0a 4b 	lsr	r11,r12,r9
8000cf9e:	f4 09 0a 4a 	lsr	r10,r10,r9
8000cfa2:	f8 01 09 4c 	lsl	r12,r12,r1
8000cfa6:	18 4a       	or	r10,r12
8000cfa8:	2f dd       	sub	sp,-12
8000cfaa:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000d000 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000d000:	c0 08       	rjmp	8000d000 <_evba>
	...

8000d004 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000d004:	c0 08       	rjmp	8000d004 <_handle_TLB_Multiple_Hit>
	...

8000d008 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000d008:	c0 08       	rjmp	8000d008 <_handle_Bus_Error_Data_Fetch>
	...

8000d00c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000d00c:	c0 08       	rjmp	8000d00c <_handle_Bus_Error_Instruction_Fetch>
	...

8000d010 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000d010:	c0 08       	rjmp	8000d010 <_handle_NMI>
	...

8000d014 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000d014:	c0 08       	rjmp	8000d014 <_handle_Instruction_Address>
	...

8000d018 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000d018:	c0 08       	rjmp	8000d018 <_handle_ITLB_Protection>
	...

8000d01c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000d01c:	c0 08       	rjmp	8000d01c <_handle_Breakpoint>
	...

8000d020 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000d020:	c0 08       	rjmp	8000d020 <_handle_Illegal_Opcode>
	...

8000d024 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000d024:	c0 08       	rjmp	8000d024 <_handle_Unimplemented_Instruction>
	...

8000d028 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000d028:	c0 08       	rjmp	8000d028 <_handle_Privilege_Violation>
	...

8000d02c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000d02c:	c0 08       	rjmp	8000d02c <_handle_Floating_Point>
	...

8000d030 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000d030:	c0 08       	rjmp	8000d030 <_handle_Coprocessor_Absent>
	...

8000d034 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000d034:	c0 08       	rjmp	8000d034 <_handle_Data_Address_Read>
	...

8000d038 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000d038:	c0 08       	rjmp	8000d038 <_handle_Data_Address_Write>
	...

8000d03c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000d03c:	c0 08       	rjmp	8000d03c <_handle_DTLB_Protection_Read>
	...

8000d040 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000d040:	c0 08       	rjmp	8000d040 <_handle_DTLB_Protection_Write>
	...

8000d044 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000d044:	c0 08       	rjmp	8000d044 <_handle_DTLB_Modified>
	...

8000d050 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000d050:	c0 08       	rjmp	8000d050 <_handle_ITLB_Miss>
	...

8000d060 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000d060:	c0 08       	rjmp	8000d060 <_handle_DTLB_Miss_Read>
	...

8000d070 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000d070:	c0 08       	rjmp	8000d070 <_handle_DTLB_Miss_Write>
	...

8000d100 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000d100:	fe cf 70 48 	sub	pc,pc,28744

8000d104 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000d104:	30 0c       	mov	r12,0
8000d106:	fe b0 c4 9f 	rcall	80005a44 <_get_interrupt_handler>
8000d10a:	58 0c       	cp.w	r12,0
8000d10c:	f8 0f 17 10 	movne	pc,r12
8000d110:	d6 03       	rete

8000d112 <_int1>:
8000d112:	30 1c       	mov	r12,1
8000d114:	fe b0 c4 98 	rcall	80005a44 <_get_interrupt_handler>
8000d118:	58 0c       	cp.w	r12,0
8000d11a:	f8 0f 17 10 	movne	pc,r12
8000d11e:	d6 03       	rete

8000d120 <_int2>:
8000d120:	30 2c       	mov	r12,2
8000d122:	fe b0 c4 91 	rcall	80005a44 <_get_interrupt_handler>
8000d126:	58 0c       	cp.w	r12,0
8000d128:	f8 0f 17 10 	movne	pc,r12
8000d12c:	d6 03       	rete

8000d12e <_int3>:
8000d12e:	30 3c       	mov	r12,3
8000d130:	fe b0 c4 8a 	rcall	80005a44 <_get_interrupt_handler>
8000d134:	58 0c       	cp.w	r12,0
8000d136:	f8 0f 17 10 	movne	pc,r12
8000d13a:	d6 03       	rete

8000d13c <ipr_val>:
8000d13c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000d14c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d15c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d16c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d17c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d18c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d19c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1ac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1bc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1cc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1dc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1ec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000d1fc:	d7 03 d7 03                                         ....
