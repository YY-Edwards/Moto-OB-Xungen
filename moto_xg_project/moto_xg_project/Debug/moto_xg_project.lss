
moto_xg_project.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009910  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  8000ba00  8000ba00  0000be00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001238  8000bc00  8000bc00  0000c000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         00000a18  00000004  8000ce38  0000d404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .balign       00000004  00000a1c  8000d850  0000de1c  2**0
                  ALLOC
  7 .bss          00001588  00000a20  8000d850  0000de20  2**2
                  ALLOC
  8 .comment      00000030  00000000  00000000  0000de1c  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 000016f8  00000000  00000000  0000de50  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000356a  00000000  00000000  0000f548  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0002c643  00000000  00000000  00012ab2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 000074c1  00000000  00000000  0003f0f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000d849  00000000  00000000  000465b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003eec  00000000  00000000  00053e00  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00007df3  00000000  00000000  00057cec  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f9ef  00000000  00000000  0005fadf  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .stack        00001000  00017000  00017000  00000400  2**0
                  ALLOC
 18 .debug_ranges 000017b8  00000000  00000000  0006f4d0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
	   // rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf d5 54 	sub	pc,pc,-10924

Disassembly of section .text:

80002004 <DeviceManagement_brdcst_func>:
80002004:	19 a9       	ld.ub	r9,r12[0x2]
80002006:	30 18       	mov	r8,1
		U8 temp = 0;
		temp  = xcmp->u8[1] << 8;
		temp |= xcmp->u8[2];
		//if (temp == theXNL_Ctrlr.XNL_DeviceLogicalAddress)
		{
			if (xcmp->u8[0] == 0x01)
80002008:	f0 09 18 00 	cp.b	r9,r8
8000200c:	c0 61       	brne	80002018 <DeviceManagement_brdcst_func+0x14>
			{
				bunchofrandomstatusflags |= 0x00000002;
8000200e:	48 68       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
80002010:	70 09       	ld.w	r9,r8[0x0]
80002012:	a1 b9       	sbr	r9,0x1
80002014:	91 09       	st.w	r8[0x0],r9
80002016:	5e fc       	retal	r12
			}
			else
			{
				bunchofrandomstatusflags &= 0xFFFFFFFD;
80002018:	48 38       	lddpc	r8,80002024 <DeviceManagement_brdcst_func+0x20>
8000201a:	70 09       	ld.w	r9,r8[0x0]
8000201c:	a1 d9       	cbr	r9,0x1
8000201e:	91 09       	st.w	r8[0x0],r9
80002020:	5e fc       	retal	r12
80002022:	00 00       	add	r0,r0
80002024:	00 00       	add	r0,r0
80002026:	0c e4       	st.h	--r6,r4

80002028 <Volume_brdcst_func>:
	//log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
	
	//log("\n\r Audio_Parameter: %x \n\r", ptr->Audio_Parameter);
	
	
}
80002028:	5e fc       	retal	r12

8000202a <AudioRoutingControl_brdcst_func>:
	//
	//log("\n\r Audio-Function: %x \n\r", xcmp->u8[3+j*2-1]);
	
	
	
}
8000202a:	5e fc       	retal	r12

8000202c <vApplicationIdleHook>:
}

void vApplicationIdleHook( void )
{
	/* This hook function does nothing but increment a counter. */
	ulIdleCycleCount++;
8000202c:	48 38       	lddpc	r8,80002038 <vApplicationIdleHook+0xc>
8000202e:	70 09       	ld.w	r9,r8[0x0]
80002030:	2f f9       	sub	r9,-1
80002032:	91 09       	st.w	r8[0x0],r9
	
}
80002034:	5e fc       	retal	r12
80002036:	00 00       	add	r0,r0
80002038:	00 00       	add	r0,r0
8000203a:	0a 38       	cp.w	r8,r5

8000203c <app_init>:
	//0x00,0x39


};
void app_init(void)
{	
8000203c:	d4 01       	pushm	lr
	xcmp_register_app_list(the_app_list);
8000203e:	48 cc       	lddpc	r12,8000206c <app_init+0x30>
80002040:	f0 1f 00 0c 	mcall	80002070 <app_init+0x34>
	
	//将app_payload_rx_proc更改为PCM加密功能
	payload_init( app_payload_rx_proc , app_payload_tx_proc );
80002044:	48 cb       	lddpc	r11,80002074 <app_init+0x38>
80002046:	48 dc       	lddpc	r12,80002078 <app_init+0x3c>
80002048:	f0 1f 00 0d 	mcall	8000207c <app_init+0x40>
	
	static portBASE_TYPE res = 0;
	 res = xTaskCreate(
8000204c:	30 09       	mov	r9,0
8000204e:	1a d9       	st.w	--sp,r9
80002050:	1a d9       	st.w	--sp,r9
80002052:	1a d9       	st.w	--sp,r9
80002054:	30 18       	mov	r8,1
80002056:	e0 6a 01 80 	mov	r10,384
8000205a:	48 ab       	lddpc	r11,80002080 <app_init+0x44>
8000205c:	48 ac       	lddpc	r12,80002084 <app_init+0x48>
8000205e:	f0 1f 00 0b 	mcall	80002088 <app_init+0x4c>
80002062:	48 b8       	lddpc	r8,8000208c <app_init+0x50>
80002064:	91 0c       	st.w	r8[0x0],r12
80002066:	2f dd       	sub	sp,-12
	,  384//1024//800//384
	,  NULL
	,  1
	,  NULL );
	
}
80002068:	d8 02       	popm	pc
8000206a:	00 00       	add	r0,r0
8000206c:	00 00       	add	r0,r0
8000206e:	00 08       	add	r8,r0
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	32 04       	mov	r4,32
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	20 90       	sub	r0,9
80002078:	80 00       	ld.sh	r0,r0[0x0]
8000207a:	20 a4       	sub	r4,10
8000207c:	80 00       	ld.sh	r0,r0[0x0]
8000207e:	31 a8       	mov	r8,26
80002080:	80 00       	ld.sh	r0,r0[0x0]
80002082:	bc 00       	st.h	lr[0x0],r0
80002084:	80 00       	ld.sh	r0,r0[0x0]
80002086:	27 3c       	sub	r12,115
80002088:	80 00       	ld.sh	r0,r0[0x0]
8000208a:	59 a4       	cp.w	r4,26
8000208c:	00 00       	add	r0,r0
8000208e:	0a 34       	cp.w	r4,r5

80002090 <app_payload_tx_proc>:

}


static void app_payload_tx_proc(void  * payload)
{
80002090:	d4 01       	pushm	lr
  log("R");
80002092:	48 3c       	lddpc	r12,8000209c <app_payload_tx_proc+0xc>
80002094:	f0 1f 00 03 	mcall	800020a0 <app_payload_tx_proc+0x10>
  //
  //
  //set_payload_idle(payload);


}
80002098:	d8 02       	popm	pc
8000209a:	00 00       	add	r0,r0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	bc 08       	st.h	lr[0x0],r8
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	5d 68       	*unknown*

800020a4 <app_payload_rx_proc>:
}



static void app_payload_rx_proc(void  * payload)
{
800020a4:	d4 01       	pushm	lr
	static  U8 times_counter = 0;
	
	times_counter++;
800020a6:	48 99       	lddpc	r9,800020c8 <app_payload_rx_proc+0x24>
800020a8:	13 88       	ld.ub	r8,r9[0x0]
800020aa:	2f f8       	sub	r8,-1
800020ac:	b2 88       	st.b	r9[0x0],r8
	if (times_counter == 3)
800020ae:	30 39       	mov	r9,3
800020b0:	f2 08 18 00 	cp.b	r8,r9
800020b4:	c0 71       	brne	800020c2 <app_payload_rx_proc+0x1e>
	{
		times_counter = 0 ;
800020b6:	30 09       	mov	r9,0
800020b8:	48 48       	lddpc	r8,800020c8 <app_payload_rx_proc+0x24>
800020ba:	b0 89       	st.b	r8[0x0],r9
		log("\n\r w: \n\r");
800020bc:	48 4c       	lddpc	r12,800020cc <app_payload_rx_proc+0x28>
800020be:	f0 1f 00 05 	mcall	800020d0 <app_payload_rx_proc+0x2c>
	}
	//log("\n\r w: \n\r");
	if (AMBE_tx_flag)//本地发送方的mic录音
800020c2:	48 58       	lddpc	r8,800020d4 <app_payload_rx_proc+0x30>
800020c4:	11 88       	ld.ub	r8,r8[0x0]
	}
	
	//payload_fragment_t * ptr = (payload_fragment_t *)payload;
	//set_payload_idle(payload);

}
800020c6:	d8 02       	popm	pc
800020c8:	00 00       	add	r0,r0
800020ca:	0a 28       	rsub	r8,r5
800020cc:	80 00       	ld.sh	r0,r0[0x0]
800020ce:	bc 0c       	st.h	lr[0x0],r12
800020d0:	80 00       	ld.sh	r0,r0[0x0]
800020d2:	5d 68       	*unknown*
800020d4:	00 00       	add	r0,r0
800020d6:	0a 21       	rsub	r1,r5

800020d8 <FD_brdcst_func>:
	
	
}

void FD_brdcst_func(xcmp_fragment_t * xcmp)
{
800020d8:	d4 01       	pushm	lr
	
	
	log("\n\r Forward Data Broadcast \n\r");
800020da:	48 3c       	lddpc	r12,800020e4 <FD_brdcst_func+0xc>
800020dc:	f0 1f 00 03 	mcall	800020e8 <FD_brdcst_func+0x10>
	
}
800020e0:	d8 02       	popm	pc
800020e2:	00 00       	add	r0,r0
800020e4:	80 00       	ld.sh	r0,r0[0x0]
800020e6:	bc 18       	st.h	lr[0x2],r8
800020e8:	80 00       	ld.sh	r0,r0[0x0]
800020ea:	5d 68       	*unknown*

800020ec <FD_reply_func>:
	
	
}

void FD_reply_func(xcmp_fragment_t * xcmp)
{
800020ec:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Reply \n\r");
800020ee:	48 3c       	lddpc	r12,800020f8 <FD_reply_func+0xc>
800020f0:	f0 1f 00 03 	mcall	800020fc <FD_reply_func+0x10>
	
	
}
800020f4:	d8 02       	popm	pc
800020f6:	00 00       	add	r0,r0
800020f8:	80 00       	ld.sh	r0,r0[0x0]
800020fa:	bc 38       	st.h	lr[0x6],r8
800020fc:	80 00       	ld.sh	r0,r0[0x0]
800020fe:	5d 68       	*unknown*

80002100 <FD_request_func>:
}



void FD_request_func(xcmp_fragment_t * xcmp)
{
80002100:	d4 01       	pushm	lr
	
	log("\n\r Forward Data Request \n\r");
80002102:	48 3c       	lddpc	r12,8000210c <FD_request_func+0xc>
80002104:	f0 1f 00 03 	mcall	80002110 <FD_request_func+0x10>
	
	
}
80002108:	d8 02       	popm	pc
8000210a:	00 00       	add	r0,r0
8000210c:	80 00       	ld.sh	r0,r0[0x0]
8000210e:	bc 54       	st.h	lr[0xa],r4
80002110:	80 00       	ld.sh	r0,r0[0x0]
80002112:	5d 68       	*unknown*

80002114 <EnOB_brdcst_func>:
	
	
}

void EnOB_brdcst_func(xcmp_fragment_t * xcmp)
{
80002114:	d4 01       	pushm	lr
	
	
	log("\n\r En_OB Broadcast \n\r");
80002116:	48 3c       	lddpc	r12,80002120 <EnOB_brdcst_func+0xc>
80002118:	f0 1f 00 03 	mcall	80002124 <EnOB_brdcst_func+0x10>
}
8000211c:	d8 02       	popm	pc
8000211e:	00 00       	add	r0,r0
80002120:	80 00       	ld.sh	r0,r0[0x0]
80002122:	bc 70       	st.h	lr[0xe],r0
80002124:	80 00       	ld.sh	r0,r0[0x0]
80002126:	5d 68       	*unknown*

80002128 <EnOB_reply_func>:
}



void EnOB_reply_func(xcmp_fragment_t * xcmp)
{
80002128:	eb cd 40 80 	pushm	r7,lr
8000212c:	18 97       	mov	r7,r12
		/*point to xcmp payload*/
	//En_OB_Control_reply_t *ptr = (En_OB_Control_reply_t* )xcmp->u8;
	//log("\n\r Xcmp_opcode: %x \n\r", xcmp->xcmp_opcode);
	
	if (xcmp->u8[0]== xcmp_Res_Success)
8000212e:	19 a9       	ld.ub	r9,r12[0x2]
80002130:	30 08       	mov	r8,0
80002132:	f0 09 18 00 	cp.b	r9,r8
80002136:	c1 91       	brne	80002168 <EnOB_reply_func+0x40>
	{
		if (xcmp->u8[1] == EN_OB_Enter)
80002138:	19 b8       	ld.ub	r8,r12[0x3]
8000213a:	30 19       	mov	r9,1
8000213c:	f2 08 18 00 	cp.b	r8,r9
80002140:	c0 61       	brne	8000214c <EnOB_reply_func+0x24>
		{
		
			log("\n\r En_OB_Enter OK \n\r");
80002142:	49 0c       	lddpc	r12,80002180 <EnOB_reply_func+0x58>
80002144:	f0 1f 00 10 	mcall	80002184 <EnOB_reply_func+0x5c>
80002148:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else if (xcmp->u8[1] == EN_OB_Exit )
8000214c:	58 08       	cp.w	r8,0
8000214e:	c0 61       	brne	8000215a <EnOB_reply_func+0x32>
		{
			log("\n\r En_OB_Exit OK \n\r");
80002150:	48 ec       	lddpc	r12,80002188 <EnOB_reply_func+0x60>
80002152:	f0 1f 00 0d 	mcall	80002184 <EnOB_reply_func+0x5c>
80002156:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		else
		{
			
			log("\n\r En_OB_Control: %x \n\r", xcmp->u8[1]);
8000215a:	1a d8       	st.w	--sp,r8
8000215c:	48 cc       	lddpc	r12,8000218c <EnOB_reply_func+0x64>
8000215e:	f0 1f 00 0a 	mcall	80002184 <EnOB_reply_func+0x5c>
80002162:	2f fd       	sub	sp,-4
80002164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r En_OB_Control error \n\r");
80002168:	48 ac       	lddpc	r12,80002190 <EnOB_reply_func+0x68>
8000216a:	f0 1f 00 07 	mcall	80002184 <EnOB_reply_func+0x5c>
		log("\n\r En_OB_result: %x \n\r", xcmp->u8[0]);
8000216e:	0f a8       	ld.ub	r8,r7[0x2]
80002170:	1a d8       	st.w	--sp,r8
80002172:	48 9c       	lddpc	r12,80002194 <EnOB_reply_func+0x6c>
80002174:	f0 1f 00 04 	mcall	80002184 <EnOB_reply_func+0x5c>
80002178:	2f fd       	sub	sp,-4
8000217a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000217e:	00 00       	add	r0,r0
80002180:	80 00       	ld.sh	r0,r0[0x0]
80002182:	bc 88       	st.b	lr[0x0],r8
80002184:	80 00       	ld.sh	r0,r0[0x0]
80002186:	5d 68       	*unknown*
80002188:	80 00       	ld.sh	r0,r0[0x0]
8000218a:	bc a0       	st.b	lr[0x2],r0
8000218c:	80 00       	ld.sh	r0,r0[0x0]
8000218e:	bc b4       	st.b	lr[0x3],r4
80002190:	80 00       	ld.sh	r0,r0[0x0]
80002192:	bc cc       	st.b	lr[0x4],r12
80002194:	80 00       	ld.sh	r0,r0[0x0]
80002196:	bc e8       	st.b	lr[0x6],r8

80002198 <SingleDetection_brdcst_func>:
	
}


void SingleDetection_brdcst_func(xcmp_fragment_t * xcmp)
{
80002198:	eb cd 40 80 	pushm	r7,lr
8000219c:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == 0x11)
8000219e:	19 a9       	ld.ub	r9,r12[0x2]
800021a0:	31 18       	mov	r8,17
800021a2:	f0 09 18 00 	cp.b	r9,r8
800021a6:	c0 91       	brne	800021b8 <SingleDetection_brdcst_func+0x20>
	{
		log("\n\r DMR_CSBK OK \n\r");
800021a8:	48 ac       	lddpc	r12,800021d0 <SingleDetection_brdcst_func+0x38>
800021aa:	f0 1f 00 0b 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		get_time_okay = TRUE;
800021ae:	30 19       	mov	r9,1
800021b0:	48 a8       	lddpc	r8,800021d8 <SingleDetection_brdcst_func+0x40>
800021b2:	b0 89       	st.b	r8[0x0],r9
800021b4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	//if(xcmp->u8[1] == 0x11)
	else
	{
		log("SIGBRCST error\n");
800021b8:	48 9c       	lddpc	r12,800021dc <SingleDetection_brdcst_func+0x44>
800021ba:	f0 1f 00 07 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
		log("\Signal_type: %X \n\r", xcmp->u8[0] );
800021be:	0f a8       	ld.ub	r8,r7[0x2]
800021c0:	1a d8       	st.w	--sp,r8
800021c2:	48 8c       	lddpc	r12,800021e0 <SingleDetection_brdcst_func+0x48>
800021c4:	f0 1f 00 04 	mcall	800021d4 <SingleDetection_brdcst_func+0x3c>
800021c8:	2f fd       	sub	sp,-4
800021ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	bd 00       	ld.d	r0,lr
800021d4:	80 00       	ld.sh	r0,r0[0x0]
800021d6:	5d 68       	*unknown*
800021d8:	00 00       	add	r0,r0
800021da:	00 04       	add	r4,r0
800021dc:	80 00       	ld.sh	r0,r0[0x0]
800021de:	bd 14       	ld.d	r4,--lr
800021e0:	80 00       	ld.sh	r0,r0[0x0]
800021e2:	bd 24       	st.d	lr++,r4

800021e4 <ButtonConfig_brdcst_func>:
	
}


void ButtonConfig_brdcst_func(xcmp_fragment_t * xcmp)
{
800021e4:	d4 31       	pushm	r0-r7,lr
	U8 Num_Button =0;
	U8 i = 0 ;
	/*point to xcmp payload*/
	ButtonConfig_brdcst_t  *ptr = (ButtonConfig_brdcst_t* )xcmp->u8;
800021e6:	f8 c7 ff fe 	sub	r7,r12,-2
	
	Num_Button = ptr->NumOfButtons;
800021ea:	0f 95       	ld.ub	r5,r7[0x1]
	
	log("\n\r ButtonConfig_broadcast  \n\r"  );
800021ec:	4a bc       	lddpc	r12,80002298 <ButtonConfig_brdcst_func+0xb4>
800021ee:	f0 1f 00 2c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r Function: %X \n\r" , ptr->Function );
800021f2:	0f 88       	ld.ub	r8,r7[0x0]
800021f4:	1a d8       	st.w	--sp,r8
800021f6:	4a bc       	lddpc	r12,800022a0 <ButtonConfig_brdcst_func+0xbc>
800021f8:	f0 1f 00 29 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
800021fc:	1a d5       	st.w	--sp,r5
800021fe:	4a ac       	lddpc	r12,800022a4 <ButtonConfig_brdcst_func+0xc0>
80002200:	f0 1f 00 27 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
80002204:	0f a8       	ld.ub	r8,r7[0x2]
80002206:	1a d8       	st.w	--sp,r8
80002208:	4a 8c       	lddpc	r12,800022a8 <ButtonConfig_brdcst_func+0xc4>
8000220a:	f0 1f 00 25 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
	
	for (i; i<Num_Button; i++)
8000220e:	2f dd       	sub	sp,-12
80002210:	58 05       	cp.w	r5,0
80002212:	c4 10       	breq	80002294 <ButtonConfig_brdcst_func+0xb0>
80002214:	30 06       	mov	r6,0
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002216:	4a 64       	lddpc	r4,800022ac <ButtonConfig_brdcst_func+0xc8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002218:	4a 63       	lddpc	r3,800022b0 <ButtonConfig_brdcst_func+0xcc>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
8000221a:	4a 72       	lddpc	r2,800022b4 <ButtonConfig_brdcst_func+0xd0>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
8000221c:	4a 71       	lddpc	r1,800022b8 <ButtonConfig_brdcst_func+0xd4>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000221e:	4a 80       	lddpc	r0,800022bc <ButtonConfig_brdcst_func+0xd8>
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
	{
		log("\n\r ButtonInfo[%d].Bt_Identifier: %x \n\r" , i, 
80002220:	0f b9       	ld.ub	r9,r7[0x3]
80002222:	0f c8       	ld.ub	r8,r7[0x4]
80002224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002228:	1a d8       	st.w	--sp,r8
8000222a:	1a d6       	st.w	--sp,r6
8000222c:	08 9c       	mov	r12,r4
8000222e:	f0 1f 00 1c 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].ButtonIdentifier[0]<<8) | (ptr->ButtonInfo[i].ButtonIdentifier[1]) );
				
		log("\n\r ButtonInfo[%d].S_PressFeature: %x \n\r" , i,
80002232:	0f d9       	ld.ub	r9,r7[0x5]
80002234:	0f e8       	ld.ub	r8,r7[0x6]
80002236:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000223a:	1a d8       	st.w	--sp,r8
8000223c:	1a d6       	st.w	--sp,r6
8000223e:	06 9c       	mov	r12,r3
80002240:	f0 1f 00 17 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].ShortPressFeature[0]<<8 )| (ptr->ButtonInfo[i].ShortPressFeature[1]) );
				 
		log("\n\r ButtonInfo[%d].Reserved1: %x \n\r" , i, 
80002244:	0f f9       	ld.ub	r9,r7[0x7]
80002246:	ef 38 00 08 	ld.ub	r8,r7[8]
8000224a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000224e:	1a d8       	st.w	--sp,r8
80002250:	1a d6       	st.w	--sp,r6
80002252:	04 9c       	mov	r12,r2
80002254:	f0 1f 00 12 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				(ptr->ButtonInfo[i].Reserved1[0]<<8) |  (ptr->ButtonInfo[i].Reserved1[1]));
		
		log("\n\r ButtonInfo[%d].L_PressFeature: %x \n\r" , i,
80002258:	ef 39 00 09 	ld.ub	r9,r7[9]
8000225c:	ef 38 00 0a 	ld.ub	r8,r7[10]
80002260:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002264:	1a d8       	st.w	--sp,r8
80002266:	1a d6       	st.w	--sp,r6
80002268:	02 9c       	mov	r12,r1
8000226a:	f0 1f 00 0d 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
				 (ptr->ButtonInfo[i].LongPressFeature[0]<<8) | (ptr->ButtonInfo[i].LongPressFeature[1]));
				 
		
		log("\n\r ButtonInfo[%d].Reserved2: %x \n\r" , i, 
8000226e:	2f 8d       	sub	sp,-32
80002270:	ef 39 00 0b 	ld.ub	r9,r7[11]
80002274:	ef 38 00 0c 	ld.ub	r8,r7[12]
80002278:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000227c:	1a d8       	st.w	--sp,r8
8000227e:	1a d6       	st.w	--sp,r6
80002280:	00 9c       	mov	r12,r0
80002282:	f0 1f 00 07 	mcall	8000229c <ButtonConfig_brdcst_func+0xb8>
80002286:	2f f6       	sub	r6,-1
80002288:	2f 67       	sub	r7,-10
	
	log("\n\r NumOfButtons: %d \n\r" , Num_Button );
	
	log("\n\r ButtonInfoStructSize: %x \n\r" , ptr->ButtoInfoStructSize );
	
	for (i; i<Num_Button; i++)
8000228a:	2f ed       	sub	sp,-8
8000228c:	ec 05 18 00 	cp.b	r5,r6
80002290:	fe 9b ff c8 	brhi	80002220 <ButtonConfig_brdcst_func+0x3c>
80002294:	d8 32       	popm	r0-r7,pc
80002296:	00 00       	add	r0,r0
80002298:	80 00       	ld.sh	r0,r0[0x0]
8000229a:	bd 38       	mul	r8,lr
8000229c:	80 00       	ld.sh	r0,r0[0x0]
8000229e:	5d 68       	*unknown*
800022a0:	80 00       	ld.sh	r0,r0[0x0]
800022a2:	bd 58       	asr	r8,0x1d
800022a4:	80 00       	ld.sh	r0,r0[0x0]
800022a6:	bd 6c       	lsl	r12,0x1c
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	bd 84       	lsr	r4,0x1c
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	bd a4       	sbr	r4,0x1c
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	bd cc       	cbr	r12,0x1c
800022b4:	80 00       	ld.sh	r0,r0[0x0]
800022b6:	bd f4       	*unknown*
800022b8:	80 00       	ld.sh	r0,r0[0x0]
800022ba:	be 18       	st.h	pc[0x2],r8
800022bc:	80 00       	ld.sh	r0,r0[0x0]
800022be:	be 40       	st.h	pc[0x8],r0

800022c0 <ButtonConfig_reply_func>:
	}
	
}

void ButtonConfig_reply_func(xcmp_fragment_t * xcmp)
{
800022c0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	ButtonConfig_reply_t *ptr = (ButtonConfig_reply_t* )(xcmp->u8);
800022c4:	f8 c7 ff fe 	sub	r7,r12,-2
	if (ptr->Result == xcmp_Res_Success)
800022c8:	0f 89       	ld.ub	r9,r7[0x0]
800022ca:	30 08       	mov	r8,0
800022cc:	f0 09 18 00 	cp.b	r9,r8
800022d0:	c0 c1       	brne	800022e8 <ButtonConfig_reply_func+0x28>
	{
		log("\n\r Button_Config OK \n\r");
800022d2:	48 9c       	lddpc	r12,800022f4 <ButtonConfig_reply_func+0x34>
800022d4:	f0 1f 00 09 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
		
		log("\n\r Function: %X \n\r" , ptr->Function );
800022d8:	0f 98       	ld.ub	r8,r7[0x1]
800022da:	1a d8       	st.w	--sp,r8
800022dc:	48 8c       	lddpc	r12,800022fc <ButtonConfig_reply_func+0x3c>
800022de:	f0 1f 00 07 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022e2:	2f fd       	sub	sp,-4
800022e4:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	
	else
	{
		log("\n\r Button_Request error \n\r");
800022e8:	48 6c       	lddpc	r12,80002300 <ButtonConfig_reply_func+0x40>
800022ea:	f0 1f 00 04 	mcall	800022f8 <ButtonConfig_reply_func+0x38>
800022ee:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f2:	00 00       	add	r0,r0
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	be 64       	st.h	pc[0xc],r4
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	5d 68       	*unknown*
800022fc:	80 00       	ld.sh	r0,r0[0x0]
800022fe:	bd 58       	asr	r8,0x1d
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	be 7c       	st.h	pc[0xe],r12

80002304 <DataSession_reply_func>:
	
	
}

void DataSession_reply_func(xcmp_fragment_t * xcmp)
{
80002304:	eb cd 40 80 	pushm	r7,lr
80002308:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
8000230a:	19 a9       	ld.ub	r9,r12[0x2]
8000230c:	30 08       	mov	r8,0
8000230e:	f0 09 18 00 	cp.b	r9,r8
80002312:	c1 11       	brne	80002334 <DataSession_reply_func+0x30>
	{
		log("DATArep OK \n");
80002314:	49 3c       	lddpc	r12,80002360 <DataSession_reply_func+0x5c>
80002316:	f0 1f 00 14 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func: %X \n", xcmp->u8[1]);
8000231a:	0f b8       	ld.ub	r8,r7[0x3]
8000231c:	1a d8       	st.w	--sp,r8
8000231e:	49 3c       	lddpc	r12,80002368 <DataSession_reply_func+0x64>
80002320:	f0 1f 00 11 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID: %X \n", xcmp->u8[2]);
80002324:	0f c8       	ld.ub	r8,r7[0x4]
80002326:	1a d8       	st.w	--sp,r8
80002328:	49 1c       	lddpc	r12,8000236c <DataSession_reply_func+0x68>
8000232a:	f0 1f 00 0f 	mcall	80002364 <DataSession_reply_func+0x60>
8000232e:	2f ed       	sub	sp,-8
80002330:	e3 cd 80 80 	ldm	sp++,r7,pc
		
	}
	else
	{	
		log("DATArep error \n");
80002334:	48 fc       	lddpc	r12,80002370 <DataSession_reply_func+0x6c>
80002336:	f0 1f 00 0c 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Result:  %X \n", xcmp->u8[0]);
8000233a:	0f a8       	ld.ub	r8,r7[0x2]
8000233c:	1a d8       	st.w	--sp,r8
8000233e:	48 ec       	lddpc	r12,80002374 <DataSession_reply_func+0x70>
80002340:	f0 1f 00 09 	mcall	80002364 <DataSession_reply_func+0x60>
		log("Func:  %X \n", xcmp->u8[1]);
80002344:	0f b8       	ld.ub	r8,r7[0x3]
80002346:	1a d8       	st.w	--sp,r8
80002348:	48 cc       	lddpc	r12,80002378 <DataSession_reply_func+0x74>
8000234a:	f0 1f 00 07 	mcall	80002364 <DataSession_reply_func+0x60>
		log("ID:  %X \n", xcmp->u8[2]);
8000234e:	0f c8       	ld.ub	r8,r7[0x4]
80002350:	1a d8       	st.w	--sp,r8
80002352:	48 bc       	lddpc	r12,8000237c <DataSession_reply_func+0x78>
80002354:	f0 1f 00 04 	mcall	80002364 <DataSession_reply_func+0x60>
80002358:	2f dd       	sub	sp,-12
8000235a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000235e:	00 00       	add	r0,r0
80002360:	80 00       	ld.sh	r0,r0[0x0]
80002362:	be 98       	st.b	pc[0x1],r8
80002364:	80 00       	ld.sh	r0,r0[0x0]
80002366:	5d 68       	*unknown*
80002368:	80 00       	ld.sh	r0,r0[0x0]
8000236a:	be a8       	st.b	pc[0x2],r8
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	be b4       	st.b	pc[0x3],r4
80002370:	80 00       	ld.sh	r0,r0[0x0]
80002372:	be c0       	st.b	pc[0x4],r0
80002374:	80 00       	ld.sh	r0,r0[0x0]
80002376:	be d0       	st.b	pc[0x5],r0
80002378:	80 00       	ld.sh	r0,r0[0x0]
8000237a:	be e0       	st.b	pc[0x6],r0
8000237c:	80 00       	ld.sh	r0,r0[0x0]
8000237e:	be ec       	st.b	pc[0x6],r12

80002380 <CallControl_brdcst_func>:
	
}


void CallControl_brdcst_func(xcmp_fragment_t * xcmp)
{
80002380:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	CallControl_brdcst_t *ptr = (CallControl_brdcst_t* )xcmp->u8;
80002384:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  CallControl brst \n\r ");
	//log("\n\r  Call_type: %x \n\r ", ptr->Calltype );
	log("\n\r  Call_state: %x \n\r ", ptr->Callstate );
80002388:	0f 98       	ld.ub	r8,r7[0x1]
8000238a:	1a d8       	st.w	--sp,r8
8000238c:	48 bc       	lddpc	r12,800023b8 <CallControl_brdcst_func+0x38>
8000238e:	f0 1f 00 0c 	mcall	800023bc <CallControl_brdcst_func+0x3c>
	if (ptr->Callstate == Call_Ended)//0x03
80002392:	2f fd       	sub	sp,-4
80002394:	0f 99       	ld.ub	r9,r7[0x1]
80002396:	30 38       	mov	r8,3
80002398:	f0 09 18 00 	cp.b	r9,r8
8000239c:	c0 41       	brne	800023a4 <CallControl_brdcst_func+0x24>
	{
		//恢复正常语音路径通道
		//xcmp_audio_route_revert();
		Call_Begin = 0;
8000239e:	30 09       	mov	r9,0
800023a0:	48 88       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023a2:	b0 89       	st.b	r8[0x0],r9
		
	}
	
	if (ptr->Callstate == Call_Initiated)//0x04
800023a4:	0f 99       	ld.ub	r9,r7[0x1]
800023a6:	30 48       	mov	r8,4
800023a8:	f0 09 18 00 	cp.b	r9,r8
800023ac:	c0 41       	brne	800023b4 <CallControl_brdcst_func+0x34>
	{
		Call_Begin = 1;
800023ae:	30 19       	mov	r9,1
800023b0:	48 48       	lddpc	r8,800023c0 <CallControl_brdcst_func+0x40>
800023b2:	b0 89       	st.b	r8[0x0],r9
800023b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	be f8       	st.b	pc[0x7],r8
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	5d 68       	*unknown*
800023c0:	00 00       	add	r0,r0
800023c2:	0a 23       	rsub	r3,r5

800023c4 <TransmitControl_brdcst_func>:

}


void TransmitControl_brdcst_func(xcmp_fragment_t * xcmp)
{
800023c4:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	//Speaker_is_unmute = 1;
	
	TransmitControl_brdcast_t *ptr = (TransmitControl_brdcast_t* )xcmp->u8;
800023c8:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r  TransmitControl broadcast \n\r ");
	//log("\n\r  Mode_Of_Operation: %x \n\r ", ptr->Mode_Of_Operation );
	if (ptr->State == 0x00)
800023cc:	0f 99       	ld.ub	r9,r7[0x1]
800023ce:	30 08       	mov	r8,0
800023d0:	f0 09 18 00 	cp.b	r9,r8
800023d4:	c0 71       	brne	800023e2 <TransmitControl_brdcst_func+0x1e>
	{
		log("\n\r  Standby-Receive \n\r ");
800023d6:	48 ac       	lddpc	r12,800023fc <TransmitControl_brdcst_func+0x38>
800023d8:	f0 1f 00 0a 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 0;
800023dc:	30 09       	mov	r9,0
800023de:	48 a8       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023e0:	b0 89       	st.b	r8[0x0],r9
	}
	if (ptr->State == 0x01)
800023e2:	0f 99       	ld.ub	r9,r7[0x1]
800023e4:	30 18       	mov	r8,1
800023e6:	f0 09 18 00 	cp.b	r9,r8
800023ea:	c0 71       	brne	800023f8 <TransmitControl_brdcst_func+0x34>
	{
		log("\n\r  Transmit \n\r ");
800023ec:	48 7c       	lddpc	r12,80002408 <TransmitControl_brdcst_func+0x44>
800023ee:	f0 1f 00 05 	mcall	80002400 <TransmitControl_brdcst_func+0x3c>
		Radio_Transmit_State = 1;
800023f2:	30 19       	mov	r9,1
800023f4:	48 48       	lddpc	r8,80002404 <TransmitControl_brdcst_func+0x40>
800023f6:	b0 89       	st.b	r8[0x0],r9
800023f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	bf 10       	ld.d	r0,--pc
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	5d 68       	*unknown*
80002404:	00 00       	add	r0,r0
80002406:	0a 22       	rsub	r2,r5
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	bf 28       	st.d	pc++,r8

8000240c <TransmitControl_reply_func>:




void TransmitControl_reply_func(xcmp_fragment_t * xcmp)
{
8000240c:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	TransmitControl_reply_t *ptr = (TransmitControl_reply_t* )xcmp->u8;
80002410:	f8 c7 ff fe 	sub	r7,r12,-2
	
	if (ptr->Result == xcmp_Res_Success)
80002414:	0f 89       	ld.ub	r9,r7[0x0]
80002416:	30 08       	mov	r8,0
80002418:	f0 09 18 00 	cp.b	r9,r8
8000241c:	c1 61       	brne	80002448 <TransmitControl_reply_func+0x3c>
	{
		
		log("\n\r  TransmitControl OK \n\r ");
8000241e:	48 ec       	lddpc	r12,80002454 <TransmitControl_reply_func+0x48>
80002420:	f0 1f 00 0e 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Function: %x \n\r", ptr->Function);
80002424:	0f 98       	ld.ub	r8,r7[0x1]
80002426:	1a d8       	st.w	--sp,r8
80002428:	48 dc       	lddpc	r12,8000245c <TransmitControl_reply_func+0x50>
8000242a:	f0 1f 00 0c 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r Mode of Operation: %x \n\r", ptr->Mode_Of_Operation);
8000242e:	0f a8       	ld.ub	r8,r7[0x2]
80002430:	1a d8       	st.w	--sp,r8
80002432:	48 cc       	lddpc	r12,80002460 <TransmitControl_reply_func+0x54>
80002434:	f0 1f 00 09 	mcall	80002458 <TransmitControl_reply_func+0x4c>
		log("\n\r State: %x \n\r", ptr->State);
80002438:	0f b8       	ld.ub	r8,r7[0x3]
8000243a:	1a d8       	st.w	--sp,r8
8000243c:	48 ac       	lddpc	r12,80002464 <TransmitControl_reply_func+0x58>
8000243e:	f0 1f 00 07 	mcall	80002458 <TransmitControl_reply_func+0x4c>
80002442:	2f dd       	sub	sp,-12
80002444:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		//Silent_flag = 1;
	}
	else
	{
		log("TransmitControl error");
80002448:	48 8c       	lddpc	r12,80002468 <TransmitControl_reply_func+0x5c>
8000244a:	f0 1f 00 04 	mcall	80002458 <TransmitControl_reply_func+0x4c>
8000244e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002452:	00 00       	add	r0,r0
80002454:	80 00       	ld.sh	r0,r0[0x0]
80002456:	bf 3c       	mul	r12,pc
80002458:	80 00       	ld.sh	r0,r0[0x0]
8000245a:	5d 68       	*unknown*
8000245c:	80 00       	ld.sh	r0,r0[0x0]
8000245e:	bf 58       	asr	r8,0x1f
80002460:	80 00       	ld.sh	r0,r0[0x0]
80002462:	bf 6c       	lsl	r12,0x1e
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	bf 88       	lsr	r8,0x1e
80002468:	80 00       	ld.sh	r0,r0[0x0]
8000246a:	bf 98       	lsr	r8,0x1f

8000246c <AudioRoutingControl_reply_func>:
	
}


void AudioRoutingControl_reply_func(xcmp_fragment_t * xcmp)
{
8000246c:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
8000246e:	19 a9       	ld.ub	r9,r12[0x2]
80002470:	30 08       	mov	r8,0
80002472:	f0 09 18 00 	cp.b	r9,r8
80002476:	c0 51       	brne	80002480 <AudioRoutingControl_reply_func+0x14>
	{
		log("AudioRouting OK");
80002478:	48 4c       	lddpc	r12,80002488 <AudioRoutingControl_reply_func+0x1c>
8000247a:	f0 1f 00 05 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
8000247e:	d8 02       	popm	pc
		//xcmp_IdleTestTone();
		//Speaker_is_unmute = 1;
	}
	else
	{
		log("AudioRouting error");
80002480:	48 4c       	lddpc	r12,80002490 <AudioRoutingControl_reply_func+0x24>
80002482:	f0 1f 00 03 	mcall	8000248c <AudioRoutingControl_reply_func+0x20>
80002486:	d8 02       	popm	pc
80002488:	80 00       	ld.sh	r0,r0[0x0]
8000248a:	bf b0       	sbr	r0,0x1f
8000248c:	80 00       	ld.sh	r0,r0[0x0]
8000248e:	5d 68       	*unknown*
80002490:	80 00       	ld.sh	r0,r0[0x0]
80002492:	bf c0       	cbr	r0,0x1e

80002494 <Volume_reply_func>:
	
}


void Volume_reply_func(xcmp_fragment_t * xcmp)
{
80002494:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	VolumeControl_reply_t *ptr = (VolumeControl_reply_t* )xcmp->u8;
80002498:	f8 c7 ff fe 	sub	r7,r12,-2
	
		if (ptr->Result == xcmp_Res_Success)
8000249c:	0f 89       	ld.ub	r9,r7[0x0]
8000249e:	30 08       	mov	r8,0
800024a0:	f0 09 18 00 	cp.b	r9,r8
800024a4:	c1 b1       	brne	800024da <Volume_reply_func+0x46>
		{
			if (ptr->Function == Enable_IntelligentAudio)
800024a6:	0f b8       	ld.ub	r8,r7[0x3]
800024a8:	31 09       	mov	r9,16
800024aa:	f2 08 18 00 	cp.b	r8,r9
800024ae:	c0 f1       	brne	800024cc <Volume_reply_func+0x38>
			{
				log("\n\r Enable_IA OK \n\r");
800024b0:	48 dc       	lddpc	r12,800024e4 <Volume_reply_func+0x50>
800024b2:	f0 1f 00 0e 	mcall	800024e8 <Volume_reply_func+0x54>
				log("\n\r Attenuator_Number: %x \n\r",  ((ptr->Attenuator_Number[0]<<8) | (ptr->Attenuator_Number[1])) );
800024b6:	0f 99       	ld.ub	r9,r7[0x1]
800024b8:	0f a8       	ld.ub	r8,r7[0x2]
800024ba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800024be:	1a d8       	st.w	--sp,r8
800024c0:	48 bc       	lddpc	r12,800024ec <Volume_reply_func+0x58>
800024c2:	f0 1f 00 0a 	mcall	800024e8 <Volume_reply_func+0x54>
800024c6:	2f fd       	sub	sp,-4
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
	
			}
			else
			{
				
				log("\n\r VolumeControl: %x \n\r", ptr->Function);
800024cc:	1a d8       	st.w	--sp,r8
800024ce:	48 9c       	lddpc	r12,800024f0 <Volume_reply_func+0x5c>
800024d0:	f0 1f 00 06 	mcall	800024e8 <Volume_reply_func+0x54>
800024d4:	2f fd       	sub	sp,-4
800024d6:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		
		else
		{
			log("\n\r Enable_IA error \n\r");
800024da:	48 7c       	lddpc	r12,800024f4 <Volume_reply_func+0x60>
800024dc:	f0 1f 00 03 	mcall	800024e8 <Volume_reply_func+0x54>
800024e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	bf d4       	cbr	r4,0x1f
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	5d 68       	*unknown*
800024ec:	80 00       	ld.sh	r0,r0[0x0]
800024ee:	bf e8       	*unknown*
800024f0:	80 00       	ld.sh	r0,r0[0x0]
800024f2:	c0 04       	brge	800024f2 <Volume_reply_func+0x5e>
800024f4:	80 00       	ld.sh	r0,r0[0x0]
800024f6:	c0 1c       	rcall	800024f8 <spk_brdcst_func>

800024f8 <spk_brdcst_func>:
		log("spk error");
	}
}

void spk_brdcst_func(xcmp_fragment_t * xcmp)
{
800024f8:	d4 01       	pushm	lr
	if (xcmp->u8[3] == xcmp_Res_Success)//0x0000:mute
800024fa:	19 d9       	ld.ub	r9,r12[0x5]
800024fc:	30 08       	mov	r8,0
800024fe:	f0 09 18 00 	cp.b	r9,r8
80002502:	c0 81       	brne	80002512 <spk_brdcst_func+0x1a>
	{
		Speaker_is_unmute =0;
80002504:	10 99       	mov	r9,r8
80002506:	48 78       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002508:	b0 89       	st.b	r8[0x0],r9
		//Silent_flag = 0;
		log("spk_s_close ");
8000250a:	48 7c       	lddpc	r12,80002524 <spk_brdcst_func+0x2c>
8000250c:	f0 1f 00 07 	mcall	80002528 <spk_brdcst_func+0x30>
80002510:	d8 02       	popm	pc
		
	}
	else
	{
		//Silent_flag = 1;
		Speaker_is_unmute = 1;
80002512:	30 19       	mov	r9,1
80002514:	48 38       	lddpc	r8,80002520 <spk_brdcst_func+0x28>
80002516:	b0 89       	st.b	r8[0x0],r9
		log("spk_s_open ");	
80002518:	48 5c       	lddpc	r12,8000252c <spk_brdcst_func+0x34>
8000251a:	f0 1f 00 04 	mcall	80002528 <spk_brdcst_func+0x30>
8000251e:	d8 02       	popm	pc
80002520:	00 00       	add	r0,r0
80002522:	0a 20       	rsub	r0,r5
80002524:	80 00       	ld.sh	r0,r0[0x0]
80002526:	c0 34       	brge	8000252c <spk_brdcst_func+0x34>
80002528:	80 00       	ld.sh	r0,r0[0x0]
8000252a:	5d 68       	*unknown*
8000252c:	80 00       	ld.sh	r0,r0[0x0]
8000252e:	c0 44       	brge	80002536 <spk_reply_func+0x6>

80002530 <spk_reply_func>:
			
	
}

void spk_reply_func(xcmp_fragment_t * xcmp)
{
80002530:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002532:	19 a9       	ld.ub	r9,r12[0x2]
80002534:	30 08       	mov	r8,0
80002536:	f0 09 18 00 	cp.b	r9,r8
8000253a:	c0 f1       	brne	80002558 <spk_reply_func+0x28>
	{
		
		if(xcmp->u8[4])
8000253c:	19 e9       	ld.ub	r9,r12[0x6]
8000253e:	f0 09 18 00 	cp.b	r9,r8
80002542:	c0 40       	breq	8000254a <spk_reply_func+0x1a>
		{
			Speaker_is_unmute = 1;
80002544:	30 19       	mov	r9,1
80002546:	48 98       	lddpc	r8,80002568 <spk_reply_func+0x38>
80002548:	b0 89       	st.b	r8[0x0],r9
			
			//Silent_flag = 1;
		}
		log("spk OK -st%2x", xcmp->u8[4] );
8000254a:	19 e8       	ld.ub	r8,r12[0x6]
8000254c:	1a d8       	st.w	--sp,r8
8000254e:	48 8c       	lddpc	r12,8000256c <spk_reply_func+0x3c>
80002550:	f0 1f 00 08 	mcall	80002570 <spk_reply_func+0x40>
80002554:	2f fd       	sub	sp,-4
80002556:	d8 02       	popm	pc
		
	}
	else
	{
		Speaker_is_unmute = 0;
80002558:	30 09       	mov	r9,0
8000255a:	48 48       	lddpc	r8,80002568 <spk_reply_func+0x38>
8000255c:	b0 89       	st.b	r8[0x0],r9
		log("spk error");
8000255e:	48 6c       	lddpc	r12,80002574 <spk_reply_func+0x44>
80002560:	f0 1f 00 04 	mcall	80002570 <spk_reply_func+0x40>
80002564:	d8 02       	popm	pc
80002566:	00 00       	add	r0,r0
80002568:	00 00       	add	r0,r0
8000256a:	0a 20       	rsub	r0,r5
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	c0 50       	breq	80002578 <mic_brdcst_func>
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	5d 68       	*unknown*
80002574:	80 00       	ld.sh	r0,r0[0x0]
80002576:	c0 60       	breq	80002582 <mic_brdcst_func+0xa>

80002578 <mic_brdcst_func>:
	
	
}

void mic_brdcst_func(xcmp_fragment_t * xcmp)
{
80002578:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_brdcast_t *ptr = (MicControl_brdcast_t* )xcmp->u8;
8000257c:	f8 c7 ff fe 	sub	r7,r12,-2
	//log("\n\r Mic_brdcst \n\r");		
	//log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
	//log("\n\r Signal_type: %x \n\r " ,  ptr->Signaling_Type);
	if (ptr->Mic_State == 0x00)
80002580:	0f a9       	ld.ub	r9,r7[0x2]
80002582:	30 08       	mov	r8,0
80002584:	f0 09 18 00 	cp.b	r9,r8
80002588:	c0 71       	brne	80002596 <mic_brdcst_func+0x1e>
	{
		log("\n\r Mic_Disabled \n\r");	
8000258a:	48 dc       	lddpc	r12,800025bc <mic_brdcst_func+0x44>
8000258c:	f0 1f 00 0d 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 0;
80002590:	30 09       	mov	r9,0
80002592:	48 d8       	lddpc	r8,800025c4 <mic_brdcst_func+0x4c>
80002594:	b0 89       	st.b	r8[0x0],r9
	} 
	if(ptr->Mic_State == 0x11)
80002596:	0f a9       	ld.ub	r9,r7[0x2]
80002598:	31 18       	mov	r8,17
8000259a:	f0 09 18 00 	cp.b	r9,r8
8000259e:	c0 d1       	brne	800025b8 <mic_brdcst_func+0x40>
	{
		log("\n\r Mic_Enabled \n\r");
800025a0:	48 ac       	lddpc	r12,800025c8 <mic_brdcst_func+0x50>
800025a2:	f0 1f 00 08 	mcall	800025c0 <mic_brdcst_func+0x48>
		Mic_is_Enabled = 1;
800025a6:	48 89       	lddpc	r9,800025c4 <mic_brdcst_func+0x4c>
800025a8:	30 18       	mov	r8,1
800025aa:	b2 88       	st.b	r9[0x0],r8
		
		if ((Mic_is_Enabled == 1) && (Call_Begin == 1))
800025ac:	13 89       	ld.ub	r9,r9[0x0]
800025ae:	f0 09 18 00 	cp.b	r9,r8
800025b2:	c0 31       	brne	800025b8 <mic_brdcst_func+0x40>
800025b4:	48 68       	lddpc	r8,800025cc <mic_brdcst_func+0x54>
800025b6:	11 88       	ld.ub	r8,r8[0x0]
800025b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	c0 6c       	rcall	800025ca <mic_brdcst_func+0x52>
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	5d 68       	*unknown*
800025c4:	00 00       	add	r0,r0
800025c6:	0a 30       	cp.w	r0,r5
800025c8:	80 00       	ld.sh	r0,r0[0x0]
800025ca:	c0 80       	breq	800025da <mic_reply_func+0xa>
800025cc:	00 00       	add	r0,r0
800025ce:	0a 23       	rsub	r3,r5

800025d0 <mic_reply_func>:
	
	
}

void mic_reply_func(xcmp_fragment_t * xcmp)
{
800025d0:	eb cd 40 80 	pushm	r7,lr
	/*point to xcmp payload*/
	MicControl_reply_t *ptr = (MicControl_reply_t* )xcmp->u8;
800025d4:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Mic_reply \n\r");
800025d8:	49 ac       	lddpc	r12,80002640 <mic_reply_func+0x70>
800025da:	f0 1f 00 1b 	mcall	80002644 <mic_reply_func+0x74>
	if (ptr->Result == 0x00)
800025de:	0f 89       	ld.ub	r9,r7[0x0]
800025e0:	30 08       	mov	r8,0
800025e2:	f0 09 18 00 	cp.b	r9,r8
800025e6:	c2 71       	brne	80002634 <mic_reply_func+0x64>
	{
		
		if (ptr->Function == Mic_Disable)
800025e8:	0f 98       	ld.ub	r8,r7[0x1]
800025ea:	30 29       	mov	r9,2
800025ec:	f2 08 18 00 	cp.b	r8,r9
800025f0:	c1 b1       	brne	80002626 <mic_reply_func+0x56>
		{
		
			log("\n\r Mic_close_ok \n\r " );
800025f2:	49 6c       	lddpc	r12,80002648 <mic_reply_func+0x78>
800025f4:	f0 1f 00 14 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_type: %x \n\r " ,  ptr->Mic_Type);
800025f8:	0f a8       	ld.ub	r8,r7[0x2]
800025fa:	1a d8       	st.w	--sp,r8
800025fc:	49 4c       	lddpc	r12,8000264c <mic_reply_func+0x7c>
800025fe:	f0 1f 00 12 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Signaling_type: %x \n\r " ,  ptr->Signaling_Type);
80002602:	0f b8       	ld.ub	r8,r7[0x3]
80002604:	1a d8       	st.w	--sp,r8
80002606:	49 3c       	lddpc	r12,80002650 <mic_reply_func+0x80>
80002608:	f0 1f 00 0f 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Mic_state: %x \n\r " ,  ptr->Mic_State);
8000260c:	0f c8       	ld.ub	r8,r7[0x4]
8000260e:	1a d8       	st.w	--sp,r8
80002610:	49 1c       	lddpc	r12,80002654 <mic_reply_func+0x84>
80002612:	f0 1f 00 0d 	mcall	80002644 <mic_reply_func+0x74>
			log("\n\r Gain_offset: %x \n\r " ,  ptr->Gain_Offset);
80002616:	0f d8       	ld.ub	r8,r7[0x5]
80002618:	1a d8       	st.w	--sp,r8
8000261a:	49 0c       	lddpc	r12,80002658 <mic_reply_func+0x88>
8000261c:	f0 1f 00 0a 	mcall	80002644 <mic_reply_func+0x74>
80002620:	2f cd       	sub	sp,-16
80002622:	e3 cd 80 80 	ldm	sp++,r7,pc
			
		}
		else
		{
			log("\n\r Mic_function: %x \n\r ", ptr->Function );
80002626:	1a d8       	st.w	--sp,r8
80002628:	48 dc       	lddpc	r12,8000265c <mic_reply_func+0x8c>
8000262a:	f0 1f 00 07 	mcall	80002644 <mic_reply_func+0x74>
8000262e:	2f fd       	sub	sp,-4
80002630:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else 
	{
		
	
		log("\n\r Mic error \n\r");
80002634:	48 bc       	lddpc	r12,80002660 <mic_reply_func+0x90>
80002636:	f0 1f 00 04 	mcall	80002644 <mic_reply_func+0x74>
8000263a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000263e:	00 00       	add	r0,r0
80002640:	80 00       	ld.sh	r0,r0[0x0]
80002642:	c0 94       	brge	80002654 <mic_reply_func+0x84>
80002644:	80 00       	ld.sh	r0,r0[0x0]
80002646:	5d 68       	*unknown*
80002648:	80 00       	ld.sh	r0,r0[0x0]
8000264a:	c0 a4       	brge	8000265e <mic_reply_func+0x8e>
8000264c:	80 00       	ld.sh	r0,r0[0x0]
8000264e:	c0 b8       	rjmp	80002664 <dcm_brdcst_func>
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	c0 cc       	rcall	8000266a <dcm_brdcst_func+0x6>
80002654:	80 00       	ld.sh	r0,r0[0x0]
80002656:	c0 e8       	rjmp	80002672 <dcm_brdcst_func+0xe>
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	c1 00       	breq	8000267a <dcm_brdcst_func+0x16>
8000265c:	80 00       	ld.sh	r0,r0[0x0]
8000265e:	c1 18       	rjmp	80002680 <dcm_brdcst_func+0x1c>
80002660:	80 00       	ld.sh	r0,r0[0x0]
80002662:	c1 30       	breq	80002688 <dcm_brdcst_func+0x24>

80002664 <dcm_brdcst_func>:
	}
}


void dcm_brdcst_func(xcmp_fragment_t * xcmp)
{
80002664:	eb cd 40 80 	pushm	r7,lr
	
	/*point to xcmp payload*/
	DeviceControlMode_brdcst_t *ptr = (DeviceControlMode_brdcst_t* )xcmp->u8;
80002668:	f8 c7 ff fe 	sub	r7,r12,-2
	
	log("\n\r Dcm_brdcst \n\r");		
8000266c:	48 bc       	lddpc	r12,80002698 <dcm_brdcst_func+0x34>
8000266e:	f0 1f 00 0c 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r Function: %x \n\r " ,  ptr->Function);
80002672:	0f 88       	ld.ub	r8,r7[0x0]
80002674:	1a d8       	st.w	--sp,r8
80002676:	48 bc       	lddpc	r12,800026a0 <dcm_brdcst_func+0x3c>
80002678:	f0 1f 00 09 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlType: %x \n\r " ,  ptr->ControlType);
8000267c:	0f a8       	ld.ub	r8,r7[0x2]
8000267e:	1a d8       	st.w	--sp,r8
80002680:	48 9c       	lddpc	r12,800026a4 <dcm_brdcst_func+0x40>
80002682:	f0 1f 00 07 	mcall	8000269c <dcm_brdcst_func+0x38>
	log("\n\r ControlTypeSize: %x \n\r " ,  ptr->ControlTypeSize);
80002686:	0f 98       	ld.ub	r8,r7[0x1]
80002688:	1a d8       	st.w	--sp,r8
8000268a:	48 8c       	lddpc	r12,800026a8 <dcm_brdcst_func+0x44>
8000268c:	f0 1f 00 04 	mcall	8000269c <dcm_brdcst_func+0x38>
80002690:	2f dd       	sub	sp,-12
	
	
}
80002692:	e3 cd 80 80 	ldm	sp++,r7,pc
80002696:	00 00       	add	r0,r0
80002698:	80 00       	ld.sh	r0,r0[0x0]
8000269a:	c1 40       	breq	800026c2 <dcm_reply_func+0x16>
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	5d 68       	*unknown*
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	c1 54       	brge	800026cc <dcm_reply_func+0x20>
800026a4:	80 00       	ld.sh	r0,r0[0x0]
800026a6:	c1 68       	rjmp	800026d2 <dcm_reply_func+0x26>
800026a8:	80 00       	ld.sh	r0,r0[0x0]
800026aa:	c1 80       	breq	800026da <dcm_reply_func+0x2e>

800026ac <dcm_reply_func>:
		log("Tone error");
	}
}

void dcm_reply_func(xcmp_fragment_t * xcmp)
{
800026ac:	eb cd 40 80 	pushm	r7,lr
800026b0:	18 97       	mov	r7,r12
	if (xcmp->u8[0] == xcmp_Res_Success)
800026b2:	19 a9       	ld.ub	r9,r12[0x2]
800026b4:	30 08       	mov	r8,0
800026b6:	f0 09 18 00 	cp.b	r9,r8
800026ba:	c1 b1       	brne	800026f0 <dcm_reply_func+0x44>
	{
		if(xcmp->u8[1] == DCM_ENTER)
800026bc:	19 b8       	ld.ub	r8,r12[0x3]
800026be:	30 19       	mov	r9,1
800026c0:	f2 08 18 00 	cp.b	r8,r9
800026c4:	c0 51       	brne	800026ce <dcm_reply_func+0x22>
		{
			log("\n\r Dcm-Enter OK \n\r");
800026c6:	48 ec       	lddpc	r12,800026fc <dcm_reply_func+0x50>
800026c8:	f0 1f 00 0e 	mcall	80002700 <dcm_reply_func+0x54>
800026cc:	c0 a8       	rjmp	800026e0 <dcm_reply_func+0x34>
			
		}
		else if (xcmp->u8[1] == DCM_EXIT)
800026ce:	58 08       	cp.w	r8,0
800026d0:	c0 51       	brne	800026da <dcm_reply_func+0x2e>
		{
			log("\n\r Dcm-Exit OK \n\r");
800026d2:	48 dc       	lddpc	r12,80002704 <dcm_reply_func+0x58>
800026d4:	f0 1f 00 0b 	mcall	80002700 <dcm_reply_func+0x54>
800026d8:	c0 48       	rjmp	800026e0 <dcm_reply_func+0x34>
		}
		else
		{
			log("\n\r Dcm-Revoke \n\r");
800026da:	48 cc       	lddpc	r12,80002708 <dcm_reply_func+0x5c>
800026dc:	f0 1f 00 09 	mcall	80002700 <dcm_reply_func+0x54>
		}
		
		log("dcm OK-mo%X", xcmp->u8[3]);
800026e0:	0f d8       	ld.ub	r8,r7[0x5]
800026e2:	1a d8       	st.w	--sp,r8
800026e4:	48 ac       	lddpc	r12,8000270c <dcm_reply_func+0x60>
800026e6:	f0 1f 00 07 	mcall	80002700 <dcm_reply_func+0x54>
800026ea:	2f fd       	sub	sp,-4
800026ec:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		log("dcm error");
800026f0:	48 8c       	lddpc	r12,80002710 <dcm_reply_func+0x64>
800026f2:	f0 1f 00 04 	mcall	80002700 <dcm_reply_func+0x54>
800026f6:	e3 cd 80 80 	ldm	sp++,r7,pc
800026fa:	00 00       	add	r0,r0
800026fc:	80 00       	ld.sh	r0,r0[0x0]
800026fe:	c1 9c       	rcall	80002730 <ToneControl_reply_func+0x1c>
80002700:	80 00       	ld.sh	r0,r0[0x0]
80002702:	5d 68       	*unknown*
80002704:	80 00       	ld.sh	r0,r0[0x0]
80002706:	c1 b0       	breq	8000273c <app_cfg>
80002708:	80 00       	ld.sh	r0,r0[0x0]
8000270a:	c1 c4       	brge	80002742 <app_cfg+0x6>
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	c1 d8       	rjmp	80002748 <app_cfg+0xc>
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	c1 e4       	brge	8000274e <app_cfg+0x12>

80002714 <ToneControl_reply_func>:
			}
		}
}

void ToneControl_reply_func(xcmp_fragment_t * xcmp)
{
80002714:	d4 01       	pushm	lr
	if (xcmp->u8[0] == xcmp_Res_Success)
80002716:	19 a9       	ld.ub	r9,r12[0x2]
80002718:	30 08       	mov	r8,0
8000271a:	f0 09 18 00 	cp.b	r9,r8
8000271e:	c0 51       	brne	80002728 <ToneControl_reply_func+0x14>
	{		
		log("Tone OK\n");
80002720:	48 4c       	lddpc	r12,80002730 <ToneControl_reply_func+0x1c>
80002722:	f0 1f 00 05 	mcall	80002734 <ToneControl_reply_func+0x20>
80002726:	d8 02       	popm	pc
		//fl_write("/test.txt", FILE_END, (void *)"send tone ok\r\n", sizeof("send tone ok\r\n") - 1);
	}
	else
	{
		log("Tone error");
80002728:	48 4c       	lddpc	r12,80002738 <ToneControl_reply_func+0x24>
8000272a:	f0 1f 00 03 	mcall	80002734 <ToneControl_reply_func+0x20>
8000272e:	d8 02       	popm	pc
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	c1 f0       	breq	80002770 <app_cfg+0x34>
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	5d 68       	*unknown*
80002738:	80 00       	ld.sh	r0,r0[0x0]
8000273a:	c1 fc       	rcall	80002778 <app_cfg+0x3c>

8000273c <app_cfg>:
extern volatile  xTaskHandle save_handle; 
//extern portTickType water_value;
//extern portTickType tx_water_value;
//extern portTickType log_water_value;
static __app_Thread_(app_cfg)
{
8000273c:	d4 31       	pushm	r0-r7,lr
8000273e:	20 1d       	sub	sp,4
	U8 Burst_ID = 0;
	char card_id[4]={0};
	U16  * data_ptr;
	//static const uint8_t test_data[8] = {0x11, 0x23, 0x33, 0x67, 0x89, 0xAB, 0xCD, 0xEF};
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
80002740:	f0 1f 00 39 	mcall	80002824 <app_cfg+0xe8>
80002744:	4b 98       	lddpc	r8,80002828 <app_cfg+0xec>
80002746:	91 0c       	st.w	r8[0x0],r12
		
	for(;;)
	{
		switch(OB_State)
80002748:	4b 97       	lddpc	r7,8000282c <app_cfg+0xf0>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
8000274a:	4b a5       	lddpc	r5,80002830 <app_cfg+0xf4>
							OB_State = OB_WAITINGAPPTASK;
							log("get time okay!\n");
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
8000274c:	30 92       	mov	r2,9
8000274e:	32 01       	mov	r1,32
80002750:	30 06       	mov	r6,0
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
							
							OB_State = OB_WAITINGAPPTASK;
80002752:	30 30       	mov	r0,3
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
80002754:	4b 84       	lddpc	r4,80002834 <app_cfg+0xf8>
	static	OB_States OB_State = OB_UNCONNECTEDWAITINGSTATUS;
	xLastWakeTime = xTaskGetTickCount();
		
	for(;;)
	{
		switch(OB_State)
80002756:	6e 08       	ld.w	r8,r7[0x0]
80002758:	58 28       	cp.w	r8,2
8000275a:	c3 40       	breq	800027c2 <app_cfg+0x86>
8000275c:	58 38       	cp.w	r8,3
8000275e:	c4 00       	breq	800027de <app_cfg+0xa2>
80002760:	58 08       	cp.w	r8,0
80002762:	c5 a1       	brne	80002816 <app_cfg+0xda>
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002764:	4b 58       	lddpc	r8,80002838 <app_cfg+0xfc>
80002766:	70 08       	ld.w	r8,r8[0x0]
80002768:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000276c:	58 38       	cp.w	r8,3
8000276e:	c1 21       	brne	80002792 <app_cfg+0x56>
80002770:	4b 38       	lddpc	r8,8000283c <app_cfg+0x100>
80002772:	11 88       	ld.ub	r8,r8[0x0]
80002774:	58 08       	cp.w	r8,0
80002776:	c0 e1       	brne	80002792 <app_cfg+0x56>
				{
					connect_flag=1;
80002778:	30 19       	mov	r9,1
8000277a:	4b 18       	lddpc	r8,8000283c <app_cfg+0x100>
8000277c:	b0 89       	st.b	r8[0x0],r9
					xcmp_IdleTestTone(Tone_Start, Priority_Beep);//set tone to indicate connection success!!!
8000277e:	30 cb       	mov	r11,12
80002780:	30 1c       	mov	r12,1
80002782:	f0 1f 00 30 	mcall	80002840 <app_cfg+0x104>
					OB_State = OB_CONNECTEDWAITTINGSYNTIME;
80002786:	30 28       	mov	r8,2
80002788:	8f 08       	st.w	r7[0x0],r8
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
8000278a:	4a fc       	lddpc	r12,80002844 <app_cfg+0x108>
8000278c:	f0 1f 00 2f 	mcall	80002848 <app_cfg+0x10c>
	{
		switch(OB_State)
		{
			case OB_UNCONNECTEDWAITINGSTATUS:
			
				if (0x00000003 == (bunchofrandomstatusflags & 0x00000003) && (!connect_flag))//确认连接成功了，再发送请求
80002790:	c4 38       	rjmp	80002816 <app_cfg+0xda>
					//vTaskResume(save_handle);
					log("connect OB okay!\n");
				}
				else
				{
					nop();
80002792:	d7 03       	nop
					nop();
80002794:	d7 03       	nop
					nop();
80002796:	d7 03       	nop
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
80002798:	4a dc       	lddpc	r12,8000284c <app_cfg+0x110>
8000279a:	f0 1f 00 2c 	mcall	80002848 <app_cfg+0x10c>
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
					Current_time.Hour, Current_time.Minute, Current_time.Second);
8000279e:	4a d8       	lddpc	r8,80002850 <app_cfg+0x114>
800027a0:	11 de       	ld.ub	lr,r8[0x5]
800027a2:	11 cc       	ld.ub	r12,r8[0x4]
800027a4:	11 bb       	ld.ub	r11,r8[0x3]
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					Current_time.Year, Current_time.Month, Current_time.Day,
800027a6:	11 aa       	ld.ub	r10,r8[0x2]
800027a8:	11 99       	ld.ub	r9,r8[0x1]
800027aa:	11 88       	ld.ub	r8,r8[0x0]
					nop();
					nop();
					nop();
					//xcmp_IdleTestTone(Tone_Start, Bad_Key_Chirp);//set tone to indicate connection failure!!!
					log("connecting...\n");
					log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
800027ac:	1a de       	st.w	--sp,lr
800027ae:	1a dc       	st.w	--sp,r12
800027b0:	1a db       	st.w	--sp,r11
800027b2:	1a da       	st.w	--sp,r10
800027b4:	1a d9       	st.w	--sp,r9
800027b6:	1a d8       	st.w	--sp,r8
800027b8:	4a 7c       	lddpc	r12,80002854 <app_cfg+0x118>
800027ba:	f0 1f 00 24 	mcall	80002848 <app_cfg+0x10c>
800027be:	2f ad       	sub	sp,-24
800027c0:	c2 b8       	rjmp	80002816 <app_cfg+0xda>
				}
								
			break;
			case OB_CONNECTEDWAITTINGSYNTIME:
			
						if(get_time_okay){
800027c2:	0b 88       	ld.ub	r8,r5[0x0]
800027c4:	58 08       	cp.w	r8,0
800027c6:	c0 60       	breq	800027d2 <app_cfg+0x96>
							
							OB_State = OB_WAITINGAPPTASK;
800027c8:	8f 00       	st.w	r7[0x0],r0
							log("get time okay!\n");
800027ca:	4a 4c       	lddpc	r12,80002858 <app_cfg+0x11c>
800027cc:	f0 1f 00 1f 	mcall	80002848 <app_cfg+0x10c>
800027d0:	c2 38       	rjmp	80002816 <app_cfg+0xda>
						}
						else
						{						
							xcmp_data_session_req(0x00, sizeof(Message_Protocol_t), DEST);//request to get system time						
800027d2:	04 9a       	mov	r10,r2
800027d4:	02 9b       	mov	r11,r1
800027d6:	0c 9c       	mov	r12,r6
800027d8:	f0 1f 00 21 	mcall	8000285c <app_cfg+0x120>
800027dc:	c1 d8       	rjmp	80002816 <app_cfg+0xda>
						}
			break;
			case OB_WAITINGAPPTASK:
			
					if(pdPASS == xQueueReceive(xg_resend_queue, &data_ptr, (2000*2) / portTICK_RATE_MS))
800027de:	68 0c       	ld.w	r12,r4[0x0]
800027e0:	0c 99       	mov	r9,r6
800027e2:	e0 6a 0f a0 	mov	r10,4000
800027e6:	1a 9b       	mov	r11,sp
800027e8:	f0 1f 00 1e 	mcall	80002860 <app_cfg+0x124>
800027ec:	58 1c       	cp.w	r12,1
800027ee:	c1 01       	brne	8000280e <app_cfg+0xd2>
					{
						if(data_ptr!=NULL){//Resend message
800027f0:	40 0c       	lddsp	r12,sp[0x0]
800027f2:	58 0c       	cp.w	r12,0
800027f4:	c0 d0       	breq	8000280e <app_cfg+0xd2>
							
							//Message_Protocol_t *ptr = (Message_Protocol_t* )data_ptr;
							//xgflash_message_save(data_ptr, sizeof(Message_Protocol_t), TRUE);
							//log("receive data : %d", ptr->data.XG_Time.Second);
							xcmp_data_session_req(data_ptr, sizeof(Message_Protocol_t), DEST);
800027f6:	04 9a       	mov	r10,r2
800027f8:	02 9b       	mov	r11,r1
800027fa:	f0 1f 00 19 	mcall	8000285c <app_cfg+0x120>
							
							//flashc_memset8((void*)0x80038000, 0x02, 5, TRUE);
							
							set_message_store(data_ptr);
800027fe:	49 a8       	lddpc	r8,80002864 <app_cfg+0x128>
80002800:	70 0c       	ld.w	r12,r8[0x0]
80002802:	40 0b       	lddsp	r11,sp[0x0]
80002804:	f0 1f 00 19 	mcall	80002868 <app_cfg+0x12c>
							log("receive okay!\n");
80002808:	49 9c       	lddpc	r12,8000286c <app_cfg+0x130>
8000280a:	f0 1f 00 10 	mcall	80002848 <app_cfg+0x10c>
					//}
					//else
					//{
					//log("no find card...\n");
					//}
					nop();
8000280e:	d7 03       	nop
					//log("Current time is :20%d:%2d:%2d, %2d:%2d:%2d\n",
					//Current_time.Year, Current_time.Month, Current_time.Day,
					//Current_time.Hour, Current_time.Minute, Current_time.Second);
					log("app task run!\n");
80002810:	49 8c       	lddpc	r12,80002870 <app_cfg+0x134>
80002812:	f0 1f 00 0e 	mcall	80002848 <app_cfg+0x10c>
			break;
				
		} //End of switch on OB_State.
		//vTaskDelay(300*2 / portTICK_RATE_MS);//延迟300ms
		//log("\n\r ulIdleCycleCount: %d \n\r", ulIdleCycleCount);
		vTaskDelayUntil( &xLastWakeTime, (2000*2) / portTICK_RATE_MS  );//精确的以1000ms为周期执行。
80002816:	e0 6b 0f a0 	mov	r11,4000
8000281a:	48 4c       	lddpc	r12,80002828 <app_cfg+0xec>
8000281c:	f0 1f 00 16 	mcall	80002874 <app_cfg+0x138>
	}
80002820:	c9 bb       	rjmp	80002756 <app_cfg+0x1a>
80002822:	00 00       	add	r0,r0
80002824:	80 00       	ld.sh	r0,r0[0x0]
80002826:	56 94       	stdsp	sp[0x1a4],r4
80002828:	00 00       	add	r0,r0
8000282a:	0a 2c       	rsub	r12,r5
8000282c:	00 00       	add	r0,r0
8000282e:	0a 24       	rsub	r4,r5
80002830:	00 00       	add	r0,r0
80002832:	00 04       	add	r4,r0
80002834:	00 00       	add	r0,r0
80002836:	0a 60       	and	r0,r5
80002838:	00 00       	add	r0,r0
8000283a:	0c e4       	st.h	--r6,r4
8000283c:	00 00       	add	r0,r0
8000283e:	0a 29       	rsub	r9,r5
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	33 24       	mov	r4,50
80002844:	80 00       	ld.sh	r0,r0[0x0]
80002846:	c2 08       	rjmp	80002886 <Phyuserinput_brdcst_func+0xe>
80002848:	80 00       	ld.sh	r0,r0[0x0]
8000284a:	5d 68       	*unknown*
8000284c:	80 00       	ld.sh	r0,r0[0x0]
8000284e:	c2 1c       	rcall	80002890 <Phyuserinput_brdcst_func+0x18>
80002850:	00 00       	add	r0,r0
80002852:	0c e8       	st.h	--r6,r8
80002854:	80 00       	ld.sh	r0,r0[0x0]
80002856:	c2 2c       	rcall	8000289a <Phyuserinput_brdcst_func+0x22>
80002858:	80 00       	ld.sh	r0,r0[0x0]
8000285a:	c2 58       	rjmp	800028a4 <Phyuserinput_brdcst_func+0x2c>
8000285c:	80 00       	ld.sh	r0,r0[0x0]
8000285e:	32 58       	mov	r8,37
80002860:	80 00       	ld.sh	r0,r0[0x0]
80002862:	4f 74       	lddpc	r4,80002a3c <send_flash_command+0x3c>
80002864:	00 00       	add	r0,r0
80002866:	0a 6c       	and	r12,r5
80002868:	80 00       	ld.sh	r0,r0[0x0]
8000286a:	31 bc       	mov	r12,27
8000286c:	80 00       	ld.sh	r0,r0[0x0]
8000286e:	c2 68       	rjmp	800028ba <Phyuserinput_brdcst_func+0x42>
80002870:	80 00       	ld.sh	r0,r0[0x0]
80002872:	c2 78       	rjmp	800028c0 <Phyuserinput_brdcst_func+0x48>
80002874:	80 00       	ld.sh	r0,r0[0x0]
80002876:	58 44       	cp.w	r4,4

80002878 <Phyuserinput_brdcst_func>:
	
}


void Phyuserinput_brdcst_func(xcmp_fragment_t * xcmp)
{
80002878:	eb cd 40 80 	pushm	r7,lr
	U8 PUI_State_Min_Value =0;
	U8 PUI_State_Max_Value =0;
	
	PUI_Source = xcmp->u8[0];
	PUI_Type = xcmp ->u8[1];
	PUI_ID = ((xcmp->u8[2]<<8) | xcmp->u8[3]);
8000287c:	19 c7       	ld.ub	r7,r12[0x4]
8000287e:	19 d8       	ld.ub	r8,r12[0x5]
80002880:	f1 e7 10 87 	or	r7,r8,r7<<0x8
80002884:	5c 87       	casts.h	r7
	PUI_State = xcmp->u8[4];
	PUI_State_Min_Value = xcmp->u8[5];
	PUI_State_Max_Value = xcmp->u8[6];
	
	log("PhysicalUserInput_broadcast  \n\r"  );
80002886:	48 dc       	lddpc	r12,800028b8 <Phyuserinput_brdcst_func+0x40>
80002888:	f0 1f 00 0d 	mcall	800028bc <Phyuserinput_brdcst_func+0x44>
	
	if((PUI_ID == 0x0060) && (PUI_State = 0x02) && (connect_flag == 1)){
8000288c:	36 08       	mov	r8,96
8000288e:	f0 07 19 00 	cp.h	r7,r8
80002892:	c1 11       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
80002894:	48 b8       	lddpc	r8,800028c0 <Phyuserinput_brdcst_func+0x48>
80002896:	11 89       	ld.ub	r9,r8[0x0]
80002898:	30 18       	mov	r8,1
8000289a:	f0 09 18 00 	cp.b	r9,r8
8000289e:	c0 b1       	brne	800028b4 <Phyuserinput_brdcst_func+0x3c>
		//log("send message\n");
		xcmp_IdleTestTone(Tone_Start, ACK_Received_Tone);//set tone to indicate the scan!!!
800028a0:	31 4b       	mov	r11,20
800028a2:	30 1c       	mov	r12,1
800028a4:	f0 1f 00 08 	mcall	800028c4 <Phyuserinput_brdcst_func+0x4c>
			
		vTaskDelay(400*2 / portTICK_RATE_MS);//延迟400ms
800028a8:	e0 6c 03 20 	mov	r12,800
800028ac:	f0 1f 00 07 	mcall	800028c8 <Phyuserinput_brdcst_func+0x50>
		//delay_ms(200);
		rfid_sendID_message();//send message		
800028b0:	f0 1f 00 07 	mcall	800028cc <Phyuserinput_brdcst_func+0x54>
800028b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800028b8:	80 00       	ld.sh	r0,r0[0x0]
800028ba:	c2 88       	rjmp	8000290a <DataSession_brdcst_func+0x3a>
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	5d 68       	*unknown*
800028c0:	00 00       	add	r0,r0
800028c2:	0a 29       	rsub	r9,r5
800028c4:	80 00       	ld.sh	r0,r0[0x0]
800028c6:	33 24       	mov	r4,50
800028c8:	80 00       	ld.sh	r0,r0[0x0]
800028ca:	57 fc       	stdsp	sp[0x1fc],r12
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	3c 30       	mov	r0,-61

800028d0 <DataSession_brdcst_func>:
	}
	
}

void DataSession_brdcst_func(xcmp_fragment_t * xcmp)
{
800028d0:	d4 21       	pushm	r4-r7,lr
800028d2:	20 9d       	sub	sp,36
	U32 card_id =0;
	U8 i = 0;
	xgflash_status_t return_value = XG_ERROR;
	
	/*point to xcmp payload*/
	DataSession_brdcst_t *ptr = (DataSession_brdcst_t* )xcmp->u8;
800028d4:	f8 c6 ff fe 	sub	r6,r12,-2
	
	if (ptr->State == CSBK_DATA_RX_Suc)
800028d8:	0d 88       	ld.ub	r8,r6[0x0]
800028da:	32 49       	mov	r9,36
800028dc:	f2 08 18 00 	cp.b	r8,r9
800028e0:	c2 91       	brne	80002932 <DataSession_brdcst_func+0x62>
	{
		
		log("\n\r CSBK_RX OK \n\r");
800028e2:	4a dc       	lddpc	r12,80002994 <DataSession_brdcst_func+0xc4>
800028e4:	f0 1f 00 2d 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
800028e8:	0d a5       	ld.ub	r5,r6[0x2]
800028ea:	0d b8       	ld.ub	r8,r6[0x3]
800028ec:	f1 e5 10 85 	or	r5,r8,r5<<0x8
800028f0:	5c 85       	casts.h	r5

		log("\n\r Session_ID: %x \n\r",Session_number );
800028f2:	0d 98       	ld.ub	r8,r6[0x1]
800028f4:	1a d8       	st.w	--sp,r8
800028f6:	4a ac       	lddpc	r12,8000299c <DataSession_brdcst_func+0xcc>
800028f8:	f0 1f 00 28 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		log("\n\r paylaod_length: %d \n\r",data_length );
800028fc:	f1 d5 c0 10 	bfextu	r8,r5,0x0,0x10
80002900:	1a d8       	st.w	--sp,r8
80002902:	4a 8c       	lddpc	r12,800029a0 <DataSession_brdcst_func+0xd0>
80002904:	f0 1f 00 25 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		for(i=0; i<data_length; i++)
80002908:	2f ed       	sub	sp,-8
8000290a:	58 05       	cp.w	r5,0
8000290c:	c4 10       	breq	8000298e <DataSession_brdcst_func+0xbe>
8000290e:	30 07       	mov	r7,0
		{
			
			//log("\n\r payload[%d]: %X \n\r", i, xcmp->u8[4+i]);
			log("\n\r payload[%d]: %X \n\r", i, ptr->DataPayload.DataPayload[i]);
80002910:	4a 54       	lddpc	r4,800029a4 <DataSession_brdcst_func+0xd4>
80002912:	ec 07 00 08 	add	r8,r6,r7
80002916:	11 c8       	ld.ub	r8,r8[0x4]
80002918:	1a d8       	st.w	--sp,r8
8000291a:	1a d7       	st.w	--sp,r7
8000291c:	08 9c       	mov	r12,r4
8000291e:	f0 1f 00 1f 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);

		log("\n\r Session_ID: %x \n\r",Session_number );
		log("\n\r paylaod_length: %d \n\r",data_length );
		for(i=0; i<data_length; i++)
80002922:	2f f7       	sub	r7,-1
80002924:	5c 57       	castu.b	r7
80002926:	2f ed       	sub	sp,-8
80002928:	ee 05 19 00 	cp.h	r5,r7
8000292c:	fe 9b ff f3 	brhi	80002912 <DataSession_brdcst_func+0x42>
80002930:	c2 f8       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
	else
	{
		//log("\n\r State: 0x %X \n\r", xcmp->u8[0]);
		Session_number = ptr->DataPayload.Session_ID_Number;//xcmp->u8[1];				
		data_length = (ptr->DataPayload.DataPayload_Length[0]<<8) | (ptr->DataPayload.DataPayload_Length[1]);//( xcmp->u8[2]<<8) | (xcmp->u8[3]);
		log("State: %X \n", ptr->State);
80002932:	1a d8       	st.w	--sp,r8
80002934:	49 dc       	lddpc	r12,800029a8 <DataSession_brdcst_func+0xd8>
80002936:	f0 1f 00 19 	mcall	80002998 <DataSession_brdcst_func+0xc8>
		if (ptr->State == DATA_SESSION_TX_Suc)
8000293a:	0d 88       	ld.ub	r8,r6[0x0]
8000293c:	2f fd       	sub	sp,-4
8000293e:	30 39       	mov	r9,3
80002940:	f2 08 18 00 	cp.b	r8,r9
80002944:	c0 51       	brne	8000294e <DataSession_brdcst_func+0x7e>
		{
			log("data transmit success\n");
80002946:	49 ac       	lddpc	r12,800029ac <DataSession_brdcst_func+0xdc>
80002948:	f0 1f 00 14 	mcall	80002998 <DataSession_brdcst_func+0xc8>
8000294c:	c2 18       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
		}
		else if(ptr->State == DATA_SESSION_TX_Fail)
8000294e:	30 49       	mov	r9,4
80002950:	f2 08 18 00 	cp.b	r8,r9
80002954:	c1 d1       	brne	8000298e <DataSession_brdcst_func+0xbe>
		{
			//Message_Protocol_t  *xgmessage = (Message_Protocol_t  *)ptr->DataPayload.DataPayload;
			Message_Protocol_t  xgmessage;
			memcpy(&xgmessage, ptr->DataPayload.DataPayload, sizeof(Message_Protocol_t));
80002956:	32 0a       	mov	r10,32
80002958:	ec cb ff fc 	sub	r11,r6,-4
8000295c:	1a 9c       	mov	r12,sp
8000295e:	f0 1f 00 15 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
			//xgmessage.data.XG_Time.Year, xgmessage.data.XG_Time.Month, xgmessage.data.XG_Time.Day,
			//xgmessage.data.XG_Time.Hour, xgmessage.data.XG_Time.Minute, xgmessage.data.XG_Time.Second);

			//return_value = xgflash_message_save(&xgmessage, sizeof(Message_Protocol_t), TRUE);

			Message_Protocol_t * myptr = get_message_store();	
80002962:	49 58       	lddpc	r8,800029b4 <DataSession_brdcst_func+0xe4>
80002964:	70 0c       	ld.w	r12,r8[0x0]
80002966:	f0 1f 00 15 	mcall	800029b8 <DataSession_brdcst_func+0xe8>
8000296a:	50 8c       	stdsp	sp[0x20],r12
			if(NULL != myptr)
8000296c:	c0 e0       	breq	80002988 <DataSession_brdcst_func+0xb8>
			{
				memcpy(myptr, &xgmessage, sizeof(Message_Protocol_t));			
8000296e:	32 0a       	mov	r10,32
80002970:	1a 9b       	mov	r11,sp
80002972:	f0 1f 00 10 	mcall	800029b0 <DataSession_brdcst_func+0xe0>
				xQueueSend(xg_resend_queue, &myptr, 0);
80002976:	49 28       	lddpc	r8,800029bc <DataSession_brdcst_func+0xec>
80002978:	70 0c       	ld.w	r12,r8[0x0]
8000297a:	30 09       	mov	r9,0
8000297c:	12 9a       	mov	r10,r9
8000297e:	fa cb ff e0 	sub	r11,sp,-32
80002982:	f0 1f 00 10 	mcall	800029c0 <DataSession_brdcst_func+0xf0>
80002986:	c0 48       	rjmp	8000298e <DataSession_brdcst_func+0xbe>
			}
			else
			{
				log("myptr: err\n\r" );
80002988:	48 fc       	lddpc	r12,800029c4 <DataSession_brdcst_func+0xf4>
8000298a:	f0 1f 00 04 	mcall	80002998 <DataSession_brdcst_func+0xc8>
				//
		//}
		
	}
	
}
8000298e:	2f 7d       	sub	sp,-36
80002990:	d8 22       	popm	r4-r7,pc
80002992:	00 00       	add	r0,r0
80002994:	80 00       	ld.sh	r0,r0[0x0]
80002996:	c2 a8       	rjmp	800029ea <DeviceInitializationStatus_brdcst_func+0x22>
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	5d 68       	*unknown*
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	c2 bc       	rcall	800029f4 <DeviceInitializationStatus_brdcst_func+0x2c>
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	c2 d4       	brge	800029fc <DeviceInitializationStatus_brdcst_func+0x34>
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	c2 f0       	breq	80002a04 <send_flash_command+0x4>
800029a8:	80 00       	ld.sh	r0,r0[0x0]
800029aa:	c3 08       	rjmp	80002a0a <send_flash_command+0xa>
800029ac:	80 00       	ld.sh	r0,r0[0x0]
800029ae:	c3 14       	brge	80002a10 <send_flash_command+0x10>
800029b0:	80 00       	ld.sh	r0,r0[0x0]
800029b2:	64 8a       	ld.w	r10,r2[0x20]
800029b4:	00 00       	add	r0,r0
800029b6:	0a 6c       	and	r12,r5
800029b8:	80 00       	ld.sh	r0,r0[0x0]
800029ba:	31 dc       	mov	r12,29
800029bc:	00 00       	add	r0,r0
800029be:	0a 60       	and	r0,r5
800029c0:	80 00       	ld.sh	r0,r0[0x0]
800029c2:	51 30       	stdsp	sp[0x4c],r0
800029c4:	80 00       	ld.sh	r0,r0[0x0]
800029c6:	c3 2c       	rcall	80002a2a <send_flash_command+0x2a>

800029c8 <DeviceInitializationStatus_brdcst_func>:
extern volatile xQueueHandle xg_resend_queue ;

//app func--list

void DeviceInitializationStatus_brdcst_func(xcmp_fragment_t  * xcmp)
{
800029c8:	d4 01       	pushm	lr
	if (xcmp->u8[4] == 0x01)
800029ca:	19 e8       	ld.ub	r8,r12[0x6]
800029cc:	30 19       	mov	r9,1
800029ce:	f2 08 18 00 	cp.b	r8,r9
800029d2:	c0 61       	brne	800029de <DeviceInitializationStatus_brdcst_func+0x16>
	{
		bunchofrandomstatusflags |= 0x01;  //Need do nothing else.
800029d4:	48 98       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029d6:	70 09       	ld.w	r9,r8[0x0]
800029d8:	a1 a9       	sbr	r9,0x0
800029da:	91 09       	st.w	r8[0x0],r9
800029dc:	d8 02       	popm	pc
	}
	else if(xcmp->u8[4] != 0x02)
800029de:	30 29       	mov	r9,2
800029e0:	f2 08 18 00 	cp.b	r8,r9
800029e4:	c0 80       	breq	800029f4 <DeviceInitializationStatus_brdcst_func+0x2c>
	{
		bunchofrandomstatusflags  &= 0xFFFFFFFC; //Device Init no longer Complete.
800029e6:	48 58       	lddpc	r8,800029f8 <DeviceInitializationStatus_brdcst_func+0x30>
800029e8:	70 09       	ld.w	r9,r8[0x0]
800029ea:	e0 19 ff fc 	andl	r9,0xfffc
800029ee:	91 09       	st.w	r8[0x0],r9
		xcmp_DeviceInitializationStatus_request();
800029f0:	f0 1f 00 03 	mcall	800029fc <DeviceInitializationStatus_brdcst_func+0x34>
800029f4:	d8 02       	popm	pc
800029f6:	00 00       	add	r0,r0
800029f8:	00 00       	add	r0,r0
800029fa:	0c e4       	st.h	--r6,r4
800029fc:	80 00       	ld.sh	r0,r0[0x0]
800029fe:	32 e4       	mov	r4,46

80002a00 <send_flash_command>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
U16 send_flash_command(U16 command, U32 address, U8 *data_ptr, U16 length)
{
80002a00:	eb cd 40 fc 	pushm	r2-r7,lr
80002a04:	20 1d       	sub	sp,4
80002a06:	18 97       	mov	r7,r12
80002a08:	14 95       	mov	r5,r10
80002a0a:	12 96       	mov	r6,r9
	U16 status = 1;
80002a0c:	30 18       	mov	r8,1
80002a0e:	ba 18       	st.h	sp[0x2],r8
	U16 i = 0;

    /* in order to call spi_write(U16* data), change 3-bytes address to 3-U16 address */
	U16 addr[3];
	addr[2] = (address & 0x00ff0000) >> 16;
80002a10:	e9 db c2 08 	bfextu	r4,r11,0x10,0x8
	addr[1] = (address & 0x0000ff00) >> 8;
80002a14:	e7 db c1 08 	bfextu	r3,r11,0x8,0x8
	addr[0] = (address & 0x000000ff);
80002a18:	e5 db c0 08 	bfextu	r2,r11,0x0,0x8

	U16 data_u16;

	spi_selectChip(spi, DF_SPI_PCS_1);
80002a1c:	30 1b       	mov	r11,1
80002a1e:	4e 58       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002a20:	70 0c       	ld.w	r12,r8[0x0]
80002a22:	f0 1f 00 65 	mcall	80002bb4 <send_flash_command+0x1b4>

    switch (command)
80002a26:	30 58       	mov	r8,5
80002a28:	f0 07 19 00 	cp.h	r7,r8
80002a2c:	c3 40       	breq	80002a94 <send_flash_command+0x94>
80002a2e:	e0 8b 00 18 	brhi	80002a5e <send_flash_command+0x5e>
80002a32:	30 28       	mov	r8,2
80002a34:	f0 07 19 00 	cp.h	r7,r8
80002a38:	c5 e0       	breq	80002af4 <send_flash_command+0xf4>
80002a3a:	e0 8b 00 08 	brhi	80002a4a <send_flash_command+0x4a>
80002a3e:	30 18       	mov	r8,1
80002a40:	f0 07 19 00 	cp.h	r7,r8
80002a44:	e0 81 00 ad 	brne	80002b9e <send_flash_command+0x19e>
80002a48:	c9 e8       	rjmp	80002b84 <send_flash_command+0x184>
80002a4a:	30 38       	mov	r8,3
80002a4c:	f0 07 19 00 	cp.h	r7,r8
80002a50:	c7 20       	breq	80002b34 <send_flash_command+0x134>
80002a52:	30 48       	mov	r8,4
80002a54:	f0 07 19 00 	cp.h	r7,r8
80002a58:	e0 81 00 a3 	brne	80002b9e <send_flash_command+0x19e>
80002a5c:	c2 c8       	rjmp	80002ab4 <send_flash_command+0xb4>
80002a5e:	35 28       	mov	r8,82
80002a60:	f0 07 19 00 	cp.h	r7,r8
80002a64:	c2 f0       	breq	80002ac2 <send_flash_command+0xc2>
80002a66:	e0 8b 00 0c 	brhi	80002a7e <send_flash_command+0x7e>
80002a6a:	30 68       	mov	r8,6
80002a6c:	f0 07 19 00 	cp.h	r7,r8
80002a70:	c2 20       	breq	80002ab4 <send_flash_command+0xb4>
80002a72:	32 08       	mov	r8,32
80002a74:	f0 07 19 00 	cp.h	r7,r8
80002a78:	e0 81 00 93 	brne	80002b9e <send_flash_command+0x19e>
80002a7c:	c2 38       	rjmp	80002ac2 <send_flash_command+0xc2>
80002a7e:	36 08       	mov	r8,96
80002a80:	f0 07 19 00 	cp.h	r7,r8
80002a84:	c3 20       	breq	80002ae8 <send_flash_command+0xe8>
80002a86:	e0 68 00 d8 	mov	r8,216
80002a8a:	f0 07 19 00 	cp.h	r7,r8
80002a8e:	e0 81 00 88 	brne	80002b9e <send_flash_command+0x19e>
80002a92:	c1 88       	rjmp	80002ac2 <send_flash_command+0xc2>
	{
		case READ_STATUS_REG:
			spi_write_byte(command);
80002a94:	4c 77       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002a96:	30 5b       	mov	r11,5
80002a98:	6e 0c       	ld.w	r12,r7[0x0]
80002a9a:	f0 1f 00 48 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_dummy();
80002a9e:	e0 6b 00 ff 	mov	r11,255
80002aa2:	6e 0c       	ld.w	r12,r7[0x0]
80002aa4:	f0 1f 00 45 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_read_byte(&status);
80002aa8:	fa cb ff fe 	sub	r11,sp,-2
80002aac:	6e 0c       	ld.w	r12,r7[0x0]
80002aae:	f0 1f 00 44 	mcall	80002bbc <send_flash_command+0x1bc>
			break;
80002ab2:	c7 68       	rjmp	80002b9e <send_flash_command+0x19e>
		case WRITE_ENABLE:
		case WRITE_DISABLE:
			spi_write_byte(command);
80002ab4:	0e 9b       	mov	r11,r7
80002ab6:	5c 7b       	castu.h	r11
80002ab8:	4b e8       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002aba:	70 0c       	ld.w	r12,r8[0x0]
80002abc:	f0 1f 00 3f 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002ac0:	c6 f8       	rjmp	80002b9e <send_flash_command+0x19e>
		case BLOCK_ERASE_4KB:
		case BLOCK_ERASE_32KB:
		case BLOCK_ERASE_64KB:
			spi_write_byte(command);
80002ac2:	4b c6       	lddpc	r6,80002bb0 <send_flash_command+0x1b0>
80002ac4:	0e 9b       	mov	r11,r7
80002ac6:	5c 7b       	castu.h	r11
80002ac8:	6c 0c       	ld.w	r12,r6[0x0]
80002aca:	f0 1f 00 3c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002ace:	08 9b       	mov	r11,r4
80002ad0:	6c 0c       	ld.w	r12,r6[0x0]
80002ad2:	f0 1f 00 3a 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002ad6:	06 9b       	mov	r11,r3
80002ad8:	6c 0c       	ld.w	r12,r6[0x0]
80002ada:	f0 1f 00 38 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002ade:	04 9b       	mov	r11,r2
80002ae0:	6c 0c       	ld.w	r12,r6[0x0]
80002ae2:	f0 1f 00 36 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002ae6:	c5 c8       	rjmp	80002b9e <send_flash_command+0x19e>
		case CHIP_ERASE:
			spi_write_byte(command);
80002ae8:	36 0b       	mov	r11,96
80002aea:	4b 28       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002aec:	70 0c       	ld.w	r12,r8[0x0]
80002aee:	f0 1f 00 33 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
80002af2:	c5 68       	rjmp	80002b9e <send_flash_command+0x19e>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
80002af4:	4a f7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002af6:	30 2b       	mov	r11,2
80002af8:	6e 0c       	ld.w	r12,r7[0x0]
80002afa:	f0 1f 00 30 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002afe:	08 9b       	mov	r11,r4
80002b00:	6e 0c       	ld.w	r12,r7[0x0]
80002b02:	f0 1f 00 2e 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002b06:	06 9b       	mov	r11,r3
80002b08:	6e 0c       	ld.w	r12,r7[0x0]
80002b0a:	f0 1f 00 2c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002b0e:	04 9b       	mov	r11,r2
80002b10:	6e 0c       	ld.w	r12,r7[0x0]
80002b12:	f0 1f 00 2a 	mcall	80002bb8 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002b16:	58 06       	cp.w	r6,0
80002b18:	c4 30       	breq	80002b9e <send_flash_command+0x19e>
80002b1a:	0a 97       	mov	r7,r5
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
				data_ptr++;
				spi_write_byte(data_u16);
80002b1c:	4a 54       	lddpc	r4,80002bb0 <send_flash_command+0x1b0>
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				data_u16 = (*data_ptr)&0x00ff;//modified by huayi
80002b1e:	0f 3b       	ld.ub	r11,r7++
80002b20:	ba 0b       	st.h	sp[0x0],r11
				data_ptr++;
				spi_write_byte(data_u16);
80002b22:	68 0c       	ld.w	r12,r4[0x0]
80002b24:	f0 1f 00 25 	mcall	80002bb8 <send_flash_command+0x1b8>
		case BYTE_PROGRAM: /* PAGE_PROGRAM use the same value */
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002b28:	0e 98       	mov	r8,r7
80002b2a:	0a 18       	sub	r8,r5
80002b2c:	ec 08 19 00 	cp.h	r8,r6
80002b30:	cf 73       	brcs	80002b1e <send_flash_command+0x11e>
80002b32:	c3 68       	rjmp	80002b9e <send_flash_command+0x19e>
				data_ptr++;
				spi_write_byte(data_u16);
			}
			break;
		case READ_ARRAY:
			spi_write_byte(command);
80002b34:	49 f7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002b36:	30 3b       	mov	r11,3
80002b38:	6e 0c       	ld.w	r12,r7[0x0]
80002b3a:	f0 1f 00 20 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[2]);
80002b3e:	08 9b       	mov	r11,r4
80002b40:	6e 0c       	ld.w	r12,r7[0x0]
80002b42:	f0 1f 00 1e 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[1]);
80002b46:	06 9b       	mov	r11,r3
80002b48:	6e 0c       	ld.w	r12,r7[0x0]
80002b4a:	f0 1f 00 1c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(addr[0]);
80002b4e:	04 9b       	mov	r11,r2
80002b50:	6e 0c       	ld.w	r12,r7[0x0]
80002b52:	f0 1f 00 1a 	mcall	80002bb8 <send_flash_command+0x1b8>
			for (i = 0; i < length; i++)
80002b56:	58 06       	cp.w	r6,0
80002b58:	c2 30       	breq	80002b9e <send_flash_command+0x19e>
80002b5a:	0a 97       	mov	r7,r5
			{
				spi_write_dummy();
80002b5c:	49 54       	lddpc	r4,80002bb0 <send_flash_command+0x1b0>
80002b5e:	e0 63 00 ff 	mov	r3,255
				spi_read_byte(&data_u16);
80002b62:	1a 92       	mov	r2,sp
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
			{
				spi_write_dummy();
80002b64:	06 9b       	mov	r11,r3
80002b66:	68 0c       	ld.w	r12,r4[0x0]
80002b68:	f0 1f 00 14 	mcall	80002bb8 <send_flash_command+0x1b8>
				spi_read_byte(&data_u16);
80002b6c:	1a 9b       	mov	r11,sp
80002b6e:	68 0c       	ld.w	r12,r4[0x0]
80002b70:	f0 1f 00 13 	mcall	80002bbc <send_flash_command+0x1bc>
				*data_ptr = (U8)data_u16;
80002b74:	9a 08       	ld.sh	r8,sp[0x0]
80002b76:	0e c8       	st.b	r7++,r8
		case READ_ARRAY:
			spi_write_byte(command);
			spi_write_byte(addr[2]);
			spi_write_byte(addr[1]);
			spi_write_byte(addr[0]);
			for (i = 0; i < length; i++)
80002b78:	0e 98       	mov	r8,r7
80002b7a:	0a 18       	sub	r8,r5
80002b7c:	ec 08 19 00 	cp.h	r8,r6
80002b80:	cf 23       	brcs	80002b64 <send_flash_command+0x164>
80002b82:	c0 e8       	rjmp	80002b9e <send_flash_command+0x19e>
				*data_ptr = (U8)data_u16;
				data_ptr++;
			}
			break;
		case WRITE_STATUS_REG_BYTE_1:
			spi_write_byte(command);
80002b84:	48 b7       	lddpc	r7,80002bb0 <send_flash_command+0x1b0>
80002b86:	30 1b       	mov	r11,1
80002b88:	6e 0c       	ld.w	r12,r7[0x0]
80002b8a:	f0 1f 00 0c 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002b8e:	30 0b       	mov	r11,0
80002b90:	6e 0c       	ld.w	r12,r7[0x0]
80002b92:	f0 1f 00 0a 	mcall	80002bb8 <send_flash_command+0x1b8>
			spi_write_byte(UNPROTECT_ALL_SECTORS);
80002b96:	30 0b       	mov	r11,0
80002b98:	6e 0c       	ld.w	r12,r7[0x0]
80002b9a:	f0 1f 00 08 	mcall	80002bb8 <send_flash_command+0x1b8>
			break;
		default:
			break;
	}

	spi_unselectChip(spi, DF_SPI_PCS_1);
80002b9e:	30 1b       	mov	r11,1
80002ba0:	48 48       	lddpc	r8,80002bb0 <send_flash_command+0x1b0>
80002ba2:	70 0c       	ld.w	r12,r8[0x0]
80002ba4:	f0 1f 00 07 	mcall	80002bc0 <send_flash_command+0x1c0>

	return status;
}
80002ba8:	9a 1c       	ld.sh	r12,sp[0x2]
80002baa:	2f fd       	sub	sp,-4
80002bac:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002bb0:	00 00       	add	r0,r0
80002bb2:	1f 70       	ld.ub	r0,--pc
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	48 2c       	lddpc	r12,80002bbc <send_flash_command+0x1bc>
80002bb8:	80 00       	ld.sh	r0,r0[0x0]
80002bba:	46 c6       	lddsp	r6,sp[0x1b0]
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	46 e2       	lddsp	r2,sp[0x1b8]
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	47 ec       	lddsp	r12,sp[0x1f8]

80002bc4 <data_flash_read_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_read_block(U32 address, U16 length, U8 *data_ptr)
{
80002bc4:	d4 01       	pushm	lr
	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > 0x1000)
80002bc6:	58 0a       	cp.w	r10,0
80002bc8:	5f 09       	sreq	r9
80002bca:	e0 68 ff fe 	mov	r8,65534
80002bce:	ea 18 00 7f 	orh	r8,0x7f
80002bd2:	10 3c       	cp.w	r12,r8
80002bd4:	5f b8       	srhi	r8
80002bd6:	f3 e8 10 08 	or	r8,r9,r8
80002bda:	c0 e1       	brne	80002bf6 <data_flash_read_block+0x32>
80002bdc:	e0 68 10 00 	mov	r8,4096
80002be0:	f0 0b 19 00 	cp.h	r11,r8
80002be4:	e0 8b 00 09 	brhi	80002bf6 <data_flash_read_block+0x32>
	{
		return DF_INVALID_PARAM;
	}

	send_flash_command(READ_ARRAY, address, data_ptr, length);
80002be8:	f3 db c0 10 	bfextu	r9,r11,0x0,0x10
80002bec:	18 9b       	mov	r11,r12
80002bee:	30 3c       	mov	r12,3
80002bf0:	f0 1f 00 02 	mcall	80002bf8 <data_flash_read_block+0x34>
80002bf4:	d8 0a       	popm	pc,r12=0

	return DF_OK;
80002bf6:	da 0a       	popm	pc,r12=1
80002bf8:	80 00       	ld.sh	r0,r0[0x0]
80002bfa:	2a 00       	sub	r0,-96

80002bfc <data_flash_write_page>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_page(U8 *data_ptr, U32 address, U16 length)
{
80002bfc:	eb cd 40 fc 	pushm	r2-r7,lr
80002c00:	18 94       	mov	r4,r12
80002c02:	16 93       	mov	r3,r11
80002c04:	14 92       	mov	r2,r10
	U16 status = 1;
	df_status_t return_code = DF_WRITE_FAIL;
	U16 count = 0; /* to monitor write time consumption */

	/* check input parameter */
	if (data_ptr == NULL || address >= DF_MAX_ADDR || length > DF_PAGE_SIZE)
80002c06:	58 0c       	cp.w	r12,0
80002c08:	5f 09       	sreq	r9
80002c0a:	e0 68 ff fe 	mov	r8,65534
80002c0e:	ea 18 00 7f 	orh	r8,0x7f
80002c12:	10 3b       	cp.w	r11,r8
80002c14:	5f b8       	srhi	r8
80002c16:	f3 e8 10 08 	or	r8,r9,r8
80002c1a:	c3 a1       	brne	80002c8e <data_flash_write_page+0x92>
80002c1c:	e0 68 01 00 	mov	r8,256
80002c20:	f0 0a 19 00 	cp.h	r10,r8
80002c24:	e0 8b 00 35 	brhi	80002c8e <data_flash_write_page+0x92>
	{
		return DF_INVALID_PARAM;
	}

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002c28:	30 06       	mov	r6,0
80002c2a:	30 55       	mov	r5,5
80002c2c:	30 17       	mov	r7,1
80002c2e:	0c 99       	mov	r9,r6
80002c30:	0c 9a       	mov	r10,r6
80002c32:	0c 9b       	mov	r11,r6
80002c34:	0a 9c       	mov	r12,r5
80002c36:	f0 1f 00 19 	mcall	80002c98 <data_flash_write_page+0x9c>
80002c3a:	ee 0c 19 00 	cp.h	r12,r7
80002c3e:	cf 80       	breq	80002c2e <data_flash_write_page+0x32>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002c40:	30 09       	mov	r9,0
80002c42:	12 9a       	mov	r10,r9
80002c44:	12 9b       	mov	r11,r9
80002c46:	30 6c       	mov	r12,6
80002c48:	f0 1f 00 14 	mcall	80002c98 <data_flash_write_page+0x9c>

	/* send PAGE_PROGRAM command */
	send_flash_command(PAGE_PROGRAM, address, data_ptr, length);
80002c4c:	f3 d2 c0 10 	bfextu	r9,r2,0x0,0x10
80002c50:	08 9a       	mov	r10,r4
80002c52:	06 9b       	mov	r11,r3
80002c54:	30 2c       	mov	r12,2
80002c56:	f0 1f 00 11 	mcall	80002c98 <data_flash_write_page+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002c5a:	30 06       	mov	r6,0
80002c5c:	30 57       	mov	r7,5
80002c5e:	0c 99       	mov	r9,r6
80002c60:	0c 9a       	mov	r10,r6
80002c62:	0c 9b       	mov	r11,r6
80002c64:	0e 9c       	mov	r12,r7
80002c66:	f0 1f 00 0d 	mcall	80002c98 <data_flash_write_page+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002c6a:	5c 7c       	castu.h	r12
80002c6c:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002c70:	cf 71       	brne	80002c5e <data_flash_write_page+0x62>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002c72:	18 97       	mov	r7,r12
80002c74:	e2 17 00 20 	andl	r7,0x20,COH
80002c78:	f9 b7 01 06 	movne	r7,6
80002c7c:	f9 b7 00 07 	moveq	r7,7
		/*  Erase Successful.  */
		return_code = DF_WRITE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002c80:	30 09       	mov	r9,0
80002c82:	12 9a       	mov	r10,r9
80002c84:	12 9b       	mov	r11,r9
80002c86:	30 4c       	mov	r12,4
80002c88:	f0 1f 00 04 	mcall	80002c98 <data_flash_write_page+0x9c>

	return return_code;
80002c8c:	c0 28       	rjmp	80002c90 <data_flash_write_page+0x94>
80002c8e:	30 17       	mov	r7,1
}
80002c90:	0e 9c       	mov	r12,r7
80002c92:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80002c96:	00 00       	add	r0,r0
80002c98:	80 00       	ld.sh	r0,r0[0x0]
80002c9a:	2a 00       	sub	r0,-96

80002c9c <data_flash_write_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write_block(U8 *data_ptr, U32 address, U16 data_length)
{
80002c9c:	d4 31       	pushm	r0-r7,lr
80002c9e:	18 94       	mov	r4,r12
80002ca0:	ed da b0 10 	bfexts	r6,r10,0x0,0x10
80002ca4:	16 97       	mov	r7,r11
80002ca6:	30 7c       	mov	r12,7
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002ca8:	30 03       	mov	r3,0
80002caa:	06 92       	mov	r2,r3
	{
		if ((write_addr & 0xFF) == 0)
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002cac:	e0 60 01 00 	mov	r0,256
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002cb0:	c4 98       	rjmp	80002d42 <data_flash_write_block+0xa6>
	{
		if ((write_addr & 0xFF) == 0)
80002cb2:	eb d7 c0 08 	bfextu	r5,r7,0x0,0x8
80002cb6:	c1 b1       	brne	80002cec <data_flash_write_block+0x50>
		{
			/* address 256 bytes aligned */

			if (bytes_remained <= DF_PAGE_SIZE)
80002cb8:	e0 06 19 00 	cp.h	r6,r0
80002cbc:	e0 8b 00 0a 	brhi	80002cd0 <data_flash_write_block+0x34>
			{
				/* bytes remained less than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002cc0:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002cc4:	0e 9b       	mov	r11,r7
80002cc6:	08 9c       	mov	r12,r4
80002cc8:	f0 1f 00 24 	mcall	80002d58 <data_flash_write_block+0xbc>
80002ccc:	30 06       	mov	r6,0
80002cce:	c3 a8       	rjmp	80002d42 <data_flash_write_block+0xa6>
				bytes_remained = 0;	/* end while loop */
			}
			else /* (bytes_remained > DF_PAGE_SIZE) */
			{
				/* bytes remained more than one page */
				return_code = data_flash_write_page(data_ptr, write_addr, DF_PAGE_SIZE);
80002cd0:	e0 6a 01 00 	mov	r10,256
80002cd4:	0e 9b       	mov	r11,r7
80002cd6:	08 9c       	mov	r12,r4
80002cd8:	f0 1f 00 20 	mcall	80002d58 <data_flash_write_block+0xbc>
				bytes_remained -= DF_PAGE_SIZE;
80002cdc:	ec c6 01 00 	sub	r6,r6,256
80002ce0:	5c 86       	casts.h	r6
				data_ptr += DF_PAGE_SIZE;
80002ce2:	e8 c4 ff 00 	sub	r4,r4,-256
				write_addr += DF_PAGE_SIZE;
80002ce6:	ee c7 ff 00 	sub	r7,r7,-256
80002cea:	c2 c8       	rjmp	80002d42 <data_flash_write_block+0xa6>
		}
		else
		{
			/*(write_addr & 0xFF != 0), address not 256 bytes aligned */

			if (BEYOND_PAGE_BOUNDARY(write_addr, bytes_remained) == TRUE)
80002cec:	f3 d6 c0 10 	bfextu	r9,r6,0x0,0x10
80002cf0:	0e 09       	add	r9,r7
80002cf2:	0e 98       	mov	r8,r7
80002cf4:	e4 18 00 7f 	andh	r8,0x7f
80002cf8:	e0 18 ff 00 	andl	r8,0xff00
80002cfc:	f0 c8 ff 00 	sub	r8,r8,-256
80002d00:	10 39       	cp.w	r9,r8
80002d02:	e0 88 00 19 	brls	80002d34 <data_flash_write_block+0x98>
			{
				/* bytes remained exceed current page, only write data within current page */
				return_code = data_flash_write_page(data_ptr, write_addr, BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr));
80002d06:	0e 91       	mov	r1,r7
80002d08:	5c 51       	castu.b	r1
80002d0a:	e0 6a 01 00 	mov	r10,256
80002d0e:	02 1a       	sub	r10,r1
80002d10:	5c 7a       	castu.h	r10
80002d12:	0e 9b       	mov	r11,r7
80002d14:	08 9c       	mov	r12,r4
80002d16:	f0 1f 00 11 	mcall	80002d58 <data_flash_write_block+0xbc>
				bytes_remained -= BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002d1a:	ec c6 01 00 	sub	r6,r6,256
80002d1e:	02 06       	add	r6,r1
80002d20:	5c 86       	casts.h	r6
				data_ptr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr);
80002d22:	e0 68 01 00 	mov	r8,256
80002d26:	f0 05 01 05 	sub	r5,r8,r5
80002d2a:	0a 04       	add	r4,r5
				write_addr += BYTES_TO_NEXT_PAGE_BOUNDARY(write_addr); /* now became 256 bytes aligned */
80002d2c:	e0 17 ff 00 	andl	r7,0xff00
80002d30:	10 07       	add	r7,r8
80002d32:	c0 88       	rjmp	80002d42 <data_flash_write_block+0xa6>
			}
			else
			{
				/* bytes remained not exceed current page */
				return_code = data_flash_write_page(data_ptr, write_addr, bytes_remained);
80002d34:	f5 d6 c0 10 	bfextu	r10,r6,0x0,0x10
80002d38:	0e 9b       	mov	r11,r7
80002d3a:	08 9c       	mov	r12,r4
80002d3c:	f0 1f 00 07 	mcall	80002d58 <data_flash_write_block+0xbc>
80002d40:	30 06       	mov	r6,0
{
	df_status_t return_code = DF_WRITE_COMPLETED;
	U32 write_addr = address;
	U16 bytes_remained = data_length;

	while (bytes_remained >= 1 && return_code == DF_WRITE_COMPLETED)
80002d42:	e6 06 19 00 	cp.h	r6,r3
80002d46:	5f 19       	srne	r9
80002d48:	58 7c       	cp.w	r12,7
80002d4a:	5f 08       	sreq	r8
80002d4c:	f3 e8 00 08 	and	r8,r9,r8
80002d50:	e4 08 18 00 	cp.b	r8,r2
80002d54:	ca f1       	brne	80002cb2 <data_flash_write_block+0x16>
			}
		}
	}	/* end of while */

	return return_code;
}
80002d56:	d8 32       	popm	r0-r7,pc
80002d58:	80 00       	ld.sh	r0,r0[0x0]
80002d5a:	2b fc       	sub	r12,-65

80002d5c <data_flash_erase_block>:
* ----------  --------  ----------  --------------------------------------------
* 25-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_erase_block(U32 address, df_block_size_t block_size)
{
80002d5c:	eb cd 40 f8 	pushm	r3-r7,lr
80002d60:	18 94       	mov	r4,r12
	U16 erase_commond;
	df_status_t return_code = DF_ERASE_FAIL;
	U16 count = 0; /* to monitor erase time consumption */

	/* check input parameter */
	if (address >= DF_MAX_ADDR)
80002d62:	e0 68 ff fe 	mov	r8,65534
80002d66:	ea 18 00 7f 	orh	r8,0x7f
80002d6a:	10 3c       	cp.w	r12,r8
80002d6c:	e0 88 00 04 	brls	80002d74 <data_flash_erase_block+0x18>
80002d70:	30 17       	mov	r7,1
80002d72:	c3 f8       	rjmp	80002df0 <data_flash_erase_block+0x94>
	{
		return DF_INVALID_PARAM;
	}

	/* determine erase command to be issued */
	if (block_size == DF_BLOCK_4KB)
80002d74:	58 1b       	cp.w	r11,1
80002d76:	c0 31       	brne	80002d7c <data_flash_erase_block+0x20>
80002d78:	32 03       	mov	r3,32
80002d7a:	c0 a8       	rjmp	80002d8e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_4KB;
	else if (block_size == DF_BLOCK_32KB)
80002d7c:	58 2b       	cp.w	r11,2
80002d7e:	c0 31       	brne	80002d84 <data_flash_erase_block+0x28>
80002d80:	35 23       	mov	r3,82
80002d82:	c0 68       	rjmp	80002d8e <data_flash_erase_block+0x32>
		erase_commond = BLOCK_ERASE_32KB;
	else if(block_size == DF_BLOCK_64KB)
80002d84:	e0 63 00 d8 	mov	r3,216
80002d88:	58 3b       	cp.w	r11,3
80002d8a:	f9 b3 01 60 	movne	r3,96
		erase_commond = BLOCK_ERASE_64KB;
	else/*(block_size == DF_BLOCK_ALL)*/
		erase_commond = CHIP_ERASE;

	while(status = send_flash_command(READ_STATUS_REG, 0, NULL, 0) == STATUS_BUSY);
80002d8e:	30 06       	mov	r6,0
80002d90:	30 55       	mov	r5,5
80002d92:	30 17       	mov	r7,1
80002d94:	0c 99       	mov	r9,r6
80002d96:	0c 9a       	mov	r10,r6
80002d98:	0c 9b       	mov	r11,r6
80002d9a:	0a 9c       	mov	r12,r5
80002d9c:	f0 1f 00 17 	mcall	80002df8 <data_flash_erase_block+0x9c>
80002da0:	ee 0c 19 00 	cp.h	r12,r7
80002da4:	cf 80       	breq	80002d94 <data_flash_erase_block+0x38>
	//{
		//return DF_DEVICE_BUSY;
	//}

	/* send WRITE_ENABLE command */
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002da6:	30 09       	mov	r9,0
80002da8:	12 9a       	mov	r10,r9
80002daa:	12 9b       	mov	r11,r9
80002dac:	30 6c       	mov	r12,6
80002dae:	f0 1f 00 13 	mcall	80002df8 <data_flash_erase_block+0x9c>

	/* send BLOCK_ERASE command */
	send_flash_command(erase_commond, address, NULL, 0);
80002db2:	30 09       	mov	r9,0
80002db4:	12 9a       	mov	r10,r9
80002db6:	08 9b       	mov	r11,r4
80002db8:	06 9c       	mov	r12,r3
80002dba:	f0 1f 00 10 	mcall	80002df8 <data_flash_erase_block+0x9c>
	do {
		status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002dbe:	30 06       	mov	r6,0
80002dc0:	30 57       	mov	r7,5
80002dc2:	0c 99       	mov	r9,r6
80002dc4:	0c 9a       	mov	r10,r6
80002dc6:	0c 9b       	mov	r11,r6
80002dc8:	0e 9c       	mov	r12,r7
80002dca:	f0 1f 00 0c 	mcall	80002df8 <data_flash_erase_block+0x9c>
		count++;
	} while((status & STATUS_BUSY) != 0);
80002dce:	5c 7c       	castu.h	r12
80002dd0:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80002dd4:	cf 71       	brne	80002dc2 <data_flash_erase_block+0x66>

	/*  Check Status Register */
	if ((status & STATUS_ERASE_PROG_ERROR) != 0)
80002dd6:	18 97       	mov	r7,r12
80002dd8:	e2 17 00 20 	andl	r7,0x20,COH
80002ddc:	f9 b7 01 04 	movne	r7,4
80002de0:	f9 b7 00 05 	moveq	r7,5
		/*  Erase Successful.  */
		return_code = DF_ERASE_COMPLETED;
	}

	/* send WRITE_DISABLE command */
	send_flash_command(WRITE_DISABLE, 0, NULL, 0);
80002de4:	30 09       	mov	r9,0
80002de6:	12 9a       	mov	r10,r9
80002de8:	12 9b       	mov	r11,r9
80002dea:	30 4c       	mov	r12,4
80002dec:	f0 1f 00 03 	mcall	80002df8 <data_flash_erase_block+0x9c>

	return return_code;
}
80002df0:	0e 9c       	mov	r12,r7
80002df2:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002df6:	00 00       	add	r0,r0
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	2a 00       	sub	r0,-96

80002dfc <data_flash_write>:
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
{
80002dfc:	d4 31       	pushm	r0-r7,lr
80002dfe:	20 3d       	sub	sp,12
80002e00:	50 0c       	stdsp	sp[0x0],r12
80002e02:	16 91       	mov	r1,r11
80002e04:	14 95       	mov	r5,r10
	U16 secremain;
	U16 i;
	df_status_t return_code = DF_OK;

	secpos	=	address/4096;//扇区地址 0~2047 for AT25DF641 
	secoff	=	address%4096;//在扇区内的偏移
80002e06:	f5 db c0 0c 	bfextu	r10,r11,0x0,0xc
80002e0a:	50 1a       	stdsp	sp[0x4],r10
	secremain	=	4096-secoff;//扇区剩余空间大小
80002e0c:	e0 69 10 00 	mov	r9,4096
80002e10:	f2 0a 01 07 	sub	r7,r9,r10
80002e14:	ea 07 19 00 	cp.h	r7,r5
80002e18:	ea 07 17 b0 	movhi	r7,r5
80002e1c:	5c 87       	casts.h	r7
80002e1e:	16 92       	mov	r2,r11
80002e20:	e0 12 f0 00 	andl	r2,0xf000
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002e24:	4a e4       	lddpc	r4,80002edc <data_flash_write+0xe0>
		for(i=0; i<secremain; i++)//校验数据
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002e26:	3f f6       	mov	r6,-1
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002e28:	e8 c8 ff ff 	sub	r8,r4,-1
80002e2c:	50 28       	stdsp	sp[0x8],r8
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
			address+=secremain;//写地址偏移
			data_length-=secremain;				//字节数递减
80002e2e:	12 90       	mov	r0,r9
	secoff	=	address%4096;//在扇区内的偏移
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
80002e30:	08 9a       	mov	r10,r4
80002e32:	e0 6b 10 00 	mov	r11,4096
80002e36:	04 9c       	mov	r12,r2
80002e38:	f0 1f 00 2a 	mcall	80002ee0 <data_flash_write+0xe4>
		for(i=0; i<secremain; i++)//校验数据
80002e3c:	58 07       	cp.w	r7,0
80002e3e:	c3 00       	breq	80002e9e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
80002e40:	40 13       	lddsp	r3,sp[0x4]
80002e42:	5c 73       	castu.h	r3
80002e44:	e8 03 07 08 	ld.ub	r8,r4[r3]
80002e48:	ec 08 18 00 	cp.b	r8,r6
80002e4c:	c1 11       	brne	80002e6e <data_flash_write+0x72>
80002e4e:	e6 c9 ff ff 	sub	r9,r3,-1
80002e52:	08 09       	add	r9,r4
80002e54:	30 08       	mov	r8,0
80002e56:	c0 58       	rjmp	80002e60 <data_flash_write+0x64>
80002e58:	13 3a       	ld.ub	r10,r9++
80002e5a:	ec 0a 18 00 	cp.b	r10,r6
80002e5e:	c0 81       	brne	80002e6e <data_flash_write+0x72>
	secremain	=	4096-secoff;//扇区剩余空间大小
	if(data_length <= secremain)secremain = data_length;//不大于4096个字节
	while(1)
	{
		data_flash_read_block(secpos*4096, 4096, FLASH_BUF);//读出整个扇区的内容
		for(i=0; i<secremain; i++)//校验数据
80002e60:	2f f8       	sub	r8,-1
80002e62:	5c 88       	casts.h	r8
80002e64:	f0 07 19 00 	cp.h	r7,r8
80002e68:	fe 9b ff f8 	brhi	80002e58 <data_flash_write+0x5c>
80002e6c:	c1 98       	rjmp	80002e9e <data_flash_write+0xa2>
		{
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
80002e6e:	30 1b       	mov	r11,1
80002e70:	04 9c       	mov	r12,r2
80002e72:	f0 1f 00 1d 	mcall	80002ee4 <data_flash_write+0xe8>
80002e76:	40 08       	lddsp	r8,sp[0x0]
80002e78:	08 03       	add	r3,r4
* Date        Name      Prob#       Description
* ----------  --------  ----------  --------------------------------------------
* 25-Fri-17   Edwards    none        Initial draft
*
*******************************************************************************/
df_status_t data_flash_write(U8 *data_ptr, U32 address, U16 data_length)
80002e7a:	40 2a       	lddsp	r10,sp[0x8]
80002e7c:	40 19       	lddsp	r9,sp[0x4]
80002e7e:	12 0a       	add	r10,r9
80002e80:	0e 99       	mov	r9,r7
80002e82:	20 19       	sub	r9,1
80002e84:	5c 79       	castu.h	r9
80002e86:	12 0a       	add	r10,r9
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
80002e88:	11 39       	ld.ub	r9,r8++
80002e8a:	06 c9       	st.b	r3++,r9
			if(FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除
		}
		if(i < secremain)//需要擦除
		{
			return_code = data_flash_erase_block(secpos*4096, DF_BLOCK_4KB);//擦除这个扇区
			for(i=0; i<secremain; i++)	   //复制
80002e8c:	14 33       	cp.w	r3,r10
80002e8e:	cf d1       	brne	80002e88 <data_flash_write+0x8c>
			{
				FLASH_BUF[i+secoff]=data_ptr[i];
			}
			return_code = data_flash_write_block(FLASH_BUF, secpos*4096, 4096);//写入整个扇区
80002e90:	e0 6a 10 00 	mov	r10,4096
80002e94:	04 9b       	mov	r11,r2
80002e96:	08 9c       	mov	r12,r4
80002e98:	f0 1f 00 14 	mcall	80002ee8 <data_flash_write+0xec>
80002e9c:	c0 78       	rjmp	80002eaa <data_flash_write+0xae>

		}
		else 
		{
			return_code = data_flash_write_block(data_ptr, address, secremain);//写已经擦除了的,直接写入扇区剩余区间.
80002e9e:	0e 9a       	mov	r10,r7
80002ea0:	5c 7a       	castu.h	r10
80002ea2:	02 9b       	mov	r11,r1
80002ea4:	40 0c       	lddsp	r12,sp[0x0]
80002ea6:	f0 1f 00 11 	mcall	80002ee8 <data_flash_write+0xec>
80002eaa:	e4 c2 f0 00 	sub	r2,r2,-4096
		}
		if(data_length==secremain)break;//写入结束了
80002eae:	0e 98       	mov	r8,r7
80002eb0:	ee 05 19 00 	cp.h	r5,r7
80002eb4:	c1 20       	breq	80002ed8 <data_flash_write+0xdc>
		else//写入未结束
		{
			secpos++;//扇区地址增1
			secoff=0;//偏移位置为0

			data_ptr+=secremain;  //指针偏移
80002eb6:	5c 78       	castu.h	r8
80002eb8:	40 0a       	lddsp	r10,sp[0x0]
80002eba:	10 0a       	add	r10,r8
80002ebc:	50 0a       	stdsp	sp[0x0],r10
			address+=secremain;//写地址偏移
80002ebe:	10 01       	add	r1,r8
			data_length-=secremain;				//字节数递减
80002ec0:	0e 15       	sub	r5,r7
80002ec2:	5c 85       	casts.h	r5
80002ec4:	e0 05 19 00 	cp.h	r5,r0
80002ec8:	ea 07 17 80 	movls	r7,r5
80002ecc:	e0 07 17 b0 	movhi	r7,r0
80002ed0:	5c 87       	casts.h	r7
80002ed2:	30 09       	mov	r9,0
80002ed4:	50 19       	stdsp	sp[0x4],r9
80002ed6:	ca db       	rjmp	80002e30 <data_flash_write+0x34>
		}
	}
	
	return return_code;
	
}
80002ed8:	2f dd       	sub	sp,-12
80002eda:	d8 32       	popm	r0-r7,pc
80002edc:	00 00       	add	r0,r0
80002ede:	0f 70       	ld.ub	r0,--r7
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	2b c4       	sub	r4,-68
80002ee4:	80 00       	ld.sh	r0,r0[0x0]
80002ee6:	2d 5c       	sub	r12,-43
80002ee8:	80 00       	ld.sh	r0,r0[0x0]
80002eea:	2c 9c       	sub	r12,-55

80002eec <data_flash_init>:
* ----------  --------  ----------  --------------------------------------------
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
void data_flash_init(void)
{
80002eec:	eb cd 40 c0 	pushm	r6-r7,lr
80002ef0:	20 5d       	sub	sp,20
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 1,//0,0 针对不同的存储芯片，注意模式
		.modfdis      = 1
	};
80002ef2:	4c 28       	lddpc	r8,80002ff8 <data_flash_init+0x10c>
80002ef4:	fa c6 ff fc 	sub	r6,sp,-4
80002ef8:	f0 ea 00 00 	ld.d	r10,r8[0]
80002efc:	ec eb 00 00 	st.d	r6[0],r10
80002f00:	f0 e8 00 08 	ld.d	r8,r8[8]
80002f04:	ec e9 00 08 	st.d	r6[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(DF_SPI_GPIO_MAP, sizeof(DF_SPI_GPIO_MAP) / sizeof(DF_SPI_GPIO_MAP[0]));
80002f08:	30 4b       	mov	r11,4
80002f0a:	4b dc       	lddpc	r12,80002ffc <data_flash_init+0x110>
80002f0c:	f0 1f 00 3d 	mcall	80003000 <data_flash_init+0x114>

	spi = &AVR32_SPI;
80002f10:	4b d7       	lddpc	r7,80003004 <data_flash_init+0x118>
80002f12:	fe 7c 24 00 	mov	r12,-56320
80002f16:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80002f18:	0c 9b       	mov	r11,r6
80002f1a:	f0 1f 00 3c 	mcall	80003008 <data_flash_init+0x11c>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80002f1e:	30 09       	mov	r9,0
80002f20:	12 9a       	mov	r10,r9
80002f22:	12 9b       	mov	r11,r9
80002f24:	6e 0c       	ld.w	r12,r7[0x0]
80002f26:	f0 1f 00 3a 	mcall	8000300c <data_flash_init+0x120>

	// Enable SPI.
	spi_enable(spi);
80002f2a:	6e 0c       	ld.w	r12,r7[0x0]
80002f2c:	f0 1f 00 39 	mcall	80003010 <data_flash_init+0x124>

	// Initialize data flash with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
80002f30:	e0 6a 36 00 	mov	r10,13824
80002f34:	ea 1a 01 6e 	orh	r10,0x16e
80002f38:	0c 9b       	mov	r11,r6
80002f3a:	6e 0c       	ld.w	r12,r7[0x0]
80002f3c:	f0 1f 00 36 	mcall	80003014 <data_flash_init+0x128>
80002f40:	c0 50       	breq	80002f4a <data_flash_init+0x5e>
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_SPI_INIT;
80002f42:	30 29       	mov	r9,2
80002f44:	4b 58       	lddpc	r8,80003018 <data_flash_init+0x12c>
80002f46:	b0 89       	st.b	r8[0x0],r9
		return;
80002f48:	c5 58       	rjmp	80002ff2 <data_flash_init+0x106>
* 10-Feb-10   a21961    none        Initial draft
*
*******************************************************************************/
static Bool data_flash_check_device_id(void)
{
	U16 manufacturer_device_id[2] = {0x5A5A, 0x5A5A};
80002f4a:	1a 96       	mov	r6,sp
80002f4c:	30 4a       	mov	r10,4
80002f4e:	4b 4b       	lddpc	r11,8000301c <data_flash_init+0x130>
80002f50:	1a 9c       	mov	r12,sp
80002f52:	f0 1f 00 34 	mcall	80003020 <data_flash_init+0x134>

	/* DF memory check. */
	/* Select the DF memory to check. */
	spi_selectChip(spi, DF_SPI_PCS_1);
80002f56:	4a c7       	lddpc	r7,80003004 <data_flash_init+0x118>
80002f58:	30 1b       	mov	r11,1
80002f5a:	6e 0c       	ld.w	r12,r7[0x0]
80002f5c:	f0 1f 00 32 	mcall	80003024 <data_flash_init+0x138>

	/* Send the Manufacturer/Device ID Read command. */
	spi_write(spi, READ_M_D_ID);	
80002f60:	e0 6b 00 90 	mov	r11,144
80002f64:	6e 0c       	ld.w	r12,r7[0x0]
80002f66:	f0 1f 00 31 	mcall	80003028 <data_flash_init+0x13c>
	spi_write_zero();
80002f6a:	30 0b       	mov	r11,0
80002f6c:	6e 0c       	ld.w	r12,r7[0x0]
80002f6e:	f0 1f 00 2f 	mcall	80003028 <data_flash_init+0x13c>
	spi_write_zero();
80002f72:	30 0b       	mov	r11,0
80002f74:	6e 0c       	ld.w	r12,r7[0x0]
80002f76:	f0 1f 00 2d 	mcall	80003028 <data_flash_init+0x13c>
	spi_write_zero();
80002f7a:	30 0b       	mov	r11,0
80002f7c:	6e 0c       	ld.w	r12,r7[0x0]
80002f7e:	f0 1f 00 2b 	mcall	80003028 <data_flash_init+0x13c>

	/* Send 2 dummy byte to read the status register. */
	
	spi_write_dummy();
80002f82:	e0 6b 00 ff 	mov	r11,255
80002f86:	6e 0c       	ld.w	r12,r7[0x0]
80002f88:	f0 1f 00 28 	mcall	80003028 <data_flash_init+0x13c>
	spi_read(spi, &manufacturer_device_id[0]);
80002f8c:	1a 9b       	mov	r11,sp
80002f8e:	6e 0c       	ld.w	r12,r7[0x0]
80002f90:	f0 1f 00 27 	mcall	8000302c <data_flash_init+0x140>
	
	spi_write_dummy();
80002f94:	e0 6b 00 ff 	mov	r11,255
80002f98:	6e 0c       	ld.w	r12,r7[0x0]
80002f9a:	f0 1f 00 24 	mcall	80003028 <data_flash_init+0x13c>
	spi_read(spi, &manufacturer_device_id[1]);
80002f9e:	fa cb ff fe 	sub	r11,sp,-2
80002fa2:	6e 0c       	ld.w	r12,r7[0x0]
80002fa4:	f0 1f 00 22 	mcall	8000302c <data_flash_init+0x140>

	/* Unselect the checked DF memory. */
	spi_unselectChip(spi, DF_SPI_PCS_1);
80002fa8:	30 1b       	mov	r11,1
80002faa:	6e 0c       	ld.w	r12,r7[0x0]
80002fac:	f0 1f 00 21 	mcall	80003030 <data_flash_init+0x144>

	/* Unexpected device ID. */
    if ((manufacturer_device_id[0] != 0xEF) || (manufacturer_device_id[1] != 0x16))
80002fb0:	e0 68 00 ef 	mov	r8,239
80002fb4:	9a 09       	ld.sh	r9,sp[0x0]
80002fb6:	f0 09 19 00 	cp.h	r9,r8
80002fba:	c0 61       	brne	80002fc6 <data_flash_init+0xda>
80002fbc:	31 68       	mov	r8,22
80002fbe:	9a 19       	ld.sh	r9,sp[0x2]
80002fc0:	f0 09 19 00 	cp.h	r9,r8
80002fc4:	c0 50       	breq	80002fce <data_flash_init+0xe2>
		return;
	}
	 
	if (data_flash_check_device_id() != TRUE)//check W25Q64 ID
	{
		data_flash_failure = FATAL_ERROR_DATA_FLASH_READ_ID;
80002fc6:	30 39       	mov	r9,3
80002fc8:	49 48       	lddpc	r8,80003018 <data_flash_init+0x12c>
80002fca:	b0 89       	st.b	r8[0x0],r9
		return;
80002fcc:	c1 38       	rjmp	80002ff2 <data_flash_init+0x106>
	}

	// Set STATUS reg to unprotect all sect
	send_flash_command(WRITE_ENABLE, 0, NULL, 0);
80002fce:	30 09       	mov	r9,0
80002fd0:	12 9a       	mov	r10,r9
80002fd2:	12 9b       	mov	r11,r9
80002fd4:	30 6c       	mov	r12,6
80002fd6:	f0 1f 00 18 	mcall	80003034 <data_flash_init+0x148>
	send_flash_command(WRITE_STATUS_REG_BYTE_1, 0, NULL, 0);
80002fda:	30 09       	mov	r9,0
80002fdc:	12 9a       	mov	r10,r9
80002fde:	12 9b       	mov	r11,r9
80002fe0:	30 1c       	mov	r12,1
80002fe2:	f0 1f 00 15 	mcall	80003034 <data_flash_init+0x148>
	status = send_flash_command(READ_STATUS_REG, 0, NULL, 0);
80002fe6:	30 09       	mov	r9,0
80002fe8:	12 9a       	mov	r10,r9
80002fea:	12 9b       	mov	r11,r9
80002fec:	30 5c       	mov	r12,5
80002fee:	f0 1f 00 12 	mcall	80003034 <data_flash_init+0x148>
	
	return;
}
80002ff2:	2f bd       	sub	sp,-20
80002ff4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	c3 60       	breq	80003066 <xg_rtc_init+0x2e>
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	c3 40       	breq	80003066 <xg_rtc_init+0x2e>
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	41 ec       	lddsp	r12,sp[0x78]
80003004:	00 00       	add	r0,r0
80003006:	1f 70       	ld.ub	r0,--pc
80003008:	80 00       	ld.sh	r0,r0[0x0]
8000300a:	46 5c       	lddsp	r12,sp[0x194]
8000300c:	80 00       	ld.sh	r0,r0[0x0]
8000300e:	46 94       	lddsp	r4,sp[0x1a4]
80003010:	80 00       	ld.sh	r0,r0[0x0]
80003012:	46 c0       	lddsp	r0,sp[0x1b0]
80003014:	80 00       	ld.sh	r0,r0[0x0]
80003016:	47 04       	lddsp	r4,sp[0x1c0]
80003018:	00 00       	add	r0,r0
8000301a:	0a 3c       	cp.w	r12,r5
8000301c:	80 00       	ld.sh	r0,r0[0x0]
8000301e:	c3 3a       	rjmp	80002c84 <data_flash_write_page+0x88>
80003020:	80 00       	ld.sh	r0,r0[0x0]
80003022:	64 8a       	ld.w	r10,r2[0x20]
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	48 2c       	lddpc	r12,8000302c <data_flash_init+0x140>
80003028:	80 00       	ld.sh	r0,r0[0x0]
8000302a:	46 c6       	lddsp	r6,sp[0x1b0]
8000302c:	80 00       	ld.sh	r0,r0[0x0]
8000302e:	46 e2       	lddsp	r2,sp[0x1b8]
80003030:	80 00       	ld.sh	r0,r0[0x0]
80003032:	47 ec       	lddsp	r12,sp[0x1f8]
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	2a 00       	sub	r0,-96

80003038 <xg_rtc_init>:
}



void xg_rtc_init(void)
{
80003038:	d4 01       	pushm	lr
	
	// Disable all interrupts. */
	Disable_global_interrupt();
8000303a:	d3 03       	ssrf	0x10
	  
	// Register the RTC interrupt handler to the interrupt controller.
	INTC_register_interrupt(&rtc_irq, AVR32_RTC_IRQ, AVR32_INTC_INT0);
8000303c:	30 0a       	mov	r10,0
8000303e:	32 8b       	mov	r11,40
80003040:	49 5c       	lddpc	r12,80003094 <xg_rtc_init+0x5c>
80003042:	f0 1f 00 16 	mcall	80003098 <xg_rtc_init+0x60>

	// Initialize the RTC
	//if (!rtc_init(&AVR32_RTC, RTC_OSC_RC, RTC_PSEL_RC_1_76HZ))
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, RTC_PSEL_32KHZ_1HZ))
80003046:	30 ea       	mov	r10,14
80003048:	30 1b       	mov	r11,1
8000304a:	fe 7c 0d 00 	mov	r12,-62208
8000304e:	f0 1f 00 14 	mcall	8000309c <xg_rtc_init+0x64>
80003052:	c0 41       	brne	8000305a <xg_rtc_init+0x22>
	{
		log("Error initializing the RTC\r\n");
80003054:	49 3c       	lddpc	r12,800030a0 <xg_rtc_init+0x68>
80003056:	f0 1f 00 14 	mcall	800030a4 <xg_rtc_init+0x6c>
	}
	// Set top value to 0 to generate an interrupt every seconds */
	rtc_set_top_value(&AVR32_RTC, 0);
8000305a:	30 0b       	mov	r11,0
8000305c:	fe 7c 0d 00 	mov	r12,-62208
80003060:	f0 1f 00 12 	mcall	800030a8 <xg_rtc_init+0x70>
	// Enable the interrupts
	rtc_enable_interrupt(&AVR32_RTC);
80003064:	fe 7c 0d 00 	mov	r12,-62208
80003068:	f0 1f 00 11 	mcall	800030ac <xg_rtc_init+0x74>
	// Enable the RTC
	rtc_enable(&AVR32_RTC);
8000306c:	fe 7c 0d 00 	mov	r12,-62208
80003070:	f0 1f 00 10 	mcall	800030b0 <xg_rtc_init+0x78>

	Current_time.Year		= 16;
80003074:	49 08       	lddpc	r8,800030b4 <xg_rtc_init+0x7c>
80003076:	31 09       	mov	r9,16
80003078:	b0 89       	st.b	r8[0x0],r9
	Current_time.Month		= 2;
8000307a:	30 29       	mov	r9,2
8000307c:	b0 99       	st.b	r8[0x1],r9
	Current_time.Day		= 29;
8000307e:	31 d9       	mov	r9,29
80003080:	b0 a9       	st.b	r8[0x2],r9
	Current_time.Hour		= 23;
80003082:	31 79       	mov	r9,23
80003084:	b0 b9       	st.b	r8[0x3],r9
	Current_time.Minute		= 59;
80003086:	33 b9       	mov	r9,59
80003088:	b0 c9       	st.b	r8[0x4],r9
	Current_time.Second		= 40;
8000308a:	32 89       	mov	r9,40
8000308c:	b0 d9       	st.b	r8[0x5],r9
	
	// Enable global interrupts
	Enable_global_interrupt();
8000308e:	d5 03       	csrf	0x10
	  
	//RTC_Test();	

}
80003090:	d8 02       	popm	pc
80003092:	00 00       	add	r0,r0
80003094:	80 00       	ld.sh	r0,r0[0x0]
80003096:	30 b8       	mov	r8,11
80003098:	80 00       	ld.sh	r0,r0[0x0]
8000309a:	42 70       	lddsp	r0,sp[0x9c]
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	45 bc       	lddsp	r12,sp[0x16c]
800030a0:	80 00       	ld.sh	r0,r0[0x0]
800030a2:	c3 70       	breq	80003110 <rtc_irq+0x58>
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	5d 68       	*unknown*
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	45 78       	lddsp	r8,sp[0x15c]
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	45 70       	lddsp	r0,sp[0x15c]
800030b0:	80 00       	ld.sh	r0,r0[0x0]
800030b2:	45 4c       	lddsp	r12,sp[0x150]
800030b4:	00 00       	add	r0,r0
800030b6:	0c e8       	st.h	--r6,r8

800030b8 <rtc_irq>:
/* RTC Interrupt  */
#pragma handler = AVR32_RTC_IRQ_GROUP, 1
__interrupt
#endif
void rtc_irq(void)
{
800030b8:	d4 01       	pushm	lr
	U8 T,K;
	U32 T16,K16;
	// Increment the minutes counter
	//sec++;
	
	Current_time.Second++;
800030ba:	4b 98       	lddpc	r8,8000319c <rtc_irq+0xe4>
800030bc:	11 d9       	ld.ub	r9,r8[0x5]
800030be:	2f f9       	sub	r9,-1
800030c0:	b0 d9       	st.b	r8[0x5],r9
	if(Current_time.Second>=60)
800030c2:	11 d9       	ld.ub	r9,r8[0x5]
800030c4:	33 b8       	mov	r8,59
800030c6:	f0 09 18 00 	cp.b	r9,r8
800030ca:	e0 88 00 5f 	brls	80003188 <rtc_irq+0xd0>
	{
		Current_time.Second =0;
800030ce:	4b 48       	lddpc	r8,8000319c <rtc_irq+0xe4>
800030d0:	30 09       	mov	r9,0
800030d2:	b0 d9       	st.b	r8[0x5],r9
		Current_time.Minute++;
800030d4:	11 c9       	ld.ub	r9,r8[0x4]
800030d6:	2f f9       	sub	r9,-1
800030d8:	b0 c9       	st.b	r8[0x4],r9
		if(Current_time.Minute>=60)
800030da:	11 c9       	ld.ub	r9,r8[0x4]
800030dc:	33 b8       	mov	r8,59
800030de:	f0 09 18 00 	cp.b	r9,r8
800030e2:	e0 88 00 53 	brls	80003188 <rtc_irq+0xd0>
		{
			Current_time.Minute=0;
800030e6:	4a e8       	lddpc	r8,8000319c <rtc_irq+0xe4>
800030e8:	30 09       	mov	r9,0
800030ea:	b0 c9       	st.b	r8[0x4],r9
			Current_time.Hour++;
800030ec:	11 b9       	ld.ub	r9,r8[0x3]
800030ee:	2f f9       	sub	r9,-1
800030f0:	b0 b9       	st.b	r8[0x3],r9
			if (Current_time.Hour>=24)
800030f2:	11 b9       	ld.ub	r9,r8[0x3]
800030f4:	31 78       	mov	r8,23
800030f6:	f0 09 18 00 	cp.b	r9,r8
800030fa:	e0 88 00 47 	brls	80003188 <rtc_irq+0xd0>
			{
				Current_time.Hour=0;
800030fe:	4a 88       	lddpc	r8,8000319c <rtc_irq+0xe4>
80003100:	30 09       	mov	r9,0
80003102:	b0 b9       	st.b	r8[0x3],r9
				K16=(Current_time.Year&0x03)?365:366;				//判断当年是否为闰年,并获取当年的总天数（此算法时间起点为2000年）
80003104:	11 88       	ld.ub	r8,r8[0x0]
80003106:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000310a:	e0 69 01 6e 	mov	r9,366
8000310e:	e0 6a 01 6d 	mov	r10,365
80003112:	f4 08 17 10 	movne	r8,r10
80003116:	f2 08 17 00 	moveq	r8,r9
				K16-=337;											//计算当年二月份天数
				//统计当月天数				
				K=(Current_time.Month==2)?K16:(((Current_time.Month+(Current_time.Month>>3))&0x01)+30);			
8000311a:	4a 19       	lddpc	r9,8000319c <rtc_irq+0xe4>
8000311c:	13 9a       	ld.ub	r10,r9[0x1]
8000311e:	30 29       	mov	r9,2
80003120:	f2 0a 18 00 	cp.b	r10,r9
80003124:	c0 b0       	breq	8000313a <rtc_irq+0x82>
80003126:	49 e8       	lddpc	r8,8000319c <rtc_irq+0xe4>
80003128:	11 99       	ld.ub	r9,r8[0x1]
8000312a:	11 9a       	ld.ub	r10,r8[0x1]
8000312c:	a3 9a       	lsr	r10,0x3
8000312e:	12 0a       	add	r10,r9
80003130:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80003134:	2e 2a       	sub	r10,-30
80003136:	5c 5a       	castu.b	r10
80003138:	c0 58       	rjmp	80003142 <rtc_irq+0x8a>
8000313a:	f0 c8 01 51 	sub	r8,r8,337
8000313e:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
				Current_time.Day++;
80003142:	49 78       	lddpc	r8,8000319c <rtc_irq+0xe4>
80003144:	11 a9       	ld.ub	r9,r8[0x2]
80003146:	2f f9       	sub	r9,-1
80003148:	b0 a9       	st.b	r8[0x2],r9
				if(Current_time.Day>K)
8000314a:	11 a8       	ld.ub	r8,r8[0x2]
8000314c:	f0 0a 18 00 	cp.b	r10,r8
80003150:	c1 c2       	brcc	80003188 <rtc_irq+0xd0>
				{	
					Current_time.Day = 1;//重置到下月1号
80003152:	49 38       	lddpc	r8,8000319c <rtc_irq+0xe4>
80003154:	30 19       	mov	r9,1
80003156:	b0 a9       	st.b	r8[0x2],r9
					Current_time.Month++;
80003158:	11 99       	ld.ub	r9,r8[0x1]
8000315a:	2f f9       	sub	r9,-1
8000315c:	b0 99       	st.b	r8[0x1],r9
					if(Current_time.Month>12)
8000315e:	11 99       	ld.ub	r9,r8[0x1]
80003160:	30 c8       	mov	r8,12
80003162:	f0 09 18 00 	cp.b	r9,r8
80003166:	e0 88 00 11 	brls	80003188 <rtc_irq+0xd0>
					{
						Current_time.Month = 1;//重置到下一年的第一个月
8000316a:	48 d8       	lddpc	r8,8000319c <rtc_irq+0xe4>
8000316c:	30 19       	mov	r9,1
8000316e:	b0 99       	st.b	r8[0x1],r9
						Current_time.Year++;
80003170:	11 89       	ld.ub	r9,r8[0x0]
80003172:	2f f9       	sub	r9,-1
80003174:	b0 89       	st.b	r8[0x0],r9
						if (Current_time.Year>150)Current_time.Year=0;//重置年份											
80003176:	11 89       	ld.ub	r9,r8[0x0]
80003178:	39 68       	mov	r8,-106
8000317a:	f0 09 18 00 	cp.b	r9,r8
8000317e:	e0 88 00 05 	brls	80003188 <rtc_irq+0xd0>
80003182:	30 09       	mov	r9,0
80003184:	48 68       	lddpc	r8,8000319c <rtc_irq+0xe4>
80003186:	b0 89       	st.b	r8[0x0],r9
	}
	
	//Time_scale++;

	// clear the interrupt flag
	rtc_clear_interrupt(&AVR32_RTC);
80003188:	fe 7c 0d 00 	mov	r12,-62208
8000318c:	f0 1f 00 05 	mcall	800031a0 <rtc_irq+0xe8>

	// specify that an interrupt has been raised
	print_sec = 1;
80003190:	30 19       	mov	r9,1
80003192:	48 58       	lddpc	r8,800031a4 <rtc_irq+0xec>
80003194:	91 09       	st.w	r8[0x0],r9
}
80003196:	d4 02       	popm	lr
80003198:	d6 03       	rete
8000319a:	00 00       	add	r0,r0
8000319c:	00 00       	add	r0,r0
8000319e:	0c e8       	st.h	--r6,r8
800031a0:	80 00       	ld.sh	r0,r0[0x0]
800031a2:	45 9c       	lddsp	r12,sp[0x164]
800031a4:	00 00       	add	r0,r0
800031a6:	04 f4       	st.b	--r2,r4

800031a8 <payload_init>:
Calls: xTaskCreate--freertos
Called By:app_init -- app.c
*/
void payload_init(void ( *payload_rx_func)(void * ), void ( *payload_tx_func)(void * ) )
{				
	payload_rx_exec = payload_rx_func;
800031a8:	48 38       	lddpc	r8,800031b4 <payload_init+0xc>
800031aa:	91 0c       	st.w	r8[0x0],r12
	payload_tx_exec = payload_tx_func;
800031ac:	48 38       	lddpc	r8,800031b8 <payload_init+0x10>
800031ae:	91 0b       	st.w	r8[0x0],r11
	//,  2
	//,  NULL
	//);
	//
	
}
800031b0:	5e fc       	retal	r12
800031b2:	00 00       	add	r0,r0
800031b4:	00 00       	add	r0,r0
800031b6:	0a 40       	or	r0,r5
800031b8:	00 00       	add	r0,r0
800031ba:	0a 44       	or	r4,r5

800031bc <set_idle_store>:
	}
}


void set_idle_store(xQueueHandle store, void * ptr)
{
800031bc:	eb cd 40 80 	pushm	r7,lr
800031c0:	20 1d       	sub	sp,4
800031c2:	fa c7 ff fc 	sub	r7,sp,-4
800031c6:	0e db       	st.w	--r7,r11
	xQueueSend(store, &ptr, 0);
800031c8:	30 09       	mov	r9,0
800031ca:	12 9a       	mov	r10,r9
800031cc:	1a 9b       	mov	r11,sp
800031ce:	f0 1f 00 03 	mcall	800031d8 <set_idle_store+0x1c>
}
800031d2:	2f fd       	sub	sp,-4
800031d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800031d8:	80 00       	ld.sh	r0,r0[0x0]
800031da:	51 30       	stdsp	sp[0x4c],r0

800031dc <get_idle_store>:
	}//End of RxMedia Phy Handler.
}
#endif /*end if*/

void * get_idle_store(xQueueHandle store)
{
800031dc:	d4 01       	pushm	lr
800031de:	20 1d       	sub	sp,4
	void * ptr = NULL;
800031e0:	30 0a       	mov	r10,0
800031e2:	fa cb ff fc 	sub	r11,sp,-4
800031e6:	16 da       	st.w	--r11,r10

	if(pdTRUE == xQueueReceive(store, &ptr, 0))
800031e8:	14 99       	mov	r9,r10
800031ea:	1a 9b       	mov	r11,sp
800031ec:	f0 1f 00 05 	mcall	80003200 <get_idle_store+0x24>
800031f0:	58 1c       	cp.w	r12,1
800031f2:	f9 bc 01 00 	movne	r12,0
	{
		return ptr;
800031f6:	fb fc 00 00 	ld.weq	r12,sp[0x0]
	}
	else
	{
		return NULL;
	}
}
800031fa:	2f fd       	sub	sp,-4
800031fc:	d8 02       	popm	pc
800031fe:	00 00       	add	r0,r0
80003200:	80 00       	ld.sh	r0,r0[0x0]
80003202:	4f 74       	lddpc	r4,800033dc <xnl_tx+0x58>

80003204 <xcmp_register_app_list>:
Calls: 
Called By: app_init -- app.c
*/
void xcmp_register_app_list(void * list)
{
	app_list = (app_exec_t *)list;
80003204:	48 28       	lddpc	r8,8000320c <xcmp_register_app_list+0x8>
80003206:	91 0c       	st.w	r8[0x0],r12
}
80003208:	5e fc       	retal	r12
8000320a:	00 00       	add	r0,r0
8000320c:	00 00       	add	r0,r0
8000320e:	1f 74       	ld.ub	r4,--pc

80003210 <xcmp_tx>:
Calls:   
	xnl_tx -- xnl.c
Called By: ...
*/
static void xcmp_tx( xcmp_fragment_t * xcmp, U8 payload_len)
{
80003210:	eb cd 40 80 	pushm	r7,lr
80003214:	fa cd 01 00 	sub	sp,sp,256
80003218:	16 97       	mov	r7,r11
	Length :xnl length + checksum
	= checksum + xnl header + xcmp opcode + xcmp payload
	= 0x02 + 0x0C + 0x02 + xcmp payload
	= 0x10 + xcmp payload
	*/
	xnl_frame.phy_header.phy_control = 0x4000 | ( 0x10 + payload_len);
8000321a:	16 98       	mov	r8,r11
8000321c:	2f 08       	sub	r8,-16
8000321e:	af a8       	sbr	r8,0xe
80003220:	ba 08       	st.h	sp[0x0],r8
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.phy_header.check_sum = DEFAULT_VALUE; 
80003222:	3f f8       	mov	r8,-1
80003224:	ba 18       	st.h	sp[0x2],r8
	
	/*Insert opcode*/
	xnl_frame.xnl_header.opcode = XNL_DATA_MSG;
80003226:	30 b9       	mov	r9,11
80003228:	ba 29       	st.h	sp[0x4],r9
	
	/*If the value is DEFAULT_VALUE, then say the value will be modified in 
	the xnl_tx*/
	xnl_frame.xnl_header.flags = DEFAULT_VALUE;	
8000322a:	ba 38       	st.h	sp[0x6],r8
	xnl_frame.xnl_header.destination = DEFAULT_VALUE;
8000322c:	ba 48       	st.h	sp[0x8],r8
	xnl_frame.xnl_header.source = DEFAULT_VALUE;	
8000322e:	ba 58       	st.h	sp[0xa],r8
	xnl_frame.xnl_header.transaction_id = DEFAULT_VALUE;
80003230:	ba 68       	st.h	sp[0xc],r8
	
	/*insert xcmp frame data*/
	memcpy(&xnl_frame.xnl_payload.xnl_content_data_msg, xcmp, payload_len + 2);
80003232:	f6 ca ff fe 	sub	r10,r11,-2
80003236:	18 9b       	mov	r11,r12
80003238:	fa cc ff f0 	sub	r12,sp,-16
8000323c:	f0 1f 00 05 	mcall	80003250 <xcmp_tx+0x40>
	xnl_frame.xnl_header.payload_length = payload_len + 2;	
80003240:	2f e7       	sub	r7,-2
80003242:	ba 77       	st.h	sp[0xe],r7
	
	/* send xnl frame*/	
	xnl_tx(&xnl_frame);
80003244:	1a 9c       	mov	r12,sp
80003246:	f0 1f 00 04 	mcall	80003254 <xcmp_tx+0x44>
}
8000324a:	2c 0d       	sub	sp,-256
8000324c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003250:	80 00       	ld.sh	r0,r0[0x0]
80003252:	64 8a       	ld.w	r10,r2[0x20]
80003254:	80 00       	ld.sh	r0,r0[0x0]
80003256:	33 84       	mov	r4,56

80003258 <xcmp_data_session_req>:
Description: send data-session request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_data_session_req(void *message, U16 length, U8 dest)
{
80003258:	d4 21       	pushm	r4-r7,lr
8000325a:	fa cd 00 d0 	sub	sp,sp,208
8000325e:	18 94       	mov	r4,r12
80003260:	16 97       	mov	r7,r11
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
80003262:	e0 68 01 00 	mov	r8,256
80003266:	f0 0b 19 00 	cp.h	r11,r8
8000326a:	e0 8b 00 36 	brhi	800032d6 <xcmp_data_session_req+0x7e>
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
	
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
8000326e:	fa c5 ff f8 	sub	r5,sp,-8
	//U8 SizeofAddress = Remote_Mototrbo_Address_Size;// 3;//可能会变化
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | DATA_SESSION;
80003272:	e0 68 04 1d 	mov	r8,1053
80003276:	ba 38       	st.h	sp[0x6],r8
	/*point to xcmp payload*/
	DataSession_req_t * ptr = (DataSession_req_t *)xcmp_farme.u8;
	
	if (length > 256)return -1;
	
	ptr->Function = Single_Data_Uint;
80003278:	30 18       	mov	r8,1
8000327a:	aa 88       	st.b	r5[0x0],r8
	
	ptr->DataDefinition.Data_Protocol_Version = TMP_Ver_1_1;//0x20
8000327c:	32 08       	mov	r8,32
8000327e:	aa 98       	st.b	r5[0x1],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Type = Remote_IPV4_Address;//0x02
80003280:	30 28       	mov	r8,2
80003282:	aa a8       	st.b	r5[0x2],r8
	
	ptr->DataDefinition.Dest_Address.Remote_Address_Size = Remote_IPV4_Address_Size;//0x04
80003284:	30 48       	mov	r8,4
80003286:	aa b8       	st.b	r5[0x3],r8
	
	unsigned int addr = 0x0C000000 | (dest & 0x00FFFFFF);
80003288:	ea 1a 0c 00 	orh	r10,0xc00
8000328c:	50 0a       	stdsp	sp[0x0],r10
	memcpy(ptr->DataDefinition.Dest_Address.Remote_Address, &addr, Remote_IPV4_Address_Size);
8000328e:	30 4a       	mov	r10,4
80003290:	1a 9b       	mov	r11,sp
80003292:	fa cc ff f4 	sub	r12,sp,-12
80003296:	f0 1f 00 12 	mcall	800032dc <xcmp_data_session_req+0x84>
	//ptr->DataDefinition.Dest_Address.Remote_Address[0] = 0x0C;//12
	//ptr->DataDefinition.Dest_Address.Remote_Address[1] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[2] = 0x00;//0
	//ptr->DataDefinition.Dest_Address.Remote_Address[3] = 0x02;//2
	
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[0] = (Remote_Port >>8) & 0xFF;//4007
8000329a:	30 f8       	mov	r8,15
8000329c:	eb 68 00 08 	st.b	r5[8],r8
	ptr->DataDefinition.Dest_Address.Remote_Port_Com[1] = Remote_Port & 0xFF;//
800032a0:	3a 78       	mov	r8,-89
800032a2:	eb 68 00 09 	st.b	r5[9],r8
	
    
	ptr->DataPayload.Session_ID_Number = Session_ID;//0x00
800032a6:	30 08       	mov	r8,0
800032a8:	eb 68 00 0a 	st.b	r5[10],r8
	
	ptr->DataPayload.DataPayload_Length[0] =(length >> 8) & 0xFF ;//可能会变化
800032ac:	0e 9a       	mov	r10,r7
800032ae:	5c 7a       	castu.h	r10
800032b0:	f4 08 16 08 	lsr	r8,r10,0x8
800032b4:	eb 68 00 0b 	st.b	r5[11],r8
	ptr->DataPayload.DataPayload_Length[1] =length & 0xFF  ;//可能会变化
800032b8:	0e 96       	mov	r6,r7
800032ba:	eb 67 00 0c 	st.b	r5[12],r7
	
	memcpy(&(ptr->DataPayload.DataPayload[0]), message, length);
800032be:	08 9b       	mov	r11,r4
800032c0:	fa cc ff eb 	sub	r12,sp,-21
800032c4:	f0 1f 00 06 	mcall	800032dc <xcmp_data_session_req+0x84>
	
	xcmp_tx(&xcmp_farme, sizeof(DataSession_req_t) - (256 - length));
800032c8:	ee cb ff f3 	sub	r11,r7,-13
800032cc:	5c 5b       	castu.b	r11
800032ce:	fa cc ff fa 	sub	r12,sp,-6
800032d2:	f0 1f 00 04 	mcall	800032e0 <xcmp_data_session_req+0x88>
}
800032d6:	2c cd       	sub	sp,-208
800032d8:	d8 22       	popm	r4-r7,pc
800032da:	00 00       	add	r0,r0
800032dc:	80 00       	ld.sh	r0,r0[0x0]
800032de:	64 8a       	ld.w	r10,r2[0x20]
800032e0:	80 00       	ld.sh	r0,r0[0x0]
800032e2:	32 10       	mov	r0,33

800032e4 <xcmp_DeviceInitializationStatus_request>:
Description: send device initialization status request
Calls: xcmp_tx
Called By:...
*/
void xcmp_DeviceInitializationStatus_request(void)
{
800032e4:	d4 01       	pushm	lr
800032e6:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
		
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_BRDCAST | DEVICE_INITIALIZATION_STATUS;
800032ea:	fe 78 b4 00 	mov	r8,-19456
800032ee:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	DeviceInitializationStatus_brdcst_t * ptr 
						 = (DeviceInitializationStatus_brdcst_t *)xcmp_farme.u8;
800032f0:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*xcmp version 8.1.0.5*///版本号未正确填写，纠正
	ptr->XCMPVersion[0] = 0x08;
800032f4:	30 89       	mov	r9,8
800032f6:	b0 89       	st.b	r8[0x0],r9
	ptr->XCMPVersion[1] = 0x01;
800032f8:	30 19       	mov	r9,1
800032fa:	b0 99       	st.b	r8[0x1],r9
	ptr->XCMPVersion[2] = 0x00;
800032fc:	30 09       	mov	r9,0
800032fe:	b0 a9       	st.b	r8[0x2],r9
	ptr->XCMPVersion[3] = 0x05;
80003300:	30 5a       	mov	r10,5
80003302:	b0 ba       	st.b	r8[0x3],r10
	/*
	0x00:
	This is the message that the device sends at power up or after a reset. It 
	will give the initial status and capabilities for the device.
	*/
	ptr->DeviceInitType = 0x00;
80003304:	b0 c9       	st.b	r8[0x4],r9
	types of devices may provide a set of services to the radio system, but do 
	not have the ability to be the master.
	
	0x07:OptionBoard,3rd party Option Board-based application.
	*/
	ptr->DeviceStatusInfo.DeviceType = 0x07;
80003306:	30 7a       	mov	r10,7
80003308:	b0 da       	st.b	r8[0x5],r10
	
	/*Power Up Success, Device has powered up with no errors*/
	ptr->DeviceStatusInfo.DeviceStatus[0] = 0x00;
8000330a:	b0 e9       	st.b	r8[0x6],r9
	ptr->DeviceStatusInfo.DeviceStatus[1] = 0x00;
8000330c:	b0 f9       	st.b	r8[0x7],r9
	
	/*
	This number is the size of the Device Descriptor data structure with a 
	maximum size not exceeding 255 bytes.
	*/
	ptr->DeviceStatusInfo.DeviceDescriptorSize = 0x00;
8000330e:	f1 69 00 08 	st.b	r8[8],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme
80003312:	30 9b       	mov	r11,9
80003314:	fa cc ff fe 	sub	r12,sp,-2
80003318:	f0 1f 00 02 	mcall	80003320 <xcmp_DeviceInitializationStatus_request+0x3c>
		, sizeof(DeviceInitializationStatus_brdcst_t) - MAX_DEVICE_DESC_SIZE);
}
8000331c:	2c dd       	sub	sp,-204
8000331e:	d8 02       	popm	pc
80003320:	80 00       	ld.sh	r0,r0[0x0]
80003322:	32 10       	mov	r0,33

80003324 <xcmp_IdleTestTone>:
Description: send tone request to test
Calls: xcmp_tx
Called By:...
*/
void xcmp_IdleTestTone(U8 type, U16 toneID)
{
80003324:	d4 01       	pushm	lr
80003326:	fa cd 00 cc 	sub	sp,sp,204
	/*xcmp frame will be sent*/
	xcmp_fragment_t xcmp_farme;
	
	/*insert XCMP opcode*/
	xcmp_farme.xcmp_opcode = XCMP_REQUEST | TONE_CONTROL;
8000332a:	e0 68 04 09 	mov	r8,1033
8000332e:	ba 18       	st.h	sp[0x2],r8
	
	/*point to xcmp payload*/
	ToneControl_req_t * ptr = (ToneControl_req_t *)xcmp_farme.u8;
80003330:	fa c8 ff fc 	sub	r8,sp,-4
	
	/*Starts the specific tone*/	
	ptr->Function = type;
80003334:	b0 8c       	st.b	r8[0x0],r12
	
	/*This tone shall be sounded when radio landed on a priority channel*/
	//ptr->ToneIdentifier[0] = (Priority_Beep >> 8) & 0xFF;
	//ptr->ToneIdentifier[1] = Priority_Beep & 0xFF;
	
	ptr->ToneIdentifier[0] = (toneID >> 8) & 0xFF;
80003336:	f3 db c1 08 	bfextu	r9,r11,0x8,0x8
8000333a:	b0 99       	st.b	r8[0x1],r9
	ptr->ToneIdentifier[1] = toneID & 0xFF;	
8000333c:	b0 ab       	st.b	r8[0x2],r11
	
	/*
	The alert tone is played according to any rules for alert tones, given the 
	current volume setting. Settings for this field are 8 to 255 (0x08 ?0xFF).
	*/
	ptr->ToneVolumeControl = Current_Volume;
8000333e:	30 09       	mov	r9,0
80003340:	b0 b9       	st.b	r8[0x3],r9
	
	/*clear reserved*/
	memset(ptr->Reserved, 0, 8);
80003342:	fb 69 00 08 	st.b	sp[8],r9
80003346:	fa c8 ff f7 	sub	r8,sp,-9
8000334a:	b0 89       	st.b	r8[0x0],r9
8000334c:	fa c8 ff f6 	sub	r8,sp,-10
80003350:	b0 89       	st.b	r8[0x0],r9
80003352:	fa c8 ff f5 	sub	r8,sp,-11
80003356:	b0 89       	st.b	r8[0x0],r9
80003358:	fa c8 ff f4 	sub	r8,sp,-12
8000335c:	b0 89       	st.b	r8[0x0],r9
8000335e:	fa c8 ff f3 	sub	r8,sp,-13
80003362:	b0 89       	st.b	r8[0x0],r9
80003364:	fa c8 ff f2 	sub	r8,sp,-14
80003368:	b0 89       	st.b	r8[0x0],r9
8000336a:	fa c8 ff f1 	sub	r8,sp,-15
8000336e:	b0 89       	st.b	r8[0x0],r9
	
	/*send xcmp frame*/
	xcmp_tx( &xcmp_farme, sizeof(ToneControl_req_t));
80003370:	30 cb       	mov	r11,12
80003372:	fa cc ff fe 	sub	r12,sp,-2
80003376:	f0 1f 00 03 	mcall	80003380 <xcmp_IdleTestTone+0x5c>
}
8000337a:	2c dd       	sub	sp,-204
8000337c:	d8 02       	popm	pc
8000337e:	00 00       	add	r0,r0
80003380:	80 00       	ld.sh	r0,r0[0x0]
80003382:	32 10       	mov	r0,33

80003384 <xnl_tx>:
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
{
80003384:	eb cd 40 c0 	pushm	r6-r7,lr
80003388:	20 1d       	sub	sp,4
8000338a:	18 96       	mov	r6,r12
	message that is sent. The same value should be used for all retries.
	*/
	static U8 flags = 0;
	
	/*If the value is DEFAULT_VALUE, the value will be modified*/
	if(DEFAULT_VALUE == xnl->xnl_header.flags)
8000338c:	98 39       	ld.sh	r9,r12[0x6]
8000338e:	3f f8       	mov	r8,-1
80003390:	f0 09 19 00 	cp.h	r9,r8
80003394:	c0 a1       	brne	800033a8 <xnl_tx+0x24>
	{
		xnl->xnl_header.flags =  0x0100 | ((++flags) & 0x07);
80003396:	4a e9       	lddpc	r9,8000344c <xnl_tx+0xc8>
80003398:	13 88       	ld.ub	r8,r9[0x0]
8000339a:	2f f8       	sub	r8,-1
8000339c:	5c 58       	castu.b	r8
8000339e:	b2 88       	st.b	r9[0x0],r8
800033a0:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800033a4:	a9 a8       	sbr	r8,0x8
800033a6:	b8 38       	st.h	r12[0x6],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.destination)
800033a8:	8c 49       	ld.sh	r9,r6[0x8]
800033aa:	3f f8       	mov	r8,-1
800033ac:	f0 09 19 00 	cp.h	r9,r8
800033b0:	c0 41       	brne	800033b8 <xnl_tx+0x34>
	{		
		/*Use actual Master address.*/
		xnl->xnl_header.destination = xnl_information.master_address;
800033b2:	4a 88       	lddpc	r8,80003450 <xnl_tx+0xcc>
800033b4:	90 18       	ld.sh	r8,r8[0x2]
800033b6:	ac 48       	st.h	r6[0x8],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.source)
800033b8:	8c 59       	ld.sh	r9,r6[0xa]
800033ba:	3f f8       	mov	r8,-1
800033bc:	f0 09 19 00 	cp.h	r9,r8
800033c0:	c0 41       	brne	800033c8 <xnl_tx+0x44>
	{
		/*Use Temporary address.*/	
		xnl->xnl_header.source = xnl_information.device_address;
800033c2:	4a 48       	lddpc	r8,80003450 <xnl_tx+0xcc>
800033c4:	90 28       	ld.sh	r8,r8[0x4]
800033c6:	ac 58       	st.h	r6[0xa],r8
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
800033c8:	8c 69       	ld.sh	r9,r6[0xc]
800033ca:	3f f8       	mov	r8,-1
800033cc:	f0 09 19 00 	cp.h	r9,r8
800033d0:	c0 e1       	brne	800033ec <xnl_tx+0x68>
	{		
		xnl->xnl_header.transaction_id = 
		  ((++xnl_information.transaction_id) & 0xFF) 
800033d2:	4a 08       	lddpc	r8,80003450 <xnl_tx+0xcc>
800033d4:	90 49       	ld.sh	r9,r8[0x8]
800033d6:	2f f9       	sub	r9,-1
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800033d8:	b0 49       	st.h	r8[0x8],r9
		  ((++xnl_information.transaction_id) & 0xFF) 
800033da:	90 4a       	ld.sh	r10,r8[0x8]
		xnl->xnl_header.source = xnl_information.device_address;
	}
	
	if(DEFAULT_VALUE == xnl->xnl_header.transaction_id)
	{		
		xnl->xnl_header.transaction_id = 
800033dc:	90 49       	ld.sh	r9,r8[0x8]
800033de:	e0 19 ff 00 	andl	r9,0xff00
800033e2:	f1 da c0 08 	bfextu	r8,r10,0x0,0x8
800033e6:	f3 e8 10 08 	or	r8,r9,r8
800033ea:	ac 68       	st.h	r6[0xc],r8
	U16  sumScratch;
	U32  indextohWord;
	S32  hWordswithinFrag;
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
800033ec:	0d 98       	ld.ub	r8,r6[0x1]
800033ee:	20 28       	sub	r8,2
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
800033f0:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
800033f4:	10 0c       	add	r12,r8
800033f6:	a1 5c       	asr	r12,0x1
	indextohWord = 2;
	while (hWordswithinFrag > 0)
800033f8:	58 0c       	cp.w	r12,0
800033fa:	e0 89 00 04 	brgt	80003402 <xnl_tx+0x7e>
800033fe:	30 09       	mov	r9,0
80003400:	c0 d8       	rjmp	8000341a <xnl_tx+0x96>
80003402:	ec ca ff fc 	sub	r10,r6,-4
Parameters: xnl_fragment_t * 
Description: send xnl(resend when timeout)
Calls: xQueueSend--freertos  
Called By: ...
*/
void xnl_tx(xnl_fragment_t * xnl)
80003406:	2f ec       	sub	r12,-2
80003408:	30 09       	mov	r9,0
8000340a:	30 28       	mov	r8,2
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
	{
		sumScratch += *((U16*)xnl + indextohWord);
8000340c:	15 1b       	ld.sh	r11,r10++
8000340e:	f6 09 00 09 	add	r9,r11,r9
80003412:	5c 89       	casts.h	r9
		indextohWord     += 1;
80003414:	2f f8       	sub	r8,-1
	
	sumScratch = 0;
	hWordswithinFrag = ((xnl->phy_header.phy_control) & 0x00FF) - 2;
	hWordswithinFrag =  (hWordswithinFrag + (hWordswithinFrag & 0x0001)) >> 1; 
	indextohWord = 2;
	while (hWordswithinFrag > 0)
80003416:	18 38       	cp.w	r8,r12
80003418:	cf a1       	brne	8000340c <xnl_tx+0x88>
		  ((++xnl_information.transaction_id) & 0xFF) 
		| (xnl_information.transaction_id & 0xFF00);
	}
	
	/*count check sum */
	xnl->phy_header.check_sum = check_sum( xnl );
8000341a:	5c 39       	neg	r9
8000341c:	ac 19       	st.h	r6[0x2],r9
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
8000341e:	48 e8       	lddpc	r8,80003454 <xnl_tx+0xd0>
80003420:	70 0c       	ld.w	r12,r8[0x0]
80003422:	f0 1f 00 0e 	mcall	80003458 <xnl_tx+0xd4>
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
80003426:	c1 00       	breq	80003446 <xnl_tx+0xc2>
	//log("op -%8x", xnl->xnl_header.opcode);
	
	//log("\n\r T_xnl:%4x \n\r", xnl->xnl_header.opcode);//log:T_xnl指令
	//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
	
	xnl_fragment_t * ptr = get_xnl_idle();//pvPortMalloc(sizeof(xnl_fragment_t));
80003428:	fa c7 ff fc 	sub	r7,sp,-4
8000342c:	0e dc       	st.w	--r7,r12
	//get_xnl_idle(&ptr);
	if(NULL != ptr)
	{
		memcpy(ptr, xnl, sizeof(xnl_fragment_t));
8000342e:	e0 6a 01 00 	mov	r10,256
80003432:	0c 9b       	mov	r11,r6
80003434:	f0 1f 00 0a 	mcall	8000345c <xnl_tx+0xd8>
	
		/*push to queue and send*/
		
		//log("ptr -%8x", ptr);
		
		xQueueSend(xnl_frame_tx, &ptr, 0);
80003438:	48 a8       	lddpc	r8,80003460 <xnl_tx+0xdc>
8000343a:	70 0c       	ld.w	r12,r8[0x0]
8000343c:	30 09       	mov	r9,0
8000343e:	12 9a       	mov	r10,r9
80003440:	1a 9b       	mov	r11,sp
80003442:	f0 1f 00 09 	mcall	80003464 <xnl_tx+0xe0>
		//log("\n\r T_xcmp:%4x \n\r", xnl->xnl_payload.xnl_content_data_msg.xcmp_opcode);
		
		//vPortFree(ptr);
	}
}
80003446:	2f fd       	sub	sp,-4
80003448:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000344c:	00 00       	add	r0,r0
8000344e:	0a 4c       	or	r12,r5
80003450:	00 00       	add	r0,r0
80003452:	0a 4e       	or	lr,r5
80003454:	00 00       	add	r0,r0
80003456:	0a 48       	or	r8,r5
80003458:	80 00       	ld.sh	r0,r0[0x0]
8000345a:	31 dc       	mov	r12,29
8000345c:	80 00       	ld.sh	r0,r0[0x0]
8000345e:	64 8a       	ld.w	r10,r2[0x20]
80003460:	00 00       	add	r0,r0
80003462:	0a 58       	eor	r8,r5
80003464:	80 00       	ld.sh	r0,r0[0x0]
80003466:	51 30       	stdsp	sp[0x4c],r0

80003468 <RC522_SPI_SetSpeed>:
	//SET_SPI_CS;

}

void RC522_SPI_SetSpeed(U16 SPI_BaudRatePrescaler)
{
80003468:	d4 01       	pushm	lr
	spi->csr0 = (spi->csr0 & (U16)0x00FF) |SPI_BaudRatePrescaler;
8000346a:	48 78       	lddpc	r8,80003484 <RC522_SPI_SetSpeed+0x1c>
8000346c:	70 09       	ld.w	r9,r8[0x0]
8000346e:	72 ca       	ld.w	r10,r9[0x30]
80003470:	5c 7c       	castu.h	r12
80003472:	f5 da c0 08 	bfextu	r10,r10,0x0,0x8
80003476:	f9 ea 10 0a 	or	r10,r12,r10
8000347a:	93 ca       	st.w	r9[0x30],r10

	spi_enable(spi); /*!< SD_SPI enable */
8000347c:	70 0c       	ld.w	r12,r8[0x0]
8000347e:	f0 1f 00 03 	mcall	80003488 <RC522_SPI_SetSpeed+0x20>
		
	
}
80003482:	d8 02       	popm	pc
80003484:	00 00       	add	r0,r0
80003486:	1f 70       	ld.ub	r0,--pc
80003488:	80 00       	ld.sh	r0,r0[0x0]
8000348a:	46 c0       	lddsp	r0,sp[0x1b0]

8000348c <RC522_SPI_SetSpeedLow>:
void RC522_SPI_SetSpeedLow(void)
{
8000348c:	d4 01       	pushm	lr
	RC522_SPI_SetSpeed(0x0400);//baudDiv=4
8000348e:	e0 6c 04 00 	mov	r12,1024
80003492:	f0 1f 00 02 	mcall	80003498 <RC522_SPI_SetSpeedLow+0xc>
	
}
80003496:	d8 02       	popm	pc
80003498:	80 00       	ld.sh	r0,r0[0x0]
8000349a:	34 68       	mov	r8,70

8000349c <RC522_ReadByte>:
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
U8 RC522_ReadByte(void)
{
8000349c:	eb cd 40 c0 	pushm	r6-r7,lr
	//蹇椤昏锋芥ｅ父璇诲
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */

	spi_write(spi,  0xFF);
800034a0:	48 76       	lddpc	r6,800034bc <RC522_ReadByte+0x20>
800034a2:	e0 6b 00 ff 	mov	r11,255
800034a6:	6c 0c       	ld.w	r12,r6[0x0]
800034a8:	f0 1f 00 06 	mcall	800034c0 <RC522_ReadByte+0x24>
	
	/*!< Return the byte read from the SPI bus */

	spi_read(spi, Data);
800034ac:	30 07       	mov	r7,0
800034ae:	0e 9b       	mov	r11,r7
800034b0:	6c 0c       	ld.w	r12,r6[0x0]
800034b2:	f0 1f 00 05 	mcall	800034c4 <RC522_ReadByte+0x28>
	
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	return (U8)(*Data);
	
}
800034b6:	0f 9c       	ld.ub	r12,r7[0x1]
800034b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800034bc:	00 00       	add	r0,r0
800034be:	1f 70       	ld.ub	r0,--pc
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	46 c6       	lddsp	r6,sp[0x1b0]
800034c4:	80 00       	ld.sh	r0,r0[0x0]
800034c6:	46 e2       	lddsp	r2,sp[0x1b8]

800034c8 <RC522_WriteByte>:


U8 rc522_init_failure =0;

U8 RC522_WriteByte(U8 Data)
{
800034c8:	eb cd 40 80 	pushm	r7,lr
800034cc:	20 1d       	sub	sp,4
800034ce:	ba 8c       	st.b	sp[0x0],r12
	U8 temp =0;
	
	//spi_selectChip(spi, DF_SPI_PCS_0);
	
	/*!< Send the byte */
	spi_write(spi,  (U16)Data);
800034d0:	48 77       	lddpc	r7,800034ec <RC522_WriteByte+0x24>
800034d2:	f7 dc c0 08 	bfextu	r11,r12,0x0,0x8
800034d6:	6e 0c       	ld.w	r12,r7[0x0]
800034d8:	f0 1f 00 06 	mcall	800034f0 <RC522_WriteByte+0x28>
	
	/*!< Wait to receive a byte*/

	temp = spi_read(spi, (U16*)&Data);
800034dc:	1a 9b       	mov	r11,sp
800034de:	6e 0c       	ld.w	r12,r7[0x0]
800034e0:	f0 1f 00 05 	mcall	800034f4 <RC522_WriteByte+0x2c>
	//spi_unselectChip(spi, DF_SPI_PCS_0);
	
	/*!< Return the byte read from the SPI bus */
	return  temp;

}
800034e4:	5c 5c       	castu.b	r12
800034e6:	2f fd       	sub	sp,-4
800034e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800034ec:	00 00       	add	r0,r0
800034ee:	1f 70       	ld.ub	r0,--pc
800034f0:	80 00       	ld.sh	r0,r0[0x0]
800034f2:	46 c6       	lddsp	r6,sp[0x1b0]
800034f4:	80 00       	ld.sh	r0,r0[0x0]
800034f6:	46 e2       	lddsp	r2,sp[0x1b8]

800034f8 <WriteRawRC>:
//    斤RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//          value[IN]:ョ
/////////////////////////////////////////////////////////////////////
void WriteRawRC(U8   Address, U8   value)
{
800034f8:	eb cd 40 e0 	pushm	r5-r7,lr
800034fc:	18 96       	mov	r6,r12
800034fe:	16 95       	mov	r5,r11
	U8   ucAddr;

	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
80003500:	48 a7       	lddpc	r7,80003528 <WriteRawRC+0x30>
80003502:	30 0b       	mov	r11,0
80003504:	6e 0c       	ld.w	r12,r7[0x0]
80003506:	f0 1f 00 0a 	mcall	8000352c <WriteRawRC+0x34>
	
	ucAddr = ((Address<<1)&0x7E);
	RC522_WriteByte(ucAddr);
8000350a:	ec 0c 15 01 	lsl	r12,r6,0x1
8000350e:	e2 1c 00 7e 	andl	r12,0x7e,COH
80003512:	f0 1f 00 08 	mcall	80003530 <WriteRawRC+0x38>
	RC522_WriteByte(value);
80003516:	0a 9c       	mov	r12,r5
80003518:	f0 1f 00 06 	mcall	80003530 <WriteRawRC+0x38>
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
8000351c:	30 0b       	mov	r11,0
8000351e:	6e 0c       	ld.w	r12,r7[0x0]
80003520:	f0 1f 00 05 	mcall	80003534 <WriteRawRC+0x3c>
	
	//SET_SPI_CS;

}
80003524:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003528:	00 00       	add	r0,r0
8000352a:	1f 70       	ld.ub	r0,--pc
8000352c:	80 00       	ld.sh	r0,r0[0x0]
8000352e:	48 2c       	lddpc	r12,80003534 <WriteRawRC+0x3c>
80003530:	80 00       	ld.sh	r0,r0[0x0]
80003532:	34 c8       	mov	r8,76
80003534:	80 00       	ld.sh	r0,r0[0x0]
80003536:	47 ec       	lddsp	r12,sp[0x1f8]

80003538 <PcdReset>:
/////////////////////////////////////////////////////////////////////
//    斤澶浣RC522
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdReset(void)
{
80003538:	d4 01       	pushm	lr

	SET_RC522RST;
8000353a:	31 9c       	mov	r12,25
8000353c:	f0 1f 00 1b 	mcall	800035a8 <PcdReset+0x70>
	delay_ns(10);
80003540:	30 ac       	mov	r12,10
80003542:	f0 1f 00 1b 	mcall	800035ac <PcdReset+0x74>

	CLR_RC522RST;
80003546:	31 9c       	mov	r12,25
80003548:	f0 1f 00 1a 	mcall	800035b0 <PcdReset+0x78>
	delay_ns(10);
8000354c:	30 ac       	mov	r12,10
8000354e:	f0 1f 00 18 	mcall	800035ac <PcdReset+0x74>

	SET_RC522RST;
80003552:	31 9c       	mov	r12,25
80003554:	f0 1f 00 15 	mcall	800035a8 <PcdReset+0x70>
	delay_ns(10);
80003558:	30 ac       	mov	r12,10
8000355a:	f0 1f 00 15 	mcall	800035ac <PcdReset+0x74>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
8000355e:	30 fb       	mov	r11,15
80003560:	30 1c       	mov	r12,1
80003562:	f0 1f 00 15 	mcall	800035b4 <PcdReset+0x7c>
	WriteRawRC(CommandReg,PCD_RESETPHASE);
80003566:	30 fb       	mov	r11,15
80003568:	30 1c       	mov	r12,1
8000356a:	f0 1f 00 13 	mcall	800035b4 <PcdReset+0x7c>
	delay_ns(10);
8000356e:	30 ac       	mov	r12,10
80003570:	f0 1f 00 0f 	mcall	800035ac <PcdReset+0x74>
	
	WriteRawRC(ModeReg,0x3D);            //Mifare￠璁锛CRC濮0x6363
80003574:	33 db       	mov	r11,61
80003576:	31 1c       	mov	r12,17
80003578:	f0 1f 00 0f 	mcall	800035b4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegL,30);
8000357c:	31 eb       	mov	r11,30
8000357e:	32 dc       	mov	r12,45
80003580:	f0 1f 00 0d 	mcall	800035b4 <PcdReset+0x7c>
	WriteRawRC(TReloadRegH,0);
80003584:	30 0b       	mov	r11,0
80003586:	32 cc       	mov	r12,44
80003588:	f0 1f 00 0b 	mcall	800035b4 <PcdReset+0x7c>
	WriteRawRC(TModeReg,0x8D);
8000358c:	e0 6b 00 8d 	mov	r11,141
80003590:	32 ac       	mov	r12,42
80003592:	f0 1f 00 09 	mcall	800035b4 <PcdReset+0x7c>
	WriteRawRC(TPrescalerReg,0x3E);
80003596:	33 eb       	mov	r11,62
80003598:	32 bc       	mov	r12,43
8000359a:	f0 1f 00 07 	mcall	800035b4 <PcdReset+0x7c>
	
	WriteRawRC(TxAutoReg,0x40);//蹇椤昏
8000359e:	34 0b       	mov	r11,64
800035a0:	31 5c       	mov	r12,21
800035a2:	f0 1f 00 05 	mcall	800035b4 <PcdReset+0x7c>
	
	return MI_OK;
}
800035a6:	d8 0a       	popm	pc,r12=0
800035a8:	80 00       	ld.sh	r0,r0[0x0]
800035aa:	42 34       	lddsp	r4,sp[0x8c]
800035ac:	80 00       	ld.sh	r0,r0[0x0]
800035ae:	3d f0       	mov	r0,-33
800035b0:	80 00       	ld.sh	r0,r0[0x0]
800035b2:	42 50       	lddsp	r0,sp[0x94]
800035b4:	80 00       	ld.sh	r0,r0[0x0]
800035b6:	34 f8       	mov	r8,79

800035b8 <ReadRawRC>:
//    斤璇RC632瀵瀛
//拌存锛Address[IN]:瀵瀛ㄥ板
//杩    锛璇诲虹
/////////////////////////////////////////////////////////////////////
U8 ReadRawRC(U8   Address)
{
800035b8:	eb cd 40 c0 	pushm	r6-r7,lr
800035bc:	18 96       	mov	r6,r12
	U8   ucAddr;
	U8   ucResult=0;
	//CLR_SPI_CS;	
	spi_selectChip(spi, DF_SPI_PCS_0);
800035be:	48 c7       	lddpc	r7,800035ec <ReadRawRC+0x34>
800035c0:	30 0b       	mov	r11,0
800035c2:	6e 0c       	ld.w	r12,r7[0x0]
800035c4:	f0 1f 00 0b 	mcall	800035f0 <ReadRawRC+0x38>
	 
	ucAddr = ((Address<<1)&0x7E)|0x80;
	
	RC522_WriteByte(ucAddr);
800035c8:	a1 76       	lsl	r6,0x1
800035ca:	0c 9c       	mov	r12,r6
800035cc:	e2 1c 00 7e 	andl	r12,0x7e,COH
800035d0:	a7 bc       	sbr	r12,0x7
800035d2:	f0 1f 00 09 	mcall	800035f4 <ReadRawRC+0x3c>
	ucResult = RC522_ReadByte();
800035d6:	f0 1f 00 09 	mcall	800035f8 <ReadRawRC+0x40>
800035da:	18 96       	mov	r6,r12
	
	spi_unselectChip(spi, DF_SPI_PCS_0);
800035dc:	30 0b       	mov	r11,0
800035de:	6e 0c       	ld.w	r12,r7[0x0]
800035e0:	f0 1f 00 07 	mcall	800035fc <ReadRawRC+0x44>
	//SET_SPI_CS;
	return ucResult;
}
800035e4:	0c 9c       	mov	r12,r6
800035e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800035ea:	00 00       	add	r0,r0
800035ec:	00 00       	add	r0,r0
800035ee:	1f 70       	ld.ub	r0,--pc
800035f0:	80 00       	ld.sh	r0,r0[0x0]
800035f2:	48 2c       	lddpc	r12,800035f8 <ReadRawRC+0x40>
800035f4:	80 00       	ld.sh	r0,r0[0x0]
800035f6:	34 c8       	mov	r8,76
800035f8:	80 00       	ld.sh	r0,r0[0x0]
800035fa:	34 9c       	mov	r12,73
800035fc:	80 00       	ld.sh	r0,r0[0x0]
800035fe:	47 ec       	lddsp	r12,sp[0x1f8]

80003600 <SetBitMask>:
//    斤缃RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//          mask[IN]:缃浣
/////////////////////////////////////////////////////////////////////
void SetBitMask(U8   reg,U8   mask)
{
80003600:	eb cd 40 c0 	pushm	r6-r7,lr
80003604:	18 97       	mov	r7,r12
80003606:	16 96       	mov	r6,r11
	char   tmp = 0x0;
	tmp = ReadRawRC(reg);
80003608:	f0 1f 00 05 	mcall	8000361c <SetBitMask+0x1c>
	WriteRawRC(reg,tmp | mask);  // set bit mask
8000360c:	f9 e6 10 0b 	or	r11,r12,r6
80003610:	5c 5b       	castu.b	r11
80003612:	0e 9c       	mov	r12,r7
80003614:	f0 1f 00 03 	mcall	80003620 <SetBitMask+0x20>
}
80003618:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000361c:	80 00       	ld.sh	r0,r0[0x0]
8000361e:	35 b8       	mov	r8,91
80003620:	80 00       	ld.sh	r0,r0[0x0]
80003622:	34 f8       	mov	r8,79

80003624 <PcdAntennaOn>:
/////////////////////////////////////////////////////////////////////
//寮澶╃嚎
//姣娆″ㄦ抽澶╅╁灏涔村冲1ms撮
/////////////////////////////////////////////////////////////////////
void PcdAntennaOn(void)
{
80003624:	d4 01       	pushm	lr
	U8   i;
	i = ReadRawRC(TxControlReg);
80003626:	31 4c       	mov	r12,20
80003628:	f0 1f 00 05 	mcall	8000363c <PcdAntennaOn+0x18>
	if (!(i & 0x03))
8000362c:	f9 dc c0 02 	bfextu	r12,r12,0x0,0x2
80003630:	c0 51       	brne	8000363a <PcdAntennaOn+0x16>
	{
		SetBitMask(TxControlReg, 0x03);
80003632:	30 3b       	mov	r11,3
80003634:	31 4c       	mov	r12,20
80003636:	f0 1f 00 03 	mcall	80003640 <PcdAntennaOn+0x1c>
8000363a:	d8 02       	popm	pc
8000363c:	80 00       	ld.sh	r0,r0[0x0]
8000363e:	35 b8       	mov	r8,91
80003640:	80 00       	ld.sh	r0,r0[0x0]
80003642:	36 00       	mov	r0,96

80003644 <ClearBitMask>:
//    斤娓RC522瀵瀛ㄤ
//拌存锛reg[IN]:瀵瀛ㄥ板
//         mask[IN]:娓浣
/////////////////////////////////////////////////////////////////////
void ClearBitMask(U8   reg,U8   mask)
{
80003644:	eb cd 40 c0 	pushm	r6-r7,lr
80003648:	18 97       	mov	r7,r12
8000364a:	16 96       	mov	r6,r11
	  char   tmp = 0x0;
	  tmp = ReadRawRC(reg);
8000364c:	f0 1f 00 06 	mcall	80003664 <ClearBitMask+0x20>
	  WriteRawRC(reg, tmp & ~mask);  // clear bit mask
80003650:	5c d6       	com	r6
80003652:	f9 e6 00 06 	and	r6,r12,r6
80003656:	f7 d6 c0 08 	bfextu	r11,r6,0x0,0x8
8000365a:	0e 9c       	mov	r12,r7
8000365c:	f0 1f 00 03 	mcall	80003668 <ClearBitMask+0x24>
	
}
80003660:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003664:	80 00       	ld.sh	r0,r0[0x0]
80003666:	35 b8       	mov	r8,91
80003668:	80 00       	ld.sh	r0,r0[0x0]
8000366a:	34 f8       	mov	r8,79

8000366c <PcdAntennaOff>:

/////////////////////////////////////////////////////////////////////
//抽澶╃嚎
/////////////////////////////////////////////////////////////////////
void PcdAntennaOff(void)
{
8000366c:	d4 01       	pushm	lr
	ClearBitMask(TxControlReg, 0x03);
8000366e:	30 3b       	mov	r11,3
80003670:	31 4c       	mov	r12,20
80003672:	f0 1f 00 02 	mcall	80003678 <PcdAntennaOff+0xc>
}
80003676:	d8 02       	popm	pc
80003678:	80 00       	ld.sh	r0,r0[0x0]
8000367a:	36 44       	mov	r4,100

8000367c <M500PcdConfigISOType>:

//////////////////////////////////////////////////////////////////////
//璁剧疆RC632宸ヤ瑰
//////////////////////////////////////////////////////////////////////
char M500PcdConfigISOType(U8   type)
{
8000367c:	d4 01       	pushm	lr
	if (type == 'A')                     //ISO14443_A
8000367e:	34 18       	mov	r8,65
80003680:	f0 0c 18 00 	cp.b	r12,r8
80003684:	c0 20       	breq	80003688 <M500PcdConfigISOType+0xc>
80003686:	da 0a       	popm	pc,r12=1
	{
		ClearBitMask(Status2Reg,0x08);
80003688:	30 8b       	mov	r11,8
8000368a:	16 9c       	mov	r12,r11
8000368c:	f0 1f 00 14 	mcall	800036dc <M500PcdConfigISOType+0x60>
		WriteRawRC(ModeReg,0x3D);//3F
80003690:	33 db       	mov	r11,61
80003692:	31 1c       	mov	r12,17
80003694:	f0 1f 00 13 	mcall	800036e0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RxSelReg,0x86);//84
80003698:	e0 6b 00 86 	mov	r11,134
8000369c:	31 7c       	mov	r12,23
8000369e:	f0 1f 00 11 	mcall	800036e0 <M500PcdConfigISOType+0x64>
		WriteRawRC(RFCfgReg,0x7F);   //4F
800036a2:	37 fb       	mov	r11,127
800036a4:	32 6c       	mov	r12,38
800036a6:	f0 1f 00 0f 	mcall	800036e0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegL,30);//tmoLength);// TReloadVal = 'h6a =tmoLength(dec)
800036aa:	31 eb       	mov	r11,30
800036ac:	32 dc       	mov	r12,45
800036ae:	f0 1f 00 0d 	mcall	800036e0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TReloadRegH,0);
800036b2:	30 0b       	mov	r11,0
800036b4:	32 cc       	mov	r12,44
800036b6:	f0 1f 00 0b 	mcall	800036e0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TModeReg,0x8D);
800036ba:	e0 6b 00 8d 	mov	r11,141
800036be:	32 ac       	mov	r12,42
800036c0:	f0 1f 00 08 	mcall	800036e0 <M500PcdConfigISOType+0x64>
		WriteRawRC(TPrescalerReg,0x3E);
800036c4:	33 eb       	mov	r11,62
800036c6:	32 bc       	mov	r12,43
800036c8:	f0 1f 00 06 	mcall	800036e0 <M500PcdConfigISOType+0x64>
		delay_ns(1000);
800036cc:	e0 6c 03 e8 	mov	r12,1000
800036d0:	f0 1f 00 05 	mcall	800036e4 <M500PcdConfigISOType+0x68>
		PcdAntennaOn();
800036d4:	f0 1f 00 05 	mcall	800036e8 <M500PcdConfigISOType+0x6c>
800036d8:	d8 0a       	popm	pc,r12=0
800036da:	00 00       	add	r0,r0
800036dc:	80 00       	ld.sh	r0,r0[0x0]
800036de:	36 44       	mov	r4,100
800036e0:	80 00       	ld.sh	r0,r0[0x0]
800036e2:	34 f8       	mov	r8,79
800036e4:	80 00       	ld.sh	r0,r0[0x0]
800036e6:	3d f0       	mov	r0,-33
800036e8:	80 00       	ld.sh	r0,r0[0x0]
800036ea:	36 24       	mov	r4,98

800036ec <rc522_init>:


//mfrc522 init

void rc522_init()
{
800036ec:	eb cd 40 c0 	pushm	r6-r7,lr
800036f0:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
800036f2:	4a 28       	lddpc	r8,80003778 <rc522_init+0x8c>
800036f4:	1a 96       	mov	r6,sp
800036f6:	f0 ea 00 00 	ld.d	r10,r8[0]
800036fa:	fa eb 00 00 	st.d	sp[0],r10
800036fe:	f0 e8 00 08 	ld.d	r8,r8[8]
80003702:	fa e9 00 08 	st.d	sp[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(RC522_SPI_GPIO_MAP, sizeof(RC522_SPI_GPIO_MAP) / sizeof(RC522_SPI_GPIO_MAP[0]));
80003706:	30 1b       	mov	r11,1
80003708:	49 dc       	lddpc	r12,8000377c <rc522_init+0x90>
8000370a:	f0 1f 00 1e 	mcall	80003780 <rc522_init+0x94>

	// Configure PA25 as RST pin
	gpio_enable_gpio_pin(AVR32_PIN_PA25);
8000370e:	31 9c       	mov	r12,25
80003710:	f0 1f 00 1d 	mcall	80003784 <rc522_init+0x98>
	gpio_set_gpio_pin(AVR32_PIN_PA25);
80003714:	31 9c       	mov	r12,25
80003716:	f0 1f 00 1d 	mcall	80003788 <rc522_init+0x9c>
	
	//gpio_enable_gpio_pin(AVR32_PIN_PA24);

	spi = &AVR32_SPI;
8000371a:	49 d7       	lddpc	r7,8000378c <rc522_init+0xa0>
8000371c:	fe 7c 24 00 	mov	r12,-56320
80003720:	8f 0c       	st.w	r7[0x0],r12

	// Initialize as master.
	spi_initMaster(spi, &spiOptions);
80003722:	1a 9b       	mov	r11,sp
80003724:	f0 1f 00 1b 	mcall	80003790 <rc522_init+0xa4>

	// Set selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(spi, 0, 0, 0);
80003728:	30 09       	mov	r9,0
8000372a:	12 9a       	mov	r10,r9
8000372c:	12 9b       	mov	r11,r9
8000372e:	6e 0c       	ld.w	r12,r7[0x0]
80003730:	f0 1f 00 19 	mcall	80003794 <rc522_init+0xa8>

	// Enable SPI.
	spi_enable(spi);
80003734:	6e 0c       	ld.w	r12,r7[0x0]
80003736:	f0 1f 00 19 	mcall	80003798 <rc522_init+0xac>

	// Initialize RC522 with SPI clock PBA.
	if (spi_setupChipReg(spi, &spiOptions, 2*12000000) != SPI_OK)
8000373a:	e0 6a 36 00 	mov	r10,13824
8000373e:	ea 1a 01 6e 	orh	r10,0x16e
80003742:	1a 9b       	mov	r11,sp
80003744:	6e 0c       	ld.w	r12,r7[0x0]
80003746:	f0 1f 00 16 	mcall	8000379c <rc522_init+0xb0>
8000374a:	c0 50       	breq	80003754 <rc522_init+0x68>
	{
		
		rc522_init_failure = FATAL_ERROR_RC522_SPI_INIT;
8000374c:	30 29       	mov	r9,2
8000374e:	49 58       	lddpc	r8,800037a0 <rc522_init+0xb4>
80003750:	b0 89       	st.b	r8[0x0],r9
80003752:	c0 38       	rjmp	80003758 <rc522_init+0x6c>
		return;
	}
	
	RC522_SPI_SetSpeedLow();
80003754:	f0 1f 00 14 	mcall	800037a4 <rc522_init+0xb8>
void rc522_init()
{
	
	spi_init();
	
	PcdReset();
80003758:	f0 1f 00 14 	mcall	800037a8 <rc522_init+0xbc>
	
	PcdAntennaOff();
8000375c:	f0 1f 00 14 	mcall	800037ac <rc522_init+0xc0>
	
	delay_ms(2); 
80003760:	30 2c       	mov	r12,2
80003762:	f0 1f 00 14 	mcall	800037b0 <rc522_init+0xc4>
	
	PcdAntennaOn();
80003766:	f0 1f 00 14 	mcall	800037b4 <rc522_init+0xc8>
	
	M500PcdConfigISOType( 'A' );
8000376a:	34 1c       	mov	r12,65
8000376c:	f0 1f 00 13 	mcall	800037b8 <rc522_init+0xcc>
	

80003770:	2f cd       	sub	sp,-16
80003772:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003776:	00 00       	add	r0,r0
80003778:	80 00       	ld.sh	r0,r0[0x0]
8000377a:	c3 9c       	rcall	800037ec <PcdComMF522+0x30>
8000377c:	80 00       	ld.sh	r0,r0[0x0]
8000377e:	c3 94       	brge	800037f0 <PcdComMF522+0x34>
80003780:	80 00       	ld.sh	r0,r0[0x0]
80003782:	41 ec       	lddsp	r12,sp[0x78]
80003784:	80 00       	ld.sh	r0,r0[0x0]
80003786:	42 1c       	lddsp	r12,sp[0x84]
80003788:	80 00       	ld.sh	r0,r0[0x0]
8000378a:	42 34       	lddsp	r4,sp[0x8c]
8000378c:	00 00       	add	r0,r0
8000378e:	1f 70       	ld.ub	r0,--pc
80003790:	80 00       	ld.sh	r0,r0[0x0]
80003792:	46 5c       	lddsp	r12,sp[0x194]
80003794:	80 00       	ld.sh	r0,r0[0x0]
80003796:	46 94       	lddsp	r4,sp[0x1a4]
80003798:	80 00       	ld.sh	r0,r0[0x0]
8000379a:	46 c0       	lddsp	r0,sp[0x1b0]
8000379c:	80 00       	ld.sh	r0,r0[0x0]
8000379e:	47 04       	lddsp	r4,sp[0x1c0]
800037a0:	00 00       	add	r0,r0
800037a2:	0a 5c       	eor	r12,r5
800037a4:	80 00       	ld.sh	r0,r0[0x0]
800037a6:	34 8c       	mov	r12,72
800037a8:	80 00       	ld.sh	r0,r0[0x0]
800037aa:	35 38       	mov	r8,83
800037ac:	80 00       	ld.sh	r0,r0[0x0]
800037ae:	36 6c       	mov	r12,102
800037b0:	80 00       	ld.sh	r0,r0[0x0]
800037b2:	3e 30       	mov	r0,-29
800037b4:	80 00       	ld.sh	r0,r0[0x0]
800037b6:	36 24       	mov	r4,98
800037b8:	80 00       	ld.sh	r0,r0[0x0]
800037ba:	36 7c       	mov	r12,103

800037bc <PcdComMF522>:
char PcdComMF522(U8  Command,
				 U8 *pIn ,
				 U8  InLenByte,
				 U8 *pOut ,
				 U8 *pOutLenBit)
{
800037bc:	d4 31       	pushm	r0-r7,lr
800037be:	20 1d       	sub	sp,4
800037c0:	18 92       	mov	r2,r12
800037c2:	16 95       	mov	r5,r11
800037c4:	14 96       	mov	r6,r10
800037c6:	50 09       	stdsp	sp[0x0],r9
800037c8:	10 90       	mov	r0,r8
800037ca:	f8 c8 00 0c 	sub	r8,r12,12
800037ce:	5c 58       	castu.b	r8
800037d0:	30 29       	mov	r9,2
800037d2:	f2 08 18 00 	cp.b	r8,r9
800037d6:	e0 88 00 05 	brls	800037e0 <PcdComMF522+0x24>
800037da:	30 03       	mov	r3,0
800037dc:	06 91       	mov	r1,r3
800037de:	c0 78       	rjmp	800037ec <PcdComMF522+0x30>
800037e0:	4c f9       	lddpc	r9,8000391c <PcdComMF522+0x160>
800037e2:	f2 08 07 01 	ld.ub	r1,r9[r8]
800037e6:	4c f9       	lddpc	r9,80003920 <PcdComMF522+0x164>
800037e8:	f2 08 07 03 	ld.ub	r3,r9[r8]
		break;
		default:
		break;
	}
	
	WriteRawRC(ComIEnReg,irqEn|0x80);
800037ec:	02 9b       	mov	r11,r1
800037ee:	a7 bb       	sbr	r11,0x7
800037f0:	30 2c       	mov	r12,2
800037f2:	f0 1f 00 4d 	mcall	80003924 <PcdComMF522+0x168>
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
800037f6:	e0 6b 00 80 	mov	r11,128
800037fa:	30 4c       	mov	r12,4
800037fc:	f0 1f 00 4b 	mcall	80003928 <PcdComMF522+0x16c>
	WriteRawRC(CommandReg,PCD_IDLE);
80003800:	30 0b       	mov	r11,0
80003802:	30 1c       	mov	r12,1
80003804:	f0 1f 00 48 	mcall	80003924 <PcdComMF522+0x168>
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
80003808:	e0 6b 00 80 	mov	r11,128
8000380c:	30 ac       	mov	r12,10
8000380e:	f0 1f 00 48 	mcall	8000392c <PcdComMF522+0x170>
	
	for (i=0; i<InLenByte; i++)
80003812:	58 06       	cp.w	r6,0
80003814:	c0 c0       	breq	8000382c <PcdComMF522+0x70>
80003816:	0a 97       	mov	r7,r5
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
80003818:	30 94       	mov	r4,9
8000381a:	0f 3b       	ld.ub	r11,r7++
8000381c:	08 9c       	mov	r12,r4
8000381e:	f0 1f 00 42 	mcall	80003924 <PcdComMF522+0x168>
	WriteRawRC(ComIEnReg,irqEn|0x80);
	ClearBitMask(ComIrqReg,0x80);	//娓涓浣
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);	 	//娓FIFO缂瀛
	
	for (i=0; i<InLenByte; i++)
80003822:	0e 98       	mov	r8,r7
80003824:	0a 18       	sub	r8,r5
80003826:	ec 08 19 00 	cp.h	r8,r6
8000382a:	cf 83       	brcs	8000381a <PcdComMF522+0x5e>
	{   
		WriteRawRC(FIFODataReg, pIn [i]);
	}
	WriteRawRC(CommandReg, Command);
8000382c:	04 9b       	mov	r11,r2
8000382e:	30 1c       	mov	r12,1
80003830:	f0 1f 00 3d 	mcall	80003924 <PcdComMF522+0x168>
	
	if (Command == PCD_TRANSCEIVE)
80003834:	30 c8       	mov	r8,12
80003836:	f0 02 18 00 	cp.b	r2,r8
8000383a:	c0 61       	brne	80003846 <PcdComMF522+0x8a>
	{    
		SetBitMask(BitFramingReg,0x80);  
8000383c:	e0 6b 00 80 	mov	r11,128
80003840:	30 dc       	mov	r12,13
80003842:	f0 1f 00 3b 	mcall	8000392c <PcdComMF522+0x170>
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80003846:	30 4c       	mov	r12,4
80003848:	f0 1f 00 3a 	mcall	80003930 <PcdComMF522+0x174>
8000384c:	18 97       	mov	r7,r12
8000384e:	e0 66 07 cf 	mov	r6,1999
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80003852:	30 05       	mov	r5,0
	
	//i = 600;//规堕棰璋达浣M1℃澶х寰堕25ms
	i = 2000;
	do
	{
		n = ReadRawRC(ComIrqReg);
80003854:	30 44       	mov	r4,4
80003856:	c0 88       	rjmp	80003866 <PcdComMF522+0xaa>
80003858:	08 9c       	mov	r12,r4
8000385a:	f0 1f 00 36 	mcall	80003930 <PcdComMF522+0x174>
8000385e:	18 97       	mov	r7,r12
		i--;
80003860:	20 16       	sub	r6,1
80003862:	5c 86       	casts.h	r6
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
80003864:	c0 a0       	breq	80003878 <PcdComMF522+0xbc>
80003866:	f1 d7 c0 01 	bfextu	r8,r7,0x0,0x1
8000386a:	c4 c1       	brne	80003902 <PcdComMF522+0x146>
8000386c:	ef e3 00 08 	and	r8,r7,r3
80003870:	ea 08 18 00 	cp.b	r8,r5
80003874:	cf 20       	breq	80003858 <PcdComMF522+0x9c>
80003876:	c4 68       	rjmp	80003902 <PcdComMF522+0x146>
	ClearBitMask(BitFramingReg,0x80);
80003878:	e0 6b 00 80 	mov	r11,128
8000387c:	30 dc       	mov	r12,13
8000387e:	f0 1f 00 2b 	mcall	80003928 <PcdComMF522+0x16c>
80003882:	30 27       	mov	r7,2
80003884:	c3 38       	rjmp	800038ea <PcdComMF522+0x12e>
80003886:	02 67       	and	r7,r1
80003888:	ef d7 c0 01 	bfextu	r7,r7,0x0,0x1
		if(!(ReadRawRC(ErrorReg)&0x1B))
		{
			status = MI_OK;
			if (n & irqEn & 0x01)
			{   status = MI_NOTAGERR;   }
			if (Command == PCD_TRANSCEIVE)
8000388c:	30 c8       	mov	r8,12
8000388e:	f0 02 18 00 	cp.b	r2,r8
80003892:	c2 c1       	brne	800038ea <PcdComMF522+0x12e>
			{
				n = ReadRawRC(FIFOLevelReg);
80003894:	30 ac       	mov	r12,10
80003896:	f0 1f 00 27 	mcall	80003930 <PcdComMF522+0x174>
8000389a:	18 94       	mov	r4,r12
				lastBits = ReadRawRC(ControlReg) & 0x07;
8000389c:	30 cc       	mov	r12,12
8000389e:	f0 1f 00 25 	mcall	80003930 <PcdComMF522+0x174>
800038a2:	f9 dc c0 03 	bfextu	r12,r12,0x0,0x3
				if (lastBits)
800038a6:	c0 70       	breq	800038b4 <PcdComMF522+0xf8>
				{   *pOutLenBit = (n-1)*8 + lastBits;   }
800038a8:	08 98       	mov	r8,r4
800038aa:	20 18       	sub	r8,1
800038ac:	f8 08 00 3c 	add	r12,r12,r8<<0x3
800038b0:	a0 8c       	st.b	r0[0x0],r12
800038b2:	c0 48       	rjmp	800038ba <PcdComMF522+0xfe>
				else
				{   *pOutLenBit = n*8;   }
800038b4:	e8 08 15 03 	lsl	r8,r4,0x3
800038b8:	a0 88       	st.b	r0[0x0],r8
				if (n == 0)
800038ba:	58 04       	cp.w	r4,0
800038bc:	c0 61       	brne	800038c8 <PcdComMF522+0x10c>
800038be:	30 14       	mov	r4,1
800038c0:	40 05       	lddsp	r5,sp[0x0]
800038c2:	0a 96       	mov	r6,r5
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
800038c4:	30 93       	mov	r3,9
800038c6:	c0 98       	rjmp	800038d8 <PcdComMF522+0x11c>
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
800038c8:	31 28       	mov	r8,18
800038ca:	f0 04 18 00 	cp.b	r4,r8
800038ce:	f9 b4 0b 12 	movhi	r4,18
800038d2:	58 04       	cp.w	r4,0
800038d4:	cf 61       	brne	800038c0 <PcdComMF522+0x104>
800038d6:	c0 a8       	rjmp	800038ea <PcdComMF522+0x12e>
				{   pOut [i] = ReadRawRC(FIFODataReg);    }
800038d8:	06 9c       	mov	r12,r3
800038da:	f0 1f 00 16 	mcall	80003930 <PcdComMF522+0x174>
800038de:	0c cc       	st.b	r6++,r12
				{   *pOutLenBit = n*8;   }
				if (n == 0)
				{   n = 1;    }
				if (n > MAXRLEN)
				{   n = MAXRLEN;   }
				for (i=0; i<n; i++)
800038e0:	ec 05 01 08 	sub	r8,r6,r5
800038e4:	e8 08 19 00 	cp.h	r8,r4
800038e8:	cf 83       	brcs	800038d8 <PcdComMF522+0x11c>
		{   status = MI_ERR;   }
		
	}
	

	SetBitMask(ControlReg,0x80);           // stop timer now
800038ea:	e0 6b 00 80 	mov	r11,128
800038ee:	30 cc       	mov	r12,12
800038f0:	f0 1f 00 0f 	mcall	8000392c <PcdComMF522+0x170>
	WriteRawRC(CommandReg,PCD_IDLE);
800038f4:	30 0b       	mov	r11,0
800038f6:	30 1c       	mov	r12,1
800038f8:	f0 1f 00 0b 	mcall	80003924 <PcdComMF522+0x168>
	return status;
}
800038fc:	0e 9c       	mov	r12,r7
800038fe:	2f fd       	sub	sp,-4
80003900:	d8 32       	popm	r0-r7,pc
	{
		n = ReadRawRC(ComIrqReg);
		i--;
	}
	while ((i!=0) && !(n&0x01) && !(n&waitFor));
	ClearBitMask(BitFramingReg,0x80);
80003902:	e0 6b 00 80 	mov	r11,128
80003906:	30 dc       	mov	r12,13
80003908:	f0 1f 00 08 	mcall	80003928 <PcdComMF522+0x16c>

	if (i!=0)
	{
		if(!(ReadRawRC(ErrorReg)&0x1B))
8000390c:	30 6c       	mov	r12,6
8000390e:	f0 1f 00 09 	mcall	80003930 <PcdComMF522+0x174>
80003912:	e2 1c 00 1b 	andl	r12,0x1b,COH
80003916:	cb 80       	breq	80003886 <PcdComMF522+0xca>
80003918:	30 27       	mov	r7,2
8000391a:	ce 8b       	rjmp	800038ea <PcdComMF522+0x12e>
8000391c:	80 00       	ld.sh	r0,r0[0x0]
8000391e:	c3 ac       	rcall	80003992 <PcdAnticoll+0x5e>
80003920:	80 00       	ld.sh	r0,r0[0x0]
80003922:	c3 90       	breq	80003994 <PcdAnticoll+0x60>
80003924:	80 00       	ld.sh	r0,r0[0x0]
80003926:	34 f8       	mov	r8,79
80003928:	80 00       	ld.sh	r0,r0[0x0]
8000392a:	36 44       	mov	r4,100
8000392c:	80 00       	ld.sh	r0,r0[0x0]
8000392e:	36 00       	mov	r0,96
80003930:	80 00       	ld.sh	r0,r0[0x0]
80003932:	35 b8       	mov	r8,91

80003934 <PcdAnticoll>:
//    斤插叉
//拌存: pSnr[OUT]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdAnticoll(U8 *pSnr)
{
80003934:	eb cd 40 c0 	pushm	r6-r7,lr
80003938:	20 5d       	sub	sp,20
8000393a:	18 96       	mov	r6,r12
	U8   i,snr_check=0;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	

	ClearBitMask(Status2Reg,0x08);
8000393c:	30 8b       	mov	r11,8
8000393e:	16 9c       	mov	r12,r11
80003940:	f0 1f 00 1a 	mcall	800039a8 <PcdAnticoll+0x74>
	WriteRawRC(BitFramingReg,0x00);
80003944:	30 0b       	mov	r11,0
80003946:	30 dc       	mov	r12,13
80003948:	f0 1f 00 19 	mcall	800039ac <PcdAnticoll+0x78>
	ClearBitMask(CollReg,0x80);
8000394c:	e0 6b 00 80 	mov	r11,128
80003950:	30 ec       	mov	r12,14
80003952:	f0 1f 00 16 	mcall	800039a8 <PcdAnticoll+0x74>
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80003956:	39 38       	mov	r8,-109
80003958:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x20;
8000395a:	32 08       	mov	r8,32
8000395c:	ba 98       	st.b	sp[0x1],r8

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,2,ucComMF522Buf,&unLen);
8000395e:	1a 9b       	mov	r11,sp
80003960:	fa c8 ff ed 	sub	r8,sp,-19
80003964:	1a 99       	mov	r9,sp
80003966:	30 2a       	mov	r10,2
80003968:	30 cc       	mov	r12,12
8000396a:	f0 1f 00 12 	mcall	800039b0 <PcdAnticoll+0x7c>
8000396e:	18 97       	mov	r7,r12

	if (status == MI_OK)
80003970:	c1 21       	brne	80003994 <PcdAnticoll+0x60>
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80003972:	1b 89       	ld.ub	r9,sp[0x0]
80003974:	ac 89       	st.b	r6[0x0],r9
80003976:	1b 98       	ld.ub	r8,sp[0x1]
80003978:	ac 98       	st.b	r6[0x1],r8
			snr_check ^= ucComMF522Buf[i];
8000397a:	10 59       	eor	r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
8000397c:	1b a8       	ld.ub	r8,sp[0x2]
8000397e:	ac a8       	st.b	r6[0x2],r8
			snr_check ^= ucComMF522Buf[i];
80003980:	f3 e8 20 08 	eor	r8,r9,r8

	if (status == MI_OK)
	{
		for (i=0; i<4; i++)
		{
			*(pSnr+i)  = ucComMF522Buf[i];
80003984:	1b b9       	ld.ub	r9,sp[0x3]
80003986:	ac b9       	st.b	r6[0x3],r9
			snr_check ^= ucComMF522Buf[i];
80003988:	12 58       	eor	r8,r9
		}
		if (snr_check != ucComMF522Buf[i])
8000398a:	1b c9       	ld.ub	r9,sp[0x4]
8000398c:	f0 09 18 00 	cp.b	r9,r8
80003990:	f9 b7 01 02 	movne	r7,2
		{   status = MI_ERR;    }
	}
	
	SetBitMask(CollReg,0x80);
80003994:	e0 6b 00 80 	mov	r11,128
80003998:	30 ec       	mov	r12,14
8000399a:	f0 1f 00 07 	mcall	800039b4 <PcdAnticoll+0x80>
	return status;
}
8000399e:	0e 9c       	mov	r12,r7
800039a0:	2f bd       	sub	sp,-20
800039a2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800039a6:	00 00       	add	r0,r0
800039a8:	80 00       	ld.sh	r0,r0[0x0]
800039aa:	36 44       	mov	r4,100
800039ac:	80 00       	ld.sh	r0,r0[0x0]
800039ae:	34 f8       	mov	r8,79
800039b0:	80 00       	ld.sh	r0,r0[0x0]
800039b2:	37 bc       	mov	r12,123
800039b4:	80 00       	ld.sh	r0,r0[0x0]
800039b6:	36 00       	mov	r0,96

800039b8 <PcdRequest>:
//                0x0800 = Mifare_Pro(X)
//                0x4403 = Mifare_DESFire
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdRequest(U8   req_code,U8 *pTagType)
{
800039b8:	eb cd 40 c0 	pushm	r6-r7,lr
800039bc:	20 5d       	sub	sp,20
800039be:	18 97       	mov	r7,r12
800039c0:	16 96       	mov	r6,r11
	char   status;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];

	ClearBitMask(Status2Reg,0x08);
800039c2:	30 8b       	mov	r11,8
800039c4:	16 9c       	mov	r12,r11
800039c6:	f0 1f 00 12 	mcall	80003a0c <PcdRequest+0x54>
	WriteRawRC(BitFramingReg,0x07);
800039ca:	30 7b       	mov	r11,7
800039cc:	30 dc       	mov	r12,13
800039ce:	f0 1f 00 11 	mcall	80003a10 <PcdRequest+0x58>
	SetBitMask(TxControlReg,0x03);
800039d2:	30 3b       	mov	r11,3
800039d4:	31 4c       	mov	r12,20
800039d6:	f0 1f 00 10 	mcall	80003a14 <PcdRequest+0x5c>
	
	ucComMF522Buf[0] = req_code;
800039da:	ba 87       	st.b	sp[0x0],r7

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);
800039dc:	1a 9b       	mov	r11,sp
800039de:	fa c8 ff ed 	sub	r8,sp,-19
800039e2:	1a 99       	mov	r9,sp
800039e4:	30 1a       	mov	r10,1
800039e6:	30 cc       	mov	r12,12
800039e8:	f0 1f 00 0c 	mcall	80003a18 <PcdRequest+0x60>

	if ((status == MI_OK) && (unLen == 0x10))
800039ec:	c0 c1       	brne	80003a04 <PcdRequest+0x4c>
800039ee:	31 08       	mov	r8,16
800039f0:	fb 39 00 13 	ld.ub	r9,sp[19]
800039f4:	f0 09 18 00 	cp.b	r9,r8
800039f8:	c0 61       	brne	80003a04 <PcdRequest+0x4c>
	{
		*pTagType     = ucComMF522Buf[0];
800039fa:	1b 88       	ld.ub	r8,sp[0x0]
800039fc:	ac 88       	st.b	r6[0x0],r8
		*(pTagType+1) = ucComMF522Buf[1];
800039fe:	1b 98       	ld.ub	r8,sp[0x1]
80003a00:	ac 98       	st.b	r6[0x1],r8
	
	ucComMF522Buf[0] = req_code;

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,1,ucComMF522Buf,&unLen);

	if ((status == MI_OK) && (unLen == 0x10))
80003a02:	c0 28       	rjmp	80003a06 <PcdRequest+0x4e>
80003a04:	30 2c       	mov	r12,2
	}
	else
	{   status = MI_ERR;   }
	
	return status;
}
80003a06:	2f bd       	sub	sp,-20
80003a08:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003a0c:	80 00       	ld.sh	r0,r0[0x0]
80003a0e:	36 44       	mov	r4,100
80003a10:	80 00       	ld.sh	r0,r0[0x0]
80003a12:	34 f8       	mov	r8,79
80003a14:	80 00       	ld.sh	r0,r0[0x0]
80003a16:	36 00       	mov	r0,96
80003a18:	80 00       	ld.sh	r0,r0[0x0]
80003a1a:	37 bc       	mov	r12,123

80003a1c <CalulateCRC>:

/////////////////////////////////////////////////////////////////////
//MF522璁＄CRC16芥
/////////////////////////////////////////////////////////////////////
void CalulateCRC(U8 *pIn ,U8   len,U8 *pOut )
{
80003a1c:	eb cd 40 f8 	pushm	r3-r7,lr
80003a20:	18 95       	mov	r5,r12
80003a22:	16 96       	mov	r6,r11
80003a24:	14 93       	mov	r3,r10
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
80003a26:	30 4b       	mov	r11,4
80003a28:	30 5c       	mov	r12,5
80003a2a:	f0 1f 00 1c 	mcall	80003a98 <CalulateCRC+0x7c>
	WriteRawRC(CommandReg,PCD_IDLE);
80003a2e:	30 0b       	mov	r11,0
80003a30:	30 1c       	mov	r12,1
80003a32:	f0 1f 00 1b 	mcall	80003a9c <CalulateCRC+0x80>
	SetBitMask(FIFOLevelReg,0x80);
80003a36:	e0 6b 00 80 	mov	r11,128
80003a3a:	30 ac       	mov	r12,10
80003a3c:	f0 1f 00 19 	mcall	80003aa0 <CalulateCRC+0x84>
	for (i=0; i<len; i++)
80003a40:	58 06       	cp.w	r6,0
80003a42:	c0 c0       	breq	80003a5a <CalulateCRC+0x3e>
80003a44:	0a 97       	mov	r7,r5
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
80003a46:	30 94       	mov	r4,9
80003a48:	0f 3b       	ld.ub	r11,r7++
80003a4a:	08 9c       	mov	r12,r4
80003a4c:	f0 1f 00 14 	mcall	80003a9c <CalulateCRC+0x80>
{
	U8   i,n;
	ClearBitMask(DivIrqReg,0x04);
	WriteRawRC(CommandReg,PCD_IDLE);
	SetBitMask(FIFOLevelReg,0x80);
	for (i=0; i<len; i++)
80003a50:	0e 98       	mov	r8,r7
80003a52:	0a 18       	sub	r8,r5
80003a54:	ec 08 18 00 	cp.b	r8,r6
80003a58:	cf 83       	brcs	80003a48 <CalulateCRC+0x2c>
	{   WriteRawRC(FIFODataReg, *(pIn +i));   }
	WriteRawRC(CommandReg, PCD_CALCCRC);
80003a5a:	30 3b       	mov	r11,3
80003a5c:	30 1c       	mov	r12,1
80003a5e:	f0 1f 00 10 	mcall	80003a9c <CalulateCRC+0x80>
	i = 0xFF;
	do
	{
		n = ReadRawRC(DivIrqReg);
80003a62:	30 5c       	mov	r12,5
80003a64:	f0 1f 00 10 	mcall	80003aa4 <CalulateCRC+0x88>
80003a68:	e0 67 00 fe 	mov	r7,254
80003a6c:	30 56       	mov	r6,5
80003a6e:	c0 78       	rjmp	80003a7c <CalulateCRC+0x60>
80003a70:	0c 9c       	mov	r12,r6
80003a72:	f0 1f 00 0d 	mcall	80003aa4 <CalulateCRC+0x88>
		i--;
80003a76:	20 17       	sub	r7,1
80003a78:	5c 57       	castu.b	r7
	}
	while ((i!=0) && !(n&0x04));
80003a7a:	c0 40       	breq	80003a82 <CalulateCRC+0x66>
80003a7c:	e2 1c 00 04 	andl	r12,0x4,COH
80003a80:	cf 80       	breq	80003a70 <CalulateCRC+0x54>
	pOut [0] = ReadRawRC(CRCResultRegL);
80003a82:	32 2c       	mov	r12,34
80003a84:	f0 1f 00 08 	mcall	80003aa4 <CalulateCRC+0x88>
80003a88:	a6 8c       	st.b	r3[0x0],r12
	pOut [1] = ReadRawRC(CRCResultRegM);
80003a8a:	32 1c       	mov	r12,33
80003a8c:	f0 1f 00 06 	mcall	80003aa4 <CalulateCRC+0x88>
80003a90:	a6 9c       	st.b	r3[0x1],r12
}
80003a92:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003a96:	00 00       	add	r0,r0
80003a98:	80 00       	ld.sh	r0,r0[0x0]
80003a9a:	36 44       	mov	r4,100
80003a9c:	80 00       	ld.sh	r0,r0[0x0]
80003a9e:	34 f8       	mov	r8,79
80003aa0:	80 00       	ld.sh	r0,r0[0x0]
80003aa2:	36 00       	mov	r0,96
80003aa4:	80 00       	ld.sh	r0,r0[0x0]
80003aa6:	35 b8       	mov	r8,91

80003aa8 <PcdSelect>:
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
{
80003aa8:	eb cd 40 80 	pushm	r7,lr
80003aac:	20 5d       	sub	sp,20
	char   status;
	U8   i;
	U8   unLen;
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
80003aae:	39 38       	mov	r8,-109
80003ab0:	ba 88       	st.b	sp[0x0],r8
	ucComMF522Buf[1] = 0x70;
80003ab2:	37 08       	mov	r8,112
80003ab4:	ba 98       	st.b	sp[0x1],r8
	ucComMF522Buf[6] = 0;
80003ab6:	30 08       	mov	r8,0
80003ab8:	ba e8       	st.b	sp[0x6],r8
80003aba:	fa c8 ff fe 	sub	r8,sp,-2
/////////////////////////////////////////////////////////////////////
//    斤瀹＄
//拌存: pSnr[IN]:＄搴凤4瀛
//杩    : 杩MI_OK
/////////////////////////////////////////////////////////////////////
char PcdSelect(U8 *pSnr)
80003abe:	fa cb ff fa 	sub	r11,sp,-6
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
80003ac2:	19 89       	ld.ub	r9,r12[0x0]
80003ac4:	10 c9       	st.b	r8++,r9
		ucComMF522Buf[6]  ^= *(pSnr+i);
80003ac6:	19 3a       	ld.ub	r10,r12++
80003ac8:	1b e9       	ld.ub	r9,sp[0x6]
80003aca:	f5 e9 20 09 	eor	r9,r10,r9
80003ace:	ba e9       	st.b	sp[0x6],r9
	U8   ucComMF522Buf[MAXRLEN];
	
	ucComMF522Buf[0] = PICC_ANTICOLL1;
	ucComMF522Buf[1] = 0x70;
	ucComMF522Buf[6] = 0;
	for (i=0; i<4; i++)
80003ad0:	16 38       	cp.w	r8,r11
80003ad2:	cf 81       	brne	80003ac2 <PcdSelect+0x1a>
	{
		ucComMF522Buf[i+2] = *(pSnr+i);
		ucComMF522Buf[6]  ^= *(pSnr+i);
	}
	CalulateCRC(ucComMF522Buf,7,&ucComMF522Buf[7]);
80003ad4:	1a 97       	mov	r7,sp
80003ad6:	fa ca ff f9 	sub	r10,sp,-7
80003ada:	30 7b       	mov	r11,7
80003adc:	1a 9c       	mov	r12,sp
80003ade:	f0 1f 00 0d 	mcall	80003b10 <PcdSelect+0x68>
	
	ClearBitMask(Status2Reg,0x08);
80003ae2:	30 8b       	mov	r11,8
80003ae4:	16 9c       	mov	r12,r11
80003ae6:	f0 1f 00 0c 	mcall	80003b14 <PcdSelect+0x6c>

	status = PcdComMF522(PCD_TRANSCEIVE,ucComMF522Buf,9,ucComMF522Buf,&unLen);
80003aea:	fa c8 ff ed 	sub	r8,sp,-19
80003aee:	1a 99       	mov	r9,sp
80003af0:	30 9a       	mov	r10,9
80003af2:	1a 9b       	mov	r11,sp
80003af4:	30 cc       	mov	r12,12
80003af6:	f0 1f 00 09 	mcall	80003b18 <PcdSelect+0x70>
	
	if ((status == MI_OK) && (unLen == 0x18))
80003afa:	c0 71       	brne	80003b08 <PcdSelect+0x60>
80003afc:	31 88       	mov	r8,24
80003afe:	fb 39 00 13 	ld.ub	r9,sp[19]
80003b02:	f0 09 18 00 	cp.b	r9,r8
80003b06:	c0 20       	breq	80003b0a <PcdSelect+0x62>
80003b08:	30 2c       	mov	r12,2
	{   status = MI_OK;  }
	else
	{   status = MI_ERR;    }

	return status;
}
80003b0a:	2f bd       	sub	sp,-20
80003b0c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003b10:	80 00       	ld.sh	r0,r0[0x0]
80003b12:	3a 1c       	mov	r12,-95
80003b14:	80 00       	ld.sh	r0,r0[0x0]
80003b16:	36 44       	mov	r4,100
80003b18:	80 00       	ld.sh	r0,r0[0x0]
80003b1a:	37 bc       	mov	r12,123

80003b1c <rfid_auto_reader>:
		//
}

//娴绋锛瀵诲->插叉->->″
U8 rfid_auto_reader(void *card_id)
{
80003b1c:	d4 31       	pushm	r0-r7,lr
80003b1e:	18 92       	mov	r2,r12
	U8 status = MI_ERR;
	
	PcdReset();
80003b20:	f0 1f 00 34 	mcall	80003bf0 <rfid_auto_reader+0xd4>
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80003b24:	4b 47       	lddpc	r7,80003bf4 <rfid_auto_reader+0xd8>
80003b26:	35 25       	mov	r5,82
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80003b28:	30 44       	mov	r4,4
	else if(CT[0]==0x44&&CT[1]==0x03)
		log("MF Desire\n");
	else
		log("Unknown\n");
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80003b2a:	4b 46       	lddpc	r6,80003bf8 <rfid_auto_reader+0xdc>
	status=PcdSelect(SN);//
	if(status!=MI_OK)//return status;
	continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80003b2c:	30 41       	mov	r1,4
		log("select okay\n");
80003b2e:	4b 40       	lddpc	r0,80003bfc <rfid_auto_reader+0xe0>
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80003b30:	30 23       	mov	r3,2
{
	U8 status = MI_ERR;
	
	PcdReset();
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
80003b32:	0e 9b       	mov	r11,r7
80003b34:	0a 9c       	mov	r12,r5
80003b36:	f0 1f 00 33 	mcall	80003c00 <rfid_auto_reader+0xe4>
	if(status!=MI_OK) //return status;
80003b3a:	cf c1       	brne	80003b32 <rfid_auto_reader+0x16>
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80003b3c:	0f 88       	ld.ub	r8,r7[0x0]
80003b3e:	e8 08 18 00 	cp.b	r8,r4
80003b42:	c0 a1       	brne	80003b56 <rfid_auto_reader+0x3a>
80003b44:	0f 9a       	ld.ub	r10,r7[0x1]
80003b46:	30 09       	mov	r9,0
80003b48:	f2 0a 18 00 	cp.b	r10,r9
80003b4c:	c0 51       	brne	80003b56 <rfid_auto_reader+0x3a>
		log("MFOne-S50\n");
80003b4e:	4a ec       	lddpc	r12,80003c04 <rfid_auto_reader+0xe8>
80003b50:	f0 1f 00 2e 	mcall	80003c08 <rfid_auto_reader+0xec>
while(1){
	status=PcdRequest(PICC_REQALL,	CT);//瀵诲ぉ绾垮哄ㄩㄧ★杩＄绫诲 2瀛
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
80003b54:	c3 78       	rjmp	80003bc2 <rfid_auto_reader+0xa6>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80003b56:	e6 08 18 00 	cp.b	r8,r3
80003b5a:	c0 a1       	brne	80003b6e <rfid_auto_reader+0x52>
80003b5c:	0f 9a       	ld.ub	r10,r7[0x1]
80003b5e:	30 09       	mov	r9,0
80003b60:	f2 0a 18 00 	cp.b	r10,r9
80003b64:	c0 51       	brne	80003b6e <rfid_auto_reader+0x52>
		log("MFOne-S70\n");
80003b66:	4a ac       	lddpc	r12,80003c0c <rfid_auto_reader+0xf0>
80003b68:	f0 1f 00 28 	mcall	80003c08 <rfid_auto_reader+0xec>
	if(status!=MI_OK) //return status;
	continue;
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
80003b6c:	c2 b8       	rjmp	80003bc2 <rfid_auto_reader+0xa6>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80003b6e:	34 49       	mov	r9,68
80003b70:	f2 08 18 00 	cp.b	r8,r9
80003b74:	c0 a1       	brne	80003b88 <rfid_auto_reader+0x6c>
80003b76:	0f 9a       	ld.ub	r10,r7[0x1]
80003b78:	30 09       	mov	r9,0
80003b7a:	f2 0a 18 00 	cp.b	r10,r9
80003b7e:	c0 51       	brne	80003b88 <rfid_auto_reader+0x6c>
		log("MF-UltraLight\n");
80003b80:	4a 4c       	lddpc	r12,80003c10 <rfid_auto_reader+0xf4>
80003b82:	f0 1f 00 22 	mcall	80003c08 <rfid_auto_reader+0xec>
	
	if(CT[0]==0x04&&CT[1]==0x00)
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
80003b86:	c1 e8       	rjmp	80003bc2 <rfid_auto_reader+0xa6>
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80003b88:	30 89       	mov	r9,8
80003b8a:	f2 08 18 00 	cp.b	r8,r9
80003b8e:	c0 a1       	brne	80003ba2 <rfid_auto_reader+0x86>
80003b90:	0f 9a       	ld.ub	r10,r7[0x1]
80003b92:	30 09       	mov	r9,0
80003b94:	f2 0a 18 00 	cp.b	r10,r9
80003b98:	c0 51       	brne	80003ba2 <rfid_auto_reader+0x86>
		log("MF-Pro\n");
80003b9a:	49 fc       	lddpc	r12,80003c14 <rfid_auto_reader+0xf8>
80003b9c:	f0 1f 00 1b 	mcall	80003c08 <rfid_auto_reader+0xec>
		log("MFOne-S50\n");
	else if(CT[0]==0x02&&CT[1]==0x00)
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
80003ba0:	c1 18       	rjmp	80003bc2 <rfid_auto_reader+0xa6>
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80003ba2:	34 49       	mov	r9,68
80003ba4:	f2 08 18 00 	cp.b	r8,r9
80003ba8:	c0 a1       	brne	80003bbc <rfid_auto_reader+0xa0>
80003baa:	0f 99       	ld.ub	r9,r7[0x1]
80003bac:	30 38       	mov	r8,3
80003bae:	f0 09 18 00 	cp.b	r9,r8
80003bb2:	c0 51       	brne	80003bbc <rfid_auto_reader+0xa0>
		log("MF Desire\n");
80003bb4:	49 9c       	lddpc	r12,80003c18 <rfid_auto_reader+0xfc>
80003bb6:	f0 1f 00 15 	mcall	80003c08 <rfid_auto_reader+0xec>
		log("MFOne-S70\n");
	else if(CT[0]==0x44&&CT[1]==0x00)
		log("MF-UltraLight\n");
	else if(CT[0]==0x08&&CT[1]==0x00)
		log("MF-Pro\n");
	else if(CT[0]==0x44&&CT[1]==0x03)
80003bba:	c0 48       	rjmp	80003bc2 <rfid_auto_reader+0xa6>
		log("MF Desire\n");
	else
		log("Unknown\n");
80003bbc:	49 8c       	lddpc	r12,80003c1c <rfid_auto_reader+0x100>
80003bbe:	f0 1f 00 13 	mcall	80003c08 <rfid_auto_reader+0xec>
		
	status=PcdAnticoll(SN);//插叉锛杩＄搴 4瀛
80003bc2:	0c 9c       	mov	r12,r6
80003bc4:	f0 1f 00 17 	mcall	80003c20 <rfid_auto_reader+0x104>
	if(status!=MI_OK)
80003bc8:	c0 60       	breq	80003bd4 <rfid_auto_reader+0xb8>
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to noticy failure!!!
80003bca:	37 8b       	mov	r11,120
80003bcc:	30 1c       	mov	r12,1
80003bce:	f0 1f 00 16 	mcall	80003c24 <rfid_auto_reader+0x108>
		//return status;
		continue;
80003bd2:	cb 0b       	rjmp	80003b32 <rfid_auto_reader+0x16>
	}
	
	//memcpy(MLastSelectedSnr,&RevBuffer[2],4);
	status=PcdSelect(SN);//
80003bd4:	0c 9c       	mov	r12,r6
80003bd6:	f0 1f 00 15 	mcall	80003c28 <rfid_auto_reader+0x10c>
	if(status!=MI_OK)//return status;
80003bda:	ca c1       	brne	80003b32 <rfid_auto_reader+0x16>
	continue;
	else{//℃
			
		memcpy(card_id, SN, 4);
80003bdc:	02 9a       	mov	r10,r1
80003bde:	0c 9b       	mov	r11,r6
80003be0:	04 9c       	mov	r12,r2
80003be2:	f0 1f 00 13 	mcall	80003c2c <rfid_auto_reader+0x110>
		log("select okay\n");
80003be6:	00 9c       	mov	r12,r0
80003be8:	f0 1f 00 08 	mcall	80003c08 <rfid_auto_reader+0xec>
80003bec:	ca 3b       	rjmp	80003b32 <rfid_auto_reader+0x16>
80003bee:	00 00       	add	r0,r0
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	35 38       	mov	r8,83
80003bf4:	00 00       	add	r0,r0
80003bf6:	1f 88       	ld.ub	r8,pc[0x0]
80003bf8:	00 00       	add	r0,r0
80003bfa:	1f 8c       	ld.ub	r12,pc[0x0]
80003bfc:	80 00       	ld.sh	r0,r0[0x0]
80003bfe:	c3 f8       	rjmp	80003c7c <rfid_sendID_message+0x4c>
80003c00:	80 00       	ld.sh	r0,r0[0x0]
80003c02:	39 b8       	mov	r8,-101
80003c04:	80 00       	ld.sh	r0,r0[0x0]
80003c06:	c3 b0       	breq	80003c7c <rfid_sendID_message+0x4c>
80003c08:	80 00       	ld.sh	r0,r0[0x0]
80003c0a:	5d 68       	*unknown*
80003c0c:	80 00       	ld.sh	r0,r0[0x0]
80003c0e:	c3 bc       	rcall	80003c84 <rfid_sendID_message+0x54>
80003c10:	80 00       	ld.sh	r0,r0[0x0]
80003c12:	c3 c8       	rjmp	80003c8a <rfid_sendID_message+0x5a>
80003c14:	80 00       	ld.sh	r0,r0[0x0]
80003c16:	c3 d8       	rjmp	80003c90 <rfid_sendID_message+0x60>
80003c18:	80 00       	ld.sh	r0,r0[0x0]
80003c1a:	c3 e0       	breq	80003c96 <rfid_sendID_message+0x66>
80003c1c:	80 00       	ld.sh	r0,r0[0x0]
80003c1e:	c3 ec       	rcall	80003c9a <rfid_sendID_message+0x6a>
80003c20:	80 00       	ld.sh	r0,r0[0x0]
80003c22:	39 34       	mov	r4,-109
80003c24:	80 00       	ld.sh	r0,r0[0x0]
80003c26:	33 24       	mov	r4,50
80003c28:	80 00       	ld.sh	r0,r0[0x0]
80003c2a:	3a a8       	mov	r8,-86
80003c2c:	80 00       	ld.sh	r0,r0[0x0]
80003c2e:	64 8a       	ld.w	r10,r2[0x20]

80003c30 <rfid_sendID_message>:
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
{
80003c30:	eb cd 40 e0 	pushm	r5-r7,lr
80003c34:	21 fd       	sub	sp,124
	static U8 start_session = 0x80;
	Message_Header_t header;
	Message_Data_t data_buffer;//22bytes
	
	//memset(data_buffer, 0x00, 16);
	memset(SN, 0x00, 10);
80003c36:	fa cc ff 90 	sub	r12,sp,-112
80003c3a:	30 08       	mov	r8,0
80003c3c:	30 09       	mov	r9,0
80003c3e:	f8 e9 00 00 	st.d	r12[0],r8
80003c42:	30 0a       	mov	r10,0
80003c44:	b8 4a       	st.h	r12[0x8],r10
	memset(message, 0x00, 80);
80003c46:	fa e9 00 20 	st.d	sp[32],r8
80003c4a:	fa e9 00 28 	st.d	sp[40],r8
80003c4e:	fa e9 00 30 	st.d	sp[48],r8
80003c52:	fa e9 00 38 	st.d	sp[56],r8
80003c56:	fa e9 00 40 	st.d	sp[64],r8
80003c5a:	fa e9 00 48 	st.d	sp[72],r8
80003c5e:	fa e9 00 50 	st.d	sp[80],r8
80003c62:	fa e9 00 58 	st.d	sp[88],r8
80003c66:	fa e9 00 60 	st.d	sp[96],r8
80003c6a:	fa e9 00 68 	st.d	sp[104],r8

	return_err = rfid_auto_reader(SN);
80003c6e:	f0 1f 00 43 	mcall	80003d78 <rfid_sendID_message+0x148>
80003c72:	18 97       	mov	r7,r12
	
	if(return_err == 0){
80003c74:	c7 61       	brne	80003d60 <rfid_sendID_message+0x130>
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
80003c76:	fb 38 00 73 	ld.ub	r8,sp[115]
80003c7a:	1a d8       	st.w	--sp,r8
80003c7c:	fb 38 00 76 	ld.ub	r8,sp[118]
80003c80:	1a d8       	st.w	--sp,r8
80003c82:	fb 38 00 79 	ld.ub	r8,sp[121]
80003c86:	1a d8       	st.w	--sp,r8
80003c88:	fb 38 00 7c 	ld.ub	r8,sp[124]
80003c8c:	1a d8       	st.w	--sp,r8
80003c8e:	4b cc       	lddpc	r12,80003d7c <rfid_sendID_message+0x14c>
80003c90:	f0 1f 00 3c 	mcall	80003d80 <rfid_sendID_message+0x150>
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
80003c94:	37 7b       	mov	r11,119
80003c96:	30 1c       	mov	r12,1
80003c98:	f0 1f 00 3b 	mcall	80003d84 <rfid_sendID_message+0x154>
80003c9c:	fa c9 ff 80 	sub	r9,sp,-128
80003ca0:	fa c8 ff f0 	sub	r8,sp,-16
80003ca4:	fa ca ff ee 	sub	r10,sp,-18
}
	
}

extern volatile DateTime_t Current_time;
U8 rfid_sendID_message()
80003ca8:	fa c5 ff 7c 	sub	r5,sp,-132
80003cac:	10 9d       	mov	sp,r8
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80003cae:	30 9e       	mov	lr,9
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80003cb0:	30 06       	mov	r6,0
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
		
			 temp = ((SN[i] & 0xF0) >> 4);//瀛楂浣
80003cb2:	13 8b       	ld.ub	r11,r9[0x0]
80003cb4:	f6 0c 16 04 	lsr	r12,r11,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4] = temp+0x30;
80003cb8:	fc 0c 18 00 	cp.b	r12,lr
80003cbc:	f7 bc 08 d0 	subls	r12,-48
80003cc0:	f1 fc 8e 00 	st.bls	r8[0x0],r12
			 else 
				data_buffer.RFID_ID[i*4] = ((temp - 0x0a)+0x61);
80003cc4:	f7 bc 0b a9 	subhi	r12,-87
80003cc8:	f1 fc be 00 	st.bhi	r8[0x0],r12
			
			 data_buffer.RFID_ID[i*4+1] = 0x00;
80003ccc:	b0 96       	st.b	r8[0x1],r6
		 
			 temp = (SN[i] & 0x0F);//瀛浣浣
80003cce:	f7 db c0 04 	bfextu	r11,r11,0x0,0x4
			 if((temp >= 0) && (temp <= 9))data_buffer.RFID_ID[i*4+2] = temp+0x30;
80003cd2:	fc 0b 18 00 	cp.b	r11,lr
80003cd6:	f7 bb 08 d0 	subls	r11,-48
80003cda:	f5 fb 8e 00 	st.bls	r10[0x0],r11
			 else
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);
80003cde:	f7 bb 0b a9 	subhi	r11,-87
80003ce2:	f5 fb be 00 	st.bhi	r10[0x0],r11

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
80003ce6:	b0 b6       	st.b	r8[0x3],r6
80003ce8:	2f f9       	sub	r9,-1
80003cea:	2f c8       	sub	r8,-4
80003cec:	2f ca       	sub	r10,-4
	
	if(return_err == 0){
		
		log("card_id : %X, %X, %X, %X\n", SN[0], SN[1], SN[2], SN[3]);
		xcmp_IdleTestTone(Tone_Start, BT_Connection_Success_Tone);//set tone to indicate scan rfid success!!!		 
		for(int i = 0; i<4; i++){//灏Unicode杞涓哄ぇ绔妯″	
80003cee:	0a 39       	cp.w	r9,r5
80003cf0:	ce 11       	brne	80003cb2 <rfid_sendID_message+0x82>
				data_buffer.RFID_ID[i*4+2] = ((temp - 0x0a)+0x61);

			 data_buffer.RFID_ID[i*4+3] = 0x00; 
		}
		
		memcpy(&data_buffer.XG_Time.Year, &Current_time.Year, sizeof(DateTime_t))	;
80003cf2:	30 6a       	mov	r10,6
80003cf4:	4a 5b       	lddpc	r11,80003d88 <rfid_sendID_message+0x158>
80003cf6:	fa cc ff f0 	sub	r12,sp,-16
80003cfa:	f0 1f 00 25 	mcall	80003d8c <rfid_sendID_message+0x15c>
	
		header.length = (0x0008 + sizeof(Message_Data_t));
	
		if(start_session > 0x9f)start_session = 0x80;
80003cfe:	4a 58       	lddpc	r8,80003d90 <rfid_sendID_message+0x160>
80003d00:	11 89       	ld.ub	r9,r8[0x0]
80003d02:	39 f8       	mov	r8,-97
80003d04:	f0 09 18 00 	cp.b	r9,r8
80003d08:	e0 88 00 05 	brls	80003d12 <rfid_sendID_message+0xe2>
80003d0c:	38 09       	mov	r9,-128
80003d0e:	4a 18       	lddpc	r8,80003d90 <rfid_sendID_message+0x160>
80003d10:	b0 89       	st.b	r8[0x0],r9
	
		header.session_id = (++start_session);
80003d12:	4a 08       	lddpc	r8,80003d90 <rfid_sendID_message+0x160>
80003d14:	11 86       	ld.ub	r6,r8[0x0]
80003d16:	2f f6       	sub	r6,-1
80003d18:	b0 86       	st.b	r8[0x0],r6
	
		memcpy(&header.fixed_data[0], unsure_data, sizeof(unsure_data));
80003d1a:	30 5a       	mov	r10,5
80003d1c:	49 eb       	lddpc	r11,80003d94 <rfid_sendID_message+0x164>
80003d1e:	fa cc ff e5 	sub	r12,sp,-27
80003d22:	f0 1f 00 1b 	mcall	80003d8c <rfid_sendID_message+0x15c>
		header.type = 0xe000;
	
		memcpy(message, &header, sizeof(Message_Header_t));//疯header版
80003d26:	31 e8       	mov	r8,30
80003d28:	fb 58 00 16 	st.h	sp[22],r8
80003d2c:	fb 66 00 1a 	st.b	sp[26],r6
80003d30:	fe 78 e0 00 	mov	r8,-8192
80003d34:	fb 58 00 18 	st.h	sp[24],r8
80003d38:	fa c6 ff e0 	sub	r6,sp,-32
80003d3c:	30 aa       	mov	r10,10
80003d3e:	fa cb ff ea 	sub	r11,sp,-22
80003d42:	0c 9c       	mov	r12,r6
80003d44:	f0 1f 00 12 	mcall	80003d8c <rfid_sendID_message+0x15c>
		memcpy(&message[sizeof(Message_Header_t)], &data_buffer, sizeof(Message_Data_t));//疯淇″瀹规版
80003d48:	31 6a       	mov	r10,22
80003d4a:	1a 9b       	mov	r11,sp
80003d4c:	fa cc ff d6 	sub	r12,sp,-42
80003d50:	f0 1f 00 0f 	mcall	80003d8c <rfid_sendID_message+0x15c>
	
		xcmp_data_session_req(message, (sizeof(Message_Header_t)+sizeof(Message_Data_t)), destination);
80003d54:	30 9a       	mov	r10,9
80003d56:	32 0b       	mov	r11,32
80003d58:	0c 9c       	mov	r12,r6
80003d5a:	f0 1f 00 10 	mcall	80003d98 <rfid_sendID_message+0x168>
80003d5e:	c0 88       	rjmp	80003d6e <rfid_sendID_message+0x13e>
		
	}
	else
	{
		xcmp_IdleTestTone(Tone_Start, BT_Disconnecting_Success_Tone);//set tone to indicate scan rfid failure!!!
80003d60:	37 8b       	mov	r11,120
80003d62:	30 1c       	mov	r12,1
80003d64:	f0 1f 00 08 	mcall	80003d84 <rfid_sendID_message+0x154>
		log("no card find...\n");
80003d68:	48 dc       	lddpc	r12,80003d9c <rfid_sendID_message+0x16c>
80003d6a:	f0 1f 00 06 	mcall	80003d80 <rfid_sendID_message+0x150>
	}
	
	return return_err;
	
}
80003d6e:	0e 9c       	mov	r12,r7
80003d70:	2e 1d       	sub	sp,-124
80003d72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003d76:	00 00       	add	r0,r0
80003d78:	80 00       	ld.sh	r0,r0[0x0]
80003d7a:	3b 1c       	mov	r12,-79
80003d7c:	80 00       	ld.sh	r0,r0[0x0]
80003d7e:	c4 08       	rjmp	80003dfe <delay_ns+0xe>
80003d80:	80 00       	ld.sh	r0,r0[0x0]
80003d82:	5d 68       	*unknown*
80003d84:	80 00       	ld.sh	r0,r0[0x0]
80003d86:	33 24       	mov	r4,50
80003d88:	00 00       	add	r0,r0
80003d8a:	0c e8       	st.h	--r6,r8
80003d8c:	80 00       	ld.sh	r0,r0[0x0]
80003d8e:	64 8a       	ld.w	r10,r2[0x20]
80003d90:	00 00       	add	r0,r0
80003d92:	05 00       	ld.w	r0,r2++
80003d94:	00 00       	add	r0,r0
80003d96:	04 f8       	st.b	--r2,r8
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	32 58       	mov	r8,37
80003d9c:	80 00       	ld.sh	r0,r0[0x0]
80003d9e:	c4 24       	brge	80003e22 <delay_us+0x1a>

80003da0 <rfid_init>:
U8 RFID[16];			//瀛RFID
U8 unsure_data[5]={0x04, 0x0d, 0x00, 0x0a, 0x00};


void rfid_init()
{
80003da0:	eb cd 40 80 	pushm	r7,lr
80003da4:	20 1d       	sub	sp,4
	char card_id[4]={0};
80003da6:	fa c7 ff fc 	sub	r7,sp,-4
80003daa:	30 08       	mov	r8,0
80003dac:	0e d8       	st.w	--r7,r8
	//tc_init();//ㄥ跺200msㄥ诲
	
	rc522_init();
80003dae:	f0 1f 00 0d 	mcall	80003de0 <rfid_init+0x40>
	
	if(rfid_auto_reader(card_id) == 0){
80003db2:	1a 9c       	mov	r12,sp
80003db4:	f0 1f 00 0c 	mcall	80003de4 <rfid_init+0x44>
80003db8:	c1 11       	brne	80003dda <rfid_init+0x3a>
		log("card_id : 0x%x, 0x%x, 0x%x, 0x%x\n", &card_id[0], &card_id[1], &card_id[2], &card_id[3]);	
80003dba:	fa c8 ff fd 	sub	r8,sp,-3
80003dbe:	1a d8       	st.w	--sp,r8
80003dc0:	fa c8 ff fa 	sub	r8,sp,-6
80003dc4:	1a d8       	st.w	--sp,r8
80003dc6:	fa c8 ff f7 	sub	r8,sp,-9
80003dca:	1a d8       	st.w	--sp,r8
80003dcc:	fa c8 ff f4 	sub	r8,sp,-12
80003dd0:	1a d8       	st.w	--sp,r8
80003dd2:	48 6c       	lddpc	r12,80003de8 <rfid_init+0x48>
80003dd4:	f0 1f 00 06 	mcall	80003dec <rfid_init+0x4c>
80003dd8:	2f cd       	sub	sp,-16
	}
		//
}
80003dda:	2f fd       	sub	sp,-4
80003ddc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003de0:	80 00       	ld.sh	r0,r0[0x0]
80003de2:	36 ec       	mov	r12,110
80003de4:	80 00       	ld.sh	r0,r0[0x0]
80003de6:	3b 1c       	mov	r12,-79
80003de8:	80 00       	ld.sh	r0,r0[0x0]
80003dea:	c4 38       	rjmp	80003e70 <local_start_timer+0x18>
80003dec:	80 00       	ld.sh	r0,r0[0x0]
80003dee:	5d 68       	*unknown*

80003df0 <delay_ns>:
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80003df0:	58 0c       	cp.w	r12,0
80003df2:	5e 0c       	reteq	r12
80003df4:	30 08       	mov	r8,0
	{
		nop();
80003df6:	d7 03       	nop
		nop();
80003df8:	d7 03       	nop
		nop();
80003dfa:	d7 03       	nop
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
80003dfc:	2f f8       	sub	r8,-1
80003dfe:	10 3c       	cp.w	r12,r8
80003e00:	fe 9b ff fb 	brhi	80003df6 <delay_ns+0x6>
80003e04:	5e fc       	retal	r12
80003e06:	d7 03       	nop

80003e08 <delay_us>:
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
80003e08:	eb cd 40 e0 	pushm	r5-r7,lr
80003e0c:	18 96       	mov	r6,r12
	for(int i =0; i<us; i++){
80003e0e:	58 0c       	cp.w	r12,0
80003e10:	c0 b0       	breq	80003e26 <delay_us+0x1e>
80003e12:	30 07       	mov	r7,0
		delay_ns(1000);
80003e14:	e0 65 03 e8 	mov	r5,1000
80003e18:	0a 9c       	mov	r12,r5
80003e1a:	f0 1f 00 05 	mcall	80003e2c <delay_us+0x24>
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
80003e1e:	2f f7       	sub	r7,-1
80003e20:	0e 36       	cp.w	r6,r7
80003e22:	fe 9b ff fb 	brhi	80003e18 <delay_us+0x10>
80003e26:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e2a:	00 00       	add	r0,r0
80003e2c:	80 00       	ld.sh	r0,r0[0x0]
80003e2e:	3d f0       	mov	r0,-33

80003e30 <delay_ms>:
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
80003e30:	eb cd 40 e0 	pushm	r5-r7,lr
80003e34:	18 96       	mov	r6,r12
	for(int i =0; i<ms; i++){
80003e36:	58 0c       	cp.w	r12,0
80003e38:	c0 b0       	breq	80003e4e <delay_ms+0x1e>
80003e3a:	30 07       	mov	r7,0
		delay_us(1000);
80003e3c:	e0 65 03 e8 	mov	r5,1000
80003e40:	0a 9c       	mov	r12,r5
80003e42:	f0 1f 00 05 	mcall	80003e54 <delay_ms+0x24>
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
80003e46:	2f f7       	sub	r7,-1
80003e48:	0e 36       	cp.w	r6,r7
80003e4a:	fe 9b ff fb 	brhi	80003e40 <delay_ms+0x10>
80003e4e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003e52:	00 00       	add	r0,r0
80003e54:	80 00       	ld.sh	r0,r0[0x0]
80003e56:	3e 08       	mov	r8,-32

80003e58 <local_start_timer>:
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
80003e58:	d4 01       	pushm	lr
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));
80003e5a:	30 3b       	mov	r11,3
80003e5c:	48 8c       	lddpc	r12,80003e7c <local_start_timer+0x24>
80003e5e:	f0 1f 00 09 	mcall	80003e80 <local_start_timer+0x28>

	(&AVR32_TC)->channel[0].cmr =
80003e62:	fe 78 38 00 	mov	r8,-51200
80003e66:	e0 69 91 0d 	mov	r9,37133
80003e6a:	ea 19 00 52 	orh	r9,0x52
80003e6e:	91 19       	st.w	r8[0x4],r9
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
80003e70:	32 09       	mov	r9,32
80003e72:	91 59       	st.w	r8[0x14],r9
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
80003e74:	30 59       	mov	r9,5
80003e76:	91 09       	st.w	r8[0x0],r9
}
80003e78:	d8 02       	popm	pc
80003e7a:	00 00       	add	r0,r0
80003e7c:	80 00       	ld.sh	r0,r0[0x0]
80003e7e:	c4 5c       	rcall	80003f08 <local_start_pll0+0x84>
80003e80:	80 00       	ld.sh	r0,r0[0x0]
80003e82:	41 ec       	lddsp	r12,sp[0x78]

80003e84 <local_start_pll0>:
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
80003e84:	d4 01       	pushm	lr
	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);
80003e86:	30 3a       	mov	r10,3
80003e88:	e0 6b 1b 00 	mov	r11,6912
80003e8c:	ea 1b 00 b7 	orh	r11,0xb7
80003e90:	fe 7c 0c 00 	mov	r12,-62464
80003e94:	f0 1f 00 19 	mcall	80003ef8 <local_start_pll0+0x74>

	pm_pll_setup(&AVR32_PM,
80003e98:	31 08       	mov	r8,16
80003e9a:	1a d8       	st.w	--sp,r8
80003e9c:	30 08       	mov	r8,0
80003e9e:	30 19       	mov	r9,1
80003ea0:	30 7a       	mov	r10,7
80003ea2:	10 9b       	mov	r11,r8
80003ea4:	fe 7c 0c 00 	mov	r12,-62464
80003ea8:	f0 1f 00 15 	mcall	80003efc <local_start_pll0+0x78>
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
80003eac:	30 08       	mov	r8,0
80003eae:	30 19       	mov	r9,1
80003eb0:	12 9a       	mov	r10,r9
80003eb2:	10 9b       	mov	r11,r8
80003eb4:	fe 7c 0c 00 	mov	r12,-62464
80003eb8:	f0 1f 00 12 	mcall	80003f00 <local_start_pll0+0x7c>
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);
80003ebc:	30 0b       	mov	r11,0
80003ebe:	fe 7c 0c 00 	mov	r12,-62464
80003ec2:	f0 1f 00 11 	mcall	80003f04 <local_start_pll0+0x80>


	pm_wait_for_pll0_locked(&AVR32_PM);
80003ec6:	fe 7c 0c 00 	mov	r12,-62464
80003eca:	f0 1f 00 10 	mcall	80003f08 <local_start_pll0+0x84>


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
80003ece:	30 0a       	mov	r10,0
80003ed0:	1a da       	st.w	--sp,r10
80003ed2:	1a da       	st.w	--sp,r10
80003ed4:	14 98       	mov	r8,r10
80003ed6:	14 99       	mov	r9,r10
80003ed8:	30 1b       	mov	r11,1
80003eda:	fe 7c 0c 00 	mov	r12,-62464
80003ede:	f0 1f 00 0c 	mcall	80003f0c <local_start_pll0+0x88>
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
80003ee2:	30 1c       	mov	r12,1
80003ee4:	f0 1f 00 0b 	mcall	80003f10 <local_start_pll0+0x8c>
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
80003ee8:	30 2b       	mov	r11,2
80003eea:	fe 7c 0c 00 	mov	r12,-62464
80003eee:	f0 1f 00 0a 	mcall	80003f14 <local_start_pll0+0x90>
80003ef2:	2f dd       	sub	sp,-12
/****/
}
80003ef4:	d8 02       	popm	pc
80003ef6:	00 00       	add	r0,r0
80003ef8:	80 00       	ld.sh	r0,r0[0x0]
80003efa:	44 f4       	lddsp	r4,sp[0x13c]
80003efc:	80 00       	ld.sh	r0,r0[0x0]
80003efe:	44 96       	lddsp	r6,sp[0x124]
80003f00:	80 00       	ld.sh	r0,r0[0x0]
80003f02:	44 b8       	lddsp	r8,sp[0x12c]
80003f04:	80 00       	ld.sh	r0,r0[0x0]
80003f06:	44 d2       	lddsp	r2,sp[0x134]
80003f08:	80 00       	ld.sh	r0,r0[0x0]
80003f0a:	44 e0       	lddsp	r0,sp[0x138]
80003f0c:	80 00       	ld.sh	r0,r0[0x0]
80003f0e:	44 50       	lddsp	r0,sp[0x114]
80003f10:	80 00       	ld.sh	r0,r0[0x0]
80003f12:	41 8c       	lddsp	r12,sp[0x60]
80003f14:	80 00       	ld.sh	r0,r0[0x0]
80003f16:	44 ea       	lddsp	r10,sp[0x138]

80003f18 <xg_flashc_init>:
}


//U16	Current_total_message_count=0;
void xg_flashc_init(void)
{
80003f18:	d4 31       	pushm	r0-r7,lr
80003f1a:	20 3d       	sub	sp,12
	
	/* Create the mutex semaphore to guard a shared xgflash.*/
	xgflash_mutex = xSemaphoreCreateMutex();
80003f1c:	f0 1f 00 80 	mcall	8000411c <xg_flashc_init+0x204>
80003f20:	fe f8 02 00 	ld.w	r8,pc[512]
80003f24:	91 0c       	st.w	r8[0x0],r12
	if (xgflash_mutex == NULL)
80003f26:	70 08       	ld.w	r8,r8[0x0]
80003f28:	58 08       	cp.w	r8,0
80003f2a:	c0 41       	brne	80003f32 <xg_flashc_init+0x1a>
	{
		log("Create the xgflash_mutex semaphore failure\n");
80003f2c:	4f ec       	lddpc	r12,80004124 <xg_flashc_init+0x20c>
80003f2e:	f0 1f 00 7f 	mcall	80004128 <xg_flashc_init+0x210>
	}
	
	/* Create the binary semaphore to Synchronize other threads.*/
	vSemaphoreCreateBinary(xBinarySemaphore);
80003f32:	30 0b       	mov	r11,0
80003f34:	30 1c       	mov	r12,1
80003f36:	f0 1f 00 7e 	mcall	8000412c <xg_flashc_init+0x214>
80003f3a:	4f e8       	lddpc	r8,80004130 <xg_flashc_init+0x218>
80003f3c:	91 0c       	st.w	r8[0x0],r12
80003f3e:	70 08       	ld.w	r8,r8[0x0]
80003f40:	58 08       	cp.w	r8,0
80003f42:	c0 80       	breq	80003f52 <xg_flashc_init+0x3a>
80003f44:	4f b8       	lddpc	r8,80004130 <xg_flashc_init+0x218>
80003f46:	70 0c       	ld.w	r12,r8[0x0]
80003f48:	30 09       	mov	r9,0
80003f4a:	12 9a       	mov	r10,r9
80003f4c:	12 9b       	mov	r11,r9
80003f4e:	f0 1f 00 7a 	mcall	80004134 <xg_flashc_init+0x21c>
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
80003f52:	30 4b       	mov	r11,4
80003f54:	31 4c       	mov	r12,20
80003f56:	f0 1f 00 76 	mcall	8000412c <xg_flashc_init+0x214>
80003f5a:	4f 88       	lddpc	r8,80004138 <xg_flashc_init+0x220>
80003f5c:	91 0c       	st.w	r8[0x0],r12
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
80003f5e:	30 4b       	mov	r11,4
80003f60:	31 4c       	mov	r12,20
80003f62:	f0 1f 00 73 	mcall	8000412c <xg_flashc_init+0x214>
80003f66:	4f 68       	lddpc	r8,8000413c <xg_flashc_init+0x224>
80003f68:	91 0c       	st.w	r8[0x0],r12
80003f6a:	30 07       	mov	r7,0
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
80003f6c:	10 96       	mov	r6,r8
80003f6e:	4f 55       	lddpc	r5,80004140 <xg_flashc_init+0x228>
80003f70:	6c 0c       	ld.w	r12,r6[0x0]
80003f72:	ea 07 00 0b 	add	r11,r5,r7
80003f76:	f0 1f 00 74 	mcall	80004144 <xg_flashc_init+0x22c>
80003f7a:	2e 07       	sub	r7,-32
	
	
	xg_resend_queue = xQueueCreate(20, sizeof(U32));
	/*initialize the queue*/
	message_storage_queue = xQueueCreate(20, sizeof(U32));
	for(int i= 0; i < MAX_MESSAGE_STORE; i++ )
80003f7c:	e0 47 02 80 	cp.w	r7,640
80003f80:	cf 81       	brne	80003f70 <xg_flashc_init+0x58>
	{
		set_message_store(&message_store[i]);//push <message_store> address to the message_storage_queue;
	}
	
	
	data_flash_init();//interface
80003f82:	f0 1f 00 72 	mcall	80004148 <xg_flashc_init+0x230>
	df_status_t return_code = DF_OK;
	static U32 current_page_number =0;
	unsigned int i = 0;
	unsigned int address =0x00000000;
	static char str[80];
	memset(str, 0x00, sizeof(str));
80003f86:	30 0a       	mov	r10,0
80003f88:	30 0b       	mov	r11,0
80003f8a:	4f 18       	lddpc	r8,8000414c <xg_flashc_init+0x234>
80003f8c:	b1 2a       	st.d	r8++,r10
80003f8e:	b1 2a       	st.d	r8++,r10
80003f90:	b1 2a       	st.d	r8++,r10
80003f92:	b1 2a       	st.d	r8++,r10
80003f94:	b1 2a       	st.d	r8++,r10
80003f96:	b1 2a       	st.d	r8++,r10
80003f98:	b1 2a       	st.d	r8++,r10
80003f9a:	b1 2a       	st.d	r8++,r10
80003f9c:	b1 2a       	st.d	r8++,r10
80003f9e:	f0 eb 00 00 	st.d	r8[0],r10
80003fa2:	30 05       	mov	r5,0
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80003fa4:	4e a7       	lddpc	r7,8000414c <xg_flashc_init+0x234>
			if(return_code == DF_OK)
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
					
					memset(str, 0x00, sizeof(str));	
80003fa6:	ee c4 ff f8 	sub	r4,r7,-8
80003faa:	e8 c3 ff f8 	sub	r3,r4,-8
80003fae:	e6 c2 ff f8 	sub	r2,r3,-8
80003fb2:	e4 c1 ff f8 	sub	r1,r2,-8
80003fb6:	e2 c0 ff f8 	sub	r0,r1,-8
80003fba:	e0 ca ff f8 	sub	r10,r0,-8
80003fbe:	50 0a       	stdsp	sp[0x0],r10
80003fc0:	2f 8a       	sub	r10,-8
80003fc2:	50 1a       	stdsp	sp[0x4],r10
80003fc4:	2f 8a       	sub	r10,-8
80003fc6:	50 2a       	stdsp	sp[0x8],r10
	memset(str, 0x00, sizeof(str));
	
start:
	
	 //bytes remained less than one page 
	return_code = data_flash_read_block(LABEL_ADDRESS, LABEL_LENGTH, str);
80003fc8:	0e 9a       	mov	r10,r7
80003fca:	30 6b       	mov	r11,6
80003fcc:	30 0c       	mov	r12,0
80003fce:	f0 1f 00 61 	mcall	80004150 <xg_flashc_init+0x238>
	{
		if(memcmp(XGFlashLabel, str, sizeof(XGFlashLabel)-1) != 0)//compare label
80003fd2:	30 6a       	mov	r10,6
80003fd4:	0e 9b       	mov	r11,r7
80003fd6:	4e 0c       	lddpc	r12,80004154 <xg_flashc_init+0x23c>
80003fd8:	f0 1f 00 60 	mcall	80004158 <xg_flashc_init+0x240>
80003fdc:	c1 c0       	breq	80004014 <xg_flashc_init+0xfc>
80003fde:	c8 58       	rjmp	800040e8 <xg_flashc_init+0x1d0>
					return FALSE;
				}
				address+=65536;//64k*1024=65536bytes
			}
			//set label
			return_code = data_flash_write(XGFlashLabel, LABEL_ADDRESS, LABEL_LENGTH);
80003fe0:	30 6a       	mov	r10,6
80003fe2:	30 0b       	mov	r11,0
80003fe4:	4d cc       	lddpc	r12,80004154 <xg_flashc_init+0x23c>
80003fe6:	f0 1f 00 5e 	mcall	8000415c <xg_flashc_init+0x244>
			
			//set current_voice_index
			memset(str, 0x00, sizeof(str));
80003fea:	4d 97       	lddpc	r7,8000414c <xg_flashc_init+0x234>
80003fec:	35 0a       	mov	r10,80
80003fee:	30 0b       	mov	r11,0
80003ff0:	0e 9c       	mov	r12,r7
80003ff2:	f0 1f 00 5c 	mcall	80004160 <xg_flashc_init+0x248>
			return_code = data_flash_write(str, MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH);
80003ff6:	30 2a       	mov	r10,2
80003ff8:	30 6b       	mov	r11,6
80003ffa:	0e 9c       	mov	r12,r7
80003ffc:	f0 1f 00 58 	mcall	8000415c <xg_flashc_init+0x244>
			if(return_code != DF_WRITE_COMPLETED)
80004000:	58 7c       	cp.w	r12,7
80004002:	e0 81 00 8a 	brne	80004116 <xg_flashc_init+0x1fe>
			{
				return FALSE;
			}
			current_message_index = 0;
80004006:	30 09       	mov	r9,0
80004008:	4d 78       	lddpc	r8,80004164 <xg_flashc_init+0x24c>
8000400a:	b0 09       	st.h	r8[0x0],r9
			log("\r\n----create xg message info okay!----\r\n");
8000400c:	4d 7c       	lddpc	r12,80004168 <xg_flashc_init+0x250>
8000400e:	f0 1f 00 47 	mcall	80004128 <xg_flashc_init+0x210>
80004012:	c7 f8       	rjmp	80004110 <xg_flashc_init+0x1f8>
		}
		else//success
		{
			log("\nLABEL: %s\n", str);
80004014:	1a d7       	st.w	--sp,r7
80004016:	4d 6c       	lddpc	r12,8000416c <xg_flashc_init+0x254>
80004018:	f0 1f 00 44 	mcall	80004128 <xg_flashc_init+0x210>
			//Get the current voice index
			return_code = data_flash_read_block(MESSAGE_NUMBERS_ADD, MESSAGE_NUMBERS_LENGTH, &current_message_index);								
8000401c:	4d 2a       	lddpc	r10,80004164 <xg_flashc_init+0x24c>
8000401e:	30 2b       	mov	r11,2
80004020:	30 6c       	mov	r12,6
80004022:	f0 1f 00 4c 	mcall	80004150 <xg_flashc_init+0x238>
			if(return_code == DF_OK)
80004026:	2f fd       	sub	sp,-4
80004028:	58 0c       	cp.w	r12,0
8000402a:	c7 61       	brne	80004116 <xg_flashc_init+0x1fe>
			{
				//Calculates the offset address of the current stored message
				if(current_message_index != 0){
8000402c:	4c e8       	lddpc	r8,80004164 <xg_flashc_init+0x24c>
8000402e:	90 09       	ld.sh	r9,r8[0x0]
80004030:	30 08       	mov	r8,0
80004032:	f0 09 19 00 	cp.h	r9,r8
80004036:	c6 a0       	breq	8000410a <xg_flashc_init+0x1f2>
					
					memset(str, 0x00, sizeof(str));	
80004038:	30 08       	mov	r8,0
8000403a:	30 09       	mov	r9,0
8000403c:	ee e9 00 00 	st.d	r7[0],r8
80004040:	e8 e9 00 00 	st.d	r4[0],r8
80004044:	e6 e9 00 00 	st.d	r3[0],r8
80004048:	e4 e9 00 00 	st.d	r2[0],r8
8000404c:	e2 e9 00 00 	st.d	r1[0],r8
80004050:	e0 e9 00 00 	st.d	r0[0],r8
80004054:	40 0a       	lddsp	r10,sp[0x0]
80004056:	f4 e9 00 00 	st.d	r10[0],r8
8000405a:	40 1a       	lddsp	r10,sp[0x4]
8000405c:	f4 e9 00 00 	st.d	r10[0],r8
80004060:	40 2a       	lddsp	r10,sp[0x8]
80004062:	b5 28       	st.d	r10++,r8
80004064:	f4 e9 00 00 	st.d	r10[0],r8
					address = XG_MESSAGE_INFO_HEADER_START_ADD + ((current_message_index -1)*XG_MESSAGE_INFO_HEADER_LENGTH);
80004068:	4b f8       	lddpc	r8,80004164 <xg_flashc_init+0x24c>
8000406a:	90 85       	ld.uh	r5,r8[0x0]
8000406c:	a3 75       	lsl	r5,0x3
					return_code = data_flash_read_block(address, XG_MESSAGE_INFO_HEADER_LENGTH, (U8 *)str);			
8000406e:	0e 9a       	mov	r10,r7
80004070:	30 8b       	mov	r11,8
80004072:	0a 9c       	mov	r12,r5
80004074:	f0 1f 00 37 	mcall	80004150 <xg_flashc_init+0x238>
					if(return_code == DF_OK)
80004078:	c4 91       	brne	8000410a <xg_flashc_init+0x1f2>
					{
						MessageList_Info_t *ptr = (MessageList_Info_t *)str;
						if(ptr->numb == current_message_index)
8000407a:	0f 89       	ld.ub	r9,r7[0x0]
8000407c:	0f 98       	ld.ub	r8,r7[0x1]
8000407e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80004082:	4b 99       	lddpc	r9,80004164 <xg_flashc_init+0x24c>
80004084:	92 09       	ld.sh	r9,r9[0x0]
80004086:	f0 09 19 00 	cp.h	r9,r8
8000408a:	c2 c1       	brne	800040e2 <xg_flashc_init+0x1ca>
						{
							current_save_message_offset = ptr->address + ptr->offset;
8000408c:	0f e9       	ld.ub	r9,r7[0x6]
8000408e:	0f f8       	ld.ub	r8,r7[0x7]
80004090:	f1 e9 10 89 	or	r9,r8,r9<<0x8
80004094:	0f aa       	ld.ub	r10,r7[0x2]
80004096:	0f b8       	ld.ub	r8,r7[0x3]
80004098:	b1 68       	lsl	r8,0x10
8000409a:	f1 ea 11 88 	or	r8,r8,r10<<0x18
8000409e:	0f ca       	ld.ub	r10,r7[0x4]
800040a0:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800040a4:	0f da       	ld.ub	r10,r7[0x5]
800040a6:	f5 e8 10 08 	or	r8,r10,r8
800040aa:	f2 08 00 08 	add	r8,r9,r8
800040ae:	4b 16       	lddpc	r6,80004170 <xg_flashc_init+0x258>
800040b0:	8d 08       	st.w	r6[0x0],r8
							log("current_save_message_offset : %X\n", current_save_message_offset);
800040b2:	1a d8       	st.w	--sp,r8
800040b4:	4b 0c       	lddpc	r12,80004174 <xg_flashc_init+0x25c>
800040b6:	f0 1f 00 1d 	mcall	80004128 <xg_flashc_init+0x210>
							if(current_save_message_offset > XG_MESSAGE_DATA_BOUNDARY_ADD){
800040ba:	2f fd       	sub	sp,-4
800040bc:	6c 08       	ld.w	r8,r6[0x0]
800040be:	e0 69 ff ff 	mov	r9,65535
800040c2:	ea 19 00 7f 	orh	r9,0x7f
800040c6:	12 38       	cp.w	r8,r9
800040c8:	e0 88 00 21 	brls	8000410a <xg_flashc_init+0x1f2>
										
								log("\r\n----message storage is full!!!----\r\n");
800040cc:	4a bc       	lddpc	r12,80004178 <xg_flashc_init+0x260>
800040ce:	f0 1f 00 17 	mcall	80004128 <xg_flashc_init+0x210>
								//xgflash erase

								return_code = data_flash_erase_block(0, DF_BLOCK_ALL);
800040d2:	30 4b       	mov	r11,4
800040d4:	30 0c       	mov	r12,0
800040d6:	f0 1f 00 2a 	mcall	8000417c <xg_flashc_init+0x264>
								if(return_code == DF_ERASE_COMPLETED)goto start;
800040da:	58 5c       	cp.w	r12,5
800040dc:	fe 90 ff 76 	breq	80003fc8 <xg_flashc_init+0xb0>
800040e0:	c1 b8       	rjmp	80004116 <xg_flashc_init+0x1fe>

							}
						}
						else
						{
							log("\r\n----message storage is err!!!----\r\n");
800040e2:	4a 8c       	lddpc	r12,80004180 <xg_flashc_init+0x268>
800040e4:	f0 1f 00 11 	mcall	80004128 <xg_flashc_init+0x210>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
800040e8:	30 3b       	mov	r11,3
800040ea:	0a 9c       	mov	r12,r5
800040ec:	f0 1f 00 24 	mcall	8000417c <xg_flashc_init+0x264>
				if(return_code != DF_ERASE_COMPLETED)
800040f0:	58 5c       	cp.w	r12,5
800040f2:	c1 21       	brne	80004116 <xg_flashc_init+0x1fe>
		{
			ERASE:
			//erase list
			for(i; i < (XG_MESSAGE_LISTINFO_BOUNDARY_ADD/(64*1024)); i++)//2*64k
			{
				return_code = data_flash_erase_block(address, DF_BLOCK_64KB);
800040f4:	30 3b       	mov	r11,3
800040f6:	e0 78 00 00 	mov	r8,65536
800040fa:	ea 08 00 0c 	add	r12,r5,r8
800040fe:	f0 1f 00 20 	mcall	8000417c <xg_flashc_init+0x264>
				if(return_code != DF_ERASE_COMPLETED)
80004102:	58 5c       	cp.w	r12,5
80004104:	fe 90 ff 6e 	breq	80003fe0 <xg_flashc_init+0xc8>
80004108:	c0 78       	rjmp	80004116 <xg_flashc_init+0x1fe>
							log("\r\n----message storage is err!!!----\r\n");
							goto ERASE;
						}
					}
				}
				log("\r\n----xoxo read message info okay!----\r\n");
8000410a:	49 fc       	lddpc	r12,80004184 <xg_flashc_init+0x26c>
8000410c:	f0 1f 00 07 	mcall	80004128 <xg_flashc_init+0x210>
			else
				return FALSE;
			
		}
				
		list_init_success_flag = 1;
80004110:	30 19       	mov	r9,1
80004112:	49 e8       	lddpc	r8,80004188 <xg_flashc_init+0x270>
80004114:	b0 89       	st.b	r8[0x0],r9
	
	//flashc_lock_all_regions(false);
	xgflash_list_info_init();
	//create_xg_flash_test_task();

}
80004116:	2f dd       	sub	sp,-12
80004118:	d8 32       	popm	r0-r7,pc
8000411a:	00 00       	add	r0,r0
8000411c:	80 00       	ld.sh	r0,r0[0x0]
8000411e:	52 30       	stdsp	sp[0x8c],r0
80004120:	00 00       	add	r0,r0
80004122:	0a 68       	and	r8,r5
80004124:	80 00       	ld.sh	r0,r0[0x0]
80004126:	c4 74       	brge	800041b4 <gpio_enable_module_pin+0x1a>
80004128:	80 00       	ld.sh	r0,r0[0x0]
8000412a:	5d 68       	*unknown*
8000412c:	80 00       	ld.sh	r0,r0[0x0]
8000412e:	52 88       	stdsp	sp[0xa0],r8
80004130:	00 00       	add	r0,r0
80004132:	1f 90       	ld.ub	r0,pc[0x1]
80004134:	80 00       	ld.sh	r0,r0[0x0]
80004136:	51 30       	stdsp	sp[0x4c],r0
80004138:	00 00       	add	r0,r0
8000413a:	0a 60       	and	r0,r5
8000413c:	00 00       	add	r0,r0
8000413e:	0a 6c       	and	r12,r5
80004140:	00 00       	add	r0,r0
80004142:	0c ee       	st.h	--r6,lr
80004144:	80 00       	ld.sh	r0,r0[0x0]
80004146:	31 bc       	mov	r12,27
80004148:	80 00       	ld.sh	r0,r0[0x0]
8000414a:	2e ec       	sub	r12,-18
8000414c:	00 00       	add	r0,r0
8000414e:	0a 74       	tst	r4,r5
80004150:	80 00       	ld.sh	r0,r0[0x0]
80004152:	2b c4       	sub	r4,-68
80004154:	00 00       	add	r0,r0
80004156:	05 04       	ld.w	r4,r2++
80004158:	80 00       	ld.sh	r0,r0[0x0]
8000415a:	64 64       	ld.w	r4,r2[0x18]
8000415c:	80 00       	ld.sh	r0,r0[0x0]
8000415e:	2d fc       	sub	r12,-33
80004160:	80 00       	ld.sh	r0,r0[0x0]
80004162:	65 d2       	ld.w	r2,r2[0x74]
80004164:	00 00       	add	r0,r0
80004166:	0a 70       	tst	r0,r5
80004168:	80 00       	ld.sh	r0,r0[0x0]
8000416a:	c4 a0       	breq	800041fe <gpio_enable_module+0x12>
8000416c:	80 00       	ld.sh	r0,r0[0x0]
8000416e:	c4 cc       	rcall	80004206 <gpio_enable_module+0x1a>
80004170:	00 00       	add	r0,r0
80004172:	05 0c       	ld.w	r12,r2++
80004174:	80 00       	ld.sh	r0,r0[0x0]
80004176:	c4 d8       	rjmp	80004210 <gpio_enable_module+0x24>
80004178:	80 00       	ld.sh	r0,r0[0x0]
8000417a:	c4 fc       	rcall	80004218 <gpio_enable_module+0x2c>
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	2d 5c       	sub	r12,-43
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	c5 24       	brge	80004226 <gpio_enable_gpio_pin+0xa>
80004184:	80 00       	ld.sh	r0,r0[0x0]
80004186:	c5 4c       	rcall	8000422e <gpio_enable_gpio_pin+0x12>
80004188:	00 00       	add	r0,r0
8000418a:	0a 64       	and	r4,r5

8000418c <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
8000418c:	fe 68 14 00 	mov	r8,-125952
80004190:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
80004192:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80004196:	91 09       	st.w	r8[0x0],r9
}
80004198:	5e fc       	retal	r12

8000419a <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000419a:	f8 08 16 05 	lsr	r8,r12,0x5
8000419e:	a9 68       	lsl	r8,0x8
800041a0:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800041a4:	58 1b       	cp.w	r11,1
800041a6:	c0 d0       	breq	800041c0 <gpio_enable_module_pin+0x26>
800041a8:	c0 63       	brcs	800041b4 <gpio_enable_module_pin+0x1a>
800041aa:	58 2b       	cp.w	r11,2
800041ac:	c1 00       	breq	800041cc <gpio_enable_module_pin+0x32>
800041ae:	58 3b       	cp.w	r11,3
800041b0:	c1 40       	breq	800041d8 <gpio_enable_module_pin+0x3e>
800041b2:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800041b4:	30 19       	mov	r9,1
800041b6:	f2 0c 09 49 	lsl	r9,r9,r12
800041ba:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800041bc:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800041be:	c1 28       	rjmp	800041e2 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800041c0:	30 19       	mov	r9,1
800041c2:	f2 0c 09 49 	lsl	r9,r9,r12
800041c6:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800041c8:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800041ca:	c0 c8       	rjmp	800041e2 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800041cc:	30 19       	mov	r9,1
800041ce:	f2 0c 09 49 	lsl	r9,r9,r12
800041d2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800041d4:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800041d6:	c0 68       	rjmp	800041e2 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800041d8:	30 19       	mov	r9,1
800041da:	f2 0c 09 49 	lsl	r9,r9,r12
800041de:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800041e0:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800041e2:	30 19       	mov	r9,1
800041e4:	f2 0c 09 4c 	lsl	r12,r9,r12
800041e8:	91 2c       	st.w	r8[0x8],r12
800041ea:	5e fd       	retal	0

800041ec <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800041ec:	d4 21       	pushm	r4-r7,lr
800041ee:	18 97       	mov	r7,r12
800041f0:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800041f2:	58 0b       	cp.w	r11,0
800041f4:	c0 31       	brne	800041fa <gpio_enable_module+0xe>
800041f6:	30 05       	mov	r5,0
800041f8:	c0 d8       	rjmp	80004212 <gpio_enable_module+0x26>
800041fa:	30 06       	mov	r6,0
800041fc:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800041fe:	6e 1b       	ld.w	r11,r7[0x4]
80004200:	6e 0c       	ld.w	r12,r7[0x0]
80004202:	f0 1f 00 06 	mcall	80004218 <gpio_enable_module+0x2c>
80004206:	18 45       	or	r5,r12
		gpiomap++;
80004208:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000420a:	2f f6       	sub	r6,-1
8000420c:	0c 34       	cp.w	r4,r6
8000420e:	fe 9b ff f8 	brhi	800041fe <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80004212:	0a 9c       	mov	r12,r5
80004214:	d8 22       	popm	r4-r7,pc
80004216:	00 00       	add	r0,r0
80004218:	80 00       	ld.sh	r0,r0[0x0]
8000421a:	41 9a       	lddsp	r10,sp[0x64]

8000421c <gpio_enable_gpio_pin>:
 *            AVR32_PWM_3_PIN for PWM channel 3 can also be used to release
 *            module pins for GPIO.
 */
void gpio_enable_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000421c:	f8 08 16 05 	lsr	r8,r12,0x5
80004220:	a9 68       	lsl	r8,0x8
80004222:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->oderc = 1 << (pin & 0x1F);
80004226:	30 19       	mov	r9,1
80004228:	f2 0c 09 4c 	lsl	r12,r9,r12
8000422c:	f1 4c 00 48 	st.w	r8[72],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80004230:	91 1c       	st.w	r8[0x4],r12
}
80004232:	5e fc       	retal	r12

80004234 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004234:	f8 08 16 05 	lsr	r8,r12,0x5
80004238:	a9 68       	lsl	r8,0x8
8000423a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000423e:	30 19       	mov	r9,1
80004240:	f2 0c 09 4c 	lsl	r12,r9,r12
80004244:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80004248:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000424c:	91 1c       	st.w	r8[0x4],r12
}
8000424e:	5e fc       	retal	r12

80004250 <gpio_clr_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_clr_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80004250:	f8 08 16 05 	lsr	r8,r12,0x5
80004254:	a9 68       	lsl	r8,0x8
80004256:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000425a:	30 19       	mov	r9,1
8000425c:	f2 0c 09 4c 	lsl	r12,r9,r12
80004260:	f1 4c 00 58 	st.w	r8[88],r12
	/* The GPIO output driver is enabled for that pin. */
	gpio_port->oders = 1 << (pin & 0x1F);
80004264:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
80004268:	91 1c       	st.w	r8[0x4],r12
}
8000426a:	5e fc       	retal	r12

8000426c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000426c:	c0 08       	rjmp	8000426c <_unhandled_interrupt>
8000426e:	d7 03       	nop

80004270 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80004270:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80004274:	49 99       	lddpc	r9,800042d8 <INTC_register_interrupt+0x68>
80004276:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000427a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000427e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80004280:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80004284:	58 0a       	cp.w	r10,0
80004286:	c0 91       	brne	80004298 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004288:	49 59       	lddpc	r9,800042dc <INTC_register_interrupt+0x6c>
8000428a:	49 6a       	lddpc	r10,800042e0 <INTC_register_interrupt+0x70>
8000428c:	12 1a       	sub	r10,r9
8000428e:	fe 79 08 00 	mov	r9,-63488
80004292:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80004296:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80004298:	58 1a       	cp.w	r10,1
8000429a:	c0 a1       	brne	800042ae <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000429c:	49 09       	lddpc	r9,800042dc <INTC_register_interrupt+0x6c>
8000429e:	49 2a       	lddpc	r10,800042e4 <INTC_register_interrupt+0x74>
800042a0:	12 1a       	sub	r10,r9
800042a2:	bf aa       	sbr	r10,0x1e
800042a4:	fe 79 08 00 	mov	r9,-63488
800042a8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800042ac:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800042ae:	58 2a       	cp.w	r10,2
800042b0:	c0 a1       	brne	800042c4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800042b2:	48 b9       	lddpc	r9,800042dc <INTC_register_interrupt+0x6c>
800042b4:	48 da       	lddpc	r10,800042e8 <INTC_register_interrupt+0x78>
800042b6:	12 1a       	sub	r10,r9
800042b8:	bf ba       	sbr	r10,0x1f
800042ba:	fe 79 08 00 	mov	r9,-63488
800042be:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800042c2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800042c4:	48 69       	lddpc	r9,800042dc <INTC_register_interrupt+0x6c>
800042c6:	48 aa       	lddpc	r10,800042ec <INTC_register_interrupt+0x7c>
800042c8:	12 1a       	sub	r10,r9
800042ca:	ea 1a c0 00 	orh	r10,0xc000
800042ce:	fe 79 08 00 	mov	r9,-63488
800042d2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800042d6:	5e fc       	retal	r12
800042d8:	80 00       	ld.sh	r0,r0[0x0]
800042da:	c6 58       	rjmp	800043a4 <pm_enable_osc0_crystal+0x1c>
800042dc:	80 00       	ld.sh	r0,r0[0x0]
800042de:	ba 00       	st.h	sp[0x0],r0
800042e0:	80 00       	ld.sh	r0,r0[0x0]
800042e2:	bb 04       	ld.d	r4,sp
800042e4:	80 00       	ld.sh	r0,r0[0x0]
800042e6:	bb 12       	ld.d	r2,--sp
800042e8:	80 00       	ld.sh	r0,r0[0x0]
800042ea:	bb 20       	st.d	sp++,r0
800042ec:	80 00       	ld.sh	r0,r0[0x0]
800042ee:	bb 2e       	st.d	sp++,lr

800042f0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800042f0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800042f2:	49 18       	lddpc	r8,80004334 <INTC_init_interrupts+0x44>
800042f4:	e3 b8 00 01 	mtsr	0x4,r8
800042f8:	49 0e       	lddpc	lr,80004338 <INTC_init_interrupts+0x48>
800042fa:	30 07       	mov	r7,0
800042fc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800042fe:	49 0c       	lddpc	r12,8000433c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80004300:	49 05       	lddpc	r5,80004340 <INTC_init_interrupts+0x50>
80004302:	10 15       	sub	r5,r8
80004304:	fe 76 08 00 	mov	r6,-63488
80004308:	c1 08       	rjmp	80004328 <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000430a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000430c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000430e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80004310:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80004314:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004316:	10 3a       	cp.w	r10,r8
80004318:	fe 9b ff fc 	brhi	80004310 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000431c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80004320:	2f f7       	sub	r7,-1
80004322:	2f 8e       	sub	lr,-8
80004324:	59 37       	cp.w	r7,19
80004326:	c0 50       	breq	80004330 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80004328:	7c 08       	ld.w	r8,lr[0x0]
8000432a:	58 08       	cp.w	r8,0
8000432c:	ce f1       	brne	8000430a <INTC_init_interrupts+0x1a>
8000432e:	cf 7b       	rjmp	8000431c <INTC_init_interrupts+0x2c>
80004330:	d8 22       	popm	r4-r7,pc
80004332:	00 00       	add	r0,r0
80004334:	80 00       	ld.sh	r0,r0[0x0]
80004336:	ba 00       	st.h	sp[0x0],r0
80004338:	80 00       	ld.sh	r0,r0[0x0]
8000433a:	c6 58       	rjmp	80004404 <pm_set_osc32_mode+0x8>
8000433c:	80 00       	ld.sh	r0,r0[0x0]
8000433e:	42 6c       	lddsp	r12,sp[0x98]
80004340:	80 00       	ld.sh	r0,r0[0x0]
80004342:	bb 04       	ld.d	r4,sp

80004344 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004344:	fe 78 08 00 	mov	r8,-63488
80004348:	e0 69 00 83 	mov	r9,131
8000434c:	f2 0c 01 0c 	sub	r12,r9,r12
80004350:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80004354:	f2 ca ff c0 	sub	r10,r9,-64
80004358:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000435c:	58 08       	cp.w	r8,0
8000435e:	c0 21       	brne	80004362 <_get_interrupt_handler+0x1e>
80004360:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80004362:	f0 08 12 00 	clz	r8,r8
80004366:	48 5a       	lddpc	r10,80004378 <_get_interrupt_handler+0x34>
80004368:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000436c:	f0 08 11 1f 	rsub	r8,r8,31
80004370:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80004372:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80004376:	5e fc       	retal	r12
80004378:	80 00       	ld.sh	r0,r0[0x0]
8000437a:	c6 58       	rjmp	80004444 <pm_enable_clk32+0x10>

8000437c <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000437c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
8000437e:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80004382:	99 a8       	st.w	r12[0x28],r8
}
80004384:	5e fc       	retal	r12
80004386:	d7 03       	nop

80004388 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80004388:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
8000438a:	ec 5b bb 9f 	cp.w	r11,899999
8000438e:	e0 8b 00 04 	brhi	80004396 <pm_enable_osc0_crystal+0xe>
80004392:	30 4b       	mov	r11,4
80004394:	c1 38       	rjmp	800043ba <pm_enable_osc0_crystal+0x32>
80004396:	e0 68 c6 bf 	mov	r8,50879
8000439a:	ea 18 00 2d 	orh	r8,0x2d
8000439e:	10 3b       	cp.w	r11,r8
800043a0:	e0 8b 00 04 	brhi	800043a8 <pm_enable_osc0_crystal+0x20>
800043a4:	30 5b       	mov	r11,5
800043a6:	c0 a8       	rjmp	800043ba <pm_enable_osc0_crystal+0x32>
800043a8:	e0 68 12 00 	mov	r8,4608
800043ac:	ea 18 00 7a 	orh	r8,0x7a
800043b0:	10 3b       	cp.w	r11,r8
800043b2:	f9 bb 03 06 	movlo	r11,6
800043b6:	f9 bb 02 07 	movhs	r11,7
800043ba:	f0 1f 00 02 	mcall	800043c0 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
800043be:	d8 02       	popm	pc
800043c0:	80 00       	ld.sh	r0,r0[0x0]
800043c2:	43 7c       	lddsp	r12,sp[0xdc]

800043c4 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800043c4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
800043c6:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800043ca:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
800043cc:	78 08       	ld.w	r8,r12[0x0]
800043ce:	a3 a8       	sbr	r8,0x2
800043d0:	99 08       	st.w	r12[0x0],r8
}
800043d2:	5e fc       	retal	r12

800043d4 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
800043d4:	79 58       	ld.w	r8,r12[0x54]
800043d6:	e2 18 00 80 	andl	r8,0x80,COH
800043da:	cf d0       	breq	800043d4 <pm_wait_for_clk0_ready>
}
800043dc:	5e fc       	retal	r12
800043de:	d7 03       	nop

800043e0 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
800043e0:	eb cd 40 80 	pushm	r7,lr
800043e4:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
800043e6:	f0 1f 00 04 	mcall	800043f4 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
800043ea:	0e 9c       	mov	r12,r7
800043ec:	f0 1f 00 03 	mcall	800043f8 <pm_enable_clk0+0x18>
}
800043f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800043f4:	80 00       	ld.sh	r0,r0[0x0]
800043f6:	43 c4       	lddsp	r4,sp[0xf0]
800043f8:	80 00       	ld.sh	r0,r0[0x0]
800043fa:	43 d4       	lddsp	r4,sp[0xf4]

800043fc <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
800043fc:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
800043fe:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80004402:	99 c8       	st.w	r12[0x30],r8
}
80004404:	5e fc       	retal	r12
80004406:	d7 03       	nop

80004408 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80004408:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
8000440a:	30 1b       	mov	r11,1
8000440c:	f0 1f 00 02 	mcall	80004414 <pm_enable_osc32_crystal+0xc>
}
80004410:	d8 02       	popm	pc
80004412:	00 00       	add	r0,r0
80004414:	80 00       	ld.sh	r0,r0[0x0]
80004416:	43 fc       	lddsp	r12,sp[0xfc]

80004418 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80004418:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
8000441a:	30 19       	mov	r9,1
8000441c:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80004420:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
80004424:	99 c8       	st.w	r12[0x30],r8
}
80004426:	5e fc       	retal	r12

80004428 <pm_wait_for_clk32_ready>:


void pm_wait_for_clk32_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC32RDY_MASK));
80004428:	79 58       	ld.w	r8,r12[0x54]
8000442a:	e2 18 02 00 	andl	r8,0x200,COH
8000442e:	cf d0       	breq	80004428 <pm_wait_for_clk32_ready>
}
80004430:	5e fc       	retal	r12
80004432:	d7 03       	nop

80004434 <pm_enable_clk32>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
}


void pm_enable_clk32(volatile avr32_pm_t *pm, unsigned int startup)
{
80004434:	eb cd 40 80 	pushm	r7,lr
80004438:	18 97       	mov	r7,r12
  pm_enable_clk32_no_wait(pm, startup);
8000443a:	f0 1f 00 04 	mcall	80004448 <pm_enable_clk32+0x14>
  pm_wait_for_clk32_ready(pm);
8000443e:	0e 9c       	mov	r12,r7
80004440:	f0 1f 00 03 	mcall	8000444c <pm_enable_clk32+0x18>
}
80004444:	e3 cd 80 80 	ldm	sp++,r7,pc
80004448:	80 00       	ld.sh	r0,r0[0x0]
8000444a:	44 18       	lddsp	r8,sp[0x104]
8000444c:	80 00       	ld.sh	r0,r0[0x0]
8000444e:	44 28       	lddsp	r8,sp[0x108]

80004450 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80004450:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80004454:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80004458:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000445a:	09 f7       	ld.ub	r7,r4[0x7]
8000445c:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
80004460:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80004464:	09 b4       	ld.ub	r4,r4[0x3]
80004466:	08 96       	mov	r6,r4
80004468:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
8000446c:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80004470:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80004474:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80004478:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
8000447c:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
80004480:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80004484:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
80004488:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
8000448a:	79 58       	ld.w	r8,r12[0x54]
8000448c:	e2 18 00 20 	andl	r8,0x20,COH
80004490:	cf d0       	breq	8000448a <pm_cksel+0x3a>
}
80004492:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

80004496 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80004496:	eb cd 40 80 	pushm	r7,lr
8000449a:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
8000449c:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000449e:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
800044a2:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
800044a6:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
800044aa:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
800044ae:	2f 8b       	sub	r11,-8
800044b0:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800044b4:	e3 cd 80 80 	ldm	sp++,r7,pc

800044b8 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
800044b8:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
800044ba:	2f 8b       	sub	r11,-8
800044bc:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
800044c0:	f5 e9 10 19 	or	r9,r10,r9<<0x1
800044c4:	f3 e8 10 28 	or	r8,r9,r8<<0x2
800044c8:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
800044cc:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800044d0:	d8 02       	popm	pc

800044d2 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800044d2:	2f 8b       	sub	r11,-8
800044d4:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800044d8:	a1 a8       	sbr	r8,0x0
800044da:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
800044de:	5e fc       	retal	r12

800044e0 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
800044e0:	79 58       	ld.w	r8,r12[0x54]
800044e2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800044e6:	cf d0       	breq	800044e0 <pm_wait_for_pll0_locked>
}
800044e8:	5e fc       	retal	r12

800044ea <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
800044ea:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
800044ec:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
800044f0:	99 08       	st.w	r12[0x0],r8
}
800044f2:	5e fc       	retal	r12

800044f4 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
800044f4:	eb cd 40 c0 	pushm	r6-r7,lr
800044f8:	18 97       	mov	r7,r12
800044fa:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
800044fc:	f0 1f 00 06 	mcall	80004514 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80004500:	0c 9b       	mov	r11,r6
80004502:	0e 9c       	mov	r12,r7
80004504:	f0 1f 00 05 	mcall	80004518 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80004508:	30 1b       	mov	r11,1
8000450a:	0e 9c       	mov	r12,r7
8000450c:	f0 1f 00 04 	mcall	8000451c <pm_switch_to_osc0+0x28>
}
80004510:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004514:	80 00       	ld.sh	r0,r0[0x0]
80004516:	43 88       	lddsp	r8,sp[0xe0]
80004518:	80 00       	ld.sh	r0,r0[0x0]
8000451a:	43 e0       	lddsp	r0,sp[0xf8]
8000451c:	80 00       	ld.sh	r0,r0[0x0]
8000451e:	44 ea       	lddsp	r10,sp[0x138]

80004520 <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80004520:	78 0c       	ld.w	r12,r12[0x0]
}
80004522:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80004526:	5e fc       	retal	r12

80004528 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80004528:	eb cd 40 c0 	pushm	r6-r7,lr
8000452c:	18 97       	mov	r7,r12
8000452e:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80004530:	0e 9c       	mov	r12,r7
80004532:	f0 1f 00 06 	mcall	80004548 <rtc_set_value+0x20>
80004536:	cf d1       	brne	80004530 <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80004538:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000453a:	0e 9c       	mov	r12,r7
8000453c:	f0 1f 00 03 	mcall	80004548 <rtc_set_value+0x20>
80004540:	cf d1       	brne	8000453a <rtc_set_value+0x12>
}
80004542:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004546:	00 00       	add	r0,r0
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	45 20       	lddsp	r0,sp[0x148]

8000454c <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
8000454c:	eb cd 40 80 	pushm	r7,lr
80004550:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
80004552:	0e 9c       	mov	r12,r7
80004554:	f0 1f 00 06 	mcall	8000456c <rtc_enable+0x20>
80004558:	cf d1       	brne	80004552 <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
8000455a:	6e 08       	ld.w	r8,r7[0x0]
8000455c:	a1 a8       	sbr	r8,0x0
8000455e:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80004560:	0e 9c       	mov	r12,r7
80004562:	f0 1f 00 03 	mcall	8000456c <rtc_enable+0x20>
80004566:	cf d1       	brne	80004560 <rtc_enable+0x14>
}
80004568:	e3 cd 80 80 	ldm	sp++,r7,pc
8000456c:	80 00       	ld.sh	r0,r0[0x0]
8000456e:	45 20       	lddsp	r0,sp[0x148]

80004570 <rtc_enable_interrupt>:
}


void rtc_enable_interrupt(volatile avr32_rtc_t *rtc)
{
  rtc->ier = AVR32_RTC_IER_TOPI_MASK;
80004570:	30 18       	mov	r8,1
80004572:	99 48       	st.w	r12[0x10],r8
}
80004574:	5e fc       	retal	r12
80004576:	d7 03       	nop

80004578 <rtc_set_top_value>:
  if (global_interrupt_enabled) cpu_irq_enable();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80004578:	eb cd 40 c0 	pushm	r6-r7,lr
8000457c:	18 97       	mov	r7,r12
8000457e:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80004580:	0e 9c       	mov	r12,r7
80004582:	f0 1f 00 06 	mcall	80004598 <rtc_set_top_value+0x20>
80004586:	cf d1       	brne	80004580 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80004588:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
8000458a:	0e 9c       	mov	r12,r7
8000458c:	f0 1f 00 03 	mcall	80004598 <rtc_set_top_value+0x20>
80004590:	cf d1       	brne	8000458a <rtc_set_top_value+0x12>
}
80004592:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004596:	00 00       	add	r0,r0
80004598:	80 00       	ld.sh	r0,r0[0x0]
8000459a:	45 20       	lddsp	r0,sp[0x148]

8000459c <rtc_clear_interrupt>:
}


void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
8000459c:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) cpu_irq_disable();
800045a0:	e6 18 00 01 	andh	r8,0x1,COH
800045a4:	c0 71       	brne	800045b2 <rtc_clear_interrupt+0x16>
800045a6:	d3 03       	ssrf	0x10
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
800045a8:	30 18       	mov	r8,1
800045aa:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
800045ac:	78 78       	ld.w	r8,r12[0x1c]
  if (global_interrupt_enabled) cpu_irq_enable();
800045ae:	d5 03       	csrf	0x10
800045b0:	5e fc       	retal	r12
void rtc_clear_interrupt(volatile avr32_rtc_t *rtc)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  if (global_interrupt_enabled) cpu_irq_disable();
  rtc->icr = AVR32_RTC_ICR_TOPI_MASK;
800045b2:	30 18       	mov	r8,1
800045b4:	99 88       	st.w	r12[0x20],r8
  rtc->isr;
800045b6:	78 78       	ld.w	r8,r12[0x1c]
800045b8:	5e fc       	retal	r12
800045ba:	d7 03       	nop

800045bc <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
800045bc:	eb cd 40 e0 	pushm	r5-r7,lr
800045c0:	18 97       	mov	r7,r12
800045c2:	16 96       	mov	r6,r11
800045c4:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
800045c6:	30 18       	mov	r8,1
800045c8:	f0 0b 18 00 	cp.b	r11,r8
800045cc:	5f b9       	srhi	r9
800045ce:	30 f8       	mov	r8,15
800045d0:	f0 0a 18 00 	cp.b	r10,r8
800045d4:	5f b8       	srhi	r8
800045d6:	f3 e8 10 08 	or	r8,r9,r8
800045da:	c0 30       	breq	800045e0 <rtc_init+0x24>
800045dc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
800045e0:	30 18       	mov	r8,1
800045e2:	f0 0b 18 00 	cp.b	r11,r8
800045e6:	c0 a1       	brne	800045fa <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
800045e8:	fe 7c 0c 00 	mov	r12,-62464
800045ec:	f0 1f 00 0f 	mcall	80004628 <rtc_init+0x6c>
    // Enable the 32-kHz clock and wait until the osc32 clock is ready.
    pm_enable_clk32(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
800045f0:	30 0b       	mov	r11,0
800045f2:	fe 7c 0c 00 	mov	r12,-62464
800045f6:	f0 1f 00 0e 	mcall	8000462c <rtc_init+0x70>
  }

  // Wait until the rtc accepts writes to the CTRL register
  while (rtc_is_busy(rtc));
800045fa:	0e 9c       	mov	r12,r7
800045fc:	f0 1f 00 0d 	mcall	80004630 <rtc_init+0x74>
80004600:	cf d1       	brne	800045fa <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80004602:	a3 76       	lsl	r6,0x3
80004604:	b1 a6       	sbr	r6,0x10
80004606:	ed e5 10 85 	or	r5,r6,r5<<0x8
8000460a:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
8000460c:	0e 9c       	mov	r12,r7
8000460e:	f0 1f 00 09 	mcall	80004630 <rtc_init+0x74>
80004612:	cf d1       	brne	8000460c <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80004614:	30 0b       	mov	r11,0
80004616:	0e 9c       	mov	r12,r7
80004618:	f0 1f 00 07 	mcall	80004634 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
8000461c:	3f fb       	mov	r11,-1
8000461e:	0e 9c       	mov	r12,r7
80004620:	f0 1f 00 06 	mcall	80004638 <rtc_init+0x7c>
80004624:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004628:	80 00       	ld.sh	r0,r0[0x0]
8000462a:	44 08       	lddsp	r8,sp[0x100]
8000462c:	80 00       	ld.sh	r0,r0[0x0]
8000462e:	44 34       	lddsp	r4,sp[0x10c]
80004630:	80 00       	ld.sh	r0,r0[0x0]
80004632:	45 20       	lddsp	r0,sp[0x148]
80004634:	80 00       	ld.sh	r0,r0[0x0]
80004636:	45 28       	lddsp	r8,sp[0x148]
80004638:	80 00       	ld.sh	r0,r0[0x0]
8000463a:	45 78       	lddsp	r8,sp[0x15c]

8000463c <getBaudDiv>:
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
8000463c:	f8 c8 00 01 	sub	r8,r12,1
80004640:	f0 0b 00 0b 	add	r11,r8,r11
80004644:	f6 0c 0d 0a 	divu	r10,r11,r12
80004648:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
8000464a:	f4 c8 00 01 	sub	r8,r10,1
8000464e:	e0 48 00 fe 	cp.w	r8,254
80004652:	e0 88 00 03 	brls	80004658 <getBaudDiv+0x1c>
80004656:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80004658:	5c 8c       	casts.h	r12
}
8000465a:	5e fc       	retal	r12

8000465c <spi_initMaster>:
spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
8000465c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004660:	30 18       	mov	r8,1
80004662:	f0 09 18 00 	cp.b	r9,r8
80004666:	e0 88 00 04 	brls	8000466e <spi_initMaster+0x12>
8000466a:	30 2c       	mov	r12,2
8000466c:	5e fc       	retal	r12
		return SPI_ERROR_ARGUMENT;
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000466e:	e0 68 00 80 	mov	r8,128
80004672:	99 08       	st.w	r12[0x0],r8

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80004674:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.mstr = 1;
80004676:	30 19       	mov	r9,1
80004678:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
8000467c:	f7 39 00 0d 	ld.ub	r9,r11[13]
80004680:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
	u_avr32_spi_mr.MR.llb = 0;
80004684:	30 09       	mov	r9,0
80004686:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
8000468a:	30 fa       	mov	r10,15
8000468c:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
	spi->mr = u_avr32_spi_mr.mr;
80004690:	99 18       	st.w	r12[0x4],r8
80004692:	5e f9       	retal	r9

80004694 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
80004694:	d4 01       	pushm	lr
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80004696:	30 18       	mov	r8,1
80004698:	f0 0b 18 00 	cp.b	r11,r8
8000469c:	5f be       	srhi	lr
8000469e:	f0 0a 18 00 	cp.b	r10,r8
800046a2:	5f b8       	srhi	r8
800046a4:	fd e8 10 08 	or	r8,lr,r8
800046a8:	c0 30       	breq	800046ae <spi_selectionMode+0x1a>
800046aa:	30 2c       	mov	r12,2
800046ac:	d8 02       	popm	pc
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
	}

	u_avr32_spi_mr.mr = spi->mr;
800046ae:	78 18       	ld.w	r8,r12[0x4]
	u_avr32_spi_mr.MR.ps = variable_ps;
800046b0:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
800046b4:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
	u_avr32_spi_mr.MR.dlybcs = delay;
800046b8:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
	spi->mr = u_avr32_spi_mr.mr;
800046bc:	99 18       	st.w	r12[0x4],r8
800046be:	d8 0a       	popm	pc,r12=0

800046c0 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
800046c0:	30 18       	mov	r8,1
800046c2:	99 08       	st.w	r12[0x0],r8
}
800046c4:	5e fc       	retal	r12

800046c6 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
800046c6:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800046ca:	c0 58       	rjmp	800046d4 <spi_write+0xe>
		if (!timeout--) {
800046cc:	58 08       	cp.w	r8,0
800046ce:	c0 21       	brne	800046d2 <spi_write+0xc>
800046d0:	5e ff       	retal	1
800046d2:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
800046d4:	78 49       	ld.w	r9,r12[0x10]
800046d6:	e2 19 00 02 	andl	r9,0x2,COH
800046da:	cf 90       	breq	800046cc <spi_write+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
800046dc:	5c 7b       	castu.h	r11
800046de:	99 3b       	st.w	r12[0xc],r11
800046e0:	5e fd       	retal	0

800046e2 <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
800046e2:	e0 68 3a 98 	mov	r8,15000
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800046e6:	c0 58       	rjmp	800046f0 <spi_read+0xe>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
800046e8:	58 08       	cp.w	r8,0
800046ea:	c0 21       	brne	800046ee <spi_read+0xc>
800046ec:	5e ff       	retal	1
800046ee:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
800046f0:	78 49       	ld.w	r9,r12[0x10]
800046f2:	e2 19 02 01 	andl	r9,0x201,COH
800046f6:	e0 49 02 01 	cp.w	r9,513
800046fa:	cf 71       	brne	800046e8 <spi_read+0x6>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
800046fc:	78 28       	ld.w	r8,r12[0x8]
800046fe:	b6 08       	st.h	r11[0x0],r8
80004700:	5e fd       	retal	0
80004702:	d7 03       	nop

80004704 <spi_setupChipReg>:
}

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80004704:	eb cd 40 f8 	pushm	r3-r7,lr
80004708:	18 95       	mov	r5,r12
8000470a:	16 97       	mov	r7,r11
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000470c:	f7 36 00 0c 	ld.ub	r6,r11[12]
80004710:	30 38       	mov	r8,3
80004712:	f0 06 18 00 	cp.b	r6,r8
80004716:	e0 8b 00 5e 	brhi	800047d2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
8000471a:	f7 34 00 0b 	ld.ub	r4,r11[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000471e:	30 18       	mov	r8,1
80004720:	f0 04 18 00 	cp.b	r4,r8
80004724:	e0 8b 00 57 	brhi	800047d2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80004728:	f7 33 00 08 	ld.ub	r3,r11[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
8000472c:	30 78       	mov	r8,7
8000472e:	f0 03 18 00 	cp.b	r3,r8
80004732:	e0 88 00 50 	brls	800047d2 <spi_setupChipReg+0xce>
80004736:	31 08       	mov	r8,16
80004738:	f0 03 18 00 	cp.b	r3,r8
8000473c:	e0 8b 00 4b 	brhi	800047d2 <spi_setupChipReg+0xce>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80004740:	14 9b       	mov	r11,r10
80004742:	6e 1c       	ld.w	r12,r7[0x4]
80004744:	f0 1f 00 26 	mcall	800047dc <spi_setupChipReg+0xd8>

	if (baudDiv < 0) {
80004748:	c4 55       	brlt	800047d2 <spi_setupChipReg+0xce>
		return SPI_ERROR_ARGUMENT;
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
8000474a:	30 08       	mov	r8,0
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
8000474c:	ec 09 16 01 	lsr	r9,r6,0x1
80004750:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80004754:	ec 16 00 01 	eorl	r6,0x1
80004758:	f1 d6 d0 21 	bfins	r8,r6,0x1,0x1
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
8000475c:	f1 d4 d0 61 	bfins	r8,r4,0x3,0x1
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80004760:	20 83       	sub	r3,8
80004762:	f1 d3 d0 84 	bfins	r8,r3,0x4,0x4
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80004766:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
8000476a:	ef 39 00 09 	ld.ub	r9,r7[9]
8000476e:	f1 d9 d2 08 	bfins	r8,r9,0x10,0x8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80004772:	ef 39 00 0a 	ld.ub	r9,r7[10]
80004776:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8

	switch (options->reg) {
8000477a:	0f 89       	ld.ub	r9,r7[0x0]
8000477c:	30 1a       	mov	r10,1
8000477e:	f4 09 18 00 	cp.b	r9,r10
80004782:	c0 d0       	breq	8000479c <spi_setupChipReg+0x98>
80004784:	c0 a3       	brcs	80004798 <spi_setupChipReg+0x94>
80004786:	30 2a       	mov	r10,2
80004788:	f4 09 18 00 	cp.b	r9,r10
8000478c:	c0 a0       	breq	800047a0 <spi_setupChipReg+0x9c>
8000478e:	30 3a       	mov	r10,3
80004790:	f4 09 18 00 	cp.b	r9,r10
80004794:	c1 f1       	brne	800047d2 <spi_setupChipReg+0xce>
80004796:	c0 78       	rjmp	800047a4 <spi_setupChipReg+0xa0>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80004798:	8b c8       	st.w	r5[0x30],r8
		break;
8000479a:	c0 68       	rjmp	800047a6 <spi_setupChipReg+0xa2>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
8000479c:	8b d8       	st.w	r5[0x34],r8
		break;
8000479e:	c0 48       	rjmp	800047a6 <spi_setupChipReg+0xa2>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
800047a0:	8b e8       	st.w	r5[0x38],r8
		break;
800047a2:	c0 28       	rjmp	800047a6 <spi_setupChipReg+0xa2>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
800047a4:	8b f8       	st.w	r5[0x3c],r8
	default:
		return SPI_ERROR_ARGUMENT;
	}

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800047a6:	48 f8       	lddpc	r8,800047e0 <spi_setupChipReg+0xdc>
800047a8:	70 08       	ld.w	r8,r8[0x0]
800047aa:	58 08       	cp.w	r8,0
800047ac:	c1 61       	brne	800047d8 <spi_setupChipReg+0xd4>
		/* Create the SPI mutex. */
		vSemaphoreCreateBinary(xSPIMutex);
800047ae:	30 0b       	mov	r11,0
800047b0:	30 1c       	mov	r12,1
800047b2:	f0 1f 00 0d 	mcall	800047e4 <spi_setupChipReg+0xe0>
800047b6:	48 b8       	lddpc	r8,800047e0 <spi_setupChipReg+0xdc>
800047b8:	91 0c       	st.w	r8[0x0],r12
800047ba:	58 0c       	cp.w	r12,0
800047bc:	c0 a0       	breq	800047d0 <spi_setupChipReg+0xcc>
800047be:	30 09       	mov	r9,0
800047c0:	12 9a       	mov	r10,r9
800047c2:	12 9b       	mov	r11,r9
800047c4:	f0 1f 00 09 	mcall	800047e8 <spi_setupChipReg+0xe4>
		if (!xSPIMutex) {
800047c8:	48 68       	lddpc	r8,800047e0 <spi_setupChipReg+0xdc>
800047ca:	70 08       	ld.w	r8,r8[0x0]
800047cc:	58 08       	cp.w	r8,0
800047ce:	c0 51       	brne	800047d8 <spi_setupChipReg+0xd4>
800047d0:	c0 08       	rjmp	800047d0 <spi_setupChipReg+0xcc>
800047d2:	30 2c       	mov	r12,2
800047d4:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800047d8:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800047dc:	80 00       	ld.sh	r0,r0[0x0]
800047de:	46 3c       	lddsp	r12,sp[0x18c]
800047e0:	00 00       	add	r0,r0
800047e2:	1f 98       	ld.ub	r8,pc[0x1]
800047e4:	80 00       	ld.sh	r0,r0[0x0]
800047e6:	52 88       	stdsp	sp[0xa0],r8
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	51 30       	stdsp	sp[0x4c],r0

800047ec <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
800047ec:	d4 01       	pushm	lr
800047ee:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800047f2:	c0 58       	rjmp	800047fc <spi_unselectChip+0x10>
		if (!timeout--) {
800047f4:	58 08       	cp.w	r8,0
800047f6:	c0 21       	brne	800047fa <spi_unselectChip+0xe>
800047f8:	da 0a       	popm	pc,r12=1
800047fa:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
800047fc:	78 49       	ld.w	r9,r12[0x10]
800047fe:	e2 19 02 00 	andl	r9,0x200,COH
80004802:	cf 90       	breq	800047f4 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004804:	78 18       	ld.w	r8,r12[0x4]
80004806:	ea 18 00 0f 	orh	r8,0xf
8000480a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000480c:	fc 18 01 00 	movh	r8,0x100
80004810:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80004812:	30 09       	mov	r9,0
80004814:	12 9a       	mov	r10,r9
80004816:	12 9b       	mov	r11,r9
80004818:	48 38       	lddpc	r8,80004824 <spi_unselectChip+0x38>
8000481a:	70 0c       	ld.w	r12,r8[0x0]
8000481c:	f0 1f 00 03 	mcall	80004828 <spi_unselectChip+0x3c>
80004820:	d8 0a       	popm	pc,r12=0
80004822:	00 00       	add	r0,r0
80004824:	00 00       	add	r0,r0
80004826:	1f 98       	ld.ub	r8,pc[0x1]
80004828:	80 00       	ld.sh	r0,r0[0x0]
8000482a:	51 30       	stdsp	sp[0x4c],r0

8000482c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000482c:	eb cd 40 f8 	pushm	r3-r7,lr
80004830:	18 94       	mov	r4,r12
80004832:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80004834:	49 a6       	lddpc	r6,8000489c <spi_selectChip+0x70>
80004836:	30 07       	mov	r7,0
80004838:	31 45       	mov	r5,20
8000483a:	0e 99       	mov	r9,r7
8000483c:	0a 9a       	mov	r10,r5
8000483e:	0e 9b       	mov	r11,r7
80004840:	6c 0c       	ld.w	r12,r6[0x0]
80004842:	f0 1f 00 18 	mcall	800048a0 <spi_selectChip+0x74>
80004846:	cf a0       	breq	8000483a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80004848:	68 18       	ld.w	r8,r4[0x4]
8000484a:	ea 18 00 0f 	orh	r8,0xf
8000484e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80004850:	68 18       	ld.w	r8,r4[0x4]
80004852:	e2 18 00 04 	andl	r8,0x4,COH
80004856:	c1 10       	breq	80004878 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80004858:	30 e8       	mov	r8,14
8000485a:	f0 03 18 00 	cp.b	r3,r8
8000485e:	e0 8b 00 1c 	brhi	80004896 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80004862:	68 19       	ld.w	r9,r4[0x4]
80004864:	e6 08 15 10 	lsl	r8,r3,0x10
80004868:	ea 18 ff f0 	orh	r8,0xfff0
8000486c:	e8 18 ff ff 	orl	r8,0xffff
80004870:	12 68       	and	r8,r9
80004872:	89 18       	st.w	r4[0x4],r8
80004874:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80004878:	30 38       	mov	r8,3
8000487a:	f0 03 18 00 	cp.b	r3,r8
8000487e:	e0 8b 00 0c 	brhi	80004896 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80004882:	68 19       	ld.w	r9,r4[0x4]
80004884:	2f 03       	sub	r3,-16
80004886:	30 18       	mov	r8,1
80004888:	f0 03 09 48 	lsl	r8,r8,r3
8000488c:	5c d8       	com	r8
8000488e:	12 68       	and	r8,r9
80004890:	89 18       	st.w	r4[0x4],r8
80004892:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80004896:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
80004898:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
8000489c:	00 00       	add	r0,r0
8000489e:	1f 98       	ld.ub	r8,pc[0x1]
800048a0:	80 00       	ld.sh	r0,r0[0x0]
800048a2:	4f 74       	lddpc	r4,80004a7c <usart_init_rs232+0x9c>

800048a4 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
800048a4:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
800048a6:	f6 08 15 04 	lsl	r8,r11,0x4
800048aa:	14 38       	cp.w	r8,r10
800048ac:	f9 b8 08 10 	movls	r8,16
800048b0:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
800048b4:	f0 0b 02 4b 	mul	r11,r8,r11
800048b8:	f6 09 16 01 	lsr	r9,r11,0x1
800048bc:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
800048c0:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
800048c4:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
800048c8:	f2 cb 00 01 	sub	r11,r9,1
800048cc:	e0 4b ff fe 	cp.w	r11,65534
800048d0:	e0 88 00 03 	brls	800048d6 <usart_set_async_baudrate+0x32>
800048d4:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
800048d6:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
800048d8:	e8 6e 00 00 	mov	lr,524288
800048dc:	59 08       	cp.w	r8,16
800048de:	fc 08 17 10 	movne	r8,lr
800048e2:	f9 b8 00 00 	moveq	r8,0
800048e6:	e4 1b ff f7 	andh	r11,0xfff7
800048ea:	e0 1b fe cf 	andl	r11,0xfecf
800048ee:	16 48       	or	r8,r11
800048f0:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
800048f2:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
800048f6:	f3 ea 11 09 	or	r9,r9,r10<<0x10
800048fa:	99 89       	st.w	r12[0x20],r9
800048fc:	d8 0a       	popm	pc,r12=0

800048fe <usart_write_char>:
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800048fe:	78 58       	ld.w	r8,r12[0x14]
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
  if (usart_tx_ready(usart))
80004900:	e2 18 00 02 	andl	r8,0x2,COH
80004904:	c0 31       	brne	8000490a <usart_write_char+0xc>
80004906:	30 2c       	mov	r12,2
80004908:	5e fc       	retal	r12
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
8000490a:	f7 db c0 09 	bfextu	r11,r11,0x0,0x9
8000490e:	99 7b       	st.w	r12[0x1c],r11
80004910:	5e fd       	retal	0
80004912:	d7 03       	nop

80004914 <usart_putchar>:
    return USART_TX_BUSY;
}


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004914:	eb cd 40 e0 	pushm	r5-r7,lr
80004918:	18 96       	mov	r6,r12
8000491a:	16 95       	mov	r5,r11
8000491c:	e0 67 27 0f 	mov	r7,9999
80004920:	c0 68       	rjmp	8000492c <usart_putchar+0x18>
  int timeout = USART_DEFAULT_TIMEOUT;

  do
  {
    if (!timeout--) return USART_FAILURE;
80004922:	58 07       	cp.w	r7,0
80004924:	c0 31       	brne	8000492a <usart_putchar+0x16>
80004926:	e3 cf c0 e0 	ldm	sp++,r5-r7,pc,r12=-1
8000492a:	20 17       	sub	r7,1
  } while (usart_write_char(usart, c) != USART_SUCCESS);
8000492c:	0a 9b       	mov	r11,r5
8000492e:	0c 9c       	mov	r12,r6
80004930:	f0 1f 00 03 	mcall	8000493c <usart_putchar+0x28>
80004934:	cf 71       	brne	80004922 <usart_putchar+0xe>

  return USART_SUCCESS;
}
80004936:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000493a:	00 00       	add	r0,r0
8000493c:	80 00       	ld.sh	r0,r0[0x0]
8000493e:	48 fe       	lddpc	lr,80004978 <usart_getchar+0x14>

80004940 <usart_read_char>:

int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80004940:	78 58       	ld.w	r8,r12[0x14]
80004942:	e2 18 00 e0 	andl	r8,0xe0,COH
80004946:	c0 30       	breq	8000494c <usart_read_char+0xc>
80004948:	30 4c       	mov	r12,4
8000494a:	5e fc       	retal	r12
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
8000494c:	78 58       	ld.w	r8,r12[0x14]
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
8000494e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004952:	c0 31       	brne	80004958 <usart_read_char+0x18>
80004954:	30 3c       	mov	r12,3
80004956:	5e fc       	retal	r12
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80004958:	78 68       	ld.w	r8,r12[0x18]
8000495a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000495e:	97 08       	st.w	r11[0x0],r8
80004960:	5e fd       	retal	0
80004962:	d7 03       	nop

80004964 <usart_getchar>:
    return USART_RX_EMPTY;
}


int usart_getchar(volatile avr32_usart_t *usart)
{
80004964:	eb cd 40 c0 	pushm	r6-r7,lr
80004968:	20 1d       	sub	sp,4
8000496a:	18 96       	mov	r6,r12
  int c, ret;

  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
8000496c:	1a 97       	mov	r7,sp
8000496e:	1a 9b       	mov	r11,sp
80004970:	0c 9c       	mov	r12,r6
80004972:	f0 1f 00 07 	mcall	8000498c <usart_getchar+0x28>
80004976:	58 3c       	cp.w	r12,3
80004978:	cf b0       	breq	8000496e <usart_getchar+0xa>

  if (ret == USART_RX_ERROR)
8000497a:	58 4c       	cp.w	r12,4
8000497c:	f9 bc 00 ff 	moveq	r12,-1
    return USART_FAILURE;

  return c;
80004980:	fb fc 10 00 	ld.wne	r12,sp[0x0]
}
80004984:	2f fd       	sub	sp,-4
80004986:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000498a:	00 00       	add	r0,r0
8000498c:	80 00       	ld.sh	r0,r0[0x0]
8000498e:	49 40       	lddpc	r0,800049dc <usart_reset+0x28>

80004990 <usart_write_line>:


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004990:	eb cd 40 c0 	pushm	r6-r7,lr
80004994:	18 96       	mov	r6,r12
80004996:	16 97       	mov	r7,r11
  while (*string != '\0')
80004998:	17 8b       	ld.ub	r11,r11[0x0]
8000499a:	58 0b       	cp.w	r11,0
8000499c:	c0 80       	breq	800049ac <usart_write_line+0x1c>
    usart_putchar(usart, *string++);
8000499e:	2f f7       	sub	r7,-1
800049a0:	0c 9c       	mov	r12,r6
800049a2:	f0 1f 00 04 	mcall	800049b0 <usart_write_line+0x20>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
800049a6:	0f 8b       	ld.ub	r11,r7[0x0]
800049a8:	58 0b       	cp.w	r11,0
800049aa:	cf a1       	brne	8000499e <usart_write_line+0xe>
800049ac:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800049b0:	80 00       	ld.sh	r0,r0[0x0]
800049b2:	49 14       	lddpc	r4,800049f4 <usart_init_rs232+0x14>

800049b4 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
800049b4:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
800049b8:	e6 18 00 01 	andh	r8,0x1,COH
800049bc:	c0 71       	brne	800049ca <usart_reset+0x16>
800049be:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
800049c0:	3f f8       	mov	r8,-1
800049c2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800049c4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
800049c6:	d5 03       	csrf	0x10
800049c8:	c0 48       	rjmp	800049d0 <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
800049ca:	3f f8       	mov	r8,-1
800049cc:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800049ce:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800049d0:	30 08       	mov	r8,0
800049d2:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800049d4:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800049d6:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800049d8:	ea 68 61 0c 	mov	r8,680204
800049dc:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
800049de:	5e fc       	retal	r12

800049e0 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800049e0:	eb cd 40 e0 	pushm	r5-r7,lr
800049e4:	18 96       	mov	r6,r12
800049e6:	16 97       	mov	r7,r11
800049e8:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800049ea:	f0 1f 00 2f 	mcall	80004aa4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800049ee:	58 07       	cp.w	r7,0
800049f0:	c5 80       	breq	80004aa0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800049f2:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800049f4:	30 49       	mov	r9,4
800049f6:	f2 08 18 00 	cp.b	r8,r9
800049fa:	e0 88 00 53 	brls	80004aa0 <usart_init_rs232+0xc0>
800049fe:	30 99       	mov	r9,9
80004a00:	f2 08 18 00 	cp.b	r8,r9
80004a04:	e0 8b 00 4e 	brhi	80004aa0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80004a08:	0f d9       	ld.ub	r9,r7[0x5]
80004a0a:	30 78       	mov	r8,7
80004a0c:	f0 09 18 00 	cp.b	r9,r8
80004a10:	e0 8b 00 48 	brhi	80004aa0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80004a14:	8e 39       	ld.sh	r9,r7[0x6]
80004a16:	e0 68 01 01 	mov	r8,257
80004a1a:	f0 09 19 00 	cp.h	r9,r8
80004a1e:	e0 8b 00 41 	brhi	80004aa0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80004a22:	ef 39 00 08 	ld.ub	r9,r7[8]
80004a26:	30 38       	mov	r8,3
80004a28:	f0 09 18 00 	cp.b	r9,r8
80004a2c:	e0 8b 00 3a 	brhi	80004aa0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004a30:	0a 9a       	mov	r10,r5
80004a32:	6e 0b       	ld.w	r11,r7[0x0]
80004a34:	0c 9c       	mov	r12,r6
80004a36:	f0 1f 00 1d 	mcall	80004aa8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004a3a:	58 1c       	cp.w	r12,1
80004a3c:	c3 20       	breq	80004aa0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004a3e:	0f c8       	ld.ub	r8,r7[0x4]
80004a40:	30 99       	mov	r9,9
80004a42:	f2 08 18 00 	cp.b	r8,r9
80004a46:	c0 51       	brne	80004a50 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004a48:	6c 18       	ld.w	r8,r6[0x4]
80004a4a:	b1 b8       	sbr	r8,0x11
80004a4c:	8d 18       	st.w	r6[0x4],r8
80004a4e:	c0 68       	rjmp	80004a5a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004a50:	6c 19       	ld.w	r9,r6[0x4]
80004a52:	20 58       	sub	r8,5
80004a54:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004a58:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004a5a:	6c 19       	ld.w	r9,r6[0x4]
80004a5c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004a60:	0f d8       	ld.ub	r8,r7[0x5]
80004a62:	a9 78       	lsl	r8,0x9
80004a64:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004a68:	12 48       	or	r8,r9
80004a6a:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004a6c:	8e 38       	ld.sh	r8,r7[0x6]
80004a6e:	30 29       	mov	r9,2
80004a70:	f2 08 19 00 	cp.h	r8,r9
80004a74:	e0 88 00 09 	brls	80004a86 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004a78:	6c 18       	ld.w	r8,r6[0x4]
80004a7a:	ad b8       	sbr	r8,0xd
80004a7c:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004a7e:	8e b8       	ld.uh	r8,r7[0x6]
80004a80:	20 28       	sub	r8,2
80004a82:	8d a8       	st.w	r6[0x28],r8
80004a84:	c0 68       	rjmp	80004a90 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80004a86:	6c 19       	ld.w	r9,r6[0x4]
80004a88:	5c 78       	castu.h	r8
80004a8a:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004a8e:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004a90:	6c 18       	ld.w	r8,r6[0x4]
80004a92:	e0 18 ff f0 	andl	r8,0xfff0
80004a96:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004a98:	35 08       	mov	r8,80
80004a9a:	8d 08       	st.w	r6[0x0],r8
80004a9c:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004aa0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80004aa4:	80 00       	ld.sh	r0,r0[0x0]
80004aa6:	49 b4       	lddpc	r4,80004b10 <vListInsertEnd+0xa>
80004aa8:	80 00       	ld.sh	r0,r0[0x0]
80004aaa:	48 a4       	lddpc	r4,80004ad0 <idata_load_loop_end+0x2>

80004aac <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004aac:	e0 7d 80 00 	mov	sp,98304

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004ab0:	fe c0 90 b0 	sub	r0,pc,-28496

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004ab4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004ab8:	d5 53       	csrf	0x15
  cp      r0, r1
80004aba:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80004abc:	e0 61 0a 20 	mov	r1,2592
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004ac0:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80004ac2:	c0 62       	brcc	80004ace <idata_load_loop_end>
  cp      r0, r1
80004ac4:	48 92       	lddpc	r2,80004ae8 <udata_clear_loop_end+0x4>

80004ac6 <idata_load_loop>:
  brlo    idata_load_loop
80004ac6:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004ac8:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80004aca:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004acc:	cf d3       	brcs	80004ac6 <idata_load_loop>

80004ace <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80004ace:	e0 60 0a 20 	mov	r0,2592
  mov     r2, 0
  mov     r3, 0
80004ad2:	e0 61 1f a8 	mov	r1,8104
udata_clear_loop:
  st.d    r0++, r2
  cp      r0, r1
80004ad6:	02 30       	cp.w	r0,r1
  brlo    udata_clear_loop
80004ad8:	c0 62       	brcc	80004ae4 <udata_clear_loop_end>
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004ada:	30 02       	mov	r2,0
80004adc:	30 03       	mov	r3,0

80004ade <udata_clear_loop>:
80004ade:	a1 22       	st.d	r0++,r2
80004ae0:	02 30       	cp.w	r0,r1
80004ae2:	cf e3       	brcs	80004ade <udata_clear_loop>

80004ae4 <udata_clear_loop_end>:
80004ae4:	fe cf eb 48 	sub	pc,pc,-5304
80004ae8:	80 00       	ld.sh	r0,r0[0x0]
80004aea:	ce 38       	rjmp	80004cb0 <SCALLYield+0x38>

80004aec <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004aec:	f8 c8 ff f8 	sub	r8,r12,-8
80004af0:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004af2:	3f f9       	mov	r9,-1
80004af4:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004af6:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004af8:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80004afa:	30 08       	mov	r8,0
80004afc:	99 08       	st.w	r12[0x0],r8
}
80004afe:	5e fc       	retal	r12

80004b00 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004b00:	30 08       	mov	r8,0
80004b02:	99 48       	st.w	r12[0x10],r8
}
80004b04:	5e fc       	retal	r12

80004b06 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004b06:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004b08:	70 19       	ld.w	r9,r8[0x4]
80004b0a:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004b0c:	78 19       	ld.w	r9,r12[0x4]
80004b0e:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004b10:	70 19       	ld.w	r9,r8[0x4]
80004b12:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004b14:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004b16:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004b18:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004b1a:	78 08       	ld.w	r8,r12[0x0]
80004b1c:	2f f8       	sub	r8,-1
80004b1e:	99 08       	st.w	r12[0x0],r8
}
80004b20:	5e fc       	retal	r12

80004b22 <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004b22:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80004b24:	5b fa       	cp.w	r10,-1
80004b26:	c0 31       	brne	80004b2c <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80004b28:	78 48       	ld.w	r8,r12[0x10]
80004b2a:	c0 c8       	rjmp	80004b42 <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80004b2c:	f8 c8 ff f8 	sub	r8,r12,-8
80004b30:	70 19       	ld.w	r9,r8[0x4]
80004b32:	72 09       	ld.w	r9,r9[0x0]
80004b34:	12 3a       	cp.w	r10,r9
80004b36:	c0 63       	brcs	80004b42 <vListInsert+0x20>
80004b38:	70 18       	ld.w	r8,r8[0x4]
80004b3a:	70 19       	ld.w	r9,r8[0x4]
80004b3c:	72 09       	ld.w	r9,r9[0x0]
80004b3e:	12 3a       	cp.w	r10,r9
80004b40:	cf c2       	brcc	80004b38 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
80004b42:	70 19       	ld.w	r9,r8[0x4]
80004b44:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004b46:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80004b48:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80004b4a:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004b4c:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004b4e:	78 08       	ld.w	r8,r12[0x0]
80004b50:	2f f8       	sub	r8,-1
80004b52:	99 08       	st.w	r12[0x0],r8
}
80004b54:	5e fc       	retal	r12

80004b56 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80004b56:	78 18       	ld.w	r8,r12[0x4]
80004b58:	78 29       	ld.w	r9,r12[0x8]
80004b5a:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80004b5c:	78 28       	ld.w	r8,r12[0x8]
80004b5e:	78 19       	ld.w	r9,r12[0x4]
80004b60:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
80004b62:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80004b64:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80004b66:	18 39       	cp.w	r9,r12
80004b68:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80004b6c:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
80004b70:	30 09       	mov	r9,0
80004b72:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80004b74:	70 09       	ld.w	r9,r8[0x0]
80004b76:	20 19       	sub	r9,1
80004b78:	91 09       	st.w	r8[0x0],r9
}
80004b7a:	5e fc       	retal	r12

80004b7c <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80004b7c:	e0 68 08 08 	mov	r8,2056
80004b80:	ea 18 08 08 	orh	r8,0x808
80004b84:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80004b86:	e0 68 09 09 	mov	r8,2313
80004b8a:	ea 18 09 09 	orh	r8,0x909
80004b8e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
80004b90:	e0 68 0a 0a 	mov	r8,2570
80004b94:	ea 18 0a 0a 	orh	r8,0xa0a
80004b98:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80004b9a:	e0 68 0b 0b 	mov	r8,2827
80004b9e:	ea 18 0b 0b 	orh	r8,0xb0b
80004ba2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80004ba4:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80004ba6:	e0 68 be ef 	mov	r8,48879
80004baa:	ea 18 de ad 	orh	r8,0xdead
80004bae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
80004bb0:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
80004bb2:	fc 18 00 40 	movh	r8,0x40
80004bb6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80004bb8:	e0 68 00 ff 	mov	r8,255
80004bbc:	ea 18 ff 00 	orh	r8,0xff00
80004bc0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
80004bc2:	e0 68 01 01 	mov	r8,257
80004bc6:	ea 18 01 01 	orh	r8,0x101
80004bca:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80004bcc:	e0 68 02 02 	mov	r8,514
80004bd0:	ea 18 02 02 	orh	r8,0x202
80004bd4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80004bd6:	e0 68 03 03 	mov	r8,771
80004bda:	ea 18 03 03 	orh	r8,0x303
80004bde:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80004be0:	e0 68 04 04 	mov	r8,1028
80004be4:	ea 18 04 04 	orh	r8,0x404
80004be8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80004bea:	e0 68 05 05 	mov	r8,1285
80004bee:	ea 18 05 05 	orh	r8,0x505
80004bf2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80004bf4:	e0 68 06 06 	mov	r8,1542
80004bf8:	ea 18 06 06 	orh	r8,0x606
80004bfc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80004bfe:	e0 68 07 07 	mov	r8,1799
80004c02:	ea 18 07 07 	orh	r8,0x707
80004c06:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80004c08:	30 08       	mov	r8,0
80004c0a:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80004c0c:	5e fc       	retal	r12
80004c0e:	d7 03       	nop

80004c10 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80004c10:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
80004c12:	48 38       	lddpc	r8,80004c1c <vPortEnterCritical+0xc>
80004c14:	70 09       	ld.w	r9,r8[0x0]
80004c16:	2f f9       	sub	r9,-1
80004c18:	91 09       	st.w	r8[0x0],r9
}
80004c1a:	5e fc       	retal	r12
80004c1c:	00 00       	add	r0,r0
80004c1e:	05 10       	ld.sh	r0,r2++

80004c20 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80004c20:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
80004c22:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80004c24:	30 0a       	mov	r10,0
80004c26:	14 9b       	mov	r11,r10
80004c28:	49 2c       	lddpc	r12,80004c70 <xPortStartScheduler+0x50>
80004c2a:	f0 1f 00 13 	mcall	80004c74 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);//cause!!!
80004c2e:	e0 68 5d c0 	mov	r8,24000
80004c32:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80004c36:	30 08       	mov	r8,0
80004c38:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80004c3c:	e0 68 0c 3c 	mov	r8,3132
80004c40:	ea 18 00 00 	orh	r8,0x0
80004c44:	70 00       	ld.w	r0,r8[0x0]
80004c46:	60 0d       	ld.w	sp,r0[0x0]
80004c48:	1b 00       	ld.w	r0,sp++
80004c4a:	e0 68 05 10 	mov	r8,1296
80004c4e:	ea 18 00 00 	orh	r8,0x0
80004c52:	91 00       	st.w	r8[0x0],r0
80004c54:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004c58:	2f ed       	sub	sp,-8
80004c5a:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80004c5e:	fa f0 ff e0 	ld.w	r0,sp[-32]
80004c62:	e3 b0 00 00 	mtsr	0x0,r0
80004c66:	fa f0 ff dc 	ld.w	r0,sp[-36]
80004c6a:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
80004c6e:	d8 0a       	popm	pc,r12=0
80004c70:	80 00       	ld.sh	r0,r0[0x0]
80004c72:	4d 3c       	lddpc	r12,80004dbc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80004c74:	80 00       	ld.sh	r0,r0[0x0]
80004c76:	42 70       	lddsp	r0,sp[0x9c]

80004c78 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80004c78:	20 6d       	sub	sp,24
80004c7a:	eb cd 00 ff 	pushm	r0-r7
80004c7e:	fa c7 ff c0 	sub	r7,sp,-64
80004c82:	ee f0 ff f8 	ld.w	r0,r7[-8]
80004c86:	ef 40 ff e0 	st.w	r7[-32],r0
80004c8a:	ee f0 ff fc 	ld.w	r0,r7[-4]
80004c8e:	ef 40 ff e4 	st.w	r7[-28],r0
80004c92:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80004c96:	e0 68 05 10 	mov	r8,1296
80004c9a:	ea 18 00 00 	orh	r8,0x0
80004c9e:	70 00       	ld.w	r0,r8[0x0]
80004ca0:	1a d0       	st.w	--sp,r0
80004ca2:	f0 1f 00 1a 	mcall	80004d08 <LABEL_RET_SCALL_263+0x14>
80004ca6:	e0 68 0c 3c 	mov	r8,3132
80004caa:	ea 18 00 00 	orh	r8,0x0
80004cae:	70 00       	ld.w	r0,r8[0x0]
80004cb0:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
80004cb2:	f0 1f 00 17 	mcall	80004d0c <LABEL_RET_SCALL_263+0x18>
	portRESTORE_CONTEXT_SCALL();
80004cb6:	e0 68 0c 3c 	mov	r8,3132
80004cba:	ea 18 00 00 	orh	r8,0x0
80004cbe:	70 00       	ld.w	r0,r8[0x0]
80004cc0:	60 0d       	ld.w	sp,r0[0x0]
80004cc2:	1b 00       	ld.w	r0,sp++
80004cc4:	e0 68 05 10 	mov	r8,1296
80004cc8:	ea 18 00 00 	orh	r8,0x0
80004ccc:	91 00       	st.w	r8[0x0],r0
80004cce:	fa c7 ff d8 	sub	r7,sp,-40
80004cd2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80004cd6:	ee f0 ff e0 	ld.w	r0,r7[-32]
80004cda:	e0 61 05 10 	mov	r1,1296
80004cde:	ea 11 00 00 	orh	r1,0x0
80004ce2:	62 02       	ld.w	r2,r1[0x0]
80004ce4:	58 02       	cp.w	r2,0
80004ce6:	c0 70       	breq	80004cf4 <LABEL_RET_SCALL_263>
80004ce8:	e4 c2 00 01 	sub	r2,r2,1
80004cec:	83 02       	st.w	r1[0x0],r2
80004cee:	58 02       	cp.w	r2,0
80004cf0:	c0 21       	brne	80004cf4 <LABEL_RET_SCALL_263>
80004cf2:	b1 c0       	cbr	r0,0x10

80004cf4 <LABEL_RET_SCALL_263>:
80004cf4:	ef 40 ff f8 	st.w	r7[-8],r0
80004cf8:	ee f0 ff e4 	ld.w	r0,r7[-28]
80004cfc:	ef 40 ff fc 	st.w	r7[-4],r0
80004d00:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004d04:	2f ad       	sub	sp,-24
80004d06:	d6 13       	rets
80004d08:	80 00       	ld.sh	r0,r0[0x0]
80004d0a:	4c 10       	lddpc	r0,80004e0c <_read+0x34>
80004d0c:	80 00       	ld.sh	r0,r0[0x0]
80004d0e:	53 0c       	stdsp	sp[0xc0],r12

80004d10 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80004d10:	e1 b8 00 43 	mfsr	r8,0x10c
80004d14:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80004d18:	5e fc       	retal	r12
80004d1a:	d7 03       	nop

80004d1c <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80004d1c:	48 78       	lddpc	r8,80004d38 <vPortExitCritical+0x1c>
80004d1e:	70 08       	ld.w	r8,r8[0x0]
80004d20:	58 08       	cp.w	r8,0
80004d22:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80004d24:	48 58       	lddpc	r8,80004d38 <vPortExitCritical+0x1c>
80004d26:	70 09       	ld.w	r9,r8[0x0]
80004d28:	20 19       	sub	r9,1
80004d2a:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80004d2c:	70 08       	ld.w	r8,r8[0x0]
80004d2e:	58 08       	cp.w	r8,0
80004d30:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
80004d32:	d5 03       	csrf	0x10
80004d34:	5e fc       	retal	r12
80004d36:	00 00       	add	r0,r0
80004d38:	00 00       	add	r0,r0
80004d3a:	05 10       	ld.sh	r0,r2++

80004d3c <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80004d3c:	eb cd 00 ff 	pushm	r0-r7
80004d40:	e0 68 05 10 	mov	r8,1296
80004d44:	ea 18 00 00 	orh	r8,0x0
80004d48:	70 00       	ld.w	r0,r8[0x0]
80004d4a:	1a d0       	st.w	--sp,r0
80004d4c:	7a 90       	ld.w	r0,sp[0x24]
80004d4e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004d52:	58 10       	cp.w	r0,1
80004d54:	e0 8b 00 08 	brhi	80004d64 <LABEL_INT_SKIP_SAVE_CONTEXT_237>
80004d58:	e0 68 0c 3c 	mov	r8,3132
80004d5c:	ea 18 00 00 	orh	r8,0x0
80004d60:	70 00       	ld.w	r0,r8[0x0]
80004d62:	81 0d       	st.w	r0[0x0],sp

80004d64 <LABEL_INT_SKIP_SAVE_CONTEXT_237>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80004d64:	f0 1f 00 12 	mcall	80004dac <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80004d68:	f0 1f 00 12 	mcall	80004db0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
		vTaskIncrementTick();
80004d6c:	f0 1f 00 12 	mcall	80004db4 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x1c>
	portEXIT_CRITICAL();
80004d70:	f0 1f 00 12 	mcall	80004db8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80004d74:	7a 90       	ld.w	r0,sp[0x24]
80004d76:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004d7a:	58 10       	cp.w	r0,1
80004d7c:	e0 8b 00 0e 	brhi	80004d98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>
80004d80:	f0 1f 00 0c 	mcall	80004db0 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x18>
80004d84:	f0 1f 00 0e 	mcall	80004dbc <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x24>
80004d88:	f0 1f 00 0c 	mcall	80004db8 <LABEL_INT_SKIP_RESTORE_CONTEXT_254+0x20>
80004d8c:	e0 68 0c 3c 	mov	r8,3132
80004d90:	ea 18 00 00 	orh	r8,0x0
80004d94:	70 00       	ld.w	r0,r8[0x0]
80004d96:	60 0d       	ld.w	sp,r0[0x0]

80004d98 <LABEL_INT_SKIP_RESTORE_CONTEXT_254>:
80004d98:	1b 00       	ld.w	r0,sp++
80004d9a:	e0 68 05 10 	mov	r8,1296
80004d9e:	ea 18 00 00 	orh	r8,0x0
80004da2:	91 00       	st.w	r8[0x0],r0
80004da4:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004da8:	d6 03       	rete
80004daa:	00 00       	add	r0,r0
80004dac:	80 00       	ld.sh	r0,r0[0x0]
80004dae:	4d 10       	lddpc	r0,80004ef0 <prvUnlockQueue+0x1c>
80004db0:	80 00       	ld.sh	r0,r0[0x0]
80004db2:	4c 10       	lddpc	r0,80004eb4 <prvCopyDataFromQueue+0x10>
80004db4:	80 00       	ld.sh	r0,r0[0x0]
80004db6:	55 10       	stdsp	sp[0x144],r0
80004db8:	80 00       	ld.sh	r0,r0[0x0]
80004dba:	4d 1c       	lddpc	r12,80004efc <prvUnlockQueue+0x28>
80004dbc:	80 00       	ld.sh	r0,r0[0x0]
80004dbe:	53 0c       	stdsp	sp[0xc0],r12

80004dc0 <__malloc_lock>:
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr);
void __malloc_lock(struct _reent *ptr)
{
80004dc0:	d4 01       	pushm	lr
	vTaskSuspendAll();
80004dc2:	f0 1f 00 02 	mcall	80004dc8 <__malloc_lock+0x8>
}
80004dc6:	d8 02       	popm	pc
80004dc8:	80 00       	ld.sh	r0,r0[0x0]
80004dca:	52 fc       	stdsp	sp[0xbc],r12

80004dcc <__malloc_unlock>:
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr);
void __malloc_unlock(struct _reent *ptr)
{
80004dcc:	d4 01       	pushm	lr
	xTaskResumeAll();
80004dce:	f0 1f 00 02 	mcall	80004dd4 <__malloc_unlock+0x8>
}
80004dd2:	d8 02       	popm	pc
80004dd4:	80 00       	ld.sh	r0,r0[0x0]
80004dd6:	56 b8       	stdsp	sp[0x1ac],r8

80004dd8 <_read>:
/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
{
80004dd8:	d4 21       	pushm	r4-r7,lr
80004dda:	16 95       	mov	r5,r11
80004ddc:	14 96       	mov	r6,r10
  int nChars = 0;

  if (file != 0)
80004dde:	58 0c       	cp.w	r12,0
80004de0:	c0 30       	breq	80004de6 <_read+0xe>
80004de2:	3f f7       	mov	r7,-1
80004de4:	c1 48       	rjmp	80004e0c <_read+0x34>
    return -1;

  for (; len > 0; --len)
80004de6:	58 0a       	cp.w	r10,0
80004de8:	e0 89 00 04 	brgt	80004df0 <_read+0x18>
80004dec:	30 07       	mov	r7,0
80004dee:	c0 f8       	rjmp	80004e0c <_read+0x34>
80004df0:	30 07       	mov	r7,0
  {
    int c = usart_getchar(stdio_usart_base);
80004df2:	48 84       	lddpc	r4,80004e10 <_read+0x38>
80004df4:	68 0c       	ld.w	r12,r4[0x0]
80004df6:	f0 1f 00 08 	mcall	80004e14 <_read+0x3c>
    if (c < 0)
80004dfa:	c0 95       	brlt	80004e0c <_read+0x34>
      break;

    *ptr++ = c;
80004dfc:	ea 07 0b 0c 	st.b	r5[r7],r12
    ++nChars;
80004e00:	2f f7       	sub	r7,-1

/**
 * Low-level read command.
 */
int __attribute__((weak))
_read (int file, char * ptr, int len)
80004e02:	ec 07 01 08 	sub	r8,r6,r7
  int nChars = 0;

  if (file != 0)
    return -1;

  for (; len > 0; --len)
80004e06:	58 08       	cp.w	r8,0
80004e08:	fe 99 ff f6 	brgt	80004df4 <_read+0x1c>
    *ptr++ = c;
    ++nChars;
  }

  return nChars;
}
80004e0c:	0e 9c       	mov	r12,r7
80004e0e:	d8 22       	popm	r4-r7,pc
80004e10:	00 00       	add	r0,r0
80004e12:	1f 9c       	ld.ub	r12,pc[0x1]
80004e14:	80 00       	ld.sh	r0,r0[0x0]
80004e16:	49 64       	lddpc	r4,80004e6c <vPortFree+0x18>

80004e18 <_write>:
 * 1 and 2 is stdout and stderr which goes to usart
 * 3 is framebuffer
 */
int __attribute__((weak))
_write (int file, char * ptr, int len)
{
80004e18:	d4 21       	pushm	r4-r7,lr
80004e1a:	16 95       	mov	r5,r11
80004e1c:	14 96       	mov	r6,r10
  int nChars = 0;

  if ( (file != 1)
80004e1e:	20 1c       	sub	r12,1
80004e20:	58 2c       	cp.w	r12,2
80004e22:	e0 8b 00 12 	brhi	80004e46 <_write+0x2e>
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004e26:	58 0a       	cp.w	r10,0
80004e28:	c0 31       	brne	80004e2e <_write+0x16>
80004e2a:	30 07       	mov	r7,0
80004e2c:	c0 e8       	rjmp	80004e48 <_write+0x30>
80004e2e:	30 07       	mov	r7,0
  {
    if (usart_putchar(stdio_usart_base, *ptr++) < 0)
80004e30:	48 74       	lddpc	r4,80004e4c <_write+0x34>
80004e32:	68 0c       	ld.w	r12,r4[0x0]
80004e34:	ea 07 07 0b 	ld.ub	r11,r5[r7]
80004e38:	f0 1f 00 06 	mcall	80004e50 <_write+0x38>
80004e3c:	c0 55       	brlt	80004e46 <_write+0x2e>
    {
      return -1;
    }

    ++nChars;
80004e3e:	2f f7       	sub	r7,-1

  if ( (file != 1)
       && (file != 2) && (file!=3))
    return -1;

  for (; len != 0; --len)
80004e40:	0e 36       	cp.w	r6,r7
80004e42:	cf 81       	brne	80004e32 <_write+0x1a>
80004e44:	c0 28       	rjmp	80004e48 <_write+0x30>
80004e46:	3f f7       	mov	r7,-1

    ++nChars;
  }

  return nChars;
}
80004e48:	0e 9c       	mov	r12,r7
80004e4a:	d8 22       	popm	r4-r7,pc
80004e4c:	00 00       	add	r0,r0
80004e4e:	1f 9c       	ld.ub	r12,pc[0x1]
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	49 14       	lddpc	r4,80004e94 <pvPortMalloc+0x18>

80004e54 <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80004e54:	eb cd 40 80 	pushm	r7,lr
80004e58:	18 97       	mov	r7,r12
	if( pv )
80004e5a:	58 0c       	cp.w	r12,0
80004e5c:	c0 80       	breq	80004e6c <vPortFree+0x18>
	{
		vTaskSuspendAll();
80004e5e:	f0 1f 00 05 	mcall	80004e70 <vPortFree+0x1c>
		{
			free( pv );
80004e62:	0e 9c       	mov	r12,r7
80004e64:	f0 1f 00 04 	mcall	80004e74 <vPortFree+0x20>
		}
		xTaskResumeAll();
80004e68:	f0 1f 00 04 	mcall	80004e78 <vPortFree+0x24>
80004e6c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e70:	80 00       	ld.sh	r0,r0[0x0]
80004e72:	52 fc       	stdsp	sp[0xbc],r12
80004e74:	80 00       	ld.sh	r0,r0[0x0]
80004e76:	60 0c       	ld.w	r12,r0[0x0]
80004e78:	80 00       	ld.sh	r0,r0[0x0]
80004e7a:	56 b8       	stdsp	sp[0x1ac],r8

80004e7c <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80004e7c:	eb cd 40 80 	pushm	r7,lr
80004e80:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
80004e82:	f0 1f 00 06 	mcall	80004e98 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
80004e86:	0e 9c       	mov	r12,r7
80004e88:	f0 1f 00 05 	mcall	80004e9c <pvPortMalloc+0x20>
80004e8c:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80004e8e:	f0 1f 00 05 	mcall	80004ea0 <pvPortMalloc+0x24>
		}
	}
	#endif

	return pvReturn;
}
80004e92:	0e 9c       	mov	r12,r7
80004e94:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e98:	80 00       	ld.sh	r0,r0[0x0]
80004e9a:	52 fc       	stdsp	sp[0xbc],r12
80004e9c:	80 00       	ld.sh	r0,r0[0x0]
80004e9e:	60 1c       	ld.w	r12,r0[0x4]
80004ea0:	80 00       	ld.sh	r0,r0[0x0]
80004ea2:	56 b8       	stdsp	sp[0x1ac],r8

80004ea4 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
80004ea4:	d4 01       	pushm	lr
80004ea6:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80004ea8:	78 09       	ld.w	r9,r12[0x0]
80004eaa:	58 09       	cp.w	r9,0
80004eac:	c1 10       	breq	80004ece <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80004eae:	78 3a       	ld.w	r10,r12[0xc]
80004eb0:	79 09       	ld.w	r9,r12[0x40]
80004eb2:	f4 09 00 09 	add	r9,r10,r9
80004eb6:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80004eb8:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80004eba:	14 39       	cp.w	r9,r10
80004ebc:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80004ec0:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
80004ec4:	79 0a       	ld.w	r10,r12[0x40]
80004ec6:	78 3b       	ld.w	r11,r12[0xc]
80004ec8:	10 9c       	mov	r12,r8
80004eca:	f0 1f 00 02 	mcall	80004ed0 <prvCopyDataFromQueue+0x2c>
80004ece:	d8 02       	popm	pc
80004ed0:	80 00       	ld.sh	r0,r0[0x0]
80004ed2:	64 8a       	ld.w	r10,r2[0x20]

80004ed4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
80004ed4:	eb cd 40 c0 	pushm	r6-r7,lr
80004ed8:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80004eda:	f0 1f 00 23 	mcall	80004f64 <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004ede:	6f 28       	ld.w	r8,r7[0x48]
80004ee0:	58 08       	cp.w	r8,0
80004ee2:	e0 8a 00 18 	brle	80004f12 <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004ee6:	6e 98       	ld.w	r8,r7[0x24]
80004ee8:	58 08       	cp.w	r8,0
80004eea:	c1 40       	breq	80004f12 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004eec:	ee c6 ff dc 	sub	r6,r7,-36
80004ef0:	c0 48       	rjmp	80004ef8 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004ef2:	6e 98       	ld.w	r8,r7[0x24]
80004ef4:	58 08       	cp.w	r8,0
80004ef6:	c0 e0       	breq	80004f12 <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004ef8:	0c 9c       	mov	r12,r6
80004efa:	f0 1f 00 1c 	mcall	80004f68 <prvUnlockQueue+0x94>
80004efe:	c0 30       	breq	80004f04 <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80004f00:	f0 1f 00 1b 	mcall	80004f6c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
80004f04:	6f 28       	ld.w	r8,r7[0x48]
80004f06:	20 18       	sub	r8,1
80004f08:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80004f0c:	58 08       	cp.w	r8,0
80004f0e:	fe 99 ff f2 	brgt	80004ef2 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
80004f12:	3f f8       	mov	r8,-1
80004f14:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80004f18:	f0 1f 00 16 	mcall	80004f70 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80004f1c:	f0 1f 00 12 	mcall	80004f64 <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004f20:	6f 18       	ld.w	r8,r7[0x44]
80004f22:	58 08       	cp.w	r8,0
80004f24:	e0 8a 00 18 	brle	80004f54 <prvUnlockQueue+0x80>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004f28:	6e 48       	ld.w	r8,r7[0x10]
80004f2a:	58 08       	cp.w	r8,0
80004f2c:	c1 40       	breq	80004f54 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004f2e:	ee c6 ff f0 	sub	r6,r7,-16
80004f32:	c0 48       	rjmp	80004f3a <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004f34:	6e 48       	ld.w	r8,r7[0x10]
80004f36:	58 08       	cp.w	r8,0
80004f38:	c0 e0       	breq	80004f54 <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80004f3a:	0c 9c       	mov	r12,r6
80004f3c:	f0 1f 00 0b 	mcall	80004f68 <prvUnlockQueue+0x94>
80004f40:	c0 30       	breq	80004f46 <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
80004f42:	f0 1f 00 0b 	mcall	80004f6c <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
80004f46:	6f 18       	ld.w	r8,r7[0x44]
80004f48:	20 18       	sub	r8,1
80004f4a:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80004f4e:	58 08       	cp.w	r8,0
80004f50:	fe 99 ff f2 	brgt	80004f34 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80004f54:	3f f8       	mov	r8,-1
80004f56:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80004f5a:	f0 1f 00 06 	mcall	80004f70 <prvUnlockQueue+0x9c>
}
80004f5e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f62:	00 00       	add	r0,r0
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	4c 10       	lddpc	r0,80005068 <xQueueGenericReceive+0xf4>
80004f68:	80 00       	ld.sh	r0,r0[0x0]
80004f6a:	54 94       	stdsp	sp[0x124],r4
80004f6c:	80 00       	ld.sh	r0,r0[0x0]
80004f6e:	53 a0       	stdsp	sp[0xe8],r0
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	4d 1c       	lddpc	r12,800050b4 <xQueueGenericReceive+0x140>

80004f74 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80004f74:	d4 31       	pushm	r0-r7,lr
80004f76:	20 5d       	sub	sp,20
80004f78:	18 97       	mov	r7,r12
80004f7a:	50 0b       	stdsp	sp[0x0],r11
80004f7c:	50 2a       	stdsp	sp[0x8],r10
80004f7e:	50 19       	stdsp	sp[0x4],r9
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80004f80:	f8 c2 ff dc 	sub	r2,r12,-36
80004f84:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80004f86:	fa c4 ff f4 	sub	r4,sp,-12
80004f8a:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80004f8c:	0a 91       	mov	r1,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80004f8e:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80004f92:	f0 1f 00 3e 	mcall	80005088 <xQueueGenericReceive+0x114>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80004f96:	6e e8       	ld.w	r8,r7[0x38]
80004f98:	58 08       	cp.w	r8,0
80004f9a:	c2 a0       	breq	80004fee <xQueueGenericReceive+0x7a>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80004f9c:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80004f9e:	40 0b       	lddsp	r11,sp[0x0]
80004fa0:	0e 9c       	mov	r12,r7
80004fa2:	f0 1f 00 3b 	mcall	8000508c <xQueueGenericReceive+0x118>

				if( xJustPeeking == pdFALSE )
80004fa6:	40 18       	lddsp	r8,sp[0x4]
80004fa8:	58 08       	cp.w	r8,0
80004faa:	c1 51       	brne	80004fd4 <xQueueGenericReceive+0x60>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
80004fac:	6e e8       	ld.w	r8,r7[0x38]
80004fae:	20 18       	sub	r8,1
80004fb0:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80004fb2:	6e 08       	ld.w	r8,r7[0x0]
80004fb4:	58 08       	cp.w	r8,0
80004fb6:	c0 41       	brne	80004fbe <xQueueGenericReceive+0x4a>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
80004fb8:	f0 1f 00 36 	mcall	80005090 <xQueueGenericReceive+0x11c>
80004fbc:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80004fbe:	6e 48       	ld.w	r8,r7[0x10]
80004fc0:	58 08       	cp.w	r8,0
80004fc2:	c1 20       	breq	80004fe6 <xQueueGenericReceive+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80004fc4:	ee cc ff f0 	sub	r12,r7,-16
80004fc8:	f0 1f 00 33 	mcall	80005094 <xQueueGenericReceive+0x120>
80004fcc:	58 1c       	cp.w	r12,1
80004fce:	c0 c1       	brne	80004fe6 <xQueueGenericReceive+0x72>
						{
							portYIELD_WITHIN_API();
80004fd0:	d7 33       	scall
80004fd2:	c0 a8       	rjmp	80004fe6 <xQueueGenericReceive+0x72>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
80004fd4:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80004fd6:	6e 98       	ld.w	r8,r7[0x24]
80004fd8:	58 08       	cp.w	r8,0
80004fda:	c0 60       	breq	80004fe6 <xQueueGenericReceive+0x72>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80004fdc:	04 9c       	mov	r12,r2
80004fde:	f0 1f 00 2e 	mcall	80005094 <xQueueGenericReceive+0x120>
80004fe2:	c0 20       	breq	80004fe6 <xQueueGenericReceive+0x72>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
80004fe4:	d7 33       	scall
						}
					}

				}

				taskEXIT_CRITICAL();
80004fe6:	f0 1f 00 2d 	mcall	80005098 <xQueueGenericReceive+0x124>
80004fea:	30 1c       	mov	r12,1
				return pdPASS;
80004fec:	c4 c8       	rjmp	80005084 <xQueueGenericReceive+0x110>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80004fee:	40 28       	lddsp	r8,sp[0x8]
80004ff0:	58 08       	cp.w	r8,0
80004ff2:	c0 51       	brne	80004ffc <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80004ff4:	f0 1f 00 29 	mcall	80005098 <xQueueGenericReceive+0x124>
80004ff8:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80004ffa:	c4 58       	rjmp	80005084 <xQueueGenericReceive+0x110>
				}
				else if( xEntryTimeSet == pdFALSE )
80004ffc:	58 05       	cp.w	r5,0
80004ffe:	c0 51       	brne	80005008 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005000:	08 9c       	mov	r12,r4
80005002:	f0 1f 00 27 	mcall	8000509c <xQueueGenericReceive+0x128>
80005006:	00 95       	mov	r5,r0
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005008:	f0 1f 00 24 	mcall	80005098 <xQueueGenericReceive+0x124>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000500c:	f0 1f 00 25 	mcall	800050a0 <xQueueGenericReceive+0x12c>
		prvLockQueue( pxQueue );
80005010:	f0 1f 00 1e 	mcall	80005088 <xQueueGenericReceive+0x114>
80005014:	6f 18       	ld.w	r8,r7[0x44]
80005016:	5b f8       	cp.w	r8,-1
80005018:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000501c:	6f 28       	ld.w	r8,r7[0x48]
8000501e:	5b f8       	cp.w	r8,-1
80005020:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005024:	f0 1f 00 1d 	mcall	80005098 <xQueueGenericReceive+0x124>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005028:	06 9b       	mov	r11,r3
8000502a:	08 9c       	mov	r12,r4
8000502c:	f0 1f 00 1e 	mcall	800050a4 <xQueueGenericReceive+0x130>
80005030:	c2 41       	brne	80005078 <xQueueGenericReceive+0x104>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005032:	f0 1f 00 16 	mcall	80005088 <xQueueGenericReceive+0x114>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005036:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005038:	f0 1f 00 18 	mcall	80005098 <xQueueGenericReceive+0x124>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
8000503c:	58 06       	cp.w	r6,0
8000503e:	c1 71       	brne	8000506c <xQueueGenericReceive+0xf8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005040:	6e 08       	ld.w	r8,r7[0x0]
80005042:	58 08       	cp.w	r8,0
80005044:	c0 81       	brne	80005054 <xQueueGenericReceive+0xe0>
					{
						portENTER_CRITICAL();
80005046:	f0 1f 00 11 	mcall	80005088 <xQueueGenericReceive+0x114>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
8000504a:	6e 1c       	ld.w	r12,r7[0x4]
8000504c:	f0 1f 00 17 	mcall	800050a8 <xQueueGenericReceive+0x134>
						}
						portEXIT_CRITICAL();
80005050:	f0 1f 00 12 	mcall	80005098 <xQueueGenericReceive+0x124>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80005054:	40 2b       	lddsp	r11,sp[0x8]
80005056:	04 9c       	mov	r12,r2
80005058:	f0 1f 00 15 	mcall	800050ac <xQueueGenericReceive+0x138>
				prvUnlockQueue( pxQueue );
8000505c:	0e 9c       	mov	r12,r7
8000505e:	f0 1f 00 15 	mcall	800050b0 <xQueueGenericReceive+0x13c>
				if( !xTaskResumeAll() )
80005062:	f0 1f 00 15 	mcall	800050b4 <xQueueGenericReceive+0x140>
80005066:	c9 61       	brne	80004f92 <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80005068:	d7 33       	scall
8000506a:	c9 4b       	rjmp	80004f92 <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
8000506c:	0e 9c       	mov	r12,r7
8000506e:	f0 1f 00 11 	mcall	800050b0 <xQueueGenericReceive+0x13c>
				( void ) xTaskResumeAll();
80005072:	f0 1f 00 11 	mcall	800050b4 <xQueueGenericReceive+0x140>
80005076:	c8 eb       	rjmp	80004f92 <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80005078:	0e 9c       	mov	r12,r7
8000507a:	f0 1f 00 0e 	mcall	800050b0 <xQueueGenericReceive+0x13c>
			( void ) xTaskResumeAll();
8000507e:	f0 1f 00 0e 	mcall	800050b4 <xQueueGenericReceive+0x140>
80005082:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80005084:	2f bd       	sub	sp,-20
80005086:	d8 32       	popm	r0-r7,pc
80005088:	80 00       	ld.sh	r0,r0[0x0]
8000508a:	4c 10       	lddpc	r0,8000518c <xQueueGenericSend+0x5c>
8000508c:	80 00       	ld.sh	r0,r0[0x0]
8000508e:	4e a4       	lddpc	r4,80005234 <xQueueCreateMutex+0x4>
80005090:	80 00       	ld.sh	r0,r0[0x0]
80005092:	53 ac       	stdsp	sp[0xe8],r12
80005094:	80 00       	ld.sh	r0,r0[0x0]
80005096:	54 94       	stdsp	sp[0x124],r4
80005098:	80 00       	ld.sh	r0,r0[0x0]
8000509a:	4d 1c       	lddpc	r12,800051dc <xQueueGenericSend+0xac>
8000509c:	80 00       	ld.sh	r0,r0[0x0]
8000509e:	53 88       	stdsp	sp[0xe0],r8
800050a0:	80 00       	ld.sh	r0,r0[0x0]
800050a2:	52 fc       	stdsp	sp[0xbc],r12
800050a4:	80 00       	ld.sh	r0,r0[0x0]
800050a6:	56 24       	stdsp	sp[0x188],r4
800050a8:	80 00       	ld.sh	r0,r0[0x0]
800050aa:	54 10       	stdsp	sp[0x104],r0
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	58 c4       	cp.w	r4,12
800050b0:	80 00       	ld.sh	r0,r0[0x0]
800050b2:	4e d4       	lddpc	r4,80005264 <xQueueCreateMutex+0x34>
800050b4:	80 00       	ld.sh	r0,r0[0x0]
800050b6:	56 b8       	stdsp	sp[0x1ac],r8

800050b8 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
800050b8:	eb cd 40 80 	pushm	r7,lr
800050bc:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
800050be:	79 08       	ld.w	r8,r12[0x40]
800050c0:	58 08       	cp.w	r8,0
800050c2:	c0 a1       	brne	800050d6 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800050c4:	78 08       	ld.w	r8,r12[0x0]
800050c6:	58 08       	cp.w	r8,0
800050c8:	c2 b1       	brne	8000511e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
800050ca:	78 1c       	ld.w	r12,r12[0x4]
800050cc:	f0 1f 00 17 	mcall	80005128 <prvCopyDataToQueue+0x70>
				pxQueue->pxMutexHolder = NULL;
800050d0:	30 08       	mov	r8,0
800050d2:	8f 18       	st.w	r7[0x4],r8
800050d4:	c2 58       	rjmp	8000511e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
800050d6:	58 0a       	cp.w	r10,0
800050d8:	c1 01       	brne	800050f8 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800050da:	10 9a       	mov	r10,r8
800050dc:	78 2c       	ld.w	r12,r12[0x8]
800050de:	f0 1f 00 14 	mcall	8000512c <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
800050e2:	6e 29       	ld.w	r9,r7[0x8]
800050e4:	6f 08       	ld.w	r8,r7[0x40]
800050e6:	f2 08 00 08 	add	r8,r9,r8
800050ea:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
800050ec:	6e 19       	ld.w	r9,r7[0x4]
800050ee:	12 38       	cp.w	r8,r9
800050f0:	c1 73       	brcs	8000511e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
800050f2:	6e 08       	ld.w	r8,r7[0x0]
800050f4:	8f 28       	st.w	r7[0x8],r8
800050f6:	c1 48       	rjmp	8000511e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
800050f8:	10 9a       	mov	r10,r8
800050fa:	78 3c       	ld.w	r12,r12[0xc]
800050fc:	f0 1f 00 0c 	mcall	8000512c <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005100:	6f 08       	ld.w	r8,r7[0x40]
80005102:	6e 39       	ld.w	r9,r7[0xc]
80005104:	f2 08 01 08 	sub	r8,r9,r8
80005108:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000510a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000510c:	12 38       	cp.w	r8,r9
8000510e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005112:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005116:	f3 d8 e3 19 	subcs	r9,r9,r8
8000511a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000511e:	6e e8       	ld.w	r8,r7[0x38]
80005120:	2f f8       	sub	r8,-1
80005122:	8f e8       	st.w	r7[0x38],r8
}
80005124:	e3 cd 80 80 	ldm	sp++,r7,pc
80005128:	80 00       	ld.sh	r0,r0[0x0]
8000512a:	53 b8       	stdsp	sp[0xec],r8
8000512c:	80 00       	ld.sh	r0,r0[0x0]
8000512e:	64 8a       	ld.w	r10,r2[0x20]

80005130 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005130:	d4 31       	pushm	r0-r7,lr
80005132:	20 5d       	sub	sp,20
80005134:	18 97       	mov	r7,r12
80005136:	50 0b       	stdsp	sp[0x0],r11
80005138:	50 2a       	stdsp	sp[0x8],r10
8000513a:	50 19       	stdsp	sp[0x4],r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000513c:	f8 c0 ff f0 	sub	r0,r12,-16
80005140:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005142:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80005146:	08 91       	mov	r1,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005148:	fa c2 ff f8 	sub	r2,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
8000514c:	f0 1f 00 2f 	mcall	80005208 <xQueueGenericSend+0xd8>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005150:	6e e9       	ld.w	r9,r7[0x38]
80005152:	6e f8       	ld.w	r8,r7[0x3c]
80005154:	10 39       	cp.w	r9,r8
80005156:	c1 42       	brcc	8000517e <xQueueGenericSend+0x4e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80005158:	40 1a       	lddsp	r10,sp[0x4]
8000515a:	40 0b       	lddsp	r11,sp[0x0]
8000515c:	0e 9c       	mov	r12,r7
8000515e:	f0 1f 00 2c 	mcall	8000520c <xQueueGenericSend+0xdc>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80005162:	6e 98       	ld.w	r8,r7[0x24]
80005164:	58 08       	cp.w	r8,0
80005166:	c0 80       	breq	80005176 <xQueueGenericSend+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80005168:	ee cc ff dc 	sub	r12,r7,-36
8000516c:	f0 1f 00 29 	mcall	80005210 <xQueueGenericSend+0xe0>
80005170:	58 1c       	cp.w	r12,1
80005172:	c0 21       	brne	80005176 <xQueueGenericSend+0x46>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
80005174:	d7 33       	scall
					}
				}

				taskEXIT_CRITICAL();
80005176:	f0 1f 00 28 	mcall	80005214 <xQueueGenericSend+0xe4>
8000517a:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
8000517c:	c4 38       	rjmp	80005202 <xQueueGenericSend+0xd2>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
8000517e:	40 28       	lddsp	r8,sp[0x8]
80005180:	58 08       	cp.w	r8,0
80005182:	c0 51       	brne	8000518c <xQueueGenericSend+0x5c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80005184:	f0 1f 00 24 	mcall	80005214 <xQueueGenericSend+0xe4>
80005188:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8000518a:	c3 c8       	rjmp	80005202 <xQueueGenericSend+0xd2>
				}
				else if( xEntryTimeSet == pdFALSE )
8000518c:	58 04       	cp.w	r4,0
8000518e:	c0 51       	brne	80005198 <xQueueGenericSend+0x68>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80005190:	06 9c       	mov	r12,r3
80005192:	f0 1f 00 22 	mcall	80005218 <xQueueGenericSend+0xe8>
80005196:	30 14       	mov	r4,1
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
80005198:	f0 1f 00 1f 	mcall	80005214 <xQueueGenericSend+0xe4>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8000519c:	f0 1f 00 20 	mcall	8000521c <xQueueGenericSend+0xec>
		prvLockQueue( pxQueue );
800051a0:	f0 1f 00 1a 	mcall	80005208 <xQueueGenericSend+0xd8>
800051a4:	6f 18       	ld.w	r8,r7[0x44]
800051a6:	5b f8       	cp.w	r8,-1
800051a8:	ef f1 0a 11 	st.weq	r7[0x44],r1
800051ac:	6f 28       	ld.w	r8,r7[0x48]
800051ae:	5b f8       	cp.w	r8,-1
800051b0:	ef f1 0a 12 	st.weq	r7[0x48],r1
800051b4:	f0 1f 00 18 	mcall	80005214 <xQueueGenericSend+0xe4>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800051b8:	04 9b       	mov	r11,r2
800051ba:	06 9c       	mov	r12,r3
800051bc:	f0 1f 00 19 	mcall	80005220 <xQueueGenericSend+0xf0>
800051c0:	c1 b1       	brne	800051f6 <xQueueGenericSend+0xc6>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
800051c2:	f0 1f 00 12 	mcall	80005208 <xQueueGenericSend+0xd8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
800051c6:	6e e5       	ld.w	r5,r7[0x38]
800051c8:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
800051ca:	f0 1f 00 13 	mcall	80005214 <xQueueGenericSend+0xe4>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
800051ce:	0c 35       	cp.w	r5,r6
800051d0:	c0 d1       	brne	800051ea <xQueueGenericSend+0xba>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
800051d2:	40 2b       	lddsp	r11,sp[0x8]
800051d4:	00 9c       	mov	r12,r0
800051d6:	f0 1f 00 14 	mcall	80005224 <xQueueGenericSend+0xf4>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
800051da:	0e 9c       	mov	r12,r7
800051dc:	f0 1f 00 13 	mcall	80005228 <xQueueGenericSend+0xf8>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
800051e0:	f0 1f 00 13 	mcall	8000522c <xQueueGenericSend+0xfc>
800051e4:	cb 41       	brne	8000514c <xQueueGenericSend+0x1c>
				{
					portYIELD_WITHIN_API();
800051e6:	d7 33       	scall
800051e8:	cb 2b       	rjmp	8000514c <xQueueGenericSend+0x1c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
800051ea:	0e 9c       	mov	r12,r7
800051ec:	f0 1f 00 0f 	mcall	80005228 <xQueueGenericSend+0xf8>
				( void ) xTaskResumeAll();
800051f0:	f0 1f 00 0f 	mcall	8000522c <xQueueGenericSend+0xfc>
800051f4:	ca cb       	rjmp	8000514c <xQueueGenericSend+0x1c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
800051f6:	0e 9c       	mov	r12,r7
800051f8:	f0 1f 00 0c 	mcall	80005228 <xQueueGenericSend+0xf8>
			( void ) xTaskResumeAll();
800051fc:	f0 1f 00 0c 	mcall	8000522c <xQueueGenericSend+0xfc>
80005200:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80005202:	2f bd       	sub	sp,-20
80005204:	d8 32       	popm	r0-r7,pc
80005206:	00 00       	add	r0,r0
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	4c 10       	lddpc	r0,8000530c <vTaskSwitchContext>
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	50 b8       	stdsp	sp[0x2c],r8
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	54 94       	stdsp	sp[0x124],r4
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	4d 1c       	lddpc	r12,80005358 <vTaskSwitchContext+0x4c>
80005218:	80 00       	ld.sh	r0,r0[0x0]
8000521a:	53 88       	stdsp	sp[0xe0],r8
8000521c:	80 00       	ld.sh	r0,r0[0x0]
8000521e:	52 fc       	stdsp	sp[0xbc],r12
80005220:	80 00       	ld.sh	r0,r0[0x0]
80005222:	56 24       	stdsp	sp[0x188],r4
80005224:	80 00       	ld.sh	r0,r0[0x0]
80005226:	58 c4       	cp.w	r4,12
80005228:	80 00       	ld.sh	r0,r0[0x0]
8000522a:	4e d4       	lddpc	r4,800053dc <vTaskPriorityDisinherit+0x24>
8000522c:	80 00       	ld.sh	r0,r0[0x0]
8000522e:	56 b8       	stdsp	sp[0x1ac],r8

80005230 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
80005230:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005234:	34 cc       	mov	r12,76
80005236:	f0 1f 00 12 	mcall	8000527c <xQueueCreateMutex+0x4c>
8000523a:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000523c:	c1 d0       	breq	80005276 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000523e:	30 06       	mov	r6,0
80005240:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80005242:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005244:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80005246:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80005248:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
8000524a:	30 18       	mov	r8,1
8000524c:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
8000524e:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
80005252:	3f f8       	mov	r8,-1
80005254:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80005258:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
8000525c:	2f 0c       	sub	r12,-16
8000525e:	f0 1f 00 09 	mcall	80005280 <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
80005262:	ee cc ff dc 	sub	r12,r7,-36
80005266:	f0 1f 00 07 	mcall	80005280 <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
8000526a:	0c 99       	mov	r9,r6
8000526c:	0c 9a       	mov	r10,r6
8000526e:	0c 9b       	mov	r11,r6
80005270:	0e 9c       	mov	r12,r7
80005272:	f0 1f 00 05 	mcall	80005284 <xQueueCreateMutex+0x54>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
80005276:	0e 9c       	mov	r12,r7
80005278:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000527c:	80 00       	ld.sh	r0,r0[0x0]
8000527e:	4e 7c       	lddpc	r12,80005418 <vTaskPriorityInherit+0x8>
80005280:	80 00       	ld.sh	r0,r0[0x0]
80005282:	4a ec       	lddpc	r12,80005338 <vTaskSwitchContext+0x2c>
80005284:	80 00       	ld.sh	r0,r0[0x0]
80005286:	51 30       	stdsp	sp[0x4c],r0

80005288 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005288:	d4 21       	pushm	r4-r7,lr
8000528a:	18 97       	mov	r7,r12
8000528c:	16 96       	mov	r6,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000528e:	58 0c       	cp.w	r12,0
80005290:	c2 f0       	breq	800052ee <xQueueCreate+0x66>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005292:	34 cc       	mov	r12,76
80005294:	f0 1f 00 17 	mcall	800052f0 <xQueueCreate+0x68>
80005298:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
8000529a:	c2 a0       	breq	800052ee <xQueueCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000529c:	ec 07 02 44 	mul	r4,r6,r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
800052a0:	e8 cc ff ff 	sub	r12,r4,-1
800052a4:	f0 1f 00 13 	mcall	800052f0 <xQueueCreate+0x68>
800052a8:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
800052aa:	c1 e0       	breq	800052e6 <xQueueCreate+0x5e>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
800052ac:	f8 04 00 04 	add	r4,r12,r4
800052b0:	8b 14       	st.w	r5[0x4],r4
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
800052b2:	30 08       	mov	r8,0
800052b4:	8b e8       	st.w	r5[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
800052b6:	8b 2c       	st.w	r5[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
800052b8:	ee c8 00 01 	sub	r8,r7,1
800052bc:	ad 38       	mul	r8,r6
800052be:	10 0c       	add	r12,r8
800052c0:	8b 3c       	st.w	r5[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800052c2:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
800052c4:	eb 46 00 40 	st.w	r5[64],r6
				pxNewQueue->xRxLock = queueUNLOCKED;
800052c8:	3f f8       	mov	r8,-1
800052ca:	eb 48 00 44 	st.w	r5[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800052ce:	eb 48 00 48 	st.w	r5[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800052d2:	ea cc ff f0 	sub	r12,r5,-16
800052d6:	f0 1f 00 08 	mcall	800052f4 <xQueueCreate+0x6c>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800052da:	ea cc ff dc 	sub	r12,r5,-36
800052de:	f0 1f 00 06 	mcall	800052f4 <xQueueCreate+0x6c>
800052e2:	0a 9c       	mov	r12,r5
800052e4:	d8 22       	popm	r4-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800052e6:	0a 9c       	mov	r12,r5
800052e8:	f0 1f 00 04 	mcall	800052f8 <xQueueCreate+0x70>
800052ec:	d8 2a       	popm	r4-r7,pc,r12=0
800052ee:	d8 2a       	popm	r4-r7,pc,r12=0
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	4e 7c       	lddpc	r12,8000548c <vTaskPriorityInherit+0x7c>
800052f4:	80 00       	ld.sh	r0,r0[0x0]
800052f6:	4a ec       	lddpc	r12,800053ac <xTaskGetCurrentTaskHandle>
800052f8:	80 00       	ld.sh	r0,r0[0x0]
800052fa:	4e 54       	lddpc	r4,8000548c <vTaskPriorityInherit+0x7c>

800052fc <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800052fc:	48 38       	lddpc	r8,80005308 <vTaskSuspendAll+0xc>
800052fe:	70 09       	ld.w	r9,r8[0x0]
80005300:	2f f9       	sub	r9,-1
80005302:	91 09       	st.w	r8[0x0],r9
}
80005304:	5e fc       	retal	r12
80005306:	00 00       	add	r0,r0
80005308:	00 00       	add	r0,r0
8000530a:	0c 6c       	and	r12,r6

8000530c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000530c:	49 a8       	lddpc	r8,80005374 <vTaskSwitchContext+0x68>
8000530e:	70 08       	ld.w	r8,r8[0x0]
80005310:	58 08       	cp.w	r8,0
80005312:	c0 b1       	brne	80005328 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005314:	49 98       	lddpc	r8,80005378 <vTaskSwitchContext+0x6c>
80005316:	70 08       	ld.w	r8,r8[0x0]
80005318:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000531c:	49 89       	lddpc	r9,8000537c <vTaskSwitchContext+0x70>
8000531e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005322:	58 08       	cp.w	r8,0
80005324:	c0 60       	breq	80005330 <vTaskSwitchContext+0x24>
80005326:	c1 18       	rjmp	80005348 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005328:	30 19       	mov	r9,1
8000532a:	49 68       	lddpc	r8,80005380 <vTaskSwitchContext+0x74>
8000532c:	91 09       	st.w	r8[0x0],r9
8000532e:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005330:	49 28       	lddpc	r8,80005378 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005332:	49 3a       	lddpc	r10,8000537c <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005334:	70 09       	ld.w	r9,r8[0x0]
80005336:	20 19       	sub	r9,1
80005338:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000533a:	70 09       	ld.w	r9,r8[0x0]
8000533c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005340:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005344:	58 09       	cp.w	r9,0
80005346:	cf 70       	breq	80005334 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005348:	48 c8       	lddpc	r8,80005378 <vTaskSwitchContext+0x6c>
8000534a:	70 08       	ld.w	r8,r8[0x0]
8000534c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005350:	48 b9       	lddpc	r9,8000537c <vTaskSwitchContext+0x70>
80005352:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005356:	70 19       	ld.w	r9,r8[0x4]
80005358:	72 19       	ld.w	r9,r9[0x4]
8000535a:	91 19       	st.w	r8[0x4],r9
8000535c:	f0 ca ff f8 	sub	r10,r8,-8
80005360:	14 39       	cp.w	r9,r10
80005362:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005366:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000536a:	70 18       	ld.w	r8,r8[0x4]
8000536c:	70 39       	ld.w	r9,r8[0xc]
8000536e:	48 68       	lddpc	r8,80005384 <vTaskSwitchContext+0x78>
80005370:	91 09       	st.w	r8[0x0],r9
80005372:	5e fc       	retal	r12
80005374:	00 00       	add	r0,r0
80005376:	0c 6c       	and	r12,r6
80005378:	00 00       	add	r0,r0
8000537a:	0c a4       	st.w	r6++,r4
8000537c:	00 00       	add	r0,r0
8000537e:	0b 88       	ld.ub	r8,r5[0x0]
80005380:	00 00       	add	r0,r0
80005382:	0c 8c       	andn	r12,r6
80005384:	00 00       	add	r0,r0
80005386:	0c 3c       	cp.w	r12,r6

80005388 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005388:	48 48       	lddpc	r8,80005398 <vTaskSetTimeOutState+0x10>
8000538a:	70 08       	ld.w	r8,r8[0x0]
8000538c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000538e:	48 48       	lddpc	r8,8000539c <vTaskSetTimeOutState+0x14>
80005390:	70 08       	ld.w	r8,r8[0x0]
80005392:	99 18       	st.w	r12[0x4],r8
}
80005394:	5e fc       	retal	r12
80005396:	00 00       	add	r0,r0
80005398:	00 00       	add	r0,r0
8000539a:	0b 80       	ld.ub	r0,r5[0x0]
8000539c:	00 00       	add	r0,r0
8000539e:	0c 68       	and	r8,r6

800053a0 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800053a0:	30 19       	mov	r9,1
800053a2:	48 28       	lddpc	r8,800053a8 <vTaskMissedYield+0x8>
800053a4:	91 09       	st.w	r8[0x0],r9
}
800053a6:	5e fc       	retal	r12
800053a8:	00 00       	add	r0,r0
800053aa:	0c 8c       	andn	r12,r6

800053ac <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
800053ac:	48 28       	lddpc	r8,800053b4 <xTaskGetCurrentTaskHandle+0x8>
800053ae:	70 0c       	ld.w	r12,r8[0x0]

		return xReturn;
	}
800053b0:	5e fc       	retal	r12
800053b2:	00 00       	add	r0,r0
800053b4:	00 00       	add	r0,r0
800053b6:	0c 3c       	cp.w	r12,r6

800053b8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
800053b8:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
800053bc:	58 0c       	cp.w	r12,0
800053be:	c1 f0       	breq	800053fc <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
800053c0:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
800053c2:	78 b9       	ld.w	r9,r12[0x2c]
800053c4:	79 18       	ld.w	r8,r12[0x44]
800053c6:	10 39       	cp.w	r9,r8
800053c8:	c1 a0       	breq	800053fc <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
800053ca:	f8 c6 ff fc 	sub	r6,r12,-4
800053ce:	0c 9c       	mov	r12,r6
800053d0:	f0 1f 00 0c 	mcall	80005400 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
800053d4:	6f 1c       	ld.w	r12,r7[0x44]
800053d6:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
800053d8:	f8 08 11 08 	rsub	r8,r12,8
800053dc:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
800053de:	48 a8       	lddpc	r8,80005404 <vTaskPriorityDisinherit+0x4c>
800053e0:	70 08       	ld.w	r8,r8[0x0]
800053e2:	10 3c       	cp.w	r12,r8
800053e4:	e0 88 00 04 	brls	800053ec <vTaskPriorityDisinherit+0x34>
800053e8:	48 78       	lddpc	r8,80005404 <vTaskPriorityDisinherit+0x4c>
800053ea:	91 0c       	st.w	r8[0x0],r12
800053ec:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800053f0:	0c 9b       	mov	r11,r6
800053f2:	48 68       	lddpc	r8,80005408 <vTaskPriorityDisinherit+0x50>
800053f4:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800053f8:	f0 1f 00 05 	mcall	8000540c <vTaskPriorityDisinherit+0x54>
800053fc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005400:	80 00       	ld.sh	r0,r0[0x0]
80005402:	4b 56       	lddpc	r6,800054d4 <xTaskRemoveFromEventList+0x40>
80005404:	00 00       	add	r0,r0
80005406:	0c a4       	st.w	r6++,r4
80005408:	00 00       	add	r0,r0
8000540a:	0b 88       	ld.ub	r8,r5[0x0]
8000540c:	80 00       	ld.sh	r0,r0[0x0]
8000540e:	4b 06       	lddpc	r6,800054cc <xTaskRemoveFromEventList+0x38>

80005410 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005410:	eb cd 40 c0 	pushm	r6-r7,lr
80005414:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80005416:	49 b8       	lddpc	r8,80005480 <vTaskPriorityInherit+0x70>
80005418:	70 08       	ld.w	r8,r8[0x0]
8000541a:	78 b9       	ld.w	r9,r12[0x2c]
8000541c:	70 b8       	ld.w	r8,r8[0x2c]
8000541e:	10 39       	cp.w	r9,r8
80005420:	c2 d2       	brcc	8000547a <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
80005422:	49 88       	lddpc	r8,80005480 <vTaskPriorityInherit+0x70>
80005424:	70 08       	ld.w	r8,r8[0x0]
80005426:	70 b8       	ld.w	r8,r8[0x2c]
80005428:	f0 08 11 08 	rsub	r8,r8,8
8000542c:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
8000542e:	f2 09 00 28 	add	r8,r9,r9<<0x2
80005432:	49 59       	lddpc	r9,80005484 <vTaskPriorityInherit+0x74>
80005434:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005438:	78 59       	ld.w	r9,r12[0x14]
8000543a:	10 39       	cp.w	r9,r8
8000543c:	c1 b1       	brne	80005472 <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
8000543e:	f8 c6 ff fc 	sub	r6,r12,-4
80005442:	0c 9c       	mov	r12,r6
80005444:	f0 1f 00 11 	mcall	80005488 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005448:	48 e8       	lddpc	r8,80005480 <vTaskPriorityInherit+0x70>
8000544a:	70 08       	ld.w	r8,r8[0x0]
8000544c:	70 bc       	ld.w	r12,r8[0x2c]
8000544e:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
80005450:	48 f8       	lddpc	r8,8000548c <vTaskPriorityInherit+0x7c>
80005452:	70 08       	ld.w	r8,r8[0x0]
80005454:	10 3c       	cp.w	r12,r8
80005456:	e0 88 00 04 	brls	8000545e <vTaskPriorityInherit+0x4e>
8000545a:	48 d8       	lddpc	r8,8000548c <vTaskPriorityInherit+0x7c>
8000545c:	91 0c       	st.w	r8[0x0],r12
8000545e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005462:	0c 9b       	mov	r11,r6
80005464:	48 88       	lddpc	r8,80005484 <vTaskPriorityInherit+0x74>
80005466:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000546a:	f0 1f 00 0a 	mcall	80005490 <vTaskPriorityInherit+0x80>
8000546e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80005472:	48 48       	lddpc	r8,80005480 <vTaskPriorityInherit+0x70>
80005474:	70 08       	ld.w	r8,r8[0x0]
80005476:	70 b8       	ld.w	r8,r8[0x2c]
80005478:	99 b8       	st.w	r12[0x2c],r8
8000547a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000547e:	00 00       	add	r0,r0
80005480:	00 00       	add	r0,r0
80005482:	0c 3c       	cp.w	r12,r6
80005484:	00 00       	add	r0,r0
80005486:	0b 88       	ld.ub	r8,r5[0x0]
80005488:	80 00       	ld.sh	r0,r0[0x0]
8000548a:	4b 56       	lddpc	r6,8000555c <vTaskIncrementTick+0x4c>
8000548c:	00 00       	add	r0,r0
8000548e:	0c a4       	st.w	r6++,r4
80005490:	80 00       	ld.sh	r0,r0[0x0]
80005492:	4b 06       	lddpc	r6,80005550 <vTaskIncrementTick+0x40>

80005494 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005494:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005498:	78 38       	ld.w	r8,r12[0xc]
8000549a:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
8000549c:	ee c6 ff e8 	sub	r6,r7,-24
800054a0:	0c 9c       	mov	r12,r6
800054a2:	f0 1f 00 15 	mcall	800054f4 <xTaskRemoveFromEventList+0x60>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800054a6:	49 58       	lddpc	r8,800054f8 <xTaskRemoveFromEventList+0x64>
800054a8:	70 08       	ld.w	r8,r8[0x0]
800054aa:	58 08       	cp.w	r8,0
800054ac:	c1 71       	brne	800054da <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800054ae:	ee c6 ff fc 	sub	r6,r7,-4
800054b2:	0c 9c       	mov	r12,r6
800054b4:	f0 1f 00 10 	mcall	800054f4 <xTaskRemoveFromEventList+0x60>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800054b8:	6e bc       	ld.w	r12,r7[0x2c]
800054ba:	49 18       	lddpc	r8,800054fc <xTaskRemoveFromEventList+0x68>
800054bc:	70 08       	ld.w	r8,r8[0x0]
800054be:	10 3c       	cp.w	r12,r8
800054c0:	e0 88 00 04 	brls	800054c8 <xTaskRemoveFromEventList+0x34>
800054c4:	48 e8       	lddpc	r8,800054fc <xTaskRemoveFromEventList+0x68>
800054c6:	91 0c       	st.w	r8[0x0],r12
800054c8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800054cc:	0c 9b       	mov	r11,r6
800054ce:	48 d8       	lddpc	r8,80005500 <xTaskRemoveFromEventList+0x6c>
800054d0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800054d4:	f0 1f 00 0c 	mcall	80005504 <xTaskRemoveFromEventList+0x70>
800054d8:	c0 58       	rjmp	800054e2 <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
800054da:	0c 9b       	mov	r11,r6
800054dc:	48 bc       	lddpc	r12,80005508 <xTaskRemoveFromEventList+0x74>
800054de:	f0 1f 00 0a 	mcall	80005504 <xTaskRemoveFromEventList+0x70>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
800054e2:	48 b8       	lddpc	r8,8000550c <xTaskRemoveFromEventList+0x78>
800054e4:	70 08       	ld.w	r8,r8[0x0]
800054e6:	6e b9       	ld.w	r9,r7[0x2c]
800054e8:	70 b8       	ld.w	r8,r8[0x2c]
800054ea:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
800054ec:	5f 2c       	srhs	r12
800054ee:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800054f2:	00 00       	add	r0,r0
800054f4:	80 00       	ld.sh	r0,r0[0x0]
800054f6:	4b 56       	lddpc	r6,800055c8 <vTaskIncrementTick+0xb8>
800054f8:	00 00       	add	r0,r0
800054fa:	0c 6c       	and	r12,r6
800054fc:	00 00       	add	r0,r0
800054fe:	0c a4       	st.w	r6++,r4
80005500:	00 00       	add	r0,r0
80005502:	0b 88       	ld.ub	r8,r5[0x0]
80005504:	80 00       	ld.sh	r0,r0[0x0]
80005506:	4b 06       	lddpc	r6,800055c4 <vTaskIncrementTick+0xb4>
80005508:	00 00       	add	r0,r0
8000550a:	0c 40       	or	r0,r6
8000550c:	00 00       	add	r0,r0
8000550e:	0c 3c       	cp.w	r12,r6

80005510 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005510:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005514:	4b 98       	lddpc	r8,800055f8 <vTaskIncrementTick+0xe8>
80005516:	70 08       	ld.w	r8,r8[0x0]
80005518:	58 08       	cp.w	r8,0
8000551a:	c6 91       	brne	800055ec <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
8000551c:	4b 88       	lddpc	r8,800055fc <vTaskIncrementTick+0xec>
8000551e:	70 09       	ld.w	r9,r8[0x0]
80005520:	2f f9       	sub	r9,-1
80005522:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005524:	70 08       	ld.w	r8,r8[0x0]
80005526:	58 08       	cp.w	r8,0
80005528:	c1 a1       	brne	8000555c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
8000552a:	4b 68       	lddpc	r8,80005600 <vTaskIncrementTick+0xf0>
8000552c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
8000552e:	4b 69       	lddpc	r9,80005604 <vTaskIncrementTick+0xf4>
80005530:	72 0b       	ld.w	r11,r9[0x0]
80005532:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005534:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005536:	4b 59       	lddpc	r9,80005608 <vTaskIncrementTick+0xf8>
80005538:	72 0a       	ld.w	r10,r9[0x0]
8000553a:	2f fa       	sub	r10,-1
8000553c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8000553e:	70 08       	ld.w	r8,r8[0x0]
80005540:	70 08       	ld.w	r8,r8[0x0]
80005542:	58 08       	cp.w	r8,0
80005544:	c0 51       	brne	8000554e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005546:	3f f9       	mov	r9,-1
80005548:	4b 18       	lddpc	r8,8000560c <vTaskIncrementTick+0xfc>
8000554a:	91 09       	st.w	r8[0x0],r9
8000554c:	c0 88       	rjmp	8000555c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
8000554e:	4a d8       	lddpc	r8,80005600 <vTaskIncrementTick+0xf0>
80005550:	70 08       	ld.w	r8,r8[0x0]
80005552:	70 38       	ld.w	r8,r8[0xc]
80005554:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005556:	70 19       	ld.w	r9,r8[0x4]
80005558:	4a d8       	lddpc	r8,8000560c <vTaskIncrementTick+0xfc>
8000555a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
8000555c:	4a 88       	lddpc	r8,800055fc <vTaskIncrementTick+0xec>
8000555e:	70 09       	ld.w	r9,r8[0x0]
80005560:	4a b8       	lddpc	r8,8000560c <vTaskIncrementTick+0xfc>
80005562:	70 08       	ld.w	r8,r8[0x0]
80005564:	10 39       	cp.w	r9,r8
80005566:	c4 73       	brcs	800055f4 <vTaskIncrementTick+0xe4>
80005568:	4a 68       	lddpc	r8,80005600 <vTaskIncrementTick+0xf0>
8000556a:	70 08       	ld.w	r8,r8[0x0]
8000556c:	70 08       	ld.w	r8,r8[0x0]
8000556e:	58 08       	cp.w	r8,0
80005570:	c0 c0       	breq	80005588 <vTaskIncrementTick+0x78>
80005572:	4a 48       	lddpc	r8,80005600 <vTaskIncrementTick+0xf0>
80005574:	70 08       	ld.w	r8,r8[0x0]
80005576:	70 38       	ld.w	r8,r8[0xc]
80005578:	70 37       	ld.w	r7,r8[0xc]
8000557a:	6e 18       	ld.w	r8,r7[0x4]
8000557c:	4a 09       	lddpc	r9,800055fc <vTaskIncrementTick+0xec>
8000557e:	72 09       	ld.w	r9,r9[0x0]
80005580:	12 38       	cp.w	r8,r9
80005582:	e0 88 00 14 	brls	800055aa <vTaskIncrementTick+0x9a>
80005586:	c0 e8       	rjmp	800055a2 <vTaskIncrementTick+0x92>
80005588:	3f f9       	mov	r9,-1
8000558a:	4a 18       	lddpc	r8,8000560c <vTaskIncrementTick+0xfc>
8000558c:	91 09       	st.w	r8[0x0],r9
8000558e:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005592:	6a 08       	ld.w	r8,r5[0x0]
80005594:	70 38       	ld.w	r8,r8[0xc]
80005596:	70 37       	ld.w	r7,r8[0xc]
80005598:	6e 18       	ld.w	r8,r7[0x4]
8000559a:	64 09       	ld.w	r9,r2[0x0]
8000559c:	12 38       	cp.w	r8,r9
8000559e:	e0 88 00 0a 	brls	800055b2 <vTaskIncrementTick+0xa2>
800055a2:	49 b9       	lddpc	r9,8000560c <vTaskIncrementTick+0xfc>
800055a4:	93 08       	st.w	r9[0x0],r8
800055a6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800055aa:	49 a4       	lddpc	r4,80005610 <vTaskIncrementTick+0x100>
800055ac:	49 a3       	lddpc	r3,80005614 <vTaskIncrementTick+0x104>
800055ae:	49 55       	lddpc	r5,80005600 <vTaskIncrementTick+0xf0>
800055b0:	49 32       	lddpc	r2,800055fc <vTaskIncrementTick+0xec>
800055b2:	ee c6 ff fc 	sub	r6,r7,-4
800055b6:	0c 9c       	mov	r12,r6
800055b8:	f0 1f 00 18 	mcall	80005618 <vTaskIncrementTick+0x108>
800055bc:	6e a8       	ld.w	r8,r7[0x28]
800055be:	58 08       	cp.w	r8,0
800055c0:	c0 50       	breq	800055ca <vTaskIncrementTick+0xba>
800055c2:	ee cc ff e8 	sub	r12,r7,-24
800055c6:	f0 1f 00 15 	mcall	80005618 <vTaskIncrementTick+0x108>
800055ca:	6e bc       	ld.w	r12,r7[0x2c]
800055cc:	68 08       	ld.w	r8,r4[0x0]
800055ce:	10 3c       	cp.w	r12,r8
800055d0:	e9 fc ba 00 	st.whi	r4[0x0],r12
800055d4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800055d8:	0c 9b       	mov	r11,r6
800055da:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
800055de:	f0 1f 00 10 	mcall	8000561c <vTaskIncrementTick+0x10c>
800055e2:	6a 08       	ld.w	r8,r5[0x0]
800055e4:	70 08       	ld.w	r8,r8[0x0]
800055e6:	58 08       	cp.w	r8,0
800055e8:	cd 51       	brne	80005592 <vTaskIncrementTick+0x82>
800055ea:	cc fb       	rjmp	80005588 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
800055ec:	48 d8       	lddpc	r8,80005620 <vTaskIncrementTick+0x110>
800055ee:	70 09       	ld.w	r9,r8[0x0]
800055f0:	2f f9       	sub	r9,-1
800055f2:	91 09       	st.w	r8[0x0],r9
800055f4:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
800055f8:	00 00       	add	r0,r0
800055fa:	0c 6c       	and	r12,r6
800055fc:	00 00       	add	r0,r0
800055fe:	0c 68       	and	r8,r6
80005600:	00 00       	add	r0,r0
80005602:	0b 74       	ld.ub	r4,--r5
80005604:	00 00       	add	r0,r0
80005606:	0b 84       	ld.ub	r4,r5[0x0]
80005608:	00 00       	add	r0,r0
8000560a:	0b 80       	ld.ub	r0,r5[0x0]
8000560c:	00 00       	add	r0,r0
8000560e:	05 14       	ld.sh	r4,r2++
80005610:	00 00       	add	r0,r0
80005612:	0c a4       	st.w	r6++,r4
80005614:	00 00       	add	r0,r0
80005616:	0b 88       	ld.ub	r8,r5[0x0]
80005618:	80 00       	ld.sh	r0,r0[0x0]
8000561a:	4b 56       	lddpc	r6,800056ec <xTaskResumeAll+0x34>
8000561c:	80 00       	ld.sh	r0,r0[0x0]
8000561e:	4b 06       	lddpc	r6,800056dc <xTaskResumeAll+0x24>
80005620:	00 00       	add	r0,r0
80005622:	0b 6c       	ld.uh	r12,--r5

80005624 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005624:	eb cd 40 c0 	pushm	r6-r7,lr
80005628:	18 97       	mov	r7,r12
8000562a:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
8000562c:	f0 1f 00 15 	mcall	80005680 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005630:	6c 08       	ld.w	r8,r6[0x0]
80005632:	5b f8       	cp.w	r8,-1
80005634:	c0 31       	brne	8000563a <xTaskCheckForTimeOut+0x16>
80005636:	30 07       	mov	r7,0
80005638:	c1 f8       	rjmp	80005676 <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
8000563a:	49 39       	lddpc	r9,80005684 <xTaskCheckForTimeOut+0x60>
8000563c:	72 09       	ld.w	r9,r9[0x0]
8000563e:	6e 0a       	ld.w	r10,r7[0x0]
80005640:	12 3a       	cp.w	r10,r9
80005642:	c0 70       	breq	80005650 <xTaskCheckForTimeOut+0x2c>
80005644:	49 19       	lddpc	r9,80005688 <xTaskCheckForTimeOut+0x64>
80005646:	72 09       	ld.w	r9,r9[0x0]
80005648:	6e 1a       	ld.w	r10,r7[0x4]
8000564a:	12 3a       	cp.w	r10,r9
8000564c:	e0 88 00 14 	brls	80005674 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005650:	48 e9       	lddpc	r9,80005688 <xTaskCheckForTimeOut+0x64>
80005652:	72 0a       	ld.w	r10,r9[0x0]
80005654:	6e 19       	ld.w	r9,r7[0x4]
80005656:	12 1a       	sub	r10,r9
80005658:	14 38       	cp.w	r8,r10
8000565a:	e0 88 00 0d 	brls	80005674 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
8000565e:	48 ba       	lddpc	r10,80005688 <xTaskCheckForTimeOut+0x64>
80005660:	74 0a       	ld.w	r10,r10[0x0]
80005662:	14 19       	sub	r9,r10
80005664:	f2 08 00 08 	add	r8,r9,r8
80005668:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
8000566a:	0e 9c       	mov	r12,r7
8000566c:	f0 1f 00 08 	mcall	8000568c <xTaskCheckForTimeOut+0x68>
80005670:	30 07       	mov	r7,0
80005672:	c0 28       	rjmp	80005676 <xTaskCheckForTimeOut+0x52>
80005674:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005676:	f0 1f 00 07 	mcall	80005690 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
8000567a:	0e 9c       	mov	r12,r7
8000567c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005680:	80 00       	ld.sh	r0,r0[0x0]
80005682:	4c 10       	lddpc	r0,80005784 <xTaskResumeAll+0xcc>
80005684:	00 00       	add	r0,r0
80005686:	0b 80       	ld.ub	r0,r5[0x0]
80005688:	00 00       	add	r0,r0
8000568a:	0c 68       	and	r8,r6
8000568c:	80 00       	ld.sh	r0,r0[0x0]
8000568e:	53 88       	stdsp	sp[0xe0],r8
80005690:	80 00       	ld.sh	r0,r0[0x0]
80005692:	4d 1c       	lddpc	r12,800057d4 <prvAddCurrentTaskToDelayedList+0x34>

80005694 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005694:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005698:	f0 1f 00 05 	mcall	800056ac <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
8000569c:	48 58       	lddpc	r8,800056b0 <xTaskGetTickCount+0x1c>
8000569e:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800056a0:	f0 1f 00 05 	mcall	800056b4 <xTaskGetTickCount+0x20>

	return xTicks;
}
800056a4:	0e 9c       	mov	r12,r7
800056a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800056aa:	00 00       	add	r0,r0
800056ac:	80 00       	ld.sh	r0,r0[0x0]
800056ae:	4c 10       	lddpc	r0,800057b0 <prvAddCurrentTaskToDelayedList+0x10>
800056b0:	00 00       	add	r0,r0
800056b2:	0c 68       	and	r8,r6
800056b4:	80 00       	ld.sh	r0,r0[0x0]
800056b6:	4d 1c       	lddpc	r12,800057f8 <prvAddCurrentTaskToDelayedList+0x58>

800056b8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
800056b8:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
800056bc:	f0 1f 00 2c 	mcall	8000576c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
800056c0:	4a c8       	lddpc	r8,80005770 <xTaskResumeAll+0xb8>
800056c2:	70 09       	ld.w	r9,r8[0x0]
800056c4:	20 19       	sub	r9,1
800056c6:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800056c8:	70 08       	ld.w	r8,r8[0x0]
800056ca:	58 08       	cp.w	r8,0
800056cc:	c4 91       	brne	8000575e <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
800056ce:	4a a8       	lddpc	r8,80005774 <xTaskResumeAll+0xbc>
800056d0:	70 08       	ld.w	r8,r8[0x0]
800056d2:	58 08       	cp.w	r8,0
800056d4:	c4 50       	breq	8000575e <xTaskResumeAll+0xa6>
800056d6:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
800056d8:	4a 85       	lddpc	r5,80005778 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
800056da:	4a 93       	lddpc	r3,8000577c <xTaskResumeAll+0xc4>
800056dc:	4a 92       	lddpc	r2,80005780 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
800056de:	4a a1       	lddpc	r1,80005784 <xTaskResumeAll+0xcc>
800056e0:	c1 e8       	rjmp	8000571c <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
800056e2:	6a 38       	ld.w	r8,r5[0xc]
800056e4:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
800056e6:	ee cc ff e8 	sub	r12,r7,-24
800056ea:	f0 1f 00 28 	mcall	80005788 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
800056ee:	ee c6 ff fc 	sub	r6,r7,-4
800056f2:	0c 9c       	mov	r12,r6
800056f4:	f0 1f 00 25 	mcall	80005788 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
800056f8:	6e bc       	ld.w	r12,r7[0x2c]
800056fa:	66 08       	ld.w	r8,r3[0x0]
800056fc:	10 3c       	cp.w	r12,r8
800056fe:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005702:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005706:	0c 9b       	mov	r11,r6
80005708:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
8000570c:	f0 1f 00 20 	mcall	8000578c <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005710:	62 08       	ld.w	r8,r1[0x0]
80005712:	6e b9       	ld.w	r9,r7[0x2c]
80005714:	70 b8       	ld.w	r8,r8[0x2c]
80005716:	10 39       	cp.w	r9,r8
80005718:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
8000571c:	6a 08       	ld.w	r8,r5[0x0]
8000571e:	58 08       	cp.w	r8,0
80005720:	ce 11       	brne	800056e2 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005722:	49 c8       	lddpc	r8,80005790 <xTaskResumeAll+0xd8>
80005724:	70 08       	ld.w	r8,r8[0x0]
80005726:	58 08       	cp.w	r8,0
80005728:	c0 f0       	breq	80005746 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000572a:	49 a8       	lddpc	r8,80005790 <xTaskResumeAll+0xd8>
8000572c:	70 08       	ld.w	r8,r8[0x0]
8000572e:	58 08       	cp.w	r8,0
80005730:	c1 10       	breq	80005752 <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005732:	49 87       	lddpc	r7,80005790 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005734:	f0 1f 00 18 	mcall	80005794 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005738:	6e 08       	ld.w	r8,r7[0x0]
8000573a:	20 18       	sub	r8,1
8000573c:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
8000573e:	6e 08       	ld.w	r8,r7[0x0]
80005740:	58 08       	cp.w	r8,0
80005742:	cf 91       	brne	80005734 <xTaskResumeAll+0x7c>
80005744:	c0 78       	rjmp	80005752 <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005746:	58 14       	cp.w	r4,1
80005748:	c0 50       	breq	80005752 <xTaskResumeAll+0x9a>
8000574a:	49 48       	lddpc	r8,80005798 <xTaskResumeAll+0xe0>
8000574c:	70 08       	ld.w	r8,r8[0x0]
8000574e:	58 18       	cp.w	r8,1
80005750:	c0 71       	brne	8000575e <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005752:	30 09       	mov	r9,0
80005754:	49 18       	lddpc	r8,80005798 <xTaskResumeAll+0xe0>
80005756:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005758:	d7 33       	scall
8000575a:	30 17       	mov	r7,1
8000575c:	c0 28       	rjmp	80005760 <xTaskResumeAll+0xa8>
8000575e:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005760:	f0 1f 00 0f 	mcall	8000579c <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005764:	0e 9c       	mov	r12,r7
80005766:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000576a:	00 00       	add	r0,r0
8000576c:	80 00       	ld.sh	r0,r0[0x0]
8000576e:	4c 10       	lddpc	r0,80005870 <vTaskDelayUntil+0x2c>
80005770:	00 00       	add	r0,r0
80005772:	0c 6c       	and	r12,r6
80005774:	00 00       	add	r0,r0
80005776:	0c 88       	andn	r8,r6
80005778:	00 00       	add	r0,r0
8000577a:	0c 40       	or	r0,r6
8000577c:	00 00       	add	r0,r0
8000577e:	0c a4       	st.w	r6++,r4
80005780:	00 00       	add	r0,r0
80005782:	0b 88       	ld.ub	r8,r5[0x0]
80005784:	00 00       	add	r0,r0
80005786:	0c 3c       	cp.w	r12,r6
80005788:	80 00       	ld.sh	r0,r0[0x0]
8000578a:	4b 56       	lddpc	r6,8000585c <vTaskDelayUntil+0x18>
8000578c:	80 00       	ld.sh	r0,r0[0x0]
8000578e:	4b 06       	lddpc	r6,8000584c <vTaskDelayUntil+0x8>
80005790:	00 00       	add	r0,r0
80005792:	0b 6c       	ld.uh	r12,--r5
80005794:	80 00       	ld.sh	r0,r0[0x0]
80005796:	55 10       	stdsp	sp[0x144],r0
80005798:	00 00       	add	r0,r0
8000579a:	0c 8c       	andn	r12,r6
8000579c:	80 00       	ld.sh	r0,r0[0x0]
8000579e:	4d 1c       	lddpc	r12,800058e0 <vTaskPlaceOnEventList+0x1c>

800057a0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
800057a0:	eb cd 40 80 	pushm	r7,lr
800057a4:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
800057a6:	49 08       	lddpc	r8,800057e4 <prvAddCurrentTaskToDelayedList+0x44>
800057a8:	70 08       	ld.w	r8,r8[0x0]
800057aa:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
800057ac:	48 f8       	lddpc	r8,800057e8 <prvAddCurrentTaskToDelayedList+0x48>
800057ae:	70 08       	ld.w	r8,r8[0x0]
800057b0:	10 3c       	cp.w	r12,r8
800057b2:	c0 a2       	brcc	800057c6 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800057b4:	48 c8       	lddpc	r8,800057e4 <prvAddCurrentTaskToDelayedList+0x44>
800057b6:	70 0b       	ld.w	r11,r8[0x0]
800057b8:	48 d8       	lddpc	r8,800057ec <prvAddCurrentTaskToDelayedList+0x4c>
800057ba:	70 0c       	ld.w	r12,r8[0x0]
800057bc:	2f cb       	sub	r11,-4
800057be:	f0 1f 00 0d 	mcall	800057f0 <prvAddCurrentTaskToDelayedList+0x50>
800057c2:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800057c6:	48 88       	lddpc	r8,800057e4 <prvAddCurrentTaskToDelayedList+0x44>
800057c8:	70 0b       	ld.w	r11,r8[0x0]
800057ca:	48 b8       	lddpc	r8,800057f4 <prvAddCurrentTaskToDelayedList+0x54>
800057cc:	70 0c       	ld.w	r12,r8[0x0]
800057ce:	2f cb       	sub	r11,-4
800057d0:	f0 1f 00 08 	mcall	800057f0 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
800057d4:	48 98       	lddpc	r8,800057f8 <prvAddCurrentTaskToDelayedList+0x58>
800057d6:	70 08       	ld.w	r8,r8[0x0]
800057d8:	10 37       	cp.w	r7,r8
800057da:	c0 32       	brcc	800057e0 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
800057dc:	48 78       	lddpc	r8,800057f8 <prvAddCurrentTaskToDelayedList+0x58>
800057de:	91 07       	st.w	r8[0x0],r7
800057e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800057e4:	00 00       	add	r0,r0
800057e6:	0c 3c       	cp.w	r12,r6
800057e8:	00 00       	add	r0,r0
800057ea:	0c 68       	and	r8,r6
800057ec:	00 00       	add	r0,r0
800057ee:	0b 84       	ld.ub	r4,r5[0x0]
800057f0:	80 00       	ld.sh	r0,r0[0x0]
800057f2:	4b 22       	lddpc	r2,800058b8 <vTaskDelayUntil+0x74>
800057f4:	00 00       	add	r0,r0
800057f6:	0b 74       	ld.ub	r4,--r5
800057f8:	00 00       	add	r0,r0
800057fa:	05 14       	ld.sh	r4,r2++

800057fc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
800057fc:	eb cd 40 c0 	pushm	r6-r7,lr
80005800:	18 97       	mov	r7,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80005802:	58 0c       	cp.w	r12,0
80005804:	c1 10       	breq	80005826 <vTaskDelay+0x2a>
		{
			vTaskSuspendAll();
80005806:	f0 1f 00 0a 	mcall	8000582c <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
8000580a:	48 a8       	lddpc	r8,80005830 <vTaskDelay+0x34>
8000580c:	70 06       	ld.w	r6,r8[0x0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
8000580e:	48 a8       	lddpc	r8,80005834 <vTaskDelay+0x38>
80005810:	70 0c       	ld.w	r12,r8[0x0]
80005812:	2f cc       	sub	r12,-4
80005814:	f0 1f 00 09 	mcall	80005838 <vTaskDelay+0x3c>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005818:	ee 06 00 0c 	add	r12,r7,r6
8000581c:	f0 1f 00 08 	mcall	8000583c <vTaskDelay+0x40>
			}
			xAlreadyYielded = xTaskResumeAll();
80005820:	f0 1f 00 08 	mcall	80005840 <vTaskDelay+0x44>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005824:	c0 21       	brne	80005828 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80005826:	d7 33       	scall
80005828:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000582c:	80 00       	ld.sh	r0,r0[0x0]
8000582e:	52 fc       	stdsp	sp[0xbc],r12
80005830:	00 00       	add	r0,r0
80005832:	0c 68       	and	r8,r6
80005834:	00 00       	add	r0,r0
80005836:	0c 3c       	cp.w	r12,r6
80005838:	80 00       	ld.sh	r0,r0[0x0]
8000583a:	4b 56       	lddpc	r6,8000590c <vTaskPlaceOnEventList+0x48>
8000583c:	80 00       	ld.sh	r0,r0[0x0]
8000583e:	57 a0       	stdsp	sp[0x1e8],r0
80005840:	80 00       	ld.sh	r0,r0[0x0]
80005842:	56 b8       	stdsp	sp[0x1ac],r8

80005844 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005844:	eb cd 40 c0 	pushm	r6-r7,lr
80005848:	18 96       	mov	r6,r12
8000584a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
8000584c:	f0 1f 00 18 	mcall	800058ac <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005850:	6c 08       	ld.w	r8,r6[0x0]
80005852:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005854:	49 79       	lddpc	r9,800058b0 <vTaskDelayUntil+0x6c>
80005856:	72 09       	ld.w	r9,r9[0x0]
80005858:	12 38       	cp.w	r8,r9
8000585a:	e0 88 00 0c 	brls	80005872 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
8000585e:	0e 38       	cp.w	r8,r7
80005860:	e0 88 00 22 	brls	800058a4 <vTaskDelayUntil+0x60>
80005864:	49 38       	lddpc	r8,800058b0 <vTaskDelayUntil+0x6c>
80005866:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005868:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
8000586a:	10 37       	cp.w	r7,r8
8000586c:	e0 88 00 14 	brls	80005894 <vTaskDelayUntil+0x50>
80005870:	c0 a8       	rjmp	80005884 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005872:	0e 38       	cp.w	r8,r7
80005874:	e0 8b 00 16 	brhi	800058a0 <vTaskDelayUntil+0x5c>
80005878:	48 e8       	lddpc	r8,800058b0 <vTaskDelayUntil+0x6c>
8000587a:	70 08       	ld.w	r8,r8[0x0]
8000587c:	10 37       	cp.w	r7,r8
8000587e:	e0 8b 00 11 	brhi	800058a0 <vTaskDelayUntil+0x5c>
80005882:	c1 18       	rjmp	800058a4 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005884:	48 c8       	lddpc	r8,800058b4 <vTaskDelayUntil+0x70>
80005886:	70 0c       	ld.w	r12,r8[0x0]
80005888:	2f cc       	sub	r12,-4
8000588a:	f0 1f 00 0c 	mcall	800058b8 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
8000588e:	0e 9c       	mov	r12,r7
80005890:	f0 1f 00 0b 	mcall	800058bc <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005894:	f0 1f 00 0b 	mcall	800058c0 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005898:	c0 81       	brne	800058a8 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
8000589a:	d7 33       	scall
8000589c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
800058a0:	8d 07       	st.w	r6[0x0],r7
800058a2:	cf 1b       	rjmp	80005884 <vTaskDelayUntil+0x40>
800058a4:	8d 07       	st.w	r6[0x0],r7
800058a6:	cf 7b       	rjmp	80005894 <vTaskDelayUntil+0x50>
800058a8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058ac:	80 00       	ld.sh	r0,r0[0x0]
800058ae:	52 fc       	stdsp	sp[0xbc],r12
800058b0:	00 00       	add	r0,r0
800058b2:	0c 68       	and	r8,r6
800058b4:	00 00       	add	r0,r0
800058b6:	0c 3c       	cp.w	r12,r6
800058b8:	80 00       	ld.sh	r0,r0[0x0]
800058ba:	4b 56       	lddpc	r6,8000598c <prvIdleTask+0x70>
800058bc:	80 00       	ld.sh	r0,r0[0x0]
800058be:	57 a0       	stdsp	sp[0x1e8],r0
800058c0:	80 00       	ld.sh	r0,r0[0x0]
800058c2:	56 b8       	stdsp	sp[0x1ac],r8

800058c4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
800058c4:	eb cd 40 c0 	pushm	r6-r7,lr
800058c8:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
800058ca:	48 e7       	lddpc	r7,80005900 <vTaskPlaceOnEventList+0x3c>
800058cc:	6e 0b       	ld.w	r11,r7[0x0]
800058ce:	2e 8b       	sub	r11,-24
800058d0:	f0 1f 00 0d 	mcall	80005904 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800058d4:	6e 0c       	ld.w	r12,r7[0x0]
800058d6:	2f cc       	sub	r12,-4
800058d8:	f0 1f 00 0c 	mcall	80005908 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
800058dc:	5b f6       	cp.w	r6,-1
800058de:	c0 81       	brne	800058ee <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
800058e0:	6e 0b       	ld.w	r11,r7[0x0]
800058e2:	2f cb       	sub	r11,-4
800058e4:	48 ac       	lddpc	r12,8000590c <vTaskPlaceOnEventList+0x48>
800058e6:	f0 1f 00 0b 	mcall	80005910 <vTaskPlaceOnEventList+0x4c>
800058ea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
800058ee:	48 a8       	lddpc	r8,80005914 <vTaskPlaceOnEventList+0x50>
800058f0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
800058f2:	ec 0c 00 0c 	add	r12,r6,r12
800058f6:	f0 1f 00 09 	mcall	80005918 <vTaskPlaceOnEventList+0x54>
800058fa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800058fe:	00 00       	add	r0,r0
80005900:	00 00       	add	r0,r0
80005902:	0c 3c       	cp.w	r12,r6
80005904:	80 00       	ld.sh	r0,r0[0x0]
80005906:	4b 22       	lddpc	r2,800059cc <xTaskGenericCreate+0x28>
80005908:	80 00       	ld.sh	r0,r0[0x0]
8000590a:	4b 56       	lddpc	r6,800059dc <xTaskGenericCreate+0x38>
8000590c:	00 00       	add	r0,r0
8000590e:	0c 90       	mov	r0,r6
80005910:	80 00       	ld.sh	r0,r0[0x0]
80005912:	4b 06       	lddpc	r6,800059d0 <xTaskGenericCreate+0x2c>
80005914:	00 00       	add	r0,r0
80005916:	0c 68       	and	r8,r6
80005918:	80 00       	ld.sh	r0,r0[0x0]
8000591a:	57 a0       	stdsp	sp[0x1e8],r0

8000591c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
8000591c:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005920:	49 67       	lddpc	r7,80005978 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005922:	49 74       	lddpc	r4,8000597c <prvIdleTask+0x60>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005924:	49 73       	lddpc	r3,80005980 <prvIdleTask+0x64>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005926:	49 85       	lddpc	r5,80005984 <prvIdleTask+0x68>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005928:	6e 08       	ld.w	r8,r7[0x0]
8000592a:	58 08       	cp.w	r8,0
8000592c:	c1 e0       	breq	80005968 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
8000592e:	f0 1f 00 17 	mcall	80005988 <prvIdleTask+0x6c>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005932:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005934:	f0 1f 00 16 	mcall	8000598c <prvIdleTask+0x70>

			if( xListIsEmpty == pdFALSE )
80005938:	58 06       	cp.w	r6,0
8000593a:	c1 70       	breq	80005968 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
8000593c:	f0 1f 00 15 	mcall	80005990 <prvIdleTask+0x74>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005940:	68 38       	ld.w	r8,r4[0xc]
80005942:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005944:	ec cc ff fc 	sub	r12,r6,-4
80005948:	f0 1f 00 13 	mcall	80005994 <prvIdleTask+0x78>
					--uxCurrentNumberOfTasks;
8000594c:	66 08       	ld.w	r8,r3[0x0]
8000594e:	20 18       	sub	r8,1
80005950:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005952:	6e 08       	ld.w	r8,r7[0x0]
80005954:	20 18       	sub	r8,1
80005956:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005958:	f0 1f 00 10 	mcall	80005998 <prvIdleTask+0x7c>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
8000595c:	6c cc       	ld.w	r12,r6[0x30]
8000595e:	f0 1f 00 10 	mcall	8000599c <prvIdleTask+0x80>
		vPortFree( pxTCB );
80005962:	0c 9c       	mov	r12,r6
80005964:	f0 1f 00 0e 	mcall	8000599c <prvIdleTask+0x80>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005968:	6a 08       	ld.w	r8,r5[0x0]
8000596a:	58 18       	cp.w	r8,1
8000596c:	e0 88 00 03 	brls	80005972 <prvIdleTask+0x56>
			{
				taskYIELD();
80005970:	d7 33       	scall
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
80005972:	f0 1f 00 0c 	mcall	800059a0 <prvIdleTask+0x84>
		}
		#endif
	}
80005976:	cd 9b       	rjmp	80005928 <prvIdleTask+0xc>
80005978:	00 00       	add	r0,r0
8000597a:	0b 7c       	ld.ub	r12,--r5
8000597c:	00 00       	add	r0,r0
8000597e:	0c 28       	rsub	r8,r6
80005980:	00 00       	add	r0,r0
80005982:	0c 88       	andn	r8,r6
80005984:	00 00       	add	r0,r0
80005986:	0b 88       	ld.ub	r8,r5[0x0]
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	52 fc       	stdsp	sp[0xbc],r12
8000598c:	80 00       	ld.sh	r0,r0[0x0]
8000598e:	56 b8       	stdsp	sp[0x1ac],r8
80005990:	80 00       	ld.sh	r0,r0[0x0]
80005992:	4c 10       	lddpc	r0,80005a94 <xTaskGenericCreate+0xf0>
80005994:	80 00       	ld.sh	r0,r0[0x0]
80005996:	4b 56       	lddpc	r6,80005a68 <xTaskGenericCreate+0xc4>
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	4d 1c       	lddpc	r12,80005adc <xTaskGenericCreate+0x138>
8000599c:	80 00       	ld.sh	r0,r0[0x0]
8000599e:	4e 54       	lddpc	r4,80005b30 <xTaskGenericCreate+0x18c>
800059a0:	80 00       	ld.sh	r0,r0[0x0]
800059a2:	20 2c       	sub	r12,2

800059a4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
800059a4:	d4 31       	pushm	r0-r7,lr
800059a6:	20 1d       	sub	sp,4
800059a8:	fa c4 ff d8 	sub	r4,sp,-40
800059ac:	50 0c       	stdsp	sp[0x0],r12
800059ae:	16 91       	mov	r1,r11
800059b0:	14 97       	mov	r7,r10
800059b2:	12 90       	mov	r0,r9
800059b4:	10 93       	mov	r3,r8
800059b6:	68 02       	ld.w	r2,r4[0x0]
800059b8:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
800059ba:	34 8c       	mov	r12,72
800059bc:	f0 1f 00 5c 	mcall	80005b2c <xTaskGenericCreate+0x188>
800059c0:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
800059c2:	c0 31       	brne	800059c8 <xTaskGenericCreate+0x24>
800059c4:	3f fc       	mov	r12,-1
800059c6:	ca f8       	rjmp	80005b24 <xTaskGenericCreate+0x180>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800059c8:	58 06       	cp.w	r6,0
800059ca:	e0 81 00 af 	brne	80005b28 <xTaskGenericCreate+0x184>
800059ce:	0e 9c       	mov	r12,r7
800059d0:	5c 7c       	castu.h	r12
800059d2:	a3 6c       	lsl	r12,0x2
800059d4:	f0 1f 00 56 	mcall	80005b2c <xTaskGenericCreate+0x188>
800059d8:	18 96       	mov	r6,r12
800059da:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
800059dc:	c0 61       	brne	800059e8 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
800059de:	0a 9c       	mov	r12,r5
800059e0:	f0 1f 00 54 	mcall	80005b30 <xTaskGenericCreate+0x18c>
800059e4:	3f fc       	mov	r12,-1
800059e6:	c9 f8       	rjmp	80005b24 <xTaskGenericCreate+0x180>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
800059e8:	5c 77       	castu.h	r7
800059ea:	ee 0a 15 02 	lsl	r10,r7,0x2
800059ee:	e0 6b 00 a5 	mov	r11,165
800059f2:	0c 9c       	mov	r12,r6
800059f4:	f0 1f 00 50 	mcall	80005b34 <xTaskGenericCreate+0x190>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
800059f8:	ee c6 00 01 	sub	r6,r7,1
800059fc:	6a c8       	ld.w	r8,r5[0x30]
800059fe:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005a02:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005a06:	31 0a       	mov	r10,16
80005a08:	02 9b       	mov	r11,r1
80005a0a:	ea cc ff cc 	sub	r12,r5,-52
80005a0e:	f0 1f 00 4b 	mcall	80005b38 <xTaskGenericCreate+0x194>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005a12:	30 08       	mov	r8,0
80005a14:	eb 68 00 43 	st.b	r5[67],r8
80005a18:	58 73       	cp.w	r3,7
80005a1a:	e6 07 17 80 	movls	r7,r3
80005a1e:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005a22:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80005a24:	eb 47 00 44 	st.w	r5[68],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005a28:	ea c4 ff fc 	sub	r4,r5,-4
80005a2c:	08 9c       	mov	r12,r4
80005a2e:	f0 1f 00 44 	mcall	80005b3c <xTaskGenericCreate+0x198>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005a32:	ea cc ff e8 	sub	r12,r5,-24
80005a36:	f0 1f 00 42 	mcall	80005b3c <xTaskGenericCreate+0x198>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005a3a:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005a3c:	ee 07 11 08 	rsub	r7,r7,8
80005a40:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005a42:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005a44:	00 9a       	mov	r10,r0
80005a46:	40 0b       	lddsp	r11,sp[0x0]
80005a48:	0c 9c       	mov	r12,r6
80005a4a:	f0 1f 00 3e 	mcall	80005b40 <xTaskGenericCreate+0x19c>
80005a4e:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005a50:	58 02       	cp.w	r2,0
80005a52:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005a56:	f0 1f 00 3c 	mcall	80005b44 <xTaskGenericCreate+0x1a0>
		{
			uxCurrentNumberOfTasks++;
80005a5a:	4b c8       	lddpc	r8,80005b48 <xTaskGenericCreate+0x1a4>
80005a5c:	70 09       	ld.w	r9,r8[0x0]
80005a5e:	2f f9       	sub	r9,-1
80005a60:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005a62:	4b b8       	lddpc	r8,80005b4c <xTaskGenericCreate+0x1a8>
80005a64:	70 08       	ld.w	r8,r8[0x0]
80005a66:	58 08       	cp.w	r8,0
80005a68:	c2 61       	brne	80005ab4 <xTaskGenericCreate+0x110>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005a6a:	4b 98       	lddpc	r8,80005b4c <xTaskGenericCreate+0x1a8>
80005a6c:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005a6e:	4b 78       	lddpc	r8,80005b48 <xTaskGenericCreate+0x1a4>
80005a70:	70 08       	ld.w	r8,r8[0x0]
80005a72:	58 18       	cp.w	r8,1
80005a74:	c2 b1       	brne	80005aca <xTaskGenericCreate+0x126>
80005a76:	4b 77       	lddpc	r7,80005b50 <xTaskGenericCreate+0x1ac>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005a78:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005a7c:	0e 9c       	mov	r12,r7
80005a7e:	f0 1f 00 36 	mcall	80005b54 <xTaskGenericCreate+0x1b0>
80005a82:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005a84:	0c 37       	cp.w	r7,r6
80005a86:	cf b1       	brne	80005a7c <xTaskGenericCreate+0xd8>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005a88:	4b 47       	lddpc	r7,80005b58 <xTaskGenericCreate+0x1b4>
80005a8a:	0e 9c       	mov	r12,r7
80005a8c:	f0 1f 00 32 	mcall	80005b54 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005a90:	4b 36       	lddpc	r6,80005b5c <xTaskGenericCreate+0x1b8>
80005a92:	0c 9c       	mov	r12,r6
80005a94:	f0 1f 00 30 	mcall	80005b54 <xTaskGenericCreate+0x1b0>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005a98:	4b 2c       	lddpc	r12,80005b60 <xTaskGenericCreate+0x1bc>
80005a9a:	f0 1f 00 2f 	mcall	80005b54 <xTaskGenericCreate+0x1b0>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005a9e:	4b 2c       	lddpc	r12,80005b64 <xTaskGenericCreate+0x1c0>
80005aa0:	f0 1f 00 2d 	mcall	80005b54 <xTaskGenericCreate+0x1b0>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005aa4:	4b 1c       	lddpc	r12,80005b68 <xTaskGenericCreate+0x1c4>
80005aa6:	f0 1f 00 2c 	mcall	80005b54 <xTaskGenericCreate+0x1b0>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005aaa:	4b 18       	lddpc	r8,80005b6c <xTaskGenericCreate+0x1c8>
80005aac:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005aae:	4b 18       	lddpc	r8,80005b70 <xTaskGenericCreate+0x1cc>
80005ab0:	91 06       	st.w	r8[0x0],r6
80005ab2:	c0 c8       	rjmp	80005aca <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005ab4:	4b 08       	lddpc	r8,80005b74 <xTaskGenericCreate+0x1d0>
80005ab6:	70 08       	ld.w	r8,r8[0x0]
80005ab8:	58 08       	cp.w	r8,0
80005aba:	c0 81       	brne	80005aca <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005abc:	4a 48       	lddpc	r8,80005b4c <xTaskGenericCreate+0x1a8>
80005abe:	70 08       	ld.w	r8,r8[0x0]
80005ac0:	70 b8       	ld.w	r8,r8[0x2c]
80005ac2:	10 33       	cp.w	r3,r8
80005ac4:	c0 33       	brcs	80005aca <xTaskGenericCreate+0x126>
					{
						pxCurrentTCB = pxNewTCB;
80005ac6:	4a 28       	lddpc	r8,80005b4c <xTaskGenericCreate+0x1a8>
80005ac8:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005aca:	6a b8       	ld.w	r8,r5[0x2c]
80005acc:	4a b9       	lddpc	r9,80005b78 <xTaskGenericCreate+0x1d4>
80005ace:	72 09       	ld.w	r9,r9[0x0]
80005ad0:	12 38       	cp.w	r8,r9
80005ad2:	e0 88 00 04 	brls	80005ada <xTaskGenericCreate+0x136>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005ad6:	4a 99       	lddpc	r9,80005b78 <xTaskGenericCreate+0x1d4>
80005ad8:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005ada:	4a 98       	lddpc	r8,80005b7c <xTaskGenericCreate+0x1d8>
80005adc:	70 09       	ld.w	r9,r8[0x0]
80005ade:	2f f9       	sub	r9,-1
80005ae0:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005ae2:	6a b8       	ld.w	r8,r5[0x2c]
80005ae4:	4a 79       	lddpc	r9,80005b80 <xTaskGenericCreate+0x1dc>
80005ae6:	72 09       	ld.w	r9,r9[0x0]
80005ae8:	12 38       	cp.w	r8,r9
80005aea:	e0 88 00 04 	brls	80005af2 <xTaskGenericCreate+0x14e>
80005aee:	4a 59       	lddpc	r9,80005b80 <xTaskGenericCreate+0x1dc>
80005af0:	93 08       	st.w	r9[0x0],r8
80005af2:	6a bc       	ld.w	r12,r5[0x2c]
80005af4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005af8:	08 9b       	mov	r11,r4
80005afa:	49 68       	lddpc	r8,80005b50 <xTaskGenericCreate+0x1ac>
80005afc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005b00:	f0 1f 00 21 	mcall	80005b84 <xTaskGenericCreate+0x1e0>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005b04:	f0 1f 00 21 	mcall	80005b88 <xTaskGenericCreate+0x1e4>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005b08:	49 b8       	lddpc	r8,80005b74 <xTaskGenericCreate+0x1d0>
80005b0a:	70 08       	ld.w	r8,r8[0x0]
80005b0c:	58 08       	cp.w	r8,0
80005b0e:	c0 a0       	breq	80005b22 <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005b10:	48 f8       	lddpc	r8,80005b4c <xTaskGenericCreate+0x1a8>
80005b12:	70 08       	ld.w	r8,r8[0x0]
80005b14:	70 b8       	ld.w	r8,r8[0x2c]
80005b16:	10 33       	cp.w	r3,r8
80005b18:	e0 88 00 05 	brls	80005b22 <xTaskGenericCreate+0x17e>
			{
				portYIELD_WITHIN_API();
80005b1c:	d7 33       	scall
80005b1e:	30 1c       	mov	r12,1
80005b20:	c0 28       	rjmp	80005b24 <xTaskGenericCreate+0x180>
80005b22:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005b24:	2f fd       	sub	sp,-4
80005b26:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005b28:	99 c6       	st.w	r12[0x30],r6
80005b2a:	c5 fb       	rjmp	800059e8 <xTaskGenericCreate+0x44>
80005b2c:	80 00       	ld.sh	r0,r0[0x0]
80005b2e:	4e 7c       	lddpc	r12,80005cc8 <PrintDec+0x3a>
80005b30:	80 00       	ld.sh	r0,r0[0x0]
80005b32:	4e 54       	lddpc	r4,80005cc4 <PrintDec+0x36>
80005b34:	80 00       	ld.sh	r0,r0[0x0]
80005b36:	65 d2       	ld.w	r2,r2[0x74]
80005b38:	80 00       	ld.sh	r0,r0[0x0]
80005b3a:	68 fc       	ld.w	r12,r4[0x3c]
80005b3c:	80 00       	ld.sh	r0,r0[0x0]
80005b3e:	4b 00       	lddpc	r0,80005bfc <PrintHex+0x20>
80005b40:	80 00       	ld.sh	r0,r0[0x0]
80005b42:	4b 7c       	lddpc	r12,80005c1c <PrintHex+0x40>
80005b44:	80 00       	ld.sh	r0,r0[0x0]
80005b46:	4c 10       	lddpc	r0,80005c48 <PrintHex+0x6c>
80005b48:	00 00       	add	r0,r0
80005b4a:	0c 88       	andn	r8,r6
80005b4c:	00 00       	add	r0,r0
80005b4e:	0c 3c       	cp.w	r12,r6
80005b50:	00 00       	add	r0,r0
80005b52:	0b 88       	ld.ub	r8,r5[0x0]
80005b54:	80 00       	ld.sh	r0,r0[0x0]
80005b56:	4a ec       	lddpc	r12,80005c0c <PrintHex+0x30>
80005b58:	00 00       	add	r0,r0
80005b5a:	0c 54       	eor	r4,r6
80005b5c:	00 00       	add	r0,r0
80005b5e:	0c 70       	tst	r0,r6
80005b60:	00 00       	add	r0,r0
80005b62:	0c 40       	or	r0,r6
80005b64:	00 00       	add	r0,r0
80005b66:	0c 28       	rsub	r8,r6
80005b68:	00 00       	add	r0,r0
80005b6a:	0c 90       	mov	r0,r6
80005b6c:	00 00       	add	r0,r0
80005b6e:	0b 74       	ld.ub	r4,--r5
80005b70:	00 00       	add	r0,r0
80005b72:	0b 84       	ld.ub	r4,r5[0x0]
80005b74:	00 00       	add	r0,r0
80005b76:	0b 78       	ld.ub	r8,--r5
80005b78:	00 00       	add	r0,r0
80005b7a:	0b 70       	ld.ub	r0,--r5
80005b7c:	00 00       	add	r0,r0
80005b7e:	0c 84       	andn	r4,r6
80005b80:	00 00       	add	r0,r0
80005b82:	0c a4       	st.w	r6++,r4
80005b84:	80 00       	ld.sh	r0,r0[0x0]
80005b86:	4b 06       	lddpc	r6,80005c44 <PrintHex+0x68>
80005b88:	80 00       	ld.sh	r0,r0[0x0]
80005b8a:	4d 1c       	lddpc	r12,80005ccc <PrintDec+0x3e>

80005b8c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005b8c:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005b8e:	30 09       	mov	r9,0
80005b90:	1a d9       	st.w	--sp,r9
80005b92:	1a d9       	st.w	--sp,r9
80005b94:	1a d9       	st.w	--sp,r9
80005b96:	12 98       	mov	r8,r9
80005b98:	e0 6a 01 00 	mov	r10,256
80005b9c:	48 9b       	lddpc	r11,80005bc0 <vTaskStartScheduler+0x34>
80005b9e:	48 ac       	lddpc	r12,80005bc4 <vTaskStartScheduler+0x38>
80005ba0:	f0 1f 00 0a 	mcall	80005bc8 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005ba4:	2f dd       	sub	sp,-12
80005ba6:	58 1c       	cp.w	r12,1
80005ba8:	c0 a1       	brne	80005bbc <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005baa:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005bac:	30 19       	mov	r9,1
80005bae:	48 88       	lddpc	r8,80005bcc <vTaskStartScheduler+0x40>
80005bb0:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005bb2:	30 09       	mov	r9,0
80005bb4:	48 78       	lddpc	r8,80005bd0 <vTaskStartScheduler+0x44>
80005bb6:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80005bb8:	f0 1f 00 07 	mcall	80005bd4 <vTaskStartScheduler+0x48>
80005bbc:	d8 02       	popm	pc
80005bbe:	00 00       	add	r0,r0
80005bc0:	80 00       	ld.sh	r0,r0[0x0]
80005bc2:	c6 f0       	breq	80005ca0 <PrintDec+0x12>
80005bc4:	80 00       	ld.sh	r0,r0[0x0]
80005bc6:	59 1c       	cp.w	r12,17
80005bc8:	80 00       	ld.sh	r0,r0[0x0]
80005bca:	59 a4       	cp.w	r4,26
80005bcc:	00 00       	add	r0,r0
80005bce:	0b 78       	ld.ub	r8,--r5
80005bd0:	00 00       	add	r0,r0
80005bd2:	0c 68       	and	r8,r6
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	4c 20       	lddpc	r0,80005cdc <PrintDec+0x4e>

80005bd8 <PrintChar>:
	
static void task_log(void * pvParameters);

char *  PrintChar(char c, char * str)
{
	*str++ = c;
80005bd8:	16 cc       	st.b	r11++,r12
	return str;
}
80005bda:	5e fb       	retal	r11

80005bdc <PrintHex>:
	
	return str;
}

char * PrintHex(int i,char len, char * str)
{
80005bdc:	eb cd 40 c0 	pushm	r6-r7,lr
80005be0:	20 3d       	sub	sp,12
80005be2:	18 98       	mov	r8,r12
	char * p = str;
	char s[12];
	memset(s, 0 , 12);
80005be4:	30 06       	mov	r6,0
80005be6:	30 07       	mov	r7,0
80005be8:	fa e7 00 00 	st.d	sp[0],r6
80005bec:	30 0c       	mov	r12,0
80005bee:	50 2c       	stdsp	sp[0x8],r12
	int cnt=0;
	
	if(i)
80005bf0:	58 08       	cp.w	r8,0
80005bf2:	c1 30       	breq	80005c18 <PrintHex+0x3c>
80005bf4:	18 99       	mov	r9,r12
	while(i)
	{
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
80005bf6:	1a 9c       	mov	r12,sp
80005bf8:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005bfc:	58 9e       	cp.w	lr,9
80005bfe:	e0 8a 00 04 	brle	80005c06 <PrintHex+0x2a>
80005c02:	2c 9e       	sub	lr,-55
80005c04:	c0 48       	rjmp	80005c0c <PrintHex+0x30>
80005c06:	fd d8 c0 04 	bfextu	lr,r8,0x0,0x4
80005c0a:	2d 0e       	sub	lr,-48
80005c0c:	f8 09 0b 0e 	st.b	r12[r9],lr
80005c10:	2f f9       	sub	r9,-1
		i = (i >> 4 ) & 0x0FFFFFFF;
80005c12:	a5 88       	lsr	r8,0x4
	char s[12];
	memset(s, 0 , 12);
	int cnt=0;
	
	if(i)
	while(i)
80005c14:	cf 21       	brne	80005bf8 <PrintHex+0x1c>
80005c16:	c0 48       	rjmp	80005c1e <PrintHex+0x42>
		s[cnt++] = ((i & 0x0F) >= 0x0A) ? ((i & 0x0F) + 'A' - 10) :  ((i & 0x0F)  + '0');
		i = (i >> 4 ) & 0x0FFFFFFF;
		//i >>= 4
	}
	else
	s[cnt++] = '0';
80005c18:	33 08       	mov	r8,48
80005c1a:	ba 88       	st.b	sp[0x0],r8
80005c1c:	30 19       	mov	r9,1
	
	if(len - cnt > 0 )
80005c1e:	f6 09 01 08 	sub	r8,r11,r9
80005c22:	58 08       	cp.w	r8,0
80005c24:	e0 8a 00 13 	brle	80005c4a <PrintHex+0x6e>
	{
		char num = len - cnt;
80005c28:	12 1b       	sub	r11,r9
80005c2a:	f9 db c0 08 	bfextu	r12,r11,0x0,0x8
		for(int i = 0; i < num; i++)
80005c2e:	18 9e       	mov	lr,r12
80005c30:	58 0c       	cp.w	r12,0
80005c32:	e0 8a 00 0c 	brle	80005c4a <PrintHex+0x6e>
80005c36:	1a 9b       	mov	r11,sp
80005c38:	12 0b       	add	r11,r9
80005c3a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005c3c:	33 07       	mov	r7,48
80005c3e:	16 c7       	st.b	r11++,r7
	s[cnt++] = '0';
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005c40:	2f f8       	sub	r8,-1
80005c42:	1c 38       	cp.w	r8,lr
80005c44:	cf d5       	brlt	80005c3e <PrintHex+0x62>
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005c46:	f8 09 00 09 	add	r9,r12,r9
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005c4a:	f2 c8 ff ff 	sub	r8,r9,-1
	s[cnt++] = '0';
	
	while(cnt>0)
80005c4e:	f0 cb ff ff 	sub	r11,r8,-1
80005c52:	58 0b       	cp.w	r11,0
80005c54:	e0 8a 00 19 	brle	80005c86 <PrintHex+0xaa>
		{
			s[cnt++] = '0';
		}
	}
	
	s[cnt++] = 'x';
80005c58:	fa cb ff f4 	sub	r11,sp,-12
80005c5c:	f6 09 00 09 	add	r9,r11,r9
80005c60:	37 8b       	mov	r11,120
80005c62:	f3 6b ff f4 	st.b	r9[-12],r11
	s[cnt++] = '0';
80005c66:	fa c9 ff f4 	sub	r9,sp,-12
80005c6a:	10 09       	add	r9,r8
80005c6c:	33 0b       	mov	r11,48
80005c6e:	f3 6b ff f4 	st.b	r9[-12],r11
80005c72:	fa 08 00 08 	add	r8,sp,r8
	*p++ = s[--cnt];
	
	return str;
}

char * PrintHex(int i,char len, char * str)
80005c76:	fa ce 00 01 	sub	lr,sp,1
80005c7a:	14 99       	mov	r9,r10
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
	*p++ = s[--cnt];
80005c7c:	11 8b       	ld.ub	r11,r8[0x0]
80005c7e:	12 cb       	st.b	r9++,r11
80005c80:	20 18       	sub	r8,1
	}
	
	s[cnt++] = 'x';
	s[cnt++] = '0';
	
	while(cnt>0)
80005c82:	1c 38       	cp.w	r8,lr
80005c84:	cf c1       	brne	80005c7c <PrintHex+0xa0>
	*p++ = s[--cnt];
		
	return str;
}
80005c86:	14 9c       	mov	r12,r10
80005c88:	2f dd       	sub	sp,-12
80005c8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc

80005c8e <PrintDec>:
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
{
80005c8e:	d4 21       	pushm	r4-r7,lr
80005c90:	20 3d       	sub	sp,12
80005c92:	18 98       	mov	r8,r12
	char * p = str;
	
	int sign = i>=0 ? 0 : 1;
	char s[10];
	memset(s, 0 , 10);
80005c94:	30 06       	mov	r6,0
80005c96:	30 07       	mov	r7,0
80005c98:	fa e7 00 00 	st.d	sp[0],r6
80005c9c:	30 0c       	mov	r12,0
80005c9e:	ba 4c       	st.h	sp[0x8],r12
	int cnt=0;
	if(sign)
80005ca0:	58 08       	cp.w	r8,0
80005ca2:	c0 35       	brlt	80005ca8 <PrintDec+0x1a>
80005ca4:	14 97       	mov	r7,r10
80005ca6:	c0 58       	rjmp	80005cb0 <PrintDec+0x22>
	{
		*p++ = '-';
80005ca8:	14 97       	mov	r7,r10
80005caa:	32 d9       	mov	r9,45
80005cac:	0e c9       	st.b	r7++,r9
		i = -i;
80005cae:	5c 38       	neg	r8
	}
	
	if(i == 0 )s[cnt++] = '0';
80005cb0:	58 08       	cp.w	r8,0
80005cb2:	c0 51       	brne	80005cbc <PrintDec+0x2e>
80005cb4:	33 08       	mov	r8,48
80005cb6:	ba 88       	st.b	sp[0x0],r8
80005cb8:	30 1e       	mov	lr,1
80005cba:	c2 f8       	rjmp	80005d18 <PrintDec+0x8a>
	
	int ten = i%10;
80005cbc:	e0 65 66 67 	mov	r5,26215
80005cc0:	ea 15 66 66 	orh	r5,0x6666
80005cc4:	f0 05 04 44 	muls.d	r4,r8,r5
80005cc8:	ea 0c 14 02 	asr	r12,r5,0x2
80005ccc:	f0 09 14 1f 	asr	r9,r8,0x1f
80005cd0:	f8 09 01 09 	sub	r9,r12,r9
80005cd4:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005cd8:	f0 09 01 19 	sub	r9,r8,r9<<0x1
80005cdc:	30 0e       	mov	lr,0
	while(i)
	{
		s[cnt] = ten+'0';
80005cde:	1a 9c       	mov	r12,sp
		cnt++;
		i /= 10;
80005ce0:	e0 66 66 67 	mov	r6,26215
80005ce4:	ea 16 66 66 	orh	r6,0x6666
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
	{
		s[cnt] = ten+'0';
80005ce8:	2d 09       	sub	r9,-48
80005cea:	f8 0e 0b 09 	st.b	r12[lr],r9
		cnt++;
80005cee:	2f fe       	sub	lr,-1
		i /= 10;
80005cf0:	f0 06 04 44 	muls.d	r4,r8,r6
80005cf4:	ea 09 14 02 	asr	r9,r5,0x2
80005cf8:	bf 58       	asr	r8,0x1f
80005cfa:	f2 08 01 08 	sub	r8,r9,r8
		ten = i%10;
80005cfe:	f0 06 04 44 	muls.d	r4,r8,r6
80005d02:	ea 09 14 02 	asr	r9,r5,0x2
80005d06:	f0 05 14 1f 	asr	r5,r8,0x1f
80005d0a:	0a 19       	sub	r9,r5
80005d0c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005d10:	f0 09 01 19 	sub	r9,r8,r9<<0x1
	}
	
	if(i == 0 )s[cnt++] = '0';
	
	int ten = i%10;
	while(i)
80005d14:	58 08       	cp.w	r8,0
80005d16:	ce 91       	brne	80005ce8 <PrintDec+0x5a>
		cnt++;
		i /= 10;
		ten = i%10;
	}
	
	if(len - cnt > 0 )
80005d18:	f6 0e 01 08 	sub	r8,r11,lr
80005d1c:	58 08       	cp.w	r8,0
80005d1e:	e0 89 00 06 	brgt	80005d2a <PrintDec+0x9c>
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005d22:	58 0e       	cp.w	lr,0
80005d24:	e0 89 00 14 	brgt	80005d4c <PrintDec+0xbe>
80005d28:	c1 d8       	rjmp	80005d62 <PrintDec+0xd4>
		ten = i%10;
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
80005d2a:	1c 1b       	sub	r11,lr
80005d2c:	5c 5b       	castu.b	r11
		for(int i = 0; i < num; i++)
80005d2e:	16 9c       	mov	r12,r11
80005d30:	58 0b       	cp.w	r11,0
80005d32:	fe 9a ff f8 	brle	80005d22 <PrintDec+0x94>
80005d36:	1a 99       	mov	r9,sp
80005d38:	1c 09       	add	r9,lr
80005d3a:	30 08       	mov	r8,0
		{
			s[cnt++] = '0';
80005d3c:	33 06       	mov	r6,48
80005d3e:	12 c6       	st.b	r9++,r6
	}
	
	if(len - cnt > 0 )
	{
		char num = len - cnt;
		for(int i = 0; i < num; i++)
80005d40:	2f f8       	sub	r8,-1
80005d42:	18 38       	cp.w	r8,r12
80005d44:	cf d5       	brlt	80005d3e <PrintDec+0xb0>
{
	*str++ = c;
	return str;
}

char * PrintDec(int i, char len, char * str)
80005d46:	f6 0e 00 0e 	add	lr,r11,lr
80005d4a:	ce cb       	rjmp	80005d22 <PrintDec+0x94>
80005d4c:	fa c8 ff f4 	sub	r8,sp,-12
80005d50:	1c 08       	add	r8,lr
80005d52:	20 d8       	sub	r8,13
80005d54:	fa cb 00 01 	sub	r11,sp,1
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
	*p++ = s[--cnt];
80005d58:	11 89       	ld.ub	r9,r8[0x0]
80005d5a:	0e c9       	st.b	r7++,r9
80005d5c:	20 18       	sub	r8,1
		{
			s[cnt++] = '0';
		}
	}
	
	while(cnt>0)
80005d5e:	16 38       	cp.w	r8,r11
80005d60:	cf c1       	brne	80005d58 <PrintDec+0xca>
	*p++ = s[--cnt];
	
	return str;
}
80005d62:	14 9c       	mov	r12,r10
80005d64:	2f dd       	sub	sp,-12
80005d66:	d8 22       	popm	r4-r7,pc

80005d68 <log>:
	,  NULL );
	
}

int log(char * content, ...)
{
80005d68:	d4 31       	pushm	r0-r7,lr
80005d6a:	fa cd 02 08 	sub	sp,sp,520
80005d6e:	18 97       	mov	r7,r12
	
	
	char logTmp[MAX_LOG_LINE_SIZE];
	memset(logTmp, '\0', MAX_LOG_LINE_SIZE);	
80005d70:	e0 6a 01 00 	mov	r10,256
80005d74:	30 0b       	mov	r11,0
80005d76:	fa cc fe f8 	sub	r12,sp,-264
80005d7a:	f0 1f 00 4e 	mcall	80005eb0 <log+0x148>
	,  tskLOG_PRIORITY
	,  NULL );
	
}

int log(char * content, ...)
80005d7e:	fa c4 fd d4 	sub	r4,sp,-556
80005d82:	30 0a       	mov	r10,0
80005d84:	50 0a       	stdsp	sp[0x0],r10
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005d86:	fa c3 ff fc 	sub	r3,sp,-4
80005d8a:	e0 61 01 00 	mov	r1,256
80005d8e:	14 90       	mov	r0,r10
			
					if(*str == '%')
80005d90:	32 52       	mov	r2,37
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005d92:	fa c6 fe f8 	sub	r6,sp,-264
	//}	
			
	do
	{
		char strBuf[MAX_LOG_LINE_SIZE], *strTmp = strBuf;
		memset(strTmp, 0, MAX_LOG_LINE_SIZE);
80005d96:	02 9a       	mov	r10,r1
80005d98:	00 9b       	mov	r11,r0
80005d9a:	06 9c       	mov	r12,r3
80005d9c:	f0 1f 00 45 	mcall	80005eb0 <log+0x148>
			
					if(*str == '%')
80005da0:	0f 88       	ld.ub	r8,r7[0x0]
80005da2:	e4 08 18 00 	cp.b	r8,r2
80005da6:	c5 71       	brne	80005e54 <log+0xec>
					{
						static char lench = 0;
						lench =*(str + 1);
80005da8:	ee c8 ff ff 	sub	r8,r7,-1
80005dac:	11 89       	ld.ub	r9,r8[0x0]
80005dae:	4c 2a       	lddpc	r10,80005eb4 <log+0x14c>
80005db0:	b4 89       	st.b	r10[0x0],r9
						if((lench >= '0') &&  (lench <= '9'))
80005db2:	23 09       	sub	r9,48
80005db4:	30 9a       	mov	r10,9
80005db6:	f4 09 18 00 	cp.b	r9,r10
80005dba:	ee 08 17 b0 	movhi	r8,r7
						{
							len = *(++str) - '0';
80005dbe:	f1 f9 88 00 	ld.ubls	r9,r8[0x0]
80005dc2:	f7 b9 08 30 	subls	r9,48
80005dc6:	fb f9 8a 00 	st.wls	sp[0x0],r9
						}
						
						str++;
80005dca:	f0 c7 ff ff 	sub	r7,r8,-1
						
						switch(*(str))
80005dce:	0f 88       	ld.ub	r8,r7[0x0]
80005dd0:	22 58       	sub	r8,37
80005dd2:	e0 48 00 53 	cp.w	r8,83
80005dd6:	e0 8b 00 31 	brhi	80005e38 <log+0xd0>
80005dda:	4b 89       	lddpc	r9,80005eb8 <log+0x150>
80005ddc:	f2 08 03 2f 	ld.w	pc,r9[r8<<0x2]
						{
							case('i'):
							case('I'):
							case('d'):
							case('D'):
							x = va_arg(arg_ptr,int);
80005de0:	e8 c5 ff fc 	sub	r5,r4,-4
							strTmp = PrintDec(x, len, strTmp);
80005de4:	06 9a       	mov	r10,r3
80005de6:	40 0b       	lddsp	r11,sp[0x0]
80005de8:	5c 5b       	castu.b	r11
80005dea:	68 0c       	ld.w	r12,r4[0x0]
80005dec:	f0 1f 00 34 	mcall	80005ebc <log+0x154>
							break;
80005df0:	c2 98       	rjmp	80005e42 <log+0xda>
							
							case('f')://浮点数输出
							case('F'):
							//f = va_arg(arg_ptr,int);
							//strTmp = PrintDec(x, len, strTmp);
							log("I need float.");
80005df2:	4b 4c       	lddpc	r12,80005ec0 <log+0x158>
80005df4:	f0 1f 00 34 	mcall	80005ec4 <log+0x15c>
80005df8:	08 95       	mov	r5,r4
80005dfa:	06 9c       	mov	r12,r3
							break;
80005dfc:	c2 38       	rjmp	80005e42 <log+0xda>
							
							
							case('x'):
							case('X'):
							x = va_arg(arg_ptr,int);
80005dfe:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintHex(x,len, strTmp);
80005e02:	06 9a       	mov	r10,r3
80005e04:	40 0b       	lddsp	r11,sp[0x0]
80005e06:	5c 5b       	castu.b	r11
80005e08:	68 0c       	ld.w	r12,r4[0x0]
80005e0a:	f0 1f 00 30 	mcall	80005ec8 <log+0x160>
80005e0e:	06 9c       	mov	r12,r3
							break;
80005e10:	c1 98       	rjmp	80005e42 <log+0xda>
							
							case('c'):
							case('C'):
							y = va_arg(arg_ptr,int);
80005e12:	e8 c5 ff fc 	sub	r5,r4,-4
							PrintChar(y, strTmp);
80005e16:	06 9b       	mov	r11,r3
80005e18:	09 bc       	ld.ub	r12,r4[0x3]
80005e1a:	f0 1f 00 2d 	mcall	80005ecc <log+0x164>
80005e1e:	06 9c       	mov	r12,r3
							break;
80005e20:	c1 18       	rjmp	80005e42 <log+0xda>
							
							case('s'):
							case('S'):
							strTmp = va_arg(arg_ptr,char*);
80005e22:	e8 c5 ff fc 	sub	r5,r4,-4
80005e26:	68 0c       	ld.w	r12,r4[0x0]
							//PrintStr(s);
							break;
80005e28:	c0 d8       	rjmp	80005e42 <log+0xda>
							
							case('%'):
							PrintChar('%', strTmp);
80005e2a:	06 9b       	mov	r11,r3
80005e2c:	32 5c       	mov	r12,37
80005e2e:	f0 1f 00 28 	mcall	80005ecc <log+0x164>
80005e32:	08 95       	mov	r5,r4
80005e34:	06 9c       	mov	r12,r3
							//PrintChar('%');
							break;
80005e36:	c0 68       	rjmp	80005e42 <log+0xda>
							
							default:
							log("I need relax.");
80005e38:	4a 6c       	lddpc	r12,80005ed0 <log+0x168>
80005e3a:	f0 1f 00 23 	mcall	80005ec4 <log+0x15c>
80005e3e:	08 95       	mov	r5,r4
80005e40:	06 9c       	mov	r12,r3
						}
						str++;
80005e42:	2f f7       	sub	r7,-1
						
						length = sprintf(logTmp,"%s%s",logTmp,strTmp );
80005e44:	1a dc       	st.w	--sp,r12
80005e46:	1a d6       	st.w	--sp,r6
80005e48:	4a 3b       	lddpc	r11,80005ed4 <log+0x16c>
80005e4a:	0c 9c       	mov	r12,r6
80005e4c:	f0 1f 00 23 	mcall	80005ed8 <log+0x170>
80005e50:	2f ed       	sub	sp,-8
80005e52:	c0 a8       	rjmp	80005e66 <log+0xfe>
						//}
						//else
						//length = sprintf(logTmp,"%s%c",logTmp, *str++);
					//}
					else
					length = sprintf(logTmp,"%s%c",logTmp, *str++);
80005e54:	2f f7       	sub	r7,-1
80005e56:	1a d8       	st.w	--sp,r8
80005e58:	1a d6       	st.w	--sp,r6
80005e5a:	4a 1b       	lddpc	r11,80005edc <log+0x174>
80005e5c:	0c 9c       	mov	r12,r6
80005e5e:	f0 1f 00 1f 	mcall	80005ed8 <log+0x170>
80005e62:	08 95       	mov	r5,r4
80005e64:	2f ed       	sub	sp,-8
			
			
			
	}while(*str != '\0');
80005e66:	0f 89       	ld.ub	r9,r7[0x0]
80005e68:	30 08       	mov	r8,0
80005e6a:	f0 09 18 00 	cp.b	r9,r8
80005e6e:	c0 30       	breq	80005e74 <log+0x10c>
80005e70:	0a 94       	mov	r4,r5
80005e72:	c9 2b       	rjmp	80005d96 <log+0x2e>
		
		
				
	va_end(arg_ptr);
	//while(1)		
	length = sprintf(logTmp,"%s\r\n",logTmp);
80005e74:	fa c7 fe f8 	sub	r7,sp,-264
80005e78:	1a d7       	st.w	--sp,r7
80005e7a:	49 ab       	lddpc	r11,80005ee0 <log+0x178>
80005e7c:	0e 9c       	mov	r12,r7
80005e7e:	f0 1f 00 17 	mcall	80005ed8 <log+0x170>
	
	char * p = pvPortMalloc(length+1);
80005e82:	5c 5c       	castu.b	r12
80005e84:	f8 c6 ff ff 	sub	r6,r12,-1
80005e88:	0c 9c       	mov	r12,r6
80005e8a:	f0 1f 00 17 	mcall	80005ee4 <log+0x17c>
80005e8e:	54 2c       	stdsp	sp[0x108],r12
	memcpy(p, logTmp, length+1);
80005e90:	0c 9a       	mov	r10,r6
80005e92:	0e 9b       	mov	r11,r7
80005e94:	f0 1f 00 15 	mcall	80005ee8 <log+0x180>
	//
	//usart_write_line(EXAMPLE_USART, logTmp)
	
	xQueueSend( logQueue, &p, 5);
80005e98:	30 09       	mov	r9,0
80005e9a:	30 5a       	mov	r10,5
80005e9c:	fa cb fe f8 	sub	r11,sp,-264
80005ea0:	49 38       	lddpc	r8,80005eec <log+0x184>
80005ea2:	70 0c       	ld.w	r12,r8[0x0]
80005ea4:	f0 1f 00 13 	mcall	80005ef0 <log+0x188>
80005ea8:	2f fd       	sub	sp,-4
	
	
}
80005eaa:	fe 3d fd f8 	sub	sp,-520
80005eae:	d8 32       	popm	r0-r7,pc
80005eb0:	80 00       	ld.sh	r0,r0[0x0]
80005eb2:	65 d2       	ld.w	r2,r2[0x74]
80005eb4:	00 00       	add	r0,r0
80005eb6:	0c a8       	st.w	r6++,r8
80005eb8:	80 00       	ld.sh	r0,r0[0x0]
80005eba:	c6 f8       	rjmp	80005f98 <task_log+0x40>
80005ebc:	80 00       	ld.sh	r0,r0[0x0]
80005ebe:	5c 8e       	casts.h	lr
80005ec0:	80 00       	ld.sh	r0,r0[0x0]
80005ec2:	c8 54       	brge	80005dcc <log+0x64>
80005ec4:	80 00       	ld.sh	r0,r0[0x0]
80005ec6:	5d 68       	*unknown*
80005ec8:	80 00       	ld.sh	r0,r0[0x0]
80005eca:	5b dc       	cp.w	r12,-3
80005ecc:	80 00       	ld.sh	r0,r0[0x0]
80005ece:	5b d8       	cp.w	r8,-3
80005ed0:	80 00       	ld.sh	r0,r0[0x0]
80005ed2:	c8 64       	brge	80005dde <log+0x76>
80005ed4:	80 00       	ld.sh	r0,r0[0x0]
80005ed6:	c8 74       	brge	80005de4 <log+0x7c>
80005ed8:	80 00       	ld.sh	r0,r0[0x0]
80005eda:	68 c0       	ld.w	r0,r4[0x30]
80005edc:	80 00       	ld.sh	r0,r0[0x0]
80005ede:	c8 7c       	rcall	80005fec <main+0x50>
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	c8 84       	brge	80005df2 <log+0x8a>
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	4e 7c       	lddpc	r12,80006080 <_malloc_r+0x54>
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	64 8a       	ld.w	r10,r2[0x20]
80005eec:	00 00       	add	r0,r0
80005eee:	1f a0       	ld.ub	r0,pc[0x2]
80005ef0:	80 00       	ld.sh	r0,r0[0x0]
80005ef2:	51 30       	stdsp	sp[0x4c],r0

80005ef4 <log_init>:
		
	return str;
}

void log_init(void)
{
80005ef4:	d4 01       	pushm	lr
		.stopbits     = USART_1_STOPBIT,
		.channelmode  = USART_NORMAL_CHMODE
	};

	// Assign GPIO to USART.
	gpio_enable_module(USART_GPIO_MAP,
80005ef6:	30 2b       	mov	r11,2
80005ef8:	48 fc       	lddpc	r12,80005f34 <log_init+0x40>
80005efa:	f0 1f 00 10 	mcall	80005f38 <log_init+0x44>
	sizeof(USART_GPIO_MAP) / sizeof(USART_GPIO_MAP[0]));

	// Initialize USART in RS232 mode.
	usart_init_rs232(EXAMPLE_USART, &USART_OPTIONS, EXAMPLE_TARGET_PBACLK_FREQ_HZ);			
80005efe:	e0 6a 36 00 	mov	r10,13824
80005f02:	ea 1a 01 6e 	orh	r10,0x16e
80005f06:	48 eb       	lddpc	r11,80005f3c <log_init+0x48>
80005f08:	fe 7c 18 00 	mov	r12,-59392
80005f0c:	f0 1f 00 0d 	mcall	80005f40 <log_init+0x4c>
			
	logQueue  = xQueueCreate(50, sizeof(char *));
80005f10:	30 4b       	mov	r11,4
80005f12:	33 2c       	mov	r12,50
80005f14:	f0 1f 00 0c 	mcall	80005f44 <log_init+0x50>
80005f18:	48 c8       	lddpc	r8,80005f48 <log_init+0x54>
80005f1a:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80005f1c:	30 09       	mov	r9,0
80005f1e:	1a d9       	st.w	--sp,r9
80005f20:	1a d9       	st.w	--sp,r9
80005f22:	1a d9       	st.w	--sp,r9
80005f24:	30 28       	mov	r8,2
80005f26:	36 4a       	mov	r10,100
80005f28:	48 9b       	lddpc	r11,80005f4c <log_init+0x58>
80005f2a:	48 ac       	lddpc	r12,80005f50 <log_init+0x5c>
80005f2c:	f0 1f 00 0a 	mcall	80005f54 <log_init+0x60>
80005f30:	2f dd       	sub	sp,-12
	,  100//384
	,  NULL
	,  tskLOG_PRIORITY
	,  NULL );
	
}
80005f32:	d8 02       	popm	pc
80005f34:	80 00       	ld.sh	r0,r0[0x0]
80005f36:	c8 90       	breq	80005e48 <log+0xe0>
80005f38:	80 00       	ld.sh	r0,r0[0x0]
80005f3a:	41 ec       	lddsp	r12,sp[0x78]
80005f3c:	80 00       	ld.sh	r0,r0[0x0]
80005f3e:	c8 48       	rjmp	80006046 <_malloc_r+0x1a>
80005f40:	80 00       	ld.sh	r0,r0[0x0]
80005f42:	49 e0       	lddpc	r0,80005fb8 <main+0x1c>
80005f44:	80 00       	ld.sh	r0,r0[0x0]
80005f46:	52 88       	stdsp	sp[0xa0],r8
80005f48:	00 00       	add	r0,r0
80005f4a:	1f a0       	ld.ub	r0,pc[0x2]
80005f4c:	80 00       	ld.sh	r0,r0[0x0]
80005f4e:	c8 8c       	rcall	8000605e <_malloc_r+0x32>
80005f50:	80 00       	ld.sh	r0,r0[0x0]
80005f52:	5f 58       	srlt	r8
80005f54:	80 00       	ld.sh	r0,r0[0x0]
80005f56:	59 a4       	cp.w	r4,26

80005f58 <task_log>:
			////taskYIELD();
		//}
	}
//portTickType log_water_value =0;	
static void task_log(void * pvParameters)
{
80005f58:	eb cd 40 f8 	pushm	r3-r7,lr
80005f5c:	20 1d       	sub	sp,4
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80005f5e:	48 c7       	lddpc	r7,80005f8c <task_log+0x34>
80005f60:	30 05       	mov	r5,0
80005f62:	3f f4       	mov	r4,-1
		{
			if( NULL != str)
			{
				usart_write_line(EXAMPLE_USART, str);
80005f64:	fe 73 18 00 	mov	r3,-59392
	char * str;
	//char str[MAX_LOG_LINE_SIZE];
	for(;;)
	{
		//log_water_value = uxTaskGetStackHighWaterMark(NULL);
		if(xQueueReceive( logQueue, &str, portMAX_DELAY ) == pdTRUE )
80005f68:	0a 99       	mov	r9,r5
80005f6a:	08 9a       	mov	r10,r4
80005f6c:	1a 9b       	mov	r11,sp
80005f6e:	6e 0c       	ld.w	r12,r7[0x0]
80005f70:	f0 1f 00 08 	mcall	80005f90 <task_log+0x38>
80005f74:	58 1c       	cp.w	r12,1
80005f76:	cf 91       	brne	80005f68 <task_log+0x10>
		{
			if( NULL != str)
80005f78:	40 0b       	lddsp	r11,sp[0x0]
80005f7a:	58 0b       	cp.w	r11,0
80005f7c:	cf 60       	breq	80005f68 <task_log+0x10>
			{
				usart_write_line(EXAMPLE_USART, str);
80005f7e:	06 9c       	mov	r12,r3
80005f80:	f0 1f 00 05 	mcall	80005f94 <task_log+0x3c>
				vPortFree(str);
80005f84:	40 0c       	lddsp	r12,sp[0x0]
80005f86:	f0 1f 00 05 	mcall	80005f98 <task_log+0x40>
80005f8a:	ce fb       	rjmp	80005f68 <task_log+0x10>
80005f8c:	00 00       	add	r0,r0
80005f8e:	1f a0       	ld.ub	r0,pc[0x2]
80005f90:	80 00       	ld.sh	r0,r0[0x0]
80005f92:	4f 74       	lddpc	r4,8000616c <_malloc_r+0x140>
80005f94:	80 00       	ld.sh	r0,r0[0x0]
80005f96:	49 90       	lddpc	r0,80005ff8 <main+0x5c>
80005f98:	80 00       	ld.sh	r0,r0[0x0]
80005f9a:	4e 54       	lddpc	r4,8000612c <_malloc_r+0x100>

80005f9c <main>:
#include "xgflash.h"
#include "app.h"


int main (void)
{
80005f9c:	d4 01       	pushm	lr
	
	//Force SSC_TX_DATA_ENABLE Disabled as soon as possible.
	AVR32_GPIO.port[1].ovrs  =  0x00000001;  //Value will be high.
80005f9e:	fe 78 10 00 	mov	r8,-61440
80005fa2:	30 19       	mov	r9,1
80005fa4:	f1 49 01 54 	st.w	r8[340],r9
	AVR32_GPIO.port[1].oders =  0x00000001;  //Output Driver will be Enabled.
80005fa8:	f1 49 01 44 	st.w	r8[324],r9
	AVR32_GPIO.port[1].gpers =  0x00000001;  //Enable as GPIO.
80005fac:	f1 49 01 04 	st.w	r8[260],r9
		
	Disable_global_interrupt();
80005fb0:	d3 03       	ssrf	0x10
	local_start_pll0();
80005fb2:	f0 1f 00 0c 	mcall	80005fe0 <main+0x44>
		
	INTC_init_interrupts();
80005fb6:	f0 1f 00 0c 	mcall	80005fe4 <main+0x48>
		
	log_init();
80005fba:	f0 1f 00 0c 	mcall	80005fe8 <main+0x4c>
	log("----start debug----");
80005fbe:	48 cc       	lddpc	r12,80005fec <main+0x50>
80005fc0:	f0 1f 00 0c 	mcall	80005ff0 <main+0x54>
	
	xg_flashc_init();
80005fc4:	f0 1f 00 0c 	mcall	80005ff4 <main+0x58>
		
	//voc_init();

	//tc_init();
	
	rfid_init();
80005fc8:	f0 1f 00 0c 	mcall	80005ff8 <main+0x5c>
		
	app_init();
80005fcc:	f0 1f 00 0c 	mcall	80005ffc <main+0x60>
	
	xg_rtc_init();
80005fd0:	f0 1f 00 0c 	mcall	80006000 <main+0x64>
		
	//xcmp_init();

	local_start_timer();
80005fd4:	f0 1f 00 0c 	mcall	80006004 <main+0x68>
		
	vTaskStartScheduler();
80005fd8:	f0 1f 00 0c 	mcall	80006008 <main+0x6c>
	return 0;
	
}
80005fdc:	d8 0a       	popm	pc,r12=0
80005fde:	00 00       	add	r0,r0
80005fe0:	80 00       	ld.sh	r0,r0[0x0]
80005fe2:	3e 84       	mov	r4,-24
80005fe4:	80 00       	ld.sh	r0,r0[0x0]
80005fe6:	42 f0       	lddsp	r0,sp[0xbc]
80005fe8:	80 00       	ld.sh	r0,r0[0x0]
80005fea:	5e f4       	retal	r4
80005fec:	80 00       	ld.sh	r0,r0[0x0]
80005fee:	c8 a0       	breq	80005f02 <log_init+0xe>
80005ff0:	80 00       	ld.sh	r0,r0[0x0]
80005ff2:	5d 68       	*unknown*
80005ff4:	80 00       	ld.sh	r0,r0[0x0]
80005ff6:	3f 18       	mov	r8,-15
80005ff8:	80 00       	ld.sh	r0,r0[0x0]
80005ffa:	3d a0       	mov	r0,-38
80005ffc:	80 00       	ld.sh	r0,r0[0x0]
80005ffe:	20 3c       	sub	r12,3
80006000:	80 00       	ld.sh	r0,r0[0x0]
80006002:	30 38       	mov	r8,3
80006004:	80 00       	ld.sh	r0,r0[0x0]
80006006:	3e 58       	mov	r8,-27
80006008:	80 00       	ld.sh	r0,r0[0x0]
8000600a:	5b 8c       	cp.w	r12,-8

8000600c <free>:
8000600c:	d4 01       	pushm	lr
8000600e:	e0 68 0a 18 	mov	r8,2584
80006012:	18 9b       	mov	r11,r12
80006014:	70 0c       	ld.w	r12,r8[0x0]
80006016:	e0 a0 1e 73 	rcall	80009cfc <_free_r>
8000601a:	d8 02       	popm	pc

8000601c <malloc>:
8000601c:	d4 01       	pushm	lr
8000601e:	e0 68 0a 18 	mov	r8,2584
80006022:	18 9b       	mov	r11,r12
80006024:	70 0c       	ld.w	r12,r8[0x0]
80006026:	c0 3c       	rcall	8000602c <_malloc_r>
80006028:	d8 02       	popm	pc
8000602a:	d7 03       	nop

8000602c <_malloc_r>:
8000602c:	d4 31       	pushm	r0-r7,lr
8000602e:	f6 c8 ff f5 	sub	r8,r11,-11
80006032:	18 95       	mov	r5,r12
80006034:	10 97       	mov	r7,r8
80006036:	e0 17 ff f8 	andl	r7,0xfff8
8000603a:	59 68       	cp.w	r8,22
8000603c:	f9 b7 08 10 	movls	r7,16
80006040:	16 37       	cp.w	r7,r11
80006042:	5f 38       	srlo	r8
80006044:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
80006048:	c0 50       	breq	80006052 <_malloc_r+0x26>
8000604a:	30 c8       	mov	r8,12
8000604c:	99 38       	st.w	r12[0xc],r8
8000604e:	e0 8f 01 fa 	bral	80006442 <_malloc_r+0x416>
80006052:	fe b0 f6 b7 	rcall	80004dc0 <__malloc_lock>
80006056:	e0 47 01 f7 	cp.w	r7,503
8000605a:	e0 8b 00 1d 	brhi	80006094 <_malloc_r+0x68>
8000605e:	ee 03 16 03 	lsr	r3,r7,0x3
80006062:	e0 68 05 18 	mov	r8,1304
80006066:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000606a:	70 36       	ld.w	r6,r8[0xc]
8000606c:	10 36       	cp.w	r6,r8
8000606e:	c0 61       	brne	8000607a <_malloc_r+0x4e>
80006070:	ec c8 ff f8 	sub	r8,r6,-8
80006074:	70 36       	ld.w	r6,r8[0xc]
80006076:	10 36       	cp.w	r6,r8
80006078:	c0 c0       	breq	80006090 <_malloc_r+0x64>
8000607a:	6c 18       	ld.w	r8,r6[0x4]
8000607c:	e0 18 ff fc 	andl	r8,0xfffc
80006080:	6c 3a       	ld.w	r10,r6[0xc]
80006082:	ec 08 00 09 	add	r9,r6,r8
80006086:	0a 9c       	mov	r12,r5
80006088:	6c 28       	ld.w	r8,r6[0x8]
8000608a:	95 28       	st.w	r10[0x8],r8
8000608c:	91 3a       	st.w	r8[0xc],r10
8000608e:	c4 78       	rjmp	8000611c <_malloc_r+0xf0>
80006090:	2f e3       	sub	r3,-2
80006092:	c4 d8       	rjmp	8000612c <_malloc_r+0x100>
80006094:	ee 03 16 09 	lsr	r3,r7,0x9
80006098:	c0 41       	brne	800060a0 <_malloc_r+0x74>
8000609a:	ee 03 16 03 	lsr	r3,r7,0x3
8000609e:	c2 68       	rjmp	800060ea <_malloc_r+0xbe>
800060a0:	58 43       	cp.w	r3,4
800060a2:	e0 8b 00 06 	brhi	800060ae <_malloc_r+0x82>
800060a6:	ee 03 16 06 	lsr	r3,r7,0x6
800060aa:	2c 83       	sub	r3,-56
800060ac:	c1 f8       	rjmp	800060ea <_malloc_r+0xbe>
800060ae:	59 43       	cp.w	r3,20
800060b0:	e0 8b 00 04 	brhi	800060b8 <_malloc_r+0x8c>
800060b4:	2a 53       	sub	r3,-91
800060b6:	c1 a8       	rjmp	800060ea <_malloc_r+0xbe>
800060b8:	e0 43 00 54 	cp.w	r3,84
800060bc:	e0 8b 00 06 	brhi	800060c8 <_malloc_r+0x9c>
800060c0:	ee 03 16 0c 	lsr	r3,r7,0xc
800060c4:	29 23       	sub	r3,-110
800060c6:	c1 28       	rjmp	800060ea <_malloc_r+0xbe>
800060c8:	e0 43 01 54 	cp.w	r3,340
800060cc:	e0 8b 00 06 	brhi	800060d8 <_malloc_r+0xac>
800060d0:	ee 03 16 0f 	lsr	r3,r7,0xf
800060d4:	28 93       	sub	r3,-119
800060d6:	c0 a8       	rjmp	800060ea <_malloc_r+0xbe>
800060d8:	e0 43 05 54 	cp.w	r3,1364
800060dc:	e0 88 00 04 	brls	800060e4 <_malloc_r+0xb8>
800060e0:	37 e3       	mov	r3,126
800060e2:	c0 48       	rjmp	800060ea <_malloc_r+0xbe>
800060e4:	ee 03 16 12 	lsr	r3,r7,0x12
800060e8:	28 43       	sub	r3,-124
800060ea:	e0 6a 05 18 	mov	r10,1304
800060ee:	f4 03 00 3a 	add	r10,r10,r3<<0x3
800060f2:	74 36       	ld.w	r6,r10[0xc]
800060f4:	c1 98       	rjmp	80006126 <_malloc_r+0xfa>
800060f6:	6c 19       	ld.w	r9,r6[0x4]
800060f8:	e0 19 ff fc 	andl	r9,0xfffc
800060fc:	f2 07 01 0b 	sub	r11,r9,r7
80006100:	58 fb       	cp.w	r11,15
80006102:	e0 8a 00 04 	brle	8000610a <_malloc_r+0xde>
80006106:	20 13       	sub	r3,1
80006108:	c1 18       	rjmp	8000612a <_malloc_r+0xfe>
8000610a:	6c 38       	ld.w	r8,r6[0xc]
8000610c:	58 0b       	cp.w	r11,0
8000610e:	c0 b5       	brlt	80006124 <_malloc_r+0xf8>
80006110:	6c 2a       	ld.w	r10,r6[0x8]
80006112:	ec 09 00 09 	add	r9,r6,r9
80006116:	0a 9c       	mov	r12,r5
80006118:	91 2a       	st.w	r8[0x8],r10
8000611a:	95 38       	st.w	r10[0xc],r8
8000611c:	72 18       	ld.w	r8,r9[0x4]
8000611e:	a1 a8       	sbr	r8,0x0
80006120:	93 18       	st.w	r9[0x4],r8
80006122:	cb c8       	rjmp	8000629a <_malloc_r+0x26e>
80006124:	10 96       	mov	r6,r8
80006126:	14 36       	cp.w	r6,r10
80006128:	ce 71       	brne	800060f6 <_malloc_r+0xca>
8000612a:	2f f3       	sub	r3,-1
8000612c:	e0 6a 05 18 	mov	r10,1304
80006130:	f4 cc ff f8 	sub	r12,r10,-8
80006134:	78 26       	ld.w	r6,r12[0x8]
80006136:	18 36       	cp.w	r6,r12
80006138:	c6 c0       	breq	80006210 <_malloc_r+0x1e4>
8000613a:	6c 19       	ld.w	r9,r6[0x4]
8000613c:	e0 19 ff fc 	andl	r9,0xfffc
80006140:	f2 07 01 08 	sub	r8,r9,r7
80006144:	58 f8       	cp.w	r8,15
80006146:	e0 89 00 8f 	brgt	80006264 <_malloc_r+0x238>
8000614a:	99 3c       	st.w	r12[0xc],r12
8000614c:	99 2c       	st.w	r12[0x8],r12
8000614e:	58 08       	cp.w	r8,0
80006150:	c0 55       	brlt	8000615a <_malloc_r+0x12e>
80006152:	ec 09 00 09 	add	r9,r6,r9
80006156:	0a 9c       	mov	r12,r5
80006158:	ce 2b       	rjmp	8000611c <_malloc_r+0xf0>
8000615a:	e0 49 01 ff 	cp.w	r9,511
8000615e:	e0 8b 00 13 	brhi	80006184 <_malloc_r+0x158>
80006162:	a3 99       	lsr	r9,0x3
80006164:	f4 09 00 38 	add	r8,r10,r9<<0x3
80006168:	70 2b       	ld.w	r11,r8[0x8]
8000616a:	8d 38       	st.w	r6[0xc],r8
8000616c:	8d 2b       	st.w	r6[0x8],r11
8000616e:	97 36       	st.w	r11[0xc],r6
80006170:	91 26       	st.w	r8[0x8],r6
80006172:	a3 49       	asr	r9,0x2
80006174:	74 18       	ld.w	r8,r10[0x4]
80006176:	30 1b       	mov	r11,1
80006178:	f6 09 09 49 	lsl	r9,r11,r9
8000617c:	f1 e9 10 09 	or	r9,r8,r9
80006180:	95 19       	st.w	r10[0x4],r9
80006182:	c4 78       	rjmp	80006210 <_malloc_r+0x1e4>
80006184:	f2 0a 16 09 	lsr	r10,r9,0x9
80006188:	58 4a       	cp.w	r10,4
8000618a:	e0 8b 00 07 	brhi	80006198 <_malloc_r+0x16c>
8000618e:	f2 0a 16 06 	lsr	r10,r9,0x6
80006192:	2c 8a       	sub	r10,-56
80006194:	c2 08       	rjmp	800061d4 <_malloc_r+0x1a8>
80006196:	d7 03       	nop
80006198:	59 4a       	cp.w	r10,20
8000619a:	e0 8b 00 04 	brhi	800061a2 <_malloc_r+0x176>
8000619e:	2a 5a       	sub	r10,-91
800061a0:	c1 a8       	rjmp	800061d4 <_malloc_r+0x1a8>
800061a2:	e0 4a 00 54 	cp.w	r10,84
800061a6:	e0 8b 00 06 	brhi	800061b2 <_malloc_r+0x186>
800061aa:	f2 0a 16 0c 	lsr	r10,r9,0xc
800061ae:	29 2a       	sub	r10,-110
800061b0:	c1 28       	rjmp	800061d4 <_malloc_r+0x1a8>
800061b2:	e0 4a 01 54 	cp.w	r10,340
800061b6:	e0 8b 00 06 	brhi	800061c2 <_malloc_r+0x196>
800061ba:	f2 0a 16 0f 	lsr	r10,r9,0xf
800061be:	28 9a       	sub	r10,-119
800061c0:	c0 a8       	rjmp	800061d4 <_malloc_r+0x1a8>
800061c2:	e0 4a 05 54 	cp.w	r10,1364
800061c6:	e0 88 00 04 	brls	800061ce <_malloc_r+0x1a2>
800061ca:	37 ea       	mov	r10,126
800061cc:	c0 48       	rjmp	800061d4 <_malloc_r+0x1a8>
800061ce:	f2 0a 16 12 	lsr	r10,r9,0x12
800061d2:	28 4a       	sub	r10,-124
800061d4:	e0 6b 05 18 	mov	r11,1304
800061d8:	f6 0a 00 34 	add	r4,r11,r10<<0x3
800061dc:	68 28       	ld.w	r8,r4[0x8]
800061de:	08 38       	cp.w	r8,r4
800061e0:	c0 e1       	brne	800061fc <_malloc_r+0x1d0>
800061e2:	76 19       	ld.w	r9,r11[0x4]
800061e4:	a3 4a       	asr	r10,0x2
800061e6:	30 1e       	mov	lr,1
800061e8:	fc 0a 09 4a 	lsl	r10,lr,r10
800061ec:	f3 ea 10 0a 	or	r10,r9,r10
800061f0:	10 99       	mov	r9,r8
800061f2:	97 1a       	st.w	r11[0x4],r10
800061f4:	c0 a8       	rjmp	80006208 <_malloc_r+0x1dc>
800061f6:	70 28       	ld.w	r8,r8[0x8]
800061f8:	08 38       	cp.w	r8,r4
800061fa:	c0 60       	breq	80006206 <_malloc_r+0x1da>
800061fc:	70 1a       	ld.w	r10,r8[0x4]
800061fe:	e0 1a ff fc 	andl	r10,0xfffc
80006202:	14 39       	cp.w	r9,r10
80006204:	cf 93       	brcs	800061f6 <_malloc_r+0x1ca>
80006206:	70 39       	ld.w	r9,r8[0xc]
80006208:	8d 39       	st.w	r6[0xc],r9
8000620a:	8d 28       	st.w	r6[0x8],r8
8000620c:	91 36       	st.w	r8[0xc],r6
8000620e:	93 26       	st.w	r9[0x8],r6
80006210:	e6 08 14 02 	asr	r8,r3,0x2
80006214:	30 1b       	mov	r11,1
80006216:	e0 64 05 18 	mov	r4,1304
8000621a:	f6 08 09 4b 	lsl	r11,r11,r8
8000621e:	68 18       	ld.w	r8,r4[0x4]
80006220:	10 3b       	cp.w	r11,r8
80006222:	e0 8b 00 6b 	brhi	800062f8 <_malloc_r+0x2cc>
80006226:	f7 e8 00 09 	and	r9,r11,r8
8000622a:	c0 b1       	brne	80006240 <_malloc_r+0x214>
8000622c:	e0 13 ff fc 	andl	r3,0xfffc
80006230:	a1 7b       	lsl	r11,0x1
80006232:	2f c3       	sub	r3,-4
80006234:	c0 38       	rjmp	8000623a <_malloc_r+0x20e>
80006236:	2f c3       	sub	r3,-4
80006238:	a1 7b       	lsl	r11,0x1
8000623a:	f7 e8 00 09 	and	r9,r11,r8
8000623e:	cf c0       	breq	80006236 <_malloc_r+0x20a>
80006240:	e8 03 00 3e 	add	lr,r4,r3<<0x3
80006244:	06 92       	mov	r2,r3
80006246:	1c 91       	mov	r1,lr
80006248:	62 36       	ld.w	r6,r1[0xc]
8000624a:	c2 e8       	rjmp	800062a6 <_malloc_r+0x27a>
8000624c:	6c 1a       	ld.w	r10,r6[0x4]
8000624e:	e0 1a ff fc 	andl	r10,0xfffc
80006252:	f4 07 01 08 	sub	r8,r10,r7
80006256:	58 f8       	cp.w	r8,15
80006258:	e0 8a 00 15 	brle	80006282 <_malloc_r+0x256>
8000625c:	6c 3a       	ld.w	r10,r6[0xc]
8000625e:	6c 29       	ld.w	r9,r6[0x8]
80006260:	95 29       	st.w	r10[0x8],r9
80006262:	93 3a       	st.w	r9[0xc],r10
80006264:	0e 99       	mov	r9,r7
80006266:	ec 07 00 07 	add	r7,r6,r7
8000626a:	a1 a9       	sbr	r9,0x0
8000626c:	99 37       	st.w	r12[0xc],r7
8000626e:	99 27       	st.w	r12[0x8],r7
80006270:	8d 19       	st.w	r6[0x4],r9
80006272:	ee 08 09 08 	st.w	r7[r8],r8
80006276:	8f 2c       	st.w	r7[0x8],r12
80006278:	8f 3c       	st.w	r7[0xc],r12
8000627a:	a1 a8       	sbr	r8,0x0
8000627c:	0a 9c       	mov	r12,r5
8000627e:	8f 18       	st.w	r7[0x4],r8
80006280:	c0 d8       	rjmp	8000629a <_malloc_r+0x26e>
80006282:	6c 39       	ld.w	r9,r6[0xc]
80006284:	58 08       	cp.w	r8,0
80006286:	c0 f5       	brlt	800062a4 <_malloc_r+0x278>
80006288:	ec 0a 00 0a 	add	r10,r6,r10
8000628c:	74 18       	ld.w	r8,r10[0x4]
8000628e:	a1 a8       	sbr	r8,0x0
80006290:	0a 9c       	mov	r12,r5
80006292:	95 18       	st.w	r10[0x4],r8
80006294:	6c 28       	ld.w	r8,r6[0x8]
80006296:	93 28       	st.w	r9[0x8],r8
80006298:	91 39       	st.w	r8[0xc],r9
8000629a:	fe b0 f5 99 	rcall	80004dcc <__malloc_unlock>
8000629e:	ec cc ff f8 	sub	r12,r6,-8
800062a2:	d8 32       	popm	r0-r7,pc
800062a4:	12 96       	mov	r6,r9
800062a6:	02 36       	cp.w	r6,r1
800062a8:	cd 21       	brne	8000624c <_malloc_r+0x220>
800062aa:	2f f2       	sub	r2,-1
800062ac:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
800062b0:	c0 30       	breq	800062b6 <_malloc_r+0x28a>
800062b2:	2f 81       	sub	r1,-8
800062b4:	cc ab       	rjmp	80006248 <_malloc_r+0x21c>
800062b6:	1c 98       	mov	r8,lr
800062b8:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
800062bc:	c0 81       	brne	800062cc <_malloc_r+0x2a0>
800062be:	68 19       	ld.w	r9,r4[0x4]
800062c0:	f6 08 11 ff 	rsub	r8,r11,-1
800062c4:	f3 e8 00 08 	and	r8,r9,r8
800062c8:	89 18       	st.w	r4[0x4],r8
800062ca:	c0 78       	rjmp	800062d8 <_malloc_r+0x2ac>
800062cc:	f0 c9 00 08 	sub	r9,r8,8
800062d0:	20 13       	sub	r3,1
800062d2:	70 08       	ld.w	r8,r8[0x0]
800062d4:	12 38       	cp.w	r8,r9
800062d6:	cf 10       	breq	800062b8 <_malloc_r+0x28c>
800062d8:	a1 7b       	lsl	r11,0x1
800062da:	68 18       	ld.w	r8,r4[0x4]
800062dc:	10 3b       	cp.w	r11,r8
800062de:	e0 8b 00 0d 	brhi	800062f8 <_malloc_r+0x2cc>
800062e2:	58 0b       	cp.w	r11,0
800062e4:	c0 a0       	breq	800062f8 <_malloc_r+0x2cc>
800062e6:	04 93       	mov	r3,r2
800062e8:	c0 38       	rjmp	800062ee <_malloc_r+0x2c2>
800062ea:	2f c3       	sub	r3,-4
800062ec:	a1 7b       	lsl	r11,0x1
800062ee:	f7 e8 00 09 	and	r9,r11,r8
800062f2:	ca 71       	brne	80006240 <_malloc_r+0x214>
800062f4:	cf bb       	rjmp	800062ea <_malloc_r+0x2be>
800062f6:	d7 03       	nop
800062f8:	68 23       	ld.w	r3,r4[0x8]
800062fa:	66 12       	ld.w	r2,r3[0x4]
800062fc:	e0 12 ff fc 	andl	r2,0xfffc
80006300:	0e 32       	cp.w	r2,r7
80006302:	5f 39       	srlo	r9
80006304:	e4 07 01 08 	sub	r8,r2,r7
80006308:	58 f8       	cp.w	r8,15
8000630a:	5f aa       	srle	r10
8000630c:	f5 e9 10 09 	or	r9,r10,r9
80006310:	e0 80 00 9a 	breq	80006444 <_malloc_r+0x418>
80006314:	e0 68 0c b4 	mov	r8,3252
80006318:	70 01       	ld.w	r1,r8[0x0]
8000631a:	e0 68 09 24 	mov	r8,2340
8000631e:	2f 01       	sub	r1,-16
80006320:	70 08       	ld.w	r8,r8[0x0]
80006322:	0e 01       	add	r1,r7
80006324:	5b f8       	cp.w	r8,-1
80006326:	c0 40       	breq	8000632e <_malloc_r+0x302>
80006328:	28 11       	sub	r1,-127
8000632a:	e0 11 ff 80 	andl	r1,0xff80
8000632e:	02 9b       	mov	r11,r1
80006330:	0a 9c       	mov	r12,r5
80006332:	e0 a0 02 b7 	rcall	800068a0 <_sbrk_r>
80006336:	18 96       	mov	r6,r12
80006338:	5b fc       	cp.w	r12,-1
8000633a:	c7 50       	breq	80006424 <_malloc_r+0x3f8>
8000633c:	e6 02 00 08 	add	r8,r3,r2
80006340:	10 3c       	cp.w	r12,r8
80006342:	c0 32       	brcc	80006348 <_malloc_r+0x31c>
80006344:	08 33       	cp.w	r3,r4
80006346:	c6 f1       	brne	80006424 <_malloc_r+0x3f8>
80006348:	e0 6a 0c b8 	mov	r10,3256
8000634c:	74 09       	ld.w	r9,r10[0x0]
8000634e:	e2 09 00 09 	add	r9,r1,r9
80006352:	95 09       	st.w	r10[0x0],r9
80006354:	10 36       	cp.w	r6,r8
80006356:	c0 a1       	brne	8000636a <_malloc_r+0x33e>
80006358:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000635c:	c0 71       	brne	8000636a <_malloc_r+0x33e>
8000635e:	e2 02 00 02 	add	r2,r1,r2
80006362:	68 28       	ld.w	r8,r4[0x8]
80006364:	a1 a2       	sbr	r2,0x0
80006366:	91 12       	st.w	r8[0x4],r2
80006368:	c4 f8       	rjmp	80006406 <_malloc_r+0x3da>
8000636a:	e0 6a 09 24 	mov	r10,2340
8000636e:	74 0b       	ld.w	r11,r10[0x0]
80006370:	5b fb       	cp.w	r11,-1
80006372:	c0 31       	brne	80006378 <_malloc_r+0x34c>
80006374:	95 06       	st.w	r10[0x0],r6
80006376:	c0 78       	rjmp	80006384 <_malloc_r+0x358>
80006378:	ec 09 00 09 	add	r9,r6,r9
8000637c:	e0 6a 0c b8 	mov	r10,3256
80006380:	10 19       	sub	r9,r8
80006382:	95 09       	st.w	r10[0x0],r9
80006384:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
80006388:	f0 09 11 08 	rsub	r9,r8,8
8000638c:	58 08       	cp.w	r8,0
8000638e:	f2 08 17 10 	movne	r8,r9
80006392:	ed d8 e1 06 	addne	r6,r6,r8
80006396:	28 08       	sub	r8,-128
80006398:	ec 01 00 01 	add	r1,r6,r1
8000639c:	0a 9c       	mov	r12,r5
8000639e:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
800063a2:	f0 01 01 01 	sub	r1,r8,r1
800063a6:	02 9b       	mov	r11,r1
800063a8:	e0 a0 02 7c 	rcall	800068a0 <_sbrk_r>
800063ac:	e0 68 0c b8 	mov	r8,3256
800063b0:	5b fc       	cp.w	r12,-1
800063b2:	ec 0c 17 00 	moveq	r12,r6
800063b6:	f9 b1 00 00 	moveq	r1,0
800063ba:	70 09       	ld.w	r9,r8[0x0]
800063bc:	0c 1c       	sub	r12,r6
800063be:	89 26       	st.w	r4[0x8],r6
800063c0:	02 0c       	add	r12,r1
800063c2:	12 01       	add	r1,r9
800063c4:	a1 ac       	sbr	r12,0x0
800063c6:	91 01       	st.w	r8[0x0],r1
800063c8:	8d 1c       	st.w	r6[0x4],r12
800063ca:	08 33       	cp.w	r3,r4
800063cc:	c1 d0       	breq	80006406 <_malloc_r+0x3da>
800063ce:	58 f2       	cp.w	r2,15
800063d0:	e0 8b 00 05 	brhi	800063da <_malloc_r+0x3ae>
800063d4:	30 18       	mov	r8,1
800063d6:	8d 18       	st.w	r6[0x4],r8
800063d8:	c2 68       	rjmp	80006424 <_malloc_r+0x3f8>
800063da:	30 59       	mov	r9,5
800063dc:	20 c2       	sub	r2,12
800063de:	e0 12 ff f8 	andl	r2,0xfff8
800063e2:	e6 02 00 08 	add	r8,r3,r2
800063e6:	91 29       	st.w	r8[0x8],r9
800063e8:	91 19       	st.w	r8[0x4],r9
800063ea:	66 18       	ld.w	r8,r3[0x4]
800063ec:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800063f0:	e5 e8 10 08 	or	r8,r2,r8
800063f4:	87 18       	st.w	r3[0x4],r8
800063f6:	58 f2       	cp.w	r2,15
800063f8:	e0 88 00 07 	brls	80006406 <_malloc_r+0x3da>
800063fc:	e6 cb ff f8 	sub	r11,r3,-8
80006400:	0a 9c       	mov	r12,r5
80006402:	e0 a0 1c 7d 	rcall	80009cfc <_free_r>
80006406:	e0 69 0c b0 	mov	r9,3248
8000640a:	72 0a       	ld.w	r10,r9[0x0]
8000640c:	e0 68 0c b8 	mov	r8,3256
80006410:	70 08       	ld.w	r8,r8[0x0]
80006412:	14 38       	cp.w	r8,r10
80006414:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006418:	e0 69 0c ac 	mov	r9,3244
8000641c:	72 0a       	ld.w	r10,r9[0x0]
8000641e:	14 38       	cp.w	r8,r10
80006420:	f3 f8 ba 00 	st.whi	r9[0x0],r8
80006424:	68 28       	ld.w	r8,r4[0x8]
80006426:	70 18       	ld.w	r8,r8[0x4]
80006428:	e0 18 ff fc 	andl	r8,0xfffc
8000642c:	0e 38       	cp.w	r8,r7
8000642e:	5f 39       	srlo	r9
80006430:	0e 18       	sub	r8,r7
80006432:	58 f8       	cp.w	r8,15
80006434:	5f aa       	srle	r10
80006436:	f5 e9 10 09 	or	r9,r10,r9
8000643a:	c0 50       	breq	80006444 <_malloc_r+0x418>
8000643c:	0a 9c       	mov	r12,r5
8000643e:	fe b0 f4 c7 	rcall	80004dcc <__malloc_unlock>
80006442:	d8 3a       	popm	r0-r7,pc,r12=0
80006444:	68 26       	ld.w	r6,r4[0x8]
80006446:	a1 a8       	sbr	r8,0x0
80006448:	0e 99       	mov	r9,r7
8000644a:	a1 a9       	sbr	r9,0x0
8000644c:	8d 19       	st.w	r6[0x4],r9
8000644e:	ec 07 00 07 	add	r7,r6,r7
80006452:	0a 9c       	mov	r12,r5
80006454:	89 27       	st.w	r4[0x8],r7
80006456:	8f 18       	st.w	r7[0x4],r8
80006458:	fe b0 f4 ba 	rcall	80004dcc <__malloc_unlock>
8000645c:	ec cc ff f8 	sub	r12,r6,-8
80006460:	d8 32       	popm	r0-r7,pc
80006462:	d7 03       	nop

80006464 <memcmp>:
80006464:	d4 01       	pushm	lr
80006466:	30 08       	mov	r8,0
80006468:	c0 d8       	rjmp	80006482 <memcmp+0x1e>
8000646a:	f8 08 07 0e 	ld.ub	lr,r12[r8]
8000646e:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006472:	20 1a       	sub	r10,1
80006474:	2f f8       	sub	r8,-1
80006476:	f2 0e 18 00 	cp.b	lr,r9
8000647a:	c0 40       	breq	80006482 <memcmp+0x1e>
8000647c:	fc 09 01 0c 	sub	r12,lr,r9
80006480:	d8 02       	popm	pc
80006482:	58 0a       	cp.w	r10,0
80006484:	cf 31       	brne	8000646a <memcmp+0x6>
80006486:	14 9c       	mov	r12,r10
80006488:	d8 02       	popm	pc

8000648a <memcpy>:
8000648a:	58 8a       	cp.w	r10,8
8000648c:	c2 f5       	brlt	800064ea <memcpy+0x60>
8000648e:	f9 eb 10 09 	or	r9,r12,r11
80006492:	e2 19 00 03 	andl	r9,0x3,COH
80006496:	e0 81 00 97 	brne	800065c4 <memcpy+0x13a>
8000649a:	e0 4a 00 20 	cp.w	r10,32
8000649e:	c3 b4       	brge	80006514 <memcpy+0x8a>
800064a0:	f4 08 14 02 	asr	r8,r10,0x2
800064a4:	f0 09 11 08 	rsub	r9,r8,8
800064a8:	fe 09 00 2f 	add	pc,pc,r9<<0x2
800064ac:	76 69       	ld.w	r9,r11[0x18]
800064ae:	99 69       	st.w	r12[0x18],r9
800064b0:	76 59       	ld.w	r9,r11[0x14]
800064b2:	99 59       	st.w	r12[0x14],r9
800064b4:	76 49       	ld.w	r9,r11[0x10]
800064b6:	99 49       	st.w	r12[0x10],r9
800064b8:	76 39       	ld.w	r9,r11[0xc]
800064ba:	99 39       	st.w	r12[0xc],r9
800064bc:	76 29       	ld.w	r9,r11[0x8]
800064be:	99 29       	st.w	r12[0x8],r9
800064c0:	76 19       	ld.w	r9,r11[0x4]
800064c2:	99 19       	st.w	r12[0x4],r9
800064c4:	76 09       	ld.w	r9,r11[0x0]
800064c6:	99 09       	st.w	r12[0x0],r9
800064c8:	f6 08 00 2b 	add	r11,r11,r8<<0x2
800064cc:	f8 08 00 28 	add	r8,r12,r8<<0x2
800064d0:	e0 1a 00 03 	andl	r10,0x3
800064d4:	f4 0a 11 04 	rsub	r10,r10,4
800064d8:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800064dc:	17 a9       	ld.ub	r9,r11[0x2]
800064de:	b0 a9       	st.b	r8[0x2],r9
800064e0:	17 99       	ld.ub	r9,r11[0x1]
800064e2:	b0 99       	st.b	r8[0x1],r9
800064e4:	17 89       	ld.ub	r9,r11[0x0]
800064e6:	b0 89       	st.b	r8[0x0],r9
800064e8:	5e fc       	retal	r12
800064ea:	f4 0a 11 09 	rsub	r10,r10,9
800064ee:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800064f2:	17 f9       	ld.ub	r9,r11[0x7]
800064f4:	b8 f9       	st.b	r12[0x7],r9
800064f6:	17 e9       	ld.ub	r9,r11[0x6]
800064f8:	b8 e9       	st.b	r12[0x6],r9
800064fa:	17 d9       	ld.ub	r9,r11[0x5]
800064fc:	b8 d9       	st.b	r12[0x5],r9
800064fe:	17 c9       	ld.ub	r9,r11[0x4]
80006500:	b8 c9       	st.b	r12[0x4],r9
80006502:	17 b9       	ld.ub	r9,r11[0x3]
80006504:	b8 b9       	st.b	r12[0x3],r9
80006506:	17 a9       	ld.ub	r9,r11[0x2]
80006508:	b8 a9       	st.b	r12[0x2],r9
8000650a:	17 99       	ld.ub	r9,r11[0x1]
8000650c:	b8 99       	st.b	r12[0x1],r9
8000650e:	17 89       	ld.ub	r9,r11[0x0]
80006510:	b8 89       	st.b	r12[0x0],r9
80006512:	5e fc       	retal	r12
80006514:	eb cd 40 c0 	pushm	r6-r7,lr
80006518:	18 99       	mov	r9,r12
8000651a:	22 0a       	sub	r10,32
8000651c:	b7 07       	ld.d	r6,r11++
8000651e:	b3 26       	st.d	r9++,r6
80006520:	b7 07       	ld.d	r6,r11++
80006522:	b3 26       	st.d	r9++,r6
80006524:	b7 07       	ld.d	r6,r11++
80006526:	b3 26       	st.d	r9++,r6
80006528:	b7 07       	ld.d	r6,r11++
8000652a:	b3 26       	st.d	r9++,r6
8000652c:	22 0a       	sub	r10,32
8000652e:	cf 74       	brge	8000651c <memcpy+0x92>
80006530:	2f 0a       	sub	r10,-16
80006532:	c0 65       	brlt	8000653e <memcpy+0xb4>
80006534:	b7 07       	ld.d	r6,r11++
80006536:	b3 26       	st.d	r9++,r6
80006538:	b7 07       	ld.d	r6,r11++
8000653a:	b3 26       	st.d	r9++,r6
8000653c:	21 0a       	sub	r10,16
8000653e:	5c 3a       	neg	r10
80006540:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80006544:	d7 03       	nop
80006546:	d7 03       	nop
80006548:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000654c:	f3 66 00 0e 	st.b	r9[14],r6
80006550:	f7 36 00 0d 	ld.ub	r6,r11[13]
80006554:	f3 66 00 0d 	st.b	r9[13],r6
80006558:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000655c:	f3 66 00 0c 	st.b	r9[12],r6
80006560:	f7 36 00 0b 	ld.ub	r6,r11[11]
80006564:	f3 66 00 0b 	st.b	r9[11],r6
80006568:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000656c:	f3 66 00 0a 	st.b	r9[10],r6
80006570:	f7 36 00 09 	ld.ub	r6,r11[9]
80006574:	f3 66 00 09 	st.b	r9[9],r6
80006578:	f7 36 00 08 	ld.ub	r6,r11[8]
8000657c:	f3 66 00 08 	st.b	r9[8],r6
80006580:	f7 36 00 07 	ld.ub	r6,r11[7]
80006584:	f3 66 00 07 	st.b	r9[7],r6
80006588:	f7 36 00 06 	ld.ub	r6,r11[6]
8000658c:	f3 66 00 06 	st.b	r9[6],r6
80006590:	f7 36 00 05 	ld.ub	r6,r11[5]
80006594:	f3 66 00 05 	st.b	r9[5],r6
80006598:	f7 36 00 04 	ld.ub	r6,r11[4]
8000659c:	f3 66 00 04 	st.b	r9[4],r6
800065a0:	f7 36 00 03 	ld.ub	r6,r11[3]
800065a4:	f3 66 00 03 	st.b	r9[3],r6
800065a8:	f7 36 00 02 	ld.ub	r6,r11[2]
800065ac:	f3 66 00 02 	st.b	r9[2],r6
800065b0:	f7 36 00 01 	ld.ub	r6,r11[1]
800065b4:	f3 66 00 01 	st.b	r9[1],r6
800065b8:	f7 36 00 00 	ld.ub	r6,r11[0]
800065bc:	f3 66 00 00 	st.b	r9[0],r6
800065c0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800065c4:	20 1a       	sub	r10,1
800065c6:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800065ca:	f8 0a 0b 09 	st.b	r12[r10],r9
800065ce:	cf b1       	brne	800065c4 <memcpy+0x13a>
800065d0:	5e fc       	retal	r12

800065d2 <memset>:
800065d2:	18 98       	mov	r8,r12
800065d4:	c0 38       	rjmp	800065da <memset+0x8>
800065d6:	10 cb       	st.b	r8++,r11
800065d8:	20 1a       	sub	r10,1
800065da:	58 0a       	cp.w	r10,0
800065dc:	cf d1       	brne	800065d6 <memset+0x4>
800065de:	5e fc       	retal	r12

800065e0 <_realloc_r>:
800065e0:	d4 31       	pushm	r0-r7,lr
800065e2:	20 1d       	sub	sp,4
800065e4:	16 94       	mov	r4,r11
800065e6:	18 92       	mov	r2,r12
800065e8:	14 9b       	mov	r11,r10
800065ea:	58 04       	cp.w	r4,0
800065ec:	c0 51       	brne	800065f6 <_realloc_r+0x16>
800065ee:	fe b0 fd 1f 	rcall	8000602c <_malloc_r>
800065f2:	18 95       	mov	r5,r12
800065f4:	c5 39       	rjmp	8000689a <_realloc_r+0x2ba>
800065f6:	50 0a       	stdsp	sp[0x0],r10
800065f8:	fe b0 f3 e4 	rcall	80004dc0 <__malloc_lock>
800065fc:	40 0b       	lddsp	r11,sp[0x0]
800065fe:	f6 c8 ff f5 	sub	r8,r11,-11
80006602:	e8 c1 00 08 	sub	r1,r4,8
80006606:	10 96       	mov	r6,r8
80006608:	62 1c       	ld.w	r12,r1[0x4]
8000660a:	e0 16 ff f8 	andl	r6,0xfff8
8000660e:	59 68       	cp.w	r8,22
80006610:	f9 b6 08 10 	movls	r6,16
80006614:	16 36       	cp.w	r6,r11
80006616:	5f 38       	srlo	r8
80006618:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000661c:	c0 50       	breq	80006626 <_realloc_r+0x46>
8000661e:	30 c8       	mov	r8,12
80006620:	30 05       	mov	r5,0
80006622:	85 38       	st.w	r2[0xc],r8
80006624:	c3 b9       	rjmp	8000689a <_realloc_r+0x2ba>
80006626:	18 90       	mov	r0,r12
80006628:	e0 10 ff fc 	andl	r0,0xfffc
8000662c:	0c 30       	cp.w	r0,r6
8000662e:	e0 84 01 0b 	brge	80006844 <_realloc_r+0x264>
80006632:	e0 68 05 18 	mov	r8,1304
80006636:	e2 00 00 09 	add	r9,r1,r0
8000663a:	70 25       	ld.w	r5,r8[0x8]
8000663c:	0a 39       	cp.w	r9,r5
8000663e:	c0 90       	breq	80006650 <_realloc_r+0x70>
80006640:	72 1a       	ld.w	r10,r9[0x4]
80006642:	a1 ca       	cbr	r10,0x0
80006644:	f2 0a 00 0a 	add	r10,r9,r10
80006648:	74 1a       	ld.w	r10,r10[0x4]
8000664a:	ed ba 00 00 	bld	r10,0x0
8000664e:	c2 20       	breq	80006692 <_realloc_r+0xb2>
80006650:	72 1a       	ld.w	r10,r9[0x4]
80006652:	e0 1a ff fc 	andl	r10,0xfffc
80006656:	f4 00 00 03 	add	r3,r10,r0
8000665a:	0a 39       	cp.w	r9,r5
8000665c:	c1 31       	brne	80006682 <_realloc_r+0xa2>
8000665e:	ec c7 ff f0 	sub	r7,r6,-16
80006662:	0e 33       	cp.w	r3,r7
80006664:	c1 95       	brlt	80006696 <_realloc_r+0xb6>
80006666:	e2 06 00 09 	add	r9,r1,r6
8000666a:	0c 13       	sub	r3,r6
8000666c:	a1 a3       	sbr	r3,0x0
8000666e:	93 13       	st.w	r9[0x4],r3
80006670:	91 29       	st.w	r8[0x8],r9
80006672:	04 9c       	mov	r12,r2
80006674:	62 18       	ld.w	r8,r1[0x4]
80006676:	08 95       	mov	r5,r4
80006678:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000667c:	10 46       	or	r6,r8
8000667e:	83 16       	st.w	r1[0x4],r6
80006680:	c0 b9       	rjmp	80006896 <_realloc_r+0x2b6>
80006682:	0c 33       	cp.w	r3,r6
80006684:	c0 95       	brlt	80006696 <_realloc_r+0xb6>
80006686:	72 28       	ld.w	r8,r9[0x8]
80006688:	02 97       	mov	r7,r1
8000668a:	72 39       	ld.w	r9,r9[0xc]
8000668c:	93 28       	st.w	r9[0x8],r8
8000668e:	91 39       	st.w	r8[0xc],r9
80006690:	cd c8       	rjmp	80006848 <_realloc_r+0x268>
80006692:	30 0a       	mov	r10,0
80006694:	14 99       	mov	r9,r10
80006696:	ed bc 00 00 	bld	r12,0x0
8000669a:	e0 80 00 95 	breq	800067c4 <_realloc_r+0x1e4>
8000669e:	62 07       	ld.w	r7,r1[0x0]
800066a0:	e2 07 01 07 	sub	r7,r1,r7
800066a4:	6e 1c       	ld.w	r12,r7[0x4]
800066a6:	e0 1c ff fc 	andl	r12,0xfffc
800066aa:	58 09       	cp.w	r9,0
800066ac:	c5 60       	breq	80006758 <_realloc_r+0x178>
800066ae:	f8 00 00 03 	add	r3,r12,r0
800066b2:	0a 39       	cp.w	r9,r5
800066b4:	c4 81       	brne	80006744 <_realloc_r+0x164>
800066b6:	14 03       	add	r3,r10
800066b8:	ec c9 ff f0 	sub	r9,r6,-16
800066bc:	12 33       	cp.w	r3,r9
800066be:	c4 d5       	brlt	80006758 <_realloc_r+0x178>
800066c0:	6e 3a       	ld.w	r10,r7[0xc]
800066c2:	6e 29       	ld.w	r9,r7[0x8]
800066c4:	95 29       	st.w	r10[0x8],r9
800066c6:	93 3a       	st.w	r9[0xc],r10
800066c8:	ee c5 ff f8 	sub	r5,r7,-8
800066cc:	e0 ca 00 04 	sub	r10,r0,4
800066d0:	e0 4a 00 24 	cp.w	r10,36
800066d4:	e0 8b 00 25 	brhi	8000671e <_realloc_r+0x13e>
800066d8:	0a 99       	mov	r9,r5
800066da:	59 3a       	cp.w	r10,19
800066dc:	e0 88 00 1a 	brls	80006710 <_realloc_r+0x130>
800066e0:	09 09       	ld.w	r9,r4++
800066e2:	8b 09       	st.w	r5[0x0],r9
800066e4:	09 09       	ld.w	r9,r4++
800066e6:	8f 39       	st.w	r7[0xc],r9
800066e8:	ee c9 ff f0 	sub	r9,r7,-16
800066ec:	59 ba       	cp.w	r10,27
800066ee:	e0 88 00 11 	brls	80006710 <_realloc_r+0x130>
800066f2:	09 0b       	ld.w	r11,r4++
800066f4:	93 0b       	st.w	r9[0x0],r11
800066f6:	09 09       	ld.w	r9,r4++
800066f8:	8f 59       	st.w	r7[0x14],r9
800066fa:	ee c9 ff e8 	sub	r9,r7,-24
800066fe:	e0 4a 00 24 	cp.w	r10,36
80006702:	c0 71       	brne	80006710 <_realloc_r+0x130>
80006704:	09 0a       	ld.w	r10,r4++
80006706:	93 0a       	st.w	r9[0x0],r10
80006708:	ee c9 ff e0 	sub	r9,r7,-32
8000670c:	09 0a       	ld.w	r10,r4++
8000670e:	8f 7a       	st.w	r7[0x1c],r10
80006710:	09 0a       	ld.w	r10,r4++
80006712:	12 aa       	st.w	r9++,r10
80006714:	68 0a       	ld.w	r10,r4[0x0]
80006716:	93 0a       	st.w	r9[0x0],r10
80006718:	68 1a       	ld.w	r10,r4[0x4]
8000671a:	93 1a       	st.w	r9[0x4],r10
8000671c:	c0 78       	rjmp	8000672a <_realloc_r+0x14a>
8000671e:	50 08       	stdsp	sp[0x0],r8
80006720:	08 9b       	mov	r11,r4
80006722:	0a 9c       	mov	r12,r5
80006724:	e0 a0 1d 8f 	rcall	8000a242 <memmove>
80006728:	40 08       	lddsp	r8,sp[0x0]
8000672a:	ee 06 00 09 	add	r9,r7,r6
8000672e:	0c 13       	sub	r3,r6
80006730:	a1 a3       	sbr	r3,0x0
80006732:	93 13       	st.w	r9[0x4],r3
80006734:	91 29       	st.w	r8[0x8],r9
80006736:	04 9c       	mov	r12,r2
80006738:	6e 18       	ld.w	r8,r7[0x4]
8000673a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000673e:	10 46       	or	r6,r8
80006740:	8f 16       	st.w	r7[0x4],r6
80006742:	ca a8       	rjmp	80006896 <_realloc_r+0x2b6>
80006744:	14 03       	add	r3,r10
80006746:	0c 33       	cp.w	r3,r6
80006748:	c0 85       	brlt	80006758 <_realloc_r+0x178>
8000674a:	72 28       	ld.w	r8,r9[0x8]
8000674c:	72 39       	ld.w	r9,r9[0xc]
8000674e:	93 28       	st.w	r9[0x8],r8
80006750:	91 39       	st.w	r8[0xc],r9
80006752:	6e 28       	ld.w	r8,r7[0x8]
80006754:	6e 39       	ld.w	r9,r7[0xc]
80006756:	c0 78       	rjmp	80006764 <_realloc_r+0x184>
80006758:	f8 00 00 03 	add	r3,r12,r0
8000675c:	0c 33       	cp.w	r3,r6
8000675e:	c3 35       	brlt	800067c4 <_realloc_r+0x1e4>
80006760:	6e 39       	ld.w	r9,r7[0xc]
80006762:	6e 28       	ld.w	r8,r7[0x8]
80006764:	93 28       	st.w	r9[0x8],r8
80006766:	91 39       	st.w	r8[0xc],r9
80006768:	e0 ca 00 04 	sub	r10,r0,4
8000676c:	ee cc ff f8 	sub	r12,r7,-8
80006770:	e0 4a 00 24 	cp.w	r10,36
80006774:	e0 8b 00 24 	brhi	800067bc <_realloc_r+0x1dc>
80006778:	59 3a       	cp.w	r10,19
8000677a:	e0 88 00 1a 	brls	800067ae <_realloc_r+0x1ce>
8000677e:	09 08       	ld.w	r8,r4++
80006780:	99 08       	st.w	r12[0x0],r8
80006782:	09 08       	ld.w	r8,r4++
80006784:	8f 38       	st.w	r7[0xc],r8
80006786:	ee cc ff f0 	sub	r12,r7,-16
8000678a:	59 ba       	cp.w	r10,27
8000678c:	e0 88 00 11 	brls	800067ae <_realloc_r+0x1ce>
80006790:	09 08       	ld.w	r8,r4++
80006792:	99 08       	st.w	r12[0x0],r8
80006794:	09 08       	ld.w	r8,r4++
80006796:	8f 58       	st.w	r7[0x14],r8
80006798:	ee cc ff e8 	sub	r12,r7,-24
8000679c:	e0 4a 00 24 	cp.w	r10,36
800067a0:	c0 71       	brne	800067ae <_realloc_r+0x1ce>
800067a2:	09 08       	ld.w	r8,r4++
800067a4:	99 08       	st.w	r12[0x0],r8
800067a6:	ee cc ff e0 	sub	r12,r7,-32
800067aa:	09 08       	ld.w	r8,r4++
800067ac:	8f 78       	st.w	r7[0x1c],r8
800067ae:	09 08       	ld.w	r8,r4++
800067b0:	18 a8       	st.w	r12++,r8
800067b2:	68 08       	ld.w	r8,r4[0x0]
800067b4:	99 08       	st.w	r12[0x0],r8
800067b6:	68 18       	ld.w	r8,r4[0x4]
800067b8:	99 18       	st.w	r12[0x4],r8
800067ba:	c4 78       	rjmp	80006848 <_realloc_r+0x268>
800067bc:	08 9b       	mov	r11,r4
800067be:	e0 a0 1d 42 	rcall	8000a242 <memmove>
800067c2:	c4 38       	rjmp	80006848 <_realloc_r+0x268>
800067c4:	04 9c       	mov	r12,r2
800067c6:	fe b0 fc 33 	rcall	8000602c <_malloc_r>
800067ca:	18 95       	mov	r5,r12
800067cc:	c3 a0       	breq	80006840 <_realloc_r+0x260>
800067ce:	62 18       	ld.w	r8,r1[0x4]
800067d0:	f8 c9 00 08 	sub	r9,r12,8
800067d4:	a1 c8       	cbr	r8,0x0
800067d6:	e2 08 00 08 	add	r8,r1,r8
800067da:	10 39       	cp.w	r9,r8
800067dc:	c0 71       	brne	800067ea <_realloc_r+0x20a>
800067de:	72 13       	ld.w	r3,r9[0x4]
800067e0:	02 97       	mov	r7,r1
800067e2:	e0 13 ff fc 	andl	r3,0xfffc
800067e6:	00 03       	add	r3,r0
800067e8:	c3 08       	rjmp	80006848 <_realloc_r+0x268>
800067ea:	e0 ca 00 04 	sub	r10,r0,4
800067ee:	e0 4a 00 24 	cp.w	r10,36
800067f2:	e0 8b 00 20 	brhi	80006832 <_realloc_r+0x252>
800067f6:	08 99       	mov	r9,r4
800067f8:	18 98       	mov	r8,r12
800067fa:	59 3a       	cp.w	r10,19
800067fc:	e0 88 00 14 	brls	80006824 <_realloc_r+0x244>
80006800:	13 0b       	ld.w	r11,r9++
80006802:	10 ab       	st.w	r8++,r11
80006804:	13 0b       	ld.w	r11,r9++
80006806:	10 ab       	st.w	r8++,r11
80006808:	59 ba       	cp.w	r10,27
8000680a:	e0 88 00 0d 	brls	80006824 <_realloc_r+0x244>
8000680e:	13 0b       	ld.w	r11,r9++
80006810:	10 ab       	st.w	r8++,r11
80006812:	13 0b       	ld.w	r11,r9++
80006814:	10 ab       	st.w	r8++,r11
80006816:	e0 4a 00 24 	cp.w	r10,36
8000681a:	c0 51       	brne	80006824 <_realloc_r+0x244>
8000681c:	13 0a       	ld.w	r10,r9++
8000681e:	10 aa       	st.w	r8++,r10
80006820:	13 0a       	ld.w	r10,r9++
80006822:	10 aa       	st.w	r8++,r10
80006824:	13 0a       	ld.w	r10,r9++
80006826:	10 aa       	st.w	r8++,r10
80006828:	72 0a       	ld.w	r10,r9[0x0]
8000682a:	91 0a       	st.w	r8[0x0],r10
8000682c:	72 19       	ld.w	r9,r9[0x4]
8000682e:	91 19       	st.w	r8[0x4],r9
80006830:	c0 48       	rjmp	80006838 <_realloc_r+0x258>
80006832:	08 9b       	mov	r11,r4
80006834:	e0 a0 1d 07 	rcall	8000a242 <memmove>
80006838:	08 9b       	mov	r11,r4
8000683a:	04 9c       	mov	r12,r2
8000683c:	e0 a0 1a 60 	rcall	80009cfc <_free_r>
80006840:	04 9c       	mov	r12,r2
80006842:	c2 a8       	rjmp	80006896 <_realloc_r+0x2b6>
80006844:	00 93       	mov	r3,r0
80006846:	02 97       	mov	r7,r1
80006848:	e6 06 01 09 	sub	r9,r3,r6
8000684c:	6e 18       	ld.w	r8,r7[0x4]
8000684e:	58 f9       	cp.w	r9,15
80006850:	e0 88 00 16 	brls	8000687c <_realloc_r+0x29c>
80006854:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006858:	ed e8 10 08 	or	r8,r6,r8
8000685c:	8f 18       	st.w	r7[0x4],r8
8000685e:	12 98       	mov	r8,r9
80006860:	a1 a8       	sbr	r8,0x0
80006862:	ee 06 00 0b 	add	r11,r7,r6
80006866:	f6 09 00 09 	add	r9,r11,r9
8000686a:	97 18       	st.w	r11[0x4],r8
8000686c:	72 18       	ld.w	r8,r9[0x4]
8000686e:	a1 a8       	sbr	r8,0x0
80006870:	2f 8b       	sub	r11,-8
80006872:	93 18       	st.w	r9[0x4],r8
80006874:	04 9c       	mov	r12,r2
80006876:	e0 a0 1a 43 	rcall	80009cfc <_free_r>
8000687a:	c0 b8       	rjmp	80006890 <_realloc_r+0x2b0>
8000687c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006880:	e7 e8 10 08 	or	r8,r3,r8
80006884:	8f 18       	st.w	r7[0x4],r8
80006886:	ee 03 00 03 	add	r3,r7,r3
8000688a:	66 18       	ld.w	r8,r3[0x4]
8000688c:	a1 a8       	sbr	r8,0x0
8000688e:	87 18       	st.w	r3[0x4],r8
80006890:	04 9c       	mov	r12,r2
80006892:	ee c5 ff f8 	sub	r5,r7,-8
80006896:	fe b0 f2 9b 	rcall	80004dcc <__malloc_unlock>
8000689a:	0a 9c       	mov	r12,r5
8000689c:	2f fd       	sub	sp,-4
8000689e:	d8 32       	popm	r0-r7,pc

800068a0 <_sbrk_r>:
800068a0:	d4 21       	pushm	r4-r7,lr
800068a2:	30 08       	mov	r8,0
800068a4:	18 97       	mov	r7,r12
800068a6:	e0 66 1f a4 	mov	r6,8100
800068aa:	16 9c       	mov	r12,r11
800068ac:	8d 08       	st.w	r6[0x0],r8
800068ae:	c8 5c       	rcall	800069b8 <_sbrk>
800068b0:	5b fc       	cp.w	r12,-1
800068b2:	c0 51       	brne	800068bc <_sbrk_r+0x1c>
800068b4:	6c 08       	ld.w	r8,r6[0x0]
800068b6:	58 08       	cp.w	r8,0
800068b8:	ef f8 1a 03 	st.wne	r7[0xc],r8
800068bc:	d8 22       	popm	r4-r7,pc
800068be:	d7 03       	nop

800068c0 <sprintf>:
800068c0:	d4 01       	pushm	lr
800068c2:	21 7d       	sub	sp,92
800068c4:	e0 68 ff ff 	mov	r8,65535
800068c8:	ea 18 7f ff 	orh	r8,0x7fff
800068cc:	50 58       	stdsp	sp[0x14],r8
800068ce:	50 28       	stdsp	sp[0x8],r8
800068d0:	e0 68 02 08 	mov	r8,520
800068d4:	ba 68       	st.h	sp[0xc],r8
800068d6:	3f f8       	mov	r8,-1
800068d8:	ba 78       	st.h	sp[0xe],r8
800068da:	e0 68 0a 18 	mov	r8,2584
800068de:	50 4c       	stdsp	sp[0x10],r12
800068e0:	16 9a       	mov	r10,r11
800068e2:	50 0c       	stdsp	sp[0x0],r12
800068e4:	fa c9 ff a0 	sub	r9,sp,-96
800068e8:	70 0c       	ld.w	r12,r8[0x0]
800068ea:	1a 9b       	mov	r11,sp
800068ec:	e0 a0 02 1a 	rcall	80006d20 <_vfprintf_r>
800068f0:	30 09       	mov	r9,0
800068f2:	40 08       	lddsp	r8,sp[0x0]
800068f4:	b0 89       	st.b	r8[0x0],r9
800068f6:	2e 9d       	sub	sp,-92
800068f8:	d8 02       	popm	pc
800068fa:	d7 03       	nop

800068fc <strncpy>:
800068fc:	30 08       	mov	r8,0
800068fe:	10 3a       	cp.w	r10,r8
80006900:	5e 0c       	reteq	r12
80006902:	f6 08 07 09 	ld.ub	r9,r11[r8]
80006906:	f8 08 0b 09 	st.b	r12[r8],r9
8000690a:	2f f8       	sub	r8,-1
8000690c:	58 09       	cp.w	r9,0
8000690e:	cf 81       	brne	800068fe <strncpy+0x2>
80006910:	10 3a       	cp.w	r10,r8
80006912:	5e 0c       	reteq	r12
80006914:	f8 08 0b 09 	st.b	r12[r8],r9
80006918:	2f f8       	sub	r8,-1
8000691a:	cf bb       	rjmp	80006910 <strncpy+0x14>

8000691c <_close>:
8000691c:	30 28       	mov	r8,2
8000691e:	d6 73       	breakpoint
80006920:	3f fc       	mov	r12,-1
80006922:	35 8b       	mov	r11,88
80006924:	58 0c       	cp.w	r12,0
80006926:	5e 4c       	retge	r12
80006928:	e0 6a 1f a4 	mov	r10,8100
8000692c:	95 0b       	st.w	r10[0x0],r11
8000692e:	5e fc       	retal	r12

80006930 <_lseek>:
80006930:	30 58       	mov	r8,5
80006932:	d6 73       	breakpoint
80006934:	3f fc       	mov	r12,-1
80006936:	35 8b       	mov	r11,88
80006938:	58 0c       	cp.w	r12,0
8000693a:	5e 4c       	retge	r12
8000693c:	e0 6a 1f a4 	mov	r10,8100
80006940:	95 0b       	st.w	r10[0x0],r11
80006942:	5e fc       	retal	r12

80006944 <isatty>:
80006944:	30 b8       	mov	r8,11
80006946:	d6 73       	breakpoint
80006948:	3f fc       	mov	r12,-1
8000694a:	35 8b       	mov	r11,88
8000694c:	58 0c       	cp.w	r12,0
8000694e:	5e 4c       	retge	r12
80006950:	e0 6a 1f a4 	mov	r10,8100
80006954:	95 0b       	st.w	r10[0x0],r11
80006956:	5e fc       	retal	r12

80006958 <_fstat_host>:
80006958:	30 98       	mov	r8,9
8000695a:	d6 73       	breakpoint
8000695c:	3f fc       	mov	r12,-1
8000695e:	35 8b       	mov	r11,88
80006960:	58 0c       	cp.w	r12,0
80006962:	5e 4c       	retge	r12
80006964:	e0 6a 1f a4 	mov	r10,8100
80006968:	95 0b       	st.w	r10[0x0],r11
8000696a:	5e fc       	retal	r12

8000696c <_fstat>:
8000696c:	d4 21       	pushm	r4-r7,lr
8000696e:	21 0d       	sub	sp,64
80006970:	16 97       	mov	r7,r11
80006972:	1a 9b       	mov	r11,sp
80006974:	cf 2f       	rcall	80006958 <_fstat_host>
80006976:	c0 34       	brge	8000697c <_fstat+0x10>
80006978:	3f fc       	mov	r12,-1
8000697a:	c1 c8       	rjmp	800069b2 <_fstat+0x46>
8000697c:	40 08       	lddsp	r8,sp[0x0]
8000697e:	ae 08       	st.h	r7[0x0],r8
80006980:	40 18       	lddsp	r8,sp[0x4]
80006982:	ae 18       	st.h	r7[0x2],r8
80006984:	40 28       	lddsp	r8,sp[0x8]
80006986:	8f 18       	st.w	r7[0x4],r8
80006988:	40 38       	lddsp	r8,sp[0xc]
8000698a:	ae 48       	st.h	r7[0x8],r8
8000698c:	40 48       	lddsp	r8,sp[0x10]
8000698e:	ae 58       	st.h	r7[0xa],r8
80006990:	40 58       	lddsp	r8,sp[0x14]
80006992:	ae 68       	st.h	r7[0xc],r8
80006994:	40 68       	lddsp	r8,sp[0x18]
80006996:	ae 78       	st.h	r7[0xe],r8
80006998:	40 88       	lddsp	r8,sp[0x20]
8000699a:	8f 48       	st.w	r7[0x10],r8
8000699c:	40 a8       	lddsp	r8,sp[0x28]
8000699e:	8f b8       	st.w	r7[0x2c],r8
800069a0:	40 c8       	lddsp	r8,sp[0x30]
800069a2:	8f c8       	st.w	r7[0x30],r8
800069a4:	40 d8       	lddsp	r8,sp[0x34]
800069a6:	8f 58       	st.w	r7[0x14],r8
800069a8:	40 e8       	lddsp	r8,sp[0x38]
800069aa:	30 0c       	mov	r12,0
800069ac:	8f 78       	st.w	r7[0x1c],r8
800069ae:	40 f8       	lddsp	r8,sp[0x3c]
800069b0:	8f 98       	st.w	r7[0x24],r8
800069b2:	2f 0d       	sub	sp,-64
800069b4:	d8 22       	popm	r4-r7,pc
800069b6:	d7 03       	nop

800069b8 <_sbrk>:
800069b8:	d4 01       	pushm	lr
800069ba:	e0 68 0c e0 	mov	r8,3296
800069be:	70 09       	ld.w	r9,r8[0x0]
800069c0:	58 09       	cp.w	r9,0
800069c2:	c0 41       	brne	800069ca <_sbrk+0x12>
800069c4:	e0 69 1f a8 	mov	r9,8104
800069c8:	91 09       	st.w	r8[0x0],r9
800069ca:	e0 69 0c e0 	mov	r9,3296
800069ce:	e0 7a 70 00 	mov	r10,94208
800069d2:	72 08       	ld.w	r8,r9[0x0]
800069d4:	f0 0c 00 0c 	add	r12,r8,r12
800069d8:	14 3c       	cp.w	r12,r10
800069da:	e0 8b 00 04 	brhi	800069e2 <_sbrk+0x2a>
800069de:	93 0c       	st.w	r9[0x0],r12
800069e0:	c0 68       	rjmp	800069ec <_sbrk+0x34>
800069e2:	e0 a0 18 15 	rcall	80009a0c <__errno>
800069e6:	30 c8       	mov	r8,12
800069e8:	99 08       	st.w	r12[0x0],r8
800069ea:	3f f8       	mov	r8,-1
800069ec:	10 9c       	mov	r12,r8
800069ee:	d8 02       	popm	pc

800069f0 <get_arg>:
800069f0:	d4 31       	pushm	r0-r7,lr
800069f2:	20 8d       	sub	sp,32
800069f4:	fa c4 ff bc 	sub	r4,sp,-68
800069f8:	50 4b       	stdsp	sp[0x10],r11
800069fa:	68 2e       	ld.w	lr,r4[0x8]
800069fc:	50 58       	stdsp	sp[0x14],r8
800069fe:	12 96       	mov	r6,r9
80006a00:	7c 0b       	ld.w	r11,lr[0x0]
80006a02:	70 05       	ld.w	r5,r8[0x0]
80006a04:	50 6e       	stdsp	sp[0x18],lr
80006a06:	58 0b       	cp.w	r11,0
80006a08:	f4 0b 17 00 	moveq	r11,r10
80006a0c:	68 03       	ld.w	r3,r4[0x0]
80006a0e:	68 11       	ld.w	r1,r4[0x4]
80006a10:	40 49       	lddsp	r9,sp[0x10]
80006a12:	30 08       	mov	r8,0
80006a14:	c2 89       	rjmp	80006c64 <get_arg+0x274>
80006a16:	2f fb       	sub	r11,-1
80006a18:	32 5c       	mov	r12,37
80006a1a:	17 8a       	ld.ub	r10,r11[0x0]
80006a1c:	f8 0a 18 00 	cp.b	r10,r12
80006a20:	5f 1e       	srne	lr
80006a22:	f0 0a 18 00 	cp.b	r10,r8
80006a26:	5f 1c       	srne	r12
80006a28:	fd ec 00 0c 	and	r12,lr,r12
80006a2c:	f0 0c 18 00 	cp.b	r12,r8
80006a30:	cf 31       	brne	80006a16 <get_arg+0x26>
80006a32:	58 0a       	cp.w	r10,0
80006a34:	e0 80 01 25 	breq	80006c7e <get_arg+0x28e>
80006a38:	30 0c       	mov	r12,0
80006a3a:	3f fa       	mov	r10,-1
80006a3c:	18 90       	mov	r0,r12
80006a3e:	50 3a       	stdsp	sp[0xc],r10
80006a40:	18 94       	mov	r4,r12
80006a42:	18 92       	mov	r2,r12
80006a44:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
80006a48:	16 97       	mov	r7,r11
80006a4a:	50 7c       	stdsp	sp[0x1c],r12
80006a4c:	fe cc 9e c4 	sub	r12,pc,-24892
80006a50:	0f 3a       	ld.ub	r10,r7++
80006a52:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
80006a56:	40 7c       	lddsp	r12,sp[0x1c]
80006a58:	1c 0c       	add	r12,lr
80006a5a:	fe ce 9f 9a 	sub	lr,pc,-24678
80006a5e:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
80006a62:	20 1e       	sub	lr,1
80006a64:	50 0e       	stdsp	sp[0x0],lr
80006a66:	fe ce a0 12 	sub	lr,pc,-24558
80006a6a:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80006a6e:	50 7c       	stdsp	sp[0x1c],r12
80006a70:	40 0c       	lddsp	r12,sp[0x0]
80006a72:	58 7c       	cp.w	r12,7
80006a74:	e0 8b 00 f1 	brhi	80006c56 <get_arg+0x266>
80006a78:	fe ce a1 c4 	sub	lr,pc,-24124
80006a7c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
80006a80:	36 8b       	mov	r11,104
80006a82:	f6 0a 18 00 	cp.b	r10,r11
80006a86:	e0 80 00 e8 	breq	80006c56 <get_arg+0x266>
80006a8a:	37 1b       	mov	r11,113
80006a8c:	f6 0a 18 00 	cp.b	r10,r11
80006a90:	c0 70       	breq	80006a9e <get_arg+0xae>
80006a92:	34 cb       	mov	r11,76
80006a94:	f6 0a 18 00 	cp.b	r10,r11
80006a98:	c0 51       	brne	80006aa2 <get_arg+0xb2>
80006a9a:	a3 b4       	sbr	r4,0x3
80006a9c:	cd d8       	rjmp	80006c56 <get_arg+0x266>
80006a9e:	a5 b4       	sbr	r4,0x5
80006aa0:	cd b8       	rjmp	80006c56 <get_arg+0x266>
80006aa2:	08 9a       	mov	r10,r4
80006aa4:	0e 9b       	mov	r11,r7
80006aa6:	a5 aa       	sbr	r10,0x4
80006aa8:	17 3c       	ld.ub	r12,r11++
80006aaa:	a5 b4       	sbr	r4,0x5
80006aac:	36 ce       	mov	lr,108
80006aae:	fc 0c 18 00 	cp.b	r12,lr
80006ab2:	e0 80 00 d3 	breq	80006c58 <get_arg+0x268>
80006ab6:	14 94       	mov	r4,r10
80006ab8:	cc f8       	rjmp	80006c56 <get_arg+0x266>
80006aba:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
80006abe:	36 7c       	mov	r12,103
80006ac0:	f8 0a 18 00 	cp.b	r10,r12
80006ac4:	e0 8b 00 27 	brhi	80006b12 <get_arg+0x122>
80006ac8:	36 5b       	mov	r11,101
80006aca:	f6 0a 18 00 	cp.b	r10,r11
80006ace:	c4 82       	brcc	80006b5e <get_arg+0x16e>
80006ad0:	34 fb       	mov	r11,79
80006ad2:	f6 0a 18 00 	cp.b	r10,r11
80006ad6:	c4 80       	breq	80006b66 <get_arg+0x176>
80006ad8:	e0 8b 00 0c 	brhi	80006af0 <get_arg+0x100>
80006adc:	34 5b       	mov	r11,69
80006ade:	f6 0a 18 00 	cp.b	r10,r11
80006ae2:	c3 e0       	breq	80006b5e <get_arg+0x16e>
80006ae4:	34 7b       	mov	r11,71
80006ae6:	f6 0a 18 00 	cp.b	r10,r11
80006aea:	c3 a0       	breq	80006b5e <get_arg+0x16e>
80006aec:	34 4b       	mov	r11,68
80006aee:	c0 88       	rjmp	80006afe <get_arg+0x10e>
80006af0:	35 8b       	mov	r11,88
80006af2:	f6 0a 18 00 	cp.b	r10,r11
80006af6:	c2 c0       	breq	80006b4e <get_arg+0x15e>
80006af8:	e0 8b 00 07 	brhi	80006b06 <get_arg+0x116>
80006afc:	35 5b       	mov	r11,85
80006afe:	f6 0a 18 00 	cp.b	r10,r11
80006b02:	c3 51       	brne	80006b6c <get_arg+0x17c>
80006b04:	c3 18       	rjmp	80006b66 <get_arg+0x176>
80006b06:	36 3b       	mov	r11,99
80006b08:	f6 0a 18 00 	cp.b	r10,r11
80006b0c:	c2 f0       	breq	80006b6a <get_arg+0x17a>
80006b0e:	36 4b       	mov	r11,100
80006b10:	c0 e8       	rjmp	80006b2c <get_arg+0x13c>
80006b12:	37 0b       	mov	r11,112
80006b14:	f6 0a 18 00 	cp.b	r10,r11
80006b18:	c2 50       	breq	80006b62 <get_arg+0x172>
80006b1a:	e0 8b 00 0d 	brhi	80006b34 <get_arg+0x144>
80006b1e:	36 eb       	mov	r11,110
80006b20:	f6 0a 18 00 	cp.b	r10,r11
80006b24:	c1 f0       	breq	80006b62 <get_arg+0x172>
80006b26:	e0 8b 00 14 	brhi	80006b4e <get_arg+0x15e>
80006b2a:	36 9b       	mov	r11,105
80006b2c:	f6 0a 18 00 	cp.b	r10,r11
80006b30:	c1 e1       	brne	80006b6c <get_arg+0x17c>
80006b32:	c0 e8       	rjmp	80006b4e <get_arg+0x15e>
80006b34:	37 5b       	mov	r11,117
80006b36:	f6 0a 18 00 	cp.b	r10,r11
80006b3a:	c0 a0       	breq	80006b4e <get_arg+0x15e>
80006b3c:	37 8b       	mov	r11,120
80006b3e:	f6 0a 18 00 	cp.b	r10,r11
80006b42:	c0 60       	breq	80006b4e <get_arg+0x15e>
80006b44:	37 3b       	mov	r11,115
80006b46:	f6 0a 18 00 	cp.b	r10,r11
80006b4a:	c1 11       	brne	80006b6c <get_arg+0x17c>
80006b4c:	c0 b8       	rjmp	80006b62 <get_arg+0x172>
80006b4e:	ed b4 00 04 	bld	r4,0x4
80006b52:	c0 a0       	breq	80006b66 <get_arg+0x176>
80006b54:	ed b4 00 05 	bld	r4,0x5
80006b58:	c0 91       	brne	80006b6a <get_arg+0x17a>
80006b5a:	30 20       	mov	r0,2
80006b5c:	c0 88       	rjmp	80006b6c <get_arg+0x17c>
80006b5e:	30 40       	mov	r0,4
80006b60:	c0 68       	rjmp	80006b6c <get_arg+0x17c>
80006b62:	30 30       	mov	r0,3
80006b64:	c0 48       	rjmp	80006b6c <get_arg+0x17c>
80006b66:	30 10       	mov	r0,1
80006b68:	c0 28       	rjmp	80006b6c <get_arg+0x17c>
80006b6a:	30 00       	mov	r0,0
80006b6c:	40 3b       	lddsp	r11,sp[0xc]
80006b6e:	5b fb       	cp.w	r11,-1
80006b70:	c0 40       	breq	80006b78 <get_arg+0x188>
80006b72:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
80006b76:	c7 08       	rjmp	80006c56 <get_arg+0x266>
80006b78:	58 60       	cp.w	r0,6
80006b7a:	e0 8b 00 6e 	brhi	80006c56 <get_arg+0x266>
80006b7e:	6c 0a       	ld.w	r10,r6[0x0]
80006b80:	ea cc ff ff 	sub	r12,r5,-1
80006b84:	fe ce a2 b0 	sub	lr,pc,-23888
80006b88:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
80006b8c:	f4 cb ff f8 	sub	r11,r10,-8
80006b90:	8d 0b       	st.w	r6[0x0],r11
80006b92:	f4 ea 00 00 	ld.d	r10,r10[0]
80006b96:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006b9a:	c0 f8       	rjmp	80006bb8 <get_arg+0x1c8>
80006b9c:	f4 cb ff fc 	sub	r11,r10,-4
80006ba0:	8d 0b       	st.w	r6[0x0],r11
80006ba2:	74 0a       	ld.w	r10,r10[0x0]
80006ba4:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006ba8:	c0 88       	rjmp	80006bb8 <get_arg+0x1c8>
80006baa:	f4 cb ff f8 	sub	r11,r10,-8
80006bae:	8d 0b       	st.w	r6[0x0],r11
80006bb0:	f4 ea 00 00 	ld.d	r10,r10[0]
80006bb4:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
80006bb8:	0e 9b       	mov	r11,r7
80006bba:	18 95       	mov	r5,r12
80006bbc:	c4 e8       	rjmp	80006c58 <get_arg+0x268>
80006bbe:	62 0a       	ld.w	r10,r1[0x0]
80006bc0:	5b fa       	cp.w	r10,-1
80006bc2:	c0 b1       	brne	80006bd8 <get_arg+0x1e8>
80006bc4:	50 19       	stdsp	sp[0x4],r9
80006bc6:	50 28       	stdsp	sp[0x8],r8
80006bc8:	e0 6a 00 80 	mov	r10,128
80006bcc:	30 0b       	mov	r11,0
80006bce:	02 9c       	mov	r12,r1
80006bd0:	fe b0 fd 01 	rcall	800065d2 <memset>
80006bd4:	40 28       	lddsp	r8,sp[0x8]
80006bd6:	40 19       	lddsp	r9,sp[0x4]
80006bd8:	e4 cc 00 01 	sub	r12,r2,1
80006bdc:	0e 9b       	mov	r11,r7
80006bde:	50 3c       	stdsp	sp[0xc],r12
80006be0:	f2 0c 0c 49 	max	r9,r9,r12
80006be4:	c3 a8       	rjmp	80006c58 <get_arg+0x268>
80006be6:	62 0a       	ld.w	r10,r1[0x0]
80006be8:	5b fa       	cp.w	r10,-1
80006bea:	c0 b1       	brne	80006c00 <get_arg+0x210>
80006bec:	50 19       	stdsp	sp[0x4],r9
80006bee:	50 28       	stdsp	sp[0x8],r8
80006bf0:	e0 6a 00 80 	mov	r10,128
80006bf4:	30 0b       	mov	r11,0
80006bf6:	02 9c       	mov	r12,r1
80006bf8:	fe b0 fc ed 	rcall	800065d2 <memset>
80006bfc:	40 28       	lddsp	r8,sp[0x8]
80006bfe:	40 19       	lddsp	r9,sp[0x4]
80006c00:	20 12       	sub	r2,1
80006c02:	30 0a       	mov	r10,0
80006c04:	0e 9b       	mov	r11,r7
80006c06:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
80006c0a:	f2 02 0c 49 	max	r9,r9,r2
80006c0e:	c2 58       	rjmp	80006c58 <get_arg+0x268>
80006c10:	16 97       	mov	r7,r11
80006c12:	6c 0a       	ld.w	r10,r6[0x0]
80006c14:	f4 cb ff fc 	sub	r11,r10,-4
80006c18:	8d 0b       	st.w	r6[0x0],r11
80006c1a:	74 0a       	ld.w	r10,r10[0x0]
80006c1c:	0e 9b       	mov	r11,r7
80006c1e:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
80006c22:	2f f5       	sub	r5,-1
80006c24:	c1 a8       	rjmp	80006c58 <get_arg+0x268>
80006c26:	f4 c2 00 30 	sub	r2,r10,48
80006c2a:	c0 68       	rjmp	80006c36 <get_arg+0x246>
80006c2c:	e4 02 00 22 	add	r2,r2,r2<<0x2
80006c30:	2f f7       	sub	r7,-1
80006c32:	f4 02 00 12 	add	r2,r10,r2<<0x1
80006c36:	0f 8a       	ld.ub	r10,r7[0x0]
80006c38:	58 0a       	cp.w	r10,0
80006c3a:	c0 e0       	breq	80006c56 <get_arg+0x266>
80006c3c:	23 0a       	sub	r10,48
80006c3e:	58 9a       	cp.w	r10,9
80006c40:	fe 98 ff f6 	brls	80006c2c <get_arg+0x23c>
80006c44:	c0 98       	rjmp	80006c56 <get_arg+0x266>
80006c46:	2f f7       	sub	r7,-1
80006c48:	0f 8a       	ld.ub	r10,r7[0x0]
80006c4a:	58 0a       	cp.w	r10,0
80006c4c:	c0 50       	breq	80006c56 <get_arg+0x266>
80006c4e:	23 0a       	sub	r10,48
80006c50:	58 9a       	cp.w	r10,9
80006c52:	fe 98 ff fa 	brls	80006c46 <get_arg+0x256>
80006c56:	0e 9b       	mov	r11,r7
80006c58:	40 7c       	lddsp	r12,sp[0x1c]
80006c5a:	30 ba       	mov	r10,11
80006c5c:	f4 0c 18 00 	cp.b	r12,r10
80006c60:	fe 91 fe f2 	brne	80006a44 <get_arg+0x54>
80006c64:	40 42       	lddsp	r2,sp[0x10]
80006c66:	17 8c       	ld.ub	r12,r11[0x0]
80006c68:	0a 32       	cp.w	r2,r5
80006c6a:	5f 4a       	srge	r10
80006c6c:	f0 0c 18 00 	cp.b	r12,r8
80006c70:	5f 1c       	srne	r12
80006c72:	f9 ea 00 0a 	and	r10,r12,r10
80006c76:	f0 0a 18 00 	cp.b	r10,r8
80006c7a:	fe 91 fe cf 	brne	80006a18 <get_arg+0x28>
80006c7e:	30 08       	mov	r8,0
80006c80:	40 4e       	lddsp	lr,sp[0x10]
80006c82:	17 8a       	ld.ub	r10,r11[0x0]
80006c84:	e2 05 00 21 	add	r1,r1,r5<<0x2
80006c88:	f0 0a 18 00 	cp.b	r10,r8
80006c8c:	fc 09 17 10 	movne	r9,lr
80006c90:	e6 05 00 38 	add	r8,r3,r5<<0x3
80006c94:	06 9e       	mov	lr,r3
80006c96:	c2 a8       	rjmp	80006cea <get_arg+0x2fa>
80006c98:	62 0a       	ld.w	r10,r1[0x0]
80006c9a:	58 3a       	cp.w	r10,3
80006c9c:	c1 e0       	breq	80006cd8 <get_arg+0x2e8>
80006c9e:	e0 89 00 07 	brgt	80006cac <get_arg+0x2bc>
80006ca2:	58 1a       	cp.w	r10,1
80006ca4:	c1 a0       	breq	80006cd8 <get_arg+0x2e8>
80006ca6:	58 2a       	cp.w	r10,2
80006ca8:	c1 81       	brne	80006cd8 <get_arg+0x2e8>
80006caa:	c0 58       	rjmp	80006cb4 <get_arg+0x2c4>
80006cac:	58 5a       	cp.w	r10,5
80006cae:	c0 c0       	breq	80006cc6 <get_arg+0x2d6>
80006cb0:	c0 b5       	brlt	80006cc6 <get_arg+0x2d6>
80006cb2:	c1 38       	rjmp	80006cd8 <get_arg+0x2e8>
80006cb4:	6c 0a       	ld.w	r10,r6[0x0]
80006cb6:	f4 cc ff f8 	sub	r12,r10,-8
80006cba:	8d 0c       	st.w	r6[0x0],r12
80006cbc:	f4 e2 00 00 	ld.d	r2,r10[0]
80006cc0:	f0 e3 00 00 	st.d	r8[0],r2
80006cc4:	c1 08       	rjmp	80006ce4 <get_arg+0x2f4>
80006cc6:	6c 0a       	ld.w	r10,r6[0x0]
80006cc8:	f4 cc ff f8 	sub	r12,r10,-8
80006ccc:	8d 0c       	st.w	r6[0x0],r12
80006cce:	f4 e2 00 00 	ld.d	r2,r10[0]
80006cd2:	f0 e3 00 00 	st.d	r8[0],r2
80006cd6:	c0 78       	rjmp	80006ce4 <get_arg+0x2f4>
80006cd8:	6c 0a       	ld.w	r10,r6[0x0]
80006cda:	f4 cc ff fc 	sub	r12,r10,-4
80006cde:	8d 0c       	st.w	r6[0x0],r12
80006ce0:	74 0a       	ld.w	r10,r10[0x0]
80006ce2:	91 0a       	st.w	r8[0x0],r10
80006ce4:	2f f5       	sub	r5,-1
80006ce6:	2f 88       	sub	r8,-8
80006ce8:	2f c1       	sub	r1,-4
80006cea:	12 35       	cp.w	r5,r9
80006cec:	fe 9a ff d6 	brle	80006c98 <get_arg+0x2a8>
80006cf0:	1c 93       	mov	r3,lr
80006cf2:	40 52       	lddsp	r2,sp[0x14]
80006cf4:	40 6e       	lddsp	lr,sp[0x18]
80006cf6:	85 05       	st.w	r2[0x0],r5
80006cf8:	9d 0b       	st.w	lr[0x0],r11
80006cfa:	40 4b       	lddsp	r11,sp[0x10]
80006cfc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
80006d00:	2f 8d       	sub	sp,-32
80006d02:	d8 32       	popm	r0-r7,pc

80006d04 <__sprint_r>:
80006d04:	d4 21       	pushm	r4-r7,lr
80006d06:	14 97       	mov	r7,r10
80006d08:	74 28       	ld.w	r8,r10[0x8]
80006d0a:	58 08       	cp.w	r8,0
80006d0c:	c0 41       	brne	80006d14 <__sprint_r+0x10>
80006d0e:	95 18       	st.w	r10[0x4],r8
80006d10:	10 9c       	mov	r12,r8
80006d12:	d8 22       	popm	r4-r7,pc
80006d14:	e0 a0 18 ba 	rcall	80009e88 <__sfvwrite_r>
80006d18:	30 08       	mov	r8,0
80006d1a:	8f 18       	st.w	r7[0x4],r8
80006d1c:	8f 28       	st.w	r7[0x8],r8
80006d1e:	d8 22       	popm	r4-r7,pc

80006d20 <_vfprintf_r>:
80006d20:	d4 31       	pushm	r0-r7,lr
80006d22:	fa cd 06 bc 	sub	sp,sp,1724
80006d26:	51 09       	stdsp	sp[0x40],r9
80006d28:	16 91       	mov	r1,r11
80006d2a:	14 97       	mov	r7,r10
80006d2c:	18 95       	mov	r5,r12
80006d2e:	e0 a0 1a 1d 	rcall	8000a168 <_localeconv_r>
80006d32:	78 0c       	ld.w	r12,r12[0x0]
80006d34:	50 cc       	stdsp	sp[0x30],r12
80006d36:	58 05       	cp.w	r5,0
80006d38:	c0 70       	breq	80006d46 <_vfprintf_r+0x26>
80006d3a:	6a 68       	ld.w	r8,r5[0x18]
80006d3c:	58 08       	cp.w	r8,0
80006d3e:	c0 41       	brne	80006d46 <_vfprintf_r+0x26>
80006d40:	0a 9c       	mov	r12,r5
80006d42:	e0 a0 17 43 	rcall	80009bc8 <__sinit>
80006d46:	fe c8 a0 ae 	sub	r8,pc,-24402
80006d4a:	10 31       	cp.w	r1,r8
80006d4c:	c0 31       	brne	80006d52 <_vfprintf_r+0x32>
80006d4e:	6a 01       	ld.w	r1,r5[0x0]
80006d50:	c0 c8       	rjmp	80006d68 <_vfprintf_r+0x48>
80006d52:	fe c8 a0 9a 	sub	r8,pc,-24422
80006d56:	10 31       	cp.w	r1,r8
80006d58:	c0 31       	brne	80006d5e <_vfprintf_r+0x3e>
80006d5a:	6a 11       	ld.w	r1,r5[0x4]
80006d5c:	c0 68       	rjmp	80006d68 <_vfprintf_r+0x48>
80006d5e:	fe c8 a0 86 	sub	r8,pc,-24442
80006d62:	10 31       	cp.w	r1,r8
80006d64:	eb f1 00 02 	ld.weq	r1,r5[0x8]
80006d68:	82 68       	ld.sh	r8,r1[0xc]
80006d6a:	ed b8 00 03 	bld	r8,0x3
80006d6e:	c0 41       	brne	80006d76 <_vfprintf_r+0x56>
80006d70:	62 48       	ld.w	r8,r1[0x10]
80006d72:	58 08       	cp.w	r8,0
80006d74:	c0 71       	brne	80006d82 <_vfprintf_r+0x62>
80006d76:	02 9b       	mov	r11,r1
80006d78:	0a 9c       	mov	r12,r5
80006d7a:	e0 a0 0f 5d 	rcall	80008c34 <__swsetup_r>
80006d7e:	e0 81 0f 54 	brne	80008c26 <_vfprintf_r+0x1f06>
80006d82:	82 68       	ld.sh	r8,r1[0xc]
80006d84:	10 99       	mov	r9,r8
80006d86:	e2 19 00 1a 	andl	r9,0x1a,COH
80006d8a:	58 a9       	cp.w	r9,10
80006d8c:	c3 c1       	brne	80006e04 <_vfprintf_r+0xe4>
80006d8e:	82 79       	ld.sh	r9,r1[0xe]
80006d90:	30 0a       	mov	r10,0
80006d92:	f4 09 19 00 	cp.h	r9,r10
80006d96:	c3 75       	brlt	80006e04 <_vfprintf_r+0xe4>
80006d98:	a1 d8       	cbr	r8,0x1
80006d9a:	fb 58 05 d0 	st.h	sp[1488],r8
80006d9e:	62 88       	ld.w	r8,r1[0x20]
80006da0:	fb 48 05 e4 	st.w	sp[1508],r8
80006da4:	62 a8       	ld.w	r8,r1[0x28]
80006da6:	fb 48 05 ec 	st.w	sp[1516],r8
80006daa:	fa c8 ff bc 	sub	r8,sp,-68
80006dae:	fb 48 05 d4 	st.w	sp[1492],r8
80006db2:	fb 48 05 c4 	st.w	sp[1476],r8
80006db6:	e0 68 04 00 	mov	r8,1024
80006dba:	fb 48 05 d8 	st.w	sp[1496],r8
80006dbe:	fb 48 05 cc 	st.w	sp[1484],r8
80006dc2:	30 08       	mov	r8,0
80006dc4:	fb 59 05 d2 	st.h	sp[1490],r9
80006dc8:	0e 9a       	mov	r10,r7
80006dca:	41 09       	lddsp	r9,sp[0x40]
80006dcc:	fa c7 fa 3c 	sub	r7,sp,-1476
80006dd0:	fb 48 05 dc 	st.w	sp[1500],r8
80006dd4:	0a 9c       	mov	r12,r5
80006dd6:	0e 9b       	mov	r11,r7
80006dd8:	ca 4f       	rcall	80006d20 <_vfprintf_r>
80006dda:	50 bc       	stdsp	sp[0x2c],r12
80006ddc:	c0 95       	brlt	80006dee <_vfprintf_r+0xce>
80006dde:	0e 9b       	mov	r11,r7
80006de0:	0a 9c       	mov	r12,r5
80006de2:	e0 a0 16 1b 	rcall	80009a18 <_fflush_r>
80006de6:	40 be       	lddsp	lr,sp[0x2c]
80006de8:	f9 be 01 ff 	movne	lr,-1
80006dec:	50 be       	stdsp	sp[0x2c],lr
80006dee:	fb 08 05 d0 	ld.sh	r8,sp[1488]
80006df2:	ed b8 00 06 	bld	r8,0x6
80006df6:	e0 81 0f 1a 	brne	80008c2a <_vfprintf_r+0x1f0a>
80006dfa:	82 68       	ld.sh	r8,r1[0xc]
80006dfc:	a7 a8       	sbr	r8,0x6
80006dfe:	a2 68       	st.h	r1[0xc],r8
80006e00:	e0 8f 0f 15 	bral	80008c2a <_vfprintf_r+0x1f0a>
80006e04:	30 08       	mov	r8,0
80006e06:	fb 48 06 b4 	st.w	sp[1716],r8
80006e0a:	fb 48 06 90 	st.w	sp[1680],r8
80006e0e:	fb 48 06 8c 	st.w	sp[1676],r8
80006e12:	fb 48 06 b0 	st.w	sp[1712],r8
80006e16:	30 08       	mov	r8,0
80006e18:	30 09       	mov	r9,0
80006e1a:	50 a7       	stdsp	sp[0x28],r7
80006e1c:	50 78       	stdsp	sp[0x1c],r8
80006e1e:	fa c3 f9 e0 	sub	r3,sp,-1568
80006e22:	3f f8       	mov	r8,-1
80006e24:	50 59       	stdsp	sp[0x14],r9
80006e26:	fb 43 06 88 	st.w	sp[1672],r3
80006e2a:	fb 48 05 44 	st.w	sp[1348],r8
80006e2e:	12 9c       	mov	r12,r9
80006e30:	50 69       	stdsp	sp[0x18],r9
80006e32:	50 d9       	stdsp	sp[0x34],r9
80006e34:	50 e9       	stdsp	sp[0x38],r9
80006e36:	50 b9       	stdsp	sp[0x2c],r9
80006e38:	12 97       	mov	r7,r9
80006e3a:	0a 94       	mov	r4,r5
80006e3c:	40 a2       	lddsp	r2,sp[0x28]
80006e3e:	32 5a       	mov	r10,37
80006e40:	30 08       	mov	r8,0
80006e42:	c0 28       	rjmp	80006e46 <_vfprintf_r+0x126>
80006e44:	2f f2       	sub	r2,-1
80006e46:	05 89       	ld.ub	r9,r2[0x0]
80006e48:	f0 09 18 00 	cp.b	r9,r8
80006e4c:	5f 1b       	srne	r11
80006e4e:	f4 09 18 00 	cp.b	r9,r10
80006e52:	5f 19       	srne	r9
80006e54:	f3 eb 00 0b 	and	r11,r9,r11
80006e58:	f0 0b 18 00 	cp.b	r11,r8
80006e5c:	cf 41       	brne	80006e44 <_vfprintf_r+0x124>
80006e5e:	40 ab       	lddsp	r11,sp[0x28]
80006e60:	e4 0b 01 06 	sub	r6,r2,r11
80006e64:	c1 e0       	breq	80006ea0 <_vfprintf_r+0x180>
80006e66:	fa f8 06 90 	ld.w	r8,sp[1680]
80006e6a:	0c 08       	add	r8,r6
80006e6c:	87 0b       	st.w	r3[0x0],r11
80006e6e:	fb 48 06 90 	st.w	sp[1680],r8
80006e72:	87 16       	st.w	r3[0x4],r6
80006e74:	fa f8 06 8c 	ld.w	r8,sp[1676]
80006e78:	2f f8       	sub	r8,-1
80006e7a:	fb 48 06 8c 	st.w	sp[1676],r8
80006e7e:	58 78       	cp.w	r8,7
80006e80:	e0 89 00 04 	brgt	80006e88 <_vfprintf_r+0x168>
80006e84:	2f 83       	sub	r3,-8
80006e86:	c0 a8       	rjmp	80006e9a <_vfprintf_r+0x17a>
80006e88:	fa ca f9 78 	sub	r10,sp,-1672
80006e8c:	02 9b       	mov	r11,r1
80006e8e:	08 9c       	mov	r12,r4
80006e90:	c3 af       	rcall	80006d04 <__sprint_r>
80006e92:	e0 81 0e c6 	brne	80008c1e <_vfprintf_r+0x1efe>
80006e96:	fa c3 f9 e0 	sub	r3,sp,-1568
80006e9a:	40 ba       	lddsp	r10,sp[0x2c]
80006e9c:	0c 0a       	add	r10,r6
80006e9e:	50 ba       	stdsp	sp[0x2c],r10
80006ea0:	05 89       	ld.ub	r9,r2[0x0]
80006ea2:	30 08       	mov	r8,0
80006ea4:	f0 09 18 00 	cp.b	r9,r8
80006ea8:	e0 80 0e aa 	breq	80008bfc <_vfprintf_r+0x1edc>
80006eac:	30 09       	mov	r9,0
80006eae:	fb 68 06 bb 	st.b	sp[1723],r8
80006eb2:	0e 96       	mov	r6,r7
80006eb4:	e4 c8 ff ff 	sub	r8,r2,-1
80006eb8:	3f fe       	mov	lr,-1
80006eba:	50 93       	stdsp	sp[0x24],r3
80006ebc:	50 41       	stdsp	sp[0x10],r1
80006ebe:	0e 93       	mov	r3,r7
80006ec0:	04 91       	mov	r1,r2
80006ec2:	50 89       	stdsp	sp[0x20],r9
80006ec4:	50 a8       	stdsp	sp[0x28],r8
80006ec6:	50 2e       	stdsp	sp[0x8],lr
80006ec8:	50 39       	stdsp	sp[0xc],r9
80006eca:	12 95       	mov	r5,r9
80006ecc:	12 90       	mov	r0,r9
80006ece:	10 97       	mov	r7,r8
80006ed0:	08 92       	mov	r2,r4
80006ed2:	c0 78       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
80006ed4:	3f fc       	mov	r12,-1
80006ed6:	08 97       	mov	r7,r4
80006ed8:	50 2c       	stdsp	sp[0x8],r12
80006eda:	c0 38       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
80006edc:	30 0b       	mov	r11,0
80006ede:	50 3b       	stdsp	sp[0xc],r11
80006ee0:	0f 38       	ld.ub	r8,r7++
80006ee2:	c0 28       	rjmp	80006ee6 <_vfprintf_r+0x1c6>
80006ee4:	12 90       	mov	r0,r9
80006ee6:	f0 c9 00 20 	sub	r9,r8,32
80006eea:	e0 49 00 58 	cp.w	r9,88
80006eee:	e0 8b 0a 30 	brhi	8000834e <_vfprintf_r+0x162e>
80006ef2:	fe ca a6 02 	sub	r10,pc,-23038
80006ef6:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
80006efa:	50 a7       	stdsp	sp[0x28],r7
80006efc:	50 80       	stdsp	sp[0x20],r0
80006efe:	0c 97       	mov	r7,r6
80006f00:	04 94       	mov	r4,r2
80006f02:	06 96       	mov	r6,r3
80006f04:	02 92       	mov	r2,r1
80006f06:	fe c9 a3 da 	sub	r9,pc,-23590
80006f0a:	40 93       	lddsp	r3,sp[0x24]
80006f0c:	10 90       	mov	r0,r8
80006f0e:	40 41       	lddsp	r1,sp[0x10]
80006f10:	50 d9       	stdsp	sp[0x34],r9
80006f12:	e0 8f 08 8e 	bral	8000802e <_vfprintf_r+0x130e>
80006f16:	30 08       	mov	r8,0
80006f18:	fb 39 06 bb 	ld.ub	r9,sp[1723]
80006f1c:	f0 09 18 00 	cp.b	r9,r8
80006f20:	ce 01       	brne	80006ee0 <_vfprintf_r+0x1c0>
80006f22:	32 08       	mov	r8,32
80006f24:	c6 e8       	rjmp	80007000 <_vfprintf_r+0x2e0>
80006f26:	a1 a5       	sbr	r5,0x0
80006f28:	cd cb       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
80006f2a:	0f 89       	ld.ub	r9,r7[0x0]
80006f2c:	f2 c8 00 30 	sub	r8,r9,48
80006f30:	58 98       	cp.w	r8,9
80006f32:	e0 8b 00 1d 	brhi	80006f6c <_vfprintf_r+0x24c>
80006f36:	ee c8 ff ff 	sub	r8,r7,-1
80006f3a:	30 0b       	mov	r11,0
80006f3c:	23 09       	sub	r9,48
80006f3e:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
80006f42:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
80006f46:	11 39       	ld.ub	r9,r8++
80006f48:	f2 ca 00 30 	sub	r10,r9,48
80006f4c:	58 9a       	cp.w	r10,9
80006f4e:	fe 98 ff f7 	brls	80006f3c <_vfprintf_r+0x21c>
80006f52:	e0 49 00 24 	cp.w	r9,36
80006f56:	cc 31       	brne	80006edc <_vfprintf_r+0x1bc>
80006f58:	e0 4b 00 20 	cp.w	r11,32
80006f5c:	e0 89 0e 60 	brgt	80008c1c <_vfprintf_r+0x1efc>
80006f60:	20 1b       	sub	r11,1
80006f62:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006f66:	12 3b       	cp.w	r11,r9
80006f68:	c0 95       	brlt	80006f7a <_vfprintf_r+0x25a>
80006f6a:	c1 08       	rjmp	80006f8a <_vfprintf_r+0x26a>
80006f6c:	fa f9 06 b4 	ld.w	r9,sp[1716]
80006f70:	ec ca ff ff 	sub	r10,r6,-1
80006f74:	12 36       	cp.w	r6,r9
80006f76:	c1 f5       	brlt	80006fb4 <_vfprintf_r+0x294>
80006f78:	c2 68       	rjmp	80006fc4 <_vfprintf_r+0x2a4>
80006f7a:	fa ce f9 44 	sub	lr,sp,-1724
80006f7e:	10 97       	mov	r7,r8
80006f80:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
80006f84:	f6 f0 fd 88 	ld.w	r0,r11[-632]
80006f88:	c3 58       	rjmp	80006ff2 <_vfprintf_r+0x2d2>
80006f8a:	10 97       	mov	r7,r8
80006f8c:	fa c8 f9 50 	sub	r8,sp,-1712
80006f90:	1a d8       	st.w	--sp,r8
80006f92:	fa c8 fa b8 	sub	r8,sp,-1352
80006f96:	1a d8       	st.w	--sp,r8
80006f98:	fa c8 fb b4 	sub	r8,sp,-1100
80006f9c:	02 9a       	mov	r10,r1
80006f9e:	1a d8       	st.w	--sp,r8
80006fa0:	04 9c       	mov	r12,r2
80006fa2:	fa c8 f9 40 	sub	r8,sp,-1728
80006fa6:	fa c9 ff b4 	sub	r9,sp,-76
80006faa:	fe b0 fd 23 	rcall	800069f0 <get_arg>
80006fae:	2f dd       	sub	sp,-12
80006fb0:	78 00       	ld.w	r0,r12[0x0]
80006fb2:	c2 08       	rjmp	80006ff2 <_vfprintf_r+0x2d2>
80006fb4:	fa cc f9 44 	sub	r12,sp,-1724
80006fb8:	14 96       	mov	r6,r10
80006fba:	f8 03 00 38 	add	r8,r12,r3<<0x3
80006fbe:	f0 f0 fd 88 	ld.w	r0,r8[-632]
80006fc2:	c1 88       	rjmp	80006ff2 <_vfprintf_r+0x2d2>
80006fc4:	41 08       	lddsp	r8,sp[0x40]
80006fc6:	59 f9       	cp.w	r9,31
80006fc8:	e0 89 00 11 	brgt	80006fea <_vfprintf_r+0x2ca>
80006fcc:	f0 cb ff fc 	sub	r11,r8,-4
80006fd0:	51 0b       	stdsp	sp[0x40],r11
80006fd2:	70 00       	ld.w	r0,r8[0x0]
80006fd4:	fa cb f9 44 	sub	r11,sp,-1724
80006fd8:	f6 09 00 38 	add	r8,r11,r9<<0x3
80006fdc:	f1 40 fd 88 	st.w	r8[-632],r0
80006fe0:	2f f9       	sub	r9,-1
80006fe2:	14 96       	mov	r6,r10
80006fe4:	fb 49 06 b4 	st.w	sp[1716],r9
80006fe8:	c0 58       	rjmp	80006ff2 <_vfprintf_r+0x2d2>
80006fea:	70 00       	ld.w	r0,r8[0x0]
80006fec:	14 96       	mov	r6,r10
80006fee:	2f c8       	sub	r8,-4
80006ff0:	51 08       	stdsp	sp[0x40],r8
80006ff2:	58 00       	cp.w	r0,0
80006ff4:	fe 94 ff 76 	brge	80006ee0 <_vfprintf_r+0x1c0>
80006ff8:	5c 30       	neg	r0
80006ffa:	a3 a5       	sbr	r5,0x2
80006ffc:	c7 2b       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
80006ffe:	32 b8       	mov	r8,43
80007000:	fb 68 06 bb 	st.b	sp[1723],r8
80007004:	c6 eb       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
80007006:	0f 38       	ld.ub	r8,r7++
80007008:	e0 48 00 2a 	cp.w	r8,42
8000700c:	c0 30       	breq	80007012 <_vfprintf_r+0x2f2>
8000700e:	30 09       	mov	r9,0
80007010:	c7 98       	rjmp	80007102 <_vfprintf_r+0x3e2>
80007012:	0f 88       	ld.ub	r8,r7[0x0]
80007014:	f0 c9 00 30 	sub	r9,r8,48
80007018:	58 99       	cp.w	r9,9
8000701a:	e0 8b 00 1f 	brhi	80007058 <_vfprintf_r+0x338>
8000701e:	ee c4 ff ff 	sub	r4,r7,-1
80007022:	30 0b       	mov	r11,0
80007024:	23 08       	sub	r8,48
80007026:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000702a:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000702e:	09 38       	ld.ub	r8,r4++
80007030:	f0 c9 00 30 	sub	r9,r8,48
80007034:	58 99       	cp.w	r9,9
80007036:	fe 98 ff f7 	brls	80007024 <_vfprintf_r+0x304>
8000703a:	e0 48 00 24 	cp.w	r8,36
8000703e:	fe 91 ff 4f 	brne	80006edc <_vfprintf_r+0x1bc>
80007042:	e0 4b 00 20 	cp.w	r11,32
80007046:	e0 89 0d eb 	brgt	80008c1c <_vfprintf_r+0x1efc>
8000704a:	20 1b       	sub	r11,1
8000704c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007050:	10 3b       	cp.w	r11,r8
80007052:	c0 a5       	brlt	80007066 <_vfprintf_r+0x346>
80007054:	c1 18       	rjmp	80007076 <_vfprintf_r+0x356>
80007056:	d7 03       	nop
80007058:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000705c:	ec c9 ff ff 	sub	r9,r6,-1
80007060:	14 36       	cp.w	r6,r10
80007062:	c1 f5       	brlt	800070a0 <_vfprintf_r+0x380>
80007064:	c2 88       	rjmp	800070b4 <_vfprintf_r+0x394>
80007066:	fa ca f9 44 	sub	r10,sp,-1724
8000706a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000706e:	f6 fb fd 88 	ld.w	r11,r11[-632]
80007072:	50 2b       	stdsp	sp[0x8],r11
80007074:	c3 c8       	rjmp	800070ec <_vfprintf_r+0x3cc>
80007076:	fa c8 f9 50 	sub	r8,sp,-1712
8000707a:	1a d8       	st.w	--sp,r8
8000707c:	fa c8 fa b8 	sub	r8,sp,-1352
80007080:	1a d8       	st.w	--sp,r8
80007082:	fa c8 fb b4 	sub	r8,sp,-1100
80007086:	02 9a       	mov	r10,r1
80007088:	1a d8       	st.w	--sp,r8
8000708a:	04 9c       	mov	r12,r2
8000708c:	fa c8 f9 40 	sub	r8,sp,-1728
80007090:	fa c9 ff b4 	sub	r9,sp,-76
80007094:	fe b0 fc ae 	rcall	800069f0 <get_arg>
80007098:	2f dd       	sub	sp,-12
8000709a:	78 0c       	ld.w	r12,r12[0x0]
8000709c:	50 2c       	stdsp	sp[0x8],r12
8000709e:	c2 78       	rjmp	800070ec <_vfprintf_r+0x3cc>
800070a0:	12 96       	mov	r6,r9
800070a2:	0e 94       	mov	r4,r7
800070a4:	fa c9 f9 44 	sub	r9,sp,-1724
800070a8:	f2 03 00 38 	add	r8,r9,r3<<0x3
800070ac:	f0 f8 fd 88 	ld.w	r8,r8[-632]
800070b0:	50 28       	stdsp	sp[0x8],r8
800070b2:	c1 d8       	rjmp	800070ec <_vfprintf_r+0x3cc>
800070b4:	41 08       	lddsp	r8,sp[0x40]
800070b6:	59 fa       	cp.w	r10,31
800070b8:	e0 89 00 14 	brgt	800070e0 <_vfprintf_r+0x3c0>
800070bc:	f0 cb ff fc 	sub	r11,r8,-4
800070c0:	70 08       	ld.w	r8,r8[0x0]
800070c2:	51 0b       	stdsp	sp[0x40],r11
800070c4:	50 28       	stdsp	sp[0x8],r8
800070c6:	fa c6 f9 44 	sub	r6,sp,-1724
800070ca:	40 2e       	lddsp	lr,sp[0x8]
800070cc:	ec 0a 00 38 	add	r8,r6,r10<<0x3
800070d0:	f1 4e fd 88 	st.w	r8[-632],lr
800070d4:	2f fa       	sub	r10,-1
800070d6:	0e 94       	mov	r4,r7
800070d8:	fb 4a 06 b4 	st.w	sp[1716],r10
800070dc:	12 96       	mov	r6,r9
800070de:	c0 78       	rjmp	800070ec <_vfprintf_r+0x3cc>
800070e0:	70 0c       	ld.w	r12,r8[0x0]
800070e2:	0e 94       	mov	r4,r7
800070e4:	2f c8       	sub	r8,-4
800070e6:	50 2c       	stdsp	sp[0x8],r12
800070e8:	12 96       	mov	r6,r9
800070ea:	51 08       	stdsp	sp[0x40],r8
800070ec:	40 2b       	lddsp	r11,sp[0x8]
800070ee:	58 0b       	cp.w	r11,0
800070f0:	fe 95 fe f2 	brlt	80006ed4 <_vfprintf_r+0x1b4>
800070f4:	08 97       	mov	r7,r4
800070f6:	cf 5a       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
800070f8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800070fc:	0f 38       	ld.ub	r8,r7++
800070fe:	f4 09 00 19 	add	r9,r10,r9<<0x1
80007102:	f0 ca 00 30 	sub	r10,r8,48
80007106:	58 9a       	cp.w	r10,9
80007108:	fe 98 ff f8 	brls	800070f8 <_vfprintf_r+0x3d8>
8000710c:	3f fa       	mov	r10,-1
8000710e:	f2 0a 0c 49 	max	r9,r9,r10
80007112:	50 29       	stdsp	sp[0x8],r9
80007114:	ce 9a       	rjmp	80006ee6 <_vfprintf_r+0x1c6>
80007116:	a7 b5       	sbr	r5,0x7
80007118:	ce 4a       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
8000711a:	30 09       	mov	r9,0
8000711c:	23 08       	sub	r8,48
8000711e:	f2 09 00 29 	add	r9,r9,r9<<0x2
80007122:	f0 09 00 19 	add	r9,r8,r9<<0x1
80007126:	0f 38       	ld.ub	r8,r7++
80007128:	f0 ca 00 30 	sub	r10,r8,48
8000712c:	58 9a       	cp.w	r10,9
8000712e:	fe 98 ff f7 	brls	8000711c <_vfprintf_r+0x3fc>
80007132:	e0 48 00 24 	cp.w	r8,36
80007136:	fe 91 fe d7 	brne	80006ee4 <_vfprintf_r+0x1c4>
8000713a:	e0 49 00 20 	cp.w	r9,32
8000713e:	e0 89 0d 6f 	brgt	80008c1c <_vfprintf_r+0x1efc>
80007142:	f2 c3 00 01 	sub	r3,r9,1
80007146:	30 19       	mov	r9,1
80007148:	50 39       	stdsp	sp[0xc],r9
8000714a:	cc ba       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
8000714c:	a3 b5       	sbr	r5,0x3
8000714e:	cc 9a       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
80007150:	a7 a5       	sbr	r5,0x6
80007152:	cc 7a       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
80007154:	0a 98       	mov	r8,r5
80007156:	a5 b5       	sbr	r5,0x5
80007158:	a5 a8       	sbr	r8,0x4
8000715a:	0f 89       	ld.ub	r9,r7[0x0]
8000715c:	36 ce       	mov	lr,108
8000715e:	fc 09 18 00 	cp.b	r9,lr
80007162:	f7 b7 00 ff 	subeq	r7,-1
80007166:	f0 05 17 10 	movne	r5,r8
8000716a:	cb ba       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
8000716c:	a5 b5       	sbr	r5,0x5
8000716e:	cb 9a       	rjmp	80006ee0 <_vfprintf_r+0x1c0>
80007170:	50 a7       	stdsp	sp[0x28],r7
80007172:	50 80       	stdsp	sp[0x20],r0
80007174:	0c 97       	mov	r7,r6
80007176:	10 90       	mov	r0,r8
80007178:	06 96       	mov	r6,r3
8000717a:	04 94       	mov	r4,r2
8000717c:	40 93       	lddsp	r3,sp[0x24]
8000717e:	02 92       	mov	r2,r1
80007180:	0e 99       	mov	r9,r7
80007182:	40 41       	lddsp	r1,sp[0x10]
80007184:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007188:	40 3c       	lddsp	r12,sp[0xc]
8000718a:	58 0c       	cp.w	r12,0
8000718c:	c1 d0       	breq	800071c6 <_vfprintf_r+0x4a6>
8000718e:	10 36       	cp.w	r6,r8
80007190:	c0 64       	brge	8000719c <_vfprintf_r+0x47c>
80007192:	fa cb f9 44 	sub	r11,sp,-1724
80007196:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000719a:	c1 d8       	rjmp	800071d4 <_vfprintf_r+0x4b4>
8000719c:	fa c8 f9 50 	sub	r8,sp,-1712
800071a0:	1a d8       	st.w	--sp,r8
800071a2:	fa c8 fa b8 	sub	r8,sp,-1352
800071a6:	1a d8       	st.w	--sp,r8
800071a8:	fa c8 fb b4 	sub	r8,sp,-1100
800071ac:	1a d8       	st.w	--sp,r8
800071ae:	fa c8 f9 40 	sub	r8,sp,-1728
800071b2:	fa c9 ff b4 	sub	r9,sp,-76
800071b6:	04 9a       	mov	r10,r2
800071b8:	0c 9b       	mov	r11,r6
800071ba:	08 9c       	mov	r12,r4
800071bc:	fe b0 fc 1a 	rcall	800069f0 <get_arg>
800071c0:	2f dd       	sub	sp,-12
800071c2:	19 b8       	ld.ub	r8,r12[0x3]
800071c4:	c2 28       	rjmp	80007208 <_vfprintf_r+0x4e8>
800071c6:	2f f7       	sub	r7,-1
800071c8:	10 39       	cp.w	r9,r8
800071ca:	c0 84       	brge	800071da <_vfprintf_r+0x4ba>
800071cc:	fa ca f9 44 	sub	r10,sp,-1724
800071d0:	f4 06 00 36 	add	r6,r10,r6<<0x3
800071d4:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
800071d8:	c1 88       	rjmp	80007208 <_vfprintf_r+0x4e8>
800071da:	41 09       	lddsp	r9,sp[0x40]
800071dc:	59 f8       	cp.w	r8,31
800071de:	e0 89 00 12 	brgt	80007202 <_vfprintf_r+0x4e2>
800071e2:	f2 ca ff fc 	sub	r10,r9,-4
800071e6:	51 0a       	stdsp	sp[0x40],r10
800071e8:	72 09       	ld.w	r9,r9[0x0]
800071ea:	fa c6 f9 44 	sub	r6,sp,-1724
800071ee:	ec 08 00 3a 	add	r10,r6,r8<<0x3
800071f2:	2f f8       	sub	r8,-1
800071f4:	f5 49 fd 88 	st.w	r10[-632],r9
800071f8:	fb 48 06 b4 	st.w	sp[1716],r8
800071fc:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80007200:	c0 48       	rjmp	80007208 <_vfprintf_r+0x4e8>
80007202:	13 b8       	ld.ub	r8,r9[0x3]
80007204:	2f c9       	sub	r9,-4
80007206:	51 09       	stdsp	sp[0x40],r9
80007208:	fb 68 06 60 	st.b	sp[1632],r8
8000720c:	30 0e       	mov	lr,0
8000720e:	30 08       	mov	r8,0
80007210:	30 12       	mov	r2,1
80007212:	fb 68 06 bb 	st.b	sp[1723],r8
80007216:	50 2e       	stdsp	sp[0x8],lr
80007218:	e0 8f 08 ad 	bral	80008372 <_vfprintf_r+0x1652>
8000721c:	50 a7       	stdsp	sp[0x28],r7
8000721e:	50 80       	stdsp	sp[0x20],r0
80007220:	0c 97       	mov	r7,r6
80007222:	04 94       	mov	r4,r2
80007224:	06 96       	mov	r6,r3
80007226:	02 92       	mov	r2,r1
80007228:	40 93       	lddsp	r3,sp[0x24]
8000722a:	10 90       	mov	r0,r8
8000722c:	40 41       	lddsp	r1,sp[0x10]
8000722e:	a5 a5       	sbr	r5,0x4
80007230:	c0 a8       	rjmp	80007244 <_vfprintf_r+0x524>
80007232:	50 a7       	stdsp	sp[0x28],r7
80007234:	50 80       	stdsp	sp[0x20],r0
80007236:	0c 97       	mov	r7,r6
80007238:	04 94       	mov	r4,r2
8000723a:	06 96       	mov	r6,r3
8000723c:	02 92       	mov	r2,r1
8000723e:	40 93       	lddsp	r3,sp[0x24]
80007240:	10 90       	mov	r0,r8
80007242:	40 41       	lddsp	r1,sp[0x10]
80007244:	ed b5 00 05 	bld	r5,0x5
80007248:	c5 11       	brne	800072ea <_vfprintf_r+0x5ca>
8000724a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000724e:	40 3c       	lddsp	r12,sp[0xc]
80007250:	58 0c       	cp.w	r12,0
80007252:	c1 e0       	breq	8000728e <_vfprintf_r+0x56e>
80007254:	10 36       	cp.w	r6,r8
80007256:	c0 64       	brge	80007262 <_vfprintf_r+0x542>
80007258:	fa cb f9 44 	sub	r11,sp,-1724
8000725c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007260:	c2 08       	rjmp	800072a0 <_vfprintf_r+0x580>
80007262:	fa c8 f9 50 	sub	r8,sp,-1712
80007266:	1a d8       	st.w	--sp,r8
80007268:	fa c8 fa b8 	sub	r8,sp,-1352
8000726c:	0c 9b       	mov	r11,r6
8000726e:	1a d8       	st.w	--sp,r8
80007270:	fa c8 fb b4 	sub	r8,sp,-1100
80007274:	1a d8       	st.w	--sp,r8
80007276:	fa c9 ff b4 	sub	r9,sp,-76
8000727a:	fa c8 f9 40 	sub	r8,sp,-1728
8000727e:	04 9a       	mov	r10,r2
80007280:	08 9c       	mov	r12,r4
80007282:	fe b0 fb b7 	rcall	800069f0 <get_arg>
80007286:	2f dd       	sub	sp,-12
80007288:	78 1b       	ld.w	r11,r12[0x4]
8000728a:	78 09       	ld.w	r9,r12[0x0]
8000728c:	c2 b8       	rjmp	800072e2 <_vfprintf_r+0x5c2>
8000728e:	ee ca ff ff 	sub	r10,r7,-1
80007292:	10 37       	cp.w	r7,r8
80007294:	c0 b4       	brge	800072aa <_vfprintf_r+0x58a>
80007296:	fa c9 f9 44 	sub	r9,sp,-1724
8000729a:	14 97       	mov	r7,r10
8000729c:	f2 06 00 36 	add	r6,r9,r6<<0x3
800072a0:	ec fb fd 8c 	ld.w	r11,r6[-628]
800072a4:	ec f9 fd 88 	ld.w	r9,r6[-632]
800072a8:	c1 d8       	rjmp	800072e2 <_vfprintf_r+0x5c2>
800072aa:	41 09       	lddsp	r9,sp[0x40]
800072ac:	59 f8       	cp.w	r8,31
800072ae:	e0 89 00 14 	brgt	800072d6 <_vfprintf_r+0x5b6>
800072b2:	f2 cb ff f8 	sub	r11,r9,-8
800072b6:	51 0b       	stdsp	sp[0x40],r11
800072b8:	fa c6 f9 44 	sub	r6,sp,-1724
800072bc:	72 1b       	ld.w	r11,r9[0x4]
800072be:	ec 08 00 3c 	add	r12,r6,r8<<0x3
800072c2:	72 09       	ld.w	r9,r9[0x0]
800072c4:	f9 4b fd 8c 	st.w	r12[-628],r11
800072c8:	f9 49 fd 88 	st.w	r12[-632],r9
800072cc:	2f f8       	sub	r8,-1
800072ce:	14 97       	mov	r7,r10
800072d0:	fb 48 06 b4 	st.w	sp[1716],r8
800072d4:	c0 78       	rjmp	800072e2 <_vfprintf_r+0x5c2>
800072d6:	f2 c8 ff f8 	sub	r8,r9,-8
800072da:	72 1b       	ld.w	r11,r9[0x4]
800072dc:	14 97       	mov	r7,r10
800072de:	51 08       	stdsp	sp[0x40],r8
800072e0:	72 09       	ld.w	r9,r9[0x0]
800072e2:	16 98       	mov	r8,r11
800072e4:	fa e9 00 00 	st.d	sp[0],r8
800072e8:	ca e8       	rjmp	80007444 <_vfprintf_r+0x724>
800072ea:	ed b5 00 04 	bld	r5,0x4
800072ee:	c1 71       	brne	8000731c <_vfprintf_r+0x5fc>
800072f0:	fa f8 06 b4 	ld.w	r8,sp[1716]
800072f4:	40 3e       	lddsp	lr,sp[0xc]
800072f6:	58 0e       	cp.w	lr,0
800072f8:	c0 80       	breq	80007308 <_vfprintf_r+0x5e8>
800072fa:	10 36       	cp.w	r6,r8
800072fc:	c6 94       	brge	800073ce <_vfprintf_r+0x6ae>
800072fe:	fa cc f9 44 	sub	r12,sp,-1724
80007302:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007306:	c8 28       	rjmp	8000740a <_vfprintf_r+0x6ea>
80007308:	ee ca ff ff 	sub	r10,r7,-1
8000730c:	10 37       	cp.w	r7,r8
8000730e:	e0 84 00 81 	brge	80007410 <_vfprintf_r+0x6f0>
80007312:	fa cb f9 44 	sub	r11,sp,-1724
80007316:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000731a:	c7 78       	rjmp	80007408 <_vfprintf_r+0x6e8>
8000731c:	ed b5 00 06 	bld	r5,0x6
80007320:	c4 b1       	brne	800073b6 <_vfprintf_r+0x696>
80007322:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007326:	40 3c       	lddsp	r12,sp[0xc]
80007328:	58 0c       	cp.w	r12,0
8000732a:	c1 d0       	breq	80007364 <_vfprintf_r+0x644>
8000732c:	10 36       	cp.w	r6,r8
8000732e:	c0 64       	brge	8000733a <_vfprintf_r+0x61a>
80007330:	fa cb f9 44 	sub	r11,sp,-1724
80007334:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007338:	c1 f8       	rjmp	80007376 <_vfprintf_r+0x656>
8000733a:	fa c8 f9 50 	sub	r8,sp,-1712
8000733e:	1a d8       	st.w	--sp,r8
80007340:	fa c8 fa b8 	sub	r8,sp,-1352
80007344:	1a d8       	st.w	--sp,r8
80007346:	fa c8 fb b4 	sub	r8,sp,-1100
8000734a:	1a d8       	st.w	--sp,r8
8000734c:	fa c8 f9 40 	sub	r8,sp,-1728
80007350:	fa c9 ff b4 	sub	r9,sp,-76
80007354:	04 9a       	mov	r10,r2
80007356:	0c 9b       	mov	r11,r6
80007358:	08 9c       	mov	r12,r4
8000735a:	fe b0 fb 4b 	rcall	800069f0 <get_arg>
8000735e:	2f dd       	sub	sp,-12
80007360:	98 18       	ld.sh	r8,r12[0x2]
80007362:	c2 68       	rjmp	800073ae <_vfprintf_r+0x68e>
80007364:	ee ca ff ff 	sub	r10,r7,-1
80007368:	10 37       	cp.w	r7,r8
8000736a:	c0 94       	brge	8000737c <_vfprintf_r+0x65c>
8000736c:	fa c9 f9 44 	sub	r9,sp,-1724
80007370:	14 97       	mov	r7,r10
80007372:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007376:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000737a:	c1 a8       	rjmp	800073ae <_vfprintf_r+0x68e>
8000737c:	41 09       	lddsp	r9,sp[0x40]
8000737e:	59 f8       	cp.w	r8,31
80007380:	e0 89 00 13 	brgt	800073a6 <_vfprintf_r+0x686>
80007384:	f2 cb ff fc 	sub	r11,r9,-4
80007388:	51 0b       	stdsp	sp[0x40],r11
8000738a:	72 09       	ld.w	r9,r9[0x0]
8000738c:	fa c6 f9 44 	sub	r6,sp,-1724
80007390:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007394:	2f f8       	sub	r8,-1
80007396:	f7 49 fd 88 	st.w	r11[-632],r9
8000739a:	fb 48 06 b4 	st.w	sp[1716],r8
8000739e:	14 97       	mov	r7,r10
800073a0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
800073a4:	c0 58       	rjmp	800073ae <_vfprintf_r+0x68e>
800073a6:	92 18       	ld.sh	r8,r9[0x2]
800073a8:	14 97       	mov	r7,r10
800073aa:	2f c9       	sub	r9,-4
800073ac:	51 09       	stdsp	sp[0x40],r9
800073ae:	50 18       	stdsp	sp[0x4],r8
800073b0:	bf 58       	asr	r8,0x1f
800073b2:	50 08       	stdsp	sp[0x0],r8
800073b4:	c4 88       	rjmp	80007444 <_vfprintf_r+0x724>
800073b6:	fa f8 06 b4 	ld.w	r8,sp[1716]
800073ba:	40 3c       	lddsp	r12,sp[0xc]
800073bc:	58 0c       	cp.w	r12,0
800073be:	c1 d0       	breq	800073f8 <_vfprintf_r+0x6d8>
800073c0:	10 36       	cp.w	r6,r8
800073c2:	c0 64       	brge	800073ce <_vfprintf_r+0x6ae>
800073c4:	fa cb f9 44 	sub	r11,sp,-1724
800073c8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800073cc:	c1 f8       	rjmp	8000740a <_vfprintf_r+0x6ea>
800073ce:	fa c8 f9 50 	sub	r8,sp,-1712
800073d2:	1a d8       	st.w	--sp,r8
800073d4:	fa c8 fa b8 	sub	r8,sp,-1352
800073d8:	0c 9b       	mov	r11,r6
800073da:	1a d8       	st.w	--sp,r8
800073dc:	fa c8 fb b4 	sub	r8,sp,-1100
800073e0:	04 9a       	mov	r10,r2
800073e2:	1a d8       	st.w	--sp,r8
800073e4:	08 9c       	mov	r12,r4
800073e6:	fa c8 f9 40 	sub	r8,sp,-1728
800073ea:	fa c9 ff b4 	sub	r9,sp,-76
800073ee:	fe b0 fb 01 	rcall	800069f0 <get_arg>
800073f2:	2f dd       	sub	sp,-12
800073f4:	78 0b       	ld.w	r11,r12[0x0]
800073f6:	c2 48       	rjmp	8000743e <_vfprintf_r+0x71e>
800073f8:	ee ca ff ff 	sub	r10,r7,-1
800073fc:	10 37       	cp.w	r7,r8
800073fe:	c0 94       	brge	80007410 <_vfprintf_r+0x6f0>
80007400:	fa c9 f9 44 	sub	r9,sp,-1724
80007404:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007408:	14 97       	mov	r7,r10
8000740a:	ec fb fd 88 	ld.w	r11,r6[-632]
8000740e:	c1 88       	rjmp	8000743e <_vfprintf_r+0x71e>
80007410:	41 09       	lddsp	r9,sp[0x40]
80007412:	59 f8       	cp.w	r8,31
80007414:	e0 89 00 11 	brgt	80007436 <_vfprintf_r+0x716>
80007418:	f2 cb ff fc 	sub	r11,r9,-4
8000741c:	51 0b       	stdsp	sp[0x40],r11
8000741e:	fa c6 f9 44 	sub	r6,sp,-1724
80007422:	72 0b       	ld.w	r11,r9[0x0]
80007424:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007428:	f3 4b fd 88 	st.w	r9[-632],r11
8000742c:	2f f8       	sub	r8,-1
8000742e:	14 97       	mov	r7,r10
80007430:	fb 48 06 b4 	st.w	sp[1716],r8
80007434:	c0 58       	rjmp	8000743e <_vfprintf_r+0x71e>
80007436:	72 0b       	ld.w	r11,r9[0x0]
80007438:	14 97       	mov	r7,r10
8000743a:	2f c9       	sub	r9,-4
8000743c:	51 09       	stdsp	sp[0x40],r9
8000743e:	50 1b       	stdsp	sp[0x4],r11
80007440:	bf 5b       	asr	r11,0x1f
80007442:	50 0b       	stdsp	sp[0x0],r11
80007444:	fa ea 00 00 	ld.d	r10,sp[0]
80007448:	58 0a       	cp.w	r10,0
8000744a:	5c 2b       	cpc	r11
8000744c:	c0 e4       	brge	80007468 <_vfprintf_r+0x748>
8000744e:	30 08       	mov	r8,0
80007450:	fa ea 00 00 	ld.d	r10,sp[0]
80007454:	30 09       	mov	r9,0
80007456:	f0 0a 01 0a 	sub	r10,r8,r10
8000745a:	f2 0b 01 4b 	sbc	r11,r9,r11
8000745e:	32 d8       	mov	r8,45
80007460:	fa eb 00 00 	st.d	sp[0],r10
80007464:	fb 68 06 bb 	st.b	sp[1723],r8
80007468:	30 18       	mov	r8,1
8000746a:	e0 8f 06 fa 	bral	8000825e <_vfprintf_r+0x153e>
8000746e:	50 a7       	stdsp	sp[0x28],r7
80007470:	50 80       	stdsp	sp[0x20],r0
80007472:	0c 97       	mov	r7,r6
80007474:	04 94       	mov	r4,r2
80007476:	06 96       	mov	r6,r3
80007478:	02 92       	mov	r2,r1
8000747a:	40 93       	lddsp	r3,sp[0x24]
8000747c:	10 90       	mov	r0,r8
8000747e:	40 41       	lddsp	r1,sp[0x10]
80007480:	0e 99       	mov	r9,r7
80007482:	ed b5 00 03 	bld	r5,0x3
80007486:	c4 11       	brne	80007508 <_vfprintf_r+0x7e8>
80007488:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000748c:	40 3a       	lddsp	r10,sp[0xc]
8000748e:	58 0a       	cp.w	r10,0
80007490:	c1 90       	breq	800074c2 <_vfprintf_r+0x7a2>
80007492:	10 36       	cp.w	r6,r8
80007494:	c6 45       	brlt	8000755c <_vfprintf_r+0x83c>
80007496:	fa c8 f9 50 	sub	r8,sp,-1712
8000749a:	1a d8       	st.w	--sp,r8
8000749c:	fa c8 fa b8 	sub	r8,sp,-1352
800074a0:	1a d8       	st.w	--sp,r8
800074a2:	fa c8 fb b4 	sub	r8,sp,-1100
800074a6:	0c 9b       	mov	r11,r6
800074a8:	1a d8       	st.w	--sp,r8
800074aa:	04 9a       	mov	r10,r2
800074ac:	fa c8 f9 40 	sub	r8,sp,-1728
800074b0:	fa c9 ff b4 	sub	r9,sp,-76
800074b4:	08 9c       	mov	r12,r4
800074b6:	fe b0 fa 9d 	rcall	800069f0 <get_arg>
800074ba:	2f dd       	sub	sp,-12
800074bc:	78 16       	ld.w	r6,r12[0x4]
800074be:	50 76       	stdsp	sp[0x1c],r6
800074c0:	c4 88       	rjmp	80007550 <_vfprintf_r+0x830>
800074c2:	2f f7       	sub	r7,-1
800074c4:	10 39       	cp.w	r9,r8
800074c6:	c0 c4       	brge	800074de <_vfprintf_r+0x7be>
800074c8:	fa ce f9 44 	sub	lr,sp,-1724
800074cc:	fc 06 00 36 	add	r6,lr,r6<<0x3
800074d0:	ec fc fd 8c 	ld.w	r12,r6[-628]
800074d4:	50 7c       	stdsp	sp[0x1c],r12
800074d6:	ec f6 fd 88 	ld.w	r6,r6[-632]
800074da:	50 56       	stdsp	sp[0x14],r6
800074dc:	c6 68       	rjmp	800075a8 <_vfprintf_r+0x888>
800074de:	41 09       	lddsp	r9,sp[0x40]
800074e0:	59 f8       	cp.w	r8,31
800074e2:	e0 89 00 10 	brgt	80007502 <_vfprintf_r+0x7e2>
800074e6:	f2 ca ff f8 	sub	r10,r9,-8
800074ea:	72 1b       	ld.w	r11,r9[0x4]
800074ec:	51 0a       	stdsp	sp[0x40],r10
800074ee:	72 09       	ld.w	r9,r9[0x0]
800074f0:	fa ca f9 44 	sub	r10,sp,-1724
800074f4:	50 7b       	stdsp	sp[0x1c],r11
800074f6:	50 59       	stdsp	sp[0x14],r9
800074f8:	f4 08 00 39 	add	r9,r10,r8<<0x3
800074fc:	40 5b       	lddsp	r11,sp[0x14]
800074fe:	40 7a       	lddsp	r10,sp[0x1c]
80007500:	c4 78       	rjmp	8000758e <_vfprintf_r+0x86e>
80007502:	72 18       	ld.w	r8,r9[0x4]
80007504:	50 78       	stdsp	sp[0x1c],r8
80007506:	c4 c8       	rjmp	8000759e <_vfprintf_r+0x87e>
80007508:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000750c:	40 3e       	lddsp	lr,sp[0xc]
8000750e:	58 0e       	cp.w	lr,0
80007510:	c2 30       	breq	80007556 <_vfprintf_r+0x836>
80007512:	10 36       	cp.w	r6,r8
80007514:	c0 94       	brge	80007526 <_vfprintf_r+0x806>
80007516:	fa cc f9 44 	sub	r12,sp,-1724
8000751a:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000751e:	ec fb fd 8c 	ld.w	r11,r6[-628]
80007522:	50 7b       	stdsp	sp[0x1c],r11
80007524:	cd 9b       	rjmp	800074d6 <_vfprintf_r+0x7b6>
80007526:	fa c8 f9 50 	sub	r8,sp,-1712
8000752a:	1a d8       	st.w	--sp,r8
8000752c:	fa c8 fa b8 	sub	r8,sp,-1352
80007530:	04 9a       	mov	r10,r2
80007532:	1a d8       	st.w	--sp,r8
80007534:	fa c8 fb b4 	sub	r8,sp,-1100
80007538:	0c 9b       	mov	r11,r6
8000753a:	1a d8       	st.w	--sp,r8
8000753c:	08 9c       	mov	r12,r4
8000753e:	fa c8 f9 40 	sub	r8,sp,-1728
80007542:	fa c9 ff b4 	sub	r9,sp,-76
80007546:	fe b0 fa 55 	rcall	800069f0 <get_arg>
8000754a:	2f dd       	sub	sp,-12
8000754c:	78 1a       	ld.w	r10,r12[0x4]
8000754e:	50 7a       	stdsp	sp[0x1c],r10
80007550:	78 0c       	ld.w	r12,r12[0x0]
80007552:	50 5c       	stdsp	sp[0x14],r12
80007554:	c2 a8       	rjmp	800075a8 <_vfprintf_r+0x888>
80007556:	2f f7       	sub	r7,-1
80007558:	10 39       	cp.w	r9,r8
8000755a:	c0 94       	brge	8000756c <_vfprintf_r+0x84c>
8000755c:	fa c9 f9 44 	sub	r9,sp,-1724
80007560:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007564:	ec f8 fd 8c 	ld.w	r8,r6[-628]
80007568:	50 78       	stdsp	sp[0x1c],r8
8000756a:	cb 6b       	rjmp	800074d6 <_vfprintf_r+0x7b6>
8000756c:	41 09       	lddsp	r9,sp[0x40]
8000756e:	59 f8       	cp.w	r8,31
80007570:	e0 89 00 15 	brgt	8000759a <_vfprintf_r+0x87a>
80007574:	f2 ca ff f8 	sub	r10,r9,-8
80007578:	72 16       	ld.w	r6,r9[0x4]
8000757a:	72 09       	ld.w	r9,r9[0x0]
8000757c:	51 0a       	stdsp	sp[0x40],r10
8000757e:	50 59       	stdsp	sp[0x14],r9
80007580:	fa ce f9 44 	sub	lr,sp,-1724
80007584:	50 76       	stdsp	sp[0x1c],r6
80007586:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000758a:	40 5b       	lddsp	r11,sp[0x14]
8000758c:	0c 9a       	mov	r10,r6
8000758e:	f2 eb fd 88 	st.d	r9[-632],r10
80007592:	2f f8       	sub	r8,-1
80007594:	fb 48 06 b4 	st.w	sp[1716],r8
80007598:	c0 88       	rjmp	800075a8 <_vfprintf_r+0x888>
8000759a:	72 1c       	ld.w	r12,r9[0x4]
8000759c:	50 7c       	stdsp	sp[0x1c],r12
8000759e:	f2 c8 ff f8 	sub	r8,r9,-8
800075a2:	51 08       	stdsp	sp[0x40],r8
800075a4:	72 09       	ld.w	r9,r9[0x0]
800075a6:	50 59       	stdsp	sp[0x14],r9
800075a8:	40 5b       	lddsp	r11,sp[0x14]
800075aa:	40 7a       	lddsp	r10,sp[0x1c]
800075ac:	e0 a0 19 54 	rcall	8000a854 <__isinfd>
800075b0:	18 96       	mov	r6,r12
800075b2:	c1 70       	breq	800075e0 <_vfprintf_r+0x8c0>
800075b4:	30 08       	mov	r8,0
800075b6:	30 09       	mov	r9,0
800075b8:	40 5b       	lddsp	r11,sp[0x14]
800075ba:	40 7a       	lddsp	r10,sp[0x1c]
800075bc:	e0 a0 1d b4 	rcall	8000b124 <__avr32_f64_cmp_lt>
800075c0:	c0 40       	breq	800075c8 <_vfprintf_r+0x8a8>
800075c2:	32 d8       	mov	r8,45
800075c4:	fb 68 06 bb 	st.b	sp[1723],r8
800075c8:	fe c8 aa 88 	sub	r8,pc,-21880
800075cc:	fe c6 aa 88 	sub	r6,pc,-21880
800075d0:	a7 d5       	cbr	r5,0x7
800075d2:	e0 40 00 47 	cp.w	r0,71
800075d6:	f0 06 17 a0 	movle	r6,r8
800075da:	30 32       	mov	r2,3
800075dc:	e0 8f 06 ce 	bral	80008378 <_vfprintf_r+0x1658>
800075e0:	40 5b       	lddsp	r11,sp[0x14]
800075e2:	40 7a       	lddsp	r10,sp[0x1c]
800075e4:	e0 a0 19 4d 	rcall	8000a87e <__isnand>
800075e8:	c0 e0       	breq	80007604 <_vfprintf_r+0x8e4>
800075ea:	50 26       	stdsp	sp[0x8],r6
800075ec:	fe c8 aa a4 	sub	r8,pc,-21852
800075f0:	fe c6 aa a4 	sub	r6,pc,-21852
800075f4:	a7 d5       	cbr	r5,0x7
800075f6:	e0 40 00 47 	cp.w	r0,71
800075fa:	f0 06 17 a0 	movle	r6,r8
800075fe:	30 32       	mov	r2,3
80007600:	e0 8f 06 c2 	bral	80008384 <_vfprintf_r+0x1664>
80007604:	40 2a       	lddsp	r10,sp[0x8]
80007606:	5b fa       	cp.w	r10,-1
80007608:	c0 41       	brne	80007610 <_vfprintf_r+0x8f0>
8000760a:	30 69       	mov	r9,6
8000760c:	50 29       	stdsp	sp[0x8],r9
8000760e:	c1 18       	rjmp	80007630 <_vfprintf_r+0x910>
80007610:	e0 40 00 47 	cp.w	r0,71
80007614:	5f 09       	sreq	r9
80007616:	e0 40 00 67 	cp.w	r0,103
8000761a:	5f 08       	sreq	r8
8000761c:	f3 e8 10 08 	or	r8,r9,r8
80007620:	f8 08 18 00 	cp.b	r8,r12
80007624:	c0 60       	breq	80007630 <_vfprintf_r+0x910>
80007626:	40 28       	lddsp	r8,sp[0x8]
80007628:	58 08       	cp.w	r8,0
8000762a:	f9 b8 00 01 	moveq	r8,1
8000762e:	50 28       	stdsp	sp[0x8],r8
80007630:	40 78       	lddsp	r8,sp[0x1c]
80007632:	40 59       	lddsp	r9,sp[0x14]
80007634:	fa e9 06 94 	st.d	sp[1684],r8
80007638:	a9 a5       	sbr	r5,0x8
8000763a:	fa f8 06 94 	ld.w	r8,sp[1684]
8000763e:	58 08       	cp.w	r8,0
80007640:	c0 65       	brlt	8000764c <_vfprintf_r+0x92c>
80007642:	40 5e       	lddsp	lr,sp[0x14]
80007644:	30 0c       	mov	r12,0
80007646:	50 6e       	stdsp	sp[0x18],lr
80007648:	50 9c       	stdsp	sp[0x24],r12
8000764a:	c0 78       	rjmp	80007658 <_vfprintf_r+0x938>
8000764c:	40 5b       	lddsp	r11,sp[0x14]
8000764e:	32 da       	mov	r10,45
80007650:	ee 1b 80 00 	eorh	r11,0x8000
80007654:	50 9a       	stdsp	sp[0x24],r10
80007656:	50 6b       	stdsp	sp[0x18],r11
80007658:	e0 40 00 46 	cp.w	r0,70
8000765c:	5f 09       	sreq	r9
8000765e:	e0 40 00 66 	cp.w	r0,102
80007662:	5f 08       	sreq	r8
80007664:	f3 e8 10 08 	or	r8,r9,r8
80007668:	50 48       	stdsp	sp[0x10],r8
8000766a:	c0 40       	breq	80007672 <_vfprintf_r+0x952>
8000766c:	40 22       	lddsp	r2,sp[0x8]
8000766e:	30 39       	mov	r9,3
80007670:	c1 08       	rjmp	80007690 <_vfprintf_r+0x970>
80007672:	e0 40 00 45 	cp.w	r0,69
80007676:	5f 09       	sreq	r9
80007678:	e0 40 00 65 	cp.w	r0,101
8000767c:	5f 08       	sreq	r8
8000767e:	40 22       	lddsp	r2,sp[0x8]
80007680:	10 49       	or	r9,r8
80007682:	2f f2       	sub	r2,-1
80007684:	40 46       	lddsp	r6,sp[0x10]
80007686:	ec 09 18 00 	cp.b	r9,r6
8000768a:	fb f2 00 02 	ld.weq	r2,sp[0x8]
8000768e:	30 29       	mov	r9,2
80007690:	fa c8 f9 5c 	sub	r8,sp,-1700
80007694:	1a d8       	st.w	--sp,r8
80007696:	fa c8 f9 54 	sub	r8,sp,-1708
8000769a:	1a d8       	st.w	--sp,r8
8000769c:	fa c8 f9 4c 	sub	r8,sp,-1716
800076a0:	08 9c       	mov	r12,r4
800076a2:	1a d8       	st.w	--sp,r8
800076a4:	04 98       	mov	r8,r2
800076a6:	40 9b       	lddsp	r11,sp[0x24]
800076a8:	40 aa       	lddsp	r10,sp[0x28]
800076aa:	e0 a0 0b c3 	rcall	80008e30 <_dtoa_r>
800076ae:	e0 40 00 47 	cp.w	r0,71
800076b2:	5f 19       	srne	r9
800076b4:	e0 40 00 67 	cp.w	r0,103
800076b8:	5f 18       	srne	r8
800076ba:	18 96       	mov	r6,r12
800076bc:	2f dd       	sub	sp,-12
800076be:	f3 e8 00 08 	and	r8,r9,r8
800076c2:	c0 41       	brne	800076ca <_vfprintf_r+0x9aa>
800076c4:	ed b5 00 00 	bld	r5,0x0
800076c8:	c3 01       	brne	80007728 <_vfprintf_r+0xa08>
800076ca:	ec 02 00 0e 	add	lr,r6,r2
800076ce:	50 3e       	stdsp	sp[0xc],lr
800076d0:	40 4c       	lddsp	r12,sp[0x10]
800076d2:	58 0c       	cp.w	r12,0
800076d4:	c1 50       	breq	800076fe <_vfprintf_r+0x9de>
800076d6:	0d 89       	ld.ub	r9,r6[0x0]
800076d8:	33 08       	mov	r8,48
800076da:	f0 09 18 00 	cp.b	r9,r8
800076de:	c0 b1       	brne	800076f4 <_vfprintf_r+0x9d4>
800076e0:	30 08       	mov	r8,0
800076e2:	30 09       	mov	r9,0
800076e4:	40 6b       	lddsp	r11,sp[0x18]
800076e6:	40 7a       	lddsp	r10,sp[0x1c]
800076e8:	e0 a0 1c d7 	rcall	8000b096 <__avr32_f64_cmp_eq>
800076ec:	fb b2 00 01 	rsubeq	r2,1
800076f0:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
800076f4:	40 3b       	lddsp	r11,sp[0xc]
800076f6:	fa f8 06 ac 	ld.w	r8,sp[1708]
800076fa:	10 0b       	add	r11,r8
800076fc:	50 3b       	stdsp	sp[0xc],r11
800076fe:	40 6b       	lddsp	r11,sp[0x18]
80007700:	30 08       	mov	r8,0
80007702:	30 09       	mov	r9,0
80007704:	40 7a       	lddsp	r10,sp[0x1c]
80007706:	e0 a0 1c c8 	rcall	8000b096 <__avr32_f64_cmp_eq>
8000770a:	c0 90       	breq	8000771c <_vfprintf_r+0x9fc>
8000770c:	40 3a       	lddsp	r10,sp[0xc]
8000770e:	fb 4a 06 a4 	st.w	sp[1700],r10
80007712:	c0 58       	rjmp	8000771c <_vfprintf_r+0x9fc>
80007714:	10 c9       	st.b	r8++,r9
80007716:	fb 48 06 a4 	st.w	sp[1700],r8
8000771a:	c0 28       	rjmp	8000771e <_vfprintf_r+0x9fe>
8000771c:	33 09       	mov	r9,48
8000771e:	fa f8 06 a4 	ld.w	r8,sp[1700]
80007722:	40 3e       	lddsp	lr,sp[0xc]
80007724:	1c 38       	cp.w	r8,lr
80007726:	cf 73       	brcs	80007714 <_vfprintf_r+0x9f4>
80007728:	e0 40 00 47 	cp.w	r0,71
8000772c:	5f 09       	sreq	r9
8000772e:	e0 40 00 67 	cp.w	r0,103
80007732:	5f 08       	sreq	r8
80007734:	f3 e8 10 08 	or	r8,r9,r8
80007738:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000773c:	0c 19       	sub	r9,r6
8000773e:	50 69       	stdsp	sp[0x18],r9
80007740:	58 08       	cp.w	r8,0
80007742:	c0 b0       	breq	80007758 <_vfprintf_r+0xa38>
80007744:	fa f8 06 ac 	ld.w	r8,sp[1708]
80007748:	5b d8       	cp.w	r8,-3
8000774a:	c0 55       	brlt	80007754 <_vfprintf_r+0xa34>
8000774c:	40 2c       	lddsp	r12,sp[0x8]
8000774e:	18 38       	cp.w	r8,r12
80007750:	e0 8a 00 6a 	brle	80007824 <_vfprintf_r+0xb04>
80007754:	20 20       	sub	r0,2
80007756:	c0 58       	rjmp	80007760 <_vfprintf_r+0xa40>
80007758:	e0 40 00 65 	cp.w	r0,101
8000775c:	e0 89 00 46 	brgt	800077e8 <_vfprintf_r+0xac8>
80007760:	fa fb 06 ac 	ld.w	r11,sp[1708]
80007764:	fb 60 06 9c 	st.b	sp[1692],r0
80007768:	20 1b       	sub	r11,1
8000776a:	fb 4b 06 ac 	st.w	sp[1708],r11
8000776e:	c0 47       	brpl	80007776 <_vfprintf_r+0xa56>
80007770:	5c 3b       	neg	r11
80007772:	32 d8       	mov	r8,45
80007774:	c0 28       	rjmp	80007778 <_vfprintf_r+0xa58>
80007776:	32 b8       	mov	r8,43
80007778:	fb 68 06 9d 	st.b	sp[1693],r8
8000777c:	58 9b       	cp.w	r11,9
8000777e:	e0 8a 00 1d 	brle	800077b8 <_vfprintf_r+0xa98>
80007782:	fa c9 fa 35 	sub	r9,sp,-1483
80007786:	30 aa       	mov	r10,10
80007788:	12 98       	mov	r8,r9
8000778a:	0e 9c       	mov	r12,r7
8000778c:	0c 92       	mov	r2,r6
8000778e:	f6 0a 0c 06 	divs	r6,r11,r10
80007792:	0e 9b       	mov	r11,r7
80007794:	2d 0b       	sub	r11,-48
80007796:	10 fb       	st.b	--r8,r11
80007798:	0c 9b       	mov	r11,r6
8000779a:	58 96       	cp.w	r6,9
8000779c:	fe 99 ff f9 	brgt	8000778e <_vfprintf_r+0xa6e>
800077a0:	2d 0b       	sub	r11,-48
800077a2:	18 97       	mov	r7,r12
800077a4:	04 96       	mov	r6,r2
800077a6:	10 fb       	st.b	--r8,r11
800077a8:	fa ca f9 62 	sub	r10,sp,-1694
800077ac:	c0 38       	rjmp	800077b2 <_vfprintf_r+0xa92>
800077ae:	11 3b       	ld.ub	r11,r8++
800077b0:	14 cb       	st.b	r10++,r11
800077b2:	12 38       	cp.w	r8,r9
800077b4:	cf d3       	brcs	800077ae <_vfprintf_r+0xa8e>
800077b6:	c0 98       	rjmp	800077c8 <_vfprintf_r+0xaa8>
800077b8:	2d 0b       	sub	r11,-48
800077ba:	33 08       	mov	r8,48
800077bc:	fb 6b 06 9f 	st.b	sp[1695],r11
800077c0:	fb 68 06 9e 	st.b	sp[1694],r8
800077c4:	fa ca f9 60 	sub	r10,sp,-1696
800077c8:	fa c8 f9 64 	sub	r8,sp,-1692
800077cc:	f4 08 01 08 	sub	r8,r10,r8
800077d0:	50 e8       	stdsp	sp[0x38],r8
800077d2:	10 92       	mov	r2,r8
800077d4:	40 6b       	lddsp	r11,sp[0x18]
800077d6:	16 02       	add	r2,r11
800077d8:	58 1b       	cp.w	r11,1
800077da:	e0 89 00 05 	brgt	800077e4 <_vfprintf_r+0xac4>
800077de:	ed b5 00 00 	bld	r5,0x0
800077e2:	c3 51       	brne	8000784c <_vfprintf_r+0xb2c>
800077e4:	2f f2       	sub	r2,-1
800077e6:	c3 38       	rjmp	8000784c <_vfprintf_r+0xb2c>
800077e8:	e0 40 00 66 	cp.w	r0,102
800077ec:	c1 c1       	brne	80007824 <_vfprintf_r+0xb04>
800077ee:	fa f2 06 ac 	ld.w	r2,sp[1708]
800077f2:	58 02       	cp.w	r2,0
800077f4:	e0 8a 00 0c 	brle	8000780c <_vfprintf_r+0xaec>
800077f8:	40 2a       	lddsp	r10,sp[0x8]
800077fa:	58 0a       	cp.w	r10,0
800077fc:	c0 41       	brne	80007804 <_vfprintf_r+0xae4>
800077fe:	ed b5 00 00 	bld	r5,0x0
80007802:	c2 51       	brne	8000784c <_vfprintf_r+0xb2c>
80007804:	2f f2       	sub	r2,-1
80007806:	40 29       	lddsp	r9,sp[0x8]
80007808:	12 02       	add	r2,r9
8000780a:	c0 b8       	rjmp	80007820 <_vfprintf_r+0xb00>
8000780c:	40 28       	lddsp	r8,sp[0x8]
8000780e:	58 08       	cp.w	r8,0
80007810:	c0 61       	brne	8000781c <_vfprintf_r+0xafc>
80007812:	ed b5 00 00 	bld	r5,0x0
80007816:	c0 30       	breq	8000781c <_vfprintf_r+0xafc>
80007818:	30 12       	mov	r2,1
8000781a:	c1 98       	rjmp	8000784c <_vfprintf_r+0xb2c>
8000781c:	40 22       	lddsp	r2,sp[0x8]
8000781e:	2f e2       	sub	r2,-2
80007820:	36 60       	mov	r0,102
80007822:	c1 58       	rjmp	8000784c <_vfprintf_r+0xb2c>
80007824:	fa f2 06 ac 	ld.w	r2,sp[1708]
80007828:	40 6e       	lddsp	lr,sp[0x18]
8000782a:	1c 32       	cp.w	r2,lr
8000782c:	c0 65       	brlt	80007838 <_vfprintf_r+0xb18>
8000782e:	ed b5 00 00 	bld	r5,0x0
80007832:	f7 b2 00 ff 	subeq	r2,-1
80007836:	c0 a8       	rjmp	8000784a <_vfprintf_r+0xb2a>
80007838:	e4 08 11 02 	rsub	r8,r2,2
8000783c:	40 6c       	lddsp	r12,sp[0x18]
8000783e:	58 02       	cp.w	r2,0
80007840:	f0 02 17 a0 	movle	r2,r8
80007844:	f9 b2 09 01 	movgt	r2,1
80007848:	18 02       	add	r2,r12
8000784a:	36 70       	mov	r0,103
8000784c:	40 9b       	lddsp	r11,sp[0x24]
8000784e:	58 0b       	cp.w	r11,0
80007850:	e0 80 05 94 	breq	80008378 <_vfprintf_r+0x1658>
80007854:	32 d8       	mov	r8,45
80007856:	fb 68 06 bb 	st.b	sp[1723],r8
8000785a:	e0 8f 05 93 	bral	80008380 <_vfprintf_r+0x1660>
8000785e:	50 a7       	stdsp	sp[0x28],r7
80007860:	04 94       	mov	r4,r2
80007862:	0c 97       	mov	r7,r6
80007864:	02 92       	mov	r2,r1
80007866:	06 96       	mov	r6,r3
80007868:	40 41       	lddsp	r1,sp[0x10]
8000786a:	40 93       	lddsp	r3,sp[0x24]
8000786c:	0e 99       	mov	r9,r7
8000786e:	ed b5 00 05 	bld	r5,0x5
80007872:	c4 81       	brne	80007902 <_vfprintf_r+0xbe2>
80007874:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007878:	40 3e       	lddsp	lr,sp[0xc]
8000787a:	58 0e       	cp.w	lr,0
8000787c:	c1 d0       	breq	800078b6 <_vfprintf_r+0xb96>
8000787e:	10 36       	cp.w	r6,r8
80007880:	c0 64       	brge	8000788c <_vfprintf_r+0xb6c>
80007882:	fa cc f9 44 	sub	r12,sp,-1724
80007886:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000788a:	c1 d8       	rjmp	800078c4 <_vfprintf_r+0xba4>
8000788c:	fa c8 f9 50 	sub	r8,sp,-1712
80007890:	1a d8       	st.w	--sp,r8
80007892:	fa c8 fa b8 	sub	r8,sp,-1352
80007896:	04 9a       	mov	r10,r2
80007898:	1a d8       	st.w	--sp,r8
8000789a:	fa c8 fb b4 	sub	r8,sp,-1100
8000789e:	0c 9b       	mov	r11,r6
800078a0:	1a d8       	st.w	--sp,r8
800078a2:	08 9c       	mov	r12,r4
800078a4:	fa c8 f9 40 	sub	r8,sp,-1728
800078a8:	fa c9 ff b4 	sub	r9,sp,-76
800078ac:	fe b0 f8 a2 	rcall	800069f0 <get_arg>
800078b0:	2f dd       	sub	sp,-12
800078b2:	78 0a       	ld.w	r10,r12[0x0]
800078b4:	c2 08       	rjmp	800078f4 <_vfprintf_r+0xbd4>
800078b6:	2f f7       	sub	r7,-1
800078b8:	10 39       	cp.w	r9,r8
800078ba:	c0 84       	brge	800078ca <_vfprintf_r+0xbaa>
800078bc:	fa cb f9 44 	sub	r11,sp,-1724
800078c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
800078c4:	ec fa fd 88 	ld.w	r10,r6[-632]
800078c8:	c1 68       	rjmp	800078f4 <_vfprintf_r+0xbd4>
800078ca:	41 09       	lddsp	r9,sp[0x40]
800078cc:	59 f8       	cp.w	r8,31
800078ce:	e0 89 00 10 	brgt	800078ee <_vfprintf_r+0xbce>
800078d2:	f2 ca ff fc 	sub	r10,r9,-4
800078d6:	51 0a       	stdsp	sp[0x40],r10
800078d8:	fa c6 f9 44 	sub	r6,sp,-1724
800078dc:	72 0a       	ld.w	r10,r9[0x0]
800078de:	ec 08 00 39 	add	r9,r6,r8<<0x3
800078e2:	f3 4a fd 88 	st.w	r9[-632],r10
800078e6:	2f f8       	sub	r8,-1
800078e8:	fb 48 06 b4 	st.w	sp[1716],r8
800078ec:	c0 48       	rjmp	800078f4 <_vfprintf_r+0xbd4>
800078ee:	72 0a       	ld.w	r10,r9[0x0]
800078f0:	2f c9       	sub	r9,-4
800078f2:	51 09       	stdsp	sp[0x40],r9
800078f4:	40 be       	lddsp	lr,sp[0x2c]
800078f6:	1c 98       	mov	r8,lr
800078f8:	95 1e       	st.w	r10[0x4],lr
800078fa:	bf 58       	asr	r8,0x1f
800078fc:	95 08       	st.w	r10[0x0],r8
800078fe:	fe 9f fa 9f 	bral	80006e3c <_vfprintf_r+0x11c>
80007902:	ed b5 00 04 	bld	r5,0x4
80007906:	c4 80       	breq	80007996 <_vfprintf_r+0xc76>
80007908:	e2 15 00 40 	andl	r5,0x40,COH
8000790c:	c4 50       	breq	80007996 <_vfprintf_r+0xc76>
8000790e:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007912:	40 3c       	lddsp	r12,sp[0xc]
80007914:	58 0c       	cp.w	r12,0
80007916:	c1 d0       	breq	80007950 <_vfprintf_r+0xc30>
80007918:	10 36       	cp.w	r6,r8
8000791a:	c0 64       	brge	80007926 <_vfprintf_r+0xc06>
8000791c:	fa cb f9 44 	sub	r11,sp,-1724
80007920:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007924:	c1 d8       	rjmp	8000795e <_vfprintf_r+0xc3e>
80007926:	fa c8 f9 50 	sub	r8,sp,-1712
8000792a:	1a d8       	st.w	--sp,r8
8000792c:	fa c8 fa b8 	sub	r8,sp,-1352
80007930:	04 9a       	mov	r10,r2
80007932:	1a d8       	st.w	--sp,r8
80007934:	fa c8 fb b4 	sub	r8,sp,-1100
80007938:	0c 9b       	mov	r11,r6
8000793a:	1a d8       	st.w	--sp,r8
8000793c:	08 9c       	mov	r12,r4
8000793e:	fa c8 f9 40 	sub	r8,sp,-1728
80007942:	fa c9 ff b4 	sub	r9,sp,-76
80007946:	fe b0 f8 55 	rcall	800069f0 <get_arg>
8000794a:	2f dd       	sub	sp,-12
8000794c:	78 0a       	ld.w	r10,r12[0x0]
8000794e:	c2 08       	rjmp	8000798e <_vfprintf_r+0xc6e>
80007950:	2f f7       	sub	r7,-1
80007952:	10 39       	cp.w	r9,r8
80007954:	c0 84       	brge	80007964 <_vfprintf_r+0xc44>
80007956:	fa ca f9 44 	sub	r10,sp,-1724
8000795a:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000795e:	ec fa fd 88 	ld.w	r10,r6[-632]
80007962:	c1 68       	rjmp	8000798e <_vfprintf_r+0xc6e>
80007964:	41 09       	lddsp	r9,sp[0x40]
80007966:	59 f8       	cp.w	r8,31
80007968:	e0 89 00 10 	brgt	80007988 <_vfprintf_r+0xc68>
8000796c:	f2 ca ff fc 	sub	r10,r9,-4
80007970:	51 0a       	stdsp	sp[0x40],r10
80007972:	fa c6 f9 44 	sub	r6,sp,-1724
80007976:	72 0a       	ld.w	r10,r9[0x0]
80007978:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000797c:	f3 4a fd 88 	st.w	r9[-632],r10
80007980:	2f f8       	sub	r8,-1
80007982:	fb 48 06 b4 	st.w	sp[1716],r8
80007986:	c0 48       	rjmp	8000798e <_vfprintf_r+0xc6e>
80007988:	72 0a       	ld.w	r10,r9[0x0]
8000798a:	2f c9       	sub	r9,-4
8000798c:	51 09       	stdsp	sp[0x40],r9
8000798e:	40 be       	lddsp	lr,sp[0x2c]
80007990:	b4 0e       	st.h	r10[0x0],lr
80007992:	fe 9f fa 55 	bral	80006e3c <_vfprintf_r+0x11c>
80007996:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000799a:	40 3c       	lddsp	r12,sp[0xc]
8000799c:	58 0c       	cp.w	r12,0
8000799e:	c1 d0       	breq	800079d8 <_vfprintf_r+0xcb8>
800079a0:	10 36       	cp.w	r6,r8
800079a2:	c0 64       	brge	800079ae <_vfprintf_r+0xc8e>
800079a4:	fa cb f9 44 	sub	r11,sp,-1724
800079a8:	f6 06 00 36 	add	r6,r11,r6<<0x3
800079ac:	c1 d8       	rjmp	800079e6 <_vfprintf_r+0xcc6>
800079ae:	fa c8 f9 50 	sub	r8,sp,-1712
800079b2:	1a d8       	st.w	--sp,r8
800079b4:	fa c8 fa b8 	sub	r8,sp,-1352
800079b8:	04 9a       	mov	r10,r2
800079ba:	1a d8       	st.w	--sp,r8
800079bc:	fa c8 fb b4 	sub	r8,sp,-1100
800079c0:	0c 9b       	mov	r11,r6
800079c2:	1a d8       	st.w	--sp,r8
800079c4:	08 9c       	mov	r12,r4
800079c6:	fa c8 f9 40 	sub	r8,sp,-1728
800079ca:	fa c9 ff b4 	sub	r9,sp,-76
800079ce:	fe b0 f8 11 	rcall	800069f0 <get_arg>
800079d2:	2f dd       	sub	sp,-12
800079d4:	78 0a       	ld.w	r10,r12[0x0]
800079d6:	c2 08       	rjmp	80007a16 <_vfprintf_r+0xcf6>
800079d8:	2f f7       	sub	r7,-1
800079da:	10 39       	cp.w	r9,r8
800079dc:	c0 84       	brge	800079ec <_vfprintf_r+0xccc>
800079de:	fa ca f9 44 	sub	r10,sp,-1724
800079e2:	f4 06 00 36 	add	r6,r10,r6<<0x3
800079e6:	ec fa fd 88 	ld.w	r10,r6[-632]
800079ea:	c1 68       	rjmp	80007a16 <_vfprintf_r+0xcf6>
800079ec:	41 09       	lddsp	r9,sp[0x40]
800079ee:	59 f8       	cp.w	r8,31
800079f0:	e0 89 00 10 	brgt	80007a10 <_vfprintf_r+0xcf0>
800079f4:	f2 ca ff fc 	sub	r10,r9,-4
800079f8:	51 0a       	stdsp	sp[0x40],r10
800079fa:	fa c6 f9 44 	sub	r6,sp,-1724
800079fe:	72 0a       	ld.w	r10,r9[0x0]
80007a00:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007a04:	f3 4a fd 88 	st.w	r9[-632],r10
80007a08:	2f f8       	sub	r8,-1
80007a0a:	fb 48 06 b4 	st.w	sp[1716],r8
80007a0e:	c0 48       	rjmp	80007a16 <_vfprintf_r+0xcf6>
80007a10:	72 0a       	ld.w	r10,r9[0x0]
80007a12:	2f c9       	sub	r9,-4
80007a14:	51 09       	stdsp	sp[0x40],r9
80007a16:	40 be       	lddsp	lr,sp[0x2c]
80007a18:	95 0e       	st.w	r10[0x0],lr
80007a1a:	fe 9f fa 11 	bral	80006e3c <_vfprintf_r+0x11c>
80007a1e:	50 a7       	stdsp	sp[0x28],r7
80007a20:	50 80       	stdsp	sp[0x20],r0
80007a22:	0c 97       	mov	r7,r6
80007a24:	04 94       	mov	r4,r2
80007a26:	06 96       	mov	r6,r3
80007a28:	02 92       	mov	r2,r1
80007a2a:	40 93       	lddsp	r3,sp[0x24]
80007a2c:	10 90       	mov	r0,r8
80007a2e:	40 41       	lddsp	r1,sp[0x10]
80007a30:	a5 a5       	sbr	r5,0x4
80007a32:	c0 a8       	rjmp	80007a46 <_vfprintf_r+0xd26>
80007a34:	50 a7       	stdsp	sp[0x28],r7
80007a36:	50 80       	stdsp	sp[0x20],r0
80007a38:	0c 97       	mov	r7,r6
80007a3a:	04 94       	mov	r4,r2
80007a3c:	06 96       	mov	r6,r3
80007a3e:	02 92       	mov	r2,r1
80007a40:	40 93       	lddsp	r3,sp[0x24]
80007a42:	10 90       	mov	r0,r8
80007a44:	40 41       	lddsp	r1,sp[0x10]
80007a46:	ed b5 00 05 	bld	r5,0x5
80007a4a:	c5 d1       	brne	80007b04 <_vfprintf_r+0xde4>
80007a4c:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007a50:	40 3c       	lddsp	r12,sp[0xc]
80007a52:	58 0c       	cp.w	r12,0
80007a54:	c2 60       	breq	80007aa0 <_vfprintf_r+0xd80>
80007a56:	10 36       	cp.w	r6,r8
80007a58:	c0 a4       	brge	80007a6c <_vfprintf_r+0xd4c>
80007a5a:	fa cb f9 44 	sub	r11,sp,-1724
80007a5e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007a62:	ec e8 fd 88 	ld.d	r8,r6[-632]
80007a66:	fa e9 00 00 	st.d	sp[0],r8
80007a6a:	c1 88       	rjmp	80007a9a <_vfprintf_r+0xd7a>
80007a6c:	fa c8 f9 50 	sub	r8,sp,-1712
80007a70:	1a d8       	st.w	--sp,r8
80007a72:	fa c8 fa b8 	sub	r8,sp,-1352
80007a76:	04 9a       	mov	r10,r2
80007a78:	1a d8       	st.w	--sp,r8
80007a7a:	0c 9b       	mov	r11,r6
80007a7c:	fa c8 fb b4 	sub	r8,sp,-1100
80007a80:	08 9c       	mov	r12,r4
80007a82:	1a d8       	st.w	--sp,r8
80007a84:	fa c8 f9 40 	sub	r8,sp,-1728
80007a88:	fa c9 ff b4 	sub	r9,sp,-76
80007a8c:	fe b0 f7 b2 	rcall	800069f0 <get_arg>
80007a90:	2f dd       	sub	sp,-12
80007a92:	f8 ea 00 00 	ld.d	r10,r12[0]
80007a96:	fa eb 00 00 	st.d	sp[0],r10
80007a9a:	30 08       	mov	r8,0
80007a9c:	e0 8f 03 de 	bral	80008258 <_vfprintf_r+0x1538>
80007aa0:	ee ca ff ff 	sub	r10,r7,-1
80007aa4:	10 37       	cp.w	r7,r8
80007aa6:	c0 b4       	brge	80007abc <_vfprintf_r+0xd9c>
80007aa8:	fa c9 f9 44 	sub	r9,sp,-1724
80007aac:	14 97       	mov	r7,r10
80007aae:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007ab2:	ec ea fd 88 	ld.d	r10,r6[-632]
80007ab6:	fa eb 00 00 	st.d	sp[0],r10
80007aba:	c1 88       	rjmp	80007aea <_vfprintf_r+0xdca>
80007abc:	41 09       	lddsp	r9,sp[0x40]
80007abe:	59 f8       	cp.w	r8,31
80007ac0:	e0 89 00 18 	brgt	80007af0 <_vfprintf_r+0xdd0>
80007ac4:	f2 e6 00 00 	ld.d	r6,r9[0]
80007ac8:	f2 cb ff f8 	sub	r11,r9,-8
80007acc:	fa e7 00 00 	st.d	sp[0],r6
80007ad0:	51 0b       	stdsp	sp[0x40],r11
80007ad2:	fa c6 f9 44 	sub	r6,sp,-1724
80007ad6:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ada:	fa e6 00 00 	ld.d	r6,sp[0]
80007ade:	f2 e7 fd 88 	st.d	r9[-632],r6
80007ae2:	2f f8       	sub	r8,-1
80007ae4:	14 97       	mov	r7,r10
80007ae6:	fb 48 06 b4 	st.w	sp[1716],r8
80007aea:	40 38       	lddsp	r8,sp[0xc]
80007aec:	e0 8f 03 b6 	bral	80008258 <_vfprintf_r+0x1538>
80007af0:	f2 e6 00 00 	ld.d	r6,r9[0]
80007af4:	40 38       	lddsp	r8,sp[0xc]
80007af6:	fa e7 00 00 	st.d	sp[0],r6
80007afa:	2f 89       	sub	r9,-8
80007afc:	14 97       	mov	r7,r10
80007afe:	51 09       	stdsp	sp[0x40],r9
80007b00:	e0 8f 03 ac 	bral	80008258 <_vfprintf_r+0x1538>
80007b04:	ed b5 00 04 	bld	r5,0x4
80007b08:	c1 61       	brne	80007b34 <_vfprintf_r+0xe14>
80007b0a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b0e:	40 3e       	lddsp	lr,sp[0xc]
80007b10:	58 0e       	cp.w	lr,0
80007b12:	c0 80       	breq	80007b22 <_vfprintf_r+0xe02>
80007b14:	10 36       	cp.w	r6,r8
80007b16:	c6 74       	brge	80007be4 <_vfprintf_r+0xec4>
80007b18:	fa cc f9 44 	sub	r12,sp,-1724
80007b1c:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007b20:	c8 08       	rjmp	80007c20 <_vfprintf_r+0xf00>
80007b22:	ee ca ff ff 	sub	r10,r7,-1
80007b26:	10 37       	cp.w	r7,r8
80007b28:	c7 f4       	brge	80007c26 <_vfprintf_r+0xf06>
80007b2a:	fa cb f9 44 	sub	r11,sp,-1724
80007b2e:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b32:	c7 68       	rjmp	80007c1e <_vfprintf_r+0xefe>
80007b34:	ed b5 00 06 	bld	r5,0x6
80007b38:	c4 a1       	brne	80007bcc <_vfprintf_r+0xeac>
80007b3a:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007b3e:	40 3c       	lddsp	r12,sp[0xc]
80007b40:	58 0c       	cp.w	r12,0
80007b42:	c1 d0       	breq	80007b7c <_vfprintf_r+0xe5c>
80007b44:	10 36       	cp.w	r6,r8
80007b46:	c0 64       	brge	80007b52 <_vfprintf_r+0xe32>
80007b48:	fa cb f9 44 	sub	r11,sp,-1724
80007b4c:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007b50:	c1 f8       	rjmp	80007b8e <_vfprintf_r+0xe6e>
80007b52:	fa c8 f9 50 	sub	r8,sp,-1712
80007b56:	1a d8       	st.w	--sp,r8
80007b58:	fa c8 fa b8 	sub	r8,sp,-1352
80007b5c:	1a d8       	st.w	--sp,r8
80007b5e:	fa c8 fb b4 	sub	r8,sp,-1100
80007b62:	1a d8       	st.w	--sp,r8
80007b64:	fa c8 f9 40 	sub	r8,sp,-1728
80007b68:	fa c9 ff b4 	sub	r9,sp,-76
80007b6c:	04 9a       	mov	r10,r2
80007b6e:	0c 9b       	mov	r11,r6
80007b70:	08 9c       	mov	r12,r4
80007b72:	fe b0 f7 3f 	rcall	800069f0 <get_arg>
80007b76:	2f dd       	sub	sp,-12
80007b78:	98 18       	ld.sh	r8,r12[0x2]
80007b7a:	c2 68       	rjmp	80007bc6 <_vfprintf_r+0xea6>
80007b7c:	ee ca ff ff 	sub	r10,r7,-1
80007b80:	10 37       	cp.w	r7,r8
80007b82:	c0 94       	brge	80007b94 <_vfprintf_r+0xe74>
80007b84:	fa c9 f9 44 	sub	r9,sp,-1724
80007b88:	14 97       	mov	r7,r10
80007b8a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007b8e:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007b92:	c1 a8       	rjmp	80007bc6 <_vfprintf_r+0xea6>
80007b94:	41 09       	lddsp	r9,sp[0x40]
80007b96:	59 f8       	cp.w	r8,31
80007b98:	e0 89 00 13 	brgt	80007bbe <_vfprintf_r+0xe9e>
80007b9c:	f2 cb ff fc 	sub	r11,r9,-4
80007ba0:	51 0b       	stdsp	sp[0x40],r11
80007ba2:	72 09       	ld.w	r9,r9[0x0]
80007ba4:	fa c6 f9 44 	sub	r6,sp,-1724
80007ba8:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007bac:	2f f8       	sub	r8,-1
80007bae:	f7 49 fd 88 	st.w	r11[-632],r9
80007bb2:	fb 48 06 b4 	st.w	sp[1716],r8
80007bb6:	14 97       	mov	r7,r10
80007bb8:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007bbc:	c0 58       	rjmp	80007bc6 <_vfprintf_r+0xea6>
80007bbe:	92 18       	ld.sh	r8,r9[0x2]
80007bc0:	14 97       	mov	r7,r10
80007bc2:	2f c9       	sub	r9,-4
80007bc4:	51 09       	stdsp	sp[0x40],r9
80007bc6:	5c 78       	castu.h	r8
80007bc8:	50 18       	stdsp	sp[0x4],r8
80007bca:	c4 68       	rjmp	80007c56 <_vfprintf_r+0xf36>
80007bcc:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007bd0:	40 3c       	lddsp	r12,sp[0xc]
80007bd2:	58 0c       	cp.w	r12,0
80007bd4:	c1 d0       	breq	80007c0e <_vfprintf_r+0xeee>
80007bd6:	10 36       	cp.w	r6,r8
80007bd8:	c0 64       	brge	80007be4 <_vfprintf_r+0xec4>
80007bda:	fa cb f9 44 	sub	r11,sp,-1724
80007bde:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007be2:	c1 f8       	rjmp	80007c20 <_vfprintf_r+0xf00>
80007be4:	fa c8 f9 50 	sub	r8,sp,-1712
80007be8:	1a d8       	st.w	--sp,r8
80007bea:	fa c8 fa b8 	sub	r8,sp,-1352
80007bee:	0c 9b       	mov	r11,r6
80007bf0:	1a d8       	st.w	--sp,r8
80007bf2:	fa c8 fb b4 	sub	r8,sp,-1100
80007bf6:	04 9a       	mov	r10,r2
80007bf8:	1a d8       	st.w	--sp,r8
80007bfa:	08 9c       	mov	r12,r4
80007bfc:	fa c8 f9 40 	sub	r8,sp,-1728
80007c00:	fa c9 ff b4 	sub	r9,sp,-76
80007c04:	fe b0 f6 f6 	rcall	800069f0 <get_arg>
80007c08:	2f dd       	sub	sp,-12
80007c0a:	78 0b       	ld.w	r11,r12[0x0]
80007c0c:	c2 48       	rjmp	80007c54 <_vfprintf_r+0xf34>
80007c0e:	ee ca ff ff 	sub	r10,r7,-1
80007c12:	10 37       	cp.w	r7,r8
80007c14:	c0 94       	brge	80007c26 <_vfprintf_r+0xf06>
80007c16:	fa c9 f9 44 	sub	r9,sp,-1724
80007c1a:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007c1e:	14 97       	mov	r7,r10
80007c20:	ec fb fd 88 	ld.w	r11,r6[-632]
80007c24:	c1 88       	rjmp	80007c54 <_vfprintf_r+0xf34>
80007c26:	41 09       	lddsp	r9,sp[0x40]
80007c28:	59 f8       	cp.w	r8,31
80007c2a:	e0 89 00 11 	brgt	80007c4c <_vfprintf_r+0xf2c>
80007c2e:	f2 cb ff fc 	sub	r11,r9,-4
80007c32:	51 0b       	stdsp	sp[0x40],r11
80007c34:	fa c6 f9 44 	sub	r6,sp,-1724
80007c38:	72 0b       	ld.w	r11,r9[0x0]
80007c3a:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007c3e:	f3 4b fd 88 	st.w	r9[-632],r11
80007c42:	2f f8       	sub	r8,-1
80007c44:	14 97       	mov	r7,r10
80007c46:	fb 48 06 b4 	st.w	sp[1716],r8
80007c4a:	c0 58       	rjmp	80007c54 <_vfprintf_r+0xf34>
80007c4c:	72 0b       	ld.w	r11,r9[0x0]
80007c4e:	14 97       	mov	r7,r10
80007c50:	2f c9       	sub	r9,-4
80007c52:	51 09       	stdsp	sp[0x40],r9
80007c54:	50 1b       	stdsp	sp[0x4],r11
80007c56:	30 0e       	mov	lr,0
80007c58:	50 0e       	stdsp	sp[0x0],lr
80007c5a:	1c 98       	mov	r8,lr
80007c5c:	e0 8f 02 fe 	bral	80008258 <_vfprintf_r+0x1538>
80007c60:	50 a7       	stdsp	sp[0x28],r7
80007c62:	50 80       	stdsp	sp[0x20],r0
80007c64:	0c 97       	mov	r7,r6
80007c66:	04 94       	mov	r4,r2
80007c68:	06 96       	mov	r6,r3
80007c6a:	02 92       	mov	r2,r1
80007c6c:	40 93       	lddsp	r3,sp[0x24]
80007c6e:	40 41       	lddsp	r1,sp[0x10]
80007c70:	0e 99       	mov	r9,r7
80007c72:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007c76:	40 3c       	lddsp	r12,sp[0xc]
80007c78:	58 0c       	cp.w	r12,0
80007c7a:	c1 d0       	breq	80007cb4 <_vfprintf_r+0xf94>
80007c7c:	10 36       	cp.w	r6,r8
80007c7e:	c0 64       	brge	80007c8a <_vfprintf_r+0xf6a>
80007c80:	fa cb f9 44 	sub	r11,sp,-1724
80007c84:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007c88:	c1 d8       	rjmp	80007cc2 <_vfprintf_r+0xfa2>
80007c8a:	fa c8 f9 50 	sub	r8,sp,-1712
80007c8e:	1a d8       	st.w	--sp,r8
80007c90:	fa c8 fa b8 	sub	r8,sp,-1352
80007c94:	1a d8       	st.w	--sp,r8
80007c96:	fa c8 fb b4 	sub	r8,sp,-1100
80007c9a:	1a d8       	st.w	--sp,r8
80007c9c:	fa c9 ff b4 	sub	r9,sp,-76
80007ca0:	fa c8 f9 40 	sub	r8,sp,-1728
80007ca4:	04 9a       	mov	r10,r2
80007ca6:	0c 9b       	mov	r11,r6
80007ca8:	08 9c       	mov	r12,r4
80007caa:	fe b0 f6 a3 	rcall	800069f0 <get_arg>
80007cae:	2f dd       	sub	sp,-12
80007cb0:	78 09       	ld.w	r9,r12[0x0]
80007cb2:	c2 18       	rjmp	80007cf4 <_vfprintf_r+0xfd4>
80007cb4:	2f f7       	sub	r7,-1
80007cb6:	10 39       	cp.w	r9,r8
80007cb8:	c0 84       	brge	80007cc8 <_vfprintf_r+0xfa8>
80007cba:	fa ca f9 44 	sub	r10,sp,-1724
80007cbe:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007cc2:	ec f9 fd 88 	ld.w	r9,r6[-632]
80007cc6:	c1 78       	rjmp	80007cf4 <_vfprintf_r+0xfd4>
80007cc8:	41 09       	lddsp	r9,sp[0x40]
80007cca:	59 f8       	cp.w	r8,31
80007ccc:	e0 89 00 10 	brgt	80007cec <_vfprintf_r+0xfcc>
80007cd0:	f2 ca ff fc 	sub	r10,r9,-4
80007cd4:	51 0a       	stdsp	sp[0x40],r10
80007cd6:	fa c6 f9 44 	sub	r6,sp,-1724
80007cda:	72 09       	ld.w	r9,r9[0x0]
80007cdc:	ec 08 00 3a 	add	r10,r6,r8<<0x3
80007ce0:	f5 49 fd 88 	st.w	r10[-632],r9
80007ce4:	2f f8       	sub	r8,-1
80007ce6:	fb 48 06 b4 	st.w	sp[1716],r8
80007cea:	c0 58       	rjmp	80007cf4 <_vfprintf_r+0xfd4>
80007cec:	f2 c8 ff fc 	sub	r8,r9,-4
80007cf0:	51 08       	stdsp	sp[0x40],r8
80007cf2:	72 09       	ld.w	r9,r9[0x0]
80007cf4:	33 08       	mov	r8,48
80007cf6:	fb 68 06 b8 	st.b	sp[1720],r8
80007cfa:	37 88       	mov	r8,120
80007cfc:	30 0e       	mov	lr,0
80007cfe:	fb 68 06 b9 	st.b	sp[1721],r8
80007d02:	fe cc b1 b2 	sub	r12,pc,-20046
80007d06:	50 19       	stdsp	sp[0x4],r9
80007d08:	a1 b5       	sbr	r5,0x1
80007d0a:	50 0e       	stdsp	sp[0x0],lr
80007d0c:	50 dc       	stdsp	sp[0x34],r12
80007d0e:	30 28       	mov	r8,2
80007d10:	37 80       	mov	r0,120
80007d12:	e0 8f 02 a3 	bral	80008258 <_vfprintf_r+0x1538>
80007d16:	50 a7       	stdsp	sp[0x28],r7
80007d18:	50 80       	stdsp	sp[0x20],r0
80007d1a:	10 90       	mov	r0,r8
80007d1c:	30 08       	mov	r8,0
80007d1e:	fb 68 06 bb 	st.b	sp[1723],r8
80007d22:	0c 97       	mov	r7,r6
80007d24:	04 94       	mov	r4,r2
80007d26:	06 96       	mov	r6,r3
80007d28:	02 92       	mov	r2,r1
80007d2a:	40 93       	lddsp	r3,sp[0x24]
80007d2c:	40 41       	lddsp	r1,sp[0x10]
80007d2e:	0e 99       	mov	r9,r7
80007d30:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007d34:	40 3b       	lddsp	r11,sp[0xc]
80007d36:	58 0b       	cp.w	r11,0
80007d38:	c1 d0       	breq	80007d72 <_vfprintf_r+0x1052>
80007d3a:	10 36       	cp.w	r6,r8
80007d3c:	c0 64       	brge	80007d48 <_vfprintf_r+0x1028>
80007d3e:	fa ca f9 44 	sub	r10,sp,-1724
80007d42:	f4 06 00 36 	add	r6,r10,r6<<0x3
80007d46:	c1 d8       	rjmp	80007d80 <_vfprintf_r+0x1060>
80007d48:	fa c8 f9 50 	sub	r8,sp,-1712
80007d4c:	1a d8       	st.w	--sp,r8
80007d4e:	fa c8 fa b8 	sub	r8,sp,-1352
80007d52:	1a d8       	st.w	--sp,r8
80007d54:	fa c8 fb b4 	sub	r8,sp,-1100
80007d58:	0c 9b       	mov	r11,r6
80007d5a:	1a d8       	st.w	--sp,r8
80007d5c:	04 9a       	mov	r10,r2
80007d5e:	fa c8 f9 40 	sub	r8,sp,-1728
80007d62:	fa c9 ff b4 	sub	r9,sp,-76
80007d66:	08 9c       	mov	r12,r4
80007d68:	fe b0 f6 44 	rcall	800069f0 <get_arg>
80007d6c:	2f dd       	sub	sp,-12
80007d6e:	78 06       	ld.w	r6,r12[0x0]
80007d70:	c2 08       	rjmp	80007db0 <_vfprintf_r+0x1090>
80007d72:	2f f7       	sub	r7,-1
80007d74:	10 39       	cp.w	r9,r8
80007d76:	c0 84       	brge	80007d86 <_vfprintf_r+0x1066>
80007d78:	fa c9 f9 44 	sub	r9,sp,-1724
80007d7c:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007d80:	ec f6 fd 88 	ld.w	r6,r6[-632]
80007d84:	c1 68       	rjmp	80007db0 <_vfprintf_r+0x1090>
80007d86:	41 09       	lddsp	r9,sp[0x40]
80007d88:	59 f8       	cp.w	r8,31
80007d8a:	e0 89 00 10 	brgt	80007daa <_vfprintf_r+0x108a>
80007d8e:	f2 ca ff fc 	sub	r10,r9,-4
80007d92:	51 0a       	stdsp	sp[0x40],r10
80007d94:	72 06       	ld.w	r6,r9[0x0]
80007d96:	fa ce f9 44 	sub	lr,sp,-1724
80007d9a:	fc 08 00 39 	add	r9,lr,r8<<0x3
80007d9e:	f3 46 fd 88 	st.w	r9[-632],r6
80007da2:	2f f8       	sub	r8,-1
80007da4:	fb 48 06 b4 	st.w	sp[1716],r8
80007da8:	c0 48       	rjmp	80007db0 <_vfprintf_r+0x1090>
80007daa:	72 06       	ld.w	r6,r9[0x0]
80007dac:	2f c9       	sub	r9,-4
80007dae:	51 09       	stdsp	sp[0x40],r9
80007db0:	40 2c       	lddsp	r12,sp[0x8]
80007db2:	58 0c       	cp.w	r12,0
80007db4:	c1 05       	brlt	80007dd4 <_vfprintf_r+0x10b4>
80007db6:	18 9a       	mov	r10,r12
80007db8:	30 0b       	mov	r11,0
80007dba:	0c 9c       	mov	r12,r6
80007dbc:	e0 a0 12 38 	rcall	8000a22c <memchr>
80007dc0:	e0 80 02 df 	breq	8000837e <_vfprintf_r+0x165e>
80007dc4:	f8 06 01 02 	sub	r2,r12,r6
80007dc8:	40 2b       	lddsp	r11,sp[0x8]
80007dca:	16 32       	cp.w	r2,r11
80007dcc:	e0 89 02 d9 	brgt	8000837e <_vfprintf_r+0x165e>
80007dd0:	e0 8f 02 d4 	bral	80008378 <_vfprintf_r+0x1658>
80007dd4:	30 0a       	mov	r10,0
80007dd6:	0c 9c       	mov	r12,r6
80007dd8:	50 2a       	stdsp	sp[0x8],r10
80007dda:	e0 a0 15 99 	rcall	8000a90c <strlen>
80007dde:	18 92       	mov	r2,r12
80007de0:	e0 8f 02 d2 	bral	80008384 <_vfprintf_r+0x1664>
80007de4:	50 a7       	stdsp	sp[0x28],r7
80007de6:	50 80       	stdsp	sp[0x20],r0
80007de8:	0c 97       	mov	r7,r6
80007dea:	04 94       	mov	r4,r2
80007dec:	06 96       	mov	r6,r3
80007dee:	02 92       	mov	r2,r1
80007df0:	40 93       	lddsp	r3,sp[0x24]
80007df2:	10 90       	mov	r0,r8
80007df4:	40 41       	lddsp	r1,sp[0x10]
80007df6:	a5 a5       	sbr	r5,0x4
80007df8:	c0 a8       	rjmp	80007e0c <_vfprintf_r+0x10ec>
80007dfa:	50 a7       	stdsp	sp[0x28],r7
80007dfc:	50 80       	stdsp	sp[0x20],r0
80007dfe:	0c 97       	mov	r7,r6
80007e00:	04 94       	mov	r4,r2
80007e02:	06 96       	mov	r6,r3
80007e04:	02 92       	mov	r2,r1
80007e06:	40 93       	lddsp	r3,sp[0x24]
80007e08:	10 90       	mov	r0,r8
80007e0a:	40 41       	lddsp	r1,sp[0x10]
80007e0c:	ed b5 00 05 	bld	r5,0x5
80007e10:	c5 61       	brne	80007ebc <_vfprintf_r+0x119c>
80007e12:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007e16:	40 39       	lddsp	r9,sp[0xc]
80007e18:	58 09       	cp.w	r9,0
80007e1a:	c2 10       	breq	80007e5c <_vfprintf_r+0x113c>
80007e1c:	10 36       	cp.w	r6,r8
80007e1e:	c0 74       	brge	80007e2c <_vfprintf_r+0x110c>
80007e20:	fa c8 f9 44 	sub	r8,sp,-1724
80007e24:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007e28:	c2 38       	rjmp	80007e6e <_vfprintf_r+0x114e>
80007e2a:	d7 03       	nop
80007e2c:	fa c8 f9 50 	sub	r8,sp,-1712
80007e30:	1a d8       	st.w	--sp,r8
80007e32:	fa c8 fa b8 	sub	r8,sp,-1352
80007e36:	1a d8       	st.w	--sp,r8
80007e38:	fa c8 fb b4 	sub	r8,sp,-1100
80007e3c:	1a d8       	st.w	--sp,r8
80007e3e:	fa c8 f9 40 	sub	r8,sp,-1728
80007e42:	fa c9 ff b4 	sub	r9,sp,-76
80007e46:	04 9a       	mov	r10,r2
80007e48:	0c 9b       	mov	r11,r6
80007e4a:	08 9c       	mov	r12,r4
80007e4c:	fe b0 f5 d2 	rcall	800069f0 <get_arg>
80007e50:	2f dd       	sub	sp,-12
80007e52:	f8 e8 00 00 	ld.d	r8,r12[0]
80007e56:	fa e9 00 00 	st.d	sp[0],r8
80007e5a:	c2 e8       	rjmp	80007eb6 <_vfprintf_r+0x1196>
80007e5c:	ee ca ff ff 	sub	r10,r7,-1
80007e60:	10 37       	cp.w	r7,r8
80007e62:	c0 b4       	brge	80007e78 <_vfprintf_r+0x1158>
80007e64:	fa c8 f9 44 	sub	r8,sp,-1724
80007e68:	14 97       	mov	r7,r10
80007e6a:	f0 06 00 36 	add	r6,r8,r6<<0x3
80007e6e:	ec ea fd 88 	ld.d	r10,r6[-632]
80007e72:	fa eb 00 00 	st.d	sp[0],r10
80007e76:	c2 08       	rjmp	80007eb6 <_vfprintf_r+0x1196>
80007e78:	41 09       	lddsp	r9,sp[0x40]
80007e7a:	59 f8       	cp.w	r8,31
80007e7c:	e0 89 00 16 	brgt	80007ea8 <_vfprintf_r+0x1188>
80007e80:	f2 e6 00 00 	ld.d	r6,r9[0]
80007e84:	f2 cb ff f8 	sub	r11,r9,-8
80007e88:	fa e7 00 00 	st.d	sp[0],r6
80007e8c:	51 0b       	stdsp	sp[0x40],r11
80007e8e:	fa c6 f9 44 	sub	r6,sp,-1724
80007e92:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007e96:	fa e6 00 00 	ld.d	r6,sp[0]
80007e9a:	f2 e7 fd 88 	st.d	r9[-632],r6
80007e9e:	2f f8       	sub	r8,-1
80007ea0:	14 97       	mov	r7,r10
80007ea2:	fb 48 06 b4 	st.w	sp[1716],r8
80007ea6:	c0 88       	rjmp	80007eb6 <_vfprintf_r+0x1196>
80007ea8:	f2 e6 00 00 	ld.d	r6,r9[0]
80007eac:	2f 89       	sub	r9,-8
80007eae:	fa e7 00 00 	st.d	sp[0],r6
80007eb2:	51 09       	stdsp	sp[0x40],r9
80007eb4:	14 97       	mov	r7,r10
80007eb6:	30 18       	mov	r8,1
80007eb8:	e0 8f 01 d0 	bral	80008258 <_vfprintf_r+0x1538>
80007ebc:	ed b5 00 04 	bld	r5,0x4
80007ec0:	c1 61       	brne	80007eec <_vfprintf_r+0x11cc>
80007ec2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ec6:	40 3e       	lddsp	lr,sp[0xc]
80007ec8:	58 0e       	cp.w	lr,0
80007eca:	c0 80       	breq	80007eda <_vfprintf_r+0x11ba>
80007ecc:	10 36       	cp.w	r6,r8
80007ece:	c6 74       	brge	80007f9c <_vfprintf_r+0x127c>
80007ed0:	fa cc f9 44 	sub	r12,sp,-1724
80007ed4:	f8 06 00 36 	add	r6,r12,r6<<0x3
80007ed8:	c8 08       	rjmp	80007fd8 <_vfprintf_r+0x12b8>
80007eda:	ee ca ff ff 	sub	r10,r7,-1
80007ede:	10 37       	cp.w	r7,r8
80007ee0:	c7 f4       	brge	80007fde <_vfprintf_r+0x12be>
80007ee2:	fa cb f9 44 	sub	r11,sp,-1724
80007ee6:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007eea:	c7 68       	rjmp	80007fd6 <_vfprintf_r+0x12b6>
80007eec:	ed b5 00 06 	bld	r5,0x6
80007ef0:	c4 a1       	brne	80007f84 <_vfprintf_r+0x1264>
80007ef2:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007ef6:	40 3c       	lddsp	r12,sp[0xc]
80007ef8:	58 0c       	cp.w	r12,0
80007efa:	c1 d0       	breq	80007f34 <_vfprintf_r+0x1214>
80007efc:	10 36       	cp.w	r6,r8
80007efe:	c0 64       	brge	80007f0a <_vfprintf_r+0x11ea>
80007f00:	fa cb f9 44 	sub	r11,sp,-1724
80007f04:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f08:	c1 f8       	rjmp	80007f46 <_vfprintf_r+0x1226>
80007f0a:	fa c8 f9 50 	sub	r8,sp,-1712
80007f0e:	1a d8       	st.w	--sp,r8
80007f10:	fa c8 fa b8 	sub	r8,sp,-1352
80007f14:	1a d8       	st.w	--sp,r8
80007f16:	fa c8 fb b4 	sub	r8,sp,-1100
80007f1a:	1a d8       	st.w	--sp,r8
80007f1c:	fa c8 f9 40 	sub	r8,sp,-1728
80007f20:	fa c9 ff b4 	sub	r9,sp,-76
80007f24:	04 9a       	mov	r10,r2
80007f26:	0c 9b       	mov	r11,r6
80007f28:	08 9c       	mov	r12,r4
80007f2a:	fe b0 f5 63 	rcall	800069f0 <get_arg>
80007f2e:	2f dd       	sub	sp,-12
80007f30:	98 18       	ld.sh	r8,r12[0x2]
80007f32:	c2 68       	rjmp	80007f7e <_vfprintf_r+0x125e>
80007f34:	ee ca ff ff 	sub	r10,r7,-1
80007f38:	10 37       	cp.w	r7,r8
80007f3a:	c0 94       	brge	80007f4c <_vfprintf_r+0x122c>
80007f3c:	fa c9 f9 44 	sub	r9,sp,-1724
80007f40:	14 97       	mov	r7,r10
80007f42:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007f46:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
80007f4a:	c1 a8       	rjmp	80007f7e <_vfprintf_r+0x125e>
80007f4c:	41 09       	lddsp	r9,sp[0x40]
80007f4e:	59 f8       	cp.w	r8,31
80007f50:	e0 89 00 13 	brgt	80007f76 <_vfprintf_r+0x1256>
80007f54:	f2 cb ff fc 	sub	r11,r9,-4
80007f58:	51 0b       	stdsp	sp[0x40],r11
80007f5a:	72 09       	ld.w	r9,r9[0x0]
80007f5c:	fa c6 f9 44 	sub	r6,sp,-1724
80007f60:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80007f64:	2f f8       	sub	r8,-1
80007f66:	f7 49 fd 88 	st.w	r11[-632],r9
80007f6a:	fb 48 06 b4 	st.w	sp[1716],r8
80007f6e:	14 97       	mov	r7,r10
80007f70:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80007f74:	c0 58       	rjmp	80007f7e <_vfprintf_r+0x125e>
80007f76:	92 18       	ld.sh	r8,r9[0x2]
80007f78:	14 97       	mov	r7,r10
80007f7a:	2f c9       	sub	r9,-4
80007f7c:	51 09       	stdsp	sp[0x40],r9
80007f7e:	5c 78       	castu.h	r8
80007f80:	50 18       	stdsp	sp[0x4],r8
80007f82:	c4 68       	rjmp	8000800e <_vfprintf_r+0x12ee>
80007f84:	fa f8 06 b4 	ld.w	r8,sp[1716]
80007f88:	40 3c       	lddsp	r12,sp[0xc]
80007f8a:	58 0c       	cp.w	r12,0
80007f8c:	c1 d0       	breq	80007fc6 <_vfprintf_r+0x12a6>
80007f8e:	10 36       	cp.w	r6,r8
80007f90:	c0 64       	brge	80007f9c <_vfprintf_r+0x127c>
80007f92:	fa cb f9 44 	sub	r11,sp,-1724
80007f96:	f6 06 00 36 	add	r6,r11,r6<<0x3
80007f9a:	c1 f8       	rjmp	80007fd8 <_vfprintf_r+0x12b8>
80007f9c:	fa c8 f9 50 	sub	r8,sp,-1712
80007fa0:	1a d8       	st.w	--sp,r8
80007fa2:	fa c8 fa b8 	sub	r8,sp,-1352
80007fa6:	0c 9b       	mov	r11,r6
80007fa8:	1a d8       	st.w	--sp,r8
80007faa:	fa c8 fb b4 	sub	r8,sp,-1100
80007fae:	04 9a       	mov	r10,r2
80007fb0:	1a d8       	st.w	--sp,r8
80007fb2:	08 9c       	mov	r12,r4
80007fb4:	fa c8 f9 40 	sub	r8,sp,-1728
80007fb8:	fa c9 ff b4 	sub	r9,sp,-76
80007fbc:	fe b0 f5 1a 	rcall	800069f0 <get_arg>
80007fc0:	2f dd       	sub	sp,-12
80007fc2:	78 0b       	ld.w	r11,r12[0x0]
80007fc4:	c2 48       	rjmp	8000800c <_vfprintf_r+0x12ec>
80007fc6:	ee ca ff ff 	sub	r10,r7,-1
80007fca:	10 37       	cp.w	r7,r8
80007fcc:	c0 94       	brge	80007fde <_vfprintf_r+0x12be>
80007fce:	fa c9 f9 44 	sub	r9,sp,-1724
80007fd2:	f2 06 00 36 	add	r6,r9,r6<<0x3
80007fd6:	14 97       	mov	r7,r10
80007fd8:	ec fb fd 88 	ld.w	r11,r6[-632]
80007fdc:	c1 88       	rjmp	8000800c <_vfprintf_r+0x12ec>
80007fde:	41 09       	lddsp	r9,sp[0x40]
80007fe0:	59 f8       	cp.w	r8,31
80007fe2:	e0 89 00 11 	brgt	80008004 <_vfprintf_r+0x12e4>
80007fe6:	f2 cb ff fc 	sub	r11,r9,-4
80007fea:	51 0b       	stdsp	sp[0x40],r11
80007fec:	fa c6 f9 44 	sub	r6,sp,-1724
80007ff0:	72 0b       	ld.w	r11,r9[0x0]
80007ff2:	ec 08 00 39 	add	r9,r6,r8<<0x3
80007ff6:	f3 4b fd 88 	st.w	r9[-632],r11
80007ffa:	2f f8       	sub	r8,-1
80007ffc:	14 97       	mov	r7,r10
80007ffe:	fb 48 06 b4 	st.w	sp[1716],r8
80008002:	c0 58       	rjmp	8000800c <_vfprintf_r+0x12ec>
80008004:	72 0b       	ld.w	r11,r9[0x0]
80008006:	14 97       	mov	r7,r10
80008008:	2f c9       	sub	r9,-4
8000800a:	51 09       	stdsp	sp[0x40],r9
8000800c:	50 1b       	stdsp	sp[0x4],r11
8000800e:	30 0e       	mov	lr,0
80008010:	30 18       	mov	r8,1
80008012:	50 0e       	stdsp	sp[0x0],lr
80008014:	c2 29       	rjmp	80008258 <_vfprintf_r+0x1538>
80008016:	50 a7       	stdsp	sp[0x28],r7
80008018:	50 80       	stdsp	sp[0x20],r0
8000801a:	0c 97       	mov	r7,r6
8000801c:	04 94       	mov	r4,r2
8000801e:	06 96       	mov	r6,r3
80008020:	02 92       	mov	r2,r1
80008022:	fe cc b4 d2 	sub	r12,pc,-19246
80008026:	40 93       	lddsp	r3,sp[0x24]
80008028:	10 90       	mov	r0,r8
8000802a:	40 41       	lddsp	r1,sp[0x10]
8000802c:	50 dc       	stdsp	sp[0x34],r12
8000802e:	ed b5 00 05 	bld	r5,0x5
80008032:	c5 51       	brne	800080dc <_vfprintf_r+0x13bc>
80008034:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008038:	40 3b       	lddsp	r11,sp[0xc]
8000803a:	58 0b       	cp.w	r11,0
8000803c:	c2 20       	breq	80008080 <_vfprintf_r+0x1360>
8000803e:	10 36       	cp.w	r6,r8
80008040:	c0 a4       	brge	80008054 <_vfprintf_r+0x1334>
80008042:	fa ca f9 44 	sub	r10,sp,-1724
80008046:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000804a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000804e:	fa e9 00 00 	st.d	sp[0],r8
80008052:	cf 28       	rjmp	80008236 <_vfprintf_r+0x1516>
80008054:	fa c8 f9 50 	sub	r8,sp,-1712
80008058:	1a d8       	st.w	--sp,r8
8000805a:	fa c8 fa b8 	sub	r8,sp,-1352
8000805e:	04 9a       	mov	r10,r2
80008060:	1a d8       	st.w	--sp,r8
80008062:	0c 9b       	mov	r11,r6
80008064:	fa c8 fb b4 	sub	r8,sp,-1100
80008068:	08 9c       	mov	r12,r4
8000806a:	1a d8       	st.w	--sp,r8
8000806c:	fa c8 f9 40 	sub	r8,sp,-1728
80008070:	fa c9 ff b4 	sub	r9,sp,-76
80008074:	fe b0 f4 be 	rcall	800069f0 <get_arg>
80008078:	2f dd       	sub	sp,-12
8000807a:	f8 ea 00 00 	ld.d	r10,r12[0]
8000807e:	c0 c8       	rjmp	80008096 <_vfprintf_r+0x1376>
80008080:	ee ca ff ff 	sub	r10,r7,-1
80008084:	10 37       	cp.w	r7,r8
80008086:	c0 b4       	brge	8000809c <_vfprintf_r+0x137c>
80008088:	fa c9 f9 44 	sub	r9,sp,-1724
8000808c:	14 97       	mov	r7,r10
8000808e:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008092:	ec ea fd 88 	ld.d	r10,r6[-632]
80008096:	fa eb 00 00 	st.d	sp[0],r10
8000809a:	cc e8       	rjmp	80008236 <_vfprintf_r+0x1516>
8000809c:	41 09       	lddsp	r9,sp[0x40]
8000809e:	59 f8       	cp.w	r8,31
800080a0:	e0 89 00 16 	brgt	800080cc <_vfprintf_r+0x13ac>
800080a4:	f2 e6 00 00 	ld.d	r6,r9[0]
800080a8:	f2 cb ff f8 	sub	r11,r9,-8
800080ac:	fa e7 00 00 	st.d	sp[0],r6
800080b0:	51 0b       	stdsp	sp[0x40],r11
800080b2:	fa c6 f9 44 	sub	r6,sp,-1724
800080b6:	ec 08 00 39 	add	r9,r6,r8<<0x3
800080ba:	fa e6 00 00 	ld.d	r6,sp[0]
800080be:	f2 e7 fd 88 	st.d	r9[-632],r6
800080c2:	2f f8       	sub	r8,-1
800080c4:	14 97       	mov	r7,r10
800080c6:	fb 48 06 b4 	st.w	sp[1716],r8
800080ca:	cb 68       	rjmp	80008236 <_vfprintf_r+0x1516>
800080cc:	f2 e6 00 00 	ld.d	r6,r9[0]
800080d0:	2f 89       	sub	r9,-8
800080d2:	fa e7 00 00 	st.d	sp[0],r6
800080d6:	51 09       	stdsp	sp[0x40],r9
800080d8:	14 97       	mov	r7,r10
800080da:	ca e8       	rjmp	80008236 <_vfprintf_r+0x1516>
800080dc:	ed b5 00 04 	bld	r5,0x4
800080e0:	c1 71       	brne	8000810e <_vfprintf_r+0x13ee>
800080e2:	fa f8 06 b4 	ld.w	r8,sp[1716]
800080e6:	40 3e       	lddsp	lr,sp[0xc]
800080e8:	58 0e       	cp.w	lr,0
800080ea:	c0 80       	breq	800080fa <_vfprintf_r+0x13da>
800080ec:	10 36       	cp.w	r6,r8
800080ee:	c6 94       	brge	800081c0 <_vfprintf_r+0x14a0>
800080f0:	fa cc f9 44 	sub	r12,sp,-1724
800080f4:	f8 06 00 36 	add	r6,r12,r6<<0x3
800080f8:	c8 28       	rjmp	800081fc <_vfprintf_r+0x14dc>
800080fa:	ee ca ff ff 	sub	r10,r7,-1
800080fe:	10 37       	cp.w	r7,r8
80008100:	e0 84 00 81 	brge	80008202 <_vfprintf_r+0x14e2>
80008104:	fa cb f9 44 	sub	r11,sp,-1724
80008108:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000810c:	c7 78       	rjmp	800081fa <_vfprintf_r+0x14da>
8000810e:	ed b5 00 06 	bld	r5,0x6
80008112:	c4 b1       	brne	800081a8 <_vfprintf_r+0x1488>
80008114:	fa f8 06 b4 	ld.w	r8,sp[1716]
80008118:	40 3c       	lddsp	r12,sp[0xc]
8000811a:	58 0c       	cp.w	r12,0
8000811c:	c1 d0       	breq	80008156 <_vfprintf_r+0x1436>
8000811e:	10 36       	cp.w	r6,r8
80008120:	c0 64       	brge	8000812c <_vfprintf_r+0x140c>
80008122:	fa cb f9 44 	sub	r11,sp,-1724
80008126:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000812a:	c1 f8       	rjmp	80008168 <_vfprintf_r+0x1448>
8000812c:	fa c8 f9 50 	sub	r8,sp,-1712
80008130:	1a d8       	st.w	--sp,r8
80008132:	fa c8 fa b8 	sub	r8,sp,-1352
80008136:	1a d8       	st.w	--sp,r8
80008138:	fa c8 fb b4 	sub	r8,sp,-1100
8000813c:	1a d8       	st.w	--sp,r8
8000813e:	fa c8 f9 40 	sub	r8,sp,-1728
80008142:	fa c9 ff b4 	sub	r9,sp,-76
80008146:	04 9a       	mov	r10,r2
80008148:	0c 9b       	mov	r11,r6
8000814a:	08 9c       	mov	r12,r4
8000814c:	fe b0 f4 52 	rcall	800069f0 <get_arg>
80008150:	2f dd       	sub	sp,-12
80008152:	98 18       	ld.sh	r8,r12[0x2]
80008154:	c2 78       	rjmp	800081a2 <_vfprintf_r+0x1482>
80008156:	ee ca ff ff 	sub	r10,r7,-1
8000815a:	10 37       	cp.w	r7,r8
8000815c:	c0 a4       	brge	80008170 <_vfprintf_r+0x1450>
8000815e:	fa c9 f9 44 	sub	r9,sp,-1724
80008162:	14 97       	mov	r7,r10
80008164:	f2 06 00 36 	add	r6,r9,r6<<0x3
80008168:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000816c:	c1 b8       	rjmp	800081a2 <_vfprintf_r+0x1482>
8000816e:	d7 03       	nop
80008170:	41 09       	lddsp	r9,sp[0x40]
80008172:	59 f8       	cp.w	r8,31
80008174:	e0 89 00 13 	brgt	8000819a <_vfprintf_r+0x147a>
80008178:	f2 cb ff fc 	sub	r11,r9,-4
8000817c:	51 0b       	stdsp	sp[0x40],r11
8000817e:	72 09       	ld.w	r9,r9[0x0]
80008180:	fa c6 f9 44 	sub	r6,sp,-1724
80008184:	ec 08 00 3b 	add	r11,r6,r8<<0x3
80008188:	2f f8       	sub	r8,-1
8000818a:	f7 49 fd 88 	st.w	r11[-632],r9
8000818e:	fb 48 06 b4 	st.w	sp[1716],r8
80008192:	14 97       	mov	r7,r10
80008194:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
80008198:	c0 58       	rjmp	800081a2 <_vfprintf_r+0x1482>
8000819a:	92 18       	ld.sh	r8,r9[0x2]
8000819c:	14 97       	mov	r7,r10
8000819e:	2f c9       	sub	r9,-4
800081a0:	51 09       	stdsp	sp[0x40],r9
800081a2:	5c 78       	castu.h	r8
800081a4:	50 18       	stdsp	sp[0x4],r8
800081a6:	c4 68       	rjmp	80008232 <_vfprintf_r+0x1512>
800081a8:	fa f8 06 b4 	ld.w	r8,sp[1716]
800081ac:	40 3c       	lddsp	r12,sp[0xc]
800081ae:	58 0c       	cp.w	r12,0
800081b0:	c1 d0       	breq	800081ea <_vfprintf_r+0x14ca>
800081b2:	10 36       	cp.w	r6,r8
800081b4:	c0 64       	brge	800081c0 <_vfprintf_r+0x14a0>
800081b6:	fa cb f9 44 	sub	r11,sp,-1724
800081ba:	f6 06 00 36 	add	r6,r11,r6<<0x3
800081be:	c1 f8       	rjmp	800081fc <_vfprintf_r+0x14dc>
800081c0:	fa c8 f9 50 	sub	r8,sp,-1712
800081c4:	1a d8       	st.w	--sp,r8
800081c6:	fa c8 fa b8 	sub	r8,sp,-1352
800081ca:	0c 9b       	mov	r11,r6
800081cc:	1a d8       	st.w	--sp,r8
800081ce:	fa c8 fb b4 	sub	r8,sp,-1100
800081d2:	04 9a       	mov	r10,r2
800081d4:	1a d8       	st.w	--sp,r8
800081d6:	08 9c       	mov	r12,r4
800081d8:	fa c8 f9 40 	sub	r8,sp,-1728
800081dc:	fa c9 ff b4 	sub	r9,sp,-76
800081e0:	fe b0 f4 08 	rcall	800069f0 <get_arg>
800081e4:	2f dd       	sub	sp,-12
800081e6:	78 0b       	ld.w	r11,r12[0x0]
800081e8:	c2 48       	rjmp	80008230 <_vfprintf_r+0x1510>
800081ea:	ee ca ff ff 	sub	r10,r7,-1
800081ee:	10 37       	cp.w	r7,r8
800081f0:	c0 94       	brge	80008202 <_vfprintf_r+0x14e2>
800081f2:	fa c9 f9 44 	sub	r9,sp,-1724
800081f6:	f2 06 00 36 	add	r6,r9,r6<<0x3
800081fa:	14 97       	mov	r7,r10
800081fc:	ec fb fd 88 	ld.w	r11,r6[-632]
80008200:	c1 88       	rjmp	80008230 <_vfprintf_r+0x1510>
80008202:	41 09       	lddsp	r9,sp[0x40]
80008204:	59 f8       	cp.w	r8,31
80008206:	e0 89 00 11 	brgt	80008228 <_vfprintf_r+0x1508>
8000820a:	f2 cb ff fc 	sub	r11,r9,-4
8000820e:	51 0b       	stdsp	sp[0x40],r11
80008210:	fa c6 f9 44 	sub	r6,sp,-1724
80008214:	72 0b       	ld.w	r11,r9[0x0]
80008216:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000821a:	f3 4b fd 88 	st.w	r9[-632],r11
8000821e:	2f f8       	sub	r8,-1
80008220:	14 97       	mov	r7,r10
80008222:	fb 48 06 b4 	st.w	sp[1716],r8
80008226:	c0 58       	rjmp	80008230 <_vfprintf_r+0x1510>
80008228:	72 0b       	ld.w	r11,r9[0x0]
8000822a:	14 97       	mov	r7,r10
8000822c:	2f c9       	sub	r9,-4
8000822e:	51 09       	stdsp	sp[0x40],r9
80008230:	50 1b       	stdsp	sp[0x4],r11
80008232:	30 0e       	mov	lr,0
80008234:	50 0e       	stdsp	sp[0x0],lr
80008236:	40 08       	lddsp	r8,sp[0x0]
80008238:	40 1c       	lddsp	r12,sp[0x4]
8000823a:	18 48       	or	r8,r12
8000823c:	5f 19       	srne	r9
8000823e:	0a 98       	mov	r8,r5
80008240:	eb e9 00 09 	and	r9,r5,r9
80008244:	a1 b8       	sbr	r8,0x1
80008246:	58 09       	cp.w	r9,0
80008248:	c0 70       	breq	80008256 <_vfprintf_r+0x1536>
8000824a:	10 95       	mov	r5,r8
8000824c:	fb 60 06 b9 	st.b	sp[1721],r0
80008250:	33 08       	mov	r8,48
80008252:	fb 68 06 b8 	st.b	sp[1720],r8
80008256:	30 28       	mov	r8,2
80008258:	30 09       	mov	r9,0
8000825a:	fb 69 06 bb 	st.b	sp[1723],r9
8000825e:	0a 99       	mov	r9,r5
80008260:	a7 d9       	cbr	r9,0x7
80008262:	40 2b       	lddsp	r11,sp[0x8]
80008264:	40 16       	lddsp	r6,sp[0x4]
80008266:	58 0b       	cp.w	r11,0
80008268:	5f 1a       	srne	r10
8000826a:	f2 05 17 40 	movge	r5,r9
8000826e:	fa c2 f9 78 	sub	r2,sp,-1672
80008272:	40 09       	lddsp	r9,sp[0x0]
80008274:	0c 49       	or	r9,r6
80008276:	5f 19       	srne	r9
80008278:	f5 e9 10 09 	or	r9,r10,r9
8000827c:	c5 c0       	breq	80008334 <_vfprintf_r+0x1614>
8000827e:	30 19       	mov	r9,1
80008280:	f2 08 18 00 	cp.b	r8,r9
80008284:	c0 60       	breq	80008290 <_vfprintf_r+0x1570>
80008286:	30 29       	mov	r9,2
80008288:	f2 08 18 00 	cp.b	r8,r9
8000828c:	c0 41       	brne	80008294 <_vfprintf_r+0x1574>
8000828e:	c3 c8       	rjmp	80008306 <_vfprintf_r+0x15e6>
80008290:	04 96       	mov	r6,r2
80008292:	c3 08       	rjmp	800082f2 <_vfprintf_r+0x15d2>
80008294:	04 96       	mov	r6,r2
80008296:	fa e8 00 00 	ld.d	r8,sp[0]
8000829a:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000829e:	2d 0a       	sub	r10,-48
800082a0:	0c fa       	st.b	--r6,r10
800082a2:	f0 0b 16 03 	lsr	r11,r8,0x3
800082a6:	f2 0c 16 03 	lsr	r12,r9,0x3
800082aa:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
800082ae:	18 99       	mov	r9,r12
800082b0:	16 98       	mov	r8,r11
800082b2:	58 08       	cp.w	r8,0
800082b4:	5c 29       	cpc	r9
800082b6:	cf 21       	brne	8000829a <_vfprintf_r+0x157a>
800082b8:	fa e9 00 00 	st.d	sp[0],r8
800082bc:	ed b5 00 00 	bld	r5,0x0
800082c0:	c4 51       	brne	8000834a <_vfprintf_r+0x162a>
800082c2:	33 09       	mov	r9,48
800082c4:	f2 0a 18 00 	cp.b	r10,r9
800082c8:	c4 10       	breq	8000834a <_vfprintf_r+0x162a>
800082ca:	0c f9       	st.b	--r6,r9
800082cc:	c3 f8       	rjmp	8000834a <_vfprintf_r+0x162a>
800082ce:	fa ea 00 00 	ld.d	r10,sp[0]
800082d2:	30 a8       	mov	r8,10
800082d4:	30 09       	mov	r9,0
800082d6:	e0 a0 1a 19 	rcall	8000b708 <__avr32_umod64>
800082da:	30 a8       	mov	r8,10
800082dc:	2d 0a       	sub	r10,-48
800082de:	30 09       	mov	r9,0
800082e0:	ac 8a       	st.b	r6[0x0],r10
800082e2:	fa ea 00 00 	ld.d	r10,sp[0]
800082e6:	e0 a0 18 df 	rcall	8000b4a4 <__avr32_udiv64>
800082ea:	16 99       	mov	r9,r11
800082ec:	14 98       	mov	r8,r10
800082ee:	fa e9 00 00 	st.d	sp[0],r8
800082f2:	20 16       	sub	r6,1
800082f4:	fa ea 00 00 	ld.d	r10,sp[0]
800082f8:	58 9a       	cp.w	r10,9
800082fa:	5c 2b       	cpc	r11
800082fc:	fe 9b ff e9 	brhi	800082ce <_vfprintf_r+0x15ae>
80008300:	1b f8       	ld.ub	r8,sp[0x7]
80008302:	2d 08       	sub	r8,-48
80008304:	c2 08       	rjmp	80008344 <_vfprintf_r+0x1624>
80008306:	04 96       	mov	r6,r2
80008308:	fa e8 00 00 	ld.d	r8,sp[0]
8000830c:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
80008310:	40 de       	lddsp	lr,sp[0x34]
80008312:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
80008316:	0c fa       	st.b	--r6,r10
80008318:	f2 0b 16 04 	lsr	r11,r9,0x4
8000831c:	f0 0a 16 04 	lsr	r10,r8,0x4
80008320:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
80008324:	16 99       	mov	r9,r11
80008326:	14 98       	mov	r8,r10
80008328:	58 08       	cp.w	r8,0
8000832a:	5c 29       	cpc	r9
8000832c:	cf 01       	brne	8000830c <_vfprintf_r+0x15ec>
8000832e:	fa e9 00 00 	st.d	sp[0],r8
80008332:	c0 c8       	rjmp	8000834a <_vfprintf_r+0x162a>
80008334:	58 08       	cp.w	r8,0
80008336:	c0 91       	brne	80008348 <_vfprintf_r+0x1628>
80008338:	ed b5 00 00 	bld	r5,0x0
8000833c:	c0 61       	brne	80008348 <_vfprintf_r+0x1628>
8000833e:	fa c6 f9 79 	sub	r6,sp,-1671
80008342:	33 08       	mov	r8,48
80008344:	ac 88       	st.b	r6[0x0],r8
80008346:	c0 28       	rjmp	8000834a <_vfprintf_r+0x162a>
80008348:	04 96       	mov	r6,r2
8000834a:	0c 12       	sub	r2,r6
8000834c:	c1 c8       	rjmp	80008384 <_vfprintf_r+0x1664>
8000834e:	50 a7       	stdsp	sp[0x28],r7
80008350:	50 80       	stdsp	sp[0x20],r0
80008352:	40 93       	lddsp	r3,sp[0x24]
80008354:	0c 97       	mov	r7,r6
80008356:	10 90       	mov	r0,r8
80008358:	04 94       	mov	r4,r2
8000835a:	40 41       	lddsp	r1,sp[0x10]
8000835c:	58 08       	cp.w	r8,0
8000835e:	e0 80 04 4f 	breq	80008bfc <_vfprintf_r+0x1edc>
80008362:	fb 68 06 60 	st.b	sp[1632],r8
80008366:	30 0c       	mov	r12,0
80008368:	30 08       	mov	r8,0
8000836a:	30 12       	mov	r2,1
8000836c:	fb 68 06 bb 	st.b	sp[1723],r8
80008370:	50 2c       	stdsp	sp[0x8],r12
80008372:	fa c6 f9 a0 	sub	r6,sp,-1632
80008376:	c0 78       	rjmp	80008384 <_vfprintf_r+0x1664>
80008378:	30 0b       	mov	r11,0
8000837a:	50 2b       	stdsp	sp[0x8],r11
8000837c:	c0 48       	rjmp	80008384 <_vfprintf_r+0x1664>
8000837e:	40 22       	lddsp	r2,sp[0x8]
80008380:	30 0a       	mov	r10,0
80008382:	50 2a       	stdsp	sp[0x8],r10
80008384:	40 29       	lddsp	r9,sp[0x8]
80008386:	e4 09 0c 49 	max	r9,r2,r9
8000838a:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000838e:	50 39       	stdsp	sp[0xc],r9
80008390:	0a 9e       	mov	lr,r5
80008392:	30 09       	mov	r9,0
80008394:	e2 1e 00 02 	andl	lr,0x2,COH
80008398:	f2 08 18 00 	cp.b	r8,r9
8000839c:	fb f8 10 03 	ld.wne	r8,sp[0xc]
800083a0:	f7 b8 01 ff 	subne	r8,-1
800083a4:	fb f8 1a 03 	st.wne	sp[0xc],r8
800083a8:	0a 9b       	mov	r11,r5
800083aa:	58 0e       	cp.w	lr,0
800083ac:	fb fc 10 03 	ld.wne	r12,sp[0xc]
800083b0:	f7 bc 01 fe 	subne	r12,-2
800083b4:	fb fc 1a 03 	st.wne	sp[0xc],r12
800083b8:	e2 1b 00 84 	andl	r11,0x84,COH
800083bc:	50 fe       	stdsp	sp[0x3c],lr
800083be:	50 9b       	stdsp	sp[0x24],r11
800083c0:	c4 71       	brne	8000844e <_vfprintf_r+0x172e>
800083c2:	40 8a       	lddsp	r10,sp[0x20]
800083c4:	40 39       	lddsp	r9,sp[0xc]
800083c6:	12 1a       	sub	r10,r9
800083c8:	50 4a       	stdsp	sp[0x10],r10
800083ca:	58 0a       	cp.w	r10,0
800083cc:	e0 89 00 20 	brgt	8000840c <_vfprintf_r+0x16ec>
800083d0:	c3 f8       	rjmp	8000844e <_vfprintf_r+0x172e>
800083d2:	2f 09       	sub	r9,-16
800083d4:	2f f8       	sub	r8,-1
800083d6:	fe ce b8 6e 	sub	lr,pc,-18322
800083da:	31 0c       	mov	r12,16
800083dc:	fb 49 06 90 	st.w	sp[1680],r9
800083e0:	87 0e       	st.w	r3[0x0],lr
800083e2:	87 1c       	st.w	r3[0x4],r12
800083e4:	fb 48 06 8c 	st.w	sp[1676],r8
800083e8:	58 78       	cp.w	r8,7
800083ea:	e0 89 00 04 	brgt	800083f2 <_vfprintf_r+0x16d2>
800083ee:	2f 83       	sub	r3,-8
800083f0:	c0 b8       	rjmp	80008406 <_vfprintf_r+0x16e6>
800083f2:	fa ca f9 78 	sub	r10,sp,-1672
800083f6:	02 9b       	mov	r11,r1
800083f8:	08 9c       	mov	r12,r4
800083fa:	fe b0 f4 85 	rcall	80006d04 <__sprint_r>
800083fe:	e0 81 04 10 	brne	80008c1e <_vfprintf_r+0x1efe>
80008402:	fa c3 f9 e0 	sub	r3,sp,-1568
80008406:	40 4b       	lddsp	r11,sp[0x10]
80008408:	21 0b       	sub	r11,16
8000840a:	50 4b       	stdsp	sp[0x10],r11
8000840c:	fa f9 06 90 	ld.w	r9,sp[1680]
80008410:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008414:	fe ca b8 ac 	sub	r10,pc,-18260
80008418:	40 4e       	lddsp	lr,sp[0x10]
8000841a:	59 0e       	cp.w	lr,16
8000841c:	fe 99 ff db 	brgt	800083d2 <_vfprintf_r+0x16b2>
80008420:	1c 09       	add	r9,lr
80008422:	2f f8       	sub	r8,-1
80008424:	87 0a       	st.w	r3[0x0],r10
80008426:	fb 49 06 90 	st.w	sp[1680],r9
8000842a:	87 1e       	st.w	r3[0x4],lr
8000842c:	fb 48 06 8c 	st.w	sp[1676],r8
80008430:	58 78       	cp.w	r8,7
80008432:	e0 89 00 04 	brgt	8000843a <_vfprintf_r+0x171a>
80008436:	2f 83       	sub	r3,-8
80008438:	c0 b8       	rjmp	8000844e <_vfprintf_r+0x172e>
8000843a:	fa ca f9 78 	sub	r10,sp,-1672
8000843e:	02 9b       	mov	r11,r1
80008440:	08 9c       	mov	r12,r4
80008442:	fe b0 f4 61 	rcall	80006d04 <__sprint_r>
80008446:	e0 81 03 ec 	brne	80008c1e <_vfprintf_r+0x1efe>
8000844a:	fa c3 f9 e0 	sub	r3,sp,-1568
8000844e:	30 09       	mov	r9,0
80008450:	fb 38 06 bb 	ld.ub	r8,sp[1723]
80008454:	f2 08 18 00 	cp.b	r8,r9
80008458:	c1 f0       	breq	80008496 <_vfprintf_r+0x1776>
8000845a:	fa f8 06 90 	ld.w	r8,sp[1680]
8000845e:	fa c9 f9 45 	sub	r9,sp,-1723
80008462:	2f f8       	sub	r8,-1
80008464:	87 09       	st.w	r3[0x0],r9
80008466:	fb 48 06 90 	st.w	sp[1680],r8
8000846a:	30 19       	mov	r9,1
8000846c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008470:	87 19       	st.w	r3[0x4],r9
80008472:	2f f8       	sub	r8,-1
80008474:	fb 48 06 8c 	st.w	sp[1676],r8
80008478:	58 78       	cp.w	r8,7
8000847a:	e0 89 00 04 	brgt	80008482 <_vfprintf_r+0x1762>
8000847e:	2f 83       	sub	r3,-8
80008480:	c0 b8       	rjmp	80008496 <_vfprintf_r+0x1776>
80008482:	fa ca f9 78 	sub	r10,sp,-1672
80008486:	02 9b       	mov	r11,r1
80008488:	08 9c       	mov	r12,r4
8000848a:	fe b0 f4 3d 	rcall	80006d04 <__sprint_r>
8000848e:	e0 81 03 c8 	brne	80008c1e <_vfprintf_r+0x1efe>
80008492:	fa c3 f9 e0 	sub	r3,sp,-1568
80008496:	40 fc       	lddsp	r12,sp[0x3c]
80008498:	58 0c       	cp.w	r12,0
8000849a:	c1 f0       	breq	800084d8 <_vfprintf_r+0x17b8>
8000849c:	fa f8 06 90 	ld.w	r8,sp[1680]
800084a0:	fa c9 f9 48 	sub	r9,sp,-1720
800084a4:	2f e8       	sub	r8,-2
800084a6:	87 09       	st.w	r3[0x0],r9
800084a8:	fb 48 06 90 	st.w	sp[1680],r8
800084ac:	30 29       	mov	r9,2
800084ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
800084b2:	87 19       	st.w	r3[0x4],r9
800084b4:	2f f8       	sub	r8,-1
800084b6:	fb 48 06 8c 	st.w	sp[1676],r8
800084ba:	58 78       	cp.w	r8,7
800084bc:	e0 89 00 04 	brgt	800084c4 <_vfprintf_r+0x17a4>
800084c0:	2f 83       	sub	r3,-8
800084c2:	c0 b8       	rjmp	800084d8 <_vfprintf_r+0x17b8>
800084c4:	fa ca f9 78 	sub	r10,sp,-1672
800084c8:	02 9b       	mov	r11,r1
800084ca:	08 9c       	mov	r12,r4
800084cc:	fe b0 f4 1c 	rcall	80006d04 <__sprint_r>
800084d0:	e0 81 03 a7 	brne	80008c1e <_vfprintf_r+0x1efe>
800084d4:	fa c3 f9 e0 	sub	r3,sp,-1568
800084d8:	40 9b       	lddsp	r11,sp[0x24]
800084da:	e0 4b 00 80 	cp.w	r11,128
800084de:	c4 71       	brne	8000856c <_vfprintf_r+0x184c>
800084e0:	40 8a       	lddsp	r10,sp[0x20]
800084e2:	40 39       	lddsp	r9,sp[0xc]
800084e4:	12 1a       	sub	r10,r9
800084e6:	50 4a       	stdsp	sp[0x10],r10
800084e8:	58 0a       	cp.w	r10,0
800084ea:	e0 89 00 20 	brgt	8000852a <_vfprintf_r+0x180a>
800084ee:	c3 f8       	rjmp	8000856c <_vfprintf_r+0x184c>
800084f0:	2f 09       	sub	r9,-16
800084f2:	2f f8       	sub	r8,-1
800084f4:	fe ce b9 7c 	sub	lr,pc,-18052
800084f8:	31 0c       	mov	r12,16
800084fa:	fb 49 06 90 	st.w	sp[1680],r9
800084fe:	87 0e       	st.w	r3[0x0],lr
80008500:	87 1c       	st.w	r3[0x4],r12
80008502:	fb 48 06 8c 	st.w	sp[1676],r8
80008506:	58 78       	cp.w	r8,7
80008508:	e0 89 00 04 	brgt	80008510 <_vfprintf_r+0x17f0>
8000850c:	2f 83       	sub	r3,-8
8000850e:	c0 b8       	rjmp	80008524 <_vfprintf_r+0x1804>
80008510:	fa ca f9 78 	sub	r10,sp,-1672
80008514:	02 9b       	mov	r11,r1
80008516:	08 9c       	mov	r12,r4
80008518:	fe b0 f3 f6 	rcall	80006d04 <__sprint_r>
8000851c:	e0 81 03 81 	brne	80008c1e <_vfprintf_r+0x1efe>
80008520:	fa c3 f9 e0 	sub	r3,sp,-1568
80008524:	40 4b       	lddsp	r11,sp[0x10]
80008526:	21 0b       	sub	r11,16
80008528:	50 4b       	stdsp	sp[0x10],r11
8000852a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000852e:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008532:	fe ca b9 ba 	sub	r10,pc,-17990
80008536:	40 4e       	lddsp	lr,sp[0x10]
80008538:	59 0e       	cp.w	lr,16
8000853a:	fe 99 ff db 	brgt	800084f0 <_vfprintf_r+0x17d0>
8000853e:	1c 09       	add	r9,lr
80008540:	2f f8       	sub	r8,-1
80008542:	87 0a       	st.w	r3[0x0],r10
80008544:	fb 49 06 90 	st.w	sp[1680],r9
80008548:	87 1e       	st.w	r3[0x4],lr
8000854a:	fb 48 06 8c 	st.w	sp[1676],r8
8000854e:	58 78       	cp.w	r8,7
80008550:	e0 89 00 04 	brgt	80008558 <_vfprintf_r+0x1838>
80008554:	2f 83       	sub	r3,-8
80008556:	c0 b8       	rjmp	8000856c <_vfprintf_r+0x184c>
80008558:	fa ca f9 78 	sub	r10,sp,-1672
8000855c:	02 9b       	mov	r11,r1
8000855e:	08 9c       	mov	r12,r4
80008560:	fe b0 f3 d2 	rcall	80006d04 <__sprint_r>
80008564:	e0 81 03 5d 	brne	80008c1e <_vfprintf_r+0x1efe>
80008568:	fa c3 f9 e0 	sub	r3,sp,-1568
8000856c:	40 2c       	lddsp	r12,sp[0x8]
8000856e:	04 1c       	sub	r12,r2
80008570:	50 2c       	stdsp	sp[0x8],r12
80008572:	58 0c       	cp.w	r12,0
80008574:	e0 89 00 20 	brgt	800085b4 <_vfprintf_r+0x1894>
80008578:	c3 f8       	rjmp	800085f6 <_vfprintf_r+0x18d6>
8000857a:	2f 09       	sub	r9,-16
8000857c:	2f f8       	sub	r8,-1
8000857e:	fe cb ba 06 	sub	r11,pc,-17914
80008582:	31 0a       	mov	r10,16
80008584:	fb 49 06 90 	st.w	sp[1680],r9
80008588:	87 0b       	st.w	r3[0x0],r11
8000858a:	87 1a       	st.w	r3[0x4],r10
8000858c:	fb 48 06 8c 	st.w	sp[1676],r8
80008590:	58 78       	cp.w	r8,7
80008592:	e0 89 00 04 	brgt	8000859a <_vfprintf_r+0x187a>
80008596:	2f 83       	sub	r3,-8
80008598:	c0 b8       	rjmp	800085ae <_vfprintf_r+0x188e>
8000859a:	fa ca f9 78 	sub	r10,sp,-1672
8000859e:	02 9b       	mov	r11,r1
800085a0:	08 9c       	mov	r12,r4
800085a2:	fe b0 f3 b1 	rcall	80006d04 <__sprint_r>
800085a6:	e0 81 03 3c 	brne	80008c1e <_vfprintf_r+0x1efe>
800085aa:	fa c3 f9 e0 	sub	r3,sp,-1568
800085ae:	40 29       	lddsp	r9,sp[0x8]
800085b0:	21 09       	sub	r9,16
800085b2:	50 29       	stdsp	sp[0x8],r9
800085b4:	fa f9 06 90 	ld.w	r9,sp[1680]
800085b8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800085bc:	fe ca ba 44 	sub	r10,pc,-17852
800085c0:	40 2e       	lddsp	lr,sp[0x8]
800085c2:	59 0e       	cp.w	lr,16
800085c4:	fe 99 ff db 	brgt	8000857a <_vfprintf_r+0x185a>
800085c8:	1c 09       	add	r9,lr
800085ca:	2f f8       	sub	r8,-1
800085cc:	87 0a       	st.w	r3[0x0],r10
800085ce:	fb 49 06 90 	st.w	sp[1680],r9
800085d2:	87 1e       	st.w	r3[0x4],lr
800085d4:	fb 48 06 8c 	st.w	sp[1676],r8
800085d8:	58 78       	cp.w	r8,7
800085da:	e0 89 00 04 	brgt	800085e2 <_vfprintf_r+0x18c2>
800085de:	2f 83       	sub	r3,-8
800085e0:	c0 b8       	rjmp	800085f6 <_vfprintf_r+0x18d6>
800085e2:	fa ca f9 78 	sub	r10,sp,-1672
800085e6:	02 9b       	mov	r11,r1
800085e8:	08 9c       	mov	r12,r4
800085ea:	fe b0 f3 8d 	rcall	80006d04 <__sprint_r>
800085ee:	e0 81 03 18 	brne	80008c1e <_vfprintf_r+0x1efe>
800085f2:	fa c3 f9 e0 	sub	r3,sp,-1568
800085f6:	ed b5 00 08 	bld	r5,0x8
800085fa:	c0 b0       	breq	80008610 <_vfprintf_r+0x18f0>
800085fc:	fa f8 06 90 	ld.w	r8,sp[1680]
80008600:	87 12       	st.w	r3[0x4],r2
80008602:	87 06       	st.w	r3[0x0],r6
80008604:	f0 02 00 02 	add	r2,r8,r2
80008608:	fb 42 06 90 	st.w	sp[1680],r2
8000860c:	e0 8f 01 d4 	bral	800089b4 <_vfprintf_r+0x1c94>
80008610:	e0 40 00 65 	cp.w	r0,101
80008614:	e0 8a 01 d6 	brle	800089c0 <_vfprintf_r+0x1ca0>
80008618:	30 08       	mov	r8,0
8000861a:	30 09       	mov	r9,0
8000861c:	40 5b       	lddsp	r11,sp[0x14]
8000861e:	40 7a       	lddsp	r10,sp[0x1c]
80008620:	e0 a0 15 3b 	rcall	8000b096 <__avr32_f64_cmp_eq>
80008624:	c7 90       	breq	80008716 <_vfprintf_r+0x19f6>
80008626:	fa f8 06 90 	ld.w	r8,sp[1680]
8000862a:	fe c9 ba c6 	sub	r9,pc,-17722
8000862e:	2f f8       	sub	r8,-1
80008630:	87 09       	st.w	r3[0x0],r9
80008632:	fb 48 06 90 	st.w	sp[1680],r8
80008636:	30 19       	mov	r9,1
80008638:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000863c:	87 19       	st.w	r3[0x4],r9
8000863e:	2f f8       	sub	r8,-1
80008640:	fb 48 06 8c 	st.w	sp[1676],r8
80008644:	58 78       	cp.w	r8,7
80008646:	e0 89 00 05 	brgt	80008650 <_vfprintf_r+0x1930>
8000864a:	2f 83       	sub	r3,-8
8000864c:	c0 c8       	rjmp	80008664 <_vfprintf_r+0x1944>
8000864e:	d7 03       	nop
80008650:	fa ca f9 78 	sub	r10,sp,-1672
80008654:	02 9b       	mov	r11,r1
80008656:	08 9c       	mov	r12,r4
80008658:	fe b0 f3 56 	rcall	80006d04 <__sprint_r>
8000865c:	e0 81 02 e1 	brne	80008c1e <_vfprintf_r+0x1efe>
80008660:	fa c3 f9 e0 	sub	r3,sp,-1568
80008664:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008668:	40 6c       	lddsp	r12,sp[0x18]
8000866a:	18 38       	cp.w	r8,r12
8000866c:	c0 55       	brlt	80008676 <_vfprintf_r+0x1956>
8000866e:	ed b5 00 00 	bld	r5,0x0
80008672:	e0 81 02 6b 	brne	80008b48 <_vfprintf_r+0x1e28>
80008676:	fa f8 06 90 	ld.w	r8,sp[1680]
8000867a:	2f f8       	sub	r8,-1
8000867c:	40 cb       	lddsp	r11,sp[0x30]
8000867e:	fb 48 06 90 	st.w	sp[1680],r8
80008682:	30 19       	mov	r9,1
80008684:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008688:	87 0b       	st.w	r3[0x0],r11
8000868a:	2f f8       	sub	r8,-1
8000868c:	87 19       	st.w	r3[0x4],r9
8000868e:	fb 48 06 8c 	st.w	sp[1676],r8
80008692:	58 78       	cp.w	r8,7
80008694:	e0 89 00 04 	brgt	8000869c <_vfprintf_r+0x197c>
80008698:	2f 83       	sub	r3,-8
8000869a:	c0 b8       	rjmp	800086b0 <_vfprintf_r+0x1990>
8000869c:	fa ca f9 78 	sub	r10,sp,-1672
800086a0:	02 9b       	mov	r11,r1
800086a2:	08 9c       	mov	r12,r4
800086a4:	fe b0 f3 30 	rcall	80006d04 <__sprint_r>
800086a8:	e0 81 02 bb 	brne	80008c1e <_vfprintf_r+0x1efe>
800086ac:	fa c3 f9 e0 	sub	r3,sp,-1568
800086b0:	40 66       	lddsp	r6,sp[0x18]
800086b2:	20 16       	sub	r6,1
800086b4:	58 06       	cp.w	r6,0
800086b6:	e0 89 00 1d 	brgt	800086f0 <_vfprintf_r+0x19d0>
800086ba:	e0 8f 02 47 	bral	80008b48 <_vfprintf_r+0x1e28>
800086be:	2f 09       	sub	r9,-16
800086c0:	2f f8       	sub	r8,-1
800086c2:	fb 49 06 90 	st.w	sp[1680],r9
800086c6:	87 02       	st.w	r3[0x0],r2
800086c8:	87 10       	st.w	r3[0x4],r0
800086ca:	fb 48 06 8c 	st.w	sp[1676],r8
800086ce:	58 78       	cp.w	r8,7
800086d0:	e0 89 00 04 	brgt	800086d8 <_vfprintf_r+0x19b8>
800086d4:	2f 83       	sub	r3,-8
800086d6:	c0 b8       	rjmp	800086ec <_vfprintf_r+0x19cc>
800086d8:	fa ca f9 78 	sub	r10,sp,-1672
800086dc:	02 9b       	mov	r11,r1
800086de:	08 9c       	mov	r12,r4
800086e0:	fe b0 f3 12 	rcall	80006d04 <__sprint_r>
800086e4:	e0 81 02 9d 	brne	80008c1e <_vfprintf_r+0x1efe>
800086e8:	fa c3 f9 e0 	sub	r3,sp,-1568
800086ec:	21 06       	sub	r6,16
800086ee:	c0 48       	rjmp	800086f6 <_vfprintf_r+0x19d6>
800086f0:	fe c2 bb 78 	sub	r2,pc,-17544
800086f4:	31 00       	mov	r0,16
800086f6:	fa f9 06 90 	ld.w	r9,sp[1680]
800086fa:	fa f8 06 8c 	ld.w	r8,sp[1676]
800086fe:	fe ca bb 86 	sub	r10,pc,-17530
80008702:	59 06       	cp.w	r6,16
80008704:	fe 99 ff dd 	brgt	800086be <_vfprintf_r+0x199e>
80008708:	0c 09       	add	r9,r6
8000870a:	87 0a       	st.w	r3[0x0],r10
8000870c:	fb 49 06 90 	st.w	sp[1680],r9
80008710:	2f f8       	sub	r8,-1
80008712:	87 16       	st.w	r3[0x4],r6
80008714:	c5 39       	rjmp	800089ba <_vfprintf_r+0x1c9a>
80008716:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000871a:	58 0a       	cp.w	r10,0
8000871c:	e0 89 00 92 	brgt	80008840 <_vfprintf_r+0x1b20>
80008720:	fa f8 06 90 	ld.w	r8,sp[1680]
80008724:	fe c9 bb c0 	sub	r9,pc,-17472
80008728:	2f f8       	sub	r8,-1
8000872a:	87 09       	st.w	r3[0x0],r9
8000872c:	fb 48 06 90 	st.w	sp[1680],r8
80008730:	30 19       	mov	r9,1
80008732:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008736:	87 19       	st.w	r3[0x4],r9
80008738:	2f f8       	sub	r8,-1
8000873a:	fb 48 06 8c 	st.w	sp[1676],r8
8000873e:	58 78       	cp.w	r8,7
80008740:	e0 89 00 04 	brgt	80008748 <_vfprintf_r+0x1a28>
80008744:	2f 83       	sub	r3,-8
80008746:	c0 b8       	rjmp	8000875c <_vfprintf_r+0x1a3c>
80008748:	fa ca f9 78 	sub	r10,sp,-1672
8000874c:	02 9b       	mov	r11,r1
8000874e:	08 9c       	mov	r12,r4
80008750:	fe b0 f2 da 	rcall	80006d04 <__sprint_r>
80008754:	e0 81 02 65 	brne	80008c1e <_vfprintf_r+0x1efe>
80008758:	fa c3 f9 e0 	sub	r3,sp,-1568
8000875c:	fa f8 06 ac 	ld.w	r8,sp[1708]
80008760:	58 08       	cp.w	r8,0
80008762:	c0 81       	brne	80008772 <_vfprintf_r+0x1a52>
80008764:	40 6a       	lddsp	r10,sp[0x18]
80008766:	58 0a       	cp.w	r10,0
80008768:	c0 51       	brne	80008772 <_vfprintf_r+0x1a52>
8000876a:	ed b5 00 00 	bld	r5,0x0
8000876e:	e0 81 01 ed 	brne	80008b48 <_vfprintf_r+0x1e28>
80008772:	40 c9       	lddsp	r9,sp[0x30]
80008774:	fa f8 06 90 	ld.w	r8,sp[1680]
80008778:	2f f8       	sub	r8,-1
8000877a:	87 09       	st.w	r3[0x0],r9
8000877c:	fb 48 06 90 	st.w	sp[1680],r8
80008780:	30 19       	mov	r9,1
80008782:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008786:	87 19       	st.w	r3[0x4],r9
80008788:	2f f8       	sub	r8,-1
8000878a:	fb 48 06 8c 	st.w	sp[1676],r8
8000878e:	58 78       	cp.w	r8,7
80008790:	e0 89 00 04 	brgt	80008798 <_vfprintf_r+0x1a78>
80008794:	2f 83       	sub	r3,-8
80008796:	c0 b8       	rjmp	800087ac <_vfprintf_r+0x1a8c>
80008798:	fa ca f9 78 	sub	r10,sp,-1672
8000879c:	02 9b       	mov	r11,r1
8000879e:	08 9c       	mov	r12,r4
800087a0:	fe b0 f2 b2 	rcall	80006d04 <__sprint_r>
800087a4:	e0 81 02 3d 	brne	80008c1e <_vfprintf_r+0x1efe>
800087a8:	fa c3 f9 e0 	sub	r3,sp,-1568
800087ac:	fa f2 06 ac 	ld.w	r2,sp[1708]
800087b0:	5c 32       	neg	r2
800087b2:	58 02       	cp.w	r2,0
800087b4:	e0 89 00 1d 	brgt	800087ee <_vfprintf_r+0x1ace>
800087b8:	c3 d8       	rjmp	80008832 <_vfprintf_r+0x1b12>
800087ba:	2f 09       	sub	r9,-16
800087bc:	2f f8       	sub	r8,-1
800087be:	31 0e       	mov	lr,16
800087c0:	fb 49 06 90 	st.w	sp[1680],r9
800087c4:	87 00       	st.w	r3[0x0],r0
800087c6:	87 1e       	st.w	r3[0x4],lr
800087c8:	fb 48 06 8c 	st.w	sp[1676],r8
800087cc:	58 78       	cp.w	r8,7
800087ce:	e0 89 00 04 	brgt	800087d6 <_vfprintf_r+0x1ab6>
800087d2:	2f 83       	sub	r3,-8
800087d4:	c0 b8       	rjmp	800087ea <_vfprintf_r+0x1aca>
800087d6:	fa ca f9 78 	sub	r10,sp,-1672
800087da:	02 9b       	mov	r11,r1
800087dc:	08 9c       	mov	r12,r4
800087de:	fe b0 f2 93 	rcall	80006d04 <__sprint_r>
800087e2:	e0 81 02 1e 	brne	80008c1e <_vfprintf_r+0x1efe>
800087e6:	fa c3 f9 e0 	sub	r3,sp,-1568
800087ea:	21 02       	sub	r2,16
800087ec:	c0 38       	rjmp	800087f2 <_vfprintf_r+0x1ad2>
800087ee:	fe c0 bc 76 	sub	r0,pc,-17290
800087f2:	fa f9 06 90 	ld.w	r9,sp[1680]
800087f6:	fa f8 06 8c 	ld.w	r8,sp[1676]
800087fa:	fe ca bc 82 	sub	r10,pc,-17278
800087fe:	59 02       	cp.w	r2,16
80008800:	fe 99 ff dd 	brgt	800087ba <_vfprintf_r+0x1a9a>
80008804:	04 09       	add	r9,r2
80008806:	2f f8       	sub	r8,-1
80008808:	87 0a       	st.w	r3[0x0],r10
8000880a:	fb 49 06 90 	st.w	sp[1680],r9
8000880e:	87 12       	st.w	r3[0x4],r2
80008810:	fb 48 06 8c 	st.w	sp[1676],r8
80008814:	58 78       	cp.w	r8,7
80008816:	e0 89 00 04 	brgt	8000881e <_vfprintf_r+0x1afe>
8000881a:	2f 83       	sub	r3,-8
8000881c:	c0 b8       	rjmp	80008832 <_vfprintf_r+0x1b12>
8000881e:	fa ca f9 78 	sub	r10,sp,-1672
80008822:	02 9b       	mov	r11,r1
80008824:	08 9c       	mov	r12,r4
80008826:	fe b0 f2 6f 	rcall	80006d04 <__sprint_r>
8000882a:	e0 81 01 fa 	brne	80008c1e <_vfprintf_r+0x1efe>
8000882e:	fa c3 f9 e0 	sub	r3,sp,-1568
80008832:	40 6c       	lddsp	r12,sp[0x18]
80008834:	fa f8 06 90 	ld.w	r8,sp[1680]
80008838:	87 06       	st.w	r3[0x0],r6
8000883a:	87 1c       	st.w	r3[0x4],r12
8000883c:	18 08       	add	r8,r12
8000883e:	cb 98       	rjmp	800089b0 <_vfprintf_r+0x1c90>
80008840:	fa f9 06 90 	ld.w	r9,sp[1680]
80008844:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008848:	40 6b       	lddsp	r11,sp[0x18]
8000884a:	16 3a       	cp.w	r10,r11
8000884c:	c6 f5       	brlt	8000892a <_vfprintf_r+0x1c0a>
8000884e:	16 09       	add	r9,r11
80008850:	2f f8       	sub	r8,-1
80008852:	87 06       	st.w	r3[0x0],r6
80008854:	fb 49 06 90 	st.w	sp[1680],r9
80008858:	87 1b       	st.w	r3[0x4],r11
8000885a:	fb 48 06 8c 	st.w	sp[1676],r8
8000885e:	58 78       	cp.w	r8,7
80008860:	e0 89 00 04 	brgt	80008868 <_vfprintf_r+0x1b48>
80008864:	2f 83       	sub	r3,-8
80008866:	c0 b8       	rjmp	8000887c <_vfprintf_r+0x1b5c>
80008868:	fa ca f9 78 	sub	r10,sp,-1672
8000886c:	02 9b       	mov	r11,r1
8000886e:	08 9c       	mov	r12,r4
80008870:	fe b0 f2 4a 	rcall	80006d04 <__sprint_r>
80008874:	e0 81 01 d5 	brne	80008c1e <_vfprintf_r+0x1efe>
80008878:	fa c3 f9 e0 	sub	r3,sp,-1568
8000887c:	fa f6 06 ac 	ld.w	r6,sp[1708]
80008880:	40 6a       	lddsp	r10,sp[0x18]
80008882:	14 16       	sub	r6,r10
80008884:	58 06       	cp.w	r6,0
80008886:	e0 89 00 1c 	brgt	800088be <_vfprintf_r+0x1b9e>
8000888a:	c3 d8       	rjmp	80008904 <_vfprintf_r+0x1be4>
8000888c:	2f 09       	sub	r9,-16
8000888e:	2f f8       	sub	r8,-1
80008890:	fb 49 06 90 	st.w	sp[1680],r9
80008894:	87 02       	st.w	r3[0x0],r2
80008896:	87 10       	st.w	r3[0x4],r0
80008898:	fb 48 06 8c 	st.w	sp[1676],r8
8000889c:	58 78       	cp.w	r8,7
8000889e:	e0 89 00 04 	brgt	800088a6 <_vfprintf_r+0x1b86>
800088a2:	2f 83       	sub	r3,-8
800088a4:	c0 b8       	rjmp	800088ba <_vfprintf_r+0x1b9a>
800088a6:	fa ca f9 78 	sub	r10,sp,-1672
800088aa:	02 9b       	mov	r11,r1
800088ac:	08 9c       	mov	r12,r4
800088ae:	fe b0 f2 2b 	rcall	80006d04 <__sprint_r>
800088b2:	e0 81 01 b6 	brne	80008c1e <_vfprintf_r+0x1efe>
800088b6:	fa c3 f9 e0 	sub	r3,sp,-1568
800088ba:	21 06       	sub	r6,16
800088bc:	c0 48       	rjmp	800088c4 <_vfprintf_r+0x1ba4>
800088be:	fe c2 bd 46 	sub	r2,pc,-17082
800088c2:	31 00       	mov	r0,16
800088c4:	fa f9 06 90 	ld.w	r9,sp[1680]
800088c8:	fa f8 06 8c 	ld.w	r8,sp[1676]
800088cc:	fe ca bd 54 	sub	r10,pc,-17068
800088d0:	59 06       	cp.w	r6,16
800088d2:	fe 99 ff dd 	brgt	8000888c <_vfprintf_r+0x1b6c>
800088d6:	0c 09       	add	r9,r6
800088d8:	2f f8       	sub	r8,-1
800088da:	87 0a       	st.w	r3[0x0],r10
800088dc:	fb 49 06 90 	st.w	sp[1680],r9
800088e0:	87 16       	st.w	r3[0x4],r6
800088e2:	fb 48 06 8c 	st.w	sp[1676],r8
800088e6:	58 78       	cp.w	r8,7
800088e8:	e0 89 00 04 	brgt	800088f0 <_vfprintf_r+0x1bd0>
800088ec:	2f 83       	sub	r3,-8
800088ee:	c0 b8       	rjmp	80008904 <_vfprintf_r+0x1be4>
800088f0:	fa ca f9 78 	sub	r10,sp,-1672
800088f4:	02 9b       	mov	r11,r1
800088f6:	08 9c       	mov	r12,r4
800088f8:	fe b0 f2 06 	rcall	80006d04 <__sprint_r>
800088fc:	e0 81 01 91 	brne	80008c1e <_vfprintf_r+0x1efe>
80008900:	fa c3 f9 e0 	sub	r3,sp,-1568
80008904:	ed b5 00 00 	bld	r5,0x0
80008908:	e0 81 01 20 	brne	80008b48 <_vfprintf_r+0x1e28>
8000890c:	40 c9       	lddsp	r9,sp[0x30]
8000890e:	fa f8 06 90 	ld.w	r8,sp[1680]
80008912:	2f f8       	sub	r8,-1
80008914:	87 09       	st.w	r3[0x0],r9
80008916:	fb 48 06 90 	st.w	sp[1680],r8
8000891a:	30 19       	mov	r9,1
8000891c:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008920:	87 19       	st.w	r3[0x4],r9
80008922:	2f f8       	sub	r8,-1
80008924:	fb 48 06 8c 	st.w	sp[1676],r8
80008928:	c0 29       	rjmp	80008b2c <_vfprintf_r+0x1e0c>
8000892a:	14 09       	add	r9,r10
8000892c:	2f f8       	sub	r8,-1
8000892e:	fb 49 06 90 	st.w	sp[1680],r9
80008932:	87 06       	st.w	r3[0x0],r6
80008934:	87 1a       	st.w	r3[0x4],r10
80008936:	fb 48 06 8c 	st.w	sp[1676],r8
8000893a:	58 78       	cp.w	r8,7
8000893c:	e0 89 00 04 	brgt	80008944 <_vfprintf_r+0x1c24>
80008940:	2f 83       	sub	r3,-8
80008942:	c0 b8       	rjmp	80008958 <_vfprintf_r+0x1c38>
80008944:	fa ca f9 78 	sub	r10,sp,-1672
80008948:	02 9b       	mov	r11,r1
8000894a:	08 9c       	mov	r12,r4
8000894c:	fe b0 f1 dc 	rcall	80006d04 <__sprint_r>
80008950:	e0 81 01 67 	brne	80008c1e <_vfprintf_r+0x1efe>
80008954:	fa c3 f9 e0 	sub	r3,sp,-1568
80008958:	40 c8       	lddsp	r8,sp[0x30]
8000895a:	87 08       	st.w	r3[0x0],r8
8000895c:	fa f8 06 90 	ld.w	r8,sp[1680]
80008960:	2f f8       	sub	r8,-1
80008962:	30 19       	mov	r9,1
80008964:	fb 48 06 90 	st.w	sp[1680],r8
80008968:	87 19       	st.w	r3[0x4],r9
8000896a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000896e:	2f f8       	sub	r8,-1
80008970:	fb 48 06 8c 	st.w	sp[1676],r8
80008974:	fa f2 06 ac 	ld.w	r2,sp[1708]
80008978:	58 78       	cp.w	r8,7
8000897a:	e0 89 00 04 	brgt	80008982 <_vfprintf_r+0x1c62>
8000897e:	2f 83       	sub	r3,-8
80008980:	c0 b8       	rjmp	80008996 <_vfprintf_r+0x1c76>
80008982:	fa ca f9 78 	sub	r10,sp,-1672
80008986:	02 9b       	mov	r11,r1
80008988:	08 9c       	mov	r12,r4
8000898a:	fe b0 f1 bd 	rcall	80006d04 <__sprint_r>
8000898e:	e0 81 01 48 	brne	80008c1e <_vfprintf_r+0x1efe>
80008992:	fa c3 f9 e0 	sub	r3,sp,-1568
80008996:	04 06       	add	r6,r2
80008998:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000899c:	87 06       	st.w	r3[0x0],r6
8000899e:	fa f9 06 90 	ld.w	r9,sp[1680]
800089a2:	40 66       	lddsp	r6,sp[0x18]
800089a4:	40 6e       	lddsp	lr,sp[0x18]
800089a6:	10 16       	sub	r6,r8
800089a8:	f2 08 01 08 	sub	r8,r9,r8
800089ac:	87 16       	st.w	r3[0x4],r6
800089ae:	1c 08       	add	r8,lr
800089b0:	fb 48 06 90 	st.w	sp[1680],r8
800089b4:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089b8:	2f f8       	sub	r8,-1
800089ba:	fb 48 06 8c 	st.w	sp[1676],r8
800089be:	cb 78       	rjmp	80008b2c <_vfprintf_r+0x1e0c>
800089c0:	40 6c       	lddsp	r12,sp[0x18]
800089c2:	58 1c       	cp.w	r12,1
800089c4:	e0 89 00 06 	brgt	800089d0 <_vfprintf_r+0x1cb0>
800089c8:	ed b5 00 00 	bld	r5,0x0
800089cc:	e0 81 00 85 	brne	80008ad6 <_vfprintf_r+0x1db6>
800089d0:	fa f8 06 90 	ld.w	r8,sp[1680]
800089d4:	2f f8       	sub	r8,-1
800089d6:	30 19       	mov	r9,1
800089d8:	fb 48 06 90 	st.w	sp[1680],r8
800089dc:	87 06       	st.w	r3[0x0],r6
800089de:	fa f8 06 8c 	ld.w	r8,sp[1676]
800089e2:	87 19       	st.w	r3[0x4],r9
800089e4:	2f f8       	sub	r8,-1
800089e6:	fb 48 06 8c 	st.w	sp[1676],r8
800089ea:	58 78       	cp.w	r8,7
800089ec:	e0 89 00 04 	brgt	800089f4 <_vfprintf_r+0x1cd4>
800089f0:	2f 83       	sub	r3,-8
800089f2:	c0 b8       	rjmp	80008a08 <_vfprintf_r+0x1ce8>
800089f4:	fa ca f9 78 	sub	r10,sp,-1672
800089f8:	02 9b       	mov	r11,r1
800089fa:	08 9c       	mov	r12,r4
800089fc:	fe b0 f1 84 	rcall	80006d04 <__sprint_r>
80008a00:	e0 81 01 0f 	brne	80008c1e <_vfprintf_r+0x1efe>
80008a04:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a08:	fa f8 06 90 	ld.w	r8,sp[1680]
80008a0c:	2f f8       	sub	r8,-1
80008a0e:	40 cb       	lddsp	r11,sp[0x30]
80008a10:	fb 48 06 90 	st.w	sp[1680],r8
80008a14:	30 19       	mov	r9,1
80008a16:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a1a:	87 0b       	st.w	r3[0x0],r11
80008a1c:	2f f8       	sub	r8,-1
80008a1e:	87 19       	st.w	r3[0x4],r9
80008a20:	fb 48 06 8c 	st.w	sp[1676],r8
80008a24:	58 78       	cp.w	r8,7
80008a26:	e0 89 00 05 	brgt	80008a30 <_vfprintf_r+0x1d10>
80008a2a:	2f 83       	sub	r3,-8
80008a2c:	c0 c8       	rjmp	80008a44 <_vfprintf_r+0x1d24>
80008a2e:	d7 03       	nop
80008a30:	fa ca f9 78 	sub	r10,sp,-1672
80008a34:	02 9b       	mov	r11,r1
80008a36:	08 9c       	mov	r12,r4
80008a38:	fe b0 f1 66 	rcall	80006d04 <__sprint_r>
80008a3c:	e0 81 00 f1 	brne	80008c1e <_vfprintf_r+0x1efe>
80008a40:	fa c3 f9 e0 	sub	r3,sp,-1568
80008a44:	30 08       	mov	r8,0
80008a46:	30 09       	mov	r9,0
80008a48:	40 5b       	lddsp	r11,sp[0x14]
80008a4a:	40 7a       	lddsp	r10,sp[0x1c]
80008a4c:	e0 a0 13 25 	rcall	8000b096 <__avr32_f64_cmp_eq>
80008a50:	40 68       	lddsp	r8,sp[0x18]
80008a52:	20 18       	sub	r8,1
80008a54:	58 0c       	cp.w	r12,0
80008a56:	c0 d1       	brne	80008a70 <_vfprintf_r+0x1d50>
80008a58:	2f f6       	sub	r6,-1
80008a5a:	87 18       	st.w	r3[0x4],r8
80008a5c:	87 06       	st.w	r3[0x0],r6
80008a5e:	fa f6 06 90 	ld.w	r6,sp[1680]
80008a62:	10 06       	add	r6,r8
80008a64:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008a68:	fb 46 06 90 	st.w	sp[1680],r6
80008a6c:	2f f8       	sub	r8,-1
80008a6e:	c3 18       	rjmp	80008ad0 <_vfprintf_r+0x1db0>
80008a70:	10 96       	mov	r6,r8
80008a72:	58 08       	cp.w	r8,0
80008a74:	e0 89 00 1c 	brgt	80008aac <_vfprintf_r+0x1d8c>
80008a78:	c4 b8       	rjmp	80008b0e <_vfprintf_r+0x1dee>
80008a7a:	2f 09       	sub	r9,-16
80008a7c:	2f f8       	sub	r8,-1
80008a7e:	fb 49 06 90 	st.w	sp[1680],r9
80008a82:	87 02       	st.w	r3[0x0],r2
80008a84:	87 10       	st.w	r3[0x4],r0
80008a86:	fb 48 06 8c 	st.w	sp[1676],r8
80008a8a:	58 78       	cp.w	r8,7
80008a8c:	e0 89 00 04 	brgt	80008a94 <_vfprintf_r+0x1d74>
80008a90:	2f 83       	sub	r3,-8
80008a92:	c0 b8       	rjmp	80008aa8 <_vfprintf_r+0x1d88>
80008a94:	fa ca f9 78 	sub	r10,sp,-1672
80008a98:	02 9b       	mov	r11,r1
80008a9a:	08 9c       	mov	r12,r4
80008a9c:	fe b0 f1 34 	rcall	80006d04 <__sprint_r>
80008aa0:	e0 81 00 bf 	brne	80008c1e <_vfprintf_r+0x1efe>
80008aa4:	fa c3 f9 e0 	sub	r3,sp,-1568
80008aa8:	21 06       	sub	r6,16
80008aaa:	c0 48       	rjmp	80008ab2 <_vfprintf_r+0x1d92>
80008aac:	fe c2 bf 34 	sub	r2,pc,-16588
80008ab0:	31 00       	mov	r0,16
80008ab2:	fa f9 06 90 	ld.w	r9,sp[1680]
80008ab6:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008aba:	fe ca bf 42 	sub	r10,pc,-16574
80008abe:	59 06       	cp.w	r6,16
80008ac0:	fe 99 ff dd 	brgt	80008a7a <_vfprintf_r+0x1d5a>
80008ac4:	0c 09       	add	r9,r6
80008ac6:	87 0a       	st.w	r3[0x0],r10
80008ac8:	fb 49 06 90 	st.w	sp[1680],r9
80008acc:	2f f8       	sub	r8,-1
80008ace:	87 16       	st.w	r3[0x4],r6
80008ad0:	fb 48 06 8c 	st.w	sp[1676],r8
80008ad4:	c0 e8       	rjmp	80008af0 <_vfprintf_r+0x1dd0>
80008ad6:	fa f8 06 90 	ld.w	r8,sp[1680]
80008ada:	2f f8       	sub	r8,-1
80008adc:	30 19       	mov	r9,1
80008ade:	fb 48 06 90 	st.w	sp[1680],r8
80008ae2:	87 06       	st.w	r3[0x0],r6
80008ae4:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008ae8:	87 19       	st.w	r3[0x4],r9
80008aea:	2f f8       	sub	r8,-1
80008aec:	fb 48 06 8c 	st.w	sp[1676],r8
80008af0:	58 78       	cp.w	r8,7
80008af2:	e0 89 00 04 	brgt	80008afa <_vfprintf_r+0x1dda>
80008af6:	2f 83       	sub	r3,-8
80008af8:	c0 b8       	rjmp	80008b0e <_vfprintf_r+0x1dee>
80008afa:	fa ca f9 78 	sub	r10,sp,-1672
80008afe:	02 9b       	mov	r11,r1
80008b00:	08 9c       	mov	r12,r4
80008b02:	fe b0 f1 01 	rcall	80006d04 <__sprint_r>
80008b06:	e0 81 00 8c 	brne	80008c1e <_vfprintf_r+0x1efe>
80008b0a:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b0e:	40 ea       	lddsp	r10,sp[0x38]
80008b10:	fa f8 06 90 	ld.w	r8,sp[1680]
80008b14:	14 08       	add	r8,r10
80008b16:	fa c9 f9 64 	sub	r9,sp,-1692
80008b1a:	fb 48 06 90 	st.w	sp[1680],r8
80008b1e:	87 1a       	st.w	r3[0x4],r10
80008b20:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b24:	87 09       	st.w	r3[0x0],r9
80008b26:	2f f8       	sub	r8,-1
80008b28:	fb 48 06 8c 	st.w	sp[1676],r8
80008b2c:	58 78       	cp.w	r8,7
80008b2e:	e0 89 00 04 	brgt	80008b36 <_vfprintf_r+0x1e16>
80008b32:	2f 83       	sub	r3,-8
80008b34:	c0 a8       	rjmp	80008b48 <_vfprintf_r+0x1e28>
80008b36:	fa ca f9 78 	sub	r10,sp,-1672
80008b3a:	02 9b       	mov	r11,r1
80008b3c:	08 9c       	mov	r12,r4
80008b3e:	fe b0 f0 e3 	rcall	80006d04 <__sprint_r>
80008b42:	c6 e1       	brne	80008c1e <_vfprintf_r+0x1efe>
80008b44:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b48:	e2 15 00 04 	andl	r5,0x4,COH
80008b4c:	c3 f0       	breq	80008bca <_vfprintf_r+0x1eaa>
80008b4e:	40 86       	lddsp	r6,sp[0x20]
80008b50:	40 39       	lddsp	r9,sp[0xc]
80008b52:	12 16       	sub	r6,r9
80008b54:	58 06       	cp.w	r6,0
80008b56:	e0 89 00 1a 	brgt	80008b8a <_vfprintf_r+0x1e6a>
80008b5a:	c3 88       	rjmp	80008bca <_vfprintf_r+0x1eaa>
80008b5c:	2f 09       	sub	r9,-16
80008b5e:	2f f8       	sub	r8,-1
80008b60:	fb 49 06 90 	st.w	sp[1680],r9
80008b64:	87 05       	st.w	r3[0x0],r5
80008b66:	87 12       	st.w	r3[0x4],r2
80008b68:	fb 48 06 8c 	st.w	sp[1676],r8
80008b6c:	58 78       	cp.w	r8,7
80008b6e:	e0 89 00 04 	brgt	80008b76 <_vfprintf_r+0x1e56>
80008b72:	2f 83       	sub	r3,-8
80008b74:	c0 98       	rjmp	80008b86 <_vfprintf_r+0x1e66>
80008b76:	00 9a       	mov	r10,r0
80008b78:	02 9b       	mov	r11,r1
80008b7a:	08 9c       	mov	r12,r4
80008b7c:	fe b0 f0 c4 	rcall	80006d04 <__sprint_r>
80008b80:	c4 f1       	brne	80008c1e <_vfprintf_r+0x1efe>
80008b82:	fa c3 f9 e0 	sub	r3,sp,-1568
80008b86:	21 06       	sub	r6,16
80008b88:	c0 68       	rjmp	80008b94 <_vfprintf_r+0x1e74>
80008b8a:	fe c5 c0 22 	sub	r5,pc,-16350
80008b8e:	31 02       	mov	r2,16
80008b90:	fa c0 f9 78 	sub	r0,sp,-1672
80008b94:	fa f9 06 90 	ld.w	r9,sp[1680]
80008b98:	fa f8 06 8c 	ld.w	r8,sp[1676]
80008b9c:	fe ca c0 34 	sub	r10,pc,-16332
80008ba0:	59 06       	cp.w	r6,16
80008ba2:	fe 99 ff dd 	brgt	80008b5c <_vfprintf_r+0x1e3c>
80008ba6:	0c 09       	add	r9,r6
80008ba8:	2f f8       	sub	r8,-1
80008baa:	87 0a       	st.w	r3[0x0],r10
80008bac:	87 16       	st.w	r3[0x4],r6
80008bae:	fb 49 06 90 	st.w	sp[1680],r9
80008bb2:	fb 48 06 8c 	st.w	sp[1676],r8
80008bb6:	58 78       	cp.w	r8,7
80008bb8:	e0 8a 00 09 	brle	80008bca <_vfprintf_r+0x1eaa>
80008bbc:	fa ca f9 78 	sub	r10,sp,-1672
80008bc0:	02 9b       	mov	r11,r1
80008bc2:	08 9c       	mov	r12,r4
80008bc4:	fe b0 f0 a0 	rcall	80006d04 <__sprint_r>
80008bc8:	c2 b1       	brne	80008c1e <_vfprintf_r+0x1efe>
80008bca:	40 bc       	lddsp	r12,sp[0x2c]
80008bcc:	40 36       	lddsp	r6,sp[0xc]
80008bce:	40 8e       	lddsp	lr,sp[0x20]
80008bd0:	ec 0e 0c 48 	max	r8,r6,lr
80008bd4:	10 0c       	add	r12,r8
80008bd6:	50 bc       	stdsp	sp[0x2c],r12
80008bd8:	fa f8 06 90 	ld.w	r8,sp[1680]
80008bdc:	58 08       	cp.w	r8,0
80008bde:	c0 80       	breq	80008bee <_vfprintf_r+0x1ece>
80008be0:	fa ca f9 78 	sub	r10,sp,-1672
80008be4:	02 9b       	mov	r11,r1
80008be6:	08 9c       	mov	r12,r4
80008be8:	fe b0 f0 8e 	rcall	80006d04 <__sprint_r>
80008bec:	c1 91       	brne	80008c1e <_vfprintf_r+0x1efe>
80008bee:	30 0b       	mov	r11,0
80008bf0:	fa c3 f9 e0 	sub	r3,sp,-1568
80008bf4:	fb 4b 06 8c 	st.w	sp[1676],r11
80008bf8:	fe 9f f1 22 	bral	80006e3c <_vfprintf_r+0x11c>
80008bfc:	08 95       	mov	r5,r4
80008bfe:	fa f8 06 90 	ld.w	r8,sp[1680]
80008c02:	58 08       	cp.w	r8,0
80008c04:	c0 80       	breq	80008c14 <_vfprintf_r+0x1ef4>
80008c06:	08 9c       	mov	r12,r4
80008c08:	fa ca f9 78 	sub	r10,sp,-1672
80008c0c:	02 9b       	mov	r11,r1
80008c0e:	fe b0 f0 7b 	rcall	80006d04 <__sprint_r>
80008c12:	c0 61       	brne	80008c1e <_vfprintf_r+0x1efe>
80008c14:	30 08       	mov	r8,0
80008c16:	fb 48 06 8c 	st.w	sp[1676],r8
80008c1a:	c0 28       	rjmp	80008c1e <_vfprintf_r+0x1efe>
80008c1c:	40 41       	lddsp	r1,sp[0x10]
80008c1e:	82 68       	ld.sh	r8,r1[0xc]
80008c20:	ed b8 00 06 	bld	r8,0x6
80008c24:	c0 31       	brne	80008c2a <_vfprintf_r+0x1f0a>
80008c26:	3f fa       	mov	r10,-1
80008c28:	50 ba       	stdsp	sp[0x2c],r10
80008c2a:	40 bc       	lddsp	r12,sp[0x2c]
80008c2c:	fe 3d f9 44 	sub	sp,-1724
80008c30:	d8 32       	popm	r0-r7,pc
80008c32:	d7 03       	nop

80008c34 <__swsetup_r>:
80008c34:	d4 21       	pushm	r4-r7,lr
80008c36:	e0 68 0a 18 	mov	r8,2584
80008c3a:	18 96       	mov	r6,r12
80008c3c:	16 97       	mov	r7,r11
80008c3e:	70 0c       	ld.w	r12,r8[0x0]
80008c40:	58 0c       	cp.w	r12,0
80008c42:	c0 60       	breq	80008c4e <__swsetup_r+0x1a>
80008c44:	78 68       	ld.w	r8,r12[0x18]
80008c46:	58 08       	cp.w	r8,0
80008c48:	c0 31       	brne	80008c4e <__swsetup_r+0x1a>
80008c4a:	e0 a0 07 bf 	rcall	80009bc8 <__sinit>
80008c4e:	fe c8 bf b6 	sub	r8,pc,-16458
80008c52:	10 37       	cp.w	r7,r8
80008c54:	c0 61       	brne	80008c60 <__swsetup_r+0x2c>
80008c56:	e0 68 0a 18 	mov	r8,2584
80008c5a:	70 08       	ld.w	r8,r8[0x0]
80008c5c:	70 07       	ld.w	r7,r8[0x0]
80008c5e:	c1 28       	rjmp	80008c82 <__swsetup_r+0x4e>
80008c60:	fe c8 bf a8 	sub	r8,pc,-16472
80008c64:	10 37       	cp.w	r7,r8
80008c66:	c0 61       	brne	80008c72 <__swsetup_r+0x3e>
80008c68:	e0 68 0a 18 	mov	r8,2584
80008c6c:	70 08       	ld.w	r8,r8[0x0]
80008c6e:	70 17       	ld.w	r7,r8[0x4]
80008c70:	c0 98       	rjmp	80008c82 <__swsetup_r+0x4e>
80008c72:	fe c8 bf 9a 	sub	r8,pc,-16486
80008c76:	10 37       	cp.w	r7,r8
80008c78:	c0 51       	brne	80008c82 <__swsetup_r+0x4e>
80008c7a:	e0 68 0a 18 	mov	r8,2584
80008c7e:	70 08       	ld.w	r8,r8[0x0]
80008c80:	70 27       	ld.w	r7,r8[0x8]
80008c82:	8e 68       	ld.sh	r8,r7[0xc]
80008c84:	ed b8 00 03 	bld	r8,0x3
80008c88:	c1 e0       	breq	80008cc4 <__swsetup_r+0x90>
80008c8a:	ed b8 00 04 	bld	r8,0x4
80008c8e:	c3 e1       	brne	80008d0a <__swsetup_r+0xd6>
80008c90:	ed b8 00 02 	bld	r8,0x2
80008c94:	c1 51       	brne	80008cbe <__swsetup_r+0x8a>
80008c96:	6e db       	ld.w	r11,r7[0x34]
80008c98:	58 0b       	cp.w	r11,0
80008c9a:	c0 a0       	breq	80008cae <__swsetup_r+0x7a>
80008c9c:	ee c8 ff bc 	sub	r8,r7,-68
80008ca0:	10 3b       	cp.w	r11,r8
80008ca2:	c0 40       	breq	80008caa <__swsetup_r+0x76>
80008ca4:	0c 9c       	mov	r12,r6
80008ca6:	e0 a0 08 2b 	rcall	80009cfc <_free_r>
80008caa:	30 08       	mov	r8,0
80008cac:	8f d8       	st.w	r7[0x34],r8
80008cae:	8e 68       	ld.sh	r8,r7[0xc]
80008cb0:	e0 18 ff db 	andl	r8,0xffdb
80008cb4:	ae 68       	st.h	r7[0xc],r8
80008cb6:	30 08       	mov	r8,0
80008cb8:	8f 18       	st.w	r7[0x4],r8
80008cba:	6e 48       	ld.w	r8,r7[0x10]
80008cbc:	8f 08       	st.w	r7[0x0],r8
80008cbe:	8e 68       	ld.sh	r8,r7[0xc]
80008cc0:	a3 b8       	sbr	r8,0x3
80008cc2:	ae 68       	st.h	r7[0xc],r8
80008cc4:	6e 48       	ld.w	r8,r7[0x10]
80008cc6:	58 08       	cp.w	r8,0
80008cc8:	c0 b1       	brne	80008cde <__swsetup_r+0xaa>
80008cca:	8e 68       	ld.sh	r8,r7[0xc]
80008ccc:	e2 18 02 80 	andl	r8,0x280,COH
80008cd0:	e0 48 02 00 	cp.w	r8,512
80008cd4:	c0 50       	breq	80008cde <__swsetup_r+0xaa>
80008cd6:	0c 9c       	mov	r12,r6
80008cd8:	0e 9b       	mov	r11,r7
80008cda:	e0 a0 0a 4b 	rcall	8000a170 <__smakebuf_r>
80008cde:	8e 69       	ld.sh	r9,r7[0xc]
80008ce0:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
80008ce4:	c0 70       	breq	80008cf2 <__swsetup_r+0xbe>
80008ce6:	30 08       	mov	r8,0
80008ce8:	8f 28       	st.w	r7[0x8],r8
80008cea:	6e 58       	ld.w	r8,r7[0x14]
80008cec:	5c 38       	neg	r8
80008cee:	8f 68       	st.w	r7[0x18],r8
80008cf0:	c0 68       	rjmp	80008cfc <__swsetup_r+0xc8>
80008cf2:	ed b9 00 01 	bld	r9,0x1
80008cf6:	ef f8 10 05 	ld.wne	r8,r7[0x14]
80008cfa:	8f 28       	st.w	r7[0x8],r8
80008cfc:	6e 48       	ld.w	r8,r7[0x10]
80008cfe:	58 08       	cp.w	r8,0
80008d00:	c0 61       	brne	80008d0c <__swsetup_r+0xd8>
80008d02:	8e 68       	ld.sh	r8,r7[0xc]
80008d04:	ed b8 00 07 	bld	r8,0x7
80008d08:	c0 21       	brne	80008d0c <__swsetup_r+0xd8>
80008d0a:	dc 2a       	popm	r4-r7,pc,r12=-1
80008d0c:	d8 2a       	popm	r4-r7,pc,r12=0
80008d0e:	d7 03       	nop

80008d10 <quorem>:
80008d10:	d4 31       	pushm	r0-r7,lr
80008d12:	20 2d       	sub	sp,8
80008d14:	18 97       	mov	r7,r12
80008d16:	78 48       	ld.w	r8,r12[0x10]
80008d18:	76 46       	ld.w	r6,r11[0x10]
80008d1a:	0c 38       	cp.w	r8,r6
80008d1c:	c0 34       	brge	80008d22 <quorem+0x12>
80008d1e:	30 0c       	mov	r12,0
80008d20:	c8 58       	rjmp	80008e2a <quorem+0x11a>
80008d22:	ec c2 ff fc 	sub	r2,r6,-4
80008d26:	f6 c3 ff ec 	sub	r3,r11,-20
80008d2a:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
80008d2e:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
80008d32:	2f f9       	sub	r9,-1
80008d34:	20 16       	sub	r6,1
80008d36:	f8 09 0d 08 	divu	r8,r12,r9
80008d3a:	f6 02 00 22 	add	r2,r11,r2<<0x2
80008d3e:	ee c4 ff ec 	sub	r4,r7,-20
80008d42:	10 95       	mov	r5,r8
80008d44:	58 08       	cp.w	r8,0
80008d46:	c4 10       	breq	80008dc8 <quorem+0xb8>
80008d48:	30 09       	mov	r9,0
80008d4a:	06 9a       	mov	r10,r3
80008d4c:	08 98       	mov	r8,r4
80008d4e:	12 91       	mov	r1,r9
80008d50:	50 0b       	stdsp	sp[0x0],r11
80008d52:	70 0e       	ld.w	lr,r8[0x0]
80008d54:	b1 8e       	lsr	lr,0x10
80008d56:	50 1e       	stdsp	sp[0x4],lr
80008d58:	15 0e       	ld.w	lr,r10++
80008d5a:	fc 00 16 10 	lsr	r0,lr,0x10
80008d5e:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80008d62:	ea 0e 03 41 	mac	r1,r5,lr
80008d66:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
80008d6a:	b1 81       	lsr	r1,0x10
80008d6c:	40 1b       	lddsp	r11,sp[0x4]
80008d6e:	ea 00 02 40 	mul	r0,r5,r0
80008d72:	e2 00 00 00 	add	r0,r1,r0
80008d76:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
80008d7a:	02 1b       	sub	r11,r1
80008d7c:	50 1b       	stdsp	sp[0x4],r11
80008d7e:	70 0b       	ld.w	r11,r8[0x0]
80008d80:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
80008d84:	02 09       	add	r9,r1
80008d86:	f2 0e 01 0e 	sub	lr,r9,lr
80008d8a:	b0 1e       	st.h	r8[0x2],lr
80008d8c:	fc 09 14 10 	asr	r9,lr,0x10
80008d90:	40 1e       	lddsp	lr,sp[0x4]
80008d92:	fc 09 00 09 	add	r9,lr,r9
80008d96:	b0 09       	st.h	r8[0x0],r9
80008d98:	e0 01 16 10 	lsr	r1,r0,0x10
80008d9c:	2f c8       	sub	r8,-4
80008d9e:	b1 49       	asr	r9,0x10
80008da0:	04 3a       	cp.w	r10,r2
80008da2:	fe 98 ff d8 	brls	80008d52 <quorem+0x42>
80008da6:	40 0b       	lddsp	r11,sp[0x0]
80008da8:	58 0c       	cp.w	r12,0
80008daa:	c0 f1       	brne	80008dc8 <quorem+0xb8>
80008dac:	ec c8 ff fb 	sub	r8,r6,-5
80008db0:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008db4:	c0 28       	rjmp	80008db8 <quorem+0xa8>
80008db6:	20 16       	sub	r6,1
80008db8:	20 48       	sub	r8,4
80008dba:	08 38       	cp.w	r8,r4
80008dbc:	e0 88 00 05 	brls	80008dc6 <quorem+0xb6>
80008dc0:	70 09       	ld.w	r9,r8[0x0]
80008dc2:	58 09       	cp.w	r9,0
80008dc4:	cf 90       	breq	80008db6 <quorem+0xa6>
80008dc6:	8f 46       	st.w	r7[0x10],r6
80008dc8:	0e 9c       	mov	r12,r7
80008dca:	e0 a0 0a d2 	rcall	8000a36e <__mcmp>
80008dce:	c2 d5       	brlt	80008e28 <quorem+0x118>
80008dd0:	2f f5       	sub	r5,-1
80008dd2:	08 98       	mov	r8,r4
80008dd4:	30 09       	mov	r9,0
80008dd6:	07 0b       	ld.w	r11,r3++
80008dd8:	f6 0a 16 10 	lsr	r10,r11,0x10
80008ddc:	70 0c       	ld.w	r12,r8[0x0]
80008dde:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
80008de2:	f8 0e 16 10 	lsr	lr,r12,0x10
80008de6:	14 1e       	sub	lr,r10
80008de8:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80008dec:	16 1a       	sub	r10,r11
80008dee:	12 0a       	add	r10,r9
80008df0:	b0 1a       	st.h	r8[0x2],r10
80008df2:	b1 4a       	asr	r10,0x10
80008df4:	fc 0a 00 09 	add	r9,lr,r10
80008df8:	b0 09       	st.h	r8[0x0],r9
80008dfa:	2f c8       	sub	r8,-4
80008dfc:	b1 49       	asr	r9,0x10
80008dfe:	04 33       	cp.w	r3,r2
80008e00:	fe 98 ff eb 	brls	80008dd6 <quorem+0xc6>
80008e04:	ec c8 ff fb 	sub	r8,r6,-5
80008e08:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
80008e0c:	58 09       	cp.w	r9,0
80008e0e:	c0 d1       	brne	80008e28 <quorem+0x118>
80008e10:	ee 08 00 28 	add	r8,r7,r8<<0x2
80008e14:	c0 28       	rjmp	80008e18 <quorem+0x108>
80008e16:	20 16       	sub	r6,1
80008e18:	20 48       	sub	r8,4
80008e1a:	08 38       	cp.w	r8,r4
80008e1c:	e0 88 00 05 	brls	80008e26 <quorem+0x116>
80008e20:	70 09       	ld.w	r9,r8[0x0]
80008e22:	58 09       	cp.w	r9,0
80008e24:	cf 90       	breq	80008e16 <quorem+0x106>
80008e26:	8f 46       	st.w	r7[0x10],r6
80008e28:	0a 9c       	mov	r12,r5
80008e2a:	2f ed       	sub	sp,-8
80008e2c:	d8 32       	popm	r0-r7,pc
80008e2e:	d7 03       	nop

80008e30 <_dtoa_r>:
80008e30:	d4 31       	pushm	r0-r7,lr
80008e32:	21 ad       	sub	sp,104
80008e34:	fa c4 ff 74 	sub	r4,sp,-140
80008e38:	18 97       	mov	r7,r12
80008e3a:	16 95       	mov	r5,r11
80008e3c:	68 2c       	ld.w	r12,r4[0x8]
80008e3e:	50 c9       	stdsp	sp[0x30],r9
80008e40:	68 16       	ld.w	r6,r4[0x4]
80008e42:	68 09       	ld.w	r9,r4[0x0]
80008e44:	50 e8       	stdsp	sp[0x38],r8
80008e46:	14 94       	mov	r4,r10
80008e48:	51 2c       	stdsp	sp[0x48],r12
80008e4a:	fa e5 00 08 	st.d	sp[8],r4
80008e4e:	51 59       	stdsp	sp[0x54],r9
80008e50:	6e 95       	ld.w	r5,r7[0x24]
80008e52:	58 05       	cp.w	r5,0
80008e54:	c0 91       	brne	80008e66 <_dtoa_r+0x36>
80008e56:	31 0c       	mov	r12,16
80008e58:	fe b0 e8 e2 	rcall	8000601c <malloc>
80008e5c:	99 35       	st.w	r12[0xc],r5
80008e5e:	8f 9c       	st.w	r7[0x24],r12
80008e60:	99 15       	st.w	r12[0x4],r5
80008e62:	99 25       	st.w	r12[0x8],r5
80008e64:	99 05       	st.w	r12[0x0],r5
80008e66:	6e 99       	ld.w	r9,r7[0x24]
80008e68:	72 08       	ld.w	r8,r9[0x0]
80008e6a:	58 08       	cp.w	r8,0
80008e6c:	c0 f0       	breq	80008e8a <_dtoa_r+0x5a>
80008e6e:	72 1a       	ld.w	r10,r9[0x4]
80008e70:	91 1a       	st.w	r8[0x4],r10
80008e72:	30 1a       	mov	r10,1
80008e74:	72 19       	ld.w	r9,r9[0x4]
80008e76:	f4 09 09 49 	lsl	r9,r10,r9
80008e7a:	10 9b       	mov	r11,r8
80008e7c:	91 29       	st.w	r8[0x8],r9
80008e7e:	0e 9c       	mov	r12,r7
80008e80:	e0 a0 0a 90 	rcall	8000a3a0 <_Bfree>
80008e84:	6e 98       	ld.w	r8,r7[0x24]
80008e86:	30 09       	mov	r9,0
80008e88:	91 09       	st.w	r8[0x0],r9
80008e8a:	40 28       	lddsp	r8,sp[0x8]
80008e8c:	10 94       	mov	r4,r8
80008e8e:	58 08       	cp.w	r8,0
80008e90:	c0 64       	brge	80008e9c <_dtoa_r+0x6c>
80008e92:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
80008e96:	50 28       	stdsp	sp[0x8],r8
80008e98:	30 18       	mov	r8,1
80008e9a:	c0 28       	rjmp	80008e9e <_dtoa_r+0x6e>
80008e9c:	30 08       	mov	r8,0
80008e9e:	8d 08       	st.w	r6[0x0],r8
80008ea0:	fc 1c 7f f0 	movh	r12,0x7ff0
80008ea4:	40 26       	lddsp	r6,sp[0x8]
80008ea6:	0c 98       	mov	r8,r6
80008ea8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80008eac:	18 38       	cp.w	r8,r12
80008eae:	c2 01       	brne	80008eee <_dtoa_r+0xbe>
80008eb0:	e0 68 27 0f 	mov	r8,9999
80008eb4:	41 5b       	lddsp	r11,sp[0x54]
80008eb6:	97 08       	st.w	r11[0x0],r8
80008eb8:	40 3a       	lddsp	r10,sp[0xc]
80008eba:	58 0a       	cp.w	r10,0
80008ebc:	c0 71       	brne	80008eca <_dtoa_r+0x9a>
80008ebe:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
80008ec2:	c0 41       	brne	80008eca <_dtoa_r+0x9a>
80008ec4:	fe cc c2 3c 	sub	r12,pc,-15812
80008ec8:	c0 38       	rjmp	80008ece <_dtoa_r+0x9e>
80008eca:	fe cc c2 36 	sub	r12,pc,-15818
80008ece:	41 29       	lddsp	r9,sp[0x48]
80008ed0:	58 09       	cp.w	r9,0
80008ed2:	e0 80 05 9a 	breq	80009a06 <_dtoa_r+0xbd6>
80008ed6:	f8 c8 ff fd 	sub	r8,r12,-3
80008eda:	f8 c9 ff f8 	sub	r9,r12,-8
80008ede:	11 8b       	ld.ub	r11,r8[0x0]
80008ee0:	30 0a       	mov	r10,0
80008ee2:	41 25       	lddsp	r5,sp[0x48]
80008ee4:	f4 0b 18 00 	cp.b	r11,r10
80008ee8:	f2 08 17 10 	movne	r8,r9
80008eec:	c1 68       	rjmp	80008f18 <_dtoa_r+0xe8>
80008eee:	fa ea 00 08 	ld.d	r10,sp[8]
80008ef2:	30 08       	mov	r8,0
80008ef4:	fa eb 00 3c 	st.d	sp[60],r10
80008ef8:	30 09       	mov	r9,0
80008efa:	e0 a0 10 ce 	rcall	8000b096 <__avr32_f64_cmp_eq>
80008efe:	c1 00       	breq	80008f1e <_dtoa_r+0xee>
80008f00:	30 18       	mov	r8,1
80008f02:	41 5a       	lddsp	r10,sp[0x54]
80008f04:	95 08       	st.w	r10[0x0],r8
80008f06:	fe cc c3 a2 	sub	r12,pc,-15454
80008f0a:	41 29       	lddsp	r9,sp[0x48]
80008f0c:	f8 08 00 08 	add	r8,r12,r8
80008f10:	58 09       	cp.w	r9,0
80008f12:	e0 80 05 7a 	breq	80009a06 <_dtoa_r+0xbd6>
80008f16:	12 95       	mov	r5,r9
80008f18:	8b 08       	st.w	r5[0x0],r8
80008f1a:	e0 8f 05 76 	bral	80009a06 <_dtoa_r+0xbd6>
80008f1e:	fa c8 ff 9c 	sub	r8,sp,-100
80008f22:	fa c9 ff a0 	sub	r9,sp,-96
80008f26:	fa ea 00 3c 	ld.d	r10,sp[60]
80008f2a:	0e 9c       	mov	r12,r7
80008f2c:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
80008f30:	e0 a0 0a 8a 	rcall	8000a444 <__d2b>
80008f34:	18 93       	mov	r3,r12
80008f36:	58 05       	cp.w	r5,0
80008f38:	c0 d0       	breq	80008f52 <_dtoa_r+0x122>
80008f3a:	fa ea 00 3c 	ld.d	r10,sp[60]
80008f3e:	30 04       	mov	r4,0
80008f40:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
80008f44:	ea c5 03 ff 	sub	r5,r5,1023
80008f48:	10 9b       	mov	r11,r8
80008f4a:	51 74       	stdsp	sp[0x5c],r4
80008f4c:	ea 1b 3f f0 	orh	r11,0x3ff0
80008f50:	c2 58       	rjmp	80008f9a <_dtoa_r+0x16a>
80008f52:	41 88       	lddsp	r8,sp[0x60]
80008f54:	41 9c       	lddsp	r12,sp[0x64]
80008f56:	10 0c       	add	r12,r8
80008f58:	f8 c5 fb ce 	sub	r5,r12,-1074
80008f5c:	e0 45 00 20 	cp.w	r5,32
80008f60:	e0 8a 00 0e 	brle	80008f7c <_dtoa_r+0x14c>
80008f64:	f8 cc fb ee 	sub	r12,r12,-1042
80008f68:	40 3b       	lddsp	r11,sp[0xc]
80008f6a:	ea 08 11 40 	rsub	r8,r5,64
80008f6e:	f6 0c 0a 4c 	lsr	r12,r11,r12
80008f72:	ec 08 09 46 	lsl	r6,r6,r8
80008f76:	0c 4c       	or	r12,r6
80008f78:	c0 78       	rjmp	80008f86 <_dtoa_r+0x156>
80008f7a:	d7 03       	nop
80008f7c:	ea 0c 11 20 	rsub	r12,r5,32
80008f80:	40 3a       	lddsp	r10,sp[0xc]
80008f82:	f4 0c 09 4c 	lsl	r12,r10,r12
80008f86:	e0 a0 10 14 	rcall	8000afae <__avr32_u32_to_f64>
80008f8a:	fc 18 fe 10 	movh	r8,0xfe10
80008f8e:	30 19       	mov	r9,1
80008f90:	ea c5 04 33 	sub	r5,r5,1075
80008f94:	f0 0b 00 0b 	add	r11,r8,r11
80008f98:	51 79       	stdsp	sp[0x5c],r9
80008f9a:	30 08       	mov	r8,0
80008f9c:	fc 19 3f f8 	movh	r9,0x3ff8
80008fa0:	e0 a0 0e 9c 	rcall	8000acd8 <__avr32_f64_sub>
80008fa4:	e0 68 43 61 	mov	r8,17249
80008fa8:	ea 18 63 6f 	orh	r8,0x636f
80008fac:	e0 69 87 a7 	mov	r9,34727
80008fb0:	ea 19 3f d2 	orh	r9,0x3fd2
80008fb4:	e0 a0 0d a6 	rcall	8000ab00 <__avr32_f64_mul>
80008fb8:	e0 68 c8 b3 	mov	r8,51379
80008fbc:	ea 18 8b 60 	orh	r8,0x8b60
80008fc0:	e0 69 8a 28 	mov	r9,35368
80008fc4:	ea 19 3f c6 	orh	r9,0x3fc6
80008fc8:	e0 a0 0f 56 	rcall	8000ae74 <__avr32_f64_add>
80008fcc:	0a 9c       	mov	r12,r5
80008fce:	14 90       	mov	r0,r10
80008fd0:	16 91       	mov	r1,r11
80008fd2:	e0 a0 0f f2 	rcall	8000afb6 <__avr32_s32_to_f64>
80008fd6:	e0 68 79 fb 	mov	r8,31227
80008fda:	ea 18 50 9f 	orh	r8,0x509f
80008fde:	e0 69 44 13 	mov	r9,17427
80008fe2:	ea 19 3f d3 	orh	r9,0x3fd3
80008fe6:	e0 a0 0d 8d 	rcall	8000ab00 <__avr32_f64_mul>
80008fea:	14 98       	mov	r8,r10
80008fec:	16 99       	mov	r9,r11
80008fee:	00 9a       	mov	r10,r0
80008ff0:	02 9b       	mov	r11,r1
80008ff2:	e0 a0 0f 41 	rcall	8000ae74 <__avr32_f64_add>
80008ff6:	14 90       	mov	r0,r10
80008ff8:	16 91       	mov	r1,r11
80008ffa:	e0 a0 0f c7 	rcall	8000af88 <__avr32_f64_to_s32>
80008ffe:	30 08       	mov	r8,0
80009000:	18 96       	mov	r6,r12
80009002:	30 09       	mov	r9,0
80009004:	00 9a       	mov	r10,r0
80009006:	02 9b       	mov	r11,r1
80009008:	e0 a0 10 8e 	rcall	8000b124 <__avr32_f64_cmp_lt>
8000900c:	c0 c0       	breq	80009024 <_dtoa_r+0x1f4>
8000900e:	0c 9c       	mov	r12,r6
80009010:	e0 a0 0f d3 	rcall	8000afb6 <__avr32_s32_to_f64>
80009014:	14 98       	mov	r8,r10
80009016:	16 99       	mov	r9,r11
80009018:	00 9a       	mov	r10,r0
8000901a:	02 9b       	mov	r11,r1
8000901c:	e0 a0 10 3d 	rcall	8000b096 <__avr32_f64_cmp_eq>
80009020:	f7 b6 00 01 	subeq	r6,1
80009024:	59 66       	cp.w	r6,22
80009026:	e0 88 00 05 	brls	80009030 <_dtoa_r+0x200>
8000902a:	30 18       	mov	r8,1
8000902c:	51 48       	stdsp	sp[0x50],r8
8000902e:	c1 38       	rjmp	80009054 <_dtoa_r+0x224>
80009030:	fe c8 c2 e8 	sub	r8,pc,-15640
80009034:	fa ea 00 3c 	ld.d	r10,sp[60]
80009038:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000903c:	e0 a0 10 74 	rcall	8000b124 <__avr32_f64_cmp_lt>
80009040:	f9 b4 00 00 	moveq	r4,0
80009044:	fb f4 0a 14 	st.weq	sp[0x50],r4
80009048:	f7 b6 01 01 	subne	r6,1
8000904c:	f9 bc 01 00 	movne	r12,0
80009050:	fb fc 1a 14 	st.wne	sp[0x50],r12
80009054:	41 90       	lddsp	r0,sp[0x64]
80009056:	20 10       	sub	r0,1
80009058:	0a 10       	sub	r0,r5
8000905a:	c0 46       	brmi	80009062 <_dtoa_r+0x232>
8000905c:	50 40       	stdsp	sp[0x10],r0
8000905e:	30 00       	mov	r0,0
80009060:	c0 48       	rjmp	80009068 <_dtoa_r+0x238>
80009062:	30 0b       	mov	r11,0
80009064:	5c 30       	neg	r0
80009066:	50 4b       	stdsp	sp[0x10],r11
80009068:	ec 02 11 00 	rsub	r2,r6,0
8000906c:	58 06       	cp.w	r6,0
8000906e:	fb fa 40 04 	ld.wge	r10,sp[0x10]
80009072:	f5 d6 e4 0a 	addge	r10,r10,r6
80009076:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000907a:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000907e:	f9 b2 04 00 	movge	r2,0
80009082:	e1 d6 e5 10 	sublt	r0,r0,r6
80009086:	f9 b9 05 00 	movlt	r9,0
8000908a:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000908e:	40 c8       	lddsp	r8,sp[0x30]
80009090:	58 98       	cp.w	r8,9
80009092:	e0 8b 00 20 	brhi	800090d2 <_dtoa_r+0x2a2>
80009096:	58 58       	cp.w	r8,5
80009098:	f9 b4 0a 01 	movle	r4,1
8000909c:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
800090a0:	f7 b5 09 04 	subgt	r5,4
800090a4:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
800090a8:	f9 b4 09 00 	movgt	r4,0
800090ac:	40 cc       	lddsp	r12,sp[0x30]
800090ae:	58 3c       	cp.w	r12,3
800090b0:	c2 d0       	breq	8000910a <_dtoa_r+0x2da>
800090b2:	e0 89 00 05 	brgt	800090bc <_dtoa_r+0x28c>
800090b6:	58 2c       	cp.w	r12,2
800090b8:	c1 01       	brne	800090d8 <_dtoa_r+0x2a8>
800090ba:	c1 88       	rjmp	800090ea <_dtoa_r+0x2ba>
800090bc:	40 cb       	lddsp	r11,sp[0x30]
800090be:	58 4b       	cp.w	r11,4
800090c0:	c0 60       	breq	800090cc <_dtoa_r+0x29c>
800090c2:	58 5b       	cp.w	r11,5
800090c4:	c0 a1       	brne	800090d8 <_dtoa_r+0x2a8>
800090c6:	30 1a       	mov	r10,1
800090c8:	50 da       	stdsp	sp[0x34],r10
800090ca:	c2 28       	rjmp	8000910e <_dtoa_r+0x2de>
800090cc:	30 19       	mov	r9,1
800090ce:	50 d9       	stdsp	sp[0x34],r9
800090d0:	c0 f8       	rjmp	800090ee <_dtoa_r+0x2be>
800090d2:	30 08       	mov	r8,0
800090d4:	30 14       	mov	r4,1
800090d6:	50 c8       	stdsp	sp[0x30],r8
800090d8:	3f f5       	mov	r5,-1
800090da:	30 1c       	mov	r12,1
800090dc:	30 0b       	mov	r11,0
800090de:	50 95       	stdsp	sp[0x24],r5
800090e0:	50 dc       	stdsp	sp[0x34],r12
800090e2:	0a 91       	mov	r1,r5
800090e4:	31 28       	mov	r8,18
800090e6:	50 eb       	stdsp	sp[0x38],r11
800090e8:	c2 08       	rjmp	80009128 <_dtoa_r+0x2f8>
800090ea:	30 0a       	mov	r10,0
800090ec:	50 da       	stdsp	sp[0x34],r10
800090ee:	40 e9       	lddsp	r9,sp[0x38]
800090f0:	58 09       	cp.w	r9,0
800090f2:	e0 89 00 07 	brgt	80009100 <_dtoa_r+0x2d0>
800090f6:	30 18       	mov	r8,1
800090f8:	50 98       	stdsp	sp[0x24],r8
800090fa:	10 91       	mov	r1,r8
800090fc:	50 e8       	stdsp	sp[0x38],r8
800090fe:	c1 58       	rjmp	80009128 <_dtoa_r+0x2f8>
80009100:	40 e5       	lddsp	r5,sp[0x38]
80009102:	50 95       	stdsp	sp[0x24],r5
80009104:	0a 91       	mov	r1,r5
80009106:	0a 98       	mov	r8,r5
80009108:	c1 08       	rjmp	80009128 <_dtoa_r+0x2f8>
8000910a:	30 0c       	mov	r12,0
8000910c:	50 dc       	stdsp	sp[0x34],r12
8000910e:	40 eb       	lddsp	r11,sp[0x38]
80009110:	ec 0b 00 0b 	add	r11,r6,r11
80009114:	50 9b       	stdsp	sp[0x24],r11
80009116:	16 98       	mov	r8,r11
80009118:	2f f8       	sub	r8,-1
8000911a:	58 08       	cp.w	r8,0
8000911c:	e0 89 00 05 	brgt	80009126 <_dtoa_r+0x2f6>
80009120:	10 91       	mov	r1,r8
80009122:	30 18       	mov	r8,1
80009124:	c0 28       	rjmp	80009128 <_dtoa_r+0x2f8>
80009126:	10 91       	mov	r1,r8
80009128:	30 09       	mov	r9,0
8000912a:	6e 9a       	ld.w	r10,r7[0x24]
8000912c:	95 19       	st.w	r10[0x4],r9
8000912e:	30 49       	mov	r9,4
80009130:	c0 68       	rjmp	8000913c <_dtoa_r+0x30c>
80009132:	d7 03       	nop
80009134:	6a 1a       	ld.w	r10,r5[0x4]
80009136:	a1 79       	lsl	r9,0x1
80009138:	2f fa       	sub	r10,-1
8000913a:	8b 1a       	st.w	r5[0x4],r10
8000913c:	6e 95       	ld.w	r5,r7[0x24]
8000913e:	f2 ca ff ec 	sub	r10,r9,-20
80009142:	10 3a       	cp.w	r10,r8
80009144:	fe 98 ff f8 	brls	80009134 <_dtoa_r+0x304>
80009148:	6a 1b       	ld.w	r11,r5[0x4]
8000914a:	0e 9c       	mov	r12,r7
8000914c:	e0 a0 09 44 	rcall	8000a3d4 <_Balloc>
80009150:	58 e1       	cp.w	r1,14
80009152:	5f 88       	srls	r8
80009154:	8b 0c       	st.w	r5[0x0],r12
80009156:	f1 e4 00 04 	and	r4,r8,r4
8000915a:	6e 98       	ld.w	r8,r7[0x24]
8000915c:	70 08       	ld.w	r8,r8[0x0]
8000915e:	50 88       	stdsp	sp[0x20],r8
80009160:	e0 80 01 82 	breq	80009464 <_dtoa_r+0x634>
80009164:	58 06       	cp.w	r6,0
80009166:	e0 8a 00 43 	brle	800091ec <_dtoa_r+0x3bc>
8000916a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8000916e:	fe c8 c4 26 	sub	r8,pc,-15322
80009172:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80009176:	fa e5 00 18 	st.d	sp[24],r4
8000917a:	ec 04 14 04 	asr	r4,r6,0x4
8000917e:	ed b4 00 04 	bld	r4,0x4
80009182:	c0 30       	breq	80009188 <_dtoa_r+0x358>
80009184:	30 25       	mov	r5,2
80009186:	c1 08       	rjmp	800091a6 <_dtoa_r+0x376>
80009188:	fe c8 c3 78 	sub	r8,pc,-15496
8000918c:	f0 e8 00 20 	ld.d	r8,r8[32]
80009190:	fa ea 00 3c 	ld.d	r10,sp[60]
80009194:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80009198:	e0 a0 0f fa 	rcall	8000b18c <__avr32_f64_div>
8000919c:	30 35       	mov	r5,3
8000919e:	14 98       	mov	r8,r10
800091a0:	16 99       	mov	r9,r11
800091a2:	fa e9 00 08 	st.d	sp[8],r8
800091a6:	fe cc c3 96 	sub	r12,pc,-15466
800091aa:	50 a3       	stdsp	sp[0x28],r3
800091ac:	0c 93       	mov	r3,r6
800091ae:	18 96       	mov	r6,r12
800091b0:	c0 f8       	rjmp	800091ce <_dtoa_r+0x39e>
800091b2:	fa ea 00 18 	ld.d	r10,sp[24]
800091b6:	ed b4 00 00 	bld	r4,0x0
800091ba:	c0 81       	brne	800091ca <_dtoa_r+0x39a>
800091bc:	ec e8 00 00 	ld.d	r8,r6[0]
800091c0:	2f f5       	sub	r5,-1
800091c2:	e0 a0 0c 9f 	rcall	8000ab00 <__avr32_f64_mul>
800091c6:	fa eb 00 18 	st.d	sp[24],r10
800091ca:	a1 54       	asr	r4,0x1
800091cc:	2f 86       	sub	r6,-8
800091ce:	58 04       	cp.w	r4,0
800091d0:	cf 11       	brne	800091b2 <_dtoa_r+0x382>
800091d2:	fa e8 00 18 	ld.d	r8,sp[24]
800091d6:	fa ea 00 08 	ld.d	r10,sp[8]
800091da:	06 96       	mov	r6,r3
800091dc:	e0 a0 0f d8 	rcall	8000b18c <__avr32_f64_div>
800091e0:	40 a3       	lddsp	r3,sp[0x28]
800091e2:	14 98       	mov	r8,r10
800091e4:	16 99       	mov	r9,r11
800091e6:	fa e9 00 08 	st.d	sp[8],r8
800091ea:	c2 f8       	rjmp	80009248 <_dtoa_r+0x418>
800091ec:	ec 08 11 00 	rsub	r8,r6,0
800091f0:	c0 31       	brne	800091f6 <_dtoa_r+0x3c6>
800091f2:	30 25       	mov	r5,2
800091f4:	c2 a8       	rjmp	80009248 <_dtoa_r+0x418>
800091f6:	fe cc c3 e6 	sub	r12,pc,-15386
800091fa:	f0 04 14 04 	asr	r4,r8,0x4
800091fe:	50 1c       	stdsp	sp[0x4],r12
80009200:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80009204:	fe c9 c4 bc 	sub	r9,pc,-15172
80009208:	fa ea 00 3c 	ld.d	r10,sp[60]
8000920c:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009210:	e0 a0 0c 78 	rcall	8000ab00 <__avr32_f64_mul>
80009214:	40 1c       	lddsp	r12,sp[0x4]
80009216:	50 63       	stdsp	sp[0x18],r3
80009218:	30 25       	mov	r5,2
8000921a:	0c 93       	mov	r3,r6
8000921c:	fa eb 00 08 	st.d	sp[8],r10
80009220:	18 96       	mov	r6,r12
80009222:	c0 f8       	rjmp	80009240 <_dtoa_r+0x410>
80009224:	fa ea 00 08 	ld.d	r10,sp[8]
80009228:	ed b4 00 00 	bld	r4,0x0
8000922c:	c0 81       	brne	8000923c <_dtoa_r+0x40c>
8000922e:	ec e8 00 00 	ld.d	r8,r6[0]
80009232:	2f f5       	sub	r5,-1
80009234:	e0 a0 0c 66 	rcall	8000ab00 <__avr32_f64_mul>
80009238:	fa eb 00 08 	st.d	sp[8],r10
8000923c:	a1 54       	asr	r4,0x1
8000923e:	2f 86       	sub	r6,-8
80009240:	58 04       	cp.w	r4,0
80009242:	cf 11       	brne	80009224 <_dtoa_r+0x3f4>
80009244:	06 96       	mov	r6,r3
80009246:	40 63       	lddsp	r3,sp[0x18]
80009248:	41 4a       	lddsp	r10,sp[0x50]
8000924a:	58 0a       	cp.w	r10,0
8000924c:	c2 a0       	breq	800092a0 <_dtoa_r+0x470>
8000924e:	fa e8 00 08 	ld.d	r8,sp[8]
80009252:	58 01       	cp.w	r1,0
80009254:	5f 94       	srgt	r4
80009256:	fa e9 00 18 	st.d	sp[24],r8
8000925a:	30 08       	mov	r8,0
8000925c:	fc 19 3f f0 	movh	r9,0x3ff0
80009260:	fa ea 00 18 	ld.d	r10,sp[24]
80009264:	e0 a0 0f 60 	rcall	8000b124 <__avr32_f64_cmp_lt>
80009268:	f9 bc 00 00 	moveq	r12,0
8000926c:	f9 bc 01 01 	movne	r12,1
80009270:	e9 ec 00 0c 	and	r12,r4,r12
80009274:	c1 60       	breq	800092a0 <_dtoa_r+0x470>
80009276:	40 98       	lddsp	r8,sp[0x24]
80009278:	58 08       	cp.w	r8,0
8000927a:	e0 8a 00 f1 	brle	8000945c <_dtoa_r+0x62c>
8000927e:	30 08       	mov	r8,0
80009280:	fc 19 40 24 	movh	r9,0x4024
80009284:	ec c4 00 01 	sub	r4,r6,1
80009288:	fa ea 00 18 	ld.d	r10,sp[24]
8000928c:	2f f5       	sub	r5,-1
8000928e:	50 64       	stdsp	sp[0x18],r4
80009290:	e0 a0 0c 38 	rcall	8000ab00 <__avr32_f64_mul>
80009294:	40 94       	lddsp	r4,sp[0x24]
80009296:	14 98       	mov	r8,r10
80009298:	16 99       	mov	r9,r11
8000929a:	fa e9 00 08 	st.d	sp[8],r8
8000929e:	c0 38       	rjmp	800092a4 <_dtoa_r+0x474>
800092a0:	50 66       	stdsp	sp[0x18],r6
800092a2:	02 94       	mov	r4,r1
800092a4:	0a 9c       	mov	r12,r5
800092a6:	e0 a0 0e 88 	rcall	8000afb6 <__avr32_s32_to_f64>
800092aa:	fa e8 00 08 	ld.d	r8,sp[8]
800092ae:	e0 a0 0c 29 	rcall	8000ab00 <__avr32_f64_mul>
800092b2:	30 08       	mov	r8,0
800092b4:	fc 19 40 1c 	movh	r9,0x401c
800092b8:	e0 a0 0d de 	rcall	8000ae74 <__avr32_f64_add>
800092bc:	14 98       	mov	r8,r10
800092be:	16 99       	mov	r9,r11
800092c0:	fa e9 00 28 	st.d	sp[40],r8
800092c4:	fc 18 fc c0 	movh	r8,0xfcc0
800092c8:	40 a5       	lddsp	r5,sp[0x28]
800092ca:	10 05       	add	r5,r8
800092cc:	50 a5       	stdsp	sp[0x28],r5
800092ce:	58 04       	cp.w	r4,0
800092d0:	c2 11       	brne	80009312 <_dtoa_r+0x4e2>
800092d2:	fa ea 00 08 	ld.d	r10,sp[8]
800092d6:	30 08       	mov	r8,0
800092d8:	fc 19 40 14 	movh	r9,0x4014
800092dc:	e0 a0 0c fe 	rcall	8000acd8 <__avr32_f64_sub>
800092e0:	40 bc       	lddsp	r12,sp[0x2c]
800092e2:	fa eb 00 08 	st.d	sp[8],r10
800092e6:	14 98       	mov	r8,r10
800092e8:	16 99       	mov	r9,r11
800092ea:	18 9a       	mov	r10,r12
800092ec:	0a 9b       	mov	r11,r5
800092ee:	e0 a0 0f 1b 	rcall	8000b124 <__avr32_f64_cmp_lt>
800092f2:	e0 81 02 54 	brne	8000979a <_dtoa_r+0x96a>
800092f6:	0a 98       	mov	r8,r5
800092f8:	40 b9       	lddsp	r9,sp[0x2c]
800092fa:	ee 18 80 00 	eorh	r8,0x8000
800092fe:	fa ea 00 08 	ld.d	r10,sp[8]
80009302:	10 95       	mov	r5,r8
80009304:	12 98       	mov	r8,r9
80009306:	0a 99       	mov	r9,r5
80009308:	e0 a0 0f 0e 	rcall	8000b124 <__avr32_f64_cmp_lt>
8000930c:	e0 81 02 3e 	brne	80009788 <_dtoa_r+0x958>
80009310:	ca 68       	rjmp	8000945c <_dtoa_r+0x62c>
80009312:	fe c9 c5 ca 	sub	r9,pc,-14902
80009316:	e8 c8 00 01 	sub	r8,r4,1
8000931a:	40 d5       	lddsp	r5,sp[0x34]
8000931c:	58 05       	cp.w	r5,0
8000931e:	c4 f0       	breq	800093bc <_dtoa_r+0x58c>
80009320:	30 0c       	mov	r12,0
80009322:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
80009326:	51 3c       	stdsp	sp[0x4c],r12
80009328:	30 0a       	mov	r10,0
8000932a:	fc 1b 3f e0 	movh	r11,0x3fe0
8000932e:	e0 a0 0f 2f 	rcall	8000b18c <__avr32_f64_div>
80009332:	fa e8 00 28 	ld.d	r8,sp[40]
80009336:	40 85       	lddsp	r5,sp[0x20]
80009338:	e0 a0 0c d0 	rcall	8000acd8 <__avr32_f64_sub>
8000933c:	fa eb 00 28 	st.d	sp[40],r10
80009340:	fa ea 00 08 	ld.d	r10,sp[8]
80009344:	e0 a0 0e 22 	rcall	8000af88 <__avr32_f64_to_s32>
80009348:	51 6c       	stdsp	sp[0x58],r12
8000934a:	e0 a0 0e 36 	rcall	8000afb6 <__avr32_s32_to_f64>
8000934e:	14 98       	mov	r8,r10
80009350:	16 99       	mov	r9,r11
80009352:	fa ea 00 08 	ld.d	r10,sp[8]
80009356:	e0 a0 0c c1 	rcall	8000acd8 <__avr32_f64_sub>
8000935a:	fa eb 00 08 	st.d	sp[8],r10
8000935e:	41 68       	lddsp	r8,sp[0x58]
80009360:	2d 08       	sub	r8,-48
80009362:	0a c8       	st.b	r5++,r8
80009364:	41 39       	lddsp	r9,sp[0x4c]
80009366:	2f f9       	sub	r9,-1
80009368:	51 39       	stdsp	sp[0x4c],r9
8000936a:	fa e8 00 28 	ld.d	r8,sp[40]
8000936e:	e0 a0 0e db 	rcall	8000b124 <__avr32_f64_cmp_lt>
80009372:	e0 81 03 39 	brne	800099e4 <_dtoa_r+0xbb4>
80009376:	fa e8 00 08 	ld.d	r8,sp[8]
8000937a:	30 0a       	mov	r10,0
8000937c:	fc 1b 3f f0 	movh	r11,0x3ff0
80009380:	e0 a0 0c ac 	rcall	8000acd8 <__avr32_f64_sub>
80009384:	fa e8 00 28 	ld.d	r8,sp[40]
80009388:	e0 a0 0e ce 	rcall	8000b124 <__avr32_f64_cmp_lt>
8000938c:	fa ea 00 28 	ld.d	r10,sp[40]
80009390:	30 08       	mov	r8,0
80009392:	fc 19 40 24 	movh	r9,0x4024
80009396:	e0 81 00 da 	brne	8000954a <_dtoa_r+0x71a>
8000939a:	41 3c       	lddsp	r12,sp[0x4c]
8000939c:	08 3c       	cp.w	r12,r4
8000939e:	c5 f4       	brge	8000945c <_dtoa_r+0x62c>
800093a0:	e0 a0 0b b0 	rcall	8000ab00 <__avr32_f64_mul>
800093a4:	30 08       	mov	r8,0
800093a6:	fa eb 00 28 	st.d	sp[40],r10
800093aa:	fc 19 40 24 	movh	r9,0x4024
800093ae:	fa ea 00 08 	ld.d	r10,sp[8]
800093b2:	e0 a0 0b a7 	rcall	8000ab00 <__avr32_f64_mul>
800093b6:	fa eb 00 08 	st.d	sp[8],r10
800093ba:	cc 3b       	rjmp	80009340 <_dtoa_r+0x510>
800093bc:	40 85       	lddsp	r5,sp[0x20]
800093be:	08 05       	add	r5,r4
800093c0:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
800093c4:	51 35       	stdsp	sp[0x4c],r5
800093c6:	fa e8 00 28 	ld.d	r8,sp[40]
800093ca:	40 85       	lddsp	r5,sp[0x20]
800093cc:	e0 a0 0b 9a 	rcall	8000ab00 <__avr32_f64_mul>
800093d0:	fa eb 00 28 	st.d	sp[40],r10
800093d4:	fa ea 00 08 	ld.d	r10,sp[8]
800093d8:	e0 a0 0d d8 	rcall	8000af88 <__avr32_f64_to_s32>
800093dc:	51 6c       	stdsp	sp[0x58],r12
800093de:	e0 a0 0d ec 	rcall	8000afb6 <__avr32_s32_to_f64>
800093e2:	14 98       	mov	r8,r10
800093e4:	16 99       	mov	r9,r11
800093e6:	fa ea 00 08 	ld.d	r10,sp[8]
800093ea:	e0 a0 0c 77 	rcall	8000acd8 <__avr32_f64_sub>
800093ee:	fa eb 00 08 	st.d	sp[8],r10
800093f2:	41 68       	lddsp	r8,sp[0x58]
800093f4:	2d 08       	sub	r8,-48
800093f6:	0a c8       	st.b	r5++,r8
800093f8:	41 3c       	lddsp	r12,sp[0x4c]
800093fa:	18 35       	cp.w	r5,r12
800093fc:	c2 81       	brne	8000944c <_dtoa_r+0x61c>
800093fe:	30 08       	mov	r8,0
80009400:	fc 19 3f e0 	movh	r9,0x3fe0
80009404:	fa ea 00 28 	ld.d	r10,sp[40]
80009408:	e0 a0 0d 36 	rcall	8000ae74 <__avr32_f64_add>
8000940c:	40 85       	lddsp	r5,sp[0x20]
8000940e:	fa e8 00 08 	ld.d	r8,sp[8]
80009412:	08 05       	add	r5,r4
80009414:	e0 a0 0e 88 	rcall	8000b124 <__avr32_f64_cmp_lt>
80009418:	e0 81 00 99 	brne	8000954a <_dtoa_r+0x71a>
8000941c:	fa e8 00 28 	ld.d	r8,sp[40]
80009420:	30 0a       	mov	r10,0
80009422:	fc 1b 3f e0 	movh	r11,0x3fe0
80009426:	e0 a0 0c 59 	rcall	8000acd8 <__avr32_f64_sub>
8000942a:	14 98       	mov	r8,r10
8000942c:	16 99       	mov	r9,r11
8000942e:	fa ea 00 08 	ld.d	r10,sp[8]
80009432:	e0 a0 0e 79 	rcall	8000b124 <__avr32_f64_cmp_lt>
80009436:	c1 30       	breq	8000945c <_dtoa_r+0x62c>
80009438:	33 09       	mov	r9,48
8000943a:	0a 98       	mov	r8,r5
8000943c:	11 7a       	ld.ub	r10,--r8
8000943e:	f2 0a 18 00 	cp.b	r10,r9
80009442:	e0 81 02 d1 	brne	800099e4 <_dtoa_r+0xbb4>
80009446:	10 95       	mov	r5,r8
80009448:	cf 9b       	rjmp	8000943a <_dtoa_r+0x60a>
8000944a:	d7 03       	nop
8000944c:	30 08       	mov	r8,0
8000944e:	fc 19 40 24 	movh	r9,0x4024
80009452:	e0 a0 0b 57 	rcall	8000ab00 <__avr32_f64_mul>
80009456:	fa eb 00 08 	st.d	sp[8],r10
8000945a:	cb db       	rjmp	800093d4 <_dtoa_r+0x5a4>
8000945c:	fa ea 00 3c 	ld.d	r10,sp[60]
80009460:	fa eb 00 08 	st.d	sp[8],r10
80009464:	58 e6       	cp.w	r6,14
80009466:	5f ab       	srle	r11
80009468:	41 8a       	lddsp	r10,sp[0x60]
8000946a:	30 08       	mov	r8,0
8000946c:	f4 09 11 ff 	rsub	r9,r10,-1
80009470:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80009474:	f0 09 18 00 	cp.b	r9,r8
80009478:	e0 80 00 82 	breq	8000957c <_dtoa_r+0x74c>
8000947c:	40 ea       	lddsp	r10,sp[0x38]
8000947e:	58 01       	cp.w	r1,0
80009480:	5f a9       	srle	r9
80009482:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80009486:	fe ca c7 3e 	sub	r10,pc,-14530
8000948a:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
8000948e:	fa e5 00 10 	st.d	sp[16],r4
80009492:	f0 09 18 00 	cp.b	r9,r8
80009496:	c1 40       	breq	800094be <_dtoa_r+0x68e>
80009498:	58 01       	cp.w	r1,0
8000949a:	e0 81 01 77 	brne	80009788 <_dtoa_r+0x958>
8000949e:	30 08       	mov	r8,0
800094a0:	fc 19 40 14 	movh	r9,0x4014
800094a4:	08 9a       	mov	r10,r4
800094a6:	0a 9b       	mov	r11,r5
800094a8:	e0 a0 0b 2c 	rcall	8000ab00 <__avr32_f64_mul>
800094ac:	fa e8 00 08 	ld.d	r8,sp[8]
800094b0:	e0 a0 0e 06 	rcall	8000b0bc <__avr32_f64_cmp_ge>
800094b4:	e0 81 01 6a 	brne	80009788 <_dtoa_r+0x958>
800094b8:	02 92       	mov	r2,r1
800094ba:	e0 8f 01 72 	bral	8000979e <_dtoa_r+0x96e>
800094be:	40 85       	lddsp	r5,sp[0x20]
800094c0:	30 14       	mov	r4,1
800094c2:	fa e8 00 10 	ld.d	r8,sp[16]
800094c6:	fa ea 00 08 	ld.d	r10,sp[8]
800094ca:	e0 a0 0e 61 	rcall	8000b18c <__avr32_f64_div>
800094ce:	e0 a0 0d 5d 	rcall	8000af88 <__avr32_f64_to_s32>
800094d2:	18 92       	mov	r2,r12
800094d4:	e0 a0 0d 71 	rcall	8000afb6 <__avr32_s32_to_f64>
800094d8:	fa e8 00 10 	ld.d	r8,sp[16]
800094dc:	e0 a0 0b 12 	rcall	8000ab00 <__avr32_f64_mul>
800094e0:	14 98       	mov	r8,r10
800094e2:	16 99       	mov	r9,r11
800094e4:	fa ea 00 08 	ld.d	r10,sp[8]
800094e8:	e0 a0 0b f8 	rcall	8000acd8 <__avr32_f64_sub>
800094ec:	fa eb 00 08 	st.d	sp[8],r10
800094f0:	e4 c8 ff d0 	sub	r8,r2,-48
800094f4:	0a c8       	st.b	r5++,r8
800094f6:	fc 19 40 24 	movh	r9,0x4024
800094fa:	30 08       	mov	r8,0
800094fc:	02 34       	cp.w	r4,r1
800094fe:	c3 31       	brne	80009564 <_dtoa_r+0x734>
80009500:	fa e8 00 08 	ld.d	r8,sp[8]
80009504:	e0 a0 0c b8 	rcall	8000ae74 <__avr32_f64_add>
80009508:	16 91       	mov	r1,r11
8000950a:	14 90       	mov	r0,r10
8000950c:	14 98       	mov	r8,r10
8000950e:	02 99       	mov	r9,r1
80009510:	fa ea 00 10 	ld.d	r10,sp[16]
80009514:	e0 a0 0e 08 	rcall	8000b124 <__avr32_f64_cmp_lt>
80009518:	c1 a1       	brne	8000954c <_dtoa_r+0x71c>
8000951a:	fa e8 00 10 	ld.d	r8,sp[16]
8000951e:	00 9a       	mov	r10,r0
80009520:	02 9b       	mov	r11,r1
80009522:	e0 a0 0d ba 	rcall	8000b096 <__avr32_f64_cmp_eq>
80009526:	e0 80 02 5e 	breq	800099e2 <_dtoa_r+0xbb2>
8000952a:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8000952e:	c0 f1       	brne	8000954c <_dtoa_r+0x71c>
80009530:	e0 8f 02 59 	bral	800099e2 <_dtoa_r+0xbb2>
80009534:	40 8a       	lddsp	r10,sp[0x20]
80009536:	14 38       	cp.w	r8,r10
80009538:	c0 30       	breq	8000953e <_dtoa_r+0x70e>
8000953a:	10 95       	mov	r5,r8
8000953c:	c0 98       	rjmp	8000954e <_dtoa_r+0x71e>
8000953e:	33 08       	mov	r8,48
80009540:	40 89       	lddsp	r9,sp[0x20]
80009542:	2f f6       	sub	r6,-1
80009544:	b2 88       	st.b	r9[0x0],r8
80009546:	40 88       	lddsp	r8,sp[0x20]
80009548:	c0 88       	rjmp	80009558 <_dtoa_r+0x728>
8000954a:	40 66       	lddsp	r6,sp[0x18]
8000954c:	33 99       	mov	r9,57
8000954e:	0a 98       	mov	r8,r5
80009550:	11 7a       	ld.ub	r10,--r8
80009552:	f2 0a 18 00 	cp.b	r10,r9
80009556:	ce f0       	breq	80009534 <_dtoa_r+0x704>
80009558:	50 66       	stdsp	sp[0x18],r6
8000955a:	11 89       	ld.ub	r9,r8[0x0]
8000955c:	2f f9       	sub	r9,-1
8000955e:	b0 89       	st.b	r8[0x0],r9
80009560:	e0 8f 02 42 	bral	800099e4 <_dtoa_r+0xbb4>
80009564:	e0 a0 0a ce 	rcall	8000ab00 <__avr32_f64_mul>
80009568:	2f f4       	sub	r4,-1
8000956a:	fa eb 00 08 	st.d	sp[8],r10
8000956e:	30 08       	mov	r8,0
80009570:	30 09       	mov	r9,0
80009572:	e0 a0 0d 92 	rcall	8000b096 <__avr32_f64_cmp_eq>
80009576:	ca 60       	breq	800094c2 <_dtoa_r+0x692>
80009578:	e0 8f 02 35 	bral	800099e2 <_dtoa_r+0xbb2>
8000957c:	40 d8       	lddsp	r8,sp[0x34]
8000957e:	58 08       	cp.w	r8,0
80009580:	c0 51       	brne	8000958a <_dtoa_r+0x75a>
80009582:	04 98       	mov	r8,r2
80009584:	00 95       	mov	r5,r0
80009586:	40 d4       	lddsp	r4,sp[0x34]
80009588:	c3 78       	rjmp	800095f6 <_dtoa_r+0x7c6>
8000958a:	40 c5       	lddsp	r5,sp[0x30]
8000958c:	58 15       	cp.w	r5,1
8000958e:	e0 89 00 0f 	brgt	800095ac <_dtoa_r+0x77c>
80009592:	41 74       	lddsp	r4,sp[0x5c]
80009594:	58 04       	cp.w	r4,0
80009596:	c0 40       	breq	8000959e <_dtoa_r+0x76e>
80009598:	f4 c9 fb cd 	sub	r9,r10,-1075
8000959c:	c0 48       	rjmp	800095a4 <_dtoa_r+0x774>
8000959e:	41 99       	lddsp	r9,sp[0x64]
800095a0:	f2 09 11 36 	rsub	r9,r9,54
800095a4:	04 98       	mov	r8,r2
800095a6:	00 95       	mov	r5,r0
800095a8:	c1 c8       	rjmp	800095e0 <_dtoa_r+0x7b0>
800095aa:	d7 03       	nop
800095ac:	e2 c8 00 01 	sub	r8,r1,1
800095b0:	58 01       	cp.w	r1,0
800095b2:	e0 05 17 40 	movge	r5,r0
800095b6:	e2 09 17 40 	movge	r9,r1
800095ba:	e1 d1 e5 15 	sublt	r5,r0,r1
800095be:	f9 b9 05 00 	movlt	r9,0
800095c2:	10 32       	cp.w	r2,r8
800095c4:	e5 d8 e4 18 	subge	r8,r2,r8
800095c8:	f1 d2 e5 18 	sublt	r8,r8,r2
800095cc:	e5 d8 e5 02 	addlt	r2,r2,r8
800095d0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
800095d4:	f9 d8 e5 0c 	addlt	r12,r12,r8
800095d8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
800095dc:	f9 b8 05 00 	movlt	r8,0
800095e0:	40 4b       	lddsp	r11,sp[0x10]
800095e2:	12 0b       	add	r11,r9
800095e4:	50 08       	stdsp	sp[0x0],r8
800095e6:	50 4b       	stdsp	sp[0x10],r11
800095e8:	12 00       	add	r0,r9
800095ea:	30 1b       	mov	r11,1
800095ec:	0e 9c       	mov	r12,r7
800095ee:	e0 a0 08 a7 	rcall	8000a73c <__i2b>
800095f2:	40 08       	lddsp	r8,sp[0x0]
800095f4:	18 94       	mov	r4,r12
800095f6:	40 4a       	lddsp	r10,sp[0x10]
800095f8:	58 05       	cp.w	r5,0
800095fa:	5f 99       	srgt	r9
800095fc:	58 0a       	cp.w	r10,0
800095fe:	5f 9a       	srgt	r10
80009600:	f5 e9 00 09 	and	r9,r10,r9
80009604:	c0 80       	breq	80009614 <_dtoa_r+0x7e4>
80009606:	40 4c       	lddsp	r12,sp[0x10]
80009608:	f8 05 0d 49 	min	r9,r12,r5
8000960c:	12 1c       	sub	r12,r9
8000960e:	12 10       	sub	r0,r9
80009610:	50 4c       	stdsp	sp[0x10],r12
80009612:	12 15       	sub	r5,r9
80009614:	58 02       	cp.w	r2,0
80009616:	e0 8a 00 27 	brle	80009664 <_dtoa_r+0x834>
8000961a:	40 db       	lddsp	r11,sp[0x34]
8000961c:	58 0b       	cp.w	r11,0
8000961e:	c1 d0       	breq	80009658 <_dtoa_r+0x828>
80009620:	58 08       	cp.w	r8,0
80009622:	e0 8a 00 17 	brle	80009650 <_dtoa_r+0x820>
80009626:	10 9a       	mov	r10,r8
80009628:	50 08       	stdsp	sp[0x0],r8
8000962a:	08 9b       	mov	r11,r4
8000962c:	0e 9c       	mov	r12,r7
8000962e:	e0 a0 08 cd 	rcall	8000a7c8 <__pow5mult>
80009632:	06 9a       	mov	r10,r3
80009634:	18 9b       	mov	r11,r12
80009636:	18 94       	mov	r4,r12
80009638:	0e 9c       	mov	r12,r7
8000963a:	e0 a0 08 01 	rcall	8000a63c <__multiply>
8000963e:	18 99       	mov	r9,r12
80009640:	06 9b       	mov	r11,r3
80009642:	50 19       	stdsp	sp[0x4],r9
80009644:	0e 9c       	mov	r12,r7
80009646:	e0 a0 06 ad 	rcall	8000a3a0 <_Bfree>
8000964a:	40 19       	lddsp	r9,sp[0x4]
8000964c:	40 08       	lddsp	r8,sp[0x0]
8000964e:	12 93       	mov	r3,r9
80009650:	e4 08 01 0a 	sub	r10,r2,r8
80009654:	c0 80       	breq	80009664 <_dtoa_r+0x834>
80009656:	c0 28       	rjmp	8000965a <_dtoa_r+0x82a>
80009658:	04 9a       	mov	r10,r2
8000965a:	06 9b       	mov	r11,r3
8000965c:	0e 9c       	mov	r12,r7
8000965e:	e0 a0 08 b5 	rcall	8000a7c8 <__pow5mult>
80009662:	18 93       	mov	r3,r12
80009664:	30 1b       	mov	r11,1
80009666:	0e 9c       	mov	r12,r7
80009668:	e0 a0 08 6a 	rcall	8000a73c <__i2b>
8000966c:	41 1a       	lddsp	r10,sp[0x44]
8000966e:	18 92       	mov	r2,r12
80009670:	58 0a       	cp.w	r10,0
80009672:	e0 8a 00 07 	brle	80009680 <_dtoa_r+0x850>
80009676:	18 9b       	mov	r11,r12
80009678:	0e 9c       	mov	r12,r7
8000967a:	e0 a0 08 a7 	rcall	8000a7c8 <__pow5mult>
8000967e:	18 92       	mov	r2,r12
80009680:	40 c9       	lddsp	r9,sp[0x30]
80009682:	58 19       	cp.w	r9,1
80009684:	e0 89 00 14 	brgt	800096ac <_dtoa_r+0x87c>
80009688:	40 38       	lddsp	r8,sp[0xc]
8000968a:	58 08       	cp.w	r8,0
8000968c:	c1 01       	brne	800096ac <_dtoa_r+0x87c>
8000968e:	40 29       	lddsp	r9,sp[0x8]
80009690:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80009694:	c0 c1       	brne	800096ac <_dtoa_r+0x87c>
80009696:	12 98       	mov	r8,r9
80009698:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000969c:	c0 80       	breq	800096ac <_dtoa_r+0x87c>
8000969e:	40 4c       	lddsp	r12,sp[0x10]
800096a0:	30 1b       	mov	r11,1
800096a2:	2f fc       	sub	r12,-1
800096a4:	2f f0       	sub	r0,-1
800096a6:	50 4c       	stdsp	sp[0x10],r12
800096a8:	50 6b       	stdsp	sp[0x18],r11
800096aa:	c0 38       	rjmp	800096b0 <_dtoa_r+0x880>
800096ac:	30 0a       	mov	r10,0
800096ae:	50 6a       	stdsp	sp[0x18],r10
800096b0:	41 19       	lddsp	r9,sp[0x44]
800096b2:	58 09       	cp.w	r9,0
800096b4:	c0 31       	brne	800096ba <_dtoa_r+0x88a>
800096b6:	30 1c       	mov	r12,1
800096b8:	c0 98       	rjmp	800096ca <_dtoa_r+0x89a>
800096ba:	64 48       	ld.w	r8,r2[0x10]
800096bc:	2f c8       	sub	r8,-4
800096be:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
800096c2:	e0 a0 05 df 	rcall	8000a280 <__hi0bits>
800096c6:	f8 0c 11 20 	rsub	r12,r12,32
800096ca:	40 4b       	lddsp	r11,sp[0x10]
800096cc:	f8 0b 00 08 	add	r8,r12,r11
800096d0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800096d4:	c0 c0       	breq	800096ec <_dtoa_r+0x8bc>
800096d6:	f0 08 11 20 	rsub	r8,r8,32
800096da:	58 48       	cp.w	r8,4
800096dc:	e0 8a 00 06 	brle	800096e8 <_dtoa_r+0x8b8>
800096e0:	20 48       	sub	r8,4
800096e2:	10 0b       	add	r11,r8
800096e4:	50 4b       	stdsp	sp[0x10],r11
800096e6:	c0 78       	rjmp	800096f4 <_dtoa_r+0x8c4>
800096e8:	58 48       	cp.w	r8,4
800096ea:	c0 70       	breq	800096f8 <_dtoa_r+0x8c8>
800096ec:	40 4a       	lddsp	r10,sp[0x10]
800096ee:	2e 48       	sub	r8,-28
800096f0:	10 0a       	add	r10,r8
800096f2:	50 4a       	stdsp	sp[0x10],r10
800096f4:	10 00       	add	r0,r8
800096f6:	10 05       	add	r5,r8
800096f8:	58 00       	cp.w	r0,0
800096fa:	e0 8a 00 08 	brle	8000970a <_dtoa_r+0x8da>
800096fe:	06 9b       	mov	r11,r3
80009700:	00 9a       	mov	r10,r0
80009702:	0e 9c       	mov	r12,r7
80009704:	e0 a0 07 58 	rcall	8000a5b4 <__lshift>
80009708:	18 93       	mov	r3,r12
8000970a:	40 49       	lddsp	r9,sp[0x10]
8000970c:	58 09       	cp.w	r9,0
8000970e:	e0 8a 00 08 	brle	8000971e <_dtoa_r+0x8ee>
80009712:	04 9b       	mov	r11,r2
80009714:	12 9a       	mov	r10,r9
80009716:	0e 9c       	mov	r12,r7
80009718:	e0 a0 07 4e 	rcall	8000a5b4 <__lshift>
8000971c:	18 92       	mov	r2,r12
8000971e:	41 48       	lddsp	r8,sp[0x50]
80009720:	58 08       	cp.w	r8,0
80009722:	c1 b0       	breq	80009758 <_dtoa_r+0x928>
80009724:	04 9b       	mov	r11,r2
80009726:	06 9c       	mov	r12,r3
80009728:	e0 a0 06 23 	rcall	8000a36e <__mcmp>
8000972c:	c1 64       	brge	80009758 <_dtoa_r+0x928>
8000972e:	06 9b       	mov	r11,r3
80009730:	30 09       	mov	r9,0
80009732:	30 aa       	mov	r10,10
80009734:	0e 9c       	mov	r12,r7
80009736:	e0 a0 08 0b 	rcall	8000a74c <__multadd>
8000973a:	20 16       	sub	r6,1
8000973c:	18 93       	mov	r3,r12
8000973e:	40 dc       	lddsp	r12,sp[0x34]
80009740:	58 0c       	cp.w	r12,0
80009742:	c0 31       	brne	80009748 <_dtoa_r+0x918>
80009744:	40 91       	lddsp	r1,sp[0x24]
80009746:	c0 98       	rjmp	80009758 <_dtoa_r+0x928>
80009748:	08 9b       	mov	r11,r4
8000974a:	40 91       	lddsp	r1,sp[0x24]
8000974c:	30 09       	mov	r9,0
8000974e:	30 aa       	mov	r10,10
80009750:	0e 9c       	mov	r12,r7
80009752:	e0 a0 07 fd 	rcall	8000a74c <__multadd>
80009756:	18 94       	mov	r4,r12
80009758:	58 01       	cp.w	r1,0
8000975a:	5f a9       	srle	r9
8000975c:	40 cb       	lddsp	r11,sp[0x30]
8000975e:	58 2b       	cp.w	r11,2
80009760:	5f 98       	srgt	r8
80009762:	f3 e8 00 08 	and	r8,r9,r8
80009766:	c2 50       	breq	800097b0 <_dtoa_r+0x980>
80009768:	58 01       	cp.w	r1,0
8000976a:	c1 11       	brne	8000978c <_dtoa_r+0x95c>
8000976c:	04 9b       	mov	r11,r2
8000976e:	02 99       	mov	r9,r1
80009770:	30 5a       	mov	r10,5
80009772:	0e 9c       	mov	r12,r7
80009774:	e0 a0 07 ec 	rcall	8000a74c <__multadd>
80009778:	18 92       	mov	r2,r12
8000977a:	18 9b       	mov	r11,r12
8000977c:	06 9c       	mov	r12,r3
8000977e:	e0 a0 05 f8 	rcall	8000a36e <__mcmp>
80009782:	e0 89 00 0f 	brgt	800097a0 <_dtoa_r+0x970>
80009786:	c0 38       	rjmp	8000978c <_dtoa_r+0x95c>
80009788:	30 02       	mov	r2,0
8000978a:	04 94       	mov	r4,r2
8000978c:	40 ea       	lddsp	r10,sp[0x38]
8000978e:	30 09       	mov	r9,0
80009790:	5c da       	com	r10
80009792:	40 85       	lddsp	r5,sp[0x20]
80009794:	50 6a       	stdsp	sp[0x18],r10
80009796:	50 49       	stdsp	sp[0x10],r9
80009798:	c0 f9       	rjmp	800099b6 <_dtoa_r+0xb86>
8000979a:	08 92       	mov	r2,r4
8000979c:	40 66       	lddsp	r6,sp[0x18]
8000979e:	04 94       	mov	r4,r2
800097a0:	2f f6       	sub	r6,-1
800097a2:	50 66       	stdsp	sp[0x18],r6
800097a4:	33 18       	mov	r8,49
800097a6:	40 85       	lddsp	r5,sp[0x20]
800097a8:	0a c8       	st.b	r5++,r8
800097aa:	30 08       	mov	r8,0
800097ac:	50 48       	stdsp	sp[0x10],r8
800097ae:	c0 49       	rjmp	800099b6 <_dtoa_r+0xb86>
800097b0:	40 dc       	lddsp	r12,sp[0x34]
800097b2:	58 0c       	cp.w	r12,0
800097b4:	e0 80 00 b5 	breq	8000991e <_dtoa_r+0xaee>
800097b8:	58 05       	cp.w	r5,0
800097ba:	e0 8a 00 08 	brle	800097ca <_dtoa_r+0x99a>
800097be:	08 9b       	mov	r11,r4
800097c0:	0a 9a       	mov	r10,r5
800097c2:	0e 9c       	mov	r12,r7
800097c4:	e0 a0 06 f8 	rcall	8000a5b4 <__lshift>
800097c8:	18 94       	mov	r4,r12
800097ca:	40 6b       	lddsp	r11,sp[0x18]
800097cc:	58 0b       	cp.w	r11,0
800097ce:	c0 31       	brne	800097d4 <_dtoa_r+0x9a4>
800097d0:	08 9c       	mov	r12,r4
800097d2:	c1 38       	rjmp	800097f8 <_dtoa_r+0x9c8>
800097d4:	68 1b       	ld.w	r11,r4[0x4]
800097d6:	0e 9c       	mov	r12,r7
800097d8:	e0 a0 05 fe 	rcall	8000a3d4 <_Balloc>
800097dc:	68 4a       	ld.w	r10,r4[0x10]
800097de:	18 95       	mov	r5,r12
800097e0:	e8 cb ff f4 	sub	r11,r4,-12
800097e4:	2f ea       	sub	r10,-2
800097e6:	2f 4c       	sub	r12,-12
800097e8:	a3 6a       	lsl	r10,0x2
800097ea:	fe b0 e6 50 	rcall	8000648a <memcpy>
800097ee:	0a 9b       	mov	r11,r5
800097f0:	30 1a       	mov	r10,1
800097f2:	0e 9c       	mov	r12,r7
800097f4:	e0 a0 06 e0 	rcall	8000a5b4 <__lshift>
800097f8:	50 44       	stdsp	sp[0x10],r4
800097fa:	40 3a       	lddsp	r10,sp[0xc]
800097fc:	30 19       	mov	r9,1
800097fe:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80009802:	18 94       	mov	r4,r12
80009804:	50 da       	stdsp	sp[0x34],r10
80009806:	40 85       	lddsp	r5,sp[0x20]
80009808:	50 99       	stdsp	sp[0x24],r9
8000980a:	50 26       	stdsp	sp[0x8],r6
8000980c:	50 e1       	stdsp	sp[0x38],r1
8000980e:	04 9b       	mov	r11,r2
80009810:	06 9c       	mov	r12,r3
80009812:	fe b0 fa 7f 	rcall	80008d10 <quorem>
80009816:	40 4b       	lddsp	r11,sp[0x10]
80009818:	f8 c0 ff d0 	sub	r0,r12,-48
8000981c:	06 9c       	mov	r12,r3
8000981e:	e0 a0 05 a8 	rcall	8000a36e <__mcmp>
80009822:	08 9a       	mov	r10,r4
80009824:	50 6c       	stdsp	sp[0x18],r12
80009826:	04 9b       	mov	r11,r2
80009828:	0e 9c       	mov	r12,r7
8000982a:	e0 a0 06 5d 	rcall	8000a4e4 <__mdiff>
8000982e:	18 91       	mov	r1,r12
80009830:	78 38       	ld.w	r8,r12[0xc]
80009832:	58 08       	cp.w	r8,0
80009834:	c0 30       	breq	8000983a <_dtoa_r+0xa0a>
80009836:	30 16       	mov	r6,1
80009838:	c0 68       	rjmp	80009844 <_dtoa_r+0xa14>
8000983a:	18 9b       	mov	r11,r12
8000983c:	06 9c       	mov	r12,r3
8000983e:	e0 a0 05 98 	rcall	8000a36e <__mcmp>
80009842:	18 96       	mov	r6,r12
80009844:	0e 9c       	mov	r12,r7
80009846:	02 9b       	mov	r11,r1
80009848:	e0 a0 05 ac 	rcall	8000a3a0 <_Bfree>
8000984c:	40 cc       	lddsp	r12,sp[0x30]
8000984e:	ed ec 10 08 	or	r8,r6,r12
80009852:	c0 d1       	brne	8000986c <_dtoa_r+0xa3c>
80009854:	40 db       	lddsp	r11,sp[0x34]
80009856:	58 0b       	cp.w	r11,0
80009858:	c0 a1       	brne	8000986c <_dtoa_r+0xa3c>
8000985a:	40 26       	lddsp	r6,sp[0x8]
8000985c:	e0 40 00 39 	cp.w	r0,57
80009860:	c3 00       	breq	800098c0 <_dtoa_r+0xa90>
80009862:	40 6a       	lddsp	r10,sp[0x18]
80009864:	58 0a       	cp.w	r10,0
80009866:	e0 89 00 24 	brgt	800098ae <_dtoa_r+0xa7e>
8000986a:	c2 f8       	rjmp	800098c8 <_dtoa_r+0xa98>
8000986c:	40 69       	lddsp	r9,sp[0x18]
8000986e:	58 09       	cp.w	r9,0
80009870:	c0 85       	brlt	80009880 <_dtoa_r+0xa50>
80009872:	12 98       	mov	r8,r9
80009874:	40 cc       	lddsp	r12,sp[0x30]
80009876:	18 48       	or	r8,r12
80009878:	c1 d1       	brne	800098b2 <_dtoa_r+0xa82>
8000987a:	40 db       	lddsp	r11,sp[0x34]
8000987c:	58 0b       	cp.w	r11,0
8000987e:	c1 a1       	brne	800098b2 <_dtoa_r+0xa82>
80009880:	0c 99       	mov	r9,r6
80009882:	40 26       	lddsp	r6,sp[0x8]
80009884:	58 09       	cp.w	r9,0
80009886:	e0 8a 00 21 	brle	800098c8 <_dtoa_r+0xa98>
8000988a:	06 9b       	mov	r11,r3
8000988c:	30 1a       	mov	r10,1
8000988e:	0e 9c       	mov	r12,r7
80009890:	e0 a0 06 92 	rcall	8000a5b4 <__lshift>
80009894:	04 9b       	mov	r11,r2
80009896:	18 93       	mov	r3,r12
80009898:	e0 a0 05 6b 	rcall	8000a36e <__mcmp>
8000989c:	e0 89 00 06 	brgt	800098a8 <_dtoa_r+0xa78>
800098a0:	c1 41       	brne	800098c8 <_dtoa_r+0xa98>
800098a2:	ed b0 00 00 	bld	r0,0x0
800098a6:	c1 11       	brne	800098c8 <_dtoa_r+0xa98>
800098a8:	e0 40 00 39 	cp.w	r0,57
800098ac:	c0 a0       	breq	800098c0 <_dtoa_r+0xa90>
800098ae:	2f f0       	sub	r0,-1
800098b0:	c0 c8       	rjmp	800098c8 <_dtoa_r+0xa98>
800098b2:	58 06       	cp.w	r6,0
800098b4:	e0 8a 00 0c 	brle	800098cc <_dtoa_r+0xa9c>
800098b8:	40 26       	lddsp	r6,sp[0x8]
800098ba:	e0 40 00 39 	cp.w	r0,57
800098be:	c0 41       	brne	800098c6 <_dtoa_r+0xa96>
800098c0:	33 98       	mov	r8,57
800098c2:	0a c8       	st.b	r5++,r8
800098c4:	c6 78       	rjmp	80009992 <_dtoa_r+0xb62>
800098c6:	2f f0       	sub	r0,-1
800098c8:	0a c0       	st.b	r5++,r0
800098ca:	c7 58       	rjmp	800099b4 <_dtoa_r+0xb84>
800098cc:	0a c0       	st.b	r5++,r0
800098ce:	40 9a       	lddsp	r10,sp[0x24]
800098d0:	40 e9       	lddsp	r9,sp[0x38]
800098d2:	12 3a       	cp.w	r10,r9
800098d4:	c4 30       	breq	8000995a <_dtoa_r+0xb2a>
800098d6:	06 9b       	mov	r11,r3
800098d8:	30 09       	mov	r9,0
800098da:	30 aa       	mov	r10,10
800098dc:	0e 9c       	mov	r12,r7
800098de:	e0 a0 07 37 	rcall	8000a74c <__multadd>
800098e2:	40 48       	lddsp	r8,sp[0x10]
800098e4:	18 93       	mov	r3,r12
800098e6:	08 38       	cp.w	r8,r4
800098e8:	c0 91       	brne	800098fa <_dtoa_r+0xaca>
800098ea:	10 9b       	mov	r11,r8
800098ec:	30 09       	mov	r9,0
800098ee:	30 aa       	mov	r10,10
800098f0:	0e 9c       	mov	r12,r7
800098f2:	e0 a0 07 2d 	rcall	8000a74c <__multadd>
800098f6:	50 4c       	stdsp	sp[0x10],r12
800098f8:	c0 e8       	rjmp	80009914 <_dtoa_r+0xae4>
800098fa:	40 4b       	lddsp	r11,sp[0x10]
800098fc:	30 09       	mov	r9,0
800098fe:	30 aa       	mov	r10,10
80009900:	0e 9c       	mov	r12,r7
80009902:	e0 a0 07 25 	rcall	8000a74c <__multadd>
80009906:	08 9b       	mov	r11,r4
80009908:	50 4c       	stdsp	sp[0x10],r12
8000990a:	30 09       	mov	r9,0
8000990c:	30 aa       	mov	r10,10
8000990e:	0e 9c       	mov	r12,r7
80009910:	e0 a0 07 1e 	rcall	8000a74c <__multadd>
80009914:	18 94       	mov	r4,r12
80009916:	40 9c       	lddsp	r12,sp[0x24]
80009918:	2f fc       	sub	r12,-1
8000991a:	50 9c       	stdsp	sp[0x24],r12
8000991c:	c7 9b       	rjmp	8000980e <_dtoa_r+0x9de>
8000991e:	30 18       	mov	r8,1
80009920:	06 90       	mov	r0,r3
80009922:	40 85       	lddsp	r5,sp[0x20]
80009924:	08 93       	mov	r3,r4
80009926:	0c 94       	mov	r4,r6
80009928:	10 96       	mov	r6,r8
8000992a:	04 9b       	mov	r11,r2
8000992c:	00 9c       	mov	r12,r0
8000992e:	fe b0 f9 f1 	rcall	80008d10 <quorem>
80009932:	2d 0c       	sub	r12,-48
80009934:	0a cc       	st.b	r5++,r12
80009936:	02 36       	cp.w	r6,r1
80009938:	c0 a4       	brge	8000994c <_dtoa_r+0xb1c>
8000993a:	00 9b       	mov	r11,r0
8000993c:	30 09       	mov	r9,0
8000993e:	30 aa       	mov	r10,10
80009940:	0e 9c       	mov	r12,r7
80009942:	2f f6       	sub	r6,-1
80009944:	e0 a0 07 04 	rcall	8000a74c <__multadd>
80009948:	18 90       	mov	r0,r12
8000994a:	cf 0b       	rjmp	8000992a <_dtoa_r+0xafa>
8000994c:	08 96       	mov	r6,r4
8000994e:	30 0b       	mov	r11,0
80009950:	06 94       	mov	r4,r3
80009952:	50 4b       	stdsp	sp[0x10],r11
80009954:	00 93       	mov	r3,r0
80009956:	18 90       	mov	r0,r12
80009958:	c0 28       	rjmp	8000995c <_dtoa_r+0xb2c>
8000995a:	40 26       	lddsp	r6,sp[0x8]
8000995c:	06 9b       	mov	r11,r3
8000995e:	30 1a       	mov	r10,1
80009960:	0e 9c       	mov	r12,r7
80009962:	e0 a0 06 29 	rcall	8000a5b4 <__lshift>
80009966:	04 9b       	mov	r11,r2
80009968:	18 93       	mov	r3,r12
8000996a:	e0 a0 05 02 	rcall	8000a36e <__mcmp>
8000996e:	e0 89 00 12 	brgt	80009992 <_dtoa_r+0xb62>
80009972:	c1 b1       	brne	800099a8 <_dtoa_r+0xb78>
80009974:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80009978:	c0 d1       	brne	80009992 <_dtoa_r+0xb62>
8000997a:	c1 78       	rjmp	800099a8 <_dtoa_r+0xb78>
8000997c:	40 89       	lddsp	r9,sp[0x20]
8000997e:	12 38       	cp.w	r8,r9
80009980:	c0 30       	breq	80009986 <_dtoa_r+0xb56>
80009982:	10 95       	mov	r5,r8
80009984:	c0 88       	rjmp	80009994 <_dtoa_r+0xb64>
80009986:	2f f6       	sub	r6,-1
80009988:	50 66       	stdsp	sp[0x18],r6
8000998a:	33 18       	mov	r8,49
8000998c:	40 8c       	lddsp	r12,sp[0x20]
8000998e:	b8 88       	st.b	r12[0x0],r8
80009990:	c1 38       	rjmp	800099b6 <_dtoa_r+0xb86>
80009992:	33 9a       	mov	r10,57
80009994:	0a 98       	mov	r8,r5
80009996:	11 79       	ld.ub	r9,--r8
80009998:	f4 09 18 00 	cp.b	r9,r10
8000999c:	cf 00       	breq	8000997c <_dtoa_r+0xb4c>
8000999e:	2f f9       	sub	r9,-1
800099a0:	b0 89       	st.b	r8[0x0],r9
800099a2:	c0 98       	rjmp	800099b4 <_dtoa_r+0xb84>
800099a4:	10 95       	mov	r5,r8
800099a6:	c0 28       	rjmp	800099aa <_dtoa_r+0xb7a>
800099a8:	33 09       	mov	r9,48
800099aa:	0a 98       	mov	r8,r5
800099ac:	11 7a       	ld.ub	r10,--r8
800099ae:	f2 0a 18 00 	cp.b	r10,r9
800099b2:	cf 90       	breq	800099a4 <_dtoa_r+0xb74>
800099b4:	50 66       	stdsp	sp[0x18],r6
800099b6:	04 9b       	mov	r11,r2
800099b8:	0e 9c       	mov	r12,r7
800099ba:	e0 a0 04 f3 	rcall	8000a3a0 <_Bfree>
800099be:	58 04       	cp.w	r4,0
800099c0:	c1 20       	breq	800099e4 <_dtoa_r+0xbb4>
800099c2:	40 4b       	lddsp	r11,sp[0x10]
800099c4:	08 3b       	cp.w	r11,r4
800099c6:	5f 19       	srne	r9
800099c8:	58 0b       	cp.w	r11,0
800099ca:	5f 18       	srne	r8
800099cc:	f3 e8 00 08 	and	r8,r9,r8
800099d0:	c0 40       	breq	800099d8 <_dtoa_r+0xba8>
800099d2:	0e 9c       	mov	r12,r7
800099d4:	e0 a0 04 e6 	rcall	8000a3a0 <_Bfree>
800099d8:	08 9b       	mov	r11,r4
800099da:	0e 9c       	mov	r12,r7
800099dc:	e0 a0 04 e2 	rcall	8000a3a0 <_Bfree>
800099e0:	c0 28       	rjmp	800099e4 <_dtoa_r+0xbb4>
800099e2:	50 66       	stdsp	sp[0x18],r6
800099e4:	0e 9c       	mov	r12,r7
800099e6:	06 9b       	mov	r11,r3
800099e8:	e0 a0 04 dc 	rcall	8000a3a0 <_Bfree>
800099ec:	30 08       	mov	r8,0
800099ee:	aa 88       	st.b	r5[0x0],r8
800099f0:	40 68       	lddsp	r8,sp[0x18]
800099f2:	41 5a       	lddsp	r10,sp[0x54]
800099f4:	2f f8       	sub	r8,-1
800099f6:	41 29       	lddsp	r9,sp[0x48]
800099f8:	95 08       	st.w	r10[0x0],r8
800099fa:	40 8c       	lddsp	r12,sp[0x20]
800099fc:	58 09       	cp.w	r9,0
800099fe:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80009a02:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80009a06:	2e 6d       	sub	sp,-104
80009a08:	d8 32       	popm	r0-r7,pc
80009a0a:	d7 03       	nop

80009a0c <__errno>:
80009a0c:	e0 68 0a 18 	mov	r8,2584
80009a10:	70 0c       	ld.w	r12,r8[0x0]
80009a12:	2f 4c       	sub	r12,-12
80009a14:	5e fc       	retal	r12
80009a16:	d7 03       	nop

80009a18 <_fflush_r>:
80009a18:	d4 21       	pushm	r4-r7,lr
80009a1a:	16 97       	mov	r7,r11
80009a1c:	18 96       	mov	r6,r12
80009a1e:	76 48       	ld.w	r8,r11[0x10]
80009a20:	58 08       	cp.w	r8,0
80009a22:	c7 f0       	breq	80009b20 <_fflush_r+0x108>
80009a24:	58 0c       	cp.w	r12,0
80009a26:	c0 50       	breq	80009a30 <_fflush_r+0x18>
80009a28:	78 68       	ld.w	r8,r12[0x18]
80009a2a:	58 08       	cp.w	r8,0
80009a2c:	c0 21       	brne	80009a30 <_fflush_r+0x18>
80009a2e:	cc dc       	rcall	80009bc8 <__sinit>
80009a30:	fe c8 cd 98 	sub	r8,pc,-12904
80009a34:	10 37       	cp.w	r7,r8
80009a36:	c0 31       	brne	80009a3c <_fflush_r+0x24>
80009a38:	6c 07       	ld.w	r7,r6[0x0]
80009a3a:	c0 c8       	rjmp	80009a52 <_fflush_r+0x3a>
80009a3c:	fe c8 cd 84 	sub	r8,pc,-12924
80009a40:	10 37       	cp.w	r7,r8
80009a42:	c0 31       	brne	80009a48 <_fflush_r+0x30>
80009a44:	6c 17       	ld.w	r7,r6[0x4]
80009a46:	c0 68       	rjmp	80009a52 <_fflush_r+0x3a>
80009a48:	fe c8 cd 70 	sub	r8,pc,-12944
80009a4c:	10 37       	cp.w	r7,r8
80009a4e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80009a52:	8e 6a       	ld.sh	r10,r7[0xc]
80009a54:	14 98       	mov	r8,r10
80009a56:	ed ba 00 03 	bld	r10,0x3
80009a5a:	c4 20       	breq	80009ade <_fflush_r+0xc6>
80009a5c:	ab ba       	sbr	r10,0xb
80009a5e:	ae 6a       	st.h	r7[0xc],r10
80009a60:	6e 18       	ld.w	r8,r7[0x4]
80009a62:	58 08       	cp.w	r8,0
80009a64:	e0 89 00 06 	brgt	80009a70 <_fflush_r+0x58>
80009a68:	6f 08       	ld.w	r8,r7[0x40]
80009a6a:	58 08       	cp.w	r8,0
80009a6c:	e0 8a 00 5a 	brle	80009b20 <_fflush_r+0x108>
80009a70:	6e b8       	ld.w	r8,r7[0x2c]
80009a72:	58 08       	cp.w	r8,0
80009a74:	c5 60       	breq	80009b20 <_fflush_r+0x108>
80009a76:	e2 1a 10 00 	andl	r10,0x1000,COH
80009a7a:	c0 30       	breq	80009a80 <_fflush_r+0x68>
80009a7c:	6f 55       	ld.w	r5,r7[0x54]
80009a7e:	c0 f8       	rjmp	80009a9c <_fflush_r+0x84>
80009a80:	30 19       	mov	r9,1
80009a82:	6e 8b       	ld.w	r11,r7[0x20]
80009a84:	0c 9c       	mov	r12,r6
80009a86:	5d 18       	icall	r8
80009a88:	18 95       	mov	r5,r12
80009a8a:	5b fc       	cp.w	r12,-1
80009a8c:	c0 81       	brne	80009a9c <_fflush_r+0x84>
80009a8e:	6c 38       	ld.w	r8,r6[0xc]
80009a90:	59 d8       	cp.w	r8,29
80009a92:	c4 70       	breq	80009b20 <_fflush_r+0x108>
80009a94:	8e 68       	ld.sh	r8,r7[0xc]
80009a96:	a7 a8       	sbr	r8,0x6
80009a98:	ae 68       	st.h	r7[0xc],r8
80009a9a:	d8 22       	popm	r4-r7,pc
80009a9c:	8e 68       	ld.sh	r8,r7[0xc]
80009a9e:	ed b8 00 02 	bld	r8,0x2
80009aa2:	c0 91       	brne	80009ab4 <_fflush_r+0x9c>
80009aa4:	6e 18       	ld.w	r8,r7[0x4]
80009aa6:	10 15       	sub	r5,r8
80009aa8:	6e d8       	ld.w	r8,r7[0x34]
80009aaa:	58 08       	cp.w	r8,0
80009aac:	ef f8 10 10 	ld.wne	r8,r7[0x40]
80009ab0:	eb d8 e1 15 	subne	r5,r5,r8
80009ab4:	6e b8       	ld.w	r8,r7[0x2c]
80009ab6:	0c 9c       	mov	r12,r6
80009ab8:	30 09       	mov	r9,0
80009aba:	0a 9a       	mov	r10,r5
80009abc:	6e 8b       	ld.w	r11,r7[0x20]
80009abe:	5d 18       	icall	r8
80009ac0:	8e 68       	ld.sh	r8,r7[0xc]
80009ac2:	0a 3c       	cp.w	r12,r5
80009ac4:	c2 61       	brne	80009b10 <_fflush_r+0xf8>
80009ac6:	ab d8       	cbr	r8,0xb
80009ac8:	30 0c       	mov	r12,0
80009aca:	6e 49       	ld.w	r9,r7[0x10]
80009acc:	ae 68       	st.h	r7[0xc],r8
80009ace:	8f 1c       	st.w	r7[0x4],r12
80009ad0:	8f 09       	st.w	r7[0x0],r9
80009ad2:	ed b8 00 0c 	bld	r8,0xc
80009ad6:	c2 51       	brne	80009b20 <_fflush_r+0x108>
80009ad8:	ef 45 00 54 	st.w	r7[84],r5
80009adc:	d8 22       	popm	r4-r7,pc
80009ade:	6e 45       	ld.w	r5,r7[0x10]
80009ae0:	58 05       	cp.w	r5,0
80009ae2:	c1 f0       	breq	80009b20 <_fflush_r+0x108>
80009ae4:	6e 04       	ld.w	r4,r7[0x0]
80009ae6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80009aea:	8f 05       	st.w	r7[0x0],r5
80009aec:	f9 b8 01 00 	movne	r8,0
80009af0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
80009af4:	0a 14       	sub	r4,r5
80009af6:	8f 28       	st.w	r7[0x8],r8
80009af8:	c1 18       	rjmp	80009b1a <_fflush_r+0x102>
80009afa:	08 99       	mov	r9,r4
80009afc:	0a 9a       	mov	r10,r5
80009afe:	6e a8       	ld.w	r8,r7[0x28]
80009b00:	6e 8b       	ld.w	r11,r7[0x20]
80009b02:	0c 9c       	mov	r12,r6
80009b04:	5d 18       	icall	r8
80009b06:	18 14       	sub	r4,r12
80009b08:	58 0c       	cp.w	r12,0
80009b0a:	e0 89 00 07 	brgt	80009b18 <_fflush_r+0x100>
80009b0e:	8e 68       	ld.sh	r8,r7[0xc]
80009b10:	a7 a8       	sbr	r8,0x6
80009b12:	3f fc       	mov	r12,-1
80009b14:	ae 68       	st.h	r7[0xc],r8
80009b16:	d8 22       	popm	r4-r7,pc
80009b18:	18 05       	add	r5,r12
80009b1a:	58 04       	cp.w	r4,0
80009b1c:	fe 99 ff ef 	brgt	80009afa <_fflush_r+0xe2>
80009b20:	d8 2a       	popm	r4-r7,pc,r12=0
80009b22:	d7 03       	nop

80009b24 <__sfp_lock_acquire>:
80009b24:	5e fc       	retal	r12

80009b26 <__sfp_lock_release>:
80009b26:	5e fc       	retal	r12

80009b28 <_cleanup_r>:
80009b28:	d4 01       	pushm	lr
80009b2a:	fe cb f0 ae 	sub	r11,pc,-3922
80009b2e:	e0 a0 02 f7 	rcall	8000a11c <_fwalk>
80009b32:	d8 02       	popm	pc

80009b34 <__sfmoreglue>:
80009b34:	d4 21       	pushm	r4-r7,lr
80009b36:	16 95       	mov	r5,r11
80009b38:	f6 06 10 5c 	mul	r6,r11,92
80009b3c:	ec cb ff f4 	sub	r11,r6,-12
80009b40:	fe b0 e2 76 	rcall	8000602c <_malloc_r>
80009b44:	18 97       	mov	r7,r12
80009b46:	c0 90       	breq	80009b58 <__sfmoreglue+0x24>
80009b48:	99 15       	st.w	r12[0x4],r5
80009b4a:	30 0b       	mov	r11,0
80009b4c:	2f 4c       	sub	r12,-12
80009b4e:	0c 9a       	mov	r10,r6
80009b50:	8f 2c       	st.w	r7[0x8],r12
80009b52:	8f 0b       	st.w	r7[0x0],r11
80009b54:	fe b0 e5 3f 	rcall	800065d2 <memset>
80009b58:	0e 9c       	mov	r12,r7
80009b5a:	d8 22       	popm	r4-r7,pc

80009b5c <__sfp>:
80009b5c:	d4 21       	pushm	r4-r7,lr
80009b5e:	fe c8 ce 62 	sub	r8,pc,-12702
80009b62:	18 96       	mov	r6,r12
80009b64:	70 07       	ld.w	r7,r8[0x0]
80009b66:	6e 68       	ld.w	r8,r7[0x18]
80009b68:	58 08       	cp.w	r8,0
80009b6a:	c0 31       	brne	80009b70 <__sfp+0x14>
80009b6c:	0e 9c       	mov	r12,r7
80009b6e:	c2 dc       	rcall	80009bc8 <__sinit>
80009b70:	ee c7 ff 28 	sub	r7,r7,-216
80009b74:	30 05       	mov	r5,0
80009b76:	6e 2c       	ld.w	r12,r7[0x8]
80009b78:	6e 18       	ld.w	r8,r7[0x4]
80009b7a:	c0 68       	rjmp	80009b86 <__sfp+0x2a>
80009b7c:	98 69       	ld.sh	r9,r12[0xc]
80009b7e:	ea 09 19 00 	cp.h	r9,r5
80009b82:	c1 10       	breq	80009ba4 <__sfp+0x48>
80009b84:	2a 4c       	sub	r12,-92
80009b86:	20 18       	sub	r8,1
80009b88:	cf a7       	brpl	80009b7c <__sfp+0x20>
80009b8a:	6e 08       	ld.w	r8,r7[0x0]
80009b8c:	58 08       	cp.w	r8,0
80009b8e:	c0 61       	brne	80009b9a <__sfp+0x3e>
80009b90:	30 4b       	mov	r11,4
80009b92:	0c 9c       	mov	r12,r6
80009b94:	cd 0f       	rcall	80009b34 <__sfmoreglue>
80009b96:	8f 0c       	st.w	r7[0x0],r12
80009b98:	c0 30       	breq	80009b9e <__sfp+0x42>
80009b9a:	6e 07       	ld.w	r7,r7[0x0]
80009b9c:	ce db       	rjmp	80009b76 <__sfp+0x1a>
80009b9e:	30 c8       	mov	r8,12
80009ba0:	8d 38       	st.w	r6[0xc],r8
80009ba2:	d8 22       	popm	r4-r7,pc
80009ba4:	30 08       	mov	r8,0
80009ba6:	f9 48 00 4c 	st.w	r12[76],r8
80009baa:	99 08       	st.w	r12[0x0],r8
80009bac:	99 28       	st.w	r12[0x8],r8
80009bae:	99 18       	st.w	r12[0x4],r8
80009bb0:	99 48       	st.w	r12[0x10],r8
80009bb2:	99 58       	st.w	r12[0x14],r8
80009bb4:	99 68       	st.w	r12[0x18],r8
80009bb6:	99 d8       	st.w	r12[0x34],r8
80009bb8:	99 e8       	st.w	r12[0x38],r8
80009bba:	f9 48 00 48 	st.w	r12[72],r8
80009bbe:	3f f8       	mov	r8,-1
80009bc0:	b8 78       	st.h	r12[0xe],r8
80009bc2:	30 18       	mov	r8,1
80009bc4:	b8 68       	st.h	r12[0xc],r8
80009bc6:	d8 22       	popm	r4-r7,pc

80009bc8 <__sinit>:
80009bc8:	d4 21       	pushm	r4-r7,lr
80009bca:	18 96       	mov	r6,r12
80009bcc:	78 67       	ld.w	r7,r12[0x18]
80009bce:	58 07       	cp.w	r7,0
80009bd0:	c4 91       	brne	80009c62 <__sinit+0x9a>
80009bd2:	fe c8 00 aa 	sub	r8,pc,170
80009bd6:	30 15       	mov	r5,1
80009bd8:	99 a8       	st.w	r12[0x28],r8
80009bda:	f9 47 00 d8 	st.w	r12[216],r7
80009bde:	f9 47 00 dc 	st.w	r12[220],r7
80009be2:	f9 47 00 e0 	st.w	r12[224],r7
80009be6:	99 65       	st.w	r12[0x18],r5
80009be8:	cb af       	rcall	80009b5c <__sfp>
80009bea:	8d 0c       	st.w	r6[0x0],r12
80009bec:	0c 9c       	mov	r12,r6
80009bee:	cb 7f       	rcall	80009b5c <__sfp>
80009bf0:	8d 1c       	st.w	r6[0x4],r12
80009bf2:	0c 9c       	mov	r12,r6
80009bf4:	cb 4f       	rcall	80009b5c <__sfp>
80009bf6:	6c 09       	ld.w	r9,r6[0x0]
80009bf8:	30 48       	mov	r8,4
80009bfa:	93 07       	st.w	r9[0x0],r7
80009bfc:	b2 68       	st.h	r9[0xc],r8
80009bfe:	93 17       	st.w	r9[0x4],r7
80009c00:	93 27       	st.w	r9[0x8],r7
80009c02:	6c 18       	ld.w	r8,r6[0x4]
80009c04:	b2 77       	st.h	r9[0xe],r7
80009c06:	93 47       	st.w	r9[0x10],r7
80009c08:	93 57       	st.w	r9[0x14],r7
80009c0a:	93 67       	st.w	r9[0x18],r7
80009c0c:	93 89       	st.w	r9[0x20],r9
80009c0e:	91 07       	st.w	r8[0x0],r7
80009c10:	91 17       	st.w	r8[0x4],r7
80009c12:	91 27       	st.w	r8[0x8],r7
80009c14:	fe ce f3 24 	sub	lr,pc,-3292
80009c18:	fe cb f3 54 	sub	r11,pc,-3244
80009c1c:	93 9e       	st.w	r9[0x24],lr
80009c1e:	93 ab       	st.w	r9[0x28],r11
80009c20:	fe ca f3 7c 	sub	r10,pc,-3204
80009c24:	fe c4 f3 88 	sub	r4,pc,-3192
80009c28:	93 ba       	st.w	r9[0x2c],r10
80009c2a:	93 c4       	st.w	r9[0x30],r4
80009c2c:	30 99       	mov	r9,9
80009c2e:	b0 69       	st.h	r8[0xc],r9
80009c30:	b0 75       	st.h	r8[0xe],r5
80009c32:	91 c4       	st.w	r8[0x30],r4
80009c34:	91 47       	st.w	r8[0x10],r7
80009c36:	91 57       	st.w	r8[0x14],r7
80009c38:	91 67       	st.w	r8[0x18],r7
80009c3a:	91 88       	st.w	r8[0x20],r8
80009c3c:	91 9e       	st.w	r8[0x24],lr
80009c3e:	91 ab       	st.w	r8[0x28],r11
80009c40:	91 ba       	st.w	r8[0x2c],r10
80009c42:	8d 2c       	st.w	r6[0x8],r12
80009c44:	31 28       	mov	r8,18
80009c46:	99 07       	st.w	r12[0x0],r7
80009c48:	b8 68       	st.h	r12[0xc],r8
80009c4a:	99 17       	st.w	r12[0x4],r7
80009c4c:	99 27       	st.w	r12[0x8],r7
80009c4e:	30 28       	mov	r8,2
80009c50:	b8 78       	st.h	r12[0xe],r8
80009c52:	99 c4       	st.w	r12[0x30],r4
80009c54:	99 67       	st.w	r12[0x18],r7
80009c56:	99 9e       	st.w	r12[0x24],lr
80009c58:	99 ab       	st.w	r12[0x28],r11
80009c5a:	99 ba       	st.w	r12[0x2c],r10
80009c5c:	99 47       	st.w	r12[0x10],r7
80009c5e:	99 57       	st.w	r12[0x14],r7
80009c60:	99 8c       	st.w	r12[0x20],r12
80009c62:	d8 22       	popm	r4-r7,pc

80009c64 <_malloc_trim_r>:
80009c64:	d4 21       	pushm	r4-r7,lr
80009c66:	16 95       	mov	r5,r11
80009c68:	18 97       	mov	r7,r12
80009c6a:	fe b0 d8 ab 	rcall	80004dc0 <__malloc_lock>
80009c6e:	e0 64 05 18 	mov	r4,1304
80009c72:	68 28       	ld.w	r8,r4[0x8]
80009c74:	70 16       	ld.w	r6,r8[0x4]
80009c76:	e0 16 ff fc 	andl	r6,0xfffc
80009c7a:	ec c8 ff 91 	sub	r8,r6,-111
80009c7e:	f0 05 01 05 	sub	r5,r8,r5
80009c82:	e0 15 ff 80 	andl	r5,0xff80
80009c86:	ea c5 00 80 	sub	r5,r5,128
80009c8a:	e0 45 00 7f 	cp.w	r5,127
80009c8e:	e0 8a 00 25 	brle	80009cd8 <_malloc_trim_r+0x74>
80009c92:	30 0b       	mov	r11,0
80009c94:	0e 9c       	mov	r12,r7
80009c96:	fe b0 e6 05 	rcall	800068a0 <_sbrk_r>
80009c9a:	68 28       	ld.w	r8,r4[0x8]
80009c9c:	0c 08       	add	r8,r6
80009c9e:	10 3c       	cp.w	r12,r8
80009ca0:	c1 c1       	brne	80009cd8 <_malloc_trim_r+0x74>
80009ca2:	ea 0b 11 00 	rsub	r11,r5,0
80009ca6:	0e 9c       	mov	r12,r7
80009ca8:	fe b0 e5 fc 	rcall	800068a0 <_sbrk_r>
80009cac:	5b fc       	cp.w	r12,-1
80009cae:	c1 91       	brne	80009ce0 <_malloc_trim_r+0x7c>
80009cb0:	30 0b       	mov	r11,0
80009cb2:	0e 9c       	mov	r12,r7
80009cb4:	fe b0 e5 f6 	rcall	800068a0 <_sbrk_r>
80009cb8:	68 28       	ld.w	r8,r4[0x8]
80009cba:	f8 08 01 09 	sub	r9,r12,r8
80009cbe:	58 f9       	cp.w	r9,15
80009cc0:	e0 8a 00 0c 	brle	80009cd8 <_malloc_trim_r+0x74>
80009cc4:	a1 a9       	sbr	r9,0x0
80009cc6:	91 19       	st.w	r8[0x4],r9
80009cc8:	e0 68 09 24 	mov	r8,2340
80009ccc:	70 09       	ld.w	r9,r8[0x0]
80009cce:	e0 68 0c b8 	mov	r8,3256
80009cd2:	f8 09 01 09 	sub	r9,r12,r9
80009cd6:	91 09       	st.w	r8[0x0],r9
80009cd8:	0e 9c       	mov	r12,r7
80009cda:	fe b0 d8 79 	rcall	80004dcc <__malloc_unlock>
80009cde:	d8 2a       	popm	r4-r7,pc,r12=0
80009ce0:	68 28       	ld.w	r8,r4[0x8]
80009ce2:	0a 16       	sub	r6,r5
80009ce4:	a1 a6       	sbr	r6,0x0
80009ce6:	91 16       	st.w	r8[0x4],r6
80009ce8:	e0 68 0c b8 	mov	r8,3256
80009cec:	70 09       	ld.w	r9,r8[0x0]
80009cee:	0a 19       	sub	r9,r5
80009cf0:	0e 9c       	mov	r12,r7
80009cf2:	91 09       	st.w	r8[0x0],r9
80009cf4:	fe b0 d8 6c 	rcall	80004dcc <__malloc_unlock>
80009cf8:	da 2a       	popm	r4-r7,pc,r12=1
80009cfa:	d7 03       	nop

80009cfc <_free_r>:
80009cfc:	d4 21       	pushm	r4-r7,lr
80009cfe:	16 96       	mov	r6,r11
80009d00:	18 97       	mov	r7,r12
80009d02:	58 0b       	cp.w	r11,0
80009d04:	e0 80 00 c0 	breq	80009e84 <_free_r+0x188>
80009d08:	fe b0 d8 5c 	rcall	80004dc0 <__malloc_lock>
80009d0c:	20 86       	sub	r6,8
80009d0e:	e0 6a 05 18 	mov	r10,1304
80009d12:	6c 18       	ld.w	r8,r6[0x4]
80009d14:	74 2e       	ld.w	lr,r10[0x8]
80009d16:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80009d1a:	a1 c8       	cbr	r8,0x0
80009d1c:	ec 08 00 09 	add	r9,r6,r8
80009d20:	72 1b       	ld.w	r11,r9[0x4]
80009d22:	e0 1b ff fc 	andl	r11,0xfffc
80009d26:	1c 39       	cp.w	r9,lr
80009d28:	c1 e1       	brne	80009d64 <_free_r+0x68>
80009d2a:	f6 08 00 08 	add	r8,r11,r8
80009d2e:	58 0c       	cp.w	r12,0
80009d30:	c0 81       	brne	80009d40 <_free_r+0x44>
80009d32:	6c 09       	ld.w	r9,r6[0x0]
80009d34:	12 16       	sub	r6,r9
80009d36:	12 08       	add	r8,r9
80009d38:	6c 3b       	ld.w	r11,r6[0xc]
80009d3a:	6c 29       	ld.w	r9,r6[0x8]
80009d3c:	97 29       	st.w	r11[0x8],r9
80009d3e:	93 3b       	st.w	r9[0xc],r11
80009d40:	10 99       	mov	r9,r8
80009d42:	95 26       	st.w	r10[0x8],r6
80009d44:	a1 a9       	sbr	r9,0x0
80009d46:	8d 19       	st.w	r6[0x4],r9
80009d48:	e0 69 09 20 	mov	r9,2336
80009d4c:	72 09       	ld.w	r9,r9[0x0]
80009d4e:	12 38       	cp.w	r8,r9
80009d50:	c0 63       	brcs	80009d5c <_free_r+0x60>
80009d52:	e0 68 0c b4 	mov	r8,3252
80009d56:	0e 9c       	mov	r12,r7
80009d58:	70 0b       	ld.w	r11,r8[0x0]
80009d5a:	c8 5f       	rcall	80009c64 <_malloc_trim_r>
80009d5c:	0e 9c       	mov	r12,r7
80009d5e:	fe b0 d8 37 	rcall	80004dcc <__malloc_unlock>
80009d62:	d8 22       	popm	r4-r7,pc
80009d64:	93 1b       	st.w	r9[0x4],r11
80009d66:	58 0c       	cp.w	r12,0
80009d68:	c0 30       	breq	80009d6e <_free_r+0x72>
80009d6a:	30 0c       	mov	r12,0
80009d6c:	c1 08       	rjmp	80009d8c <_free_r+0x90>
80009d6e:	6c 0e       	ld.w	lr,r6[0x0]
80009d70:	f4 c5 ff f8 	sub	r5,r10,-8
80009d74:	1c 16       	sub	r6,lr
80009d76:	1c 08       	add	r8,lr
80009d78:	6c 2e       	ld.w	lr,r6[0x8]
80009d7a:	0a 3e       	cp.w	lr,r5
80009d7c:	f9 bc 00 01 	moveq	r12,1
80009d80:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80009d84:	eb fe 1a 02 	st.wne	r5[0x8],lr
80009d88:	fd f5 1a 03 	st.wne	lr[0xc],r5
80009d8c:	f2 0b 00 0e 	add	lr,r9,r11
80009d90:	7c 1e       	ld.w	lr,lr[0x4]
80009d92:	ed be 00 00 	bld	lr,0x0
80009d96:	c1 40       	breq	80009dbe <_free_r+0xc2>
80009d98:	16 08       	add	r8,r11
80009d9a:	58 0c       	cp.w	r12,0
80009d9c:	c0 d1       	brne	80009db6 <_free_r+0xba>
80009d9e:	e0 6e 05 18 	mov	lr,1304
80009da2:	72 2b       	ld.w	r11,r9[0x8]
80009da4:	2f 8e       	sub	lr,-8
80009da6:	1c 3b       	cp.w	r11,lr
80009da8:	c0 71       	brne	80009db6 <_free_r+0xba>
80009daa:	97 36       	st.w	r11[0xc],r6
80009dac:	97 26       	st.w	r11[0x8],r6
80009dae:	8d 2b       	st.w	r6[0x8],r11
80009db0:	8d 3b       	st.w	r6[0xc],r11
80009db2:	30 1c       	mov	r12,1
80009db4:	c0 58       	rjmp	80009dbe <_free_r+0xc2>
80009db6:	72 2b       	ld.w	r11,r9[0x8]
80009db8:	72 39       	ld.w	r9,r9[0xc]
80009dba:	93 2b       	st.w	r9[0x8],r11
80009dbc:	97 39       	st.w	r11[0xc],r9
80009dbe:	10 99       	mov	r9,r8
80009dc0:	ec 08 09 08 	st.w	r6[r8],r8
80009dc4:	a1 a9       	sbr	r9,0x0
80009dc6:	8d 19       	st.w	r6[0x4],r9
80009dc8:	58 0c       	cp.w	r12,0
80009dca:	c5 a1       	brne	80009e7e <_free_r+0x182>
80009dcc:	e0 48 01 ff 	cp.w	r8,511
80009dd0:	e0 8b 00 13 	brhi	80009df6 <_free_r+0xfa>
80009dd4:	a3 98       	lsr	r8,0x3
80009dd6:	f4 08 00 39 	add	r9,r10,r8<<0x3
80009dda:	72 2b       	ld.w	r11,r9[0x8]
80009ddc:	8d 39       	st.w	r6[0xc],r9
80009dde:	8d 2b       	st.w	r6[0x8],r11
80009de0:	97 36       	st.w	r11[0xc],r6
80009de2:	93 26       	st.w	r9[0x8],r6
80009de4:	a3 48       	asr	r8,0x2
80009de6:	74 19       	ld.w	r9,r10[0x4]
80009de8:	30 1b       	mov	r11,1
80009dea:	f6 08 09 48 	lsl	r8,r11,r8
80009dee:	f3 e8 10 08 	or	r8,r9,r8
80009df2:	95 18       	st.w	r10[0x4],r8
80009df4:	c4 58       	rjmp	80009e7e <_free_r+0x182>
80009df6:	f0 0b 16 09 	lsr	r11,r8,0x9
80009dfa:	58 4b       	cp.w	r11,4
80009dfc:	e0 8b 00 06 	brhi	80009e08 <_free_r+0x10c>
80009e00:	f0 0b 16 06 	lsr	r11,r8,0x6
80009e04:	2c 8b       	sub	r11,-56
80009e06:	c2 08       	rjmp	80009e46 <_free_r+0x14a>
80009e08:	59 4b       	cp.w	r11,20
80009e0a:	e0 8b 00 04 	brhi	80009e12 <_free_r+0x116>
80009e0e:	2a 5b       	sub	r11,-91
80009e10:	c1 b8       	rjmp	80009e46 <_free_r+0x14a>
80009e12:	e0 4b 00 54 	cp.w	r11,84
80009e16:	e0 8b 00 06 	brhi	80009e22 <_free_r+0x126>
80009e1a:	f0 0b 16 0c 	lsr	r11,r8,0xc
80009e1e:	29 2b       	sub	r11,-110
80009e20:	c1 38       	rjmp	80009e46 <_free_r+0x14a>
80009e22:	e0 4b 01 54 	cp.w	r11,340
80009e26:	e0 8b 00 06 	brhi	80009e32 <_free_r+0x136>
80009e2a:	f0 0b 16 0f 	lsr	r11,r8,0xf
80009e2e:	28 9b       	sub	r11,-119
80009e30:	c0 b8       	rjmp	80009e46 <_free_r+0x14a>
80009e32:	e0 4b 05 54 	cp.w	r11,1364
80009e36:	e0 88 00 05 	brls	80009e40 <_free_r+0x144>
80009e3a:	37 eb       	mov	r11,126
80009e3c:	c0 58       	rjmp	80009e46 <_free_r+0x14a>
80009e3e:	d7 03       	nop
80009e40:	f0 0b 16 12 	lsr	r11,r8,0x12
80009e44:	28 4b       	sub	r11,-124
80009e46:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80009e4a:	78 29       	ld.w	r9,r12[0x8]
80009e4c:	18 39       	cp.w	r9,r12
80009e4e:	c0 e1       	brne	80009e6a <_free_r+0x16e>
80009e50:	74 18       	ld.w	r8,r10[0x4]
80009e52:	a3 4b       	asr	r11,0x2
80009e54:	30 1c       	mov	r12,1
80009e56:	f8 0b 09 4b 	lsl	r11,r12,r11
80009e5a:	f1 eb 10 0b 	or	r11,r8,r11
80009e5e:	12 98       	mov	r8,r9
80009e60:	95 1b       	st.w	r10[0x4],r11
80009e62:	c0 a8       	rjmp	80009e76 <_free_r+0x17a>
80009e64:	72 29       	ld.w	r9,r9[0x8]
80009e66:	18 39       	cp.w	r9,r12
80009e68:	c0 60       	breq	80009e74 <_free_r+0x178>
80009e6a:	72 1a       	ld.w	r10,r9[0x4]
80009e6c:	e0 1a ff fc 	andl	r10,0xfffc
80009e70:	14 38       	cp.w	r8,r10
80009e72:	cf 93       	brcs	80009e64 <_free_r+0x168>
80009e74:	72 38       	ld.w	r8,r9[0xc]
80009e76:	8d 38       	st.w	r6[0xc],r8
80009e78:	8d 29       	st.w	r6[0x8],r9
80009e7a:	93 36       	st.w	r9[0xc],r6
80009e7c:	91 26       	st.w	r8[0x8],r6
80009e7e:	0e 9c       	mov	r12,r7
80009e80:	fe b0 d7 a6 	rcall	80004dcc <__malloc_unlock>
80009e84:	d8 22       	popm	r4-r7,pc
80009e86:	d7 03       	nop

80009e88 <__sfvwrite_r>:
80009e88:	d4 31       	pushm	r0-r7,lr
80009e8a:	20 3d       	sub	sp,12
80009e8c:	14 94       	mov	r4,r10
80009e8e:	18 95       	mov	r5,r12
80009e90:	16 97       	mov	r7,r11
80009e92:	74 28       	ld.w	r8,r10[0x8]
80009e94:	58 08       	cp.w	r8,0
80009e96:	e0 80 01 40 	breq	8000a116 <__sfvwrite_r+0x28e>
80009e9a:	96 68       	ld.sh	r8,r11[0xc]
80009e9c:	ed b8 00 03 	bld	r8,0x3
80009ea0:	c0 41       	brne	80009ea8 <__sfvwrite_r+0x20>
80009ea2:	76 48       	ld.w	r8,r11[0x10]
80009ea4:	58 08       	cp.w	r8,0
80009ea6:	c0 c1       	brne	80009ebe <__sfvwrite_r+0x36>
80009ea8:	0e 9b       	mov	r11,r7
80009eaa:	0a 9c       	mov	r12,r5
80009eac:	fe b0 f6 c4 	rcall	80008c34 <__swsetup_r>
80009eb0:	c0 70       	breq	80009ebe <__sfvwrite_r+0x36>
80009eb2:	8e 68       	ld.sh	r8,r7[0xc]
80009eb4:	a7 a8       	sbr	r8,0x6
80009eb6:	ae 68       	st.h	r7[0xc],r8
80009eb8:	30 98       	mov	r8,9
80009eba:	8b 38       	st.w	r5[0xc],r8
80009ebc:	c2 b9       	rjmp	8000a112 <__sfvwrite_r+0x28a>
80009ebe:	8e 63       	ld.sh	r3,r7[0xc]
80009ec0:	68 00       	ld.w	r0,r4[0x0]
80009ec2:	06 96       	mov	r6,r3
80009ec4:	e2 16 00 02 	andl	r6,0x2,COH
80009ec8:	c2 10       	breq	80009f0a <__sfvwrite_r+0x82>
80009eca:	30 03       	mov	r3,0
80009ecc:	e0 62 04 00 	mov	r2,1024
80009ed0:	06 96       	mov	r6,r3
80009ed2:	c0 48       	rjmp	80009eda <__sfvwrite_r+0x52>
80009ed4:	60 03       	ld.w	r3,r0[0x0]
80009ed6:	60 16       	ld.w	r6,r0[0x4]
80009ed8:	2f 80       	sub	r0,-8
80009eda:	58 06       	cp.w	r6,0
80009edc:	cf c0       	breq	80009ed4 <__sfvwrite_r+0x4c>
80009ede:	e0 46 04 00 	cp.w	r6,1024
80009ee2:	ec 09 17 80 	movls	r9,r6
80009ee6:	e4 09 17 b0 	movhi	r9,r2
80009eea:	06 9a       	mov	r10,r3
80009eec:	6e a8       	ld.w	r8,r7[0x28]
80009eee:	6e 8b       	ld.w	r11,r7[0x20]
80009ef0:	0a 9c       	mov	r12,r5
80009ef2:	5d 18       	icall	r8
80009ef4:	18 16       	sub	r6,r12
80009ef6:	58 0c       	cp.w	r12,0
80009ef8:	e0 8a 01 0a 	brle	8000a10c <__sfvwrite_r+0x284>
80009efc:	68 28       	ld.w	r8,r4[0x8]
80009efe:	18 18       	sub	r8,r12
80009f00:	89 28       	st.w	r4[0x8],r8
80009f02:	e0 80 01 0a 	breq	8000a116 <__sfvwrite_r+0x28e>
80009f06:	18 03       	add	r3,r12
80009f08:	ce 9b       	rjmp	80009eda <__sfvwrite_r+0x52>
80009f0a:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80009f0e:	c0 70       	breq	80009f1c <__sfvwrite_r+0x94>
80009f10:	50 06       	stdsp	sp[0x0],r6
80009f12:	0c 93       	mov	r3,r6
80009f14:	0c 91       	mov	r1,r6
80009f16:	50 15       	stdsp	sp[0x4],r5
80009f18:	08 92       	mov	r2,r4
80009f1a:	c9 c8       	rjmp	8000a052 <__sfvwrite_r+0x1ca>
80009f1c:	06 96       	mov	r6,r3
80009f1e:	08 91       	mov	r1,r4
80009f20:	c0 48       	rjmp	80009f28 <__sfvwrite_r+0xa0>
80009f22:	60 03       	ld.w	r3,r0[0x0]
80009f24:	60 16       	ld.w	r6,r0[0x4]
80009f26:	2f 80       	sub	r0,-8
80009f28:	58 06       	cp.w	r6,0
80009f2a:	cf c0       	breq	80009f22 <__sfvwrite_r+0x9a>
80009f2c:	8e 68       	ld.sh	r8,r7[0xc]
80009f2e:	6e 24       	ld.w	r4,r7[0x8]
80009f30:	10 99       	mov	r9,r8
80009f32:	e2 19 02 00 	andl	r9,0x200,COH
80009f36:	c5 50       	breq	80009fe0 <__sfvwrite_r+0x158>
80009f38:	08 36       	cp.w	r6,r4
80009f3a:	c4 43       	brcs	80009fc2 <__sfvwrite_r+0x13a>
80009f3c:	10 99       	mov	r9,r8
80009f3e:	e2 19 04 80 	andl	r9,0x480,COH
80009f42:	c4 00       	breq	80009fc2 <__sfvwrite_r+0x13a>
80009f44:	6e 4b       	ld.w	r11,r7[0x10]
80009f46:	6e 09       	ld.w	r9,r7[0x0]
80009f48:	16 19       	sub	r9,r11
80009f4a:	50 09       	stdsp	sp[0x0],r9
80009f4c:	6e 59       	ld.w	r9,r7[0x14]
80009f4e:	10 9c       	mov	r12,r8
80009f50:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80009f54:	30 28       	mov	r8,2
80009f56:	f4 08 0c 08 	divs	r8,r10,r8
80009f5a:	fa e9 00 04 	st.d	sp[4],r8
80009f5e:	10 94       	mov	r4,r8
80009f60:	40 09       	lddsp	r9,sp[0x0]
80009f62:	e2 1c 04 00 	andl	r12,0x400,COH
80009f66:	2f f9       	sub	r9,-1
80009f68:	0c 09       	add	r9,r6
80009f6a:	12 38       	cp.w	r8,r9
80009f6c:	f2 04 17 30 	movlo	r4,r9
80009f70:	58 0c       	cp.w	r12,0
80009f72:	c1 10       	breq	80009f94 <__sfvwrite_r+0x10c>
80009f74:	08 9b       	mov	r11,r4
80009f76:	0a 9c       	mov	r12,r5
80009f78:	fe b0 e0 5a 	rcall	8000602c <_malloc_r>
80009f7c:	18 92       	mov	r2,r12
80009f7e:	c1 40       	breq	80009fa6 <__sfvwrite_r+0x11e>
80009f80:	40 0a       	lddsp	r10,sp[0x0]
80009f82:	6e 4b       	ld.w	r11,r7[0x10]
80009f84:	fe b0 e2 83 	rcall	8000648a <memcpy>
80009f88:	8e 68       	ld.sh	r8,r7[0xc]
80009f8a:	e0 18 fb 7f 	andl	r8,0xfb7f
80009f8e:	a7 b8       	sbr	r8,0x7
80009f90:	ae 68       	st.h	r7[0xc],r8
80009f92:	c0 d8       	rjmp	80009fac <__sfvwrite_r+0x124>
80009f94:	08 9a       	mov	r10,r4
80009f96:	0a 9c       	mov	r12,r5
80009f98:	fe b0 e3 24 	rcall	800065e0 <_realloc_r>
80009f9c:	18 92       	mov	r2,r12
80009f9e:	c0 71       	brne	80009fac <__sfvwrite_r+0x124>
80009fa0:	6e 4b       	ld.w	r11,r7[0x10]
80009fa2:	0a 9c       	mov	r12,r5
80009fa4:	ca ce       	rcall	80009cfc <_free_r>
80009fa6:	30 c8       	mov	r8,12
80009fa8:	8b 38       	st.w	r5[0xc],r8
80009faa:	cb 18       	rjmp	8000a10c <__sfvwrite_r+0x284>
80009fac:	40 0a       	lddsp	r10,sp[0x0]
80009fae:	40 09       	lddsp	r9,sp[0x0]
80009fb0:	e8 0a 01 0a 	sub	r10,r4,r10
80009fb4:	e4 09 00 08 	add	r8,r2,r9
80009fb8:	8f 54       	st.w	r7[0x14],r4
80009fba:	8f 2a       	st.w	r7[0x8],r10
80009fbc:	8f 08       	st.w	r7[0x0],r8
80009fbe:	8f 42       	st.w	r7[0x10],r2
80009fc0:	0c 94       	mov	r4,r6
80009fc2:	08 36       	cp.w	r6,r4
80009fc4:	ec 04 17 30 	movlo	r4,r6
80009fc8:	06 9b       	mov	r11,r3
80009fca:	08 9a       	mov	r10,r4
80009fcc:	6e 0c       	ld.w	r12,r7[0x0]
80009fce:	c3 ad       	rcall	8000a242 <memmove>
80009fd0:	6e 08       	ld.w	r8,r7[0x0]
80009fd2:	08 08       	add	r8,r4
80009fd4:	8f 08       	st.w	r7[0x0],r8
80009fd6:	6e 28       	ld.w	r8,r7[0x8]
80009fd8:	08 18       	sub	r8,r4
80009fda:	0c 94       	mov	r4,r6
80009fdc:	8f 28       	st.w	r7[0x8],r8
80009fde:	c2 e8       	rjmp	8000a03a <__sfvwrite_r+0x1b2>
80009fe0:	08 36       	cp.w	r6,r4
80009fe2:	5f ba       	srhi	r10
80009fe4:	6e 0c       	ld.w	r12,r7[0x0]
80009fe6:	6e 48       	ld.w	r8,r7[0x10]
80009fe8:	10 3c       	cp.w	r12,r8
80009fea:	5f b8       	srhi	r8
80009fec:	f5 e8 00 08 	and	r8,r10,r8
80009ff0:	f2 08 18 00 	cp.b	r8,r9
80009ff4:	c0 d0       	breq	8000a00e <__sfvwrite_r+0x186>
80009ff6:	06 9b       	mov	r11,r3
80009ff8:	08 9a       	mov	r10,r4
80009ffa:	c2 4d       	rcall	8000a242 <memmove>
80009ffc:	6e 08       	ld.w	r8,r7[0x0]
80009ffe:	08 08       	add	r8,r4
8000a000:	0e 9b       	mov	r11,r7
8000a002:	8f 08       	st.w	r7[0x0],r8
8000a004:	0a 9c       	mov	r12,r5
8000a006:	fe b0 fd 09 	rcall	80009a18 <_fflush_r>
8000a00a:	c1 80       	breq	8000a03a <__sfvwrite_r+0x1b2>
8000a00c:	c8 08       	rjmp	8000a10c <__sfvwrite_r+0x284>
8000a00e:	6e 59       	ld.w	r9,r7[0x14]
8000a010:	12 36       	cp.w	r6,r9
8000a012:	c0 a3       	brcs	8000a026 <__sfvwrite_r+0x19e>
8000a014:	6e a8       	ld.w	r8,r7[0x28]
8000a016:	06 9a       	mov	r10,r3
8000a018:	6e 8b       	ld.w	r11,r7[0x20]
8000a01a:	0a 9c       	mov	r12,r5
8000a01c:	5d 18       	icall	r8
8000a01e:	18 94       	mov	r4,r12
8000a020:	e0 89 00 0d 	brgt	8000a03a <__sfvwrite_r+0x1b2>
8000a024:	c7 48       	rjmp	8000a10c <__sfvwrite_r+0x284>
8000a026:	0c 9a       	mov	r10,r6
8000a028:	06 9b       	mov	r11,r3
8000a02a:	c0 cd       	rcall	8000a242 <memmove>
8000a02c:	6e 08       	ld.w	r8,r7[0x0]
8000a02e:	0c 08       	add	r8,r6
8000a030:	0c 94       	mov	r4,r6
8000a032:	8f 08       	st.w	r7[0x0],r8
8000a034:	6e 28       	ld.w	r8,r7[0x8]
8000a036:	0c 18       	sub	r8,r6
8000a038:	8f 28       	st.w	r7[0x8],r8
8000a03a:	62 28       	ld.w	r8,r1[0x8]
8000a03c:	08 18       	sub	r8,r4
8000a03e:	83 28       	st.w	r1[0x8],r8
8000a040:	c6 b0       	breq	8000a116 <__sfvwrite_r+0x28e>
8000a042:	08 16       	sub	r6,r4
8000a044:	08 03       	add	r3,r4
8000a046:	c7 1b       	rjmp	80009f28 <__sfvwrite_r+0xa0>
8000a048:	60 03       	ld.w	r3,r0[0x0]
8000a04a:	60 11       	ld.w	r1,r0[0x4]
8000a04c:	30 08       	mov	r8,0
8000a04e:	2f 80       	sub	r0,-8
8000a050:	50 08       	stdsp	sp[0x0],r8
8000a052:	58 01       	cp.w	r1,0
8000a054:	cf a0       	breq	8000a048 <__sfvwrite_r+0x1c0>
8000a056:	40 0a       	lddsp	r10,sp[0x0]
8000a058:	58 0a       	cp.w	r10,0
8000a05a:	c1 41       	brne	8000a082 <__sfvwrite_r+0x1fa>
8000a05c:	e2 c6 ff ff 	sub	r6,r1,-1
8000a060:	02 9a       	mov	r10,r1
8000a062:	30 ab       	mov	r11,10
8000a064:	06 9c       	mov	r12,r3
8000a066:	ce 3c       	rcall	8000a22c <memchr>
8000a068:	f8 c8 ff ff 	sub	r8,r12,-1
8000a06c:	58 0c       	cp.w	r12,0
8000a06e:	f1 d3 e1 16 	subne	r6,r8,r3
8000a072:	f9 b9 01 01 	movne	r9,1
8000a076:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a07a:	f9 b8 00 01 	moveq	r8,1
8000a07e:	fb f8 0a 00 	st.weq	sp[0x0],r8
8000a082:	02 36       	cp.w	r6,r1
8000a084:	ec 04 17 80 	movls	r4,r6
8000a088:	e2 04 17 b0 	movhi	r4,r1
8000a08c:	6e 59       	ld.w	r9,r7[0x14]
8000a08e:	6e 25       	ld.w	r5,r7[0x8]
8000a090:	f2 05 00 05 	add	r5,r9,r5
8000a094:	0a 34       	cp.w	r4,r5
8000a096:	5f 9a       	srgt	r10
8000a098:	6e 0c       	ld.w	r12,r7[0x0]
8000a09a:	6e 48       	ld.w	r8,r7[0x10]
8000a09c:	10 3c       	cp.w	r12,r8
8000a09e:	5f b8       	srhi	r8
8000a0a0:	f5 e8 00 08 	and	r8,r10,r8
8000a0a4:	30 0a       	mov	r10,0
8000a0a6:	f4 08 18 00 	cp.b	r8,r10
8000a0aa:	c0 d0       	breq	8000a0c4 <__sfvwrite_r+0x23c>
8000a0ac:	06 9b       	mov	r11,r3
8000a0ae:	0a 9a       	mov	r10,r5
8000a0b0:	cc 9c       	rcall	8000a242 <memmove>
8000a0b2:	6e 08       	ld.w	r8,r7[0x0]
8000a0b4:	0a 08       	add	r8,r5
8000a0b6:	0e 9b       	mov	r11,r7
8000a0b8:	8f 08       	st.w	r7[0x0],r8
8000a0ba:	40 1c       	lddsp	r12,sp[0x4]
8000a0bc:	fe b0 fc ae 	rcall	80009a18 <_fflush_r>
8000a0c0:	c1 70       	breq	8000a0ee <__sfvwrite_r+0x266>
8000a0c2:	c2 58       	rjmp	8000a10c <__sfvwrite_r+0x284>
8000a0c4:	12 34       	cp.w	r4,r9
8000a0c6:	c0 a5       	brlt	8000a0da <__sfvwrite_r+0x252>
8000a0c8:	6e a8       	ld.w	r8,r7[0x28]
8000a0ca:	06 9a       	mov	r10,r3
8000a0cc:	6e 8b       	ld.w	r11,r7[0x20]
8000a0ce:	40 1c       	lddsp	r12,sp[0x4]
8000a0d0:	5d 18       	icall	r8
8000a0d2:	18 95       	mov	r5,r12
8000a0d4:	e0 89 00 0d 	brgt	8000a0ee <__sfvwrite_r+0x266>
8000a0d8:	c1 a8       	rjmp	8000a10c <__sfvwrite_r+0x284>
8000a0da:	08 9a       	mov	r10,r4
8000a0dc:	06 9b       	mov	r11,r3
8000a0de:	cb 2c       	rcall	8000a242 <memmove>
8000a0e0:	6e 08       	ld.w	r8,r7[0x0]
8000a0e2:	08 08       	add	r8,r4
8000a0e4:	08 95       	mov	r5,r4
8000a0e6:	8f 08       	st.w	r7[0x0],r8
8000a0e8:	6e 28       	ld.w	r8,r7[0x8]
8000a0ea:	08 18       	sub	r8,r4
8000a0ec:	8f 28       	st.w	r7[0x8],r8
8000a0ee:	0a 16       	sub	r6,r5
8000a0f0:	c0 71       	brne	8000a0fe <__sfvwrite_r+0x276>
8000a0f2:	0e 9b       	mov	r11,r7
8000a0f4:	40 1c       	lddsp	r12,sp[0x4]
8000a0f6:	fe b0 fc 91 	rcall	80009a18 <_fflush_r>
8000a0fa:	c0 91       	brne	8000a10c <__sfvwrite_r+0x284>
8000a0fc:	50 06       	stdsp	sp[0x0],r6
8000a0fe:	64 28       	ld.w	r8,r2[0x8]
8000a100:	0a 18       	sub	r8,r5
8000a102:	85 28       	st.w	r2[0x8],r8
8000a104:	c0 90       	breq	8000a116 <__sfvwrite_r+0x28e>
8000a106:	0a 11       	sub	r1,r5
8000a108:	0a 03       	add	r3,r5
8000a10a:	ca 4b       	rjmp	8000a052 <__sfvwrite_r+0x1ca>
8000a10c:	8e 68       	ld.sh	r8,r7[0xc]
8000a10e:	a7 a8       	sbr	r8,0x6
8000a110:	ae 68       	st.h	r7[0xc],r8
8000a112:	3f fc       	mov	r12,-1
8000a114:	c0 28       	rjmp	8000a118 <__sfvwrite_r+0x290>
8000a116:	30 0c       	mov	r12,0
8000a118:	2f dd       	sub	sp,-12
8000a11a:	d8 32       	popm	r0-r7,pc

8000a11c <_fwalk>:
8000a11c:	d4 31       	pushm	r0-r7,lr
8000a11e:	30 05       	mov	r5,0
8000a120:	16 91       	mov	r1,r11
8000a122:	f8 c7 ff 28 	sub	r7,r12,-216
8000a126:	0a 92       	mov	r2,r5
8000a128:	fe b0 fc fe 	rcall	80009b24 <__sfp_lock_acquire>
8000a12c:	3f f3       	mov	r3,-1
8000a12e:	c1 68       	rjmp	8000a15a <_fwalk+0x3e>
8000a130:	6e 26       	ld.w	r6,r7[0x8]
8000a132:	6e 14       	ld.w	r4,r7[0x4]
8000a134:	2f 46       	sub	r6,-12
8000a136:	c0 c8       	rjmp	8000a14e <_fwalk+0x32>
8000a138:	8c 08       	ld.sh	r8,r6[0x0]
8000a13a:	e4 08 19 00 	cp.h	r8,r2
8000a13e:	c0 70       	breq	8000a14c <_fwalk+0x30>
8000a140:	8c 18       	ld.sh	r8,r6[0x2]
8000a142:	e6 08 19 00 	cp.h	r8,r3
8000a146:	c0 30       	breq	8000a14c <_fwalk+0x30>
8000a148:	5d 11       	icall	r1
8000a14a:	18 45       	or	r5,r12
8000a14c:	2a 46       	sub	r6,-92
8000a14e:	20 14       	sub	r4,1
8000a150:	ec cc 00 0c 	sub	r12,r6,12
8000a154:	58 04       	cp.w	r4,0
8000a156:	cf 14       	brge	8000a138 <_fwalk+0x1c>
8000a158:	6e 07       	ld.w	r7,r7[0x0]
8000a15a:	58 07       	cp.w	r7,0
8000a15c:	ce a1       	brne	8000a130 <_fwalk+0x14>
8000a15e:	fe b0 fc e4 	rcall	80009b26 <__sfp_lock_release>
8000a162:	0a 9c       	mov	r12,r5
8000a164:	d8 32       	popm	r0-r7,pc
8000a166:	d7 03       	nop

8000a168 <_localeconv_r>:
8000a168:	fe cc d4 68 	sub	r12,pc,-11160
8000a16c:	5e fc       	retal	r12
8000a16e:	d7 03       	nop

8000a170 <__smakebuf_r>:
8000a170:	d4 21       	pushm	r4-r7,lr
8000a172:	20 fd       	sub	sp,60
8000a174:	96 68       	ld.sh	r8,r11[0xc]
8000a176:	16 97       	mov	r7,r11
8000a178:	18 96       	mov	r6,r12
8000a17a:	e2 18 00 02 	andl	r8,0x2,COH
8000a17e:	c3 d1       	brne	8000a1f8 <__smakebuf_r+0x88>
8000a180:	96 7b       	ld.sh	r11,r11[0xe]
8000a182:	f0 0b 19 00 	cp.h	r11,r8
8000a186:	c0 55       	brlt	8000a190 <__smakebuf_r+0x20>
8000a188:	1a 9a       	mov	r10,sp
8000a18a:	e0 a0 04 81 	rcall	8000aa8c <_fstat_r>
8000a18e:	c0 f4       	brge	8000a1ac <__smakebuf_r+0x3c>
8000a190:	8e 65       	ld.sh	r5,r7[0xc]
8000a192:	0a 98       	mov	r8,r5
8000a194:	ab b8       	sbr	r8,0xb
8000a196:	e2 15 00 80 	andl	r5,0x80,COH
8000a19a:	ae 68       	st.h	r7[0xc],r8
8000a19c:	30 04       	mov	r4,0
8000a19e:	e0 68 04 00 	mov	r8,1024
8000a1a2:	f9 b5 01 40 	movne	r5,64
8000a1a6:	f0 05 17 00 	moveq	r5,r8
8000a1aa:	c1 c8       	rjmp	8000a1e2 <__smakebuf_r+0x72>
8000a1ac:	40 18       	lddsp	r8,sp[0x4]
8000a1ae:	e2 18 f0 00 	andl	r8,0xf000,COH
8000a1b2:	e0 48 20 00 	cp.w	r8,8192
8000a1b6:	5f 04       	sreq	r4
8000a1b8:	e0 48 80 00 	cp.w	r8,32768
8000a1bc:	c0 e1       	brne	8000a1d8 <__smakebuf_r+0x68>
8000a1be:	6e b9       	ld.w	r9,r7[0x2c]
8000a1c0:	fe c8 f9 1c 	sub	r8,pc,-1764
8000a1c4:	10 39       	cp.w	r9,r8
8000a1c6:	c0 91       	brne	8000a1d8 <__smakebuf_r+0x68>
8000a1c8:	8e 68       	ld.sh	r8,r7[0xc]
8000a1ca:	e0 65 04 00 	mov	r5,1024
8000a1ce:	ab a8       	sbr	r8,0xa
8000a1d0:	ef 45 00 50 	st.w	r7[80],r5
8000a1d4:	ae 68       	st.h	r7[0xc],r8
8000a1d6:	c0 68       	rjmp	8000a1e2 <__smakebuf_r+0x72>
8000a1d8:	8e 68       	ld.sh	r8,r7[0xc]
8000a1da:	e0 65 04 00 	mov	r5,1024
8000a1de:	ab b8       	sbr	r8,0xb
8000a1e0:	ae 68       	st.h	r7[0xc],r8
8000a1e2:	0a 9b       	mov	r11,r5
8000a1e4:	0c 9c       	mov	r12,r6
8000a1e6:	fe b0 df 23 	rcall	8000602c <_malloc_r>
8000a1ea:	8e 68       	ld.sh	r8,r7[0xc]
8000a1ec:	c0 d1       	brne	8000a206 <__smakebuf_r+0x96>
8000a1ee:	ed b8 00 09 	bld	r8,0x9
8000a1f2:	c1 b0       	breq	8000a228 <__smakebuf_r+0xb8>
8000a1f4:	a1 b8       	sbr	r8,0x1
8000a1f6:	ae 68       	st.h	r7[0xc],r8
8000a1f8:	ee c8 ff b9 	sub	r8,r7,-71
8000a1fc:	8f 48       	st.w	r7[0x10],r8
8000a1fe:	8f 08       	st.w	r7[0x0],r8
8000a200:	30 18       	mov	r8,1
8000a202:	8f 58       	st.w	r7[0x14],r8
8000a204:	c1 28       	rjmp	8000a228 <__smakebuf_r+0xb8>
8000a206:	a7 b8       	sbr	r8,0x7
8000a208:	8f 4c       	st.w	r7[0x10],r12
8000a20a:	ae 68       	st.h	r7[0xc],r8
8000a20c:	8f 55       	st.w	r7[0x14],r5
8000a20e:	fe c8 06 e6 	sub	r8,pc,1766
8000a212:	8f 0c       	st.w	r7[0x0],r12
8000a214:	8d a8       	st.w	r6[0x28],r8
8000a216:	58 04       	cp.w	r4,0
8000a218:	c0 80       	breq	8000a228 <__smakebuf_r+0xb8>
8000a21a:	8e 7c       	ld.sh	r12,r7[0xe]
8000a21c:	fe b0 e3 94 	rcall	80006944 <isatty>
8000a220:	c0 40       	breq	8000a228 <__smakebuf_r+0xb8>
8000a222:	8e 68       	ld.sh	r8,r7[0xc]
8000a224:	a1 a8       	sbr	r8,0x0
8000a226:	ae 68       	st.h	r7[0xc],r8
8000a228:	2f 1d       	sub	sp,-60
8000a22a:	d8 22       	popm	r4-r7,pc

8000a22c <memchr>:
8000a22c:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
8000a230:	c0 68       	rjmp	8000a23c <memchr+0x10>
8000a232:	20 1a       	sub	r10,1
8000a234:	19 88       	ld.ub	r8,r12[0x0]
8000a236:	16 38       	cp.w	r8,r11
8000a238:	5e 0c       	reteq	r12
8000a23a:	2f fc       	sub	r12,-1
8000a23c:	58 0a       	cp.w	r10,0
8000a23e:	cf a1       	brne	8000a232 <memchr+0x6>
8000a240:	5e fa       	retal	r10

8000a242 <memmove>:
8000a242:	d4 01       	pushm	lr
8000a244:	18 3b       	cp.w	r11,r12
8000a246:	c1 92       	brcc	8000a278 <memmove+0x36>
8000a248:	f6 0a 00 09 	add	r9,r11,r10
8000a24c:	12 3c       	cp.w	r12,r9
8000a24e:	c1 52       	brcc	8000a278 <memmove+0x36>
8000a250:	f8 0a 00 0b 	add	r11,r12,r10
8000a254:	30 08       	mov	r8,0
8000a256:	c0 68       	rjmp	8000a262 <memmove+0x20>
8000a258:	f2 08 07 0e 	ld.ub	lr,r9[r8]
8000a25c:	20 1a       	sub	r10,1
8000a25e:	f6 08 0b 0e 	st.b	r11[r8],lr
8000a262:	20 18       	sub	r8,1
8000a264:	58 0a       	cp.w	r10,0
8000a266:	cf 91       	brne	8000a258 <memmove+0x16>
8000a268:	d8 02       	popm	pc
8000a26a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000a26e:	20 1a       	sub	r10,1
8000a270:	f8 08 0b 09 	st.b	r12[r8],r9
8000a274:	2f f8       	sub	r8,-1
8000a276:	c0 28       	rjmp	8000a27a <memmove+0x38>
8000a278:	30 08       	mov	r8,0
8000a27a:	58 0a       	cp.w	r10,0
8000a27c:	cf 71       	brne	8000a26a <memmove+0x28>
8000a27e:	d8 02       	popm	pc

8000a280 <__hi0bits>:
8000a280:	18 98       	mov	r8,r12
8000a282:	e0 1c 00 00 	andl	r12,0x0
8000a286:	f0 09 15 10 	lsl	r9,r8,0x10
8000a28a:	58 0c       	cp.w	r12,0
8000a28c:	f2 08 17 00 	moveq	r8,r9
8000a290:	f9 bc 00 10 	moveq	r12,16
8000a294:	f9 bc 01 00 	movne	r12,0
8000a298:	10 9a       	mov	r10,r8
8000a29a:	f0 09 15 08 	lsl	r9,r8,0x8
8000a29e:	e6 1a ff 00 	andh	r10,0xff00,COH
8000a2a2:	f7 bc 00 f8 	subeq	r12,-8
8000a2a6:	f2 08 17 00 	moveq	r8,r9
8000a2aa:	10 9a       	mov	r10,r8
8000a2ac:	f0 09 15 04 	lsl	r9,r8,0x4
8000a2b0:	e6 1a f0 00 	andh	r10,0xf000,COH
8000a2b4:	f7 bc 00 fc 	subeq	r12,-4
8000a2b8:	f2 08 17 00 	moveq	r8,r9
8000a2bc:	10 9a       	mov	r10,r8
8000a2be:	f0 09 15 02 	lsl	r9,r8,0x2
8000a2c2:	e6 1a c0 00 	andh	r10,0xc000,COH
8000a2c6:	f7 bc 00 fe 	subeq	r12,-2
8000a2ca:	f2 08 17 00 	moveq	r8,r9
8000a2ce:	58 08       	cp.w	r8,0
8000a2d0:	5e 5c       	retlt	r12
8000a2d2:	ed b8 00 1e 	bld	r8,0x1e
8000a2d6:	f9 bc 01 20 	movne	r12,32
8000a2da:	f7 bc 00 ff 	subeq	r12,-1
8000a2de:	5e fc       	retal	r12

8000a2e0 <__lo0bits>:
8000a2e0:	18 99       	mov	r9,r12
8000a2e2:	78 08       	ld.w	r8,r12[0x0]
8000a2e4:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8000a2e8:	c1 50       	breq	8000a312 <__lo0bits+0x32>
8000a2ea:	ed b8 00 00 	bld	r8,0x0
8000a2ee:	c0 21       	brne	8000a2f2 <__lo0bits+0x12>
8000a2f0:	5e fd       	retal	0
8000a2f2:	10 9b       	mov	r11,r8
8000a2f4:	f0 0a 16 01 	lsr	r10,r8,0x1
8000a2f8:	e2 1b 00 02 	andl	r11,0x2,COH
8000a2fc:	a3 88       	lsr	r8,0x2
8000a2fe:	58 0b       	cp.w	r11,0
8000a300:	f3 fa 1a 00 	st.wne	r9[0x0],r10
8000a304:	f9 bc 01 01 	movne	r12,1
8000a308:	f3 f8 0a 00 	st.weq	r9[0x0],r8
8000a30c:	f9 bc 00 02 	moveq	r12,2
8000a310:	5e fc       	retal	r12
8000a312:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000a316:	f0 0b 16 10 	lsr	r11,r8,0x10
8000a31a:	58 0a       	cp.w	r10,0
8000a31c:	f6 08 17 00 	moveq	r8,r11
8000a320:	f9 bc 00 10 	moveq	r12,16
8000a324:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8000a328:	f0 0a 16 08 	lsr	r10,r8,0x8
8000a32c:	58 0b       	cp.w	r11,0
8000a32e:	f7 bc 00 f8 	subeq	r12,-8
8000a332:	f4 08 17 00 	moveq	r8,r10
8000a336:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
8000a33a:	f0 0a 16 04 	lsr	r10,r8,0x4
8000a33e:	58 0b       	cp.w	r11,0
8000a340:	f7 bc 00 fc 	subeq	r12,-4
8000a344:	f4 08 17 00 	moveq	r8,r10
8000a348:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
8000a34c:	f0 0a 16 02 	lsr	r10,r8,0x2
8000a350:	58 0b       	cp.w	r11,0
8000a352:	f7 bc 00 fe 	subeq	r12,-2
8000a356:	f4 08 17 00 	moveq	r8,r10
8000a35a:	ed b8 00 00 	bld	r8,0x0
8000a35e:	c0 60       	breq	8000a36a <__lo0bits+0x8a>
8000a360:	a1 98       	lsr	r8,0x1
8000a362:	c0 31       	brne	8000a368 <__lo0bits+0x88>
8000a364:	32 0c       	mov	r12,32
8000a366:	5e fc       	retal	r12
8000a368:	2f fc       	sub	r12,-1
8000a36a:	93 08       	st.w	r9[0x0],r8
8000a36c:	5e fc       	retal	r12

8000a36e <__mcmp>:
8000a36e:	d4 01       	pushm	lr
8000a370:	18 98       	mov	r8,r12
8000a372:	76 49       	ld.w	r9,r11[0x10]
8000a374:	78 4c       	ld.w	r12,r12[0x10]
8000a376:	12 1c       	sub	r12,r9
8000a378:	c1 31       	brne	8000a39e <__mcmp+0x30>
8000a37a:	2f b9       	sub	r9,-5
8000a37c:	a3 69       	lsl	r9,0x2
8000a37e:	12 0b       	add	r11,r9
8000a380:	f0 09 00 09 	add	r9,r8,r9
8000a384:	2e c8       	sub	r8,-20
8000a386:	13 4e       	ld.w	lr,--r9
8000a388:	17 4a       	ld.w	r10,--r11
8000a38a:	14 3e       	cp.w	lr,r10
8000a38c:	c0 60       	breq	8000a398 <__mcmp+0x2a>
8000a38e:	f9 bc 03 ff 	movlo	r12,-1
8000a392:	f9 bc 02 01 	movhs	r12,1
8000a396:	d8 02       	popm	pc
8000a398:	10 39       	cp.w	r9,r8
8000a39a:	fe 9b ff f6 	brhi	8000a386 <__mcmp+0x18>
8000a39e:	d8 02       	popm	pc

8000a3a0 <_Bfree>:
8000a3a0:	d4 21       	pushm	r4-r7,lr
8000a3a2:	18 97       	mov	r7,r12
8000a3a4:	16 95       	mov	r5,r11
8000a3a6:	78 96       	ld.w	r6,r12[0x24]
8000a3a8:	58 06       	cp.w	r6,0
8000a3aa:	c0 91       	brne	8000a3bc <_Bfree+0x1c>
8000a3ac:	31 0c       	mov	r12,16
8000a3ae:	fe b0 de 37 	rcall	8000601c <malloc>
8000a3b2:	99 36       	st.w	r12[0xc],r6
8000a3b4:	8f 9c       	st.w	r7[0x24],r12
8000a3b6:	99 16       	st.w	r12[0x4],r6
8000a3b8:	99 26       	st.w	r12[0x8],r6
8000a3ba:	99 06       	st.w	r12[0x0],r6
8000a3bc:	58 05       	cp.w	r5,0
8000a3be:	c0 90       	breq	8000a3d0 <_Bfree+0x30>
8000a3c0:	6a 19       	ld.w	r9,r5[0x4]
8000a3c2:	6e 98       	ld.w	r8,r7[0x24]
8000a3c4:	70 38       	ld.w	r8,r8[0xc]
8000a3c6:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
8000a3ca:	8b 0a       	st.w	r5[0x0],r10
8000a3cc:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
8000a3d0:	d8 22       	popm	r4-r7,pc
8000a3d2:	d7 03       	nop

8000a3d4 <_Balloc>:
8000a3d4:	d4 21       	pushm	r4-r7,lr
8000a3d6:	18 97       	mov	r7,r12
8000a3d8:	16 96       	mov	r6,r11
8000a3da:	78 95       	ld.w	r5,r12[0x24]
8000a3dc:	58 05       	cp.w	r5,0
8000a3de:	c0 91       	brne	8000a3f0 <_Balloc+0x1c>
8000a3e0:	31 0c       	mov	r12,16
8000a3e2:	fe b0 de 1d 	rcall	8000601c <malloc>
8000a3e6:	99 35       	st.w	r12[0xc],r5
8000a3e8:	8f 9c       	st.w	r7[0x24],r12
8000a3ea:	99 15       	st.w	r12[0x4],r5
8000a3ec:	99 25       	st.w	r12[0x8],r5
8000a3ee:	99 05       	st.w	r12[0x0],r5
8000a3f0:	6e 95       	ld.w	r5,r7[0x24]
8000a3f2:	6a 38       	ld.w	r8,r5[0xc]
8000a3f4:	58 08       	cp.w	r8,0
8000a3f6:	c0 b1       	brne	8000a40c <_Balloc+0x38>
8000a3f8:	31 0a       	mov	r10,16
8000a3fa:	30 4b       	mov	r11,4
8000a3fc:	0e 9c       	mov	r12,r7
8000a3fe:	e0 a0 02 a7 	rcall	8000a94c <_calloc_r>
8000a402:	8b 3c       	st.w	r5[0xc],r12
8000a404:	6e 98       	ld.w	r8,r7[0x24]
8000a406:	70 3c       	ld.w	r12,r8[0xc]
8000a408:	58 0c       	cp.w	r12,0
8000a40a:	c1 b0       	breq	8000a440 <_Balloc+0x6c>
8000a40c:	6e 98       	ld.w	r8,r7[0x24]
8000a40e:	70 38       	ld.w	r8,r8[0xc]
8000a410:	f0 06 00 28 	add	r8,r8,r6<<0x2
8000a414:	70 0c       	ld.w	r12,r8[0x0]
8000a416:	58 0c       	cp.w	r12,0
8000a418:	c0 40       	breq	8000a420 <_Balloc+0x4c>
8000a41a:	78 09       	ld.w	r9,r12[0x0]
8000a41c:	91 09       	st.w	r8[0x0],r9
8000a41e:	c0 e8       	rjmp	8000a43a <_Balloc+0x66>
8000a420:	0e 9c       	mov	r12,r7
8000a422:	30 17       	mov	r7,1
8000a424:	0e 9b       	mov	r11,r7
8000a426:	ee 06 09 47 	lsl	r7,r7,r6
8000a42a:	ee ca ff fb 	sub	r10,r7,-5
8000a42e:	a3 6a       	lsl	r10,0x2
8000a430:	e0 a0 02 8e 	rcall	8000a94c <_calloc_r>
8000a434:	c0 60       	breq	8000a440 <_Balloc+0x6c>
8000a436:	99 16       	st.w	r12[0x4],r6
8000a438:	99 27       	st.w	r12[0x8],r7
8000a43a:	30 08       	mov	r8,0
8000a43c:	99 38       	st.w	r12[0xc],r8
8000a43e:	99 48       	st.w	r12[0x10],r8
8000a440:	d8 22       	popm	r4-r7,pc
8000a442:	d7 03       	nop

8000a444 <__d2b>:
8000a444:	d4 31       	pushm	r0-r7,lr
8000a446:	20 2d       	sub	sp,8
8000a448:	16 93       	mov	r3,r11
8000a44a:	12 96       	mov	r6,r9
8000a44c:	10 95       	mov	r5,r8
8000a44e:	14 92       	mov	r2,r10
8000a450:	30 1b       	mov	r11,1
8000a452:	cc 1f       	rcall	8000a3d4 <_Balloc>
8000a454:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8000a458:	50 09       	stdsp	sp[0x0],r9
8000a45a:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
8000a45e:	b5 a9       	sbr	r9,0x14
8000a460:	f0 01 16 14 	lsr	r1,r8,0x14
8000a464:	fb f9 1a 00 	st.wne	sp[0x0],r9
8000a468:	18 94       	mov	r4,r12
8000a46a:	58 02       	cp.w	r2,0
8000a46c:	c1 d0       	breq	8000a4a6 <__d2b+0x62>
8000a46e:	fa cc ff f8 	sub	r12,sp,-8
8000a472:	18 d2       	st.w	--r12,r2
8000a474:	c3 6f       	rcall	8000a2e0 <__lo0bits>
8000a476:	40 18       	lddsp	r8,sp[0x4]
8000a478:	c0 d0       	breq	8000a492 <__d2b+0x4e>
8000a47a:	40 09       	lddsp	r9,sp[0x0]
8000a47c:	f8 0a 11 20 	rsub	r10,r12,32
8000a480:	f2 0a 09 4a 	lsl	r10,r9,r10
8000a484:	f5 e8 10 08 	or	r8,r10,r8
8000a488:	89 58       	st.w	r4[0x14],r8
8000a48a:	f2 0c 0a 49 	lsr	r9,r9,r12
8000a48e:	50 09       	stdsp	sp[0x0],r9
8000a490:	c0 28       	rjmp	8000a494 <__d2b+0x50>
8000a492:	89 58       	st.w	r4[0x14],r8
8000a494:	40 08       	lddsp	r8,sp[0x0]
8000a496:	58 08       	cp.w	r8,0
8000a498:	f9 b3 01 02 	movne	r3,2
8000a49c:	f9 b3 00 01 	moveq	r3,1
8000a4a0:	89 68       	st.w	r4[0x18],r8
8000a4a2:	89 43       	st.w	r4[0x10],r3
8000a4a4:	c0 88       	rjmp	8000a4b4 <__d2b+0x70>
8000a4a6:	1a 9c       	mov	r12,sp
8000a4a8:	c1 cf       	rcall	8000a2e0 <__lo0bits>
8000a4aa:	30 13       	mov	r3,1
8000a4ac:	40 08       	lddsp	r8,sp[0x0]
8000a4ae:	2e 0c       	sub	r12,-32
8000a4b0:	89 43       	st.w	r4[0x10],r3
8000a4b2:	89 58       	st.w	r4[0x14],r8
8000a4b4:	58 01       	cp.w	r1,0
8000a4b6:	c0 90       	breq	8000a4c8 <__d2b+0x84>
8000a4b8:	e2 c1 04 33 	sub	r1,r1,1075
8000a4bc:	18 01       	add	r1,r12
8000a4be:	8d 01       	st.w	r6[0x0],r1
8000a4c0:	f8 0c 11 35 	rsub	r12,r12,53
8000a4c4:	8b 0c       	st.w	r5[0x0],r12
8000a4c6:	c0 c8       	rjmp	8000a4de <__d2b+0x9a>
8000a4c8:	e6 c8 ff fc 	sub	r8,r3,-4
8000a4cc:	f8 cc 04 32 	sub	r12,r12,1074
8000a4d0:	a5 73       	lsl	r3,0x5
8000a4d2:	8d 0c       	st.w	r6[0x0],r12
8000a4d4:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
8000a4d8:	cd 4e       	rcall	8000a280 <__hi0bits>
8000a4da:	18 13       	sub	r3,r12
8000a4dc:	8b 03       	st.w	r5[0x0],r3
8000a4de:	08 9c       	mov	r12,r4
8000a4e0:	2f ed       	sub	sp,-8
8000a4e2:	d8 32       	popm	r0-r7,pc

8000a4e4 <__mdiff>:
8000a4e4:	d4 31       	pushm	r0-r7,lr
8000a4e6:	74 48       	ld.w	r8,r10[0x10]
8000a4e8:	76 45       	ld.w	r5,r11[0x10]
8000a4ea:	16 97       	mov	r7,r11
8000a4ec:	14 96       	mov	r6,r10
8000a4ee:	10 15       	sub	r5,r8
8000a4f0:	c1 31       	brne	8000a516 <__mdiff+0x32>
8000a4f2:	2f b8       	sub	r8,-5
8000a4f4:	ee ce ff ec 	sub	lr,r7,-20
8000a4f8:	a3 68       	lsl	r8,0x2
8000a4fa:	f4 08 00 0b 	add	r11,r10,r8
8000a4fe:	ee 08 00 08 	add	r8,r7,r8
8000a502:	11 4a       	ld.w	r10,--r8
8000a504:	17 49       	ld.w	r9,--r11
8000a506:	12 3a       	cp.w	r10,r9
8000a508:	c0 30       	breq	8000a50e <__mdiff+0x2a>
8000a50a:	c0 e2       	brcc	8000a526 <__mdiff+0x42>
8000a50c:	c0 78       	rjmp	8000a51a <__mdiff+0x36>
8000a50e:	1c 38       	cp.w	r8,lr
8000a510:	fe 9b ff f9 	brhi	8000a502 <__mdiff+0x1e>
8000a514:	c4 98       	rjmp	8000a5a6 <__mdiff+0xc2>
8000a516:	58 05       	cp.w	r5,0
8000a518:	c0 64       	brge	8000a524 <__mdiff+0x40>
8000a51a:	0e 98       	mov	r8,r7
8000a51c:	30 15       	mov	r5,1
8000a51e:	0c 97       	mov	r7,r6
8000a520:	10 96       	mov	r6,r8
8000a522:	c0 28       	rjmp	8000a526 <__mdiff+0x42>
8000a524:	30 05       	mov	r5,0
8000a526:	6e 1b       	ld.w	r11,r7[0x4]
8000a528:	c5 6f       	rcall	8000a3d4 <_Balloc>
8000a52a:	6e 49       	ld.w	r9,r7[0x10]
8000a52c:	6c 44       	ld.w	r4,r6[0x10]
8000a52e:	99 35       	st.w	r12[0xc],r5
8000a530:	2f b4       	sub	r4,-5
8000a532:	f2 c5 ff fb 	sub	r5,r9,-5
8000a536:	ec 04 00 24 	add	r4,r6,r4<<0x2
8000a53a:	ee 05 00 25 	add	r5,r7,r5<<0x2
8000a53e:	2e c6       	sub	r6,-20
8000a540:	2e c7       	sub	r7,-20
8000a542:	f8 c8 ff ec 	sub	r8,r12,-20
8000a546:	30 0a       	mov	r10,0
8000a548:	0f 0e       	ld.w	lr,r7++
8000a54a:	0d 0b       	ld.w	r11,r6++
8000a54c:	fc 02 16 10 	lsr	r2,lr,0x10
8000a550:	f6 03 16 10 	lsr	r3,r11,0x10
8000a554:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000a558:	e4 03 01 03 	sub	r3,r2,r3
8000a55c:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a560:	fc 0b 01 0b 	sub	r11,lr,r11
8000a564:	f6 0a 00 0a 	add	r10,r11,r10
8000a568:	b0 1a       	st.h	r8[0x2],r10
8000a56a:	b1 4a       	asr	r10,0x10
8000a56c:	e6 0a 00 0a 	add	r10,r3,r10
8000a570:	b0 0a       	st.h	r8[0x0],r10
8000a572:	2f c8       	sub	r8,-4
8000a574:	b1 4a       	asr	r10,0x10
8000a576:	08 36       	cp.w	r6,r4
8000a578:	ce 83       	brcs	8000a548 <__mdiff+0x64>
8000a57a:	c0 d8       	rjmp	8000a594 <__mdiff+0xb0>
8000a57c:	0f 0b       	ld.w	r11,r7++
8000a57e:	f6 0e 16 10 	lsr	lr,r11,0x10
8000a582:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a586:	16 0a       	add	r10,r11
8000a588:	b0 1a       	st.h	r8[0x2],r10
8000a58a:	b1 4a       	asr	r10,0x10
8000a58c:	1c 0a       	add	r10,lr
8000a58e:	b0 0a       	st.h	r8[0x0],r10
8000a590:	2f c8       	sub	r8,-4
8000a592:	b1 4a       	asr	r10,0x10
8000a594:	0a 37       	cp.w	r7,r5
8000a596:	cf 33       	brcs	8000a57c <__mdiff+0x98>
8000a598:	c0 28       	rjmp	8000a59c <__mdiff+0xb8>
8000a59a:	20 19       	sub	r9,1
8000a59c:	11 4a       	ld.w	r10,--r8
8000a59e:	58 0a       	cp.w	r10,0
8000a5a0:	cf d0       	breq	8000a59a <__mdiff+0xb6>
8000a5a2:	99 49       	st.w	r12[0x10],r9
8000a5a4:	d8 32       	popm	r0-r7,pc
8000a5a6:	30 0b       	mov	r11,0
8000a5a8:	c1 6f       	rcall	8000a3d4 <_Balloc>
8000a5aa:	30 18       	mov	r8,1
8000a5ac:	99 48       	st.w	r12[0x10],r8
8000a5ae:	30 08       	mov	r8,0
8000a5b0:	99 58       	st.w	r12[0x14],r8
8000a5b2:	d8 32       	popm	r0-r7,pc

8000a5b4 <__lshift>:
8000a5b4:	d4 31       	pushm	r0-r7,lr
8000a5b6:	16 97       	mov	r7,r11
8000a5b8:	76 46       	ld.w	r6,r11[0x10]
8000a5ba:	f4 02 14 05 	asr	r2,r10,0x5
8000a5be:	2f f6       	sub	r6,-1
8000a5c0:	14 93       	mov	r3,r10
8000a5c2:	18 94       	mov	r4,r12
8000a5c4:	04 06       	add	r6,r2
8000a5c6:	76 1b       	ld.w	r11,r11[0x4]
8000a5c8:	6e 28       	ld.w	r8,r7[0x8]
8000a5ca:	c0 38       	rjmp	8000a5d0 <__lshift+0x1c>
8000a5cc:	2f fb       	sub	r11,-1
8000a5ce:	a1 78       	lsl	r8,0x1
8000a5d0:	10 36       	cp.w	r6,r8
8000a5d2:	fe 99 ff fd 	brgt	8000a5cc <__lshift+0x18>
8000a5d6:	08 9c       	mov	r12,r4
8000a5d8:	cf ee       	rcall	8000a3d4 <_Balloc>
8000a5da:	30 09       	mov	r9,0
8000a5dc:	18 95       	mov	r5,r12
8000a5de:	f8 c8 ff ec 	sub	r8,r12,-20
8000a5e2:	12 9a       	mov	r10,r9
8000a5e4:	c0 38       	rjmp	8000a5ea <__lshift+0x36>
8000a5e6:	10 aa       	st.w	r8++,r10
8000a5e8:	2f f9       	sub	r9,-1
8000a5ea:	04 39       	cp.w	r9,r2
8000a5ec:	cf d5       	brlt	8000a5e6 <__lshift+0x32>
8000a5ee:	6e 4b       	ld.w	r11,r7[0x10]
8000a5f0:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8000a5f4:	2f bb       	sub	r11,-5
8000a5f6:	ee c9 ff ec 	sub	r9,r7,-20
8000a5fa:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
8000a5fe:	58 03       	cp.w	r3,0
8000a600:	c1 30       	breq	8000a626 <__lshift+0x72>
8000a602:	e6 0c 11 20 	rsub	r12,r3,32
8000a606:	30 0a       	mov	r10,0
8000a608:	72 02       	ld.w	r2,r9[0x0]
8000a60a:	e4 03 09 42 	lsl	r2,r2,r3
8000a60e:	04 4a       	or	r10,r2
8000a610:	10 aa       	st.w	r8++,r10
8000a612:	13 0a       	ld.w	r10,r9++
8000a614:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a618:	16 39       	cp.w	r9,r11
8000a61a:	cf 73       	brcs	8000a608 <__lshift+0x54>
8000a61c:	91 0a       	st.w	r8[0x0],r10
8000a61e:	58 0a       	cp.w	r10,0
8000a620:	c0 70       	breq	8000a62e <__lshift+0x7a>
8000a622:	2f f6       	sub	r6,-1
8000a624:	c0 58       	rjmp	8000a62e <__lshift+0x7a>
8000a626:	13 0a       	ld.w	r10,r9++
8000a628:	10 aa       	st.w	r8++,r10
8000a62a:	16 39       	cp.w	r9,r11
8000a62c:	cf d3       	brcs	8000a626 <__lshift+0x72>
8000a62e:	08 9c       	mov	r12,r4
8000a630:	20 16       	sub	r6,1
8000a632:	0e 9b       	mov	r11,r7
8000a634:	8b 46       	st.w	r5[0x10],r6
8000a636:	cb 5e       	rcall	8000a3a0 <_Bfree>
8000a638:	0a 9c       	mov	r12,r5
8000a63a:	d8 32       	popm	r0-r7,pc

8000a63c <__multiply>:
8000a63c:	d4 31       	pushm	r0-r7,lr
8000a63e:	20 2d       	sub	sp,8
8000a640:	76 49       	ld.w	r9,r11[0x10]
8000a642:	74 48       	ld.w	r8,r10[0x10]
8000a644:	16 96       	mov	r6,r11
8000a646:	14 95       	mov	r5,r10
8000a648:	10 39       	cp.w	r9,r8
8000a64a:	ec 08 17 50 	movlt	r8,r6
8000a64e:	ea 06 17 50 	movlt	r6,r5
8000a652:	f0 05 17 50 	movlt	r5,r8
8000a656:	6c 28       	ld.w	r8,r6[0x8]
8000a658:	76 43       	ld.w	r3,r11[0x10]
8000a65a:	74 42       	ld.w	r2,r10[0x10]
8000a65c:	76 1b       	ld.w	r11,r11[0x4]
8000a65e:	e4 03 00 07 	add	r7,r2,r3
8000a662:	10 37       	cp.w	r7,r8
8000a664:	f7 bb 09 ff 	subgt	r11,-1
8000a668:	cb 6e       	rcall	8000a3d4 <_Balloc>
8000a66a:	ee c4 ff fb 	sub	r4,r7,-5
8000a66e:	f8 c9 ff ec 	sub	r9,r12,-20
8000a672:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000a676:	30 0a       	mov	r10,0
8000a678:	12 98       	mov	r8,r9
8000a67a:	c0 28       	rjmp	8000a67e <__multiply+0x42>
8000a67c:	10 aa       	st.w	r8++,r10
8000a67e:	08 38       	cp.w	r8,r4
8000a680:	cf e3       	brcs	8000a67c <__multiply+0x40>
8000a682:	2f b3       	sub	r3,-5
8000a684:	2f b2       	sub	r2,-5
8000a686:	ec 03 00 23 	add	r3,r6,r3<<0x2
8000a68a:	ea 02 00 22 	add	r2,r5,r2<<0x2
8000a68e:	ec cb ff ec 	sub	r11,r6,-20
8000a692:	50 12       	stdsp	sp[0x4],r2
8000a694:	ea ca ff ec 	sub	r10,r5,-20
8000a698:	c4 48       	rjmp	8000a720 <__multiply+0xe4>
8000a69a:	94 95       	ld.uh	r5,r10[0x2]
8000a69c:	58 05       	cp.w	r5,0
8000a69e:	c2 00       	breq	8000a6de <__multiply+0xa2>
8000a6a0:	12 98       	mov	r8,r9
8000a6a2:	16 96       	mov	r6,r11
8000a6a4:	30 0e       	mov	lr,0
8000a6a6:	50 09       	stdsp	sp[0x0],r9
8000a6a8:	0d 02       	ld.w	r2,r6++
8000a6aa:	e4 00 16 10 	lsr	r0,r2,0x10
8000a6ae:	70 01       	ld.w	r1,r8[0x0]
8000a6b0:	70 09       	ld.w	r9,r8[0x0]
8000a6b2:	b1 81       	lsr	r1,0x10
8000a6b4:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8000a6b8:	e0 05 03 41 	mac	r1,r0,r5
8000a6bc:	ab 32       	mul	r2,r5
8000a6be:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
8000a6c2:	00 02       	add	r2,r0
8000a6c4:	e4 0e 00 0e 	add	lr,r2,lr
8000a6c8:	b0 1e       	st.h	r8[0x2],lr
8000a6ca:	b1 8e       	lsr	lr,0x10
8000a6cc:	1c 01       	add	r1,lr
8000a6ce:	b0 01       	st.h	r8[0x0],r1
8000a6d0:	e2 0e 16 10 	lsr	lr,r1,0x10
8000a6d4:	2f c8       	sub	r8,-4
8000a6d6:	06 36       	cp.w	r6,r3
8000a6d8:	ce 83       	brcs	8000a6a8 <__multiply+0x6c>
8000a6da:	40 09       	lddsp	r9,sp[0x0]
8000a6dc:	91 0e       	st.w	r8[0x0],lr
8000a6de:	94 86       	ld.uh	r6,r10[0x0]
8000a6e0:	58 06       	cp.w	r6,0
8000a6e2:	c1 d0       	breq	8000a71c <__multiply+0xe0>
8000a6e4:	72 02       	ld.w	r2,r9[0x0]
8000a6e6:	12 98       	mov	r8,r9
8000a6e8:	16 9e       	mov	lr,r11
8000a6ea:	30 05       	mov	r5,0
8000a6ec:	b0 12       	st.h	r8[0x2],r2
8000a6ee:	1d 01       	ld.w	r1,lr++
8000a6f0:	90 82       	ld.uh	r2,r8[0x0]
8000a6f2:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
8000a6f6:	ad 30       	mul	r0,r6
8000a6f8:	e0 02 00 02 	add	r2,r0,r2
8000a6fc:	e4 05 00 05 	add	r5,r2,r5
8000a700:	b0 05       	st.h	r8[0x0],r5
8000a702:	b1 85       	lsr	r5,0x10
8000a704:	b1 81       	lsr	r1,0x10
8000a706:	2f c8       	sub	r8,-4
8000a708:	ad 31       	mul	r1,r6
8000a70a:	90 92       	ld.uh	r2,r8[0x2]
8000a70c:	e2 02 00 02 	add	r2,r1,r2
8000a710:	0a 02       	add	r2,r5
8000a712:	e4 05 16 10 	lsr	r5,r2,0x10
8000a716:	06 3e       	cp.w	lr,r3
8000a718:	ce a3       	brcs	8000a6ec <__multiply+0xb0>
8000a71a:	91 02       	st.w	r8[0x0],r2
8000a71c:	2f ca       	sub	r10,-4
8000a71e:	2f c9       	sub	r9,-4
8000a720:	40 18       	lddsp	r8,sp[0x4]
8000a722:	10 3a       	cp.w	r10,r8
8000a724:	cb b3       	brcs	8000a69a <__multiply+0x5e>
8000a726:	c0 28       	rjmp	8000a72a <__multiply+0xee>
8000a728:	20 17       	sub	r7,1
8000a72a:	58 07       	cp.w	r7,0
8000a72c:	e0 8a 00 05 	brle	8000a736 <__multiply+0xfa>
8000a730:	09 48       	ld.w	r8,--r4
8000a732:	58 08       	cp.w	r8,0
8000a734:	cf a0       	breq	8000a728 <__multiply+0xec>
8000a736:	99 47       	st.w	r12[0x10],r7
8000a738:	2f ed       	sub	sp,-8
8000a73a:	d8 32       	popm	r0-r7,pc

8000a73c <__i2b>:
8000a73c:	d4 21       	pushm	r4-r7,lr
8000a73e:	16 97       	mov	r7,r11
8000a740:	30 1b       	mov	r11,1
8000a742:	c4 9e       	rcall	8000a3d4 <_Balloc>
8000a744:	30 19       	mov	r9,1
8000a746:	99 57       	st.w	r12[0x14],r7
8000a748:	99 49       	st.w	r12[0x10],r9
8000a74a:	d8 22       	popm	r4-r7,pc

8000a74c <__multadd>:
8000a74c:	d4 31       	pushm	r0-r7,lr
8000a74e:	30 08       	mov	r8,0
8000a750:	12 95       	mov	r5,r9
8000a752:	16 97       	mov	r7,r11
8000a754:	18 96       	mov	r6,r12
8000a756:	76 44       	ld.w	r4,r11[0x10]
8000a758:	f6 c9 ff ec 	sub	r9,r11,-20
8000a75c:	72 0b       	ld.w	r11,r9[0x0]
8000a75e:	f6 0c 16 10 	lsr	r12,r11,0x10
8000a762:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000a766:	f4 0c 02 4c 	mul	r12,r10,r12
8000a76a:	f4 0b 03 45 	mac	r5,r10,r11
8000a76e:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
8000a772:	b1 85       	lsr	r5,0x10
8000a774:	18 05       	add	r5,r12
8000a776:	ea 0c 15 10 	lsl	r12,r5,0x10
8000a77a:	f8 0b 00 0b 	add	r11,r12,r11
8000a77e:	12 ab       	st.w	r9++,r11
8000a780:	2f f8       	sub	r8,-1
8000a782:	b1 85       	lsr	r5,0x10
8000a784:	08 38       	cp.w	r8,r4
8000a786:	ce b5       	brlt	8000a75c <__multadd+0x10>
8000a788:	58 05       	cp.w	r5,0
8000a78a:	c1 c0       	breq	8000a7c2 <__multadd+0x76>
8000a78c:	6e 28       	ld.w	r8,r7[0x8]
8000a78e:	10 34       	cp.w	r4,r8
8000a790:	c1 35       	brlt	8000a7b6 <__multadd+0x6a>
8000a792:	6e 1b       	ld.w	r11,r7[0x4]
8000a794:	0c 9c       	mov	r12,r6
8000a796:	2f fb       	sub	r11,-1
8000a798:	c1 ee       	rcall	8000a3d4 <_Balloc>
8000a79a:	6e 4a       	ld.w	r10,r7[0x10]
8000a79c:	ee cb ff f4 	sub	r11,r7,-12
8000a7a0:	18 93       	mov	r3,r12
8000a7a2:	2f ea       	sub	r10,-2
8000a7a4:	2f 4c       	sub	r12,-12
8000a7a6:	a3 6a       	lsl	r10,0x2
8000a7a8:	fe b0 de 71 	rcall	8000648a <memcpy>
8000a7ac:	0e 9b       	mov	r11,r7
8000a7ae:	0c 9c       	mov	r12,r6
8000a7b0:	fe b0 fd f8 	rcall	8000a3a0 <_Bfree>
8000a7b4:	06 97       	mov	r7,r3
8000a7b6:	e8 c8 ff ff 	sub	r8,r4,-1
8000a7ba:	2f b4       	sub	r4,-5
8000a7bc:	8f 48       	st.w	r7[0x10],r8
8000a7be:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
8000a7c2:	0e 9c       	mov	r12,r7
8000a7c4:	d8 32       	popm	r0-r7,pc
8000a7c6:	d7 03       	nop

8000a7c8 <__pow5mult>:
8000a7c8:	d4 31       	pushm	r0-r7,lr
8000a7ca:	14 96       	mov	r6,r10
8000a7cc:	18 97       	mov	r7,r12
8000a7ce:	16 94       	mov	r4,r11
8000a7d0:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
8000a7d4:	c0 90       	breq	8000a7e6 <__pow5mult+0x1e>
8000a7d6:	20 18       	sub	r8,1
8000a7d8:	fe c9 da 9c 	sub	r9,pc,-9572
8000a7dc:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8000a7e0:	30 09       	mov	r9,0
8000a7e2:	cb 5f       	rcall	8000a74c <__multadd>
8000a7e4:	18 94       	mov	r4,r12
8000a7e6:	a3 46       	asr	r6,0x2
8000a7e8:	c3 40       	breq	8000a850 <__pow5mult+0x88>
8000a7ea:	6e 95       	ld.w	r5,r7[0x24]
8000a7ec:	58 05       	cp.w	r5,0
8000a7ee:	c0 91       	brne	8000a800 <__pow5mult+0x38>
8000a7f0:	31 0c       	mov	r12,16
8000a7f2:	fe b0 dc 15 	rcall	8000601c <malloc>
8000a7f6:	99 35       	st.w	r12[0xc],r5
8000a7f8:	8f 9c       	st.w	r7[0x24],r12
8000a7fa:	99 15       	st.w	r12[0x4],r5
8000a7fc:	99 25       	st.w	r12[0x8],r5
8000a7fe:	99 05       	st.w	r12[0x0],r5
8000a800:	6e 93       	ld.w	r3,r7[0x24]
8000a802:	66 25       	ld.w	r5,r3[0x8]
8000a804:	58 05       	cp.w	r5,0
8000a806:	c0 c1       	brne	8000a81e <__pow5mult+0x56>
8000a808:	e0 6b 02 71 	mov	r11,625
8000a80c:	0e 9c       	mov	r12,r7
8000a80e:	c9 7f       	rcall	8000a73c <__i2b>
8000a810:	87 2c       	st.w	r3[0x8],r12
8000a812:	30 08       	mov	r8,0
8000a814:	18 95       	mov	r5,r12
8000a816:	99 08       	st.w	r12[0x0],r8
8000a818:	c0 38       	rjmp	8000a81e <__pow5mult+0x56>
8000a81a:	06 9c       	mov	r12,r3
8000a81c:	18 95       	mov	r5,r12
8000a81e:	ed b6 00 00 	bld	r6,0x0
8000a822:	c0 b1       	brne	8000a838 <__pow5mult+0x70>
8000a824:	08 9b       	mov	r11,r4
8000a826:	0a 9a       	mov	r10,r5
8000a828:	0e 9c       	mov	r12,r7
8000a82a:	c0 9f       	rcall	8000a63c <__multiply>
8000a82c:	08 9b       	mov	r11,r4
8000a82e:	18 93       	mov	r3,r12
8000a830:	0e 9c       	mov	r12,r7
8000a832:	06 94       	mov	r4,r3
8000a834:	fe b0 fd b6 	rcall	8000a3a0 <_Bfree>
8000a838:	a1 56       	asr	r6,0x1
8000a83a:	c0 b0       	breq	8000a850 <__pow5mult+0x88>
8000a83c:	6a 03       	ld.w	r3,r5[0x0]
8000a83e:	58 03       	cp.w	r3,0
8000a840:	ce d1       	brne	8000a81a <__pow5mult+0x52>
8000a842:	0a 9a       	mov	r10,r5
8000a844:	0a 9b       	mov	r11,r5
8000a846:	0e 9c       	mov	r12,r7
8000a848:	cf ae       	rcall	8000a63c <__multiply>
8000a84a:	8b 0c       	st.w	r5[0x0],r12
8000a84c:	99 03       	st.w	r12[0x0],r3
8000a84e:	ce 7b       	rjmp	8000a81c <__pow5mult+0x54>
8000a850:	08 9c       	mov	r12,r4
8000a852:	d8 32       	popm	r0-r7,pc

8000a854 <__isinfd>:
8000a854:	14 98       	mov	r8,r10
8000a856:	fc 19 7f f0 	movh	r9,0x7ff0
8000a85a:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a85e:	f0 0b 11 00 	rsub	r11,r8,0
8000a862:	f7 e8 10 08 	or	r8,r11,r8
8000a866:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
8000a86a:	f2 08 01 08 	sub	r8,r9,r8
8000a86e:	f0 0c 11 00 	rsub	r12,r8,0
8000a872:	f9 e8 10 08 	or	r8,r12,r8
8000a876:	f0 0c 14 1f 	asr	r12,r8,0x1f
8000a87a:	2f fc       	sub	r12,-1
8000a87c:	5e fc       	retal	r12

8000a87e <__isnand>:
8000a87e:	14 98       	mov	r8,r10
8000a880:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
8000a884:	f0 0c 11 00 	rsub	r12,r8,0
8000a888:	10 4c       	or	r12,r8
8000a88a:	fc 18 7f f0 	movh	r8,0x7ff0
8000a88e:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
8000a892:	f0 0c 01 0c 	sub	r12,r8,r12
8000a896:	bf 9c       	lsr	r12,0x1f
8000a898:	5e fc       	retal	r12
8000a89a:	d7 03       	nop

8000a89c <__sclose>:
8000a89c:	d4 01       	pushm	lr
8000a89e:	96 7b       	ld.sh	r11,r11[0xe]
8000a8a0:	c8 2c       	rcall	8000a9a4 <_close_r>
8000a8a2:	d8 02       	popm	pc

8000a8a4 <__sseek>:
8000a8a4:	d4 21       	pushm	r4-r7,lr
8000a8a6:	16 97       	mov	r7,r11
8000a8a8:	96 7b       	ld.sh	r11,r11[0xe]
8000a8aa:	c0 3d       	rcall	8000aab0 <_lseek_r>
8000a8ac:	8e 68       	ld.sh	r8,r7[0xc]
8000a8ae:	10 99       	mov	r9,r8
8000a8b0:	ad c8       	cbr	r8,0xc
8000a8b2:	ad a9       	sbr	r9,0xc
8000a8b4:	5b fc       	cp.w	r12,-1
8000a8b6:	ef f8 0c 06 	st.heq	r7[0xc],r8
8000a8ba:	ef f9 1c 06 	st.hne	r7[0xc],r9
8000a8be:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000a8c2:	d8 22       	popm	r4-r7,pc

8000a8c4 <__swrite>:
8000a8c4:	d4 21       	pushm	r4-r7,lr
8000a8c6:	96 68       	ld.sh	r8,r11[0xc]
8000a8c8:	16 97       	mov	r7,r11
8000a8ca:	14 95       	mov	r5,r10
8000a8cc:	12 94       	mov	r4,r9
8000a8ce:	e2 18 01 00 	andl	r8,0x100,COH
8000a8d2:	18 96       	mov	r6,r12
8000a8d4:	c0 50       	breq	8000a8de <__swrite+0x1a>
8000a8d6:	30 29       	mov	r9,2
8000a8d8:	30 0a       	mov	r10,0
8000a8da:	96 7b       	ld.sh	r11,r11[0xe]
8000a8dc:	ce ac       	rcall	8000aab0 <_lseek_r>
8000a8de:	8e 68       	ld.sh	r8,r7[0xc]
8000a8e0:	ad c8       	cbr	r8,0xc
8000a8e2:	08 99       	mov	r9,r4
8000a8e4:	0a 9a       	mov	r10,r5
8000a8e6:	8e 7b       	ld.sh	r11,r7[0xe]
8000a8e8:	0c 9c       	mov	r12,r6
8000a8ea:	ae 68       	st.h	r7[0xc],r8
8000a8ec:	c1 cc       	rcall	8000a924 <_write_r>
8000a8ee:	d8 22       	popm	r4-r7,pc

8000a8f0 <__sread>:
8000a8f0:	d4 21       	pushm	r4-r7,lr
8000a8f2:	16 97       	mov	r7,r11
8000a8f4:	96 7b       	ld.sh	r11,r11[0xe]
8000a8f6:	cf 1c       	rcall	8000aad8 <_read_r>
8000a8f8:	c0 65       	brlt	8000a904 <__sread+0x14>
8000a8fa:	6f 58       	ld.w	r8,r7[0x54]
8000a8fc:	18 08       	add	r8,r12
8000a8fe:	ef 48 00 54 	st.w	r7[84],r8
8000a902:	d8 22       	popm	r4-r7,pc
8000a904:	8e 68       	ld.sh	r8,r7[0xc]
8000a906:	ad c8       	cbr	r8,0xc
8000a908:	ae 68       	st.h	r7[0xc],r8
8000a90a:	d8 22       	popm	r4-r7,pc

8000a90c <strlen>:
8000a90c:	30 09       	mov	r9,0
8000a90e:	18 98       	mov	r8,r12
8000a910:	c0 28       	rjmp	8000a914 <strlen+0x8>
8000a912:	2f f8       	sub	r8,-1
8000a914:	11 8a       	ld.ub	r10,r8[0x0]
8000a916:	f2 0a 18 00 	cp.b	r10,r9
8000a91a:	cf c1       	brne	8000a912 <strlen+0x6>
8000a91c:	f0 0c 01 0c 	sub	r12,r8,r12
8000a920:	5e fc       	retal	r12
8000a922:	d7 03       	nop

8000a924 <_write_r>:
8000a924:	d4 21       	pushm	r4-r7,lr
8000a926:	16 98       	mov	r8,r11
8000a928:	18 97       	mov	r7,r12
8000a92a:	10 9c       	mov	r12,r8
8000a92c:	30 08       	mov	r8,0
8000a92e:	14 9b       	mov	r11,r10
8000a930:	e0 66 1f a4 	mov	r6,8100
8000a934:	12 9a       	mov	r10,r9
8000a936:	8d 08       	st.w	r6[0x0],r8
8000a938:	fe b0 d2 70 	rcall	80004e18 <_write>
8000a93c:	5b fc       	cp.w	r12,-1
8000a93e:	c0 51       	brne	8000a948 <_write_r+0x24>
8000a940:	6c 08       	ld.w	r8,r6[0x0]
8000a942:	58 08       	cp.w	r8,0
8000a944:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a948:	d8 22       	popm	r4-r7,pc
8000a94a:	d7 03       	nop

8000a94c <_calloc_r>:
8000a94c:	d4 21       	pushm	r4-r7,lr
8000a94e:	f4 0b 02 4b 	mul	r11,r10,r11
8000a952:	fe b0 db 6d 	rcall	8000602c <_malloc_r>
8000a956:	18 97       	mov	r7,r12
8000a958:	c2 30       	breq	8000a99e <_calloc_r+0x52>
8000a95a:	f8 fa ff fc 	ld.w	r10,r12[-4]
8000a95e:	e0 1a ff fc 	andl	r10,0xfffc
8000a962:	20 4a       	sub	r10,4
8000a964:	e0 4a 00 24 	cp.w	r10,36
8000a968:	e0 8b 00 18 	brhi	8000a998 <_calloc_r+0x4c>
8000a96c:	18 98       	mov	r8,r12
8000a96e:	59 3a       	cp.w	r10,19
8000a970:	e0 88 00 0f 	brls	8000a98e <_calloc_r+0x42>
8000a974:	30 09       	mov	r9,0
8000a976:	10 a9       	st.w	r8++,r9
8000a978:	10 a9       	st.w	r8++,r9
8000a97a:	59 ba       	cp.w	r10,27
8000a97c:	e0 88 00 09 	brls	8000a98e <_calloc_r+0x42>
8000a980:	10 a9       	st.w	r8++,r9
8000a982:	10 a9       	st.w	r8++,r9
8000a984:	e0 4a 00 24 	cp.w	r10,36
8000a988:	c0 31       	brne	8000a98e <_calloc_r+0x42>
8000a98a:	10 a9       	st.w	r8++,r9
8000a98c:	10 a9       	st.w	r8++,r9
8000a98e:	30 09       	mov	r9,0
8000a990:	10 a9       	st.w	r8++,r9
8000a992:	91 19       	st.w	r8[0x4],r9
8000a994:	91 09       	st.w	r8[0x0],r9
8000a996:	c0 48       	rjmp	8000a99e <_calloc_r+0x52>
8000a998:	30 0b       	mov	r11,0
8000a99a:	fe b0 de 1c 	rcall	800065d2 <memset>
8000a99e:	0e 9c       	mov	r12,r7
8000a9a0:	d8 22       	popm	r4-r7,pc
8000a9a2:	d7 03       	nop

8000a9a4 <_close_r>:
8000a9a4:	d4 21       	pushm	r4-r7,lr
8000a9a6:	30 08       	mov	r8,0
8000a9a8:	18 97       	mov	r7,r12
8000a9aa:	e0 66 1f a4 	mov	r6,8100
8000a9ae:	16 9c       	mov	r12,r11
8000a9b0:	8d 08       	st.w	r6[0x0],r8
8000a9b2:	fe b0 df b5 	rcall	8000691c <_close>
8000a9b6:	5b fc       	cp.w	r12,-1
8000a9b8:	c0 51       	brne	8000a9c2 <_close_r+0x1e>
8000a9ba:	6c 08       	ld.w	r8,r6[0x0]
8000a9bc:	58 08       	cp.w	r8,0
8000a9be:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000a9c2:	d8 22       	popm	r4-r7,pc

8000a9c4 <_fclose_r>:
8000a9c4:	d4 21       	pushm	r4-r7,lr
8000a9c6:	18 96       	mov	r6,r12
8000a9c8:	16 97       	mov	r7,r11
8000a9ca:	58 0b       	cp.w	r11,0
8000a9cc:	c0 31       	brne	8000a9d2 <_fclose_r+0xe>
8000a9ce:	16 95       	mov	r5,r11
8000a9d0:	c5 38       	rjmp	8000aa76 <_fclose_r+0xb2>
8000a9d2:	fe b0 f8 a9 	rcall	80009b24 <__sfp_lock_acquire>
8000a9d6:	58 06       	cp.w	r6,0
8000a9d8:	c0 70       	breq	8000a9e6 <_fclose_r+0x22>
8000a9da:	6c 68       	ld.w	r8,r6[0x18]
8000a9dc:	58 08       	cp.w	r8,0
8000a9de:	c0 41       	brne	8000a9e6 <_fclose_r+0x22>
8000a9e0:	0c 9c       	mov	r12,r6
8000a9e2:	fe b0 f8 f3 	rcall	80009bc8 <__sinit>
8000a9e6:	fe c8 dd 4e 	sub	r8,pc,-8882
8000a9ea:	10 37       	cp.w	r7,r8
8000a9ec:	c0 31       	brne	8000a9f2 <_fclose_r+0x2e>
8000a9ee:	6c 07       	ld.w	r7,r6[0x0]
8000a9f0:	c0 c8       	rjmp	8000aa08 <_fclose_r+0x44>
8000a9f2:	fe c8 dd 3a 	sub	r8,pc,-8902
8000a9f6:	10 37       	cp.w	r7,r8
8000a9f8:	c0 31       	brne	8000a9fe <_fclose_r+0x3a>
8000a9fa:	6c 17       	ld.w	r7,r6[0x4]
8000a9fc:	c0 68       	rjmp	8000aa08 <_fclose_r+0x44>
8000a9fe:	fe c8 dd 26 	sub	r8,pc,-8922
8000aa02:	10 37       	cp.w	r7,r8
8000aa04:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000aa08:	8e 69       	ld.sh	r9,r7[0xc]
8000aa0a:	30 08       	mov	r8,0
8000aa0c:	f0 09 19 00 	cp.h	r9,r8
8000aa10:	c0 51       	brne	8000aa1a <_fclose_r+0x56>
8000aa12:	fe b0 f8 8a 	rcall	80009b26 <__sfp_lock_release>
8000aa16:	30 05       	mov	r5,0
8000aa18:	c2 f8       	rjmp	8000aa76 <_fclose_r+0xb2>
8000aa1a:	0e 9b       	mov	r11,r7
8000aa1c:	0c 9c       	mov	r12,r6
8000aa1e:	fe b0 f7 fd 	rcall	80009a18 <_fflush_r>
8000aa22:	6e c8       	ld.w	r8,r7[0x30]
8000aa24:	18 95       	mov	r5,r12
8000aa26:	58 08       	cp.w	r8,0
8000aa28:	c0 60       	breq	8000aa34 <_fclose_r+0x70>
8000aa2a:	6e 8b       	ld.w	r11,r7[0x20]
8000aa2c:	0c 9c       	mov	r12,r6
8000aa2e:	5d 18       	icall	r8
8000aa30:	f9 b5 05 ff 	movlt	r5,-1
8000aa34:	8e 68       	ld.sh	r8,r7[0xc]
8000aa36:	ed b8 00 07 	bld	r8,0x7
8000aa3a:	c0 51       	brne	8000aa44 <_fclose_r+0x80>
8000aa3c:	6e 4b       	ld.w	r11,r7[0x10]
8000aa3e:	0c 9c       	mov	r12,r6
8000aa40:	fe b0 f9 5e 	rcall	80009cfc <_free_r>
8000aa44:	6e db       	ld.w	r11,r7[0x34]
8000aa46:	58 0b       	cp.w	r11,0
8000aa48:	c0 a0       	breq	8000aa5c <_fclose_r+0x98>
8000aa4a:	ee c8 ff bc 	sub	r8,r7,-68
8000aa4e:	10 3b       	cp.w	r11,r8
8000aa50:	c0 40       	breq	8000aa58 <_fclose_r+0x94>
8000aa52:	0c 9c       	mov	r12,r6
8000aa54:	fe b0 f9 54 	rcall	80009cfc <_free_r>
8000aa58:	30 08       	mov	r8,0
8000aa5a:	8f d8       	st.w	r7[0x34],r8
8000aa5c:	6f 2b       	ld.w	r11,r7[0x48]
8000aa5e:	58 0b       	cp.w	r11,0
8000aa60:	c0 70       	breq	8000aa6e <_fclose_r+0xaa>
8000aa62:	0c 9c       	mov	r12,r6
8000aa64:	fe b0 f9 4c 	rcall	80009cfc <_free_r>
8000aa68:	30 08       	mov	r8,0
8000aa6a:	ef 48 00 48 	st.w	r7[72],r8
8000aa6e:	30 08       	mov	r8,0
8000aa70:	ae 68       	st.h	r7[0xc],r8
8000aa72:	fe b0 f8 5a 	rcall	80009b26 <__sfp_lock_release>
8000aa76:	0a 9c       	mov	r12,r5
8000aa78:	d8 22       	popm	r4-r7,pc
8000aa7a:	d7 03       	nop

8000aa7c <fclose>:
8000aa7c:	d4 01       	pushm	lr
8000aa7e:	e0 68 0a 18 	mov	r8,2584
8000aa82:	18 9b       	mov	r11,r12
8000aa84:	70 0c       	ld.w	r12,r8[0x0]
8000aa86:	c9 ff       	rcall	8000a9c4 <_fclose_r>
8000aa88:	d8 02       	popm	pc
8000aa8a:	d7 03       	nop

8000aa8c <_fstat_r>:
8000aa8c:	d4 21       	pushm	r4-r7,lr
8000aa8e:	16 98       	mov	r8,r11
8000aa90:	18 97       	mov	r7,r12
8000aa92:	10 9c       	mov	r12,r8
8000aa94:	30 08       	mov	r8,0
8000aa96:	e0 66 1f a4 	mov	r6,8100
8000aa9a:	14 9b       	mov	r11,r10
8000aa9c:	8d 08       	st.w	r6[0x0],r8
8000aa9e:	fe b0 df 67 	rcall	8000696c <_fstat>
8000aaa2:	5b fc       	cp.w	r12,-1
8000aaa4:	c0 51       	brne	8000aaae <_fstat_r+0x22>
8000aaa6:	6c 08       	ld.w	r8,r6[0x0]
8000aaa8:	58 08       	cp.w	r8,0
8000aaaa:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aaae:	d8 22       	popm	r4-r7,pc

8000aab0 <_lseek_r>:
8000aab0:	d4 21       	pushm	r4-r7,lr
8000aab2:	16 98       	mov	r8,r11
8000aab4:	18 97       	mov	r7,r12
8000aab6:	10 9c       	mov	r12,r8
8000aab8:	30 08       	mov	r8,0
8000aaba:	14 9b       	mov	r11,r10
8000aabc:	e0 66 1f a4 	mov	r6,8100
8000aac0:	12 9a       	mov	r10,r9
8000aac2:	8d 08       	st.w	r6[0x0],r8
8000aac4:	fe b0 df 36 	rcall	80006930 <_lseek>
8000aac8:	5b fc       	cp.w	r12,-1
8000aaca:	c0 51       	brne	8000aad4 <_lseek_r+0x24>
8000aacc:	6c 08       	ld.w	r8,r6[0x0]
8000aace:	58 08       	cp.w	r8,0
8000aad0:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aad4:	d8 22       	popm	r4-r7,pc
8000aad6:	d7 03       	nop

8000aad8 <_read_r>:
8000aad8:	d4 21       	pushm	r4-r7,lr
8000aada:	16 98       	mov	r8,r11
8000aadc:	18 97       	mov	r7,r12
8000aade:	10 9c       	mov	r12,r8
8000aae0:	30 08       	mov	r8,0
8000aae2:	14 9b       	mov	r11,r10
8000aae4:	e0 66 1f a4 	mov	r6,8100
8000aae8:	12 9a       	mov	r10,r9
8000aaea:	8d 08       	st.w	r6[0x0],r8
8000aaec:	fe b0 d1 76 	rcall	80004dd8 <_read>
8000aaf0:	5b fc       	cp.w	r12,-1
8000aaf2:	c0 51       	brne	8000aafc <_read_r+0x24>
8000aaf4:	6c 08       	ld.w	r8,r6[0x0]
8000aaf6:	58 08       	cp.w	r8,0
8000aaf8:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000aafc:	d8 22       	popm	r4-r7,pc
8000aafe:	d7 03       	nop

8000ab00 <__avr32_f64_mul>:
8000ab00:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
8000ab04:	e0 80 00 dc 	breq	8000acbc <__avr32_f64_mul_op1_zero>
8000ab08:	d4 21       	pushm	r4-r7,lr
8000ab0a:	f7 e9 20 0e 	eor	lr,r11,r9
8000ab0e:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000ab12:	30 15       	mov	r5,1
8000ab14:	c4 30       	breq	8000ab9a <__avr32_f64_mul_op1_subnormal>
8000ab16:	ab 6b       	lsl	r11,0xa
8000ab18:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
8000ab1c:	ab 6a       	lsl	r10,0xa
8000ab1e:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
8000ab22:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000ab26:	c5 c0       	breq	8000abde <__avr32_f64_mul_op2_subnormal>
8000ab28:	a1 78       	lsl	r8,0x1
8000ab2a:	5c f9       	rol	r9
8000ab2c:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000ab30:	e0 47 07 ff 	cp.w	r7,2047
8000ab34:	c7 70       	breq	8000ac22 <__avr32_f64_mul_op_nan_or_inf>
8000ab36:	e0 46 07 ff 	cp.w	r6,2047
8000ab3a:	c7 40       	breq	8000ac22 <__avr32_f64_mul_op_nan_or_inf>
8000ab3c:	ee 06 00 0c 	add	r12,r7,r6
8000ab40:	e0 2c 03 fe 	sub	r12,1022
8000ab44:	f6 08 06 44 	mulu.d	r4,r11,r8
8000ab48:	f4 09 07 44 	macu.d	r4,r10,r9
8000ab4c:	f4 08 06 46 	mulu.d	r6,r10,r8
8000ab50:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000ab54:	08 07       	add	r7,r4
8000ab56:	f4 05 00 4a 	adc	r10,r10,r5
8000ab5a:	5c 0b       	acr	r11
8000ab5c:	ed bb 00 14 	bld	r11,0x14
8000ab60:	c0 50       	breq	8000ab6a <__avr32_f64_mul+0x6a>
8000ab62:	a1 77       	lsl	r7,0x1
8000ab64:	5c fa       	rol	r10
8000ab66:	5c fb       	rol	r11
8000ab68:	20 1c       	sub	r12,1
8000ab6a:	58 0c       	cp.w	r12,0
8000ab6c:	e0 8a 00 6f 	brle	8000ac4a <__avr32_f64_mul_res_subnormal>
8000ab70:	e0 4c 07 ff 	cp.w	r12,2047
8000ab74:	e0 84 00 9c 	brge	8000acac <__avr32_f64_mul_res_inf>
8000ab78:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000ab7c:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000ab80:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000ab84:	ee 17 80 00 	eorh	r7,0x8000
8000ab88:	f1 b7 04 20 	satu	r7,0x1
8000ab8c:	0e 0a       	add	r10,r7
8000ab8e:	5c 0b       	acr	r11
8000ab90:	ed be 00 1f 	bld	lr,0x1f
8000ab94:	ef bb 00 1f 	bst	r11,0x1f
8000ab98:	d8 22       	popm	r4-r7,pc

8000ab9a <__avr32_f64_mul_op1_subnormal>:
8000ab9a:	e4 1b 00 0f 	andh	r11,0xf
8000ab9e:	f4 0c 12 00 	clz	r12,r10
8000aba2:	f6 06 12 00 	clz	r6,r11
8000aba6:	f7 bc 03 e1 	sublo	r12,-31
8000abaa:	f8 06 17 30 	movlo	r6,r12
8000abae:	f7 b6 02 01 	subhs	r6,1
8000abb2:	e0 46 00 20 	cp.w	r6,32
8000abb6:	c0 d4       	brge	8000abd0 <__avr32_f64_mul_op1_subnormal+0x36>
8000abb8:	ec 0c 11 20 	rsub	r12,r6,32
8000abbc:	f6 06 09 4b 	lsl	r11,r11,r6
8000abc0:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000abc4:	18 4b       	or	r11,r12
8000abc6:	f4 06 09 4a 	lsl	r10,r10,r6
8000abca:	20 b6       	sub	r6,11
8000abcc:	0c 17       	sub	r7,r6
8000abce:	ca ab       	rjmp	8000ab22 <__avr32_f64_mul+0x22>
8000abd0:	f4 06 09 4b 	lsl	r11,r10,r6
8000abd4:	c6 40       	breq	8000ac9c <__avr32_f64_mul_res_zero>
8000abd6:	30 0a       	mov	r10,0
8000abd8:	20 b6       	sub	r6,11
8000abda:	0c 17       	sub	r7,r6
8000abdc:	ca 3b       	rjmp	8000ab22 <__avr32_f64_mul+0x22>

8000abde <__avr32_f64_mul_op2_subnormal>:
8000abde:	e4 19 00 0f 	andh	r9,0xf
8000abe2:	f0 0c 12 00 	clz	r12,r8
8000abe6:	f2 05 12 00 	clz	r5,r9
8000abea:	f7 bc 03 ea 	sublo	r12,-22
8000abee:	f8 05 17 30 	movlo	r5,r12
8000abf2:	f7 b5 02 0a 	subhs	r5,10
8000abf6:	e0 45 00 20 	cp.w	r5,32
8000abfa:	c0 d4       	brge	8000ac14 <__avr32_f64_mul_op2_subnormal+0x36>
8000abfc:	ea 0c 11 20 	rsub	r12,r5,32
8000ac00:	f2 05 09 49 	lsl	r9,r9,r5
8000ac04:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000ac08:	18 49       	or	r9,r12
8000ac0a:	f0 05 09 48 	lsl	r8,r8,r5
8000ac0e:	20 25       	sub	r5,2
8000ac10:	0a 16       	sub	r6,r5
8000ac12:	c8 fb       	rjmp	8000ab30 <__avr32_f64_mul+0x30>
8000ac14:	f0 05 09 49 	lsl	r9,r8,r5
8000ac18:	c4 20       	breq	8000ac9c <__avr32_f64_mul_res_zero>
8000ac1a:	30 08       	mov	r8,0
8000ac1c:	20 25       	sub	r5,2
8000ac1e:	0a 16       	sub	r6,r5
8000ac20:	c8 8b       	rjmp	8000ab30 <__avr32_f64_mul+0x30>

8000ac22 <__avr32_f64_mul_op_nan_or_inf>:
8000ac22:	e4 19 00 0f 	andh	r9,0xf
8000ac26:	e4 1b 00 0f 	andh	r11,0xf
8000ac2a:	14 4b       	or	r11,r10
8000ac2c:	10 49       	or	r9,r8
8000ac2e:	e0 47 07 ff 	cp.w	r7,2047
8000ac32:	c0 91       	brne	8000ac44 <__avr32_f64_mul_op1_not_naninf>
8000ac34:	58 0b       	cp.w	r11,0
8000ac36:	c3 81       	brne	8000aca6 <__avr32_f64_mul_res_nan>
8000ac38:	e0 46 07 ff 	cp.w	r6,2047
8000ac3c:	c3 81       	brne	8000acac <__avr32_f64_mul_res_inf>
8000ac3e:	58 09       	cp.w	r9,0
8000ac40:	c3 60       	breq	8000acac <__avr32_f64_mul_res_inf>
8000ac42:	c3 28       	rjmp	8000aca6 <__avr32_f64_mul_res_nan>

8000ac44 <__avr32_f64_mul_op1_not_naninf>:
8000ac44:	58 09       	cp.w	r9,0
8000ac46:	c3 30       	breq	8000acac <__avr32_f64_mul_res_inf>
8000ac48:	c2 f8       	rjmp	8000aca6 <__avr32_f64_mul_res_nan>

8000ac4a <__avr32_f64_mul_res_subnormal>:
8000ac4a:	5c 3c       	neg	r12
8000ac4c:	2f fc       	sub	r12,-1
8000ac4e:	f1 bc 04 c0 	satu	r12,0x6
8000ac52:	e0 4c 00 20 	cp.w	r12,32
8000ac56:	c1 14       	brge	8000ac78 <__avr32_f64_mul_res_subnormal+0x2e>
8000ac58:	f8 08 11 20 	rsub	r8,r12,32
8000ac5c:	0e 46       	or	r6,r7
8000ac5e:	ee 0c 0a 47 	lsr	r7,r7,r12
8000ac62:	f4 08 09 49 	lsl	r9,r10,r8
8000ac66:	12 47       	or	r7,r9
8000ac68:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ac6c:	f6 08 09 49 	lsl	r9,r11,r8
8000ac70:	12 4a       	or	r10,r9
8000ac72:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000ac76:	c8 3b       	rjmp	8000ab7c <__avr32_f64_mul+0x7c>
8000ac78:	f8 08 11 20 	rsub	r8,r12,32
8000ac7c:	f9 b9 00 00 	moveq	r9,0
8000ac80:	c0 30       	breq	8000ac86 <__avr32_f64_mul_res_subnormal+0x3c>
8000ac82:	f6 08 09 49 	lsl	r9,r11,r8
8000ac86:	0e 46       	or	r6,r7
8000ac88:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000ac8c:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000ac90:	f3 ea 10 07 	or	r7,r9,r10
8000ac94:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000ac98:	30 0b       	mov	r11,0
8000ac9a:	c7 1b       	rjmp	8000ab7c <__avr32_f64_mul+0x7c>

8000ac9c <__avr32_f64_mul_res_zero>:
8000ac9c:	1c 9b       	mov	r11,lr
8000ac9e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000aca2:	30 0a       	mov	r10,0
8000aca4:	d8 22       	popm	r4-r7,pc

8000aca6 <__avr32_f64_mul_res_nan>:
8000aca6:	3f fb       	mov	r11,-1
8000aca8:	3f fa       	mov	r10,-1
8000acaa:	d8 22       	popm	r4-r7,pc

8000acac <__avr32_f64_mul_res_inf>:
8000acac:	f0 6b 00 00 	mov	r11,-1048576
8000acb0:	ed be 00 1f 	bld	lr,0x1f
8000acb4:	ef bb 00 1f 	bst	r11,0x1f
8000acb8:	30 0a       	mov	r10,0
8000acba:	d8 22       	popm	r4-r7,pc

8000acbc <__avr32_f64_mul_op1_zero>:
8000acbc:	f7 e9 20 0b 	eor	r11,r11,r9
8000acc0:	e6 1b 80 00 	andh	r11,0x8000,COH
8000acc4:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000acc8:	e0 4c 07 ff 	cp.w	r12,2047
8000accc:	5e 1c       	retne	r12
8000acce:	3f fa       	mov	r10,-1
8000acd0:	3f fb       	mov	r11,-1
8000acd2:	5e fc       	retal	r12

8000acd4 <__avr32_f64_sub_from_add>:
8000acd4:	ee 19 80 00 	eorh	r9,0x8000

8000acd8 <__avr32_f64_sub>:
8000acd8:	f7 e9 20 0c 	eor	r12,r11,r9
8000acdc:	e0 86 00 ca 	brmi	8000ae70 <__avr32_f64_add_from_sub>
8000ace0:	eb cd 40 e0 	pushm	r5-r7,lr
8000ace4:	16 9c       	mov	r12,r11
8000ace6:	e6 1c 80 00 	andh	r12,0x8000,COH
8000acea:	bf db       	cbr	r11,0x1f
8000acec:	bf d9       	cbr	r9,0x1f
8000acee:	10 3a       	cp.w	r10,r8
8000acf0:	f2 0b 13 00 	cpc	r11,r9
8000acf4:	c0 92       	brcc	8000ad06 <__avr32_f64_sub+0x2e>
8000acf6:	16 97       	mov	r7,r11
8000acf8:	12 9b       	mov	r11,r9
8000acfa:	0e 99       	mov	r9,r7
8000acfc:	14 97       	mov	r7,r10
8000acfe:	10 9a       	mov	r10,r8
8000ad00:	0e 98       	mov	r8,r7
8000ad02:	ee 1c 80 00 	eorh	r12,0x8000
8000ad06:	f6 07 16 14 	lsr	r7,r11,0x14
8000ad0a:	ab 7b       	lsl	r11,0xb
8000ad0c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000ad10:	ab 7a       	lsl	r10,0xb
8000ad12:	bf bb       	sbr	r11,0x1f
8000ad14:	f2 06 16 14 	lsr	r6,r9,0x14
8000ad18:	c4 40       	breq	8000ada0 <__avr32_f64_sub_opL_subnormal>
8000ad1a:	ab 79       	lsl	r9,0xb
8000ad1c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ad20:	ab 78       	lsl	r8,0xb
8000ad22:	bf b9       	sbr	r9,0x1f

8000ad24 <__avr32_f64_sub_opL_subnormal_done>:
8000ad24:	e0 47 07 ff 	cp.w	r7,2047
8000ad28:	c4 f0       	breq	8000adc6 <__avr32_f64_sub_opH_nan_or_inf>
8000ad2a:	0e 26       	rsub	r6,r7
8000ad2c:	c1 20       	breq	8000ad50 <__avr32_f64_sub_shift_done>
8000ad2e:	ec 05 11 20 	rsub	r5,r6,32
8000ad32:	e0 46 00 20 	cp.w	r6,32
8000ad36:	c7 c2       	brcc	8000ae2e <__avr32_f64_sub_longshift>
8000ad38:	f0 05 09 4e 	lsl	lr,r8,r5
8000ad3c:	f2 05 09 45 	lsl	r5,r9,r5
8000ad40:	f0 06 0a 48 	lsr	r8,r8,r6
8000ad44:	f2 06 0a 49 	lsr	r9,r9,r6
8000ad48:	0a 48       	or	r8,r5
8000ad4a:	58 0e       	cp.w	lr,0
8000ad4c:	5f 1e       	srne	lr
8000ad4e:	1c 48       	or	r8,lr

8000ad50 <__avr32_f64_sub_shift_done>:
8000ad50:	10 1a       	sub	r10,r8
8000ad52:	f6 09 01 4b 	sbc	r11,r11,r9
8000ad56:	f6 06 12 00 	clz	r6,r11
8000ad5a:	c0 e0       	breq	8000ad76 <__avr32_f64_sub_longnormalize_done>
8000ad5c:	c7 83       	brcs	8000ae4c <__avr32_f64_sub_longnormalize>
8000ad5e:	ec 0e 11 20 	rsub	lr,r6,32
8000ad62:	f6 06 09 4b 	lsl	r11,r11,r6
8000ad66:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000ad6a:	1c 4b       	or	r11,lr
8000ad6c:	f4 06 09 4a 	lsl	r10,r10,r6
8000ad70:	0c 17       	sub	r7,r6
8000ad72:	e0 8a 00 39 	brle	8000ade4 <__avr32_f64_sub_subnormal_result>

8000ad76 <__avr32_f64_sub_longnormalize_done>:
8000ad76:	f4 09 15 15 	lsl	r9,r10,0x15
8000ad7a:	ab 9a       	lsr	r10,0xb
8000ad7c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000ad80:	ab 9b       	lsr	r11,0xb
8000ad82:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000ad86:	18 4b       	or	r11,r12

8000ad88 <__avr32_f64_sub_round>:
8000ad88:	fc 17 80 00 	movh	r7,0x8000
8000ad8c:	ed ba 00 00 	bld	r10,0x0
8000ad90:	f7 b7 01 ff 	subne	r7,-1
8000ad94:	0e 39       	cp.w	r9,r7
8000ad96:	5f 29       	srhs	r9
8000ad98:	12 0a       	add	r10,r9
8000ad9a:	5c 0b       	acr	r11
8000ad9c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ada0 <__avr32_f64_sub_opL_subnormal>:
8000ada0:	ab 79       	lsl	r9,0xb
8000ada2:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000ada6:	ab 78       	lsl	r8,0xb
8000ada8:	f3 e8 10 0e 	or	lr,r9,r8
8000adac:	f9 b6 01 01 	movne	r6,1
8000adb0:	ee 0e 11 00 	rsub	lr,r7,0
8000adb4:	f9 b7 00 01 	moveq	r7,1
8000adb8:	ef bb 00 1f 	bst	r11,0x1f
8000adbc:	f7 ea 10 0e 	or	lr,r11,r10
8000adc0:	f9 b7 00 00 	moveq	r7,0
8000adc4:	cb 0b       	rjmp	8000ad24 <__avr32_f64_sub_opL_subnormal_done>

8000adc6 <__avr32_f64_sub_opH_nan_or_inf>:
8000adc6:	bf db       	cbr	r11,0x1f
8000adc8:	f7 ea 10 0e 	or	lr,r11,r10
8000adcc:	c0 81       	brne	8000addc <__avr32_f64_sub_return_nan>
8000adce:	e0 46 07 ff 	cp.w	r6,2047
8000add2:	c0 50       	breq	8000addc <__avr32_f64_sub_return_nan>
8000add4:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000add8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000addc <__avr32_f64_sub_return_nan>:
8000addc:	3f fa       	mov	r10,-1
8000adde:	3f fb       	mov	r11,-1
8000ade0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ade4 <__avr32_f64_sub_subnormal_result>:
8000ade4:	5c 37       	neg	r7
8000ade6:	2f f7       	sub	r7,-1
8000ade8:	f1 b7 04 c0 	satu	r7,0x6
8000adec:	e0 47 00 20 	cp.w	r7,32
8000adf0:	c1 14       	brge	8000ae12 <__avr32_f64_sub_subnormal_result+0x2e>
8000adf2:	ee 08 11 20 	rsub	r8,r7,32
8000adf6:	f4 08 09 49 	lsl	r9,r10,r8
8000adfa:	5f 16       	srne	r6
8000adfc:	f4 07 0a 4a 	lsr	r10,r10,r7
8000ae00:	0c 4a       	or	r10,r6
8000ae02:	f6 08 09 49 	lsl	r9,r11,r8
8000ae06:	f5 e9 10 0a 	or	r10,r10,r9
8000ae0a:	f4 07 0a 4b 	lsr	r11,r10,r7
8000ae0e:	30 07       	mov	r7,0
8000ae10:	cb 3b       	rjmp	8000ad76 <__avr32_f64_sub_longnormalize_done>
8000ae12:	ee 08 11 40 	rsub	r8,r7,64
8000ae16:	f6 08 09 49 	lsl	r9,r11,r8
8000ae1a:	14 49       	or	r9,r10
8000ae1c:	5f 16       	srne	r6
8000ae1e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000ae22:	0c 4a       	or	r10,r6
8000ae24:	30 0b       	mov	r11,0
8000ae26:	30 07       	mov	r7,0
8000ae28:	ca 7b       	rjmp	8000ad76 <__avr32_f64_sub_longnormalize_done>
8000ae2a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000ae2e <__avr32_f64_sub_longshift>:
8000ae2e:	f1 b6 04 c0 	satu	r6,0x6
8000ae32:	f0 0e 17 00 	moveq	lr,r8
8000ae36:	c0 40       	breq	8000ae3e <__avr32_f64_sub_longshift+0x10>
8000ae38:	f2 05 09 4e 	lsl	lr,r9,r5
8000ae3c:	10 4e       	or	lr,r8
8000ae3e:	f2 06 0a 48 	lsr	r8,r9,r6
8000ae42:	30 09       	mov	r9,0
8000ae44:	58 0e       	cp.w	lr,0
8000ae46:	5f 1e       	srne	lr
8000ae48:	1c 48       	or	r8,lr
8000ae4a:	c8 3b       	rjmp	8000ad50 <__avr32_f64_sub_shift_done>

8000ae4c <__avr32_f64_sub_longnormalize>:
8000ae4c:	f4 06 12 00 	clz	r6,r10
8000ae50:	f9 b7 03 00 	movlo	r7,0
8000ae54:	f9 b6 03 00 	movlo	r6,0
8000ae58:	f9 bc 03 00 	movlo	r12,0
8000ae5c:	f7 b6 02 e0 	subhs	r6,-32
8000ae60:	f4 06 09 4b 	lsl	r11,r10,r6
8000ae64:	30 0a       	mov	r10,0
8000ae66:	0c 17       	sub	r7,r6
8000ae68:	fe 9a ff be 	brle	8000ade4 <__avr32_f64_sub_subnormal_result>
8000ae6c:	c8 5b       	rjmp	8000ad76 <__avr32_f64_sub_longnormalize_done>
8000ae6e:	d7 03       	nop

8000ae70 <__avr32_f64_add_from_sub>:
8000ae70:	ee 19 80 00 	eorh	r9,0x8000

8000ae74 <__avr32_f64_add>:
8000ae74:	f7 e9 20 0c 	eor	r12,r11,r9
8000ae78:	fe 96 ff 2e 	brmi	8000acd4 <__avr32_f64_sub_from_add>
8000ae7c:	eb cd 40 e0 	pushm	r5-r7,lr
8000ae80:	16 9c       	mov	r12,r11
8000ae82:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ae86:	bf db       	cbr	r11,0x1f
8000ae88:	bf d9       	cbr	r9,0x1f
8000ae8a:	12 3b       	cp.w	r11,r9
8000ae8c:	c0 72       	brcc	8000ae9a <__avr32_f64_add+0x26>
8000ae8e:	16 97       	mov	r7,r11
8000ae90:	12 9b       	mov	r11,r9
8000ae92:	0e 99       	mov	r9,r7
8000ae94:	14 97       	mov	r7,r10
8000ae96:	10 9a       	mov	r10,r8
8000ae98:	0e 98       	mov	r8,r7
8000ae9a:	30 0e       	mov	lr,0
8000ae9c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000aea0:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000aea4:	b5 ab       	sbr	r11,0x14
8000aea6:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000aeaa:	c6 20       	breq	8000af6e <__avr32_f64_add_op2_subnormal>
8000aeac:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000aeb0:	b5 a9       	sbr	r9,0x14
8000aeb2:	e0 47 07 ff 	cp.w	r7,2047
8000aeb6:	c2 80       	breq	8000af06 <__avr32_f64_add_opH_nan_or_inf>
8000aeb8:	0e 26       	rsub	r6,r7
8000aeba:	c1 20       	breq	8000aede <__avr32_f64_add_shift_done>
8000aebc:	e0 46 00 36 	cp.w	r6,54
8000aec0:	c1 52       	brcc	8000aeea <__avr32_f64_add_res_of_done>
8000aec2:	ec 05 11 20 	rsub	r5,r6,32
8000aec6:	e0 46 00 20 	cp.w	r6,32
8000aeca:	c3 52       	brcc	8000af34 <__avr32_f64_add_longshift>
8000aecc:	f0 05 09 4e 	lsl	lr,r8,r5
8000aed0:	f2 05 09 45 	lsl	r5,r9,r5
8000aed4:	f0 06 0a 48 	lsr	r8,r8,r6
8000aed8:	f2 06 0a 49 	lsr	r9,r9,r6
8000aedc:	0a 48       	or	r8,r5

8000aede <__avr32_f64_add_shift_done>:
8000aede:	10 0a       	add	r10,r8
8000aee0:	f6 09 00 4b 	adc	r11,r11,r9
8000aee4:	ed bb 00 15 	bld	r11,0x15
8000aee8:	c3 40       	breq	8000af50 <__avr32_f64_add_res_of>

8000aeea <__avr32_f64_add_res_of_done>:
8000aeea:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000aeee:	18 4b       	or	r11,r12

8000aef0 <__avr32_f64_add_round>:
8000aef0:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000aef4:	18 4e       	or	lr,r12
8000aef6:	ee 1e 80 00 	eorh	lr,0x8000
8000aefa:	f1 be 04 20 	satu	lr,0x1
8000aefe:	1c 0a       	add	r10,lr
8000af00:	5c 0b       	acr	r11
8000af02:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af06 <__avr32_f64_add_opH_nan_or_inf>:
8000af06:	b5 cb       	cbr	r11,0x14
8000af08:	f7 ea 10 0e 	or	lr,r11,r10
8000af0c:	c1 01       	brne	8000af2c <__avr32_f64_add_return_nan>
8000af0e:	e0 46 07 ff 	cp.w	r6,2047
8000af12:	c0 30       	breq	8000af18 <__avr32_f64_add_opL_nan_or_inf>
8000af14:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af18 <__avr32_f64_add_opL_nan_or_inf>:
8000af18:	b5 c9       	cbr	r9,0x14
8000af1a:	f3 e8 10 0e 	or	lr,r9,r8
8000af1e:	c0 71       	brne	8000af2c <__avr32_f64_add_return_nan>
8000af20:	30 0a       	mov	r10,0
8000af22:	fc 1b 7f f0 	movh	r11,0x7ff0
8000af26:	18 4b       	or	r11,r12
8000af28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af2c <__avr32_f64_add_return_nan>:
8000af2c:	3f fa       	mov	r10,-1
8000af2e:	3f fb       	mov	r11,-1
8000af30:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000af34 <__avr32_f64_add_longshift>:
8000af34:	f1 b6 04 c0 	satu	r6,0x6
8000af38:	f0 0e 17 00 	moveq	lr,r8
8000af3c:	c0 60       	breq	8000af48 <__avr32_f64_add_longshift+0x14>
8000af3e:	f2 05 09 4e 	lsl	lr,r9,r5
8000af42:	58 08       	cp.w	r8,0
8000af44:	5f 18       	srne	r8
8000af46:	10 4e       	or	lr,r8
8000af48:	f2 06 0a 48 	lsr	r8,r9,r6
8000af4c:	30 09       	mov	r9,0
8000af4e:	cc 8b       	rjmp	8000aede <__avr32_f64_add_shift_done>

8000af50 <__avr32_f64_add_res_of>:
8000af50:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000af54:	a1 9b       	lsr	r11,0x1
8000af56:	5d 0a       	ror	r10
8000af58:	5d 0e       	ror	lr
8000af5a:	2f f7       	sub	r7,-1
8000af5c:	e0 47 07 ff 	cp.w	r7,2047
8000af60:	f9 ba 00 00 	moveq	r10,0
8000af64:	f9 bb 00 00 	moveq	r11,0
8000af68:	f9 be 00 00 	moveq	lr,0
8000af6c:	cb fb       	rjmp	8000aeea <__avr32_f64_add_res_of_done>

8000af6e <__avr32_f64_add_op2_subnormal>:
8000af6e:	30 16       	mov	r6,1
8000af70:	58 07       	cp.w	r7,0
8000af72:	ca 01       	brne	8000aeb2 <__avr32_f64_add+0x3e>
8000af74:	b5 cb       	cbr	r11,0x14
8000af76:	10 0a       	add	r10,r8
8000af78:	f6 09 00 4b 	adc	r11,r11,r9
8000af7c:	18 4b       	or	r11,r12
8000af7e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000af82:	d7 03       	nop

8000af84 <__avr32_f64_to_u32>:
8000af84:	58 0b       	cp.w	r11,0
8000af86:	5e 6d       	retmi	0

8000af88 <__avr32_f64_to_s32>:
8000af88:	f6 0c 15 01 	lsl	r12,r11,0x1
8000af8c:	b5 9c       	lsr	r12,0x15
8000af8e:	e0 2c 03 ff 	sub	r12,1023
8000af92:	5e 3d       	retlo	0
8000af94:	f8 0c 11 1f 	rsub	r12,r12,31
8000af98:	16 99       	mov	r9,r11
8000af9a:	ab 7b       	lsl	r11,0xb
8000af9c:	bf bb       	sbr	r11,0x1f
8000af9e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000afa2:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000afa6:	a1 79       	lsl	r9,0x1
8000afa8:	5e 2b       	reths	r11
8000afaa:	5c 3b       	neg	r11
8000afac:	5e fb       	retal	r11

8000afae <__avr32_u32_to_f64>:
8000afae:	f8 cb 00 00 	sub	r11,r12,0
8000afb2:	30 0c       	mov	r12,0
8000afb4:	c0 38       	rjmp	8000afba <__avr32_s32_to_f64+0x4>

8000afb6 <__avr32_s32_to_f64>:
8000afb6:	18 9b       	mov	r11,r12
8000afb8:	5c 4b       	abs	r11
8000afba:	30 0a       	mov	r10,0
8000afbc:	5e 0b       	reteq	r11
8000afbe:	d4 01       	pushm	lr
8000afc0:	e0 69 04 1e 	mov	r9,1054
8000afc4:	f6 08 12 00 	clz	r8,r11
8000afc8:	c1 70       	breq	8000aff6 <__avr32_s32_to_f64+0x40>
8000afca:	c0 c3       	brcs	8000afe2 <__avr32_s32_to_f64+0x2c>
8000afcc:	f0 0e 11 20 	rsub	lr,r8,32
8000afd0:	f6 08 09 4b 	lsl	r11,r11,r8
8000afd4:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000afd8:	1c 4b       	or	r11,lr
8000afda:	f4 08 09 4a 	lsl	r10,r10,r8
8000afde:	10 19       	sub	r9,r8
8000afe0:	c0 b8       	rjmp	8000aff6 <__avr32_s32_to_f64+0x40>
8000afe2:	f4 08 12 00 	clz	r8,r10
8000afe6:	f9 b8 03 00 	movlo	r8,0
8000afea:	f7 b8 02 e0 	subhs	r8,-32
8000afee:	f4 08 09 4b 	lsl	r11,r10,r8
8000aff2:	30 0a       	mov	r10,0
8000aff4:	10 19       	sub	r9,r8
8000aff6:	58 09       	cp.w	r9,0
8000aff8:	e0 89 00 30 	brgt	8000b058 <__avr32_s32_to_f64+0xa2>
8000affc:	5c 39       	neg	r9
8000affe:	2f f9       	sub	r9,-1
8000b000:	e0 49 00 36 	cp.w	r9,54
8000b004:	c0 43       	brcs	8000b00c <__avr32_s32_to_f64+0x56>
8000b006:	30 0b       	mov	r11,0
8000b008:	30 0a       	mov	r10,0
8000b00a:	c2 68       	rjmp	8000b056 <__avr32_s32_to_f64+0xa0>
8000b00c:	2f 69       	sub	r9,-10
8000b00e:	f2 08 11 20 	rsub	r8,r9,32
8000b012:	e0 49 00 20 	cp.w	r9,32
8000b016:	c0 b2       	brcc	8000b02c <__avr32_s32_to_f64+0x76>
8000b018:	f4 08 09 4e 	lsl	lr,r10,r8
8000b01c:	f6 08 09 48 	lsl	r8,r11,r8
8000b020:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b024:	f6 09 0a 4b 	lsr	r11,r11,r9
8000b028:	10 4b       	or	r11,r8
8000b02a:	c0 88       	rjmp	8000b03a <__avr32_s32_to_f64+0x84>
8000b02c:	f6 08 09 4e 	lsl	lr,r11,r8
8000b030:	14 4e       	or	lr,r10
8000b032:	16 9a       	mov	r10,r11
8000b034:	30 0b       	mov	r11,0
8000b036:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b03a:	ed ba 00 00 	bld	r10,0x0
8000b03e:	c0 92       	brcc	8000b050 <__avr32_s32_to_f64+0x9a>
8000b040:	1c 7e       	tst	lr,lr
8000b042:	c0 41       	brne	8000b04a <__avr32_s32_to_f64+0x94>
8000b044:	ed ba 00 01 	bld	r10,0x1
8000b048:	c0 42       	brcc	8000b050 <__avr32_s32_to_f64+0x9a>
8000b04a:	2f fa       	sub	r10,-1
8000b04c:	f7 bb 02 ff 	subhs	r11,-1
8000b050:	5c fc       	rol	r12
8000b052:	5d 0b       	ror	r11
8000b054:	5d 0a       	ror	r10
8000b056:	d8 02       	popm	pc
8000b058:	e0 68 03 ff 	mov	r8,1023
8000b05c:	ed ba 00 0b 	bld	r10,0xb
8000b060:	f7 b8 00 ff 	subeq	r8,-1
8000b064:	10 0a       	add	r10,r8
8000b066:	5c 0b       	acr	r11
8000b068:	f7 b9 03 fe 	sublo	r9,-2
8000b06c:	e0 49 07 ff 	cp.w	r9,2047
8000b070:	c0 55       	brlt	8000b07a <__avr32_s32_to_f64+0xc4>
8000b072:	30 0a       	mov	r10,0
8000b074:	fc 1b ff e0 	movh	r11,0xffe0
8000b078:	c0 c8       	rjmp	8000b090 <__floatsidf_return_op1>
8000b07a:	ed bb 00 1f 	bld	r11,0x1f
8000b07e:	f7 b9 01 01 	subne	r9,1
8000b082:	ab 9a       	lsr	r10,0xb
8000b084:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000b088:	a1 7b       	lsl	r11,0x1
8000b08a:	ab 9b       	lsr	r11,0xb
8000b08c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000b090 <__floatsidf_return_op1>:
8000b090:	a1 7c       	lsl	r12,0x1
8000b092:	5d 0b       	ror	r11
8000b094:	d8 02       	popm	pc

8000b096 <__avr32_f64_cmp_eq>:
8000b096:	10 3a       	cp.w	r10,r8
8000b098:	f2 0b 13 00 	cpc	r11,r9
8000b09c:	c0 80       	breq	8000b0ac <__avr32_f64_cmp_eq+0x16>
8000b09e:	a1 7b       	lsl	r11,0x1
8000b0a0:	a1 79       	lsl	r9,0x1
8000b0a2:	14 4b       	or	r11,r10
8000b0a4:	12 4b       	or	r11,r9
8000b0a6:	10 4b       	or	r11,r8
8000b0a8:	5e 0f       	reteq	1
8000b0aa:	5e fd       	retal	0
8000b0ac:	a1 7b       	lsl	r11,0x1
8000b0ae:	fc 1c ff e0 	movh	r12,0xffe0
8000b0b2:	58 0a       	cp.w	r10,0
8000b0b4:	f8 0b 13 00 	cpc	r11,r12
8000b0b8:	5e 8f       	retls	1
8000b0ba:	5e fd       	retal	0

8000b0bc <__avr32_f64_cmp_ge>:
8000b0bc:	1a de       	st.w	--sp,lr
8000b0be:	1a d7       	st.w	--sp,r7
8000b0c0:	a1 7b       	lsl	r11,0x1
8000b0c2:	5f 3c       	srlo	r12
8000b0c4:	a1 79       	lsl	r9,0x1
8000b0c6:	5f 37       	srlo	r7
8000b0c8:	5c fc       	rol	r12
8000b0ca:	fc 1e ff e0 	movh	lr,0xffe0
8000b0ce:	58 0a       	cp.w	r10,0
8000b0d0:	fc 0b 13 00 	cpc	r11,lr
8000b0d4:	e0 8b 00 1d 	brhi	8000b10e <__avr32_f64_cmp_ge+0x52>
8000b0d8:	58 08       	cp.w	r8,0
8000b0da:	fc 09 13 00 	cpc	r9,lr
8000b0de:	e0 8b 00 18 	brhi	8000b10e <__avr32_f64_cmp_ge+0x52>
8000b0e2:	58 0b       	cp.w	r11,0
8000b0e4:	f5 ba 00 00 	subfeq	r10,0
8000b0e8:	c1 50       	breq	8000b112 <__avr32_f64_cmp_ge+0x56>
8000b0ea:	1b 07       	ld.w	r7,sp++
8000b0ec:	1b 0e       	ld.w	lr,sp++
8000b0ee:	58 3c       	cp.w	r12,3
8000b0f0:	c0 a0       	breq	8000b104 <__avr32_f64_cmp_ge+0x48>
8000b0f2:	58 1c       	cp.w	r12,1
8000b0f4:	c0 33       	brcs	8000b0fa <__avr32_f64_cmp_ge+0x3e>
8000b0f6:	5e 0f       	reteq	1
8000b0f8:	5e 1d       	retne	0
8000b0fa:	10 3a       	cp.w	r10,r8
8000b0fc:	f2 0b 13 00 	cpc	r11,r9
8000b100:	5e 2f       	reths	1
8000b102:	5e 3d       	retlo	0
8000b104:	14 38       	cp.w	r8,r10
8000b106:	f6 09 13 00 	cpc	r9,r11
8000b10a:	5e 2f       	reths	1
8000b10c:	5e 3d       	retlo	0
8000b10e:	1b 07       	ld.w	r7,sp++
8000b110:	d8 0a       	popm	pc,r12=0
8000b112:	58 17       	cp.w	r7,1
8000b114:	5f 0c       	sreq	r12
8000b116:	58 09       	cp.w	r9,0
8000b118:	f5 b8 00 00 	subfeq	r8,0
8000b11c:	1b 07       	ld.w	r7,sp++
8000b11e:	1b 0e       	ld.w	lr,sp++
8000b120:	5e 0f       	reteq	1
8000b122:	5e fc       	retal	r12

8000b124 <__avr32_f64_cmp_lt>:
8000b124:	1a de       	st.w	--sp,lr
8000b126:	1a d7       	st.w	--sp,r7
8000b128:	a1 7b       	lsl	r11,0x1
8000b12a:	5f 3c       	srlo	r12
8000b12c:	a1 79       	lsl	r9,0x1
8000b12e:	5f 37       	srlo	r7
8000b130:	5c fc       	rol	r12
8000b132:	fc 1e ff e0 	movh	lr,0xffe0
8000b136:	58 0a       	cp.w	r10,0
8000b138:	fc 0b 13 00 	cpc	r11,lr
8000b13c:	e0 8b 00 1d 	brhi	8000b176 <__avr32_f64_cmp_lt+0x52>
8000b140:	58 08       	cp.w	r8,0
8000b142:	fc 09 13 00 	cpc	r9,lr
8000b146:	e0 8b 00 18 	brhi	8000b176 <__avr32_f64_cmp_lt+0x52>
8000b14a:	58 0b       	cp.w	r11,0
8000b14c:	f5 ba 00 00 	subfeq	r10,0
8000b150:	c1 50       	breq	8000b17a <__avr32_f64_cmp_lt+0x56>
8000b152:	1b 07       	ld.w	r7,sp++
8000b154:	1b 0e       	ld.w	lr,sp++
8000b156:	58 3c       	cp.w	r12,3
8000b158:	c0 a0       	breq	8000b16c <__avr32_f64_cmp_lt+0x48>
8000b15a:	58 1c       	cp.w	r12,1
8000b15c:	c0 33       	brcs	8000b162 <__avr32_f64_cmp_lt+0x3e>
8000b15e:	5e 0d       	reteq	0
8000b160:	5e 1f       	retne	1
8000b162:	10 3a       	cp.w	r10,r8
8000b164:	f2 0b 13 00 	cpc	r11,r9
8000b168:	5e 2d       	reths	0
8000b16a:	5e 3f       	retlo	1
8000b16c:	14 38       	cp.w	r8,r10
8000b16e:	f6 09 13 00 	cpc	r9,r11
8000b172:	5e 2d       	reths	0
8000b174:	5e 3f       	retlo	1
8000b176:	1b 07       	ld.w	r7,sp++
8000b178:	d8 0a       	popm	pc,r12=0
8000b17a:	58 17       	cp.w	r7,1
8000b17c:	5f 1c       	srne	r12
8000b17e:	58 09       	cp.w	r9,0
8000b180:	f5 b8 00 00 	subfeq	r8,0
8000b184:	1b 07       	ld.w	r7,sp++
8000b186:	1b 0e       	ld.w	lr,sp++
8000b188:	5e 0d       	reteq	0
8000b18a:	5e fc       	retal	r12

8000b18c <__avr32_f64_div>:
8000b18c:	eb cd 40 ff 	pushm	r0-r7,lr
8000b190:	f7 e9 20 0e 	eor	lr,r11,r9
8000b194:	f6 07 16 14 	lsr	r7,r11,0x14
8000b198:	a9 7b       	lsl	r11,0x9
8000b19a:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000b19e:	a9 7a       	lsl	r10,0x9
8000b1a0:	bd bb       	sbr	r11,0x1d
8000b1a2:	e4 1b 3f ff 	andh	r11,0x3fff
8000b1a6:	ab d7       	cbr	r7,0xb
8000b1a8:	e0 80 00 cc 	breq	8000b340 <__avr32_f64_div_round_subnormal+0x54>
8000b1ac:	e0 47 07 ff 	cp.w	r7,2047
8000b1b0:	e0 84 00 b5 	brge	8000b31a <__avr32_f64_div_round_subnormal+0x2e>
8000b1b4:	f2 06 16 14 	lsr	r6,r9,0x14
8000b1b8:	a9 79       	lsl	r9,0x9
8000b1ba:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000b1be:	a9 78       	lsl	r8,0x9
8000b1c0:	bd b9       	sbr	r9,0x1d
8000b1c2:	e4 19 3f ff 	andh	r9,0x3fff
8000b1c6:	ab d6       	cbr	r6,0xb
8000b1c8:	e0 80 00 e2 	breq	8000b38c <__avr32_f64_div_round_subnormal+0xa0>
8000b1cc:	e0 46 07 ff 	cp.w	r6,2047
8000b1d0:	e0 84 00 b2 	brge	8000b334 <__avr32_f64_div_round_subnormal+0x48>
8000b1d4:	0c 17       	sub	r7,r6
8000b1d6:	fe 37 fc 01 	sub	r7,-1023
8000b1da:	fc 1c 80 00 	movh	r12,0x8000
8000b1de:	f8 03 16 01 	lsr	r3,r12,0x1
8000b1e2:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000b1e6:	5c d4       	com	r4
8000b1e8:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000b1ec:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b1f0:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b1f4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b1f8:	ea 03 15 02 	lsl	r3,r5,0x2
8000b1fc:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b200:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b204:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b208:	ea 03 15 02 	lsl	r3,r5,0x2
8000b20c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b210:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000b214:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b218:	ea 03 15 02 	lsl	r3,r5,0x2
8000b21c:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b220:	e4 09 07 40 	macu.d	r0,r2,r9
8000b224:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b228:	02 04       	add	r4,r1
8000b22a:	5c 05       	acr	r5
8000b22c:	a3 65       	lsl	r5,0x2
8000b22e:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b232:	a3 64       	lsl	r4,0x2
8000b234:	5c 34       	neg	r4
8000b236:	f8 05 01 45 	sbc	r5,r12,r5
8000b23a:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b23e:	e4 05 07 40 	macu.d	r0,r2,r5
8000b242:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b246:	02 04       	add	r4,r1
8000b248:	5c 05       	acr	r5
8000b24a:	ea 03 15 02 	lsl	r3,r5,0x2
8000b24e:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b252:	e8 02 15 02 	lsl	r2,r4,0x2
8000b256:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b25a:	e4 09 07 40 	macu.d	r0,r2,r9
8000b25e:	e6 09 06 44 	mulu.d	r4,r3,r9
8000b262:	02 04       	add	r4,r1
8000b264:	5c 05       	acr	r5
8000b266:	a3 65       	lsl	r5,0x2
8000b268:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000b26c:	a3 64       	lsl	r4,0x2
8000b26e:	5c 34       	neg	r4
8000b270:	f8 05 01 45 	sbc	r5,r12,r5
8000b274:	e6 04 06 40 	mulu.d	r0,r3,r4
8000b278:	e4 05 07 40 	macu.d	r0,r2,r5
8000b27c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000b280:	02 04       	add	r4,r1
8000b282:	5c 05       	acr	r5
8000b284:	ea 03 15 02 	lsl	r3,r5,0x2
8000b288:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000b28c:	e8 02 15 02 	lsl	r2,r4,0x2
8000b290:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000b294:	e4 0b 07 40 	macu.d	r0,r2,r11
8000b298:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000b29c:	02 02       	add	r2,r1
8000b29e:	5c 03       	acr	r3
8000b2a0:	ed b3 00 1c 	bld	r3,0x1c
8000b2a4:	c0 90       	breq	8000b2b6 <__avr32_f64_div+0x12a>
8000b2a6:	a1 72       	lsl	r2,0x1
8000b2a8:	5c f3       	rol	r3
8000b2aa:	20 17       	sub	r7,1
8000b2ac:	a3 9a       	lsr	r10,0x3
8000b2ae:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000b2b2:	a3 9b       	lsr	r11,0x3
8000b2b4:	c0 58       	rjmp	8000b2be <__avr32_f64_div+0x132>
8000b2b6:	a5 8a       	lsr	r10,0x4
8000b2b8:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000b2bc:	a5 8b       	lsr	r11,0x4
8000b2be:	58 07       	cp.w	r7,0
8000b2c0:	e0 8a 00 8b 	brle	8000b3d6 <__avr32_f64_div_res_subnormal>
8000b2c4:	e0 12 ff 00 	andl	r2,0xff00
8000b2c8:	e8 12 00 80 	orl	r2,0x80
8000b2cc:	e6 08 06 40 	mulu.d	r0,r3,r8
8000b2d0:	e4 09 07 40 	macu.d	r0,r2,r9
8000b2d4:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b2d8:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b2dc:	00 05       	add	r5,r0
8000b2de:	f0 01 00 48 	adc	r8,r8,r1
8000b2e2:	5c 09       	acr	r9
8000b2e4:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b2e8:	58 04       	cp.w	r4,0
8000b2ea:	5c 25       	cpc	r5

8000b2ec <__avr32_f64_div_round_subnormal>:
8000b2ec:	f4 08 13 00 	cpc	r8,r10
8000b2f0:	f6 09 13 00 	cpc	r9,r11
8000b2f4:	5f 36       	srlo	r6
8000b2f6:	f8 06 17 00 	moveq	r6,r12
8000b2fa:	e4 0a 16 08 	lsr	r10,r2,0x8
8000b2fe:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000b302:	e6 0b 16 08 	lsr	r11,r3,0x8
8000b306:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000b30a:	ed be 00 1f 	bld	lr,0x1f
8000b30e:	ef bb 00 1f 	bst	r11,0x1f
8000b312:	0c 0a       	add	r10,r6
8000b314:	5c 0b       	acr	r11
8000b316:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b31a:	e4 1b 00 0f 	andh	r11,0xf
8000b31e:	14 4b       	or	r11,r10
8000b320:	e0 81 00 a7 	brne	8000b46e <__avr32_f64_div_res_subnormal+0x98>
8000b324:	f2 06 16 14 	lsr	r6,r9,0x14
8000b328:	ab d6       	cbr	r6,0xb
8000b32a:	e0 46 07 ff 	cp.w	r6,2047
8000b32e:	e0 81 00 a4 	brne	8000b476 <__avr32_f64_div_res_subnormal+0xa0>
8000b332:	c9 e8       	rjmp	8000b46e <__avr32_f64_div_res_subnormal+0x98>
8000b334:	e4 19 00 0f 	andh	r9,0xf
8000b338:	10 49       	or	r9,r8
8000b33a:	e0 81 00 9a 	brne	8000b46e <__avr32_f64_div_res_subnormal+0x98>
8000b33e:	c9 28       	rjmp	8000b462 <__avr32_f64_div_res_subnormal+0x8c>
8000b340:	a3 7b       	lsl	r11,0x3
8000b342:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000b346:	a3 7a       	lsl	r10,0x3
8000b348:	f5 eb 10 04 	or	r4,r10,r11
8000b34c:	e0 80 00 a0 	breq	8000b48c <__avr32_f64_div_op1_zero>
8000b350:	f6 04 12 00 	clz	r4,r11
8000b354:	c1 70       	breq	8000b382 <__avr32_f64_div_round_subnormal+0x96>
8000b356:	c0 c3       	brcs	8000b36e <__avr32_f64_div_round_subnormal+0x82>
8000b358:	e8 05 11 20 	rsub	r5,r4,32
8000b35c:	f6 04 09 4b 	lsl	r11,r11,r4
8000b360:	f4 05 0a 45 	lsr	r5,r10,r5
8000b364:	0a 4b       	or	r11,r5
8000b366:	f4 04 09 4a 	lsl	r10,r10,r4
8000b36a:	08 17       	sub	r7,r4
8000b36c:	c0 b8       	rjmp	8000b382 <__avr32_f64_div_round_subnormal+0x96>
8000b36e:	f4 04 12 00 	clz	r4,r10
8000b372:	f9 b4 03 00 	movlo	r4,0
8000b376:	f7 b4 02 e0 	subhs	r4,-32
8000b37a:	f4 04 09 4b 	lsl	r11,r10,r4
8000b37e:	30 0a       	mov	r10,0
8000b380:	08 17       	sub	r7,r4
8000b382:	a3 8a       	lsr	r10,0x2
8000b384:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000b388:	a3 8b       	lsr	r11,0x2
8000b38a:	c1 1b       	rjmp	8000b1ac <__avr32_f64_div+0x20>
8000b38c:	a3 79       	lsl	r9,0x3
8000b38e:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000b392:	a3 78       	lsl	r8,0x3
8000b394:	f3 e8 10 04 	or	r4,r9,r8
8000b398:	c6 f0       	breq	8000b476 <__avr32_f64_div_res_subnormal+0xa0>
8000b39a:	f2 04 12 00 	clz	r4,r9
8000b39e:	c1 70       	breq	8000b3cc <__avr32_f64_div_round_subnormal+0xe0>
8000b3a0:	c0 c3       	brcs	8000b3b8 <__avr32_f64_div_round_subnormal+0xcc>
8000b3a2:	e8 05 11 20 	rsub	r5,r4,32
8000b3a6:	f2 04 09 49 	lsl	r9,r9,r4
8000b3aa:	f0 05 0a 45 	lsr	r5,r8,r5
8000b3ae:	0a 49       	or	r9,r5
8000b3b0:	f0 04 09 48 	lsl	r8,r8,r4
8000b3b4:	08 16       	sub	r6,r4
8000b3b6:	c0 b8       	rjmp	8000b3cc <__avr32_f64_div_round_subnormal+0xe0>
8000b3b8:	f0 04 12 00 	clz	r4,r8
8000b3bc:	f9 b4 03 00 	movlo	r4,0
8000b3c0:	f7 b4 02 e0 	subhs	r4,-32
8000b3c4:	f0 04 09 49 	lsl	r9,r8,r4
8000b3c8:	30 08       	mov	r8,0
8000b3ca:	08 16       	sub	r6,r4
8000b3cc:	a3 88       	lsr	r8,0x2
8000b3ce:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000b3d2:	a3 89       	lsr	r9,0x2
8000b3d4:	cf ca       	rjmp	8000b1cc <__avr32_f64_div+0x40>

8000b3d6 <__avr32_f64_div_res_subnormal>:
8000b3d6:	5c 37       	neg	r7
8000b3d8:	2f f7       	sub	r7,-1
8000b3da:	f1 b7 04 c0 	satu	r7,0x6
8000b3de:	e0 47 00 20 	cp.w	r7,32
8000b3e2:	c1 54       	brge	8000b40c <__avr32_f64_div_res_subnormal+0x36>
8000b3e4:	ee 06 11 20 	rsub	r6,r7,32
8000b3e8:	e4 07 0a 42 	lsr	r2,r2,r7
8000b3ec:	e6 06 09 4c 	lsl	r12,r3,r6
8000b3f0:	18 42       	or	r2,r12
8000b3f2:	e6 07 0a 43 	lsr	r3,r3,r7
8000b3f6:	f4 06 09 41 	lsl	r1,r10,r6
8000b3fa:	f4 07 0a 4a 	lsr	r10,r10,r7
8000b3fe:	f6 06 09 4c 	lsl	r12,r11,r6
8000b402:	18 4a       	or	r10,r12
8000b404:	f6 07 0a 4b 	lsr	r11,r11,r7
8000b408:	30 00       	mov	r0,0
8000b40a:	c1 58       	rjmp	8000b434 <__avr32_f64_div_res_subnormal+0x5e>
8000b40c:	ee 06 11 20 	rsub	r6,r7,32
8000b410:	f9 b0 00 00 	moveq	r0,0
8000b414:	f9 bc 00 00 	moveq	r12,0
8000b418:	c0 50       	breq	8000b422 <__avr32_f64_div_res_subnormal+0x4c>
8000b41a:	f4 06 09 40 	lsl	r0,r10,r6
8000b41e:	f6 06 09 4c 	lsl	r12,r11,r6
8000b422:	e6 07 0a 42 	lsr	r2,r3,r7
8000b426:	30 03       	mov	r3,0
8000b428:	f4 07 0a 41 	lsr	r1,r10,r7
8000b42c:	18 41       	or	r1,r12
8000b42e:	f6 07 0a 4a 	lsr	r10,r11,r7
8000b432:	30 0b       	mov	r11,0
8000b434:	e0 12 ff 00 	andl	r2,0xff00
8000b438:	e8 12 00 80 	orl	r2,0x80
8000b43c:	e6 08 06 46 	mulu.d	r6,r3,r8
8000b440:	e4 09 07 46 	macu.d	r6,r2,r9
8000b444:	e4 08 06 44 	mulu.d	r4,r2,r8
8000b448:	e6 09 06 48 	mulu.d	r8,r3,r9
8000b44c:	0c 05       	add	r5,r6
8000b44e:	f0 07 00 48 	adc	r8,r8,r7
8000b452:	5c 09       	acr	r9
8000b454:	30 07       	mov	r7,0
8000b456:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000b45a:	00 34       	cp.w	r4,r0
8000b45c:	e2 05 13 00 	cpc	r5,r1
8000b460:	c4 6b       	rjmp	8000b2ec <__avr32_f64_div_round_subnormal>
8000b462:	1c 9b       	mov	r11,lr
8000b464:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b468:	30 0a       	mov	r10,0
8000b46a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b46e:	3f fb       	mov	r11,-1
8000b470:	30 0a       	mov	r10,0
8000b472:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000b476:	f5 eb 10 04 	or	r4,r10,r11
8000b47a:	c0 90       	breq	8000b48c <__avr32_f64_div_op1_zero>
8000b47c:	1c 9b       	mov	r11,lr
8000b47e:	e6 1b 80 00 	andh	r11,0x8000,COH
8000b482:	ea 1b 7f f0 	orh	r11,0x7ff0
8000b486:	30 0a       	mov	r10,0
8000b488:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000b48c <__avr32_f64_div_op1_zero>:
8000b48c:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000b490:	ce f0       	breq	8000b46e <__avr32_f64_div_res_subnormal+0x98>
8000b492:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000b496:	e0 44 07 ff 	cp.w	r4,2047
8000b49a:	ce 41       	brne	8000b462 <__avr32_f64_div_res_subnormal+0x8c>
8000b49c:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000b4a0:	ce 10       	breq	8000b462 <__avr32_f64_div_res_subnormal+0x8c>
8000b4a2:	ce 6b       	rjmp	8000b46e <__avr32_f64_div_res_subnormal+0x98>

8000b4a4 <__avr32_udiv64>:
8000b4a4:	d4 31       	pushm	r0-r7,lr
8000b4a6:	1a 97       	mov	r7,sp
8000b4a8:	20 3d       	sub	sp,12
8000b4aa:	10 9c       	mov	r12,r8
8000b4ac:	12 9e       	mov	lr,r9
8000b4ae:	14 93       	mov	r3,r10
8000b4b0:	58 09       	cp.w	r9,0
8000b4b2:	e0 81 00 bd 	brne	8000b62c <__avr32_udiv64+0x188>
8000b4b6:	16 38       	cp.w	r8,r11
8000b4b8:	e0 88 00 40 	brls	8000b538 <__avr32_udiv64+0x94>
8000b4bc:	f0 08 12 00 	clz	r8,r8
8000b4c0:	c0 d0       	breq	8000b4da <__avr32_udiv64+0x36>
8000b4c2:	f6 08 09 4b 	lsl	r11,r11,r8
8000b4c6:	f0 09 11 20 	rsub	r9,r8,32
8000b4ca:	f8 08 09 4c 	lsl	r12,r12,r8
8000b4ce:	f4 09 0a 49 	lsr	r9,r10,r9
8000b4d2:	f4 08 09 43 	lsl	r3,r10,r8
8000b4d6:	f3 eb 10 0b 	or	r11,r9,r11
8000b4da:	f8 0e 16 10 	lsr	lr,r12,0x10
8000b4de:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000b4e2:	f6 0e 0d 00 	divu	r0,r11,lr
8000b4e6:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b4ea:	00 99       	mov	r9,r0
8000b4ec:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b4f0:	e0 0a 02 48 	mul	r8,r0,r10
8000b4f4:	10 3b       	cp.w	r11,r8
8000b4f6:	c0 a2       	brcc	8000b50a <__avr32_udiv64+0x66>
8000b4f8:	20 19       	sub	r9,1
8000b4fa:	18 0b       	add	r11,r12
8000b4fc:	18 3b       	cp.w	r11,r12
8000b4fe:	c0 63       	brcs	8000b50a <__avr32_udiv64+0x66>
8000b500:	10 3b       	cp.w	r11,r8
8000b502:	f7 b9 03 01 	sublo	r9,1
8000b506:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b50a:	f6 08 01 01 	sub	r1,r11,r8
8000b50e:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b512:	e2 0e 0d 00 	divu	r0,r1,lr
8000b516:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b51a:	00 98       	mov	r8,r0
8000b51c:	e0 0a 02 4a 	mul	r10,r0,r10
8000b520:	14 33       	cp.w	r3,r10
8000b522:	c0 82       	brcc	8000b532 <__avr32_udiv64+0x8e>
8000b524:	20 18       	sub	r8,1
8000b526:	18 03       	add	r3,r12
8000b528:	18 33       	cp.w	r3,r12
8000b52a:	c0 43       	brcs	8000b532 <__avr32_udiv64+0x8e>
8000b52c:	14 33       	cp.w	r3,r10
8000b52e:	f7 b8 03 01 	sublo	r8,1
8000b532:	f1 e9 11 08 	or	r8,r8,r9<<0x10
8000b536:	cd f8       	rjmp	8000b6f4 <__avr32_udiv64+0x250>
8000b538:	58 08       	cp.w	r8,0
8000b53a:	c0 51       	brne	8000b544 <__avr32_udiv64+0xa0>
8000b53c:	30 19       	mov	r9,1
8000b53e:	f2 08 0d 08 	divu	r8,r9,r8
8000b542:	10 9c       	mov	r12,r8
8000b544:	f8 06 12 00 	clz	r6,r12
8000b548:	c0 41       	brne	8000b550 <__avr32_udiv64+0xac>
8000b54a:	18 1b       	sub	r11,r12
8000b54c:	30 19       	mov	r9,1
8000b54e:	c4 08       	rjmp	8000b5ce <__avr32_udiv64+0x12a>
8000b550:	ec 01 11 20 	rsub	r1,r6,32
8000b554:	f4 01 0a 49 	lsr	r9,r10,r1
8000b558:	f8 06 09 4c 	lsl	r12,r12,r6
8000b55c:	f6 06 09 48 	lsl	r8,r11,r6
8000b560:	f6 01 0a 41 	lsr	r1,r11,r1
8000b564:	f3 e8 10 08 	or	r8,r9,r8
8000b568:	f8 03 16 10 	lsr	r3,r12,0x10
8000b56c:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b570:	e2 03 0d 00 	divu	r0,r1,r3
8000b574:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b578:	00 9e       	mov	lr,r0
8000b57a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b57e:	e0 05 02 49 	mul	r9,r0,r5
8000b582:	12 3b       	cp.w	r11,r9
8000b584:	c0 a2       	brcc	8000b598 <__avr32_udiv64+0xf4>
8000b586:	20 1e       	sub	lr,1
8000b588:	18 0b       	add	r11,r12
8000b58a:	18 3b       	cp.w	r11,r12
8000b58c:	c0 63       	brcs	8000b598 <__avr32_udiv64+0xf4>
8000b58e:	12 3b       	cp.w	r11,r9
8000b590:	f7 be 03 01 	sublo	lr,1
8000b594:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b598:	12 1b       	sub	r11,r9
8000b59a:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
8000b59e:	f6 03 0d 02 	divu	r2,r11,r3
8000b5a2:	f1 e3 11 08 	or	r8,r8,r3<<0x10
8000b5a6:	04 99       	mov	r9,r2
8000b5a8:	e4 05 02 4b 	mul	r11,r2,r5
8000b5ac:	16 38       	cp.w	r8,r11
8000b5ae:	c0 a2       	brcc	8000b5c2 <__avr32_udiv64+0x11e>
8000b5b0:	20 19       	sub	r9,1
8000b5b2:	18 08       	add	r8,r12
8000b5b4:	18 38       	cp.w	r8,r12
8000b5b6:	c0 63       	brcs	8000b5c2 <__avr32_udiv64+0x11e>
8000b5b8:	16 38       	cp.w	r8,r11
8000b5ba:	f7 b9 03 01 	sublo	r9,1
8000b5be:	f1 dc e3 08 	addcs	r8,r8,r12
8000b5c2:	f4 06 09 43 	lsl	r3,r10,r6
8000b5c6:	f0 0b 01 0b 	sub	r11,r8,r11
8000b5ca:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000b5ce:	f8 06 16 10 	lsr	r6,r12,0x10
8000b5d2:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
8000b5d6:	f6 06 0d 00 	divu	r0,r11,r6
8000b5da:	e6 0b 16 10 	lsr	r11,r3,0x10
8000b5de:	00 9a       	mov	r10,r0
8000b5e0:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b5e4:	e0 0e 02 48 	mul	r8,r0,lr
8000b5e8:	10 3b       	cp.w	r11,r8
8000b5ea:	c0 a2       	brcc	8000b5fe <__avr32_udiv64+0x15a>
8000b5ec:	20 1a       	sub	r10,1
8000b5ee:	18 0b       	add	r11,r12
8000b5f0:	18 3b       	cp.w	r11,r12
8000b5f2:	c0 63       	brcs	8000b5fe <__avr32_udiv64+0x15a>
8000b5f4:	10 3b       	cp.w	r11,r8
8000b5f6:	f7 ba 03 01 	sublo	r10,1
8000b5fa:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b5fe:	f6 08 01 01 	sub	r1,r11,r8
8000b602:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
8000b606:	e2 06 0d 00 	divu	r0,r1,r6
8000b60a:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000b60e:	00 98       	mov	r8,r0
8000b610:	e0 0e 02 4b 	mul	r11,r0,lr
8000b614:	16 33       	cp.w	r3,r11
8000b616:	c0 82       	brcc	8000b626 <__avr32_udiv64+0x182>
8000b618:	20 18       	sub	r8,1
8000b61a:	18 03       	add	r3,r12
8000b61c:	18 33       	cp.w	r3,r12
8000b61e:	c0 43       	brcs	8000b626 <__avr32_udiv64+0x182>
8000b620:	16 33       	cp.w	r3,r11
8000b622:	f7 b8 03 01 	sublo	r8,1
8000b626:	f1 ea 11 08 	or	r8,r8,r10<<0x10
8000b62a:	c6 98       	rjmp	8000b6fc <__avr32_udiv64+0x258>
8000b62c:	16 39       	cp.w	r9,r11
8000b62e:	e0 8b 00 65 	brhi	8000b6f8 <__avr32_udiv64+0x254>
8000b632:	f2 09 12 00 	clz	r9,r9
8000b636:	c0 b1       	brne	8000b64c <__avr32_udiv64+0x1a8>
8000b638:	10 3a       	cp.w	r10,r8
8000b63a:	5f 2a       	srhs	r10
8000b63c:	1c 3b       	cp.w	r11,lr
8000b63e:	5f b8       	srhi	r8
8000b640:	10 4a       	or	r10,r8
8000b642:	f2 0a 18 00 	cp.b	r10,r9
8000b646:	c5 90       	breq	8000b6f8 <__avr32_udiv64+0x254>
8000b648:	30 18       	mov	r8,1
8000b64a:	c5 98       	rjmp	8000b6fc <__avr32_udiv64+0x258>
8000b64c:	f0 09 09 46 	lsl	r6,r8,r9
8000b650:	f2 03 11 20 	rsub	r3,r9,32
8000b654:	fc 09 09 4e 	lsl	lr,lr,r9
8000b658:	f0 03 0a 48 	lsr	r8,r8,r3
8000b65c:	f6 09 09 4c 	lsl	r12,r11,r9
8000b660:	f4 03 0a 42 	lsr	r2,r10,r3
8000b664:	ef 46 ff f4 	st.w	r7[-12],r6
8000b668:	f6 03 0a 43 	lsr	r3,r11,r3
8000b66c:	18 42       	or	r2,r12
8000b66e:	f1 ee 10 0c 	or	r12,r8,lr
8000b672:	f8 01 16 10 	lsr	r1,r12,0x10
8000b676:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b67a:	e6 01 0d 04 	divu	r4,r3,r1
8000b67e:	e4 03 16 10 	lsr	r3,r2,0x10
8000b682:	08 9e       	mov	lr,r4
8000b684:	e7 e5 11 03 	or	r3,r3,r5<<0x10
8000b688:	e8 06 02 48 	mul	r8,r4,r6
8000b68c:	10 33       	cp.w	r3,r8
8000b68e:	c0 a2       	brcc	8000b6a2 <__avr32_udiv64+0x1fe>
8000b690:	20 1e       	sub	lr,1
8000b692:	18 03       	add	r3,r12
8000b694:	18 33       	cp.w	r3,r12
8000b696:	c0 63       	brcs	8000b6a2 <__avr32_udiv64+0x1fe>
8000b698:	10 33       	cp.w	r3,r8
8000b69a:	f7 be 03 01 	sublo	lr,1
8000b69e:	e7 dc e3 03 	addcs	r3,r3,r12
8000b6a2:	10 13       	sub	r3,r8
8000b6a4:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000b6a8:	e6 01 0d 00 	divu	r0,r3,r1
8000b6ac:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b6b0:	00 98       	mov	r8,r0
8000b6b2:	e0 06 02 46 	mul	r6,r0,r6
8000b6b6:	0c 3b       	cp.w	r11,r6
8000b6b8:	c0 a2       	brcc	8000b6cc <__avr32_udiv64+0x228>
8000b6ba:	20 18       	sub	r8,1
8000b6bc:	18 0b       	add	r11,r12
8000b6be:	18 3b       	cp.w	r11,r12
8000b6c0:	c0 63       	brcs	8000b6cc <__avr32_udiv64+0x228>
8000b6c2:	0c 3b       	cp.w	r11,r6
8000b6c4:	f7 dc e3 0b 	addcs	r11,r11,r12
8000b6c8:	f7 b8 03 01 	sublo	r8,1
8000b6cc:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000b6d0:	ee f4 ff f4 	ld.w	r4,r7[-12]
8000b6d4:	0c 1b       	sub	r11,r6
8000b6d6:	f0 04 06 42 	mulu.d	r2,r8,r4
8000b6da:	06 95       	mov	r5,r3
8000b6dc:	16 35       	cp.w	r5,r11
8000b6de:	e0 8b 00 0a 	brhi	8000b6f2 <__avr32_udiv64+0x24e>
8000b6e2:	5f 0b       	sreq	r11
8000b6e4:	f4 09 09 49 	lsl	r9,r10,r9
8000b6e8:	12 32       	cp.w	r2,r9
8000b6ea:	5f b9       	srhi	r9
8000b6ec:	f7 e9 00 09 	and	r9,r11,r9
8000b6f0:	c0 60       	breq	8000b6fc <__avr32_udiv64+0x258>
8000b6f2:	20 18       	sub	r8,1
8000b6f4:	30 09       	mov	r9,0
8000b6f6:	c0 38       	rjmp	8000b6fc <__avr32_udiv64+0x258>
8000b6f8:	30 09       	mov	r9,0
8000b6fa:	12 98       	mov	r8,r9
8000b6fc:	10 9a       	mov	r10,r8
8000b6fe:	12 93       	mov	r3,r9
8000b700:	10 92       	mov	r2,r8
8000b702:	12 9b       	mov	r11,r9
8000b704:	2f dd       	sub	sp,-12
8000b706:	d8 32       	popm	r0-r7,pc

8000b708 <__avr32_umod64>:
8000b708:	d4 31       	pushm	r0-r7,lr
8000b70a:	1a 97       	mov	r7,sp
8000b70c:	20 3d       	sub	sp,12
8000b70e:	10 9c       	mov	r12,r8
8000b710:	12 95       	mov	r5,r9
8000b712:	14 9e       	mov	lr,r10
8000b714:	16 91       	mov	r1,r11
8000b716:	16 96       	mov	r6,r11
8000b718:	58 09       	cp.w	r9,0
8000b71a:	e0 81 00 81 	brne	8000b81c <__avr32_umod64+0x114>
8000b71e:	16 38       	cp.w	r8,r11
8000b720:	e0 88 00 12 	brls	8000b744 <__avr32_umod64+0x3c>
8000b724:	f0 08 12 00 	clz	r8,r8
8000b728:	c4 e0       	breq	8000b7c4 <__avr32_umod64+0xbc>
8000b72a:	f6 08 09 46 	lsl	r6,r11,r8
8000b72e:	f8 08 09 4c 	lsl	r12,r12,r8
8000b732:	f0 0b 11 20 	rsub	r11,r8,32
8000b736:	f4 08 09 4e 	lsl	lr,r10,r8
8000b73a:	f4 0b 0a 4b 	lsr	r11,r10,r11
8000b73e:	f7 e6 10 06 	or	r6,r11,r6
8000b742:	c4 18       	rjmp	8000b7c4 <__avr32_umod64+0xbc>
8000b744:	58 08       	cp.w	r8,0
8000b746:	c0 51       	brne	8000b750 <__avr32_umod64+0x48>
8000b748:	30 19       	mov	r9,1
8000b74a:	f2 08 0d 08 	divu	r8,r9,r8
8000b74e:	10 9c       	mov	r12,r8
8000b750:	f8 08 12 00 	clz	r8,r12
8000b754:	c0 31       	brne	8000b75a <__avr32_umod64+0x52>
8000b756:	18 16       	sub	r6,r12
8000b758:	c3 68       	rjmp	8000b7c4 <__avr32_umod64+0xbc>
8000b75a:	f0 03 11 20 	rsub	r3,r8,32
8000b75e:	f4 03 0a 4b 	lsr	r11,r10,r3
8000b762:	f8 08 09 4c 	lsl	r12,r12,r8
8000b766:	ec 08 09 49 	lsl	r9,r6,r8
8000b76a:	ec 03 0a 43 	lsr	r3,r6,r3
8000b76e:	f7 e9 10 09 	or	r9,r11,r9
8000b772:	f8 05 16 10 	lsr	r5,r12,0x10
8000b776:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
8000b77a:	e6 05 0d 02 	divu	r2,r3,r5
8000b77e:	f2 0e 16 10 	lsr	lr,r9,0x10
8000b782:	ec 02 02 4b 	mul	r11,r6,r2
8000b786:	fd e3 11 0e 	or	lr,lr,r3<<0x10
8000b78a:	16 3e       	cp.w	lr,r11
8000b78c:	c0 72       	brcc	8000b79a <__avr32_umod64+0x92>
8000b78e:	18 0e       	add	lr,r12
8000b790:	18 3e       	cp.w	lr,r12
8000b792:	c0 43       	brcs	8000b79a <__avr32_umod64+0x92>
8000b794:	16 3e       	cp.w	lr,r11
8000b796:	fd dc e3 0e 	addcs	lr,lr,r12
8000b79a:	fc 0b 01 03 	sub	r3,lr,r11
8000b79e:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000b7a2:	e6 05 0d 02 	divu	r2,r3,r5
8000b7a6:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b7aa:	a5 36       	mul	r6,r2
8000b7ac:	0c 39       	cp.w	r9,r6
8000b7ae:	c0 72       	brcc	8000b7bc <__avr32_umod64+0xb4>
8000b7b0:	18 09       	add	r9,r12
8000b7b2:	18 39       	cp.w	r9,r12
8000b7b4:	c0 43       	brcs	8000b7bc <__avr32_umod64+0xb4>
8000b7b6:	0c 39       	cp.w	r9,r6
8000b7b8:	f3 dc e3 09 	addcs	r9,r9,r12
8000b7bc:	f2 06 01 06 	sub	r6,r9,r6
8000b7c0:	f4 08 09 4e 	lsl	lr,r10,r8
8000b7c4:	f8 0a 16 10 	lsr	r10,r12,0x10
8000b7c8:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
8000b7cc:	ec 0a 0d 02 	divu	r2,r6,r10
8000b7d0:	fc 09 16 10 	lsr	r9,lr,0x10
8000b7d4:	ea 02 02 4b 	mul	r11,r5,r2
8000b7d8:	f3 e3 11 09 	or	r9,r9,r3<<0x10
8000b7dc:	16 39       	cp.w	r9,r11
8000b7de:	c0 72       	brcc	8000b7ec <__avr32_umod64+0xe4>
8000b7e0:	18 09       	add	r9,r12
8000b7e2:	18 39       	cp.w	r9,r12
8000b7e4:	c0 43       	brcs	8000b7ec <__avr32_umod64+0xe4>
8000b7e6:	16 39       	cp.w	r9,r11
8000b7e8:	f3 dc e3 09 	addcs	r9,r9,r12
8000b7ec:	f2 0b 01 0b 	sub	r11,r9,r11
8000b7f0:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000b7f4:	f6 0a 0d 0a 	divu	r10,r11,r10
8000b7f8:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8000b7fc:	ea 0a 02 4a 	mul	r10,r5,r10
8000b800:	14 3e       	cp.w	lr,r10
8000b802:	c0 72       	brcc	8000b810 <__avr32_umod64+0x108>
8000b804:	18 0e       	add	lr,r12
8000b806:	18 3e       	cp.w	lr,r12
8000b808:	c0 43       	brcs	8000b810 <__avr32_umod64+0x108>
8000b80a:	14 3e       	cp.w	lr,r10
8000b80c:	fd dc e3 0e 	addcs	lr,lr,r12
8000b810:	fc 0a 01 0a 	sub	r10,lr,r10
8000b814:	30 0b       	mov	r11,0
8000b816:	f4 08 0a 4a 	lsr	r10,r10,r8
8000b81a:	c7 b8       	rjmp	8000b910 <__avr32_umod64+0x208>
8000b81c:	16 39       	cp.w	r9,r11
8000b81e:	e0 8b 00 79 	brhi	8000b910 <__avr32_umod64+0x208>
8000b822:	f2 09 12 00 	clz	r9,r9
8000b826:	c1 21       	brne	8000b84a <__avr32_umod64+0x142>
8000b828:	10 3a       	cp.w	r10,r8
8000b82a:	5f 2b       	srhs	r11
8000b82c:	0a 31       	cp.w	r1,r5
8000b82e:	5f ba       	srhi	r10
8000b830:	f7 ea 10 0a 	or	r10,r11,r10
8000b834:	f2 0a 18 00 	cp.b	r10,r9
8000b838:	c0 60       	breq	8000b844 <__avr32_umod64+0x13c>
8000b83a:	fc 08 01 0c 	sub	r12,lr,r8
8000b83e:	e2 05 01 46 	sbc	r6,r1,r5
8000b842:	18 9e       	mov	lr,r12
8000b844:	0c 9b       	mov	r11,r6
8000b846:	1c 9a       	mov	r10,lr
8000b848:	c6 48       	rjmp	8000b910 <__avr32_umod64+0x208>
8000b84a:	ea 09 09 4c 	lsl	r12,r5,r9
8000b84e:	f2 06 11 20 	rsub	r6,r9,32
8000b852:	f6 09 09 4b 	lsl	r11,r11,r9
8000b856:	f0 09 09 42 	lsl	r2,r8,r9
8000b85a:	ef 46 ff f4 	st.w	r7[-12],r6
8000b85e:	f0 06 0a 48 	lsr	r8,r8,r6
8000b862:	18 48       	or	r8,r12
8000b864:	e2 06 0a 4c 	lsr	r12,r1,r6
8000b868:	f4 09 09 43 	lsl	r3,r10,r9
8000b86c:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
8000b870:	f4 06 0a 4a 	lsr	r10,r10,r6
8000b874:	16 4a       	or	r10,r11
8000b876:	f0 0b 16 10 	lsr	r11,r8,0x10
8000b87a:	f8 0b 0d 04 	divu	r4,r12,r11
8000b87e:	f4 0c 16 10 	lsr	r12,r10,0x10
8000b882:	08 91       	mov	r1,r4
8000b884:	f9 e5 11 0c 	or	r12,r12,r5<<0x10
8000b888:	e8 0e 02 46 	mul	r6,r4,lr
8000b88c:	0c 3c       	cp.w	r12,r6
8000b88e:	c0 a2       	brcc	8000b8a2 <__avr32_umod64+0x19a>
8000b890:	20 11       	sub	r1,1
8000b892:	10 0c       	add	r12,r8
8000b894:	10 3c       	cp.w	r12,r8
8000b896:	c0 63       	brcs	8000b8a2 <__avr32_umod64+0x19a>
8000b898:	0c 3c       	cp.w	r12,r6
8000b89a:	f7 b1 03 01 	sublo	r1,1
8000b89e:	f9 d8 e3 0c 	addcs	r12,r12,r8
8000b8a2:	0c 1c       	sub	r12,r6
8000b8a4:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8000b8a8:	f8 0b 0d 04 	divu	r4,r12,r11
8000b8ac:	f5 e5 11 0b 	or	r11,r10,r5<<0x10
8000b8b0:	08 96       	mov	r6,r4
8000b8b2:	e8 0e 02 4e 	mul	lr,r4,lr
8000b8b6:	1c 3b       	cp.w	r11,lr
8000b8b8:	c0 a2       	brcc	8000b8cc <__avr32_umod64+0x1c4>
8000b8ba:	20 16       	sub	r6,1
8000b8bc:	10 0b       	add	r11,r8
8000b8be:	10 3b       	cp.w	r11,r8
8000b8c0:	c0 63       	brcs	8000b8cc <__avr32_umod64+0x1c4>
8000b8c2:	1c 3b       	cp.w	r11,lr
8000b8c4:	f7 b6 03 01 	sublo	r6,1
8000b8c8:	f7 d8 e3 0b 	addcs	r11,r11,r8
8000b8cc:	ed e1 11 01 	or	r1,r6,r1<<0x10
8000b8d0:	1c 1b       	sub	r11,lr
8000b8d2:	e2 02 06 40 	mulu.d	r0,r1,r2
8000b8d6:	00 9e       	mov	lr,r0
8000b8d8:	02 9c       	mov	r12,r1
8000b8da:	16 3c       	cp.w	r12,r11
8000b8dc:	e0 8b 00 08 	brhi	8000b8ec <__avr32_umod64+0x1e4>
8000b8e0:	5f 06       	sreq	r6
8000b8e2:	06 30       	cp.w	r0,r3
8000b8e4:	5f ba       	srhi	r10
8000b8e6:	ed ea 00 0a 	and	r10,r6,r10
8000b8ea:	c0 60       	breq	8000b8f6 <__avr32_umod64+0x1ee>
8000b8ec:	fc 02 01 04 	sub	r4,lr,r2
8000b8f0:	f8 08 01 4c 	sbc	r12,r12,r8
8000b8f4:	08 9e       	mov	lr,r4
8000b8f6:	e6 0e 01 0a 	sub	r10,r3,lr
8000b8fa:	f6 0c 01 4c 	sbc	r12,r11,r12
8000b8fe:	ee f1 ff f4 	ld.w	r1,r7[-12]
8000b902:	f8 09 0a 4b 	lsr	r11,r12,r9
8000b906:	f4 09 0a 4a 	lsr	r10,r10,r9
8000b90a:	f8 01 09 4c 	lsl	r12,r12,r1
8000b90e:	18 4a       	or	r10,r12
8000b910:	2f dd       	sub	sp,-12
8000b912:	d8 32       	popm	r0-r7,pc

Disassembly of section .exception:

8000ba00 <_evba>:
_evba:

        .org  0x000
        // Unrecoverable Exception.
_handle_Unrecoverable_Exception:
        rjmp $
8000ba00:	c0 08       	rjmp	8000ba00 <_evba>
	...

8000ba04 <_handle_TLB_Multiple_Hit>:

        .org  0x004
        // TLB Multiple Hit: UNUSED IN AVR32UC.
_handle_TLB_Multiple_Hit:
        rjmp $
8000ba04:	c0 08       	rjmp	8000ba04 <_handle_TLB_Multiple_Hit>
	...

8000ba08 <_handle_Bus_Error_Data_Fetch>:

        .org  0x008
        // Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
        rjmp $
8000ba08:	c0 08       	rjmp	8000ba08 <_handle_Bus_Error_Data_Fetch>
	...

8000ba0c <_handle_Bus_Error_Instruction_Fetch>:

        .org  0x00C
         // Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
        rjmp $
8000ba0c:	c0 08       	rjmp	8000ba0c <_handle_Bus_Error_Instruction_Fetch>
	...

8000ba10 <_handle_NMI>:

        .org  0x010
        // NMI.
_handle_NMI:
        rjmp $
8000ba10:	c0 08       	rjmp	8000ba10 <_handle_NMI>
	...

8000ba14 <_handle_Instruction_Address>:

        .org  0x014
        // Instruction Address.
_handle_Instruction_Address:
        rjmp $
8000ba14:	c0 08       	rjmp	8000ba14 <_handle_Instruction_Address>
	...

8000ba18 <_handle_ITLB_Protection>:

        .org  0x018
        // ITLB Protection.
_handle_ITLB_Protection:
        rjmp $
8000ba18:	c0 08       	rjmp	8000ba18 <_handle_ITLB_Protection>
	...

8000ba1c <_handle_Breakpoint>:

        .org  0x01C
        // Breakpoint.
_handle_Breakpoint:
        rjmp $
8000ba1c:	c0 08       	rjmp	8000ba1c <_handle_Breakpoint>
	...

8000ba20 <_handle_Illegal_Opcode>:

        .org  0x020
        // Illegal Opcode.
_handle_Illegal_Opcode:
        rjmp $
8000ba20:	c0 08       	rjmp	8000ba20 <_handle_Illegal_Opcode>
	...

8000ba24 <_handle_Unimplemented_Instruction>:

        .org  0x024
        // Unimplemented Instruction.
_handle_Unimplemented_Instruction:
        rjmp $
8000ba24:	c0 08       	rjmp	8000ba24 <_handle_Unimplemented_Instruction>
	...

8000ba28 <_handle_Privilege_Violation>:

        .org  0x028
        // Privilege Violation.
_handle_Privilege_Violation:
        rjmp $
8000ba28:	c0 08       	rjmp	8000ba28 <_handle_Privilege_Violation>
	...

8000ba2c <_handle_Floating_Point>:

        .org  0x02C
        // Floating-Point: UNUSED IN AVR32UC.
_handle_Floating_Point:
        rjmp $
8000ba2c:	c0 08       	rjmp	8000ba2c <_handle_Floating_Point>
	...

8000ba30 <_handle_Coprocessor_Absent>:

        .org  0x030
        // Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
        rjmp $
8000ba30:	c0 08       	rjmp	8000ba30 <_handle_Coprocessor_Absent>
	...

8000ba34 <_handle_Data_Address_Read>:

        .org  0x034
        // Data Address (Read).
_handle_Data_Address_Read:
        rjmp $
8000ba34:	c0 08       	rjmp	8000ba34 <_handle_Data_Address_Read>
	...

8000ba38 <_handle_Data_Address_Write>:

        .org  0x038
        // Data Address (Write).
_handle_Data_Address_Write:
        rjmp $
8000ba38:	c0 08       	rjmp	8000ba38 <_handle_Data_Address_Write>
	...

8000ba3c <_handle_DTLB_Protection_Read>:

        .org  0x03C
        // DTLB Protection (Read).
_handle_DTLB_Protection_Read:
        rjmp $
8000ba3c:	c0 08       	rjmp	8000ba3c <_handle_DTLB_Protection_Read>
	...

8000ba40 <_handle_DTLB_Protection_Write>:

        .org  0x040
        // DTLB Protection (Write).
_handle_DTLB_Protection_Write:
        rjmp $
8000ba40:	c0 08       	rjmp	8000ba40 <_handle_DTLB_Protection_Write>
	...

8000ba44 <_handle_DTLB_Modified>:

        .org  0x044
        // DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
        rjmp $
8000ba44:	c0 08       	rjmp	8000ba44 <_handle_DTLB_Modified>
	...

8000ba50 <_handle_ITLB_Miss>:

        .org  0x050
        // ITLB Miss: UNUSED IN AVR32UC.
_handle_ITLB_Miss:
        rjmp $
8000ba50:	c0 08       	rjmp	8000ba50 <_handle_ITLB_Miss>
	...

8000ba60 <_handle_DTLB_Miss_Read>:

        .org  0x060
        // DTLB Miss (Read): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Read:
        rjmp $
8000ba60:	c0 08       	rjmp	8000ba60 <_handle_DTLB_Miss_Read>
	...

8000ba70 <_handle_DTLB_Miss_Write>:

        .org  0x070
        // DTLB Miss (Write): UNUSED IN AVR32UC.
_handle_DTLB_Miss_Write:
        rjmp $
8000ba70:	c0 08       	rjmp	8000ba70 <_handle_DTLB_Miss_Write>
	...

8000bb00 <_handle_Supervisor_Call>:

        .org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
8000bb00:	fe cf 6e 88 	sub	pc,pc,28296

8000bb04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
8000bb04:	30 0c       	mov	r12,0
8000bb06:	fe b0 c4 1f 	rcall	80004344 <_get_interrupt_handler>
8000bb0a:	58 0c       	cp.w	r12,0
8000bb0c:	f8 0f 17 10 	movne	pc,r12
8000bb10:	d6 03       	rete

8000bb12 <_int1>:
8000bb12:	30 1c       	mov	r12,1
8000bb14:	fe b0 c4 18 	rcall	80004344 <_get_interrupt_handler>
8000bb18:	58 0c       	cp.w	r12,0
8000bb1a:	f8 0f 17 10 	movne	pc,r12
8000bb1e:	d6 03       	rete

8000bb20 <_int2>:
8000bb20:	30 2c       	mov	r12,2
8000bb22:	fe b0 c4 11 	rcall	80004344 <_get_interrupt_handler>
8000bb26:	58 0c       	cp.w	r12,0
8000bb28:	f8 0f 17 10 	movne	pc,r12
8000bb2c:	d6 03       	rete

8000bb2e <_int3>:
8000bb2e:	30 3c       	mov	r12,3
8000bb30:	fe b0 c4 0a 	rcall	80004344 <_get_interrupt_handler>
8000bb34:	58 0c       	cp.w	r12,0
8000bb36:	f8 0f 17 10 	movne	pc,r12
8000bb3a:	d6 03       	rete

8000bb3c <ipr_val>:
8000bb3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
8000bb4c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb5c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb6c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb7c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb8c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bb9c:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbac:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbbc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbcc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbdc:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbec:	d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03 d7 03     ................
8000bbfc:	d7 03 d7 03                                         ....
