/*
 * timer.c
 *
 * Created: 2016/3/15 14:06:41
 *  Author: JHDEV2
 */ 
#include "timer.h"
#include "gpio.h"
#include <stdbool.h>

#include "conf_example.h"
#include "tc.h"

#include "intc.h"

#include "../log/log.h"

//#include "Interface/xcmp.h"


volatile U32 tc_tick = 0;

//brief Default interrupt handler.
__attribute__((__interrupt__))
static void _tc_interrupt(void)
 {
	// Increment the 200ms seconds counter
	tc_tick++;
	/*
	 * TODO: Place a breakpoint here and watch the update of tc_tick variable
	 * in the Watch Window.
	 */
	// Clear the interrupt flag. This is a side effect of reading the TC SR.
	tc_read_sr(EXAMPLE_TC, EXAMPLE_TC_CHANNEL);
	
}

//All calculations in this function suppose that the Osc0 frequency is 12MHz.
//The oscillators are disabled by default after reset.The oscillators can be enabled by writing to
//the OSCnEN bits in MCCTRL. Operation mode (external clock or crystal) is chosen by writing to
//the MODE field in OSCCTRLn. [12.5.2]
//The SSC clock is generated by the power manager. Before using the SSC, the programmer
//must ensure that the SSC clock is enabled in the power manager.
//In the SSC description, Master Clock (MCK) is the bus clock of the peripheral bus to which the
//SSC is connected. [23.6.2]
//Switch to clock Osc0 (crystal)
//start PLL0 and switch main clock to PLL0 output
void local_start_pll0(void)
{
/****
	
	//pm_switch_to_osc0(pm, 12000000, 3);
	//    pm_enable_osc0_crystal(pm, 12000000);
	//         pm_set_osc0_mode(pm,AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);  0x00000007
	//    pm_enable_clk0(pm, 3);
	//         pm_enable_clk0_no_wait(pm, 3);
	(&AVR32_PM)->oscctrl0 = 0x00000307;
	(&AVR32_PM)->mcctrl   = 0x00000004;
	//         pm_wait_for_clk0_ready(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
	//    pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);
	(&AVR32_PM)->mcctrl   = 0x00000005;

	//pm_pll_setup(pm,
	//               0,   // use PLL0
	//               7,   // MUL=7 in the formula
	//               1,   // DIV=1 in the formula
	//               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	//               16); // lockcount in main clock for the PLL wait lock
	//pm_pll_set_option(pm, 0, //PLL number 0
	//                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	//                        1, //div2 Divide the PLL output frequency by 2
	//                        0);//0 to enable the Wide-Bandith Mode
	//pm_pll_enable(pm,0);
	(&AVR32_PM)->pll[0] = 0x1007010D;


	//pm_wait_for_pll0_locked(pm);
	while (!((&AVR32_PM)->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));

	//pm_cksel(pm, 1,  //Bus A clock divisor enable = 1
	//             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	//             0,  //B clock divisor enable = 0
	//             0,  //Bus B select = 0
	//             0,  //HS Bus clock divisor enable = 0
	//             0); //HS Bus select = 0
	(&AVR32_PM)->cksel = 0x00800000;

	//flashc_set_wait_state(1);
	AVR32_FLASHC.fcr = 0x00000040;

	//pm_switch_to_clock(pm, AVR32_PM_MCSEL_PLL0);
	(&AVR32_PM)->mcctrl   = 0x00000006;


	AVR32_HMATRIX.mcfg[AVR32_HMATRIX_MASTER_CPU_INSTRUCTION] = 0x1;
	
***/
	
/*****/
	pm_switch_to_osc0(&AVR32_PM, 12000000, OSC0_STARTUP);

	pm_pll_setup(&AVR32_PM,
	               0,   // use PLL0
	               7,   // MUL=7 in the formula
	               1,   // DIV=1 in the formula
	               0,   // Sel Osc0/PLL0 or Osc1/PLL1
	               16); // lockcount in main clock for the PLL wait lock
	pm_pll_set_option(&AVR32_PM, 0, //PLL number 0
	                        1, //freq Set to 1 for VCO frequency range 80-180MHz
	                        1, //div2 Divide the PLL output frequency by 2
	                        0);//0 to enable the Wide-Bandith Mode
	pm_pll_enable(&AVR32_PM,0);


	pm_wait_for_pll0_locked(&AVR32_PM);


	pm_cksel(&AVR32_PM, 1,  //Bus A clock divisor enable = 1
	             0,  //Bus A select = 0 (PBA clock = 48MHz/2 = 24MHz).
	             0,  //B clock divisor enable = 0
	             0,  //Bus B select = 0
	             0,  //HS Bus clock divisor enable = 0
	             0); //HS Bus select = 0
				 
	flashc_set_wait_state(1);
	//AVR32_FLASHC.fcr = 0x00000040;

	pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCSEL_PLL0);
/****/
}



//	SSC Related I/O
//	MAKO_DCLK				AVR32_SSC_TX_CLOCK_0_PIN		NU	[41 PortB Pin  9 00000200 Func 0]
//							AVR32_SSC_RX_CLOCK_0_PIN			[38 PortB Pin  6 00000040 Func 0]
//	Timer Clk				AVR32_TC_CLK0_0_1_PIN				[20 PortA Pin 20 00100000 Func 1]
//	MAKO_FSYNC				AVR32_SSC_TX_FRAME_SYNC_0_PIN		[43 PortB Pin 11 00000800 Func 0]
//							AVR32_SSC_RX_FRAME_SYNC_0_PIN		[40 PortB Pin  8 00000100 Func 0]
//	Timer Sync				AVR32_TC_B0_0_0_PIN					[33 PortB Pin  1 00000002 Func 0]
//	SSC_TX_DATA_ENABLE		AVR32_TC_A0_0_0_PIN					[32 PortB Pin  0 00000001 Func 0]
//	MAKO_TX					AVR32_SSC_TX_DATA_0_PIN				[42 PortB Pin 10 00000400 Func 0]
//	MAKO_RX					AVR32_SSC_RX_DATA_0_PIN				[39 PortB Pin  7 00000080 Func 0]
//
void local_start_timer(void)
{
	////Route CLK to Timer
	//AVR32_GPIO.port[0].pmr0s = 0x00100000;
	//AVR32_GPIO.port[0].pmr1c = 0x00100000;
	//AVR32_GPIO.port[0].gperc = 0x00100000;
	////Route FS and Tri-State to Timer.
	//AVR32_GPIO.port[1].pmr0c = 0x00000003;
	//AVR32_GPIO.port[1].pmr1c = 0x00000003;
	//AVR32_GPIO.port[1].gperc = 0x00000003;
	
	static const gpio_map_t TC_GPIO_MAP =
	{
		{TIMER_TC_CLK_PIN,      TIMER_TC_CLK_FUNCTION     },
		{TIMER_TC_FS_PIN,       TIMER_TC_FS_FUNCTION      },
		{TIMER_EN_CLK_PIN,      TIMER_EN_CLK_FUNCTION     }
	};
	gpio_enable_module(TC_GPIO_MAP, sizeof(TC_GPIO_MAP) / sizeof(TC_GPIO_MAP[0]));

	(&AVR32_TC)->channel[0].cmr =
	AVR32_TC_BSWTRG_NONE       << AVR32_TC_BSWTRG_OFFSET   |
	AVR32_TC_BEEVT_NONE        << AVR32_TC_BEEVT_OFFSET    |
	AVR32_TC_BCPC_NONE         << AVR32_TC_BCPC_OFFSET     |
	AVR32_TC_BCPB_NONE         << AVR32_TC_BCPB_OFFSET     |
	AVR32_TC_ASWTRG_SET        << AVR32_TC_ASWTRG_OFFSET   |
	AVR32_TC_AEEVT_SET         << AVR32_TC_AEEVT_OFFSET    |
	AVR32_TC_ACPC_NONE         << AVR32_TC_ACPC_OFFSET     |
	AVR32_TC_ACPA_CLEAR        << AVR32_TC_ACPA_OFFSET     |
	1                          << AVR32_TC_WAVE_OFFSET     |
	AVR32_TC_WAVSEL_UP_NO_AUTO << AVR32_TC_WAVSEL_OFFSET   |
	1                          << AVR32_TC_ENETRG_OFFSET   |
	AVR32_TC_EEVT_TIOB_INPUT   << AVR32_TC_EEVT_OFFSET     |
	AVR32_TC_EEVTEDG_POS_EDGE  << AVR32_TC_EEVTEDG_OFFSET  |
	0                          << AVR32_TC_CPCDIS_OFFSET   |
	0                          << AVR32_TC_CPCSTOP_OFFSET  |
	AVR32_TC_BURST_NOT_GATED   << AVR32_TC_BURST_OFFSET    |
	1                          << AVR32_TC_CLKI_OFFSET     |
	AVR32_TC_TCCLKS_XC0        << AVR32_TC_TCCLKS_OFFSET;



	(&AVR32_TC)->channel[0].ra = 32;
	(&AVR32_TC)->channel[0].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
}



/**
 * \brief TC Initialization
 *
 * Initializes and start the TC module with the following:
 * - Counter in Up mode with automatic reset on RC compare match.
 * - fPBA/8 is used as clock source for TC
 * - Enables RC compare match interrupt
 * \param tc Base address of the TC module
 */
void tc_init()
{

	volatile avr32_tc_t * tc = EXAMPLE_TC;
	
	INTC_register_interrupt(&_tc_interrupt, AVR32_TC_IRQ1, AVR32_INTC_INT2);

	// Options for waveform generation.
	static const tc_waveform_opt_t waveform_opt = {
		// Channel selection.
		.channel  = EXAMPLE_TC_CHANNEL,
		// Software trigger effect on TIOB.
		.bswtrg   = TC_EVT_EFFECT_NOOP,
		// External event effect on TIOB.
		.beevt    = TC_EVT_EFFECT_NOOP,
		// RC compare effect on TIOB.
		.bcpc     = TC_EVT_EFFECT_NOOP,
		// RB compare effect on TIOB.
		.bcpb     = TC_EVT_EFFECT_NOOP,
		// Software trigger effect on TIOA.
		.aswtrg   = TC_EVT_EFFECT_NOOP,
		// External event effect on TIOA.
		.aeevt    = TC_EVT_EFFECT_NOOP,
		// RC compare effect on TIOA.
		.acpc     = TC_EVT_EFFECT_NOOP,
		/* RA compare effect on TIOA.
		 * (other possibilities are none, set and clear).
		 */
		.acpa     = TC_EVT_EFFECT_NOOP,
		/* Waveform selection: Up mode with automatic trigger(reset)
		 * on RC compare.
		 */
		.wavsel   = TC_WAVEFORM_SEL_UP_MODE_RC_TRIGGER,
		// External event trigger enable.
		.enetrg   = false,
		// External event selection.
		.eevt     = 0,
		// External event edge selection.
		.eevtedg  = TC_SEL_NO_EDGE,
		// Counter disable when RC compare.
		.cpcdis   = false,
		// Counter clock stopped with RC compare.
		.cpcstop  = false,
		// Burst signal selection.
		.burst    = false,
		// Clock inversion.
		.clki     = false,
		// Internal source clock 3, connected to fPBA / 8.
		.tcclks   = TC_CLOCK_SOURCE_TC3
	};

	// Options for enabling TC interrupts
	static const tc_interrupt_t tc_interrupt = {
		.etrgs = 0,
		.ldrbs = 0,
		.ldras = 0,
		.cpcs  = 1, // Enable interrupt on RC compare alone
		.cpbs  = 0,
		.cpas  = 0,
		.lovrs = 0,
		.covfs = 0
	};
	// Initialize the timer/counter.
	tc_init_waveform(tc, &waveform_opt);

	/*
	 * Set the compare triggers.
	 * We configure it to count every 1 milliseconds.
	 * We want: (1 / (fPBA / 8)) * RC = 1 ms, hence RC = (fPBA / 8) / 1000
	 * to get an interrupt every 10 ms.
	 */
	
	tc_write_rc(tc, EXAMPLE_TC_CHANNEL, ((FOSC0*2)/8/100));//10ms
	
	// configure the timer interrupt
	tc_configure_interrupts(tc, EXAMPLE_TC_CHANNEL, &tc_interrupt);
	// Start the timer/counter.
	tc_start(tc, EXAMPLE_TC_CHANNEL);
}

void delay_ns(U32 ns)
{
	U32 i;
	for(i=0;i<ns;i++)
	{
		nop();
		nop();
		nop();
	}
}
void delay_us(U32 us)
{
	for(int i =0; i<us; i++){
		delay_ns(1000);
	}

}
void delay_ms(U32 ms)
{
	for(int i =0; i<ms; i++){
		delay_us(1000);
	}
	
}
